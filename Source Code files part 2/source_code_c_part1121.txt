rrentSize = ReqSize;
            }

            if (!SetupGetStringFieldW (&ic, Field, Buffer, CurrentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToStringTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            Data = NULL;
            DataSize = 0;

            if (Callback) {
                rc = Callback (Buffer, &Data, &DataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            rc = pSetupStringTableAddStringEx (
                        Table,
                        Buffer,
                        STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,
                        Data,
                        DataSize
                        );

            if (rc == -1) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (Buffer) {
        PushError();
        MemFree (g_hHeap, 0, Buffer);
        PopError();
    }
    return b;
}
#endif // REMOVED

/*++

Routine Description:

  Finds the last wack in the path and returns a pointer to the next
  character.  If no wack is found, returns a pointer to the full
  string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file name in the path.

--*/

PCSTR
GetFileNameFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;

    p = _mbsrchr (PathSpec, '\\');
    if (p) {
        p = _mbsinc (p);
    } else {
        p = PathSpec;
    }

    return p;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;

    p = wcsrchr (PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}


/*++

Routine Description:

  Finds the last wack in the path and then the last point from the remaining path
  returning a pointer to the next character. If no point is found, returns a null pointer.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, excluding the dot, or NULL if no extension exists.

--*/

PCSTR
GetFileExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p + 1;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    return ReturnPtr;
}


PCWSTR
GetFileExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p + 1;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  GetDotExtensionFromPath finds the last wack in the path and then the last dot from
  the remaining path, returning a pointer to the dot. If no dot is found, returns the
  end of the string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, including the dot, or the end of the string if
  no extension exists.

--*/

PCSTR
GetDotExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


PCWSTR
GetDotExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  CountInstancesOfChar returns the number of occurances Char
  is found in String.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT Count;

    Count = 0;
    while (*String) {
        if (_mbsnextc (String) == Char) {
            Count++;
        }

        String = _mbsinc (String);
    }

    return Count;
}


UINT
CountInstancesOfCharW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT Count;

    Count = 0;
    while (*String) {
        if (*String == Char) {
            Count++;
        }

        String++;
    }

    return Count;
}


/*++

Routine Description:

  CountInstancesOfCharI returns the number of occurances Char
  is found in String.  The comparison is case-insenetive.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharIA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT Count;

    Char = tolower (Char);

    Count = 0;
    while (*String) {
        if ((MBCHAR) tolower (_mbsnextc (String)) == Char) {
            Count++;
        }

        String = _mbsinc (String);
    }

    return Count;
}


UINT
CountInstancesOfCharIW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT Count;

    Char = towlower (Char);

    Count = 0;
    while (*String) {
        if (towlower (*String) == Char) {
            Count++;
        }

        String++;
    }

    return Count;
}


/*++

Routine Description:

  Searches the string counting the number of occurances of
  SearchString exist in SourceString.

Arguments:

  SourceString - Specifies the text that may or may not contain
                 search text

  SearchString - Specifies the text phrase to count

Return Value:

  The number of times SearchString appears in SourceString.

--*/

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT Count;
    UINT SearchBytes;

    Count = 0;
    p = SourceString;
    SearchBytes = ByteCountA (SearchString);

    while (p = _mbsistr (p, SearchString)) {
        Count++;
        p += SearchBytes;
    }

    return Count;
}


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT Count;
    UINT SearchChars;

    Count = 0;
    p = SourceString;
    SearchChars = wcslen (SearchString);

    while (p = _wcsistr (p, SearchString)) {
        Count++;
        p += SearchChars;
    }

    return Count;
}


/*++

Routine Description:

  Searches and replaces all occurances of SearchString with
  ReplaceString.

Arguments:

  SourceString - String that contiains zero or more instances
                 of the search text

  SearchString - String to search for.  Cannot be zero-length or NULL.

  ReplaceString - String to replace.  Can be zero-length but cannot
                  be NULL.

Return Value:

  A pointer to the pool-allocated string, or NULL if no instances
  of SearchString were found in SourceString.  Free the non-NULL
  pointer with FreePathString.

--*/

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    )
{
    PSTR NewString;
    PBYTE p, q;
    PBYTE Dest;
    UINT Count;
    UINT Size;
    UINT SearchBytes;
    UINT ReplaceBytes;
    UINT UntouchedBytes;

    //
    // Count occurances within the string
    //

    Count = CountInstancesOfSubStringA (
                SourceString,
                SearchString
                );

    if (!Count) {
        return NULL;
    }

    SearchBytes = ByteCountA (SearchString);
    ReplaceBytes = ByteCountA (ReplaceString);
    MYASSERT (SearchBytes);

    Size = SizeOfStringA (SourceString) -
           Count * SearchBytes +
           Count * ReplaceBytes;

    NewString = (PSTR) PoolMemGetAlignedMemory (g_PathsPool, Size);
    if (!NewString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    Dest = (PBYTE) NewString;

    while (q = (PBYTE) _mbsistr ((PCSTR) p, SearchString)) {

        UntouchedBytes = q - p;

        if (UntouchedBytes) {
            CopyMemory (Dest, p, UntouchedBytes);
            Dest += UntouchedBytes;
        }

        if (ReplaceBytes) {
            CopyMemory (Dest, (PBYTE) ReplaceString, ReplaceBytes);
            Dest += ReplaceBytes;
        }

        p = q + SearchBytes;
    }

    StringCopyA ((PSTR) Dest, (PSTR) p);

    return NewString;
}


PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    )
{
    PWSTR NewString;
    PBYTE p, q;
    PBYTE Dest;
    UINT Count;
    UINT Size;
    UINT SearchBytes;
    UINT ReplaceBytes;
    UINT UntouchedBytes;

    //
    // Count occurances within the string
    //

    Count = CountInstancesOfSubStringW (
                SourceString,
                SearchString
                );

    if (!Count) {
        return NULL;
    }

    SearchBytes = ByteCountW (SearchString);
    ReplaceBytes = ByteCountW (ReplaceString);
    MYASSERT (SearchBytes);

    Size = SizeOfStringW (SourceString) -
           Count * SearchBytes +
           Count * ReplaceBytes;

    NewString = (PWSTR) PoolMemGetAlignedMemory (g_PathsPool, Size);
    if (!NewString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    Dest = (PBYTE) NewString;

    while (q = (PBYTE) _wcsistr ((PCWSTR) p, SearchString)) {

        UntouchedBytes = q - p;

        if (UntouchedBytes) {
            CopyMemory (Dest, p, UntouchedBytes);
            Dest += UntouchedBytes;
        }

        if (ReplaceBytes) {
            CopyMemory (Dest, (PBYTE) ReplaceString, ReplaceBytes);
            Dest += ReplaceBytes;
        }

        p = q + SearchBytes;
    }

    StringCopyW ((PWSTR) Dest, (PWSTR) p);

    return NewString;
}


PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     INT *NumArgs
    )

/*++

Routine Description:

  CommandLineToArgvA implements an ANSI version of the Win32 function
  CommandLineToArgvW.

Arguments:

  CmdLine   - A pointer to the complete command line, including the
              module name.  This is the same string returned by
              GetCommandLineA().

  NumArgs   - Receives the number of arguments allocated, identical to
              main's argc parameter.  That is, NumArgs is equal to
              the number of command line arguments plus one for the
              command itself.

Return Value:

  A pointer to an array of string pointers, one per argument.  The
  command line arguments are placed in separate nul-terminated strings.
  The caller must free the memory using a single call to GlobalFree or
  LocalFree.

--*/

{
    PCSTR Start, End;
    BOOL QuoteMode;
    MBCHAR ch = 0;
    INT Pass;
    INT ArgStrSize;
    INT Args;
    PSTR ArgStrEnd = NULL;     // filled in on pass one, used on pass two
    PSTR *ArgPtrArray = NULL;  // filled in on pass one, used on pass two

    //
    // Count args on first pass, then allocate memory and create arg string
    //

    ArgStrSize = 0;
    Pass = 0;
    do {
        // Init loop
        Pass++;
        Args = 0;
        Start = CmdLine;

        // Skip leading space
        while (isspace (*Start)) {
            Start++;
        }

        while (*Start) {
            // Look for quote mode
            if (*Start == '\"') {
                QuoteMode = TRUE;
                Start++;
            } else {
                QuoteMode = FALSE;
            }

            // Find end of arg
            End = Start;
            while (*End) {
                ch = _mbsnextc (End);
                if (QuoteMode) {
                    if (ch == '\"') {
                        break;
                    }
                } else {
                    if (isspace (ch)) {
                        break;
                    }
                }

                End = _mbsinc (End);
            }

            // If Pass 1, add string size
            if (Pass == 1) {
                ArgStrSize += (End - Start) + 1;
            }

            // If Pass 2, copy strings to buffer
            else {
                MYASSERT (ArgStrEnd);
                MYASSERT (ArgPtrArray);

                ArgPtrArray[Args] = ArgStrEnd;
                StringCopyABA (ArgStrEnd, Start, End);
                ArgStrEnd = GetEndOfStringA (ArgStrEnd);
                ArgStrEnd++;
            }

            // Set Start to next arg
            Args++;

            if (QuoteMode && ch == '\"') {
                End = _mbsinc (End);
            }

            Start = End;
            while (isspace (*Start)) {
                Start++;
            }
        }

        // If Pass 1, allocate strings
        if (Pass == 1) {
            if (Args) {
                ArgPtrArray = (PSTR *) GlobalAlloc (
                                            GPTR,
                                            sizeof (PSTR) * Args + ArgStrSize
                                            );
                if (!ArgPtrArray) {
                    return NULL;
                }

                ArgStrEnd = (PSTR) (&ArgPtrArray[Args]);
            } else {
                return NULL;
            }
        }
    } while (Pass < 2);

    *NumArgs = Args;
    return ArgPtrArray;
}


BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringA (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringW (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      CHARTYPE SearchChar
    )
{
    PCSTR ptr = CurrPtr;

    for (;;) {
        ptr = _mbsdec (StartStr, ptr);

        if (!ptr) {
            return NULL;
        }
        if (_mbsnextc (ptr) == SearchChar) {
            return (PSTR) ptr;
        }
    }
}


PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    )
{
    PCWSTR ptr = CurrPtr;

    for (;;) {
        ptr--;

        if (*ptr == SearchChar) {
            return (PWSTR) ptr;
        }
        if (ptr == StartStr) {
            return NULL;
        }
    }
}

#define WACK_REPLACE_CHAR 0x02

VOID
ToggleWacksA (
    IN PSTR Line,
    IN BOOL Operation
    )
{
    CHAR curChar;
    CHAR newChar;
    PSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : '\\';
    newChar = Operation ? '\\' : WACK_REPLACE_CHAR;

    do {

        p = _mbschr (p, curChar);

        if (p) {

            *p = newChar;
            p = _mbsinc (p);
        }

    } while (p);
}

VOID
ToggleWacksW (
    IN PWSTR Line,
    IN BOOL Operation
    )
{
    WCHAR curChar;
    WCHAR newChar;
    PWSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : L'\\';
    newChar = Operation ? L'\\' : WACK_REPLACE_CHAR;

    do {

        p = wcschr (p, curChar);

        if (p) {

            *p = newChar;
            p++;
        }

    } while (p);
}


PWSTR
our_lstrcpynW (
    OUT     PWSTR Dest,
    IN      PCWSTR Src,
    IN      INT NumChars
    )
{
    PCWSTR srcEnd;

    __try {

        if (NumChars > 0) {
            //
            // assuming we wrote this because lstrcpyn has problems... we
            // cannot use wcsncpy, because it fills the entire Dest buffer
            // with nuls when WcharCount(Src) < NumChars - 1. That just
            // wastes time.
            //

            srcEnd = Src + NumChars - 1;
            while (*Src && Src < srcEnd) {
                *Dest++ = *Src++;
            }

            *Dest = 0;
        }
    }
    __except (1) {
    }

    return Dest;
}


PSTR
pGoBackA (
    IN      PSTR LastChar,
    IN      PSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = _mbsdec (FirstChar, LastChar);
    while (NumWacks && (LastChar>=FirstChar)) {
        if (_mbsnextc (LastChar) == '\\') {
            NumWacks --;
        }
        LastChar = _mbsdec (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}

PWSTR
pGoBackW (
    IN      PWSTR LastChar,
    IN      PWSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar --;
    while (NumWacks && (LastChar>=FirstChar)) {
        if (*LastChar == L'\\') {
            NumWacks --;
        }
        LastChar --;
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}

UINT
pCountDotsA (
    IN      PCSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (_mbsnextc (PathSeg) != '.') {
            return 0;
        }
        numDots ++;
        PathSeg = _mbsinc (PathSeg);
    }
    return numDots;
}

UINT
pCountDotsW (
    IN      PCWSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (*PathSeg != L'.') {
            return 0;
        }
        numDots ++;
        PathSeg ++;
    }
    return numDots;
}

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    )
{
    CHAR pathSeg [MEMDB_MAX];
    PCSTR wackPtr;
    UINT dotNr;
    PSTR newPath = DuplicatePathStringA (FileSpec, 0);
    PSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = _mbschr (FileSpec, '\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = _mbsinc (wackPtr);
                if (!wackPtr) {
                    FreePathStringA (newPath);
                    return NULL;
                }
                if (_mbsnextc (wackPtr) == '\\') {
                    // this one starts with a double wack
                    wackPtr = _mbsinc (wackPtr);
                    if (!wackPtr) {
                        FreePathStringA (newPath);
                        return NULL;
                    }
                    wackPtr = _mbschr (wackPtr, '\\');
                } else {
                    wackPtr = _mbschr (wackPtr, '\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                _mbssafecpyab (pathSeg, FileSpec, wackPtr, MEMDB_MAX);

                FileSpec = _mbsinc (wackPtr);
            } else {
                _mbssafecpyab (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MEMDB_MAX);
            }
        } else {
            _mbssafecpyab (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MEMDB_MAX);
        }

        if (*pathSeg) {
            dotNr = pCountDotsA (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackA (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGA ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringA (newPath);
                    return NULL;
                }
            } else {

                StringCopyA (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringA (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = '\\';
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR pathSeg [MEMDB_MAX];
    PCWSTR wackPtr;
    UINT dotNr;
    PWSTR newPath = DuplicatePathStringW (FileSpec, 0);
    PWSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = wcschr (FileSpec, L'\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr ++;
                if (*wackPtr == 0) {
                    FreePathStringW (newPath);
                    return NULL;
                }
                if (*wackPtr == L'\\') {
                    // this one starts with a double wack
                    wackPtr ++;
                    if (!wackPtr) {
                        FreePathStringW (newPath);
                        return NULL;
                    }
                    wackPtr = wcschr (wackPtr, L'\\');
                } else {
                    wackPtr = wcschr (wackPtr, L'\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                _wcssafecpyab(pathSeg, FileSpec, wackPtr, MEMDB_MAX * sizeof (WCHAR));
                FileSpec = wackPtr + 1;
            } else {
                _wcssafecpyab(pathSeg, FileSpec, GetEndOfStringW (FileSpec), MEMDB_MAX * sizeof (WCHAR));
            }
        } else {
            _wcssafecpyab(pathSeg, FileSpec, GetEndOfStringW (FileSpec), MEMDB_MAX * sizeof (WCHAR));
        }

        if (*pathSeg) {
            dotNr = pCountDotsW (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackW (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGW ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringW (newPath);
                    return NULL;
                }
            } else {

                StringCopyW (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringW (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = L'\\';
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}


typedef struct {
    UINT char1;
    UINT char2;
    UINT result;
} DHLIST, *PDHLIST;

DHLIST g_DHList[] = {{0xB3, 0xDE, 0x8394},
                     {0xB6, 0xDE, 0x834B},
                     {0xB7, 0xDE, 0x834D},
                     {0xB8, 0xDE, 0x834F},
                     {0xB9, 0xDE, 0x8351},
                     {0xBA, 0xDE, 0x8353},
                     {0xBB, 0xDE, 0x8355},
                     {0xBC, 0xDE, 0x8357},
                     {0xBD, 0xDE, 0x8359},
                     {0xBE, 0xDE, 0x835B},
                     {0xBF, 0xDE, 0x835D},
                     {0xC0, 0xDE, 0x835F},
                     {0xC1, 0xDE, 0x8361},
                     {0xC2, 0xDE, 0x8364},
                     {0xC3, 0xDE, 0x8366},
                     {0xC4, 0xDE, 0x8368},
                     {0xCA, 0xDE, 0x836F},
                     {0xCB, 0xDE, 0x8372},
                     {0xCC, 0xDE, 0x8375},
                     {0xCD, 0xDE, 0x8378},
                     {0xCE, 0xDE, 0x837B},
                     {0xCA, 0xDF, 0x8370},
                     {0xCB, 0xDF, 0x8373},
                     {0xCC, 0xDF, 0x8376},
                     {0xCD, 0xDF, 0x8379},
                     {0xCE, 0xDF, 0x837C},
                     {0x00, 0x00, 0x0000}};

UINT
pBuildFromDHList (
    IN      UINT ch1,
    IN      UINT ch2
    )
{
    PDHLIST p;
    UINT result = 0;

    p = g_DHList;
    while (p->char1) {
        if ((p->char1 == ch1) && (p->char2 == ch2)) {
            result = p->result;
            break;
        }
        p++;
    }
    return result;
}

VOID
_mbssetchar (
    PSTR Dest,
    UINT Char
    )
{
    if (Char >= 256) {
        *(Dest+1) = *((PBYTE)(&Char));
        *(Dest) = *((PBYTE)((DWORD)(&Char) + 1));
    }
    else {
        *Dest = (CHAR)Char;
    }
}

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    )
{
    CHAR result[MEMDB_MAX];
    PCSTR p,p1,q;
    PSTR s;
    UINT ch;
    UINT ch1;
    BOOL dhCase = FALSE;

    ZeroMemory (result, MAX_PATH);
    p = FullPath;
    q = RootPath;
    s = result;

    while (*p && (((DWORD)s - (DWORD)result) < MEMDB_MAX)) {
        if (q && *q) {
            _mbssetchar (s, _mbsnextc(p));
            q = _mbsinc (q);
        } else if (Limit && (p >= Limit)) {
            _mbssetchar (s, _mbsnextc(p));
        } else {
            ch = _mbsnextc (p);

            //
            // It is very important not to make the conversion for characters below A1. Otherwise
            // all english letters will be converted to large letters.
            //
            if (ch >= 0xA1 && ch <= 0xDF) {
                // this is a candidate for conversion
                // we need to see if there is a special Dakutenn/Handakuten conversion
                dhCase = FALSE;
                p1 = _mbsinc (p);
                if (p1) {
                    ch1 = _mbsnextc (p1);
                    ch1 = pBuildFromDHList (ch, ch1);
                    if (ch1) {
                        p = _mbsinc (p);
                        _mbssetchar (s, ch1);
                        dhCase = TRUE;
                    }
                }
                if (!dhCase) {
                    _mbssetchar (s, _mbbtombc (ch));
                }
            } else {
                _mbssetchar (s, ch);
            }
        }
        p = _mbsinc (p);
        s = _mbsinc (s);
    }
    result [MAX_PATH - 1] = 0;
    return (DuplicatePathString (result, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\unicode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    unicode.c

Abstract:

    Simplified Unicode-Ansi conversion functions.

    Externally exposed routines:
      In-Place Conversion:
        KnownSizeDbcsToUnicodeN
        KnownSizeUnicodeToDbcsN
        KnownSizeWtoA
        KnownSizeAtoW

      In-Place Conversion without nul checks:
        DirectDbcsToUnicodeN
        DirectUnicodeToDbcsN
        DirectAtoW
        DirectWtoA

      Length/pool options:
        DbcsToUnicodeN
        UnicodeToDbcsN
        DbcsToUnicode
        UnicodeToDbcs
        FreeConvertedPoolStr

      Simplified type conversions:
        ConvertWtoA
        ConvertAtoW
        FreeConvertedStr

      TCHAR routines that can be compiled both ways:
        CreateDbcs
        CreateUnicode
        DestroyDbcs
        DestroyUnicode

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    jimschm     15-Feb-1999 Eliminated MikeCo's routines, since they are
                            broken on FE
    jimschm     23-Sep-1998 Added in-place routines

--*/

#include "pch.h"
#include <locale.h>
#include <mbctype.h>

extern POOLHANDLE g_TextPool;
extern DWORD g_MigutilWCToMBFlags;

WORD g_GlobalCodePage = CP_ACP;

typedef VOID(WINAPI SETACP)(WORD CodePage);
typedef SETACP * PSETACP;

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    )
{
    PSETACP SetACP;
    HANDLE Lib;

    g_GlobalCodePage = CodePage;


    if (ISNT()) {
        Lib = LoadLibrary (TEXT("kernel32.dll"));
        if (Lib) {
            SetACP = (PSETACP) GetProcAddress (Lib, "SetCPGlobal");
            if (SetACP) {
                SetACP (CodePage);
            }

            FreeLibrary (Lib);
        }
    }

    SetThreadLocale (Locale);
    setlocale(LC_ALL,"");
    _setmbcp(CodePage);
}


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    )
{
    if (CodePage) {
        if (g_GlobalCodePage == CP_ACP) {
            *CodePage = (WORD)GetACP();
        } else {
            *CodePage = g_GlobalCodePage;
        }
    }

    if (Locale) {
        *Locale = GetThreadLocale();
    }
}


PCSTR
RealUnicodeToDbcsN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS.

  WARNING: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool  - Specifies the pool where memory is allocated from.  If not specified,
          g_TextPool is used instead.

  StrIn - Specifies the inbound UNICODE string

  Chars - Specifies the number of characters, excluding the nul, to
          convert.

Return Value:

  A pointer to the ANSI string, or NULL if an error occurred.

--*/

{
    PSTR DbcsStr;
    DWORD Size;
    DWORD rc;

    if (!Pool) {
        Pool = g_TextPool;
    }

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    Size = (Chars + 1) * sizeof (WCHAR);

    DbcsStr = (PSTR) PoolMemGetAlignedMemory (Pool, Size);
    if (!DbcsStr) {
        DEBUGMSG ((DBG_ERROR, "UnicodeToDbcsN could not allocate string"));
        return NULL;
    }

    rc = WideCharToMultiByte (
             g_GlobalCodePage,
             g_MigutilWCToMBFlags,
             StrIn,
             Chars,              // wc input count
             DbcsStr,
             Size,
             NULL,
             NULL
             );

    // Report error returns from WideCharToMultiByte
    if (!rc && Chars) {
        PushError();
        PoolMemReleaseMemory (Pool, DbcsStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "UnicodeToDbcsN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    *CharCountToPointerA (DbcsStr, Chars) = 0;

    return DbcsStr;
}


PCWSTR
RealDbcsToUnicodeN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a DBCS string to UNICODE.

  WARNING: Currently supports the ANSI code page only.  Later we can fix this.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string to be converted

  Chars     - Specifies the number of multibyte characters, excluding the nul,
              to convert.  If -1, all of StrIn will be converted.

Return Value:

  A pointer to the converted UNICODE string, or NULL if an error ocurred.

--*/

{
    PWSTR UnicodeStr;
    DWORD UnicodeStrBufLenBytes;
    DWORD WcharsConverted;
    DWORD StrInBytesToConvert;

    //
    // Find number of multi-byte characters to convert. Punt on case where
    // caller asks for more chars than available.
    //
    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountA (StrIn);
    }

    //
    // Count bytes to convert from the input string (excludes delimiter)
    //
    StrInBytesToConvert = CharCountToPointerA(StrIn, Chars) - StrIn;

    //
    // Get output buffer size, in bytes, including delimiter
    //
    UnicodeStrBufLenBytes = (Chars + 1) * sizeof (WCHAR);

    if (!Pool) {
        Pool = g_TextPool;
    }

    //
    // Get buffer
    //
    UnicodeStr = (PWSTR) PoolMemGetAlignedMemory (Pool, UnicodeStrBufLenBytes);
    if (!UnicodeStr) {
        DEBUGMSG ((DBG_ERROR, "DbcsToUnicodeN could not allocate string"));
        return NULL;
    }

    //
    // Convert
    //
    WcharsConverted = MultiByteToWideChar (
             g_GlobalCodePage,
             0, // MB_ERR_INVALID_CHARS,
             StrIn,
             StrInBytesToConvert,
             UnicodeStr,
             UnicodeStrBufLenBytes
             );

    //
    // Check for conversion error (>0 chars in, 0 chars out)
    //
    if (0 == WcharsConverted && 0 != Chars) {
        PushError();
        PoolMemReleaseMemory (Pool, UnicodeStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "DbcsToUnicodeN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    //
    // Write delimiter on the output string
    //
    UnicodeStr[WcharsConverted] = 0;

    return UnicodeStr;
}


VOID
FreeConvertedPoolStr (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    )

/*++

Routine Description:

  Frees the memory allocated by UnicodeToDbcsN or DbcsToUnicodeN.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string that was returned by UnicodeToDebcsN or
              DbcsToUnicodeN.

Return Value:

  none

--*/

{
    if (!StrIn) {
        return;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    PoolMemReleaseMemory (Pool, (PVOID) StrIn);
}


PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    rc = WideCharToMultiByte (
             g_GlobalCodePage,
             g_MigutilWCToMBFlags,
             StrIn,
             Chars,              // wc input count
             StrOut,
             Chars * 2,
             NULL,
             NULL
             );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeUnicodeToDbcsN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;
    DWORD StrInBytesToConvert;

    if (INVALID_CHAR_COUNT == Chars) {
        StrInBytesToConvert = ByteCountA (StrIn);
    } else {
        StrInBytesToConvert = CharCountToPointerA (StrIn, Chars) - StrIn;
    }

    rc = MultiByteToWideChar (
             g_GlobalCodePage,
             0, // MB_ERR_INVALID_CHARS,
             StrIn,
             StrInBytesToConvert,
             StrOut,
             StrInBytesToConvert * 2
             );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeDbcsToUnicodeN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the
  string.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountW (StrIn);
    }

    rc = WideCharToMultiByte (
             g_GlobalCodePage,
             g_MigutilWCToMBFlags,
             StrIn,
             Bytes / sizeof (WCHAR),
             StrOut,
             Bytes,
             NULL,
             NULL
             );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectUnicodeToDbcsN failed."
        ));

    return StrOut;
}


PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the string.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountA (StrIn);
    }

    rc = MultiByteToWideChar (
             g_GlobalCodePage,
             0, // MB_ERR_INVALID_CHARS,
             StrIn,
             Bytes,
             StrOut,
             Bytes * 2
             );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectDbcsToUnicodeN failed."
        ));

    return StrOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\version.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    version.c

Abstract:

    This file implements a set of enumeration routines to access
    version info in a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    <alias>  <date>  <comments>

--*/

#include "pch.h"

#define DBG_ACTION "Action"

//
// Globals
//

PCSTR g_DefaultTranslationsA[] = {
    "04090000",
    "040904E4",
    "040904B0",
    NULL
};

PCWSTR g_DefaultTranslationsW[] = {
    L"04090000",
    L"040904E4",
    L"040904B0",
    NULL
};

//
// Prototypes
//

PCSTR
pEnumVersionValueCommonA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

PCWSTR
pEnumVersionValueCommonW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );


//
// Implementation
//

BOOL
CreateVersionStructA (
    OUT     PVERSION_STRUCTA VersionStruct,
    IN      PCSTR FileSpec
    )

/*++

Routine Description:

  CreateVersionStruct is called to load a version structure from a file
  and to obtain the fixed version stamp info that is language-independent.

  The caller must call DestroyVersionStruct after the VersionStruct is no
  longer needed.

Arguments:

  VersionStruct - Receives the version stamp info to be used by other
                  functions in this module

  FileSpec - Specifies the file to obtain version info from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

{
    //
    // Init the struct
    //

    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTA));
    VersionStruct->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VersionStruct->Size = GetFileVersionInfoSizeA (
                                (PSTR) FileSpec,
                                &VersionStruct->Handle
                                );
    if (!VersionStruct->Size) {
        DEBUGMSG ((DBG_WARNING, "File %s does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VersionStruct->VersionBuffer = GrowBuffer (&VersionStruct->GrowBuf, VersionStruct->Size * 2);

    if (!VersionStruct->VersionBuffer) {
        return FALSE;
    }

    VersionStruct->StringBuffer = VersionStruct->GrowBuf.Buf + VersionStruct->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoA (
             (PSTR) FileSpec,
             VersionStruct->Handle,
             VersionStruct->Size,
             VersionStruct->VersionBuffer
             )) {
        DestroyVersionStructA (VersionStruct);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueA (
        VersionStruct->VersionBuffer,
        "\\",
        &VersionStruct->FixedInfo,
        &VersionStruct->FixedInfoSize
        );

    return TRUE;
}

ULONGLONG
VerGetFileVer (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    ULONGLONG result = 0;
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VersionStruct->FixedInfo->dwFileVersionLS;
        *(((PDWORD) (&result)) + 1) = VersionStruct->FixedInfo->dwFileVersionMS;
    }
    return result;
}

ULONGLONG
VerGetProductVer (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    ULONGLONG result = 0;
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VersionStruct->FixedInfo->dwProductVersionLS;
        *(((PDWORD) (&result)) + 1) = VersionStruct->FixedInfo->dwProductVersionMS;
    }
    return result;
}

DWORD
VerGetFileDateLo (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileDateLS;
    }
    return 0;
}

DWORD
VerGetFileDateHi (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileDateMS;
    }
    return 0;
}

DWORD
VerGetFileVerOs (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileOS;
    }
    return 0;
}

DWORD
VerGetFileVerType (
    IN      PVERSION_STRUCTA VersionStruct
    )
{
    if (VersionStruct->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VersionStruct->FixedInfo->dwFileType;
    }
    return 0;
}

VOID
DestroyVersionStructA (
    IN      PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  DestroyVersionStruct cleans up all memory allocated by the routines
  in this module.

Arguments:

  VersionStruct - Specifies the structure to clean up

Return Value:

  none

--*/

{
    //
    // Clean up all allocations made by any routine using
    // the VersionStruct
    //

    if (VersionStruct->GrowBuf.Buf) {
        FreeGrowBuffer (&VersionStruct->GrowBuf);
    }

    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTA));
}


PCSTR
EnumFirstVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  EnumFirstVersionTranslation returins the translation string needed
  to access the string table of a version stamp.

Arguments:

  VersionStruct - Specifies the structure that has been initialized
                  by InitializeVersionStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

{
    UINT ArraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueA (
            VersionStruct->VersionBuffer,
            "\\VarFileInfo\\Translation",
            &VersionStruct->Translations,
            &ArraySize
            )) {
        //
        // No translations are available
        //

        ArraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VersionStruct->CurrentDefaultTranslation = 0;
    VersionStruct->MaxTranslations = ArraySize / sizeof (TRANSLATION);
    VersionStruct->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VersionStruct->MaxTranslations == 0,
        DBG_WARNING,
        "File %s has no translations",
        VersionStruct->FileSpec
        ));

    return EnumNextVersionTranslationA (VersionStruct);
}


BOOL
pIsDefaultTranslationA (
    IN      PCSTR TranslationStr
    )

/*++

Routine Description:

  pIsDefaultTranslationA returns TRUE if the specified translation
  string is enumerated by default.  This routine stops multiple
  enumeration of the same translation string.

Arguments:

  TranslationStr - Specifies the translation string to test

Return Value:

  TRUE if the translation string is the same as a default translation
  string, or FALSE if it is not.

--*/

{
    INT i;

    for (i = 0 ; g_DefaultTranslationsA[i] ; i++) {
        if (StringIMatchA (TranslationStr, g_DefaultTranslationsA[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


PCSTR
EnumNextVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionTranslation continues the enumeration of translation
  strings, needed to access the string table in a version stamp.

Arguments:

  VersionStruct - Specifies the same structure passed to
                  EnumFirstVersionTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

{
    PTRANSLATION Translation;

    if (g_DefaultTranslationsA[VersionStruct->CurrentDefaultTranslation]) {
        //
        // Return default translations first
        //

        StringCopyA (
            VersionStruct->TranslationStr,
            g_DefaultTranslationsA[VersionStruct->CurrentDefaultTranslation]
            );

        VersionStruct->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VersionStruct->CurrentTranslation == VersionStruct->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            Translation = &VersionStruct->Translations[VersionStruct->CurrentTranslation];

            wsprintfA (
                VersionStruct->TranslationStr,
                "%04x%04x",
                Translation->CodePage,
                Translation->Language
                );

            VersionStruct->CurrentTranslation++;

        } while (pIsDefaultTranslationA (VersionStruct->TranslationStr));
    }

    return VersionStruct->TranslationStr;
}


PCSTR
EnumFirstVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct,
    IN      PCSTR VersionField
    )

/*++

Routine Description:

  EnumFirstVersionValue returns the first value stored in a version
  stamp for a specific field.  If the field does not exist, the
  function returns NULL.

  An enumeration of EnumFirstVersionValue/EnumNextVersionValue
  is used to list all localized strings for a field.

Arguments:

  VersionStruct - Specifies the structure that was initialized by
                  InitializeVersionStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

{
    PCSTR rc;

    if (!EnumFirstVersionTranslationA (VersionStruct)) {
        return NULL;
    }

    VersionStruct->VersionField = VersionField;

    rc = pEnumVersionValueCommonA (VersionStruct);

    if (!rc) {
        rc = EnumNextVersionValueA (VersionStruct);
    }

    return rc;
}


PCSTR
EnumNextVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionValue returns the next value stored in a version
  stamp for a specific field.

Arguments:

  VersionStruct - Specifies the same structure passed to EnumFirstVersionField

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

{
    PCSTR rc = NULL;

    do {
        if (!EnumNextVersionTranslationA (VersionStruct)) {
            break;
        }

        rc = pEnumVersionValueCommonA (VersionStruct);

    } while (!rc);

    return rc;
}


PCSTR
pEnumVersionValueCommonA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    )

/*++

Routine Description:

  pEnumVersionValueCommon is a routine that obtains the value
  of a version field.  It is used for both EnumFirstVersionValue
  and EnumNextVersionValue.

Arguments:

  VersionStruct - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

{
    PSTR Text;
    UINT StringLen;
    PBYTE String;
    PCSTR Result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    Text = AllocTextA (
               16 +
               SizeOfStringA (VersionStruct->TranslationStr) +
               SizeOfStringA (VersionStruct->VersionField)
               );

    if (!Text) {
        return NULL;
    }

    wsprintfA (
        Text,
        "\\StringFileInfo\\%s\\%s",
        VersionStruct->TranslationStr,
        VersionStruct->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueA (
                VersionStruct->VersionBuffer,
                Text,
                &String,
                &StringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        _mbsnzcpy (VersionStruct->StringBuffer, (PCSTR) String, StringLen);

        Result = VersionStruct->StringBuffer;

    }
    __finally {
        FreeTextA (Text);
    }

    return Result;
}


BOOL
CreateVersionStructW (
    OUT     PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  CreateVersionStruct is called to load a version structure from a file
  and to obtain the fixed version stamp info that is language-independent.

  The caller must call DestroyVersionStruct after the VersionStruct is no
  longer needed.

Arguments:

  VersionStruct - Receives the version stamp info to be used by other
                  functions in this module

  FileSpec - Specifies the file to obtain version info from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

{
    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTW));
    VersionStruct->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VersionStruct->Size = GetFileVersionInfoSizeW (
                                (PWSTR) FileSpec,
                                &VersionStruct->Handle
                                );
    if (!VersionStruct->Size) {
        DEBUGMSG ((DBG_WARNING, "File %S does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VersionStruct->VersionBuffer = GrowBuffer (&VersionStruct->GrowBuf, VersionStruct->Size * 2);

    if (!VersionStruct->VersionBuffer) {
        return FALSE;
    }

    VersionStruct->StringBuffer = VersionStruct->GrowBuf.Buf + VersionStruct->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoW (
             (PWSTR) FileSpec,
             VersionStruct->Handle,
             VersionStruct->Size,
             VersionStruct->VersionBuffer
             )) {
        DestroyVersionStructW (VersionStruct);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueW (
        VersionStruct->VersionBuffer,
        L"\\",
        &VersionStruct->FixedInfo,
        &VersionStruct->FixedInfoSize
        );

    return TRUE;
}


VOID
DestroyVersionStructW (
    IN      PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  DestroyVersionStruct cleans up all memory allocated by the routines
  in this module.

Arguments:

  VersionStruct - Specifies the structure to clean up

Return Value:

  none

--*/

{
    if (VersionStruct->GrowBuf.Buf) {
        FreeGrowBuffer (&VersionStruct->GrowBuf);
    }

    ZeroMemory (VersionStruct, sizeof (VERSION_STRUCTW));
}


PCWSTR
EnumFirstVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  EnumFirstVersionTranslation returins the translation string needed
  to access the string table of a version stamp.

Arguments:

  VersionStruct - Specifies the structure that has been initialized
                  by InitializeVersionStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

{
    UINT ArraySize;

    if (!VerQueryValueW (
            VersionStruct->VersionBuffer,
            L"\\VarFileInfo\\Translation",
            &VersionStruct->Translations,
            &ArraySize
            )) {
        //
        // No translations are available
        //

        ArraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VersionStruct->CurrentDefaultTranslation = 0;
    VersionStruct->MaxTranslations = ArraySize / sizeof (TRANSLATION);
    VersionStruct->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VersionStruct->MaxTranslations == 0,
        DBG_WARNING,
        "File %S has no translations",
        VersionStruct->FileSpec
        ));

    return EnumNextVersionTranslationW (VersionStruct);
}


BOOL
pIsDefaultTranslationW (
    IN      PCWSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsW[i] ; i++) {
        if (StringIMatchW (TranslationStr, g_DefaultTranslationsW[i])) {
            return TRUE;
        }
    }
    return FALSE;
}


PCWSTR
EnumNextVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionTranslation continues the enumeration of translation
  strings, needed to access the string table in a version stamp.

Arguments:

  VersionStruct - Specifies the same structure passed to
                  EnumFirstVersionTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

{
    PTRANSLATION Translation;

    if (g_DefaultTranslationsW[VersionStruct->CurrentDefaultTranslation]) {

        StringCopyW (
            VersionStruct->TranslationStr,
            g_DefaultTranslationsW[VersionStruct->CurrentDefaultTranslation]
            );

        VersionStruct->CurrentDefaultTranslation++;

    } else {

        do {
            if (VersionStruct->CurrentTranslation == VersionStruct->MaxTranslations) {
                return NULL;
            }

            Translation = &VersionStruct->Translations[VersionStruct->CurrentTranslation];

            wsprintfW (
                VersionStruct->TranslationStr,
                L"%04x%04x",
                Translation->CodePage,
                Translation->Language
                );

            VersionStruct->CurrentTranslation++;

        } while (pIsDefaultTranslationW (VersionStruct->TranslationStr));
    }

    return VersionStruct->TranslationStr;
}


PCWSTR
EnumFirstVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR VersionField
    )

/*++

Routine Description:

  EnumFirstVersionValue returns the first value stored in a version
  stamp for a specific field.  If the field does not exist, the
  function returns NULL.

  An enumeration of EnumFirstVersionValue/EnumNextVersionValue
  is used to list all localized strings for a field.

Arguments:

  VersionStruct - Specifies the structure that was initialized by
                  InitializeVersionStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

{
    PCWSTR rc;

    if (!EnumFirstVersionTranslationW (VersionStruct)) {
        return NULL;
    }

    VersionStruct->VersionField = VersionField;

    rc = pEnumVersionValueCommonW (VersionStruct);

    if (!rc) {
        rc = EnumNextVersionValueW (VersionStruct);
    }

    return rc;
}


PCWSTR
EnumNextVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  EnumNextVersionValue returns the next value stored in a version
  stamp for a specific field.

Arguments:

  VersionStruct - Specifies the same structure passed to EnumFirstVersionField

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

{
    PCWSTR rc = NULL;

    do {
        if (!EnumNextVersionTranslationW (VersionStruct)) {
            break;
        }

        rc = pEnumVersionValueCommonW (VersionStruct);

    } while (!rc);

    return rc;
}


PCWSTR
pEnumVersionValueCommonW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    )

/*++

Routine Description:

  pEnumVersionValueCommon is a routine that obtains the value
  of a version field.  It is used for both EnumFirstVersionValue
  and EnumNextVersionValue.

Arguments:

  VersionStruct - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

{
    PWSTR Text;
    UINT StringLen;
    PBYTE String;
    PCWSTR Result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    Text = AllocTextW (
               18 +
               CharCountW (VersionStruct->TranslationStr) +
               CharCountW (VersionStruct->VersionField)
               );

    if (!Text) {
        return NULL;
    }

    wsprintfW (
        Text,
        L"\\StringFileInfo\\%s\\%s",
        VersionStruct->TranslationStr,
        VersionStruct->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueW (
                VersionStruct->VersionBuffer,
                Text,
                &String,
                &StringLen
                )) {
            //
            // No value is available
            //

            return NULL;
        }

        CopyMemory (VersionStruct->StringBuffer, String, StringLen * sizeof (WCHAR));
        VersionStruct->StringBuffer [StringLen * sizeof (WCHAR)] = 0;
        Result = (PWSTR) VersionStruct->StringBuffer;

    }
    __finally {
        FreeTextW (Text);
    }

    return Result;
}


PSTR
UnicodeToCcs (
    PCWSTR Source
    )

/*++

Routine Description:

  UnicodeToCcs will walk the unicode string and convert it to ANSII by encoding all DBCS characters
  to hex values.

Arguments:

  Source - the Unicode string

Return Value:

  An encoded ANSII string.

--*/

{
    CHAR result [MEMDB_MAX];
    UINT srcIndex = 0;
    UINT destIndex = 0;

    while (Source [srcIndex]) {
        if ((Source [srcIndex] >=32) &&
            (Source [srcIndex] <=126)
            ) {
            result [destIndex] = (BYTE) Source [srcIndex];
            destIndex ++;
        }
        else {
            if ((destIndex == 0) ||
                (result [destIndex-1] != '*')
                ) {
                result [destIndex] = '*';
                destIndex ++;
            }
        }
        srcIndex ++;
    }

    result [destIndex] = 0;
    return DuplicatePathString (result, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\migutil\uninstall.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    uninstall.c

Abstract:

    General uninstall-related functions.

Author:

    Aghajanyan Souren 27-Mar-2001

Revision History:

--*/


#include "pch.h"
#include "uninstall.h"

#define PARTITIONS_DEFAULT_NUMBER   128

BOOL 
GetDiskInfo(
    IN      UINT    Drive, 
    IN OUT  DISKINFO * pInfo
    )
{
    HANDLE  hDisk = NULL;
    DWORD   dwBytesReturned;
    DWORD   dwLastError;
    UINT    uiBufferSize;
    BOOL    bResult;
    TCHAR   diskPath[MAX_PATH];
    DRIVE_LAYOUT_INFORMATION_EX * pinfoLayoutEx = NULL;

    if(!pInfo){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return FALSE;
    }
    
    __try{
        wsprintf(diskPath, TEXT("\\\\.\\PHYSICALDRIVE%d"), Drive);

        hDisk = CreateFile(diskPath, 
                           GENERIC_READ, 
                           FILE_SHARE_READ | FILE_SHARE_WRITE, 
                           NULL, 
                           OPEN_EXISTING, 
                           0, 
                           NULL);

        if(INVALID_HANDLE_VALUE == hDisk){
            dwLastError = GetLastError();
            __leave;
        }
        
        AppendWack(diskPath);
        if(DRIVE_FIXED != GetDriveType(diskPath)){
            dwLastError = ERROR_ACCESS_DENIED;
            __leave;
        }
        
        dwBytesReturned = 0;
        bResult = DeviceIoControl(hDisk, 
                                  IOCTL_DISK_GET_DRIVE_GEOMETRY, 
                                  NULL, 
                                  0, 
                                  &pInfo->DiskGeometry, 
                                  sizeof(pInfo->DiskGeometry), 
                                  &dwBytesReturned, 
                                  NULL);

        if(!bResult){
            dwLastError = GetLastError();
            LOG((LOG_WARNING, "GetDiskInfo:DeviceIoControl(%s, IOCTL_DISK_GET_DRIVE_GEOMETRY) failed.", diskPath));
            __leave;
        }

        uiBufferSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX);
        do{
            uiBufferSize += PARTITIONS_DEFAULT_NUMBER * sizeof(PARTITION_INFORMATION_EX);

            if(pinfoLayoutEx){
                FreeMem(pinfoLayoutEx);
            }
            
            pinfoLayoutEx = (DRIVE_LAYOUT_INFORMATION_EX *)MemAllocZeroed(uiBufferSize);
            if(!pinfoLayoutEx){
                dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            
            dwBytesReturned = 0;
            bResult = DeviceIoControl(hDisk, 
                                      IOCTL_DISK_GET_DRIVE_LAYOUT_EX, 
                                      NULL, 
                                      0, 
                                      pinfoLayoutEx, 
                                      uiBufferSize, 
                                      &dwBytesReturned, 
                                      NULL);
        }while(!bResult && ERROR_INSUFFICIENT_BUFFER == GetLastError());

        if(!bResult){
            dwLastError = GetLastError();
            LOG((LOG_WARNING, "GetDiskInfo:DeviceIoControl(%s, IOCTL_DISK_GET_DRIVE_LAYOUT_EX) failed.", diskPath));
            __leave;
        }

        pInfo->DiskLayout = pinfoLayoutEx;

        dwLastError = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        if(pinfoLayoutEx){
            FreeMem(pinfoLayoutEx);
        }
    }

    if(hDisk){
        CloseHandle(hDisk);
    }
    
    SetLastError(dwLastError);
    
    return ERROR_SUCCESS == dwLastError;
}

BOOL 
GetPhysycalDiskNumber(
    OUT UINT * pNumberOfPhysicalDisks
    )
{
    TCHAR   diskPath[MAX_PATH];
    HANDLE  hDisk;
    UINT i;

    if(!pNumberOfPhysicalDisks){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return FALSE;
    }

    *pNumberOfPhysicalDisks = 0;
    for(i = 0; ; i++){
        wsprintf(diskPath, TEXT("\\\\.\\PHYSICALDRIVE%d"), i);
        hDisk = CreateFile(diskPath, 
                           GENERIC_READ, 
                           FILE_SHARE_READ | FILE_SHARE_WRITE, 
                           NULL, 
                           OPEN_EXISTING, 
                           0, 
                           NULL);

        if(INVALID_HANDLE_VALUE == hDisk){
            MYASSERT(GetLastError() == ERROR_FILE_NOT_FOUND);
            break;
        }
        CloseHandle(hDisk);
        
        AppendWack(diskPath);
        if(DRIVE_FIXED != GetDriveType(diskPath)){
            continue;
        }

        (*pNumberOfPhysicalDisks)++;
    }

    SetLastError(ERROR_SUCCESS);
    return TRUE;
}

BOOL 
GetDisksInfo(
    OUT     DISKINFO ** pInfo, 
    OUT     UINT * pNumberOfItem
    )
{
    UINT i;
    UINT diskNumber;

    if(!pInfo || !pNumberOfItem){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return FALSE;
    }
    
    if(!GetPhysycalDiskNumber(pNumberOfItem)){
        DEBUGMSG((DBG_ERROR, "GetDisksInfo:GetPhysycalDiskNumber failed"));
        return FALSE;
    }

    *pInfo = (DISKINFO *)MemAllocZeroed(*pNumberOfItem * sizeof(DISKINFO));

    if(!*pInfo){
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        LOG((LOG_WARNING, "GetDisksInfo:MemAlloc failed to allocate memory for %d disks", *pNumberOfItem));
        return FALSE;
    }
    
    diskNumber = 0;
    for(i = 0; i < *pNumberOfItem; i++){
        while(!GetDiskInfo(diskNumber++, (*pInfo) + i)){
            if(ERROR_ACCESS_DENIED == GetLastError()){
                continue;
            }
            if(ERROR_FILE_NOT_FOUND == GetLastError()){
                break;
            }
            LOG((LOG_WARNING, "GetDisksInfo:GetDiskInfo(phisycaldisk%d) failed with total %d", diskNumber, *pNumberOfItem));
            FreeDisksInfo(*pInfo, *pNumberOfItem);
            return FALSE;
        }
    }

    SetLastError(ERROR_SUCCESS);
    return TRUE;
}

VOID 
FreeDisksInfo(
    IN  DISKINFO *  pInfo, 
    IN  UINT        NumberOfItem
    )
{
    UINT i;
    if(!pInfo || !NumberOfItem){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return;
    }
    
    __try{
        for(i = 0; i < NumberOfItem; i++){
            if(pInfo[i].DiskLayout){
                FreeMem(pInfo[i].DiskLayout);
            }
        }

        FreeMem(pInfo);
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        DEBUGMSG((DBG_ERROR, "FreeDisksInfo throwed exception"));
    }
}

BOOL 
GetDriveInfo(
    IN      WCHAR Drive, 
    IN OUT  DRIVEINFO * pInfo
    )
{
    WCHAR driveDosPath[] = L"?:\\";
    WCHAR driveDosDeviceVolumeMountPoint[MAX_PATH];
    BOOL result;

    if(!pInfo || !pInfo->FileSystemName || !pInfo->VolumeNTPath){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return FALSE;
    }
    
    pInfo->Drive = Drive;

    driveDosPath[0] = Drive;
    if(!GetVolumeNameForVolumeMountPointW(driveDosPath, 
                                          driveDosDeviceVolumeMountPoint, 
                                          ARRAYSIZE(driveDosDeviceVolumeMountPoint))){
        DEBUGMSGW((DBG_WARNING, "GetDiskInfo:GetVolumeNameForVolumeMountPoint(%s) failed", driveDosPath));
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }
    wcscpy((LPWSTR)pInfo->VolumeNTPath, driveDosDeviceVolumeMountPoint);
    
    result = GetVolumeInformationW(
                            driveDosPath, 
                            NULL, 
                            0, 
                            NULL, 
                            NULL, 
                            &pInfo->FileSystemFlags, 
                            (LPWSTR)pInfo->FileSystemName, 
                            MAX_PATH
                            );

    if(!result && (GetLastError() == ERROR_UNRECOGNIZED_VOLUME)){
        wcscpy((LPWSTR)pInfo->FileSystemName, L"UNRECOGNIZED_VOLUME");
        result = TRUE;
        DEBUGMSGW((DBG_WARNING, "GetDiskInfo:GetVolumeInformation(%s):GetLastError() == ERROR_UNRECOGNIZED_VOLUME", driveDosPath));
    }
    
    DEBUGMSGW_IF((!result, DBG_ERROR, "GetDiskInfo:GetVolumeInformation(%s):GetLastError() == %d", driveDosPath, GetLastError()));

    return result;
}

BOOL 
GetIntegrityInfoW(
    IN  PCWSTR FileName, 
    IN  PCWSTR DirPath, 
    OUT FILEINTEGRITYINFO * IntegrityInfoPtr
)
{
    WCHAR pathFile[MAX_PATH];
    
    if(!FileName || !DirPath || !IntegrityInfoPtr){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return FALSE;
    }

    StringCopyW(pathFile, DirPath);
    StringCatW(AppendWackW(pathFile), FileName);

    StringCopyW((LPWSTR)IntegrityInfoPtr->FileName, FileName);

    if(!GetFileSizeFromFilePathW(pathFile, &IntegrityInfoPtr->FileSize)){
        return FALSE;
    }
    
    SetLastError(ERROR_SUCCESS);
    return TRUE;
}

BOOL 
GetDrivesInfo(
    IN OUT      DRIVEINFO *  pInfo, 
    IN OUT      UINT      *  pDiskInfoRealCount, 
    IN          UINT         DiskInfoMaxCount
    )
{
    UINT LogicalDrives;
    WCHAR DriveName[] = L"?:\\";
    UINT i;

    if(!pDiskInfoRealCount){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return FALSE;
    }
    
    if(!(LogicalDrives = GetLogicalDrives())) {
        return FALSE;
    }
    
    *pDiskInfoRealCount = 0;
    for(i = 0; LogicalDrives && ((*pDiskInfoRealCount) < DiskInfoMaxCount); LogicalDrives >>= 1, i++){
        if(LogicalDrives&1) {
            DriveName[0] = 'A' + (char)i;
            if(DRIVE_FIXED != GetDriveTypeW(DriveName)) {
                continue;
            }

            if(pInfo){
                if(!GetDriveInfo(DriveName[0], pInfo++)){
                    MYASSERT(FALSE);
                    return FALSE;
                }
            }
            (*pDiskInfoRealCount)++;
        }
    }

    SetLastError(ERROR_SUCCESS);
    return TRUE;
}

BOOL 
GetUndoDrivesInfo(
    OUT DRIVEINFO * pInfo, 
    OUT UINT      * pNumberOfDrive, 
    IN  WCHAR       BootDrive, 
    IN  WCHAR       SystemDrive, 
    IN  WCHAR       UndoDrive
    )
{
    if(!pInfo || !pNumberOfDrive){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return FALSE;
    }
    
    *pNumberOfDrive = 0;
    if(!GetDriveInfo(BootDrive, pInfo++)){
        MYASSERT(FALSE);
        return FALSE;
    }
    (*pNumberOfDrive)++;

    if(SystemDrive != BootDrive){
        if(!GetDriveInfo(SystemDrive, pInfo++)){
            MYASSERT(FALSE);
            return FALSE;
        }
        (*pNumberOfDrive)++;
    }
    
    if(UndoDrive != BootDrive && UndoDrive != SystemDrive){
        if(!GetDriveInfo(UndoDrive, pInfo++)){
            MYASSERT(FALSE);
            return FALSE;
        }
        (*pNumberOfDrive)++;
    }
    
    SetLastError(ERROR_SUCCESS);
    return TRUE;
}

DISKINFO_COMPARATION_STATUS 
CompareDriveInfo(
    IN      DRIVEINFO * FirstInfo,
    IN      DRIVEINFO * SecondInfo
    )
{
    if(!FirstInfo || !SecondInfo){
        MYASSERT(FALSE);
        return DiskInfoCmp_WrongParameters;
    }
    
    if(towlower(FirstInfo->Drive) != towlower(SecondInfo->Drive)){
        return DiskInfoCmp_DifferentLetter;
    }

    MYASSERT(FirstInfo->FileSystemName && SecondInfo->FileSystemName);
    if(wcscmp(FirstInfo->FileSystemName, SecondInfo->FileSystemName)){
        return DiskInfoCmp_FileSystemHasChanged;
    }
    
    if(FirstInfo->FileSystemFlags != SecondInfo->FileSystemFlags){
        return DiskInfoCmp_FileSystemHasChanged;
    }
    
    MYASSERT(FirstInfo->VolumeNTPath && SecondInfo->VolumeNTPath);
    if(wcscmp(FirstInfo->VolumeNTPath, SecondInfo->VolumeNTPath)){
        return DiskInfoCmp_DriveMountPointHasChanged;
    }
    
    return DiskInfoCmp_Equal;
}

BOOL 
CompareDrivesInfo(
    IN      DRIVEINFO *                     FirstInfo,
    IN      DRIVEINFO *                     SecondInfo, 
    IN      UINT                            DriveInfoCount, 
    OUT     PDISKINFO_COMPARATION_STATUS    OutDiskCmpStatus,           OPTIONAL
    OUT     UINT     *                      OutIfFailedDiskInfoIndex    OPTIONAL
    )
{
    UINT i;
    DISKINFO_COMPARATION_STATUS cmpStatus;

    if(!FirstInfo || !SecondInfo || !DriveInfoCount){
        MYASSERT(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for(i = 0; i < DriveInfoCount; i++){
        cmpStatus = CompareDriveInfo(FirstInfo++, SecondInfo++);
        if(DiskInfoCmp_Equal != cmpStatus){
            if(OutDiskCmpStatus){
                *OutDiskCmpStatus = cmpStatus;
            }
            if(OutIfFailedDiskInfoIndex){
                *OutIfFailedDiskInfoIndex = i;
            }
            SetLastError(ERROR_ACCESS_DENIED);
            return FALSE;
        }
    }
    
    SetLastError(ERROR_SUCCESS);
    return TRUE;
}

DISKINFO_COMPARATION_STATUS 
CompareDiskInfo(
    IN      DISKINFO * FirstInfo,
    IN      DISKINFO * SecondInfo
    )
{
    DWORD i, iLen;
    PARTITION_INFORMATION_EX * pPartition1;
    PARTITION_INFORMATION_EX * pPartition2;

    if(!FirstInfo || !SecondInfo || !FirstInfo->DiskLayout || !SecondInfo->DiskLayout){
        MYASSERT(FALSE);
        return DiskInfoCmp_WrongParameters;
    }

    //
    //DISK_GEOMETRY
    //
    if(memcmp(&FirstInfo->DiskGeometry, &SecondInfo->DiskGeometry, sizeof(FirstInfo->DiskGeometry))){
        return DiskInfoCmp_GeometryHasChanged;
    }

    //
    //DRIVE_LAYOUT_INFORMATION_EX
    //
    if(FirstInfo->DiskLayout->PartitionStyle != SecondInfo->DiskLayout->PartitionStyle){
        return DiskInfoCmp_PartitionStyleHasChanged;
    }

    if(FirstInfo->DiskLayout->PartitionCount != SecondInfo->DiskLayout->PartitionCount){
        return DiskInfoCmp_PartitionCountHasChanged;
    }
    //
    //PARTITION_INFORMATION
    //
    for(i = 0, iLen = FirstInfo->DiskLayout->PartitionCount; i < iLen; i++){
        pPartition1 = &FirstInfo->DiskLayout->PartitionEntry[i];
        pPartition2 = &SecondInfo->DiskLayout->PartitionEntry[i];
        
        if(pPartition1->PartitionStyle != pPartition2->PartitionStyle){
            return DiskInfoCmp_PartitionStyleHasChanged;
        }
        if(pPartition1->StartingOffset.QuadPart != pPartition2->StartingOffset.QuadPart){
            return DiskInfoCmp_PartitionPlaceHasChanged;
        }

        if(pPartition1->PartitionLength.QuadPart != pPartition2->PartitionLength.QuadPart){
            return DiskInfoCmp_PartitionLengthHasChanged;
        }
        
        if(pPartition1->PartitionNumber != pPartition2->PartitionNumber){
            return DiskInfoCmp_PartitionNumberHasChanged;
        }
        
        if(pPartition1->RewritePartition != pPartition2->RewritePartition){
            return DiskInfoCmp_RewritePartitionHasChanged;
        }
        
        if(pPartition1->PartitionStyle == PARTITION_STYLE_MBR){
            if(pPartition1->Mbr.PartitionType != pPartition2->Mbr.PartitionType){
                return DiskInfoCmp_PartitionTypeHasChanged;
            }
            if(pPartition1->Mbr.BootIndicator != pPartition2->Mbr.BootIndicator){
                return DiskInfoCmp_PartitionAttributesHasChanged;
            }
            if(pPartition1->Mbr.RecognizedPartition != pPartition2->Mbr.RecognizedPartition){
                return DiskInfoCmp_PartitionAttributesHasChanged;
            }
            if(pPartition1->Mbr.HiddenSectors != pPartition2->Mbr.HiddenSectors){
                return DiskInfoCmp_PartitionAttributesHasChanged;
            }
        } 
        else if(pPartition1->PartitionStyle == PARTITION_STYLE_GPT){
            if(memcmp(&pPartition1->Gpt, &pPartition2->Gpt, sizeof(pPartition1->Mbr))){
                return DiskInfoCmp_PartitionAttributesHasChanged;
            }
        }
    }
    
    return DiskInfoCmp_Equal;
}

BOOL 
CompareDisksInfo(
    IN      DISKINFO *                      FirstInfo,
    IN      DISKINFO *                      SecondInfo, 
    IN      UINT                            DiskInfoCount, 
    OUT     PDISKINFO_COMPARATION_STATUS    OutDiskCmpStatus,           OPTIONAL
    OUT     UINT     *                      OutIfFailedDiskInfoIndex    OPTIONAL
    )
{
    UINT i;
    DISKINFO_COMPARATION_STATUS cmpStatus;

    if(!FirstInfo || !SecondInfo || !DiskInfoCount){
        MYASSERT(FALSE);
        return FALSE;
    }

    for(i = 0; i < DiskInfoCount; i++){
        cmpStatus = CompareDiskInfo(FirstInfo++, SecondInfo++);
        if(DiskInfoCmp_Equal != cmpStatus){
            if(OutDiskCmpStatus){
                *OutDiskCmpStatus = cmpStatus;
            }
            if(OutIfFailedDiskInfoIndex){
                *OutIfFailedDiskInfoIndex = i;
            }
            return FALSE;
        }
    }

    return TRUE;
}

BOOL 
IsFloppyDiskInDrive(
    VOID
    )
{
    WCHAR Drive[] = L"?:\\";
    WCHAR DriveNT[] = L"\\\\.\\?:";
    UINT i;
    HANDLE hDiskDrive;
    BOOL bDiskInDrive = FALSE;
	BOOL bResult;
    DISK_GEOMETRY diskGeometry;
    DWORD bytesReturned;
	DWORD Drives;

    for(i = 0, Drives = 0x7/*GetLogicalDrives()*/; Drives; Drives >>= 1, i++){
		if(!(Drives&1)){
			continue;
		}
        
		Drive[0] = 'A' + i;
        if(DRIVE_REMOVABLE != GetDriveTypeW(Drive)){
            continue;
        }

        DriveNT[4] = Drive[0];

        while(1){
            hDiskDrive = CreateFileW(DriveNT, 
                                     GENERIC_READ, 
                                     FILE_SHARE_READ | FILE_SHARE_WRITE, 
                                     NULL, 
                                     OPEN_EXISTING, 
                                     0, 
                                     NULL);

            if(INVALID_HANDLE_VALUE == hDiskDrive){
                break;
            }

            bResult = DeviceIoControl(hDiskDrive, 
                                      IOCTL_DISK_GET_DRIVE_GEOMETRY, 
                                      NULL, 
                                      0, 
                                      &diskGeometry, 
                                      sizeof(diskGeometry), 
                                      &bytesReturned, 
                                      NULL);

            CloseHandle(hDiskDrive);


            if(bResult){
                bDiskInDrive = diskGeometry.MediaType != Unknown && 
                               diskGeometry.MediaType != RemovableMedia && 
                               diskGeometry.MediaType != FixedMedia;
                break;
            }

            if(ERROR_MEDIA_CHANGED != GetLastError()){
                break;
            }
        }
        if(bDiskInDrive){
            break;
        }
    }

    return bDiskInDrive;
}

BOOL 
GetHardDiskNumberW(
    IN  WCHAR   DriveLetter, 
    OUT UINT  * HarddiskNumberOut
    )

{
    WCHAR   driveName[] = L"\\\\.\\?:";
    HANDLE  hDisk;
    STORAGE_DEVICE_NUMBER   deviceNumber;
    BOOL    bResult;
    DWORD   dwBytesReturned;

    driveName[4] = DriveLetter;

    hDisk = CreateFileW(driveName, 
                        GENERIC_READ, 
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, 
                        OPEN_EXISTING, 
                        0,
                        NULL);
    
    if(INVALID_HANDLE_VALUE == hDisk){
        return FALSE;
    }

    bResult = DeviceIoControl(hDisk, 
                              IOCTL_STORAGE_GET_DEVICE_NUMBER, 
                              NULL, 
                              0,
                              &deviceNumber, 
                              sizeof(deviceNumber), 
                              &dwBytesReturned, 
                              NULL);
    CloseHandle(hDisk);

    if(!bResult){
        return  FALSE;
    }

    if(HarddiskNumberOut){
        *HarddiskNumberOut = deviceNumber.DeviceNumber;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\progbar\pch.h ===
#define COMMON_INCLUDES
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\dllentry.c ===
//
//  DLLENTRY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef USEHEAP
#define RGHEAP_SIZE                 9256*1024
HANDLE g_RgHeap = NULL;
#endif

BOOL
WINAPI
VMMRegDllEntry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
#ifdef USEHEAP
            if ((g_RgHeap = HeapCreate(0, RGHEAP_SIZE, RGHEAP_SIZE)) == NULL)
                return FALSE;
#endif

            if (VMMRegLibAttach(0) != ERROR_SUCCESS)
                return FALSE;

            break;

        case DLL_PROCESS_DETACH:
            VMMRegLibDetach();

#ifdef USEHEAP
            if (g_RgHeap != NULL)
                HeapDestroy(g_RgHeap);
#endif

            break;

    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\progbar\progbar.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    progbar.c

Abstract:

    Centralizes access to the progress bar and associated messages accross components
    (hwcomp,migapp,etc.) and sides (w9x, nt)

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm     19-Jun-1998     Improved to allow revision of estimates, necessary
                                for NT-side progress bar.

--*/

#include "pch.h"

//
// Types
//

typedef struct {
    BOOL    Started;
    BOOL    Completed;
    UINT    InitialGuess;
    UINT    TotalTicks;
    UINT    TicksSoFar;
    UINT    LastTickDisplayed;
} SLICE, *PSLICE;

typedef struct {
    HWND Window;
    HANDLE CancelEvent;
    PCSTR Message;
    DWORD MessageId;
    DWORD Delay;
    BOOL  InUse;
} DELAYTHREADPARAMS, *PDELAYTHREADPARAMS;


#if 0

typedef struct {
    HANDLE CancelEvent;
    DWORD TickCount;
    BOOL  InUse;
} TICKTHREADPARAMS, *PTICKTHREADPARAMS;

#endif


//
// Globals
//

BOOL g_ProgBarInitialized = FALSE;

HWND g_ProgressBar;
HWND g_Component;
HWND g_SubComponent;

PBRANGE g_OrgRange;

HANDLE g_ComponentCancelEvent;
HANDLE g_SubComponentCancelEvent;

BOOL *g_CancelFlagPtr;
GROWBUFFER g_SliceArray;
UINT g_SliceCount;
UINT g_MaxTickCount;
UINT g_PaddingTicks;
UINT g_CurrentTickCount;
UINT g_CurrentPos;
UINT g_ReduceFactor;
BOOL g_Reverse = FALSE;
OUR_CRITICAL_SECTION g_ProgBarCriticalSection;
UINT g_CurrentSliceId = (UINT)-1;

//
// Tuning constants
//

#define TICKSCALE       100


//
// Implementaiton
//

VOID
InitializeProgressBar (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    )
{
    LONG rc;
    CHAR Data[256];
    DWORD Size;
    HKEY Key;

    g_ProgressBar = ProgressBar;
    g_CancelFlagPtr = CancelFlagPtr;

    g_ProgBarInitialized = TRUE;

    SendMessage (ProgressBar, PBM_SETPOS, 0, 0);
    g_CurrentPos = 0;
    SendMessage (ProgressBar, PBM_GETRANGE, 0, (LPARAM) &g_OrgRange);

    //
    // Create cancel events for delayed messages.
    //
    g_ComponentCancelEvent      = CreateEvent (NULL, FALSE, FALSE, NULL);
    g_SubComponentCancelEvent   = CreateEvent (NULL, FALSE, FALSE, NULL);

    if (!g_ComponentCancelEvent || !g_SubComponentCancelEvent) {
        DEBUGMSG ((DBG_ERROR, "ProgressBar: Could not create cancel events."));
    }

    InitializeOurCriticalSection (&g_ProgBarCriticalSection);

    g_Component = Component;
    g_SubComponent = SubComponent;

    DEBUGMSG_IF ((
        Component && !IsWindow (Component),
        DBG_WHOOPS,
        "Progress bar component is not a valid window"
        ));

    DEBUGMSG_IF ((
        SubComponent && !IsWindow (SubComponent),
        DBG_WHOOPS,
        "Progress bar sub component is not a valid window"
        ));

    MYASSERT (!g_SliceCount);
    MYASSERT (!g_SliceArray.Buf);
    MYASSERT (!g_MaxTickCount);
    MYASSERT (!g_PaddingTicks);
    MYASSERT (!g_CurrentTickCount);
    MYASSERT (g_CurrentSliceId == (UINT)-1);

    g_ReduceFactor = 1;

    Key = OpenRegKeyStrA ("HKLM\\inapoi");
    if (Key) {
        Size = 256;
        rc = RegQueryValueExA (Key, "", NULL, NULL, (PBYTE) Data, &Size);
        CloseRegKey (Key);

        if (rc == ERROR_SUCCESS && !lstrcmpiA (Data, "backwards")) {
            g_Reverse = TRUE;
        }
    }
}


VOID
TerminateProgressBar (
    VOID
    )
{
    if (g_ComponentCancelEvent) {
        CloseHandle (g_ComponentCancelEvent);
        g_ComponentCancelEvent = NULL;
    }

    if (g_SubComponentCancelEvent) {
        CloseHandle (g_SubComponentCancelEvent);
        g_SubComponentCancelEvent = NULL;
    }

    DeleteOurCriticalSection (&g_ProgBarCriticalSection);

    FreeGrowBuffer (&g_SliceArray);
    g_SliceCount = 0;
    g_MaxTickCount = 0;
    g_PaddingTicks = 0;
    g_CurrentTickCount = 0;
    g_CurrentSliceId = -1;
    g_Component = NULL;
    g_SubComponent = NULL;

    g_ReduceFactor = 1;

    SendMessage (g_ProgressBar, PBM_SETRANGE32, g_OrgRange.iLow, g_OrgRange.iHigh);

    g_ProgBarInitialized = FALSE;
}


UINT
RegisterProgressBarSlice (
    IN      UINT InitialEstimate
    )
{
    PSLICE Slice;
    UINT SliceId;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return 0;
    }

    SliceId = g_SliceCount;

    Slice = (PSLICE) GrowBuffer (&g_SliceArray, sizeof (SLICE));
    g_SliceCount++;

    Slice->Started = FALSE;
    Slice->Completed = FALSE;
    Slice->TotalTicks = InitialEstimate * TICKSCALE;
    Slice->InitialGuess = Slice->TotalTicks;
    Slice->TicksSoFar = 0;
    Slice->LastTickDisplayed = 0;

    return SliceId;
}


VOID
ReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    )
{
    PSLICE Slice;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Invalid slice ID %u", SliceId));
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + SliceId;

    if (!g_CurrentTickCount) {
        Slice->TotalTicks = RevisedEstimate;
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Can't revise completed slice"));
        return;
    }

    if (Slice->InitialGuess == 0) {
        return;
    }

    RevisedEstimate *= TICKSCALE;

    MYASSERT (Slice->TicksSoFar * RevisedEstimate > Slice->TicksSoFar);
    MYASSERT (Slice->LastTickDisplayed * RevisedEstimate > Slice->LastTickDisplayed);

    Slice->TicksSoFar = (UINT) ((LONGLONG) Slice->TicksSoFar * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->LastTickDisplayed = (UINT) ((LONGLONG) Slice->LastTickDisplayed * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->TotalTicks = RevisedEstimate;
}


VOID
BeginSliceProcessing (
    IN      UINT SliceId
    )
{
    PSLICE Slice;
    UINT u;
    UINT TotalTicks;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (!g_ProgressBar) {
        DEBUGMSG ((DBG_WHOOPS, "No progress bar handle"));
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Invalid slice ID %u", SliceId));
        return;
    }

    if (!g_CurrentTickCount) {
        //
        // Initialize the progress bar
        //

        MYASSERT (g_CurrentSliceId == (UINT)-1);

        TotalTicks = 0;
        Slice = (PSLICE) g_SliceArray.Buf;

        for (u = 0 ; u < g_SliceCount ; u++) {
            TotalTicks += Slice->InitialGuess;
            Slice++;
        }

        TotalTicks /= TICKSCALE;
        g_PaddingTicks = TotalTicks * 5 / 100;
        g_MaxTickCount = TotalTicks + 2 * g_PaddingTicks;

        g_ReduceFactor = 1;
        while (g_MaxTickCount > 0xffff) {
            g_ReduceFactor *= 10;
            g_MaxTickCount /= 10;
        }

        SendMessage (g_ProgressBar, PBM_SETRANGE, 0, MAKELPARAM (0, g_MaxTickCount));
        SendMessage (g_ProgressBar, PBM_SETSTEP, 1, 0);

        if (g_Reverse) {
            SendMessage (
                g_ProgressBar,
                PBM_SETPOS,
                g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor),
                0
                );
        } else {
            SendMessage (g_ProgressBar, PBM_SETPOS, g_PaddingTicks / g_ReduceFactor, 0);
        }

        g_CurrentTickCount = g_PaddingTicks;
        g_CurrentPos = g_PaddingTicks;

    } else if (SliceId <= g_CurrentSliceId) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Slice ID %u processed already", SliceId));
        return;
    }


    g_CurrentSliceId = SliceId;
    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    Slice->Started = TRUE;
}


VOID
pIncrementBarIfNecessary (
    IN OUT  PSLICE Slice
    )
{
    UINT Increment;
    UINT Pos;

    if (Slice->TicksSoFar >= Slice->TotalTicks) {
        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;
    }

    if (Slice->TicksSoFar - Slice->LastTickDisplayed >= TICKSCALE) {
        Increment = (Slice->TicksSoFar - Slice->LastTickDisplayed) / TICKSCALE;
        Slice->LastTickDisplayed += Increment * TICKSCALE;

        if (g_Reverse) {

            Pos = ((g_CurrentPos + Slice->TicksSoFar) / TICKSCALE);

            Pos += g_PaddingTicks;
            Pos /= g_ReduceFactor;

            if (Pos > g_MaxTickCount) {
                Pos = g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor);
            }

            SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount - Pos, 0);
        } else {
            SendMessage (g_ProgressBar, PBM_DELTAPOS, Increment / g_ReduceFactor, 0);
        }
    }
}


VOID
pTickProgressBar (
    IN      UINT Ticks
    )
{
    PSLICE Slice;
    LONGLONG x;

    if (!Ticks || g_CurrentSliceId == (UINT)-1 || g_CurrentSliceId >= g_SliceCount) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_VERBOSE, "Progress slice ID %u already completed", g_CurrentSliceId));
        return;
    }

    MYASSERT (Ticks * TICKSCALE > Ticks);
    x = ((LONGLONG) Ticks * TICKSCALE * (LONGLONG) Slice->TotalTicks) / (LONGLONG) Slice->InitialGuess;
    MYASSERT (x + (LONGLONG) Slice->TicksSoFar < 0x100000000);

    Slice->TicksSoFar += (UINT) x;

    pIncrementBarIfNecessary (Slice);

}


BOOL
TickProgressBarDelta (
        IN      UINT TickCount
    )
{
    BOOL    rSuccess = TRUE;

    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    if (g_CancelFlagPtr && *g_CancelFlagPtr) {
        SetLastError (ERROR_CANCELLED);
        rSuccess = FALSE;
    } else {
        pTickProgressBar (TickCount);
    }

    return rSuccess;
}


BOOL
TickProgressBar (
    VOID
    )
{
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return TickProgressBarDelta (1);
}


VOID
EndSliceProcessing (
    VOID
    )
{
    PSLICE Slice;

    if (!g_ProgBarInitialized) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        Slice->Completed = TRUE;
        return;
    }

    if (!Slice->Completed) {
        DEBUGMSG ((DBG_WARNING, "Progress bar slice %u was not completed.", g_CurrentSliceId));

        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;

        pIncrementBarIfNecessary (Slice);
    }

    g_CurrentPos += Slice->TotalTicks;

    if (g_CurrentSliceId == g_SliceCount - 1) {
        //
        // End of progress bar
        //

        SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount, 0);
    }
}


BOOL
pCheckProgressBarState (
    IN HANDLE CancelEvent
    )
{

    SetEvent(CancelEvent);

    return (!g_CancelFlagPtr || !*g_CancelFlagPtr);
}


BOOL
ProgressBar_SetWindowStringA(
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,        OPTIONAL
    IN      DWORD MessageId       OPTIONAL
    )
{
    BOOL rSuccess = TRUE;
    PCSTR string = NULL;

    EnterOurCriticalSection (&g_ProgBarCriticalSection);

    if (g_ProgBarInitialized) {

        if (pCheckProgressBarState(CancelEvent)) {

            if (Message) {

                //
                // We have a normal message string.
                //

                if (!SetWindowTextA(Window, Message)) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
            else if (MessageId) {

                //
                // We have a message ID. Convert it and set it.
                //
                string = GetStringResourceA(MessageId);

                if (string) {

                    if (!SetWindowTextA(Window, string)) {
                        rSuccess = FALSE;
                        DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                    }

                    FreeStringResourceA(string);
                }
                ELSE_DEBUGMSG((DBG_ERROR,"ProgressBar: Error with GetStringResource"));

            }
            else {

                //
                // Just clear the text.
                //

                if (!SetWindowTextA(Window, "")) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
        }
        else {
            //
            // We are in a canceled state.
            //
            rSuccess = FALSE;
            SetLastError (ERROR_CANCELLED);
        }
    }

    LeaveOurCriticalSection (&g_ProgBarCriticalSection);

    return rSuccess;

}


DWORD
pSetDelayedMessageA (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PDELAYTHREADPARAMS  tParams = (PDELAYTHREADPARAMS) Param;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //
    switch (WaitForSingleObject(tParams -> CancelEvent, tParams -> Delay)) {

    case WAIT_TIMEOUT:
        //
        // We timed out without cancel being signaled. Set the delayed message.
        //
        ProgressBar_SetWindowStringA (
            tParams -> Window,
            tParams -> CancelEvent,
            tParams -> Message,
            tParams -> MessageId
            );

        break;

    case WAIT_OBJECT_0:
    default:
        //
        //  We were canceled (or something strange happened :> Do nothing!
        //
        break;
    }

    //
    // can set a new thread now
    //
    tParams->InUse = FALSE;

    return rc;
}


VOID
ProgressBar_CancelDelayedMessage (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return;
    }

    SetEvent(CancelEvent);

}


BOOL
ProgressBar_SetDelayedMessageA (
    IN HWND             Window,
    IN HANDLE           CancelEvent,
    IN LPCSTR           Message,
    IN DWORD            MessageId,
    IN DWORD            Delay
    )
{
    BOOL                rSuccess = FALSE;
    DWORD               threadId;
    static DELAYTHREADPARAMS   tParams;

    if (!g_ProgBarInitialized || tParams.InUse) {
        return TRUE;
    }

    if (!pCheckProgressBarState(Window)) {


        //
        // Fill in the parameters for this call to create thread.
        //
        tParams.Window       = Window;
        tParams.CancelEvent  = CancelEvent;
        tParams.Message      = Message;
        tParams.MessageId    = MessageId;
        tParams.Delay        = Delay;

        //
        // Spawn off a thread that will set the message.
        //
        rSuccess = NULL != CreateThread (
                            NULL,   // No inheritance.
                            0,      // Normal stack size.
                            pSetDelayedMessageA,
                            &tParams,
                            0,      // Run immediately.
                            &threadId
                            );

        if (rSuccess) {
            tParams.InUse = TRUE;
        }
        ELSE_DEBUGMSG((DBG_ERROR,"Error spawning thread in ProgressBar_SetDelayedMessageA."));
    }

    return rSuccess;
}

#if 0

DWORD
pTickProgressBarThread (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PTICKTHREADPARAMS   Params = (PTICKTHREADPARAMS)Param;
    BOOL                Continue = TRUE;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //

    do {
        switch (WaitForSingleObject(Params->CancelEvent, Params->TickCount)) {

        case WAIT_TIMEOUT:
            //
            // We timed out without cancel being signaled. Tick the progress bar.
            //
            if (!TickProgressBarDelta (Params->TickCount)) {
                //
                // cancelled
                //
                Continue = FALSE;
            }
            break;

        case WAIT_OBJECT_0:
        default:
            //
            //  We were canceled (or something strange happened :> Do nothing!
            //
            Continue = FALSE;
            break;
        }
    } while (Continue);

    //
    // can set a new thread now
    //
    Params->InUse = FALSE;

    return rc;
}


BOOL
ProgressBar_CreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    )
{
    BOOL                    rSuccess = FALSE;
    DWORD                   threadId;
    static TICKTHREADPARAMS g_Params;

    if (g_ProgBarInitialized && !g_Params.InUse) {

        if (pCheckProgressBarState(NULL)) {

            //
            // Fill in the parameters for this call to create thread.
            //
            g_Params.CancelEvent = CancelEvent;
            g_Params.TickCount = TickCount;

            //
            // Spawn off a thread that will set the message.
            //
            if (CreateThread (
                    NULL,   // No inheritance.
                    0,      // Normal stack size.
                    pTickProgressBarThread,
                    &g_Params,
                    0,      // Run immediately.
                    &threadId
                    )) {
                rSuccess = TRUE;
                g_Params.InUse = TRUE;
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Error spawning thread in ProgressBar_CreateTickThread."));
        }
    }

    return rSuccess;
}


BOOL
ProgressBar_CancelTickThread (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return SetEvent(CancelEvent);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\makefile.inc ===
obj\$(TARGET_DIRECTORY)\vmmreg32.res: vmmreg32.rc vmmreg32.rcv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regdblk.c ===
//
//  REGDBLK.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgDatablockLockCount);

//  Don't let a FREE_RECORD shrink less than this value.
#define MINIMUM_FREE_RECORD_LENGTH  (sizeof(KEY_RECORD) + sizeof(VALUE_RECORD))

//
//  RgAllocDatablockInfoBuffers
//
//  Allocates the buffers associated with a DATABLOCK_INFO structure.  The
//  size of the datablock buffer is determined by the BlockSize member.
//

int
INTERNAL
RgAllocDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    lpDatablockInfo-> lpDatablockHeader = (LPDATABLOCK_HEADER)
        RgAllocMemory(lpDatablockInfo-> BlockSize);

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {

        lpDatablockInfo-> lpKeyRecordTable = (LPKEY_RECORD_TABLE_ENTRY)
            RgSmAllocMemory(sizeof(KEY_RECORD_TABLE_ENTRY) *
            KEY_RECORDS_PER_DATABLOCK);

        if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable))
            return ERROR_SUCCESS;

        RgFreeDatablockInfoBuffers(lpDatablockInfo);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgFreeDatablockInfoBuffers
//
//  Frees the buffers associated with a DATABLOCK_INFO structure.
//

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {
        RgFreeMemory(lpDatablockInfo-> lpDatablockHeader);
        lpDatablockInfo-> lpDatablockHeader = NULL;
    }

    if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable)) {
        RgSmFreeMemory(lpDatablockInfo-> lpKeyRecordTable);
        lpDatablockInfo-> lpKeyRecordTable = NULL;
    }

}

//
//  RgBuildKeyRecordTable
//
//  Builds a KEY_RECORD index table for the given datablock.
//
//  A datablock consists of a header followed by a series of variable-sized
//  KEY_RECORDs, each with a unique id.  To make lookups fast, an index table is
//  used to map from the unique id to that KEY_RECORD's location.
//
//  As we walk over each KEY_RECORD, we do checks to validate the structure of
//  the datablock, so the error code should be checked for corruption.
//

int
INTERNAL
RgBuildKeyRecordTable(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT Offset;
    UINT BytesRemaining;
    LPKEY_RECORD lpKeyRecord;
    DWORD DatablockAddress;

    ZeroMemory(lpDatablockInfo-> lpKeyRecordTable,
        sizeof(KEY_RECORD_TABLE_ENTRY) * KEY_RECORDS_PER_DATABLOCK);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    Offset = sizeof(DATABLOCK_HEADER);
    BytesRemaining = lpDatablockInfo-> BlockSize - sizeof(DATABLOCK_HEADER);

    while (BytesRemaining) {

        lpKeyRecord = (LPKEY_RECORD) ((LPBYTE) lpDatablockHeader + Offset);
        DatablockAddress = lpKeyRecord-> DatablockAddress;

        if ((lpKeyRecord-> AllocatedSize == 0) || (lpKeyRecord-> AllocatedSize >
            BytesRemaining) || ((DatablockAddress != REG_NULL) &&
            (LOWORD(DatablockAddress) >= KEY_RECORDS_PER_DATABLOCK))) {

            TRACE(("RgBuildKeyRecordTable: invalid key record detected\n"));

            TRACE(("lpdh=%x\n", lpDatablockHeader));
            TRACE(("lpkr=%x\n", lpKeyRecord));
            TRACE(("as=%x\n", lpKeyRecord-> AllocatedSize));
            TRACE(("br=%x\n", BytesRemaining));
            TRACE(("dba=%x\n", DatablockAddress));
            TRAP();

            //  Old code tries to reclaim some of the data.
            return ERROR_BADDB;

        }

        if (DatablockAddress != REG_NULL) {
	    lpDatablockInfo-> lpKeyRecordTable[LOWORD(DatablockAddress)] =
                (KEY_RECORD_TABLE_ENTRY) Offset;
        }

        Offset += SmallDword(lpKeyRecord-> AllocatedSize);
        BytesRemaining -= SmallDword(lpKeyRecord-> AllocatedSize);

    }

    return ERROR_SUCCESS;

}

//
//  RgLockDatablock
//
//  Locks the specified datablock in memory, indicating that it is about to be
//  used.  If the datablock is not currently in memory, then it is brought in.
//  Unlocked datablocks are freed as necessary to make room for this new
//  datablock.
//
//  IMPORTANT:  Locking a datablock only means that it's guaranteed to be kept
//  in memory.  It does not mean that pointers contained in a DATABLOCK_INFO
//  structure will remain the same: routines that could change the
//  DATABLOCK_INFO pointers are labeled "IMPORTANT" as well.
//
//  lpFileInfo, registry file containing the datablock.
//  BlockIndex, index of the datablock.
//

int
INTERNAL
RgLockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex
    )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;
    HFILE hFile = HFILE_ERROR;

    if (BlockIndex >= lpFileInfo-> FileHeader.BlockCount) {
        TRACE(("RgLockDatablock: invalid datablock number\n"));
        return ERROR_BADDB;
    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    //
    //  Is the datablock currently in memory?
    //

    if (!(lpDatablockInfo-> Flags & DIF_PRESENT)) {

        NOISE(("RgLockDatablock: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", BlockIndex));

        ASSERT(lpDatablockInfo-> FileOffset != -1);

        if ((ErrorCode = RgAllocDatablockInfoBuffers(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        NOISE(("    lpDatablockHeader=%lx\n", lpDatablockInfo-> lpDatablockHeader));
        NOISE(("    lpKeyRecordTable=%lx\n", lpDatablockInfo-> lpKeyRecordTable));

        if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) == HFILE_ERROR)
            goto CleanupAfterFileError;

        if (!RgSeekFile(hFile, lpDatablockInfo-> FileOffset))
            goto CleanupAfterFileError;

        if (!RgReadFile(hFile, lpDatablockInfo-> lpDatablockHeader,
            (UINT) lpDatablockInfo-> BlockSize))
            goto CleanupAfterFileError;

        if (!RgIsValidDatablockHeader(lpDatablockInfo-> lpDatablockHeader)) {
            ErrorCode = ERROR_BADDB;
            goto CleanupAfterError;
        }

        if ((ErrorCode = RgBuildKeyRecordTable(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        RgCloseFile(hFile);

    }

    lpDatablockInfo-> Flags |= (DIF_ACCESSED | DIF_PRESENT);
    lpDatablockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);
    return ERROR_SUCCESS;

CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

CleanupAfterError:
    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    RgFreeDatablockInfoBuffers(lpDatablockInfo);

    DEBUG_OUT(("RgLockDatablock() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgUnlockDatablock
//
//  Unlocks the datablock, indicating that the datablock is no longer in active
//  use.  After a datablock has been unlocked, the datablock may be freed after
//  flushing to disk if dirty.
//

VOID
INTERNAL
RgUnlockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BOOL fMarkDirty
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    ASSERT(lpDatablockInfo-> LockCount > 0);
    lpDatablockInfo-> LockCount--;

    if (fMarkDirty) {
        lpDatablockInfo-> Flags |= DIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

}

//
//  RgLockKeyRecord
//
//  Wraps RgLockDatablock, returning the address of the specified KEY_RECORD
//  structure.
//

int
INTERNAL
RgLockKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BYTE KeyRecordIndex,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;

    if ((ErrorCode = RgLockDatablock(lpFileInfo, BlockIndex)) ==
        ERROR_SUCCESS) {

        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (IsNullKeyRecordTableEntry(lpDatablockInfo->
            lpKeyRecordTable[KeyRecordIndex])) {
            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);
            TRACE(("RgLockKeyRecord: invalid datablock address %x:%x\n",
                BlockIndex, KeyRecordIndex));
            ErrorCode = ERROR_BADDB;
        }

        else {
            *lplpKeyRecord = RgIndexKeyRecordPtr(lpDatablockInfo,
                KeyRecordIndex);
        }

    }

    return ErrorCode;

}

//
//  RgCompactDatablock
//
//  Compacts the datablock by pushing all KEY_RECORDS together and leaving a
//  single FREEKEY_RECORD at the end.
//
//  The datablock must be marked dirty by the caller, if desired.
//
//  Returns TRUE if any action was taken.
//

BOOL
INTERNAL
RgCompactDatablock(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    LPBYTE lpSource;
    LPBYTE lpDestination;
    UINT Offset;
    UINT BlockSize;
    UINT BytesToPushDown;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    //  Only need to compact if there's a free record in this datablock.
    if (lpDatablockHeader-> FirstFreeOffset == REG_NULL)
        return FALSE;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
        SmallDword(lpDatablockHeader-> FirstFreeOffset));

    //  Only need to compact if the all the free bytes aren't already at the end
    //  of the datablock (datablocks can't be greater than 64K-1, so no overflow
    //  is possible).
    if ((SmallDword(lpDatablockHeader-> FirstFreeOffset) +
        SmallDword(lpFreeKeyRecord-> AllocatedSize) >= lpDatablockInfo->
        BlockSize) && (lpFreeKeyRecord-> NextFreeOffset == REG_NULL))
        return FALSE;

    NOISE(("RgCompactDatablock: block %d\n", lpDatablockHeader-> BlockIndex));

    lpSource = NULL;
    lpDestination = NULL;
    Offset = sizeof(DATABLOCK_HEADER);
    BlockSize = lpDatablockInfo-> BlockSize;

    while (Offset < BlockSize) {

        //  Advance to the next free record or the end of the block.
        for (;;) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                Offset);

            if (Offset >= BlockSize || IsKeyRecordFree(lpFreeKeyRecord)) {

                //
                //  If lpSource is valid, then we can push down the bytes from
                //  lpSource through lpFreeKeyRecord to lpDestination.
                //

                if (!IsNullPtr(lpSource)) {
                    BytesToPushDown = (LPBYTE) lpFreeKeyRecord -
                        (LPBYTE) lpSource;
                    MoveMemory(lpDestination, lpSource, BytesToPushDown);
                    lpDestination += BytesToPushDown;
                }

                if (IsNullPtr(lpDestination))
                    lpDestination = (LPBYTE) lpFreeKeyRecord;

                break;

            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

        //  Advance to the next key record.
        while (Offset < BlockSize) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                Offset);

            if (!IsKeyRecordFree(lpFreeKeyRecord)) {
                lpSource = (LPBYTE) lpFreeKeyRecord;
                break;
            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

    }

    //  lpDestination now points at the end of the datablock where the giant
    //  free record is to be placed.  Initialize this record and patch up the
    //  datablock header.
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpDestination -
        (LPBYTE) lpDatablockHeader;
    ((LPFREEKEY_RECORD) lpDestination)-> AllocatedSize = lpDatablockInfo->
        FreeBytes;
    ((LPFREEKEY_RECORD) lpDestination)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpDestination)-> NextFreeOffset = REG_NULL;

    //  The key record table is now invalid, so we must refresh its contents.
    RgBuildKeyRecordTable(lpDatablockInfo);

    return TRUE;

}

//
//  RgCreateDatablock
//
//  Creates a new datablock at the end of the file of the specified length (plus
//  padding to align the block).
//
//  The datablock is locked, so RgUnlockDatablock must be called on the last
//  datablock in the file.
//

int
INTERNAL
RgCreateDatablock(
    LPFILE_INFO lpFileInfo,
    UINT Length
    )
{

    UINT BlockCount;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (BlockCount >= DATABLOCKS_PER_FILE)
        return ERROR_OUTOFMEMORY;

    if (BlockCount >= lpFileInfo-> DatablockInfoAllocCount) {

        //  lpDatablockInfo is too small to hold the info for a new datablock,
        //  so we must grow it a bit.
        if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
            RgSmReAllocMemory(lpFileInfo-> lpDatablockInfo, (BlockCount +
            DATABLOCK_INFO_SLACK_ALLOC) * sizeof(DATABLOCK_INFO)))))
            return ERROR_OUTOFMEMORY;

        lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
        lpFileInfo-> DatablockInfoAllocCount += DATABLOCK_INFO_SLACK_ALLOC;

    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockCount);

    Length = RgAlignBlockSize(Length + sizeof(DATABLOCK_HEADER));
    lpDatablockInfo-> BlockSize = Length;

    if (RgAllocDatablockInfoBuffers(lpDatablockInfo) != ERROR_SUCCESS)
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> FreeBytes = Length - sizeof(DATABLOCK_HEADER);
    lpDatablockInfo-> FirstFreeIndex = 0;
    lpDatablockInfo-> FileOffset = -1;          //  Set during file flush
    lpDatablockInfo-> Flags = DIF_PRESENT | DIF_ACCESSED | DIF_DIRTY;
    lpDatablockInfo-> LockCount = 1;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    lpDatablockHeader-> Signature = DH_SIGNATURE;
    lpDatablockHeader-> BlockSize = Length;
    lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
    lpDatablockHeader-> Flags = DHF_HASBLOCKNUMBERS;
    lpDatablockHeader-> BlockIndex = (WORD) BlockCount;
    lpDatablockHeader-> FirstFreeOffset = sizeof(DATABLOCK_HEADER);
    lpDatablockHeader-> MaxAllocatedIndex = 0;
    //  lpDatablockHeader-> FirstFreeIndex is copied back on the flush.
    //  lpDatablockHeader-> Reserved is worthless because it was randomly set
    //      to a pointer in the old code.

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
        sizeof(DATABLOCK_HEADER));
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpFreeKeyRecord-> DatablockAddress = REG_NULL;
    lpFreeKeyRecord-> NextFreeOffset = REG_NULL;

    lpFileInfo-> FileHeader.BlockCount++;
    lpFileInfo-> FileHeader.Flags |= FHF_DIRTY;
    //  Extending a datablock does not necessarily mean "rewrite the
    //  whole file again", but it works for now...
    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

    //  We must initialize the key record table, so we might as well let
    //  RgBuildKeyRecordTable check the validity of what we just created...
    return RgBuildKeyRecordTable(lpDatablockInfo);

}

//
//  RgExtendDatablock
//
//  Extends the given datablock to the specified size.  If successful, then the
//  resulting datablock will be compacted with a single FREEKEY_RECORD at the
//  end of the datablock which will include the added space.
//

int
INTERNAL
RgExtendDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    DWORD NewBlockSize;
    LPDATABLOCK_HEADER lpNewDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    //  Check if enough free bytes already exist: if so, no need to extend.
    if (lpDatablockInfo-> FreeBytes >= Length) {
        DEBUG_OUT(("RgExtendDatablock: unexpectedly called\n"));
        return ERROR_SUCCESS;
    }

    NewBlockSize = RgAlignBlockSize(lpDatablockInfo-> BlockSize + Length -
        lpDatablockInfo-> FreeBytes);

    if (NewBlockSize > MAXIMUM_DATABLOCK_SIZE) {
        TRACE(("RgExtendDatablock: datablock too big\n"));
        return ERROR_OUTOFMEMORY;
    }

    NOISE(("RgExtendDatablock: block %d\n", BlockIndex));
    NOISE(("block size=%x, new block size=%x\n", lpDatablockInfo-> BlockSize,
        NewBlockSize));

    if (IsNullPtr((lpNewDatablockHeader = (LPDATABLOCK_HEADER)
        RgReAllocMemory(lpDatablockInfo-> lpDatablockHeader, (UINT)
        NewBlockSize))))
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> lpDatablockHeader = lpNewDatablockHeader;

    RgCompactDatablock(lpDatablockInfo);

    if (lpNewDatablockHeader-> FirstFreeOffset == REG_NULL) {
        lpNewDatablockHeader-> FirstFreeOffset = lpDatablockInfo-> BlockSize;
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
            SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
        lpFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpFreeKeyRecord-> NextFreeOffset = REG_NULL;
    }

    else {
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
            SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
    }

    lpDatablockInfo-> FreeBytes += (UINT) NewBlockSize - lpDatablockInfo->
        BlockSize;
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpDatablockInfo-> BlockSize = (UINT) NewBlockSize;

    lpDatablockInfo-> Flags |= (DIF_DIRTY | DIF_EXTENDED);
    //  Extending a datablock does not necessarily mean "rewrite the
    //  whole file again", but it works for now...
    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordFromDatablock
//
//  Creates an uninitialized KEY_RECORD of the desired size from the provided
//  datablock.  On exit, only AllocatedSize is valid.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecordFromDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    LPFREEKEY_RECORD lpNewFreeKeyRecord;
    UINT ExtraBytes;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    if (Length > lpDatablockInfo-> FreeBytes)
        return ERROR_OUTOFMEMORY;

    RgCompactDatablock(lpDatablockInfo);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
        SmallDword(lpDatablockHeader-> FirstFreeOffset));

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (Length > AllocatedSize) {
        TRACE(("RgAllocKeyRecordFromDatablock() detected corruption?\n"));
        return ERROR_OUTOFMEMORY;
    }

    ExtraBytes = AllocatedSize - Length;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        lpNewFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
            Length);

        lpDatablockHeader-> FirstFreeOffset += Length;

        lpFreeKeyRecord-> AllocatedSize = Length;

	//  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
	//  overlap so we have to be careful when changing these fields!
	lpNewFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpNewFreeKeyRecord-> DatablockAddress = REG_NULL;
	lpNewFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        Length = AllocatedSize;

        lpDatablockHeader-> FirstFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

    }

    //  Adjust the number of free bytes in this datablock.  At this point,
    //  Length is equal to the size of the newly formed record.
    lpDatablockInfo-> FreeBytes -= Length;

    *lplpKeyRecord = (LPKEY_RECORD) lpFreeKeyRecord;
    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordIndex
//
//  Allocates a key record index from the provided datablock.  If no indexs
//  are available in the datablock, then KEY_RECORDS_PER_DATABLOCK is returned.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

UINT
INTERNAL
RgAllocKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT KeyRecordIndex;
    UINT NextFreeIndex;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTableEntry;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    KeyRecordIndex = lpDatablockInfo-> FirstFreeIndex;
    NextFreeIndex = KeyRecordIndex + 1;

    ASSERT(KeyRecordIndex < KEY_RECORDS_PER_DATABLOCK);
    ASSERT(IsNullKeyRecordTableEntry(lpDatablockInfo->
        lpKeyRecordTable[KeyRecordIndex]));

    if (KeyRecordIndex > lpDatablockHeader-> MaxAllocatedIndex)
        lpDatablockHeader-> MaxAllocatedIndex = (WORD) KeyRecordIndex;

    else {

        //  Find the next free hole in the key record table or leave ourselves
        //  at the end of the table.
        for (lpKeyRecordTableEntry =
            &lpDatablockInfo-> lpKeyRecordTable[NextFreeIndex]; NextFreeIndex <=
            lpDatablockHeader-> MaxAllocatedIndex; NextFreeIndex++,
            lpKeyRecordTableEntry++) {
            if (IsNullKeyRecordTableEntry(*lpKeyRecordTableEntry))
                break;
        }

    }

    lpDatablockInfo-> FirstFreeIndex = NextFreeIndex;

    return KeyRecordIndex;

}

//
//  RgAllocKeyRecord
//
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    BOOL fExtendDatablock;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT KeyRecordIndex;

    if (lpFileInfo-> FileHeader.BlockCount == 0)
        goto MakeNewDatablock;

    //
    //  Find a datablock that can satisfy the allocation request.  Two passes
    //  may be made over this routine-- during the second pass, datablocks may
    //  be extended.
    //

    fExtendDatablock = FALSE;

DoSecondPass:
    BlockIndex = lpFileInfo-> FileHeader.BlockCount;
    //  We overindex by one, but this gets decremented at the start of the loop.
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    while (BlockIndex--) {

        lpDatablockInfo--;

        //  Are there any more ids available in this datablock?
        if (lpDatablockInfo-> FirstFreeIndex >= KEY_RECORDS_PER_DATABLOCK)
            continue;

        if (fExtendDatablock) {
            //  Can we grow this datablock without exceeding the maximum size?
            if ((DWORD) (lpDatablockInfo-> BlockSize - lpDatablockInfo->
                FreeBytes) + Length > MAXIMUM_DATABLOCK_SIZE)
                continue;
        }
        else {
            //  Is there enough free space in this datablock for this record?
            if (Length > lpDatablockInfo-> FreeBytes)
                continue;
        }

        if (RgLockDatablock(lpFileInfo, BlockIndex) == ERROR_SUCCESS) {

            if (!fExtendDatablock || RgExtendDatablock(lpFileInfo, BlockIndex,
                Length) == ERROR_SUCCESS) {

                if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex,
                    Length, lplpKeyRecord) == ERROR_SUCCESS)
                    goto AllocatedKeyRecord;

            }

            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

        }

    }

    //  If we haven't already tried to extend some datablock, make another
    //  pass over the blocks to do so.
    if (!fExtendDatablock) {
        fExtendDatablock = TRUE;
        goto DoSecondPass;
    }

    //
    //  No datablock has enough space to satisfy the request, so attempt to
    //  create a new one at the end of the file.
    //

MakeNewDatablock:
    if (RgCreateDatablock(lpFileInfo, Length) == ERROR_SUCCESS) {

        BlockIndex = lpFileInfo-> FileHeader.BlockCount - 1;
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex, Length,
            lplpKeyRecord) == ERROR_SUCCESS) {

AllocatedKeyRecord:
            KeyRecordIndex = RgAllocKeyRecordIndex(lpDatablockInfo);
            (*lplpKeyRecord)-> DatablockAddress = MAKELONG(KeyRecordIndex,
                BlockIndex);
            lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
                (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
                (LPBYTE) lpDatablockInfo-> lpDatablockHeader);
            return ERROR_SUCCESS;

        }

        RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgExtendKeyRecord
//
//  Attempts to extend the given KEY_RECORD by combining it with an adjacent
//  FREE_RECORD.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  Returns ERROR_SUCCESS if the KEY_RECORD could be extended, else
//  ERROR_OUTOFMEMORY.
//

int
INTERNAL
RgExtendKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD lpKeyRecord
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    UINT FreeSizeAllocation;
    UINT ExtraBytes;
    LPFREEKEY_RECORD lpTempFreeKeyRecord;
    DWORD NewFreeOffset;                    //  May be REG_NULL
    UINT FreeOffset;
    DWORD Offset;                           //  May be REG_NULL

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    AllocatedSize = SmallDword(lpKeyRecord-> AllocatedSize);

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpKeyRecord +
        AllocatedSize);
    FreeOffset = (LPBYTE) lpFreeKeyRecord - (LPBYTE) lpDatablockHeader;

    //  Check if this key record is at the very end of the datablock and that
    //  lpFreeKeyRecord is really a free key record.
    if (FreeOffset >= lpDatablockInfo-> BlockSize ||
        !IsKeyRecordFree(lpFreeKeyRecord))
        return ERROR_OUTOFMEMORY;

    ASSERT(Length >= AllocatedSize);
    FreeSizeAllocation = Length - AllocatedSize;

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (FreeSizeAllocation > AllocatedSize)
        return ERROR_OUTOFMEMORY;

    ExtraBytes = AllocatedSize - FreeSizeAllocation;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        NewFreeOffset = FreeOffset + FreeSizeAllocation;
        lpTempFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
            FreeSizeAllocation);

	//  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
	//  overlap so we have to be careful when changing these fields!
        lpTempFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpTempFreeKeyRecord-> DatablockAddress = REG_NULL;
	lpTempFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        NewFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

        //  The key record's allocated length will also include all of the extra
        //  bytes.
        FreeSizeAllocation += ExtraBytes;

    }

    lpKeyRecord-> AllocatedSize += FreeSizeAllocation;
    lpDatablockInfo-> FreeBytes -= FreeSizeAllocation;

    //
    //  Unlink the free record that we just extended into and possibly link in
    //  the new FREEKEY_RECORD if a split occurred.
    //

    Offset = lpDatablockHeader-> FirstFreeOffset;

    if (Offset == FreeOffset) {
        lpDatablockHeader-> FirstFreeOffset = NewFreeOffset;
    }

    else {

        while (Offset != REG_NULL) {

            lpTempFreeKeyRecord =
                (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                SmallDword(Offset));

            Offset = lpTempFreeKeyRecord-> NextFreeOffset;

            if (Offset == FreeOffset) {
                lpTempFreeKeyRecord-> NextFreeOffset = NewFreeOffset;
                break;
            }

        }

    }

    return ERROR_SUCCESS;

}

//
//  RgFreeKeyRecord
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

VOID
INTERNAL
RgFreeKeyRecord(
    LPDATABLOCK_INFO lpDatablockInfo,
    LPKEY_RECORD lpKeyRecord
    )
{

    LPDATABLOCK_HEADER lpDatablockHeader;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    ((LPFREEKEY_RECORD) lpKeyRecord)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpKeyRecord)-> NextFreeOffset = lpDatablockHeader->
        FirstFreeOffset;
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpKeyRecord - (LPBYTE)
        lpDatablockHeader;
    lpDatablockInfo-> FreeBytes += SmallDword(((LPFREEKEY_RECORD) lpKeyRecord)->
        AllocatedSize);

}

//
//  RgFreeKeyRecordIndex
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  We don't bother updated MaxAllocatedIndex because it's only really useful
//  if we're always freeing from the maximum index to zero.  This is very
//  rarely the case, so no point in keeping that test around or touching the
//  datablock header page just to do it.
//

VOID
INTERNAL
RgFreeKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo,
    UINT KeyRecordIndex
    )
{

    ASSERT(lpDatablockInfo-> lpDatablockHeader-> MaxAllocatedIndex >=
	KeyRecordIndex);

    if (lpDatablockInfo-> FirstFreeIndex > KeyRecordIndex)
        lpDatablockInfo-> FirstFreeIndex = KeyRecordIndex;

    lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
        NULL_KEY_RECORD_TABLE_ENTRY;

}

//
//  RgWriteDatablocks
//
//  Writes all dirty datablocks to the file specified by the file handle.
//

int
INTERNAL
RgWriteDatablocks(
    LPFILE_INFO lpFileInfo,
    HFILE hSourceFile,
    HFILE hDestinationFile
    )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        if (lpDatablockInfo-> Flags & DIF_PRESENT) {

            //  The block is currently in memory.  If we're either extending
            //  the file or the block is dirty, then write out our in-memory
            //  copy to disk.
            if (hSourceFile != HFILE_ERROR || lpDatablockInfo-> Flags &
                DIF_DIRTY) {

                NOISE(("writing datablock #%d of ", BlockIndex));
                NOISE((lpFileInfo-> FileName));
                NOISE(("\n"));

                lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

                //  Copy back the fields that we've been maintaining in the
                //  DATABLOCK_INFO structure.
                lpDatablockHeader-> BlockSize = lpDatablockInfo-> BlockSize;
                lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
                lpDatablockHeader-> FirstFreeIndex = (WORD) lpDatablockInfo->
                    FirstFreeIndex;

                //  The checksum is not currently calculated, so we must clear
                //  the flag so we don't confuse Win95.
                lpDatablockHeader-> Flags &= ~DHF_HASCHECKSUM;

                if (!RgSeekFile(hDestinationFile, FileOffset))
                    return ERROR_REGISTRY_IO_FAILED;

                if (!RgWriteFile(hDestinationFile, lpDatablockHeader,
                    lpDatablockInfo-> BlockSize))
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        else {

            //  The block is not currently in memory.  If we're extending the
            //  file, then we must write out this datablock.  The overhead is
            //  too great to lock the datablock down, so just copy it from the
            //  original file to the extended file.
            if (hSourceFile != HFILE_ERROR) {

                if (RgCopyFileBytes(hSourceFile, lpDatablockInfo-> FileOffset,
                    hDestinationFile, FileOffset, lpDatablockInfo->
                    BlockSize) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteDatablocksComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteDatablocksComplete(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        lpDatablockInfo-> Flags &= ~DIF_DIRTY;
        lpDatablockInfo-> FileOffset = FileOffset;

        FileOffset += lpDatablockInfo-> BlockSize;

    }

}

//
//  RgSweepDatablocks
//
//  Makes a pass through all the present datablocks of the given FILE_INFO
//  structure and discards datablocks that have not been accessed since the last
//  sweep.
//

VOID
INTERNAL
RgSweepDatablocks(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlocksLeft;
    LPDATABLOCK_INFO lpDatablockInfo;

    for (BlocksLeft = lpFileInfo-> FileHeader.BlockCount, lpDatablockInfo =
        lpFileInfo-> lpDatablockInfo; BlocksLeft > 0; BlocksLeft--,
        lpDatablockInfo++) {

        if (((lpDatablockInfo-> Flags & (DIF_PRESENT | DIF_ACCESSED |
            DIF_DIRTY)) == DIF_PRESENT) && (lpDatablockInfo-> LockCount == 0)) {

            NOISE(("discarding datablock #%d of ",
                lpFileInfo-> FileHeader.BlockCount - BlocksLeft));
            NOISE((lpFileInfo-> FileName));
            NOISE(("\n"));

            RgFreeDatablockInfoBuffers(lpDatablockInfo);

            lpDatablockInfo-> Flags = 0;

        }

        //  Reset the accessed bit for the next sweep.
        lpDatablockInfo-> Flags &= ~DIF_ACCESSED;

    }

}

//
//  RgIsValidDatablockHeader
//
//  Returns TRUE if lpDatablockHeader is a valid DATABLOCK_HEADER structure.
//

BOOL
INTERNAL
RgIsValidDatablockHeader(
    LPDATABLOCK_HEADER lpDatablockHeader
    )
{

    if (lpDatablockHeader-> Signature != DH_SIGNATURE ||
        HIWORD(lpDatablockHeader-> BlockSize) != 0)
        return FALSE;

    return TRUE;

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitDatablockInfo
//
//  Initializes fields in the provided FILE_INFO related to the datablocks.
//

int
INTERNAL
RgInitDatablockInfo(
    LPFILE_INFO lpFileInfo,
    HFILE hFile
    )
{

    UINT BlockCount;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;
    DATABLOCK_HEADER DatablockHeader;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
        RgSmAllocMemory((BlockCount + DATABLOCK_INFO_SLACK_ALLOC) *
        sizeof(DATABLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpDatablockInfo, BlockCount * sizeof(DATABLOCK_INFO));
    lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
    lpFileInfo-> DatablockInfoAllocCount = BlockCount +
        DATABLOCK_INFO_SLACK_ALLOC;

    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex++,
        lpDatablockInfo++) {

        if (!RgSeekFile(hFile, FileOffset))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgReadFile(hFile, &DatablockHeader, sizeof(DATABLOCK_HEADER)))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgIsValidDatablockHeader(&DatablockHeader))
            return ERROR_BADDB;

        //  Following fields already zeroed by above ZeroMemory.
        //  lpDatablockInfo-> lpDatablockHeader = NULL;
        //  lpDatablockInfo-> lpKeyRecordTable = NULL;
        //  lpDatablockInfo-> Flags = 0;
        //  lpDatablockInfo-> LockCount = 0;

        lpDatablockInfo-> FileOffset = FileOffset;

        //  Cache these fields from the datablock header.  These fields should
        //  not be considered valid when the datablock is physically in memory.
        lpDatablockInfo-> BlockSize = SmallDword(DatablockHeader.BlockSize);
        lpDatablockInfo-> FreeBytes = SmallDword(DatablockHeader.FreeBytes);
        lpDatablockInfo-> FirstFreeIndex = DatablockHeader.FirstFreeIndex;

        NOISE(("DB#%d fileoff=%lx, size=%x free=%x 1stindex=%d\n", BlockIndex,
            FileOffset, lpDatablockInfo-> BlockSize, lpDatablockInfo->
            FreeBytes, lpDatablockInfo-> FirstFreeIndex));

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regdblk.h ===
//
//  REGDBLK.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGDBLK_
#define _REGDBLK_

int
INTERNAL
RgInitDatablockInfo(
    LPFILE_INFO lpFileInfo,
    HFILE hFile
    );

int
INTERNAL
RgLockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex
    );

VOID
INTERNAL
RgUnlockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgLockKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BYTE KeyRecordIndex,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgWriteDatablocks(
    LPFILE_INFO lpFileInfo,
    HFILE hSourceFile,
    HFILE hDestinationFile
    );

VOID
INTERNAL
RgWriteDatablocksComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepDatablocks(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeyRecordFromDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgAllocKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgExtendKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    );

VOID
INTERNAL
RgFreeKeyRecord(
    LPDATABLOCK_INFO lpDatablockInfo,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo,
    UINT KeyRecordIndex
    );

#endif // _REGDBLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regdebug.c ===
//
//  REGDEBUG.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

//  VXD_NODEBUGGER:  Uses debug services available when a debugger is not
//  installed, but at the cost of an intermediate debug buffer.
//#define VXD_NODEBUGGER

#ifdef DEBUG

#include <stdarg.h>

#ifdef STDIO_DEBUG
#include <stdio.h>
#else
static char g_RgDebugBuffer[256];
#endif

#ifdef VXD_NODEBUGGER
extern	ULONG	(SERVICE*_Vsprintf)(PCHAR,PCHAR,va_list);
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    )
{

    va_list arglist;

    va_start(arglist, lpFormatString);

#ifdef STDIO_DEBUG
    vprintf(lpFormatString, arglist);
#else
#ifdef VXD
#ifdef VXD_NODEBUGGER
    _Vsprintf(g_RgDebugBuffer, (PCHAR) lpFormatString, arglist);
    _Debug_Out_Service(g_RgDebugBuffer);
#else
    _Debug_Printf_Service((PCHAR) lpFormatString, arglist);
#endif
#else
    wvsprintf(g_RgDebugBuffer, lpFormatString, arglist);
    OutputDebugString(g_RgDebugBuffer);
#endif
#endif

}

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    )
{

    RgDebugPrintf("assert failed %s@%d\n", lpFile, LineNumber);

    TRAP();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regdebug.h ===
//
//  DEBUG.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _DEBUG_
#define _DEBUG_

#ifdef DEBUG

//  Disable the "in-line assembler precludes global optimizations" warning
//  because of debug breaks.
#pragma warning(disable:4704)

#if !defined(WIN32) || defined(_X86_)
#define TRAP()                      _asm {int 3}
#else
#define TRAP()                      DebugBreak()
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    );

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    );

#define TRACE(x)    RgDebugPrintf ##x

#ifdef REGDEBUG
#define NOISE(x)    RgDebugPrintf ##x
#else
#define NOISE(x)
#endif

#define ASSERT(x)   ((x) ? (VOID) 0 : RgDebugAssert(__FILE__, __LINE__))

#define DECLARE_DEBUG_COUNT(var)    int var = 0;
#define INCREMENT_DEBUG_COUNT(var)  ((var)++)
#define DECREMENT_DEBUG_COUNT(var)  ASSERT(((var)--))

#if !defined(WIN32) || defined(_X86_)
#define DEBUG_OUT(x)                { TRACE(x); _asm {int 1}; }
#else
#define DEBUG_OUT(x)                { TRACE(x); TRAP(); }
#endif

#else
#define TRAP()
#define TRACE(x)
#define NOISE(x)
#define ASSERT(x)
#define DECLARE_DEBUG_COUNT(var)
#define INCREMENT_DEBUG_COUNT(var)
#define DECREMENT_DEBUG_COUNT(var)
#define DEBUG_OUT(x)
#endif

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\pch.h ===
//
//  PCH.H
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//

#ifndef _REGPRIV_
#define _REGPRIV_

//  Conditional enable registry "features" based on the target model.
//
//  WANT_STATIC_KEYS:  Allocates key handles from a memory pool allocated
//  during library initialization.  Especially useful for real-mode to reduce
//  the memory fragmentation caused by allocating several small fixed objects.
//
//  WANT_FULL_MEMORY_CLEANUP:  When detaching, free every memory block.  Not
//  necessary for the ring zero version where "detach" means system shutdown.
//
//  WANT_HIVE_SUPPORT:  RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey
//  APIs plus support code.
//
//  WANT_DYNKEY_SUPPORT:  RegCreateDynKey plus HKEY_DYN_DATA support.
//
//  WANT_NOTIFY_CHANGE_SUPPORT:  RegNotifyChangeKeyValue plus support code.
#ifndef IS_32
#define WANT_STATIC_KEYS
#endif
#ifndef VXD
#define WANT_FULL_MEMORY_CLEANUP
#endif
#ifndef REALMODE
#define WANT_HIVE_SUPPORT
#endif
#ifdef VXD
#define WANT_REGREPLACEKEY
#define WANT_DYNKEY_SUPPORT
#define WANT_NOTIFY_CHANGE_SUPPORT
#endif

//  Map any other header's definitions of these to unused types.
#define HKEY __UNUSED_HKEY
#define LPHKEY __UNUSED_LPHKEY

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#define NORESOURCE                  //  prevent RT_* definitions from vmmsys.h
#include <windows.h>
#include <string.h>
#ifdef VXD
#error "Cannot compile with VXD defined"
// #include <vmmsys.h>
// #include <thrdsys.h>
#endif

#ifndef UNALIGNED
#define UNALIGNED                   //  defined in standard headers for RISC
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY               1
#endif

#ifdef VXD
//  By default, all registry code and data is pageable.
#pragma VMM_PAGEABLE_CODE_SEG
#pragma VMM_PAGEABLE_DATA_SEG
#endif

#define UNREFERENCED_PARAMETER(P)   (P)

#define INTERNAL                    PASCAL NEAR
#define INTERNALV                   CDECL NEAR

//  Undefine any constants that we're about to define ourselves.
#undef HKEY
#undef LPHKEY
#undef HKEY_CLASSES_ROOT
#undef HKEY_CURRENT_USER
#undef HKEY_LOCAL_MACHINE
#undef HKEY_USERS
#undef HKEY_PERFORMANCE_DATA
#undef HKEY_CURRENT_CONFIG
#undef HKEY_DYN_DATA

typedef struct _KEY FAR*            HKEY;               //  Forward reference

#include "regdebug.h"
#include "regffmt.h"
#include "regfinfo.h"

//  Many file structures in the registry are declared as DWORDs, the HIWORD is
//  always zero.  Use SmallDword to access such DWORDs for optimal access in
//  16-bit or 32-bit code.
#if defined(IS_32)
#define SmallDword(dw)              ((UINT) (dw))
#else
#define SmallDword(dw)              ((UINT) LOWORD((dw)))
#endif

#if defined(WIN16)
#define IsNullPtr(ptr)              (SELECTOROF((ptr)) == NULL)
#else
#define IsNullPtr(ptr)              ((ptr) == NULL)
#endif

//  In either mode, the resulting code uses an instrinsic version of the memcmp
//  function.
#if defined(IS_32)
#define CompareMemory               memcmp
#else
#define CompareMemory               _fmemcmp
#endif

#if defined(WIN16) || defined(WIN32)
#define StrCpy(lpd, lps)            (lstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (lstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (lstrlen((lpstr)))
#define ToUpper(ch)                 ((int) (DWORD) AnsiUpper((LPSTR)((BYTE)(ch))))
#define RgCreateFile(lpfn)          ((HFILE) _lcreat((lpfn), 0))
#define RgOpenFile(lpfn, mode)      ((HFILE) _lopen((lpfn), (mode)))
#define RgCloseFile(h)              ((VOID) _lclose(h))
#if defined(WIN32)
#define RgDeleteFile(lpv)           (DeleteFile((lpv)))
#define RgRenameFile(lpv1, lpv2)    (MoveFile((lpv1), (lpv2)))
#define RgGetFileAttributes(lpv)    (GetFileAttributes((lpv)))
#define RgSetFileAttributes(lpv, a) (SetFileAttributes((lpv), (a)))
#define RgCommitFile(h)             (FlushFileBuffers((HANDLE)h))
#ifdef USEHEAP
extern HANDLE g_RgHeap;             //  Low memory heap for testing
#define AllocBytes(cb)              ((LPVOID) HeapAlloc(g_RgHeap, 0, (cb)))
#define FreeBytes(lpv)              ((VOID) HeapFree(g_RgHeap, 0, (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) HeapReAlloc(g_RgHeap, 0, (lpv), (cb)))
#define MemorySize(lpv)             ((UINT) HeapSize(g_RgHeap, 0, (lpv)))
#else
#define AllocBytes(cb)              ((LPVOID) LocalAlloc(LMEM_FIXED, (cb)))
#define FreeBytes(lpv)              ((VOID) LocalFree((HLOCAL) (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) LocalReAlloc((HLOCAL) (lpv), (cb), LMEM_MOVEABLE))
#define MemorySize(lpv)             ((UINT) LocalSize((lpv)))
#endif // USEHEAP
#else
#define AllocBytes(cb)              ((LPVOID) MAKELP(GlobalAlloc(GMEM_FIXED, (cb)), 0))
#define FreeBytes(lpv)              ((VOID) GlobalFree((HGLOBAL) SELECTOROF((lpv))))
#define ReAllocBytes(lpv, cb)       ((LPVOID) MAKELP(GlobalReAlloc((HGLOBAL) SELECTOROF((lpv)), (cb), GMEM_MOVEABLE), 0))
#define MemorySize(lpv)             ((UINT) GlobalSize((HGLOBAL) SELECTOROF((lpv))))
//  WIN16's ZeroMemory/MoveMemory:  SETUPX is the only target WIN16 environment
//  and they already use _fmemset and _fmemmove, so just use their versions.
#define ZeroMemory(lpv, cb)         (_fmemset((lpv), 0, (cb)))
#define MoveMemory(lpd, lps, cb)    (_fmemmove((lpd), (lps), (cb)))
#endif // WIN16 || WIN32
#elif defined(REALMODE)
#define IsBadStringPtr(lpv, cb)     (FALSE)
#define IsBadHugeWritePtr(lpv, cb)  (FALSE)
#define IsBadHugeReadPtr(lpv, cb)   (FALSE)
#define StrCpy(lpd, lps)            (_fstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (_fstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (_fstrlen((lpstr)))
#define ToUpper(ch)                 ((int)(((ch>='a')&&(ch<='z'))?(ch-'a'+'A'):ch))
LPVOID INTERNAL AllocBytes(UINT);
VOID   INTERNAL FreeBytes(LPVOID);
LPVOID INTERNAL ReAllocBytes(LPVOID, UINT);
UINT   INTERNAL MemorySize(LPVOID);
VOID   INTERNAL ZeroMemory(LPVOID, UINT);
VOID   INTERNAL MoveMemory(LPVOID, const VOID FAR*, UINT);
#elif defined(VXD)
#undef IsBadStringPtr               //  Conflicts with windows.h
#undef ZeroMemory                   //  Conflicts with windows.h
#undef MoveMemory                   //  Conflicts with windows.h
BOOL    INTERNAL RgIsBadStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadOptionalStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeOptionalWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeReadPtr(const VOID FAR*, UINT);
#define IsBadStringPtr(lpv, cb)     (RgIsBadStringPtr((lpv), (cb)))
#define IsBadOptionalStringPtr(lpv, cb)     (RgIsBadOptionalStringPtr((lpv), (cb)))
#define IsBadHugeWritePtr(lpv, cb)  (RgIsBadHugeWritePtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb)  (RgIsBadHugeOptionalWritePtr((lpv), (cb)))
#define IsBadHugeReadPtr(lpv, cb)   (RgIsBadHugeReadPtr((lpv), (cb)))
#define StrCpy(lpd, lps)            (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(-1)))
#define StrCpyN(lpd, lps, cb)       (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(cb)))
#define StrLen(lpstr)               (_lstrlen((PCHAR)(lpstr)))
extern  UCHAR UpperCaseTable[256];
#define ToUpper(ch)                 ((int)(UpperCaseTable[(UCHAR)(ch)]))
VOID	INTERNAL RgSetAndReleaseEvent(HANDLE hEvent);
#define RgGetCurrentThreadId()      ((DWORD)pthcbCur)
#define AllocBytes(cb)              ((LPVOID) _HeapAllocate((cb), HEAPSWAP))
#define FreeBytes(lpv)              ((VOID) _HeapFree((lpv), 0))
#define ReAllocBytes(lpv, cb)       ((LPVOID) _HeapReAllocate((lpv), (cb), HEAPSWAP))
#define MemorySize(lpv)             ((UINT) _HeapGetSize((lpv), 0))
#define AllocPages(cp)              ((LPVOID) _PageAllocate((cp), PG_SYS, 0, 0, 0, 0, NULL, 0))
#define FreePages(lpv)              ((VOID) _PageFree((ULONG) (lpv), 0))
#define ReAllocPages(lpv, cp)       ((LPVOID) _PageReAllocate((ULONG) (lpv), (cp), 0))
VOID   INTERNAL RgZeroMemory(LPVOID, UINT);
VOID   INTERNAL RgMoveMemory(LPVOID, const VOID FAR*, UINT);
#define ZeroMemory                  RgZeroMemory
#define MoveMemory                  RgMoveMemory
#else
#error Must define REALMODE, VXD, WIN16, or WIN32.
#endif

//  The IsBadHugeOptional*Ptr macros are used to validate pointers that may be
//  NULL.  By wrapping this "predicate", we can generate smaller code in some
//  environments, specifically VMM...
#if !defined(VXD)
#define IsBadOptionalStringPtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadStringPtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadHugeWritePtr((lpv), (cb)))
#endif

//  The IsEnumIndexTooBig macro is used to check if a DWORD sized index can fit
//  into a UINT sized variable.  Only useful for validation of RegEnumKey or
//  RegEnumValue to make small code in both 16 and 32 bit environments.
#if defined(IS_32)
#define IsEnumIndexTooBig(index)    (FALSE)
#else
#define IsEnumIndexTooBig(index)    (HIWORD(index) > 0)
#endif

#if defined(VXD)
BOOL INTERNAL RgLockRegistry(VOID);
VOID INTERNAL RgUnlockRegistry(VOID);
VOID INTERNAL RgDelayFlush(VOID);
VOID INTERNAL RgYield(VOID);
#else
#define RgLockRegistry()            (TRUE)
#define RgUnlockRegistry()          (TRUE)
#define RgDelayFlush()              (TRUE)
#define RgYield()                   (TRUE)
#endif

//  Eliminate the need for #ifdef DBCS by using macros and letting the compiler
//  optimize out the DBCS code on SBCS systems.
#ifdef DBCS
#if !defined(WIN16) && !defined(WIN32)
BOOL INTERNAL RgIsDBCSLeadByte(BYTE TestChar);
#define IsDBCSLeadByte(ch)              RgIsDBCSLeadByte(ch)
#endif
#else
#define IsDBCSLeadByte(ch)              ((ch), FALSE)
#endif // DBCS

#ifdef WANT_DYNKEY_SUPPORT
//  Internally used for maintaining dynamic key information; only keeps the
//  fields that we actually need from the REG_PROVIDER structure given to
//  VMMRegCreateDynKey.
typedef struct _INTERNAL_PROVIDER {
    PQUERYHANDLER ipi_R0_1val;
    PQUERYHANDLER ipi_R0_allvals;
    LPVOID ipi_key_context;
}   INTERNAL_PROVIDER, FAR* PINTERNAL_PROVIDER;
#endif

typedef struct _KEY {
    WORD Signature;                             //  KEY_SIGNATURE
    WORD Flags; 				//  KEYF_* bits
    UINT ReferenceCount;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    DWORD ChildKeynodeIndex;
    WORD BlockIndex;
    WORD BigKeyLockedBlockIndex;        // If a bigkey function locked a datablock, this is its index
    BYTE KeyRecordIndex;
    BYTE PredefinedKeyIndex;
    struct _KEY FAR* lpNext;
    struct _KEY FAR* lpPrev;
    UINT LastEnumKeyIndex;
    DWORD LastEnumKeyKeynodeIndex;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
#endif
}   KEY;

#define KEY_SIGNATURE               0x4B48      //  "HK"

#define KEYF_PREDEFINED             0x01        //  Represents one of HKEY_*
#define KEYF_DELETED                0x02        //
#define KEYF_INVALID                0x04        //
#define KEYF_STATIC                 0x08        //  Allocated from static pool
#define KEYF_ENUMKEYCACHED          0x10        //  LastEnumKey* values valid
#define KEYF_HIVESALLOWED           0x20        //
#define KEYF_PROVIDERHASVALUELENGTH 0x40        //  PROVIDER_KEEPS_VALUE_LENGTH
#define KEYF_NEVERDELETE            0x80        //  Reference count overflow
#define KEYF_BIGKEYROOT             0x100       //  This key handle is for a big key
#define KEYF_ENUMEXTENTCACHED       0x200       //  LastEnumKey* is for a big key extent

#define INDEX_CLASSES_ROOT          0
#define INDEX_CURRENT_USER          1
#define INDEX_LOCAL_MACHINE         2
#define INDEX_USERS                 3
#define INDEX_PERFORMANCE_DATA      4
#define INDEX_CURRENT_CONFIG        5
#define INDEX_DYN_DATA              6

//  Returns TRUE if the KEY references the root of a hive, such as
//  HKEY_LOCAL_MACHINE, HKEY_USERS, or any hive loaded by RegLoadKey.
#define IsKeyRootOfHive(hkey)       \
    ((hkey)-> KeynodeIndex == (hkey)-> lpFileInfo-> KeynodeHeader.RootIndex)

//  Returns TRUE if the KEY is a subkey of HKEY_DYN_DATA.
#ifdef WANT_DYNKEY_SUPPORT
#define IsDynDataKey(hkey)          \
    ((hkey)-> PredefinedKeyIndex == INDEX_DYN_DATA)
#else
#define IsDynDataKey(hkey)          (FALSE)
#endif

#include <regapix.h>
#include "regkylst.h"
#include "regdblk.h"
#include "regknode.h"
#include "regnckey.h"
#include "regfsio.h"
#include "regmem.h"


#define ERROR_BIGKEY_NEEDED             1025L   // Internal error, the data won't fit in a normal key

#ifdef VXD
extern BYTE g_RgPostCriticalInit;
extern BYTE g_RgFileAccessDisabled;
#define IsPostCriticalInit()        (g_RgPostCriticalInit)
#define IsFileAccessDisabled()      (g_RgFileAccessDisabled)
#else
#define IsPostCriticalInit()        (TRUE)
#define IsFileAccessDisabled()      (FALSE)
#endif

//  g_RgWorkBuffer: one buffer is always available of size SIZEOF_WORK_BUFFER.
//  These macros wrap access to this buffer for to verify only one routine is
//  attempting to use it at any time.
extern LPVOID g_RgWorkBuffer;
#ifdef DEBUG
extern BOOL g_RgWorkBufferBusy;
#define RgLockWorkBuffer()          \
    (ASSERT(!g_RgWorkBufferBusy), g_RgWorkBufferBusy = TRUE, (LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)     \
    (VOID) (ASSERT((lpv) == g_RgWorkBuffer), g_RgWorkBufferBusy = FALSE)
#else
#define RgLockWorkBuffer()          ((LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)
#endif
#define SIZEOF_WORK_BUFFER          (sizeof(W95KEYNODE_BLOCK))

#define IsKeyRecordFree(lpkr) \
    (((lpkr)-> DatablockAddress) == REG_NULL)

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    );

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    );

#define LK_OPEN                     0x0000      //  Open key only
#define LK_CREATE                   0x0001      //  Create or open key
#define LK_CREATEDYNDATA            0x0002      //  HKEY_DYN_DATA may create
#define LK_BIGKEYEXT                0x0004      //  Search only for big key extents

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    );

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    );

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName,
    UINT Flags
    );

int
INTERNAL
RgLookupValueByName(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByNameStd(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByIndex(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByIndexStd(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord,
    UINT FAR* lpValueCount
    );

int
INTERNAL
RgCopyFromValueRecord(
    HKEY hKey,
    LPVALUE_RECORD lpValueRecord,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );


VOID
INTERNAL
RgDeleteValueRecord(
    LPKEY_RECORD lpKeyRecord,
    LPVALUE_RECORD lpValueRecord
    );

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    );

int
INTERNAL
RgSetValueStd(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData,
    BOOL fBigKeyExtent
    );

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    );

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    );

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    );

WORD
INTERNAL 
RgAtoW(
    LPCSTR lpDec
      );

VOID
INTERNAL
RgWtoA(
    WORD Dec,
    LPSTR lpDec
      );

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    );

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    );

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    );

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    );

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    );

#endif // _REGPRIV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regdval.c ===
//
//  REGDVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//
//  Implementation of RegDeleteValue and supporting functions.
//

#include "pch.h"

//
//  RgDeleteValueRecord
//
//  Deletes the specified VALUE_RECORD from the provided KEY_RECORD.
//

VOID
INTERNAL
RgDeleteValueRecord(
    LPKEY_RECORD lpKeyRecord,
    LPVALUE_RECORD lpValueRecord
    )
{

    UINT ValueRecordLength;
    LPBYTE lpSource;
    UINT BytesToPushDown;

    ASSERT(lpKeyRecord-> ValueCount > 0);

    ValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord-> NameLength +
        lpValueRecord-> DataLength - 1;

    ASSERT(lpKeyRecord-> RecordSize >= ValueRecordLength);

    //
    //  If this isn't the last value of this KEY_RECORD, then push down any
    //  VALUE_RECORDs after the VALUE_RECORD to delete.
    //

    if (--lpKeyRecord-> ValueCount) {

        lpSource = (LPBYTE) lpValueRecord + ValueRecordLength;

        BytesToPushDown = (UINT) ((LPBYTE) lpKeyRecord + lpKeyRecord->
            RecordSize - lpSource);

        MoveMemory((LPBYTE) lpValueRecord, lpSource, BytesToPushDown);

    }

    lpKeyRecord-> RecordSize -= ValueRecordLength;

}

//
//  VMMRegDeleteValue
//
//  See Win32 documentation of RegDeleteValue.
//

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    LPCSTR lpValueName
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord)) == ERROR_SUCCESS) {

            if (IsDynDataKey(hKey) || (hKey-> lpFileInfo-> Flags & FI_READONLY))
                ErrorCode = ERROR_ACCESS_DENIED;
            else {
                RgDeleteValueRecord(lpKeyRecord, lpValueRecord);
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, TRUE);

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regdykey.c ===
//
//  REGDYKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegCreateDynKey and supporting functions.
//

#include "pch.h"

#ifdef WANT_DYNKEY_SUPPORT

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  VMMRegCreateDynKey
//
//  See VMM DDK of _RegCreateDynKey.
//

LONG
REGAPI
VMMRegCreateDynKey(
    LPCSTR lpKeyName,
    LPVOID KeyContext,
    PPROVIDER pProvider,
    PPVALUE pValueList,
    DWORD ValueCount,
    LPHKEY lphKey
    )
{

    LONG ErrorCode;
    HKEY hKey;
    PINTERNAL_PROVIDER pProviderCopy;
    PPVALUE pCurrentValue;

    if (IsBadHugeReadPtr(pProvider, sizeof(REG_PROVIDER)) ||
        (IsNullPtr(pProvider-> pi_R0_1val) &&
        IsNullPtr(pProvider-> pi_R0_allvals)) ||
        IsBadHugeReadPtr(pValueList, sizeof(PVALUE) * ValueCount))
        return ERROR_INVALID_PARAMETER;

    //  The key could currently exist.  Win95 didn't handle this case,
    //  so would we have problems changing this behavior now?
    if ((ErrorCode = RgCreateOrOpenKey(HKEY_DYN_DATA, lpKeyName, &hKey,
        LK_CREATE | LK_CREATEDYNDATA)) != ERROR_SUCCESS)
        return ErrorCode;

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {

        pProviderCopy = RgSmAllocMemory(sizeof(INTERNAL_PROVIDER));

        if (IsNullPtr(pProviderCopy))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            //  ErrorCode = ERROR_SUCCESS;  //  Must be true if we're here...

            hKey-> pProvider = pProviderCopy;

            //  If no "get single" callback was provided, we can just use the
            //  "get atomic" callback.
            if (IsNullPtr(pProvider-> pi_R0_1val))
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_allvals;
            else
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_1val;

            pProviderCopy-> ipi_R0_allvals = pProvider-> pi_R0_allvals;
            pProviderCopy-> ipi_key_context = KeyContext;

            //  No point in keeping a whole DWORD for one bit when we can fit
            //  it inside the main key structure.
            if (pProvider-> pi_flags & PROVIDER_KEEPS_VALUE_LENGTH)
                hKey-> Flags |= KEYF_PROVIDERHASVALUELENGTH;

            //  Loop over all the values and store each name in the registry
            //  with a partial PVALUE record as the value's data.
            for (pCurrentValue = pValueList; ValueCount > 0; ValueCount--,
                pCurrentValue++) {

                if (IsBadStringPtr(pCurrentValue-> pv_valuename, (UINT) -1)) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    break;
                }

                //  Skip storing the pv_valuename field.
                if ((ErrorCode = RgSetValue(hKey, pCurrentValue-> pv_valuename,
                    REG_BINARY, (LPBYTE) &(pCurrentValue-> pv_valuelen),
                    sizeof(PVALUE) - FIELD_OFFSET(PVALUE, pv_valuelen))) !=
                    ERROR_SUCCESS) {
                    TRAP();
                    break;
                }

            }

        }

        RgUnlockRegistry();

    }

    //  Win95 difference: on an error, don't modify lphKey and close the key
    //  created above.
    if (ErrorCode == ERROR_SUCCESS)
        *lphKey = hKey;
    else
        VMMRegCloseKey(hKey);

    return ErrorCode;

}

#endif // WANT_DYNKEY_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regdkey.c ===
//
//  REGDKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegDeleteKey and supporting functions.
//

#include "pch.h"

//
//  RgFreeDatablockStructures
//
//  Helper routine for RgDeleteKey.  Deletes the specified datablock structures.
//  The datablock is not assumed to be locked.  We don't care about the success
//  of this routine-- in the worst case, some stuff will be orphaned in the
//  file.
//

VOID
INTERNAL
RgFreeDatablockStructures(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT KeyRecordIndex
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(lpFileInfo, BlockIndex, (BYTE) KeyRecordIndex,
        &lpKeyRecord) == ERROR_SUCCESS) {
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
        RgFreeKeyRecord(lpDatablockInfo, lpKeyRecord);
        RgFreeKeyRecordIndex(lpDatablockInfo, KeyRecordIndex);
        RgUnlockDatablock(lpFileInfo, BlockIndex, TRUE);
    }

}

//
//  RgDeleteKey
//
//  Worker routine for VMMRegDeleteKey.  The given key handle references a key
//  that has already been validated as "deleteable".
//

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    LPKEYNODE lpKeynode;
    DWORD NextKeynodeIndex;
    LPKEYNODE lpNextKeynode;
    DWORD ReplacementKeynodeIndex;
    HKEY hTempKey;

    lpFileInfo = hKey-> lpFileInfo;

    //
    //  Stage one: unlink the keynode of the specified key from the keynode
    //  tree and free all associate file structures with the key.
    //

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    KeynodeIndex = lpKeynode-> ParentIndex;
    ReplacementKeynodeIndex = lpKeynode-> NextIndex;
    RgUnlockKeynode(lpFileInfo, hKey-> KeynodeIndex, FALSE);

    //  Signal any waiting notifies on the parent that this key is about to be
    //  deleted.
    //
    //  Note that we may fail below, but NT does _exactly_ the same thing in
    //  this case: doesn't care.  If we get an error and don't actually delete
    //  this key, then we'll have sent a spurious notify.
    //
    //  Note also that we don't send any notification that the key itself has
    //  been deleted.  REG_NOTIFY_CHANGE_NAME is supposed to be for subkey
    //  changes only, not changes to the key itself.  But because of the
    //  incompatible way we must deal with subkeys of the key we're about to
    //  delete, we may well end up notifying the key if it has subkeys.
    RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex, REG_NOTIFY_CHANGE_NAME);

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    //  The per-key cache that we use for RegEnumKey may be invalid, so it must
    //  be zapped.
    if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex)))
        hTempKey-> Flags &= ~KEYF_ENUMKEYCACHED;

    NextKeynodeIndex = lpKeynode-> ChildIndex;

    if (NextKeynodeIndex == hKey-> KeynodeIndex) {

        //  Update the cached child keynode index in the open handle on the
        //  parent.
        if (!IsNullPtr(hTempKey))
            hTempKey-> ChildKeynodeIndex = ReplacementKeynodeIndex;

        //  This is the parent of the keynode that we need to delete.  Replace
        //  it's "child" link.
        lpKeynode-> ChildIndex = ReplacementKeynodeIndex;

    }

    else {

        //  Loop through the siblings of the keynode we're trying to delete.
        do {

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            KeynodeIndex = NextKeynodeIndex;

            if (IsNullKeynodeIndex(KeynodeIndex)) {
                DEBUG_OUT(("RgDeleteKey: couldn't find the keynode to delete\n"));
                return ERROR_BADDB;
            }

            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            NextKeynodeIndex = lpKeynode-> NextIndex;

        }   while (NextKeynodeIndex != hKey-> KeynodeIndex);

        //  This is the previous sibling of the keynode that we need to delete.
        //  Replace it's "next" link.
        lpKeynode-> NextIndex = ReplacementKeynodeIndex;

    }

    //  Unlock the updated "parent" or "next" of this keynode.
    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    //  Free the structures associated with the datablock.
    RgFreeDatablockStructures(lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex);

    //  Free the structures associated with the keynode tables.
    RgFreeKeynode(lpFileInfo, hKey-> KeynodeIndex);

    //  The key is definitely toast now.
    hKey-> Flags |= KEYF_DELETED;

    //
    //  Stage two: the specified key is unlinked, but any of its subkeys now
    //  have to be freed.  Errors are ignored at this point: we won't try to
    //  undo the stuff we did in stage one.  The worst thing that can happen is
    //  that some file structures are orphaned.
    //

    NextKeynodeIndex = hKey-> ChildKeynodeIndex;

    if (IsNullKeynodeIndex(NextKeynodeIndex) || RgLockInUseKeynode(lpFileInfo,
        NextKeynodeIndex, &lpNextKeynode) != ERROR_SUCCESS)
        return ERROR_SUCCESS;

    while (!IsNullKeynodeIndex(NextKeynodeIndex)) {

        KeynodeIndex = NextKeynodeIndex;
        lpKeynode = lpNextKeynode;

        //  Check if the keynode has any children.  If it does and we can lock
        //  it down, then move to it.
        NextKeynodeIndex = lpKeynode-> ChildIndex;

        if (!IsNullKeynodeIndex(NextKeynodeIndex) &&
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) ==
            ERROR_SUCCESS) {

            ASSERT(KeynodeIndex == lpNextKeynode-> ParentIndex);

            RgYield();

            //  "Burn" the link to our child, so that on the way back out of
            //  the tree, we don't end up recursing.  Plus, if we hit any errors
            //  deep in the tree deletion, the child of the current keynode
            //  could have already been toasted, so we have to zap our link to
            //  it.
            lpKeynode-> ChildIndex = REG_NULL;
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

            //  We've now caused a change in the subkeys of the current key.
            //  Note that we don't bother signaling notifies that are doing a
            //  subtree watch because any such notifies should have already been
            //  signaled by the above call or they've already been signaled
            //  during our recursion.  In the off chance that we have a lot of
            //  notifications registered, this will avoid a lot of unnecessary
            //  checking.
            RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_NO_WATCH_SUBTREE);

            continue;

        }

        //  The keynode doesn't have any children.  Check for sibling keynodes.
        NextKeynodeIndex = lpKeynode-> NextIndex;

        if (IsNullKeynodeIndex(NextKeynodeIndex) ||
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) !=
            ERROR_SUCCESS) {

            //  The keynode doesn't have any siblings or we were unable to get
            //  at them.  Move back to the parent.
            NextKeynodeIndex = lpKeynode-> ParentIndex;

            //  If we wrapped back up to the top of the deleted branch or if we
            //  just can't access the parent keynode, then set next to REG_NULL
            //  and bail out on the next iteration.
            if ((NextKeynodeIndex == hKey-> KeynodeIndex) ||
                RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex,
                &lpNextKeynode) != ERROR_SUCCESS)
                NextKeynodeIndex = REG_NULL;

        }

        //  If an open key refers to this file and keynode index, mark it as
        //  deleted.
        if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo,
            KeynodeIndex)))
            hTempKey-> Flags |= KEYF_DELETED;

        //  Free the structures associated with the datablock.
        RgFreeDatablockStructures(lpFileInfo, lpKeynode-> BlockIndex,
            (BYTE) lpKeynode-> KeyRecordIndex);

        //  Free the structures associated with the keynode tables.
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);
        RgFreeKeynode(lpFileInfo, KeynodeIndex);

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegDeleteKey
//
//  See Win32 documentation for a description of the behavior.
//
//  Although the Win32 documentation states that lpSubKey must be NULL, NT
//  actually allows this to pass through.  Win95 rejected the call, but the only
//  reason we didn't change it then was because we realized too late in the
//  product that it was different.
//

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if (IsNullPtr(lpSubKey))
	{
		if (IsNullPtr(hKey))
			return ERROR_BADKEY;
		else
			return ERROR_INVALID_PARAMETER;
	}

    if ((ErrorCode = VMMRegOpenKey(hKey, lpSubKey, &hSubKey)) != ERROR_SUCCESS)
        return ErrorCode;

        //  Don't allow HKEY_LOCAL_MACHINE or HKEY_USERS to be deleted.
    if (hSubKey == &g_RgLocalMachineKey || hSubKey == &g_RgUsersKey)
	{
		if (*lpSubKey == '\0')
		{
			ErrorCode = ERROR_ACCESS_DENIED;
			goto SkipDelete;
		}
		else if (lpSubKey[0] == '\\' && lpSubKey[1] == '\0')
		{
			ErrorCode = ERROR_CANTOPEN16_FILENOTFOUND32;
			goto SkipDelete;
		}
	}

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {
        if (IsKeyRootOfHive(hSubKey) || (hSubKey-> lpFileInfo-> Flags &
            FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else
            ErrorCode = RgDeleteKey(hSubKey);

        RgUnlockRegistry();

    }

SkipDelete:

    VMMRegCloseKey(hSubKey);

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regffmt.h ===
//
//  REGFFMT.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Defines the physical format of a Windows VMM registry file.
//

#ifndef _REGFFMT_
#define _REGFFMT_

#ifdef WIN32
#include <pshpack1.h>
#else
#pragma pack(1)
#endif

#define REG_NULL                    0xFFFFFFFF

typedef struct _FILE_HEADER {
    DWORD Signature;                            //  FH_SIGNATURE
    DWORD Version;                              //  FH_VERSION_*
    DWORD Size;                                 //  of file header, all keynodes
    DWORD Checksum;                             //  of file header
    WORD BlockCount;
    DWORD Flags;                                //  FHF_* bits
    WORD Type;                                  //  FHT_* constant
    BYTE Reserved[8];
}   FILE_HEADER, UNALIGNED FAR* LPFILE_HEADER;

#define FH_SIGNATURE                0x47455243  //  "CREG"
#define FH_VERSION10                0x00010000  //  Win95 compatible
#define FH_VERSION20                0x00020000  //  Supports compact keynodes (never used)

#define FHF_DIRTY                   0x00000001  //  Must rewrite to disk
#define FHF_RESERVED1               0x00000002  //  Dead bit from VERY old files
#define FHF_HASCHECKSUM             0x00000004  //  Checksum member is valid
#define FHF_FILEDIRTY               0x00000008  //  File is in the process of being updated (checked by win.com)
#define FHF_CORRUPT                 0x00000010  //  File is corrupt (detected by scanregw.exe)
#define FHF_SUPPORTSDIRTY           0x00000020  //  The registry supports FHF_CORRUPT and FHF_FILEDIRTY
#define FHF_BOOTFAILED              0x00000040  //  Failed to boot and verify the integrity of the registry

#define FHT_PRIMARY                 0x0001      //  System hives
#define FHT_SECONDARY               0x0080      //  User/application hives

typedef struct _KEYNODE_HEADER {
    DWORD Signature;                            //  KH_SIGNATURE
    DWORD FileKnSize;				//  of entire keynode table inc header
    DWORD RootIndex;				// Index into keynode array of the root key node
    DWORD FirstFreeIndex;			// Index into keynode array of the root of the key node free list
    DWORD Flags;                                //  KHF_* bits
    DWORD Checksum;                             //  of entire keynode table
    BYTE Reserved[8];
}   KEYNODE_HEADER, UNALIGNED FAR* LPKEYNODE_HEADER;

#define KH_SIGNATURE                0x4E4B4752  //  "RGKN"

#define KHF_DIRTY                   0x00000001  //  Win95: Must rewrite to disk
#define KHF_EXTENDED                0x00000002  //  Win95: Table has grown
#define KHF_HASCHECKSUM             0x00000004  //  Win95: Checksum is valid
#define KHF_NEWHASH                 0x00000008  //  Always expect

typedef struct _VERSION20_HEADER_PAGE {
    union {
        struct {
            FILE_HEADER FileHeader;
            KEYNODE_HEADER KeynodeHeader;
        };
        struct {
            BYTE Page[4096];
        };
    };
}   VERSION20_HEADER_PAGE, UNALIGNED FAR* LPVERSION20_HEADER_PAGE;

typedef struct _W95KEYNODE {
    DWORD W95State;				//  KNS_* constant
    union {
        //  State == KNS_USED or KNS_BIGUSED
        struct {
	    DWORD W95Hash;
	    DWORD W95Reserved1;
	    DWORD W95ParentOffset;              // offset from start of keynode header
	    DWORD W95ChildOffset;               // offset from start of keynode header
	    DWORD W95NextOffset;                // offset from start of keynode header
	    DWORD W95DatablockAddress;          // HIWORD: block #, LOWORD: Index in block
        };
        //  State == KNS_FREE or KNS_ALLFREE
        struct {
	    DWORD W95FreeRecordSize;
	    DWORD W95NextFreeOffset;
	    DWORD W95Reserved2[4];
        };
    };
}   W95KEYNODE, UNALIGNED FAR* LPW95KEYNODE;

#define KNS_USED                    0x00000000UL  //  Normal Keynode
#define KNS_BIGUSED                 0x00000001UL  //  Big key node root
#define KNS_BIGUSEDEXT              0x00000002UL  //  Big key node extension
#define KNS_FREE                    0x80000000UL
#define KNS_ALLFREE                 0xFFFFFFFFUL

typedef struct _KEYNODE {
    DWORD NextIndex:24,
          Flags:8;
    union {
        //  Flags & KNF_INUSE
	struct {
	    DWORD ChildIndex:24,
		  BinNumber:8;
	    DWORD ParentIndex:24,
                  KeyRecordIndex:8;
            WORD  BlockIndex;
	    WORD  Hash;
        };
        //  !(Flags & KNF_INUSE)
	struct {
            DWORD Reserved;
            DWORD FreeRecordSize;
        };
    };
}   KEYNODE, FAR* LPKEYNODE;

#define KNF_INUSE           0x01        // Block is in use
#define KNF_BIGKEYROOT      0x02        // Keynode represents a big key root
#define KNF_BIGKEYEXT       0x04        // Keynode represents a big key extension

#define IsNullKeynodeIndex(kni)     ((kni) >= 0x00FFFFFF)

typedef struct _DATABLOCK_HEADER {
    DWORD Signature;                            //  DH_SIGNATURE
    DWORD BlockSize;                            //  size of block including header
    DWORD FreeBytes;                            //  total of free bytes in block
    WORD Flags;                                 //  DHF_* bits
    WORD BlockIndex;
    DWORD FirstFreeOffset;                      //  offset of first free record from start of data block header
    WORD MaxAllocatedIndex;                     //  maximum index already allocated in the block
    WORD FirstFreeIndex;                        //  first available index in the block
    DWORD Reserved;
    DWORD Checksum;                             //  of entire datablock
}   DATABLOCK_HEADER, UNALIGNED FAR* LPDATABLOCK_HEADER;

#define DH_SIGNATURE                0x42444752  //  "RGDB"

#define DHF_DIRTY                   0x0001      //  Must rewrite to disk
#define DHF_EXTENDED                0x0002      //  Datablock size has grown
#define DHF_HASCHECKSUM             0x0004      //  Checksum member is valid
#define DHF_HASBLOCKNUMBERS         0x0008      //  Keys contain block numbers

#define DATABLOCKS_PER_FILE         0xFFFE      //  0xFFFF is 'null' block index

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_DATABLOCK_SIZE      ((DWORD)(60L*1024L))

//  Win95 registry files may not always have a key record for the root key of
//  a file.
#define NULL_BLOCK_INDEX            0xFFFF
#define IsNullBlockIndex(bi)        ((bi) == NULL_BLOCK_INDEX)

typedef struct _KEY_RECORD {
    DWORD AllocatedSize;            // bytes allocated for the record
    union {
        DWORD DatablockAddress;     // corresponds to W95KEYNODE.W95DatablockAddress
        struct {
            WORD KeyRecordIndex;    // index into the data block for this key
            WORD BlockIndex;        // data block index that this key resides in
        };
    };
    DWORD RecordSize;               // bytes used in the record
    WORD NameLength;
    WORD ValueCount;                // Count of value name records
    WORD ClassLength;
    WORD Reserved;
    char Name[ANYSIZE_ARRAY];
}   KEY_RECORD, UNALIGNED FAR* LPKEY_RECORD;

typedef struct _FREEKEY_RECORD {
    DWORD AllocatedSize;
    DWORD DatablockAddress;                     //  REG_NULL for free records
    DWORD NextFreeOffset;
}   FREEKEY_RECORD, UNALIGNED FAR* LPFREEKEY_RECORD;

typedef struct _VALUE_RECORD {
    DWORD DataType;
    DWORD Reserved;
    WORD NameLength;
    WORD DataLength;
    char Name[ANYSIZE_ARRAY];
}   VALUE_RECORD, UNALIGNED FAR* LPVALUE_RECORD;

#define KEY_RECORDS_PER_DATABLOCK   255

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_KEY_RECORD_SIZE     \
    ((DWORD)(MAXIMUM_DATABLOCK_SIZE-sizeof(DATABLOCK_HEADER)))

#ifdef WIN32
#include <poppack.h>
#else
#pragma pack()
#endif

#endif // _REGFFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regekey.c ===
//
//  REGEKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumKey and supporting functions.
//

#include "pch.h"

//
//  RgLookupKeyByIndex
//
//  lpKeyName, points to a buffer that receives the name of the subkey,
//      including the null terminator.  May be NULL.
//  lpcbKeyName, on entry, specifies the size in characters of the buffer
//      pointed to be lpKeyName, and on return, specifies the size of the
//      indexed subkey.  May not be NULL.
//

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName,
    UINT Flags
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    UINT KeysToSkip;
    DWORD KeynodeIndex;
    DWORD TempOffset;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif
#ifdef REALMODE
    BOOL secondTry;
#endif

    lpFileInfo = hKey-> lpFileInfo;
    KeysToSkip = Index;

    //
    //  Check if we've cached the keynode index of the last key index
    //  (confusing?) from a previous call to this function.  If so, then we can
    //  skip ahead a bit and avoid touching a bunch of keynode pages.
    //

    if ((hKey-> Flags & KEYF_ENUMKEYCACHED) &&
        (!(hKey-> Flags & KEYF_ENUMEXTENTCACHED) == !(Flags & LK_BIGKEYEXT)) &&
        (Index >= hKey-> LastEnumKeyIndex)) {
        KeysToSkip -= hKey-> LastEnumKeyIndex;
        KeynodeIndex = hKey-> LastEnumKeyKeynodeIndex;
    }
    else
        KeynodeIndex = hKey-> ChildKeynodeIndex;

    //
    //  Loop over the child keys of this key until we find our index or run out
    //  of children.
    //

    while (!IsNullKeynodeIndex(KeynodeIndex)) {

#ifdef REALMODE
        secondTry = FALSE;
tryAgain:
#endif // REALMODE

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        ASSERT(hKey-> KeynodeIndex == lpKeynode-> ParentIndex);

        if (!(Flags & LK_BIGKEYEXT) == !(lpKeynode-> Flags & KNF_BIGKEYEXT) &&
            KeysToSkip == 0) {

            if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode-> BlockIndex,
                (BYTE) lpKeynode-> KeyRecordIndex, &lpKeyRecord)) ==
                ERROR_SUCCESS) {

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpKeyRecord-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                            NameLength);
                        lpKeyName[lpKeyRecord-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpKeyRecord-> NameLength;

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

            }
#ifdef REALMODE
            else if (!secondTry)
            {
                // What happens in real mode, is that we get wedged with the
                // Keynode block allocated and locked in the middle of the free
                // space, and there is not a free block large enough for the data block.
                // We have already free'd up everything that isn't locked.
                // So, by unlocking and freeing the Keynode block and then restarting
                // the operation, the Keynode block gets allocated at the bottom of the
                // heap, leaving room for the data block.
                secondTry = TRUE;
                RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                RgEnumFileInfos(RgSweepFileInfo);
                RgEnumFileInfos(RgSweepFileInfo);
                goto tryAgain;
            }
#endif // REALMODE

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);

            //  Cache our current position because the caller is likely to turn
            //  around and ask for the next index.
            hKey-> LastEnumKeyIndex = Index;
            hKey-> LastEnumKeyKeynodeIndex = KeynodeIndex;
            hKey-> Flags |= KEYF_ENUMKEYCACHED;
            if (Flags & LK_BIGKEYEXT)
                hKey-> Flags |= KEYF_ENUMEXTENTCACHED;
            else
                hKey-> Flags &= ~KEYF_ENUMEXTENTCACHED;

            return ErrorCode;

        }

        TempOffset = lpKeynode-> NextIndex;
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
        KeynodeIndex = TempOffset;

        if (!(Flags & LK_BIGKEYEXT) == !(lpKeynode-> Flags & KNF_BIGKEYEXT))
        {
            KeysToSkip--;
        }
    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Loop over the hives of this key until we find our index or run out of
    //  hives.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (KeysToSkip == 0) {

                ErrorCode = ERROR_SUCCESS;

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpHiveInfo-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpHiveInfo-> Name, lpHiveInfo->
                            NameLength);
                        lpKeyName[lpHiveInfo-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpHiveInfo-> NameLength;

                //  We don't worry about the enum key cache if we find a
                //  hit in this code.  This is a rare case and already the cache
                //  that we do have is much better then Win95.

                return ErrorCode;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
            KeysToSkip--;

        }

    }
#endif

    return ERROR_NO_MORE_ITEMS;

}

//
//  VMMRegEnumKey
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    LPSTR lpKeyName,
    DWORD cbKeyName
    )
{

    int ErrorCode;

    if (IsBadHugeWritePtr(lpKeyName, cbKeyName))
        return ERROR_INVALID_PARAMETER;

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKeyByIndex(hKey, (UINT) Index, lpKeyName,
            &cbKeyName, 0);

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regeval.c ===
//
//  REGEVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumValue and supporting functions.
//

#include "pch.h"


//
//  RgLookupValueByIndex
//  (BIGKEY aware)
//
//  Searches for the value with the specified index and returns a pointer to its
//  VALUE_RECORD.
//
//  This locks the datablock associated with the KEY_RECORD and VALUE_RECORD.
//  This is always hKey->BigKeyLockedBlockIndex
//  It is the callers responsibility to unlock the datablock.  
//
int
INTERNAL
RgLookupValueByIndex(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord
    )
{
    int ErrorCode;
    HKEY hKeyExtent;
    UINT IndexKey;
    LPSTR KeyName;
    DWORD cbKeyName;
    UINT ValueCount;

    ErrorCode = RgLookupValueByIndexStd(hKey, Index, lplpValueRecord, &ValueCount);
    hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
    
    if (ErrorCode == ERROR_NO_MORE_ITEMS && (hKey->Flags & KEYF_BIGKEYROOT)) {

        if (IsNullPtr(KeyName = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
            return ERROR_OUTOFMEMORY;
        
        IndexKey = 0;
        
        while (ErrorCode == ERROR_NO_MORE_ITEMS && Index >= ValueCount)
        {
            Index -= ValueCount;

            cbKeyName = MAXIMUM_SUB_KEY_LENGTH;
            if (RgLookupKeyByIndex(hKey, IndexKey++, KeyName, &cbKeyName, LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_NO_MORE_ITEMS;
                goto lFreeKeyName;
            }

            if (RgLookupKey(hKey, KeyName, &hKeyExtent, LK_OPEN | LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_NO_MORE_ITEMS;
                goto lFreeKeyName;
            }

            hKey-> BigKeyLockedBlockIndex = hKeyExtent-> BlockIndex;
            ErrorCode = RgLookupValueByIndexStd(hKeyExtent, Index, 
                            lplpValueRecord, &ValueCount);

            RgDestroyKeyHandle(hKeyExtent);
        }

lFreeKeyName:
        RgSmFreeMemory(KeyName);
    }

    return ErrorCode;
}


//
//  RgLookupValueByIndexStd
//
//  Searches for the value with the specified index and returns a pointer to its
//  VALUE_RECORD.
//
//  This locks the datablock associated with the VALUE_RECORD.
//  This is always hKey->BlockIndex
//  It is the callers responsibility to unlock the datablock.  
//

int
INTERNAL
RgLookupValueByIndexStd(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord,
    UINT FAR* lpValueCount
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    *lpValueCount = 0;
    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_NO_MORE_ITEMS;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
        hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        *lpValueCount = lpKeyRecord-> ValueCount;

        if (Index >= lpKeyRecord-> ValueCount) {
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
            ErrorCode = ERROR_NO_MORE_ITEMS;
        }

        else {

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
                lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

            //  Should probably do more sanity checking on lpValueRecord
            while (Index--) {
                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                    Name + lpValueRecord-> NameLength + lpValueRecord->
                    DataLength);
            }

            *lplpValueRecord = lpValueRecord;
            ErrorCode = ERROR_SUCCESS;

        }

    }

    return ErrorCode;

}

//
//  VMMRegEnumValue
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumValue(
    HKEY hKey,
    DWORD Index,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadHugeWritePtr(lpcbValueName, sizeof(DWORD)) ||
        IsBadHugeWritePtr(lpValueName, *lpcbValueName) ||
        (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD))))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
	//  Win95 compatibility: don't validate lpData is of size *lpcbData.
	//  Instead of validating the entire buffer, we'll validate just the
	//  required buffer length in RgCopyFromValueRecord.
        if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
            return ERROR_INVALID_PARAMETER;
    }

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByIndex(hKey, (UINT) Index, 
            &lpValueRecord)) == ERROR_SUCCESS) {
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, lpValueName,
                lpcbValueName, lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regfinfo.h ===
//
//  REGFINFO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGFINFO_
#define _REGFINFO_

#define PAGESHIFT                   12
#define PAGESIZE                    (1 << PAGESHIFT)
#define PAGEMASK                    (PAGESIZE - 1)

#define KEYNODE_BLOCK_SHIFT	    10
#define KEYNODES_PER_BLOCK	    (1 << KEYNODE_BLOCK_SHIFT)
#define KEYNODE_BLOCK_MASK	    (KEYNODES_PER_BLOCK-1)
#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

#define KN_INDEX_IN_BLOCK(i)        ((i) & KEYNODE_BLOCK_MASK)
#define KN_BLOCK_NUMBER(i)          ((UINT) ((i) >> KEYNODE_BLOCK_SHIFT))

typedef struct _KEYNODE_BLOCK {
    KEYNODE	aKN[KEYNODES_PER_BLOCK];
} KEYNODE_BLOCK, FAR* LPKEYNODE_BLOCK;

#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

typedef struct _W95KEYNODE_BLOCK {
    W95KEYNODE	aW95KN[KEYNODES_PER_BLOCK];
} W95KEYNODE_BLOCK, FAR* LPW95KEYNODE_BLOCK;

typedef struct _KEYNODE_BLOCK_INFO {
    LPKEYNODE_BLOCK lpKeynodeBlock;
    BYTE Flags;                                 // KBDF_* bits
    BYTE LockCount;
}   KEYNODE_BLOCK_INFO, FAR* LPKEYNODE_BLOCK_INFO;

#define KBIF_ACCESSED               0x01        //  Recently accessed
#define KBIF_DIRTY                  0x02        //  Must rewrite to disk

//  Number of extra KEYNODE_BLOCK_INFO structures to alloc on top of the block
//  count already in the file.  Reduces heap fragmentation in real-mode.
#define KEYNODE_BLOCK_INFO_SLACK_ALLOC 4

#ifdef WIN32
typedef UINT KEY_RECORD_TABLE_ENTRY;
#else
typedef WORD KEY_RECORD_TABLE_ENTRY;
#endif
typedef KEY_RECORD_TABLE_ENTRY FAR* LPKEY_RECORD_TABLE_ENTRY;

#define NULL_KEY_RECORD_TABLE_ENTRY     ((KEY_RECORD_TABLE_ENTRY) 0)
#define IsNullKeyRecordTableEntry(kri)  ((kri) == NULL_KEY_RECORD_TABLE_ENTRY)

typedef struct _DATABLOCK_INFO {
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTable;
    UINT BlockSize;                             //  cached from datablock header
    UINT FreeBytes;                             //  cached from datablock header
    UINT FirstFreeIndex;                        //  cached from datablock header
    LONG FileOffset;
    BYTE Flags;                                 //  DIF_* bits
    BYTE LockCount;
}   DATABLOCK_INFO, FAR* LPDATABLOCK_INFO;

#define DIF_PRESENT                 0x01        //  In memory
#define DIF_ACCESSED                0x02        //  Recently accessed
#define DIF_DIRTY                   0x04        //  Must rewrite to disk
#define DIF_EXTENDED                0x08        //  Has grown in size

//  Number of extra DATABLOCK_INFO structures to alloc on top of the block count
//  already in the file.  Reduces heap fragmentation in real-mode.
#define DATABLOCK_INFO_SLACK_ALLOC  4

//  When we create or extend a datablock, try to keep it on page boundaries.
#define DATABLOCK_GRANULARITY       4096
#define RgAlignBlockSize(size) \
    (((size) + (DATABLOCK_GRANULARITY - 1)) & ~(DATABLOCK_GRANULARITY - 1))

typedef struct _FILE_INFO {
    struct _FILE_INFO FAR* lpNextFileInfo;
#ifdef WANT_HIVE_SUPPORT
    struct _HIVE_INFO FAR* lpHiveInfoList;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
#ifdef WANT_HIVE_SUPPORT
    struct _FILE_INFO FAR* lpParentFileInfo;
#endif
    struct _NOTIFY_CHANGE FAR* lpNotifyChangeList;
#endif
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockCount;
    UINT KeynodeBlockInfoAllocCount;
    DWORD CurTotalKnSize;           // Normally = to FileKnSize unless grown
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT DatablockInfoAllocCount;
    FILE_HEADER FileHeader;
    KEYNODE_HEADER KeynodeHeader;
    WORD Flags;                                 //  FI_* bits
    char FileName[ANYSIZE_ARRAY];
}   FILE_INFO, FAR* LPFILE_INFO;

#define FI_DIRTY                    0x0001      //  Must rewrite to disk
#define FI_KEYNODEDIRTY             0x0002      //
#define FI_EXTENDED                 0x0004      //
#define FI_VERSION20                0x0008      //
#define FI_FLUSHING                 0x0010      //  Currently flushing file
#define FI_SWEEPING                 0x0020      //  Currently sweeping file
#define FI_VOLATILE                 0x0040      //  File has no backing store
#define FI_READONLY                 0x0080      //  File cannot be modified
#define FI_REPLACEMENTEXISTS        0x0100      //  RegReplaceKey called on file

typedef struct _HIVE_INFO {
    struct _HIVE_INFO FAR* lpNextHiveInfo;
    LPFILE_INFO lpFileInfo;
    UINT NameLength;
    BYTE Hash;
    char Name[ANYSIZE_ARRAY];
}   HIVE_INFO, FAR* LPHIVE_INFO;

#define CFIN_PRIMARY                0x0000      //  FHT_PRIMARY header type
#define CFIN_SECONDARY              0x0001      //  FHT_SECONDARY header type
#define CFIN_VOLATILE               0x0002      //  File has no backing store
#define CFIN_VERSION20              0x0004      //  Use compact keynode form

int
INTERNAL
RgCreateFileInfoNew(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName,
    UINT Flags
    );

int
INTERNAL
RgCreateFileInfoExisting(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName
    );

int
INTERNAL
RgInitRootKeyFromFileInfo(
    HKEY hKey
    );

int
INTERNAL
RgDestroyFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgFlushFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgSweepFileInfo(
    LPFILE_INFO lpFileInfo
    );

typedef int (INTERNAL* LPENUMFILEINFOPROC)(LPFILE_INFO);

VOID
INTERNAL
RgEnumFileInfos(
    LPENUMFILEINFOPROC lpEnumFileInfoProc
    );

#define RgIndexKeynodeBlockInfoPtr(lpfi, index) \
    ((LPKEYNODE_BLOCK_INFO) (&(lpfi)-> lpKeynodeBlockInfo[index]))

#define RgIndexDatablockInfoPtr(lpfi, index) \
    ((LPDATABLOCK_INFO) (&(lpfi)-> lpDatablockInfo[index]))

#define RgIndexKeyRecordPtr(lpdi, index) \
    ((LPKEY_RECORD) ((LPBYTE)(lpdi)-> lpDatablockHeader + (lpdi)-> lpKeyRecordTable[(index)]))

BOOL
INTERNAL
RgIsValidFileHeader(
    LPFILE_HEADER lpFileHeader
    );

BOOL
INTERNAL
RgIsValidKeynodeHeader(
    LPKEYNODE_HEADER lpKeynodeHeader
    );

BOOL
INTERNAL
RgIsValidDatablockHeader(
    LPDATABLOCK_HEADER lpDatablockHeader
    );

extern LPFILE_INFO g_RgFileInfoList;

#endif // _REGFINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regfkey.c ===
//
//  REGFKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegFlushKey and supporting functions.
//

#include "pch.h"

//  Magic HKEY used by Setup to disable disk I/O for the duration of this
//  Windows session (you must restart to re-enable disk I/O).  This is done
//  just before the new SYSTEM.DAT and USER.DAT are copied to their final
//  destination.
#define HKEY_DISABLE_REG            (HKEY) 0x484A574D

//  Magic HKEY used by CONFIGMG to force a flush of the registry before we've
//  received our normal post-critical init call.
#define HKEY_CRITICAL_FLUSH         (HKEY) 0x5350574D

// Magic HKEY used by ScanregW to clear the failed boot bit FHF_BOOTFAILED in the file header
// of HKEY_LOCAL_MACHINE. Indicating that we successfully booted and verified the integrity
// of the registry files, and that scanreg.exe does not need to be ran by win.com on next boot.
#define HKEY_BOOT_SUCCESS           (HKEY) 0x5342574D

//
//  VMMRegFlushKey
//

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    )
{

    int ErrorCode;
    BOOL fBootSuccess = FALSE;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

#ifdef VXD
    //  Set the g_RgFileAccessDisabled flag so that all create or open file
    //  calls will be failed.  The backing stores for our files are about to
    //  be changed, so there's no file for us to go to.
    if (hKey == HKEY_DISABLE_REG) {
        g_RgFileAccessDisabled = TRUE;
        ErrorCode = ERROR_SUCCESS;
        goto ReturnErrorCode;
    }

    //  Set the g_RgPostCriticalInit flag so that all I/O calls will go to disk
    //  instead of the XMS cache.  The XMS cache will be freed when/if the
    //  normal post critical init routine is called, but we should only be
    //  getting this call when we're about to die, so it doesn't really matter.
    if (hKey == HKEY_CRITICAL_FLUSH) {
        g_RgPostCriticalInit = TRUE;
        hKey = HKEY_LOCAL_MACHINE;
    }

    // Clears the failed boot bit FHF_BOOTFAILED in the file header of HKEY_LOCAL_MACHINE.
    // Indicating that we successfully booted and verified the integrity of the registry files.
    if (hKey == HKEY_BOOT_SUCCESS)
    {
        fBootSuccess = TRUE;
        hKey = HKEY_LOCAL_MACHINE;
    }
#endif

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
    {
#ifdef VXD
        if (fBootSuccess)
        {
            hKey-> lpFileInfo-> FileHeader.Flags |= FHF_DIRTY;
            hKey-> lpFileInfo-> FileHeader.Flags &= ~FHF_BOOTFAILED;
        }
#endif
        ErrorCode = RgFlushFileInfo(hKey-> lpFileInfo);
    }

#ifdef VXD
ReturnErrorCode:
#endif
    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regfsio.h ===
//
//  REGFSIO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Prototypes for file system I/O.  Many of these prototypes may not be used
//  if a direct mapping is available in the target environment.
//

#ifndef _REGFSIO_
#define _REGFSIO_

//  Consistent with both 16-bit and 32-bit windows.h.
#ifndef HFILE_ERROR
typedef int HFILE;
#define HFILE_ERROR     ((HFILE)-1)
#endif

//  Special value used for the VMM version when we haven't fully initialized yet
//  but are reading SYSTEM.DAT from the XMS cache.
#define HFILE_MEMORY    ((HFILE)-2)

#ifndef RgCreateFile
HFILE
INTERNAL
RgCreateFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgOpenFile
HFILE
INTERNAL
RgOpenFile(
    LPCSTR lpFileName,
    int Mode
    );
#endif

#ifndef RgCreateTempFile
HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    );
#endif

#ifndef RgReadFile
BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgWriteFile
BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgSeekFile
BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    );
#endif

#ifndef RgCommitFile
BOOL
INTERNAL
RgCommitFile(
    HFILE hFile
    );
#endif


#ifndef RgCloseFile
VOID
INTERNAL
RgCloseFile(
    HFILE hFile
    );
#endif

#ifndef RgDeleteFile
BOOL
INTERNAL
RgDeleteFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgRenameFile
BOOL
INTERNAL
RgRenameFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
#endif

#define FILE_ATTRIBUTE_NONE             0

#ifndef RgGetFileAttributes
DWORD
INTERNAL
RgGetFileAttributes(
    LPCSTR lpFileName
    );
#endif

#ifndef RgSetFileAttributes
BOOL
INTERNAL
RgSetFileAttributes(
    LPCSTR lpFileName,
    UINT FileAttributes
    );
#endif

#ifndef RgGetFileSize
DWORD
INTERNAL
RgGetFileSize(
    HFILE hFile
    );
#endif

#endif // _REGFSIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regfinfo.c ===
//
//  REGFINFO.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

LPFILE_INFO g_RgFileInfoList = NULL;

const char g_RgDotBackslashPath[] = ".\\";

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgCreateFileInfoNew
//
//  If CFIN_VOLATILE is specified, then we skip trying to create the backing
//  store for the FILE_INFO.  lpFileName should point at a null byte so we can
//  initialize the FILE_INFO properly.
//
//  CFIN_PRIMARY and CFIN_SECONDARY are used to determine the FHT_* constant
//  to put in the file header.
//

int
INTERNAL
RgCreateFileInfoNew(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName,
    UINT Flags
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
        RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  For volatile FILE_INFOs, we obviously don't need to create the backing
    //  store.
    if (!(Flags & CFIN_VOLATILE)) {

        //  Attempt to the create the given filename.
        if ((hFile = RgCreateFile(lpFileName)) == HFILE_ERROR) {
            ErrorCode = ERROR_REGISTRY_IO_FAILED;
            goto ErrorDestroyFileInfo;
        }

        RgCloseFile(hFile);

    }

    lpFileInfo-> Flags = FI_DIRTY | FI_KEYNODEDIRTY;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    if (Flags & CFIN_VOLATILE)
        lpFileInfo-> Flags |= FI_VOLATILE;

    //  Initialize the file header.
    lpFileInfo-> FileHeader.Signature = FH_SIGNATURE;
    //  If we're using compact keynodes, up the version number to make sure
    //  Win95 doesn't try to load this hive.
    if (Flags & CFIN_VERSION20) {
        lpFileInfo-> FileHeader.Version = FH_VERSION20;
        lpFileInfo-> Flags |= FI_VERSION20;
    }
    else {
        lpFileInfo-> FileHeader.Version = FH_VERSION10;
    }
    //  lpFileInfo-> FileHeader.Size = 0;
    //  lpFileInfo-> FileHeader.Checksum = 0;
    //  lpFileInfo-> FileHeader.BlockCount = 0;
    lpFileInfo-> FileHeader.Flags = FHF_DIRTY;
    lpFileInfo-> FileHeader.Type = ((Flags & CFIN_SECONDARY) ? FHT_SECONDARY :
        FHT_PRIMARY);

    //  Initialize the keynode header.
    lpFileInfo-> KeynodeHeader.Signature = KH_SIGNATURE;
    //  lpFileInfo-> KeynodeHeader.FileKnSize = 0;
    lpFileInfo-> KeynodeHeader.RootIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.Flags = KHF_DIRTY | KHF_NEWHASH;
    //  lpFileInfo-> KeynodeHeader.Checksum = 0;

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  For uncompacted keynode tables, the keynode table now includes at least
    //  the header itself.
    if (!(lpFileInfo-> Flags & FI_VERSION20))
        lpFileInfo-> CurTotalKnSize = sizeof(KEYNODE_HEADER);

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, HFILE_ERROR)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Allocate the keynode for the root of the file.
    if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex, &lpKeynode)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    lpFileInfo-> KeynodeHeader.RootIndex = KeynodeIndex;

    lpKeynode-> ParentIndex = REG_NULL;
    lpKeynode-> NextIndex = REG_NULL;
    lpKeynode-> ChildIndex = REG_NULL;
    lpKeynode-> Hash = 0;
    //  Note that we don't allocate a key record for this root keynode.  Win95
    //  didn't do this either, so we already must handle this case in code that
    //  needs a key record.  Our code is smaller if we just don't allocate this
    //  key record which is rarely ever used anyway...
    lpKeynode-> BlockIndex = NULL_BLOCK_INDEX;

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    if ((ErrorCode = RgFlushFileInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

ErrorDeleteFile:
    if (!(Flags & CFIN_VOLATILE))
        RgDeleteFile(lpFileName);

ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

ErrorReturn:
    TRACE(("RgCreateFileInfoNew: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgCreateFileInfoExisting
//

int
INTERNAL
RgCreateFileInfoExisting(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    DWORD FileAttributes;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
        RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  lpFileInfo-> Flags = 0;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    //  Attempt to the open the given filename.
    if ((hFile = RgOpenFile(lpFileName, OF_READ)) == HFILE_ERROR)
        goto ErrorDestroyFileInfo;

    //  Read and validate the file header.
    if (!RgReadFile(hFile, &lpFileInfo-> FileHeader, sizeof(FILE_HEADER)))
        goto ErrorCloseFile;

    if (lpFileInfo-> FileHeader.Signature != FH_SIGNATURE ||
        (lpFileInfo-> FileHeader.Version != FH_VERSION10 &&
        lpFileInfo-> FileHeader.Version != FH_VERSION20)) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    lpFileInfo-> FileHeader.Flags &= ~(FHF_DIRTY | FHF_HASCHECKSUM);

    if (lpFileInfo-> FileHeader.Version == FH_VERSION20)
        lpFileInfo-> Flags |= FI_VERSION20;

    //  Read and validate the keynode header.
    if (!RgReadFile(hFile, &lpFileInfo-> KeynodeHeader,
        sizeof(KEYNODE_HEADER)))
        goto ErrorCloseFile;

    if (lpFileInfo-> KeynodeHeader.Signature != KH_SIGNATURE) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, hFile)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    RgCloseFile(hFile);

    //  Check if the file can be written to.  We did this in Win95 by getting
    //  the current file attributes and then slamming them back on the file.  If
    //  this failed, then we treated the file as read-only (such as hive from
    //  a read-only network share).  This seems to work, so why change?
    if ((FileAttributes = RgGetFileAttributes(lpFileName)) != (DWORD) -1) {
        if (!RgSetFileAttributes(lpFileName, (UINT) FileAttributes))
            lpFileInfo-> Flags |= FI_READONLY;
    }

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

ErrorCloseFile:
    RgCloseFile(hFile);

ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

ErrorReturn:
    TRACE(("RgCreateFileInfoExisting: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgDestroyFileInfo
//
//  Unlinks the FILE_INFO from the global list, if appropriate, and frees all
//  memory associated with the structure including the structure itself.
//
//  If the FILE_INFO is dirty, then all changes will be lost.  Call
//  RgFlushFileInfo first if the file should be flushed.
//

int
INTERNAL
RgDestroyFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    LPFILE_INFO lpPrevFileInfo;
    LPFILE_INFO lpCurrFileInfo;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
    LPHIVE_INFO lpTempHiveInfo;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    LPNOTIFY_CHANGE lpNotifyChange;
    LPNOTIFY_CHANGE lpTempNotifyChange;
#endif
    UINT Counter;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(!IsNullPtr(lpFileInfo));

    RgInvalidateKeyHandles(lpFileInfo, (UINT) -1);

    //
    //  Unlink this FILE_INFO from the the file info list.  Note that the
    //  structure may not have actually been linked in if we're called as a
    //  result of an error in one of the create file info functions.
    //

    lpPrevFileInfo = NULL;
    lpCurrFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpCurrFileInfo)) {

        if (lpCurrFileInfo == lpFileInfo) {
            if (IsNullPtr(lpPrevFileInfo))
                g_RgFileInfoList = lpCurrFileInfo-> lpNextFileInfo;
            else
                lpPrevFileInfo-> lpNextFileInfo = lpCurrFileInfo->
                    lpNextFileInfo;
            break;
        }

        lpPrevFileInfo = lpCurrFileInfo;
        lpCurrFileInfo = lpCurrFileInfo-> lpNextFileInfo;

    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Delete all of the hives connected to this FILE_INFO.
    //

    lpHiveInfo = lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpHiveInfo)) {
        RgDestroyFileInfo(lpHiveInfo-> lpFileInfo);
        lpTempHiveInfo = lpHiveInfo;
        lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
        RgSmFreeMemory(lpTempHiveInfo);
    }
#endif

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    //
    //  Signal and free all of the change notifications.  On NT, a hive cannot
    //  be unloaded if there are any open handles referencing it.  Change
    //  notifications are cleaned up when a key handle is closed.  So this
    //  cleanup is unique to our registry code.
    //

    lpNotifyChange = lpFileInfo-> lpNotifyChangeList;

    while (!IsNullPtr(lpNotifyChange)) {
        RgSetAndReleaseEvent(lpNotifyChange-> hEvent);
        lpTempNotifyChange = lpNotifyChange;
        lpNotifyChange = lpNotifyChange-> lpNextNotifyChange;
        RgSmFreeMemory(lpTempNotifyChange);
    }
#endif

    //
    //  Free all memory associated with the keynode table.
    //

    if (!IsNullPtr(lpFileInfo-> lpKeynodeBlockInfo)) {

        for (Counter = 0, lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;
            Counter < lpFileInfo-> KeynodeBlockCount; Counter++,
            lpKeynodeBlockInfo++) {
            if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock))
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
        }

        RgSmFreeMemory(lpFileInfo-> lpKeynodeBlockInfo);

    }

    //
    //  Free all memory associated with the datablocks.
    //

    if (!IsNullPtr(lpFileInfo-> lpDatablockInfo)) {

        for (Counter = 0, lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
            Counter < lpFileInfo-> FileHeader.BlockCount; Counter++,
            lpDatablockInfo++)
            RgFreeDatablockInfoBuffers(lpDatablockInfo);

        RgSmFreeMemory(lpFileInfo-> lpDatablockInfo);

    }

    //
    //  Free the FILE_INFO itself.
    //

    RgSmFreeMemory(lpFileInfo);

    return ERROR_SUCCESS;

}

#ifdef VXD
#pragma VxD_PAGEABLE_CODE_SEG
#endif

//
//  RgFlushFileInfo
//

int
INTERNAL
RgFlushFileInfo(
    LPFILE_INFO lpFileInfo
    )
{                                      

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    char TempFileName[MAX_PATH];
    UINT Index;

    ASSERT(!IsNullPtr(lpFileInfo));

    if (!IsPostCriticalInit() || IsFileAccessDisabled())
        return ERROR_SUCCESS;               //  Win95 compatibility.

    if (!(lpFileInfo-> Flags & FI_DIRTY))
        return ERROR_SUCCESS;

    //  If we're currently flushing this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, there's nothing to flush to.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_FLUSHING;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    hSourceFile = HFILE_ERROR;
    hDestinationFile = HFILE_ERROR;

    if (!RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_NONE))
        goto CleanupAfterError;

    //  Datablocks really shouldn't need to set this flag-- instead
    //  do some smart checking to see if we really need to rewrite the whole
    //  bloody thing.
    if (lpFileInfo-> Flags & FI_EXTENDED) {

        if ((Index = StrLen(lpFileInfo-> FileName)) >= MAX_PATH)
            goto CleanupAfterError;

        StrCpy(TempFileName, lpFileInfo-> FileName);

        //  Back up to the last backslash (or the start of the string) and
        //  null-terminate.
        do {
            Index--;
        }   while (Index > 0 && TempFileName[Index] != '\\');

        //  If we found a backslash, then null terminate the string after the
        //  backslash.  Otherwise, we don't have a full qualified pathname, so
        //  make the temporary file in the current directory and pray that's
        //  where the registry file is.
        if (Index != 0)
            TempFileName[Index + 1] = '\0';
        else
            StrCpy(TempFileName, g_RgDotBackslashPath);

        if ((hDestinationFile = RgCreateTempFile(TempFileName)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        if ((hSourceFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        TRACE(("rewriting to TempFileName = \""));
        TRACE((TempFileName));
        TRACE(("\"\n"));

    }

    else {
        if ((hDestinationFile = RgOpenFile(lpFileInfo-> FileName, OF_WRITE)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        // Mark the file is in the process of being updated
        lpFileInfo-> FileHeader.Flags |= FHF_FILEDIRTY | FHF_DIRTY;
    }

    //  Write out the file header.
    if (hSourceFile != HFILE_ERROR || lpFileInfo-> FileHeader.Flags &
        FHF_DIRTY) {

        lpFileInfo-> FileHeader.Flags |= FHF_SUPPORTSDIRTY;

        //  Note that RgWriteDatablocks and RgWriteDatablocksComplete uses this
        //  value, too.
        if (lpFileInfo-> Flags & FI_VERSION20)
            lpFileInfo-> FileHeader.Size = sizeof(VERSION20_HEADER_PAGE) +
                lpFileInfo-> CurTotalKnSize;
        else
            lpFileInfo-> FileHeader.Size = sizeof(FILE_HEADER) +
                lpFileInfo-> CurTotalKnSize;

        if (!RgWriteFile(hDestinationFile, &lpFileInfo-> FileHeader,
            sizeof(FILE_HEADER)))
            goto CleanupAfterError;

            // Commit the change to disk, if we are modifying in place
        if (lpFileInfo-> FileHeader.Flags & FHF_FILEDIRTY)
        {
            if (!RgCommitFile(hDestinationFile))
                goto CleanupAfterError;
        }

    }

    //  Write out the keynode header and table.
    if ((ErrorCode = RgWriteKeynodes(lpFileInfo, hSourceFile,
        hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteKeynodes returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    //  Write out the datablocks.
    if ((ErrorCode = RgWriteDatablocks(lpFileInfo, hSourceFile,
        hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteDatablocks returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    // Ensure that the file is actually written
    if (!RgCommitFile(hDestinationFile))
        goto CleanupAfterError;

    // Mark the file update as complete
    if (lpFileInfo-> FileHeader.Flags & FHF_FILEDIRTY)
    {
        lpFileInfo-> FileHeader.Flags &= ~FHF_FILEDIRTY;

        if (!RgSeekFile(hDestinationFile, 0))
            goto CleanupAfterError;

        if (!RgWriteFile(hDestinationFile, &lpFileInfo-> FileHeader,
            sizeof(FILE_HEADER)))
            goto CleanupAfterError;
    }

    RgCloseFile(hDestinationFile);

    //  If we're extending the file, we now go back and delete the current file
    //  and replace it with our temporary file.
    if (hSourceFile != HFILE_ERROR) {

        RgCloseFile(hSourceFile);

        ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

        if (!RgDeleteFile(lpFileInfo-> FileName))
            goto CleanupAfterFilesClosed;

        if (!RgRenameFile(TempFileName, lpFileInfo-> FileName)) {
            //  If we ever hit this, we're in trouble.  Need to handle it
            //  somehow, though.
            DEBUG_OUT(("RgFlushFileInfo failed to replace backing file\n"));
            goto CleanupAfterFilesClosed;
        }

    }

    //  Go back and tell everyone that the write is complete-- the file has
    //  been successfully written to disk.
    RgWriteDatablocksComplete(lpFileInfo);
    RgWriteKeynodesComplete(lpFileInfo);
    lpFileInfo-> FileHeader.Flags &= ~FHF_DIRTY;
    lpFileInfo-> Flags &= ~(FI_DIRTY | FI_EXTENDED);

    ErrorCode = ERROR_SUCCESS;

CleanupAfterFilesClosed:
    RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
        FILE_ATTRIBUTE_HIDDEN);

    lpFileInfo-> Flags &= ~FI_FLUSHING;

    if (ErrorCode != ERROR_SUCCESS)
        DEBUG_OUT(("RgFlushFileInfo() returning error %d\n", ErrorCode));

    return ErrorCode;

CleanupAfterError:
    if (hSourceFile != HFILE_ERROR)
        RgCloseFile(hSourceFile);

    if (hDestinationFile != HFILE_ERROR) {

        //  If both hSourceFile and hDestinationFile were valid, then we must
        //  have created a temporary file.  Delete it now that we've failed.
        if (hSourceFile != HFILE_ERROR)
            RgDeleteFile(TempFileName);

        RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_HIDDEN);

    }

    goto CleanupAfterFilesClosed;

}

//
//  RgSweepFileInfo
//

int
INTERNAL
RgSweepFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    ASSERT(!IsNullPtr(lpFileInfo));

    //  If we're currently sweeping this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, we can't sweep anything out.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_SWEEPING;

    RgSweepKeynodes(lpFileInfo);
    RgSweepDatablocks(lpFileInfo);

    lpFileInfo-> Flags &= ~FI_SWEEPING;

    return ERROR_SUCCESS;

}

//
//  RgEnumFileInfos
//
//  Enumerates over all FILE_INFO structures, passing each to the provided
//  callback.  Currently, all errors from callbacks are ignored.
//

VOID
INTERNAL
RgEnumFileInfos(
    LPENUMFILEINFOPROC lpEnumFileInfoProc
    )
{

    LPFILE_INFO lpFileInfo;
    LPFILE_INFO lpTempFileInfo;

    lpFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpFileInfo)) {
        lpTempFileInfo = lpFileInfo;
        lpFileInfo = lpFileInfo-> lpNextFileInfo;
        (*lpEnumFileInfoProc)(lpTempFileInfo);
    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitRootKeyFromFileInfo
//
//  Using the FILE_INFO contained in the key, initialize the rest of the members
//  of the key.  If any errors occur, then the FILE_INFO is destroyed.
//

int
INTERNAL
RgInitRootKeyFromFileInfo(
    HKEY hKey
    )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    hKey-> KeynodeIndex = hKey-> lpFileInfo-> KeynodeHeader.RootIndex;

    if ((ErrorCode = RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode)) == ERROR_SUCCESS) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED | KEYF_ENUMKEYCACHED);
        hKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
        hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
        hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);

    }

    else
        RgDestroyFileInfo(hKey-> lpFileInfo);

    return ErrorCode;

}

#ifdef VXD
#pragma VxD_INIT_CODE_SEG
#endif

//
//  VMMRegMapPredefKeyToFile
//

LONG
REGAPI
VMMRegMapPredefKeyToFile(
    HKEY hKey,
    LPCSTR lpFileName,
    UINT Flags
    )
{

    int ErrorCode;
#ifdef WIN32
    char FullPathName[MAX_PATH];
#endif
    UINT CreateNewFlags;

    if (hKey != HKEY_LOCAL_MACHINE && hKey != HKEY_USERS
#ifndef VXD
        && hKey != HKEY_CURRENT_USER
#endif
        )
        return ERROR_INVALID_PARAMETER;

    if (IsBadOptionalStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    RgValidateAndConvertKeyHandle(&hKey);

    if (!(hKey-> Flags & KEYF_INVALID))
        RgDestroyFileInfo(hKey-> lpFileInfo);

    //  Specifying NULL "unmaps" the key and leaves it invalidated.
    if (IsNullPtr(lpFileName))
        return ERROR_SUCCESS;

#ifdef WIN32
    //  For users of the Win32 DLL, resolve the path name so they don't have to.
    if ((GetFullPathName(lpFileName, sizeof(FullPathName), FullPathName,
        NULL)) != 0)
        lpFileName = FullPathName;
#endif

    if (Flags & MPKF_CREATENEW) {
        CreateNewFlags = CFIN_PRIMARY | ((Flags & MPKF_VERSION20) ?
            CFIN_VERSION20 : 0);
        ErrorCode = RgCreateFileInfoNew(&hKey-> lpFileInfo, lpFileName,
            CreateNewFlags);
    }

    else {
        ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo, lpFileName);
    }

    if (ErrorCode == ERROR_SUCCESS)
        ErrorCode = RgInitRootKeyFromFileInfo(hKey);

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\reghive.c ===
//
//  REGHIVE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey and
//  supporting functions.
//

#include "pch.h"

#ifdef WANT_HIVE_SUPPORT

//  Maximum number of times we'll allow RgCopyBranch to be reentered.
#define MAXIMUM_COPY_RECURSION          32

LPSTR g_RgNameBufferPtr;                //  Temporary buffer for RgCopyBranch
LPBYTE g_RgDataBufferPtr;               //  Temporary buffer for RgCopyBranch
UINT g_RgRecursionCount;                //  Tracks depth of RgCopyBranch

#if MAXIMUM_VALUE_NAME_LENGTH > MAXIMUM_SUB_KEY_LENGTH
#error Code assumes a value name can fit in a subkey buffer.
#endif

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgValidateHiveSubKey
//
//  Note that unlike most parameter validation routines, this routine must be
//  called with the registry lock taken because we call RgGetNextSubSubKey.
//
//  Pass back the length of the subkey to deal with the trailing backslash
//  problem.
//
//  Returns TRUE if lpSubKey is a valid subkey string for hive functions.
//

BOOL
INTERNAL
RgValidateHiveSubKey(
    LPCSTR lpSubKey,
    UINT FAR* lpHiveKeyLength
    )
{

    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;

    //  Verify that we have a valid subkey that has one and only one sub-subkey.
    //  in Win95 it was possible to load a hive with a keyname
    //  containing a backslash!
    return !IsNullPtr(lpSubKey) && !RgIsBadSubKey(lpSubKey) &&
        (RgGetNextSubSubKey(lpSubKey, &lpSubSubKey, lpHiveKeyLength) > 0) &&
        (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength) == 0);

}

//
//  VMMRegLoadKey
//
//  See Win32 documentation of RegLoadKey.
//

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    UINT SubKeyLength;
    LPHIVE_INFO lpHiveInfo;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength)) {
        ErrorCode = ERROR_BADKEY;
        goto ReturnErrorCode;
    }

    //  Check if a subkey with the specified name already exists.
    if (RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN) == ERROR_SUCCESS) {
        RgDestroyKeyHandle(hSubKey);
        ErrorCode = ERROR_BADKEY;       //  Win95 compatibility
        goto ReturnErrorCode;
    }

    if (IsNullPtr((lpHiveInfo = (LPHIVE_INFO)
        RgSmAllocMemory(sizeof(HIVE_INFO) + SubKeyLength)))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ReturnErrorCode;
    }

    //  Fill in the HIVE_INFO.
    StrCpy(lpHiveInfo-> Name, lpSubKey);
    lpHiveInfo-> NameLength = SubKeyLength;
    lpHiveInfo-> Hash = (BYTE) RgHashString(lpSubKey, SubKeyLength);

    //  Attempt to create a FILE_INFO for the specified file.  If successful,
    //  link this HIVE_INFO into the parent FILE_INFO's hive list.
    if ((ErrorCode = RgCreateFileInfoExisting(&lpHiveInfo-> lpFileInfo,
        lpFileName)) == ERROR_SUCCESS) {

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        lpHiveInfo-> lpFileInfo-> lpParentFileInfo = hKey-> lpFileInfo;
#endif
        lpHiveInfo-> lpNextHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;
        hKey-> lpFileInfo-> lpHiveInfoList = lpHiveInfo;

        //  Signal any notifications waiting on this top-level key.
        RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);

    }

    else
        RgFreeMemory(lpHiveInfo);

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  VMMRegUnLoadKey
//
//  See Win32 documentation of RegUnLoadKey.
//

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    int ErrorCode;
    UINT SubKeyLength;
    LPFILE_INFO lpFileInfo;
    LPHIVE_INFO lpPrevHiveInfo;
    LPHIVE_INFO lpCurrHiveInfo;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    ErrorCode = ERROR_BADKEY;               //  Assume this error code

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength))
        goto ReturnErrorCode;

    lpPrevHiveInfo = NULL;
    lpCurrHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpCurrHiveInfo)) {

        if (SubKeyLength == lpCurrHiveInfo-> NameLength && RgStrCmpNI(lpSubKey,
            lpCurrHiveInfo-> Name, SubKeyLength) == 0) {

            //  Unlink this HIVE_INFO structure.
            if (IsNullPtr(lpPrevHiveInfo))
                hKey-> lpFileInfo-> lpHiveInfoList = lpCurrHiveInfo->
                    lpNextHiveInfo;
            else
                lpPrevHiveInfo-> lpNextHiveInfo = lpCurrHiveInfo->
                    lpNextHiveInfo;

            //  Flush and destroy it's associated FILE_INFO structure.  When we
            //  destroy the FILE_INFO, all open keys in this hive will be
            //  invalidated.
            lpFileInfo = lpCurrHiveInfo-> lpFileInfo;
            RgFlushFileInfo(lpFileInfo);
            RgDestroyFileInfo(lpFileInfo);

            //  Free the HIVE_INFO itself.
            RgSmFreeMemory(lpCurrHiveInfo);

            //  Signal any notifications waiting on this top-level key.
            RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME);

            ErrorCode = ERROR_SUCCESS;
            break;

        }

        lpPrevHiveInfo = lpCurrHiveInfo;
        lpCurrHiveInfo = lpCurrHiveInfo-> lpNextHiveInfo;

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  RgCopyBranchHelper
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  For Win95 compatibility, we don't stop the copy process if we encounter an
//  error.  (But unlike Win95, we do actually check more error codes)
//
//  SHOULD ONLY BE CALLED BY RgCopyBranch.
//

VOID
INTERNAL
RgCopyBranchHelper(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    UINT Index;
    DWORD cbNameBuffer;
    LPVALUE_RECORD lpValueRecord;

    //
    //  Copy all of the values from the source key to the destination key.
    //

    Index = 0;

    while (RgLookupValueByIndex(hSourceKey, Index++, &lpValueRecord) ==
        ERROR_SUCCESS) {

        DWORD cbDataBuffer;
        DWORD Type;

        cbNameBuffer = MAXIMUM_VALUE_NAME_LENGTH;
        cbDataBuffer = MAXIMUM_DATA_LENGTH + 1;         //  Terminating null

        if (RgCopyFromValueRecord(hSourceKey, lpValueRecord, g_RgNameBufferPtr,
            &cbNameBuffer, &Type, g_RgDataBufferPtr, &cbDataBuffer) ==
            ERROR_SUCCESS) {
            //  Subtract the terminating null that RgCopyFromValueRecord added
            //  to cbDataBuffer.  We don't save that in the file.
            if (Type == REG_SZ) {
                ASSERT(cbDataBuffer > 0);               //  Must have the null!
                cbDataBuffer--;
            }
            RgSetValue(hDestinationKey, g_RgNameBufferPtr, Type,
                g_RgDataBufferPtr, cbDataBuffer);
        }

        RgUnlockDatablock(hSourceKey-> lpFileInfo, hSourceKey-> BigKeyLockedBlockIndex,
            FALSE);

    }

    //  We can't recurse forever, so enforce a maximum depth like Win95.
    if (g_RgRecursionCount > MAXIMUM_COPY_RECURSION)
        return;

    g_RgRecursionCount++;

    //
    //  Copy all of the subkeys from the source key to the destination key.
    //

    Index = 0;

    while (TRUE) {

        HKEY hSubSourceKey;
        HKEY hSubDestinationKey;

        cbNameBuffer = MAXIMUM_SUB_KEY_LENGTH;

        if (RgLookupKeyByIndex(hSourceKey, Index++, g_RgNameBufferPtr,
            &cbNameBuffer,0 ) != ERROR_SUCCESS)
            break;

        if (RgLookupKey(hSourceKey, g_RgNameBufferPtr, &hSubSourceKey,
            LK_OPEN) == ERROR_SUCCESS) {

            if (RgLookupKey(hDestinationKey, g_RgNameBufferPtr,
                &hSubDestinationKey, LK_CREATE) == ERROR_SUCCESS) {
                RgYield();
                RgCopyBranchHelper(hSubSourceKey, hSubDestinationKey);
                RgDestroyKeyHandle(hSubDestinationKey);
            }

            else
                TRAP();

            RgDestroyKeyHandle(hSubSourceKey);

        }

        else
            TRAP();

    }

    g_RgRecursionCount--;

}

//
//  RgCopyBranch
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  This function sets and cleans up for RgCopyBranchHelper who does all
//  the real copying.
//
//  The backing store of the destination file is flushed if successful.
//

int
INTERNAL
RgCopyBranch(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    int ErrorCode;

    if (IsNullPtr(g_RgNameBufferPtr = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        if (IsNullPtr(g_RgDataBufferPtr = RgSmAllocMemory(MAXIMUM_DATA_LENGTH +
            1)))                                        //  + terminating null
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            g_RgRecursionCount = 0;
            RgCopyBranchHelper(hSourceKey, hDestinationKey);

            //  Everything should be copied over, so flush the file now since
            //  all callers will be immediately destroying this FILE_INFO
            //  anyways.
            ErrorCode = RgFlushFileInfo(hDestinationKey-> lpFileInfo);

        }

        RgSmFreeMemory(g_RgNameBufferPtr);

    }

    RgSmFreeMemory(g_RgDataBufferPtr);

    return ErrorCode;

}

//
//  RgSaveKey
//
//  Worker routine for VMMRegSaveKey and VMMRegReplaceKey.  Saves all the keys
//  and values starting at hKey, which must point at a valid KEY structure, to
//  the location specified by lpFileName.  The file must not currently exist.
//

int
INTERNAL
RgSaveKey(
    HKEY hKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hHiveKey;

    if (IsNullPtr(hHiveKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so the below destroy will work.
        RgIncrementKeyReferenceCount(hHiveKey);

        if ((ErrorCode = RgCreateFileInfoNew(&hHiveKey-> lpFileInfo, lpFileName,
            CFIN_SECONDARY)) == ERROR_SUCCESS) {

            if (((ErrorCode = RgInitRootKeyFromFileInfo(hHiveKey)) != ERROR_SUCCESS) ||
                ((ErrorCode = RgCopyBranch(hKey, hHiveKey)) != ERROR_SUCCESS)) {
                RgSetFileAttributes(hHiveKey-> lpFileInfo-> FileName,
                    FILE_ATTRIBUTE_NONE);
                RgDeleteFile(hHiveKey-> lpFileInfo-> FileName);
            }

            //  If successful, then RgCopyBranch has already flushed the file.
            RgDestroyFileInfo(hHiveKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hHiveKey);

    }

    return ErrorCode;

}

//
//  VMMRegSaveKey
//
//  See Win32 documentation of RegSaveKey.
//

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    LPCSTR lpFileName,
    LPVOID lpSecurityAttributes
    )
{

    int ErrorCode;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgSaveKey(hKey, lpFileName);

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpSecurityAttributes);

}

#ifdef WANT_REGREPLACEKEY

//
//  RgGetKeyName
//

LPSTR
INTERNAL
RgGetKeyName(
    HKEY hKey
    )
{

    LPSTR lpKeyName;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex, &lpKeyRecord) != ERROR_SUCCESS)
        lpKeyName = NULL;

    else {

        //  A registry is corrupt if we ever hit this.  We'll continue to
        //  allocate a buffer and let downstream code fail when we try to use
        //  the string.
        ASSERT(lpKeyRecord-> NameLength < MAXIMUM_SUB_KEY_LENGTH);

        if (!IsNullPtr(lpKeyName = (LPSTR) RgSmAllocMemory(lpKeyRecord->
            NameLength + 1))) {                         //  + terminating null
            MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                NameLength);
            lpKeyName[lpKeyRecord-> NameLength] = '\0';
        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

    }

    return lpKeyName;

}

//
//  RgCreateRootKeyForFile
//
//  Creates a KEY and a FILE_INFO to access the specified file.
//

int
INTERNAL
RgCreateRootKeyForFile(
    LPHKEY lphKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hKey;

    if (IsNullPtr(hKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so RgDestroyKeyHandle will work.
        RgIncrementKeyReferenceCount(hKey);

        if ((ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo,
            lpFileName)) == ERROR_SUCCESS) {

            if ((ErrorCode = RgInitRootKeyFromFileInfo(hKey)) ==
                ERROR_SUCCESS) {
                *lphKey = hKey;
                return ERROR_SUCCESS;
            }

            RgDestroyFileInfo(hKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hKey);

    }

    return ErrorCode;

}

//
//  RgDestroyRootKeyForFile
//
//  Destroys the resources allocated by RgCreateRootKeyForFile.
//

VOID
INTERNAL
RgDestroyRootKeyForFile(
    HKEY hKey
    )
{

    RgDestroyFileInfo(hKey-> lpFileInfo);
    RgDestroyKeyHandle(hKey);

}

//
//  RgDeleteHiveFile
//
//  Deletes the specified hive file after clearing its file attributes.
//

BOOL
INTERNAL
RgDeleteHiveFile(
    LPCSTR lpFileName
    )
{

    RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE);
    //  RgSetFileAttributes may fail, but try to delete the file anyway.
    return RgDeleteFile(lpFileName);

}

//
//  VMMRegReplaceKey
//
//  See Win32 documentation of RegReplaceKey.
//

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpNewFileName,
    LPCSTR lpOldFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;
    HKEY hParentKey;
    char ReplaceFileName[MAX_PATH];
    BOOL fCreatedReplaceFile;
    HKEY hReplaceKey;
    HKEY hNewKey;
    HKEY hReplaceSubKey;
    LPSTR lpReplaceSubKey;

    if (IsBadOptionalStringPtr(lpSubKey, (UINT) -1) ||
        IsBadStringPtr(lpNewFileName, (UINT) -1) ||
        IsBadStringPtr(lpOldFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ErrorReturn;

    if ((ErrorCode = RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) !=
        ERROR_SUCCESS)
        goto ErrorReturn;

    //
    //  The provided key handle must an immediate child from the same backing
    //  store (not a hive) as either HKEY_LOCAL_MACHINE or HKEY_USERS.
    //

    if (RgLockInUseKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex,
        &lpKeynode) != ERROR_SUCCESS) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorDestroySubKey;
    }

    KeynodeIndex = lpKeynode-> ParentIndex;
    RgUnlockKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex, FALSE);

    //  Find an open key on the parent check if it's HKEY_LOCAL_MACHINE or
    //  HKEY_USERS.  If not, bail out.  KeynodeIndex may be REG_NULL, but
    //  RgFindOpenKeyHandle handles that case.
    if (IsNullPtr(hParentKey = RgFindOpenKeyHandle(hSubKey-> lpFileInfo,
        KeynodeIndex)) || ((hParentKey != &g_RgLocalMachineKey) &&
        (hParentKey != &g_RgUsersKey))) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto ErrorDestroySubKey;
    }

    //
    //  All parameters have been validated, so begin the real work of the API.
    //

    //  Because we'll be doing a file copy below, all changes must be flushed
    //  now.
    if ((ErrorCode = RgFlushFileInfo(hSubKey-> lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    //  Make a backup of the current contents of the subkey.
    if ((ErrorCode = RgSaveKey(hSubKey, lpOldFileName)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    RgGenerateAltFileName(hSubKey-> lpFileInfo-> FileName, ReplaceFileName, 'R');

    //  Check if the magic replacement file already exists and if not, create
    //  it.
    if (RgGetFileAttributes(ReplaceFileName) == (DWORD) -1) {
        if ((ErrorCode = RgCopyFile(hSubKey-> lpFileInfo-> FileName,
            ReplaceFileName)) != ERROR_SUCCESS)
            goto ErrorDeleteOldFile;
        fCreatedReplaceFile = TRUE;
    }

    else
        fCreatedReplaceFile = FALSE;

    if ((ErrorCode = RgCreateRootKeyForFile(&hNewKey, lpNewFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteReplaceFile;

    if ((ErrorCode = RgCreateRootKeyForFile(&hReplaceKey, ReplaceFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDestroyNewRootKey;

    //  The original key that we were given may reference the subkey, so
    //  lpSubKey would be a NULL or empty string.  But we need the name that
    //  this subkey refers to, so we have to go back to the file to pull out
    //  the name.
    if (hKey != hSubKey)
        lpReplaceSubKey = (LPSTR) lpSubKey;

    else {
        //  We allocate this from the heap to reduce the requirements of an
        //  already strained stack.  If this fails, we're likely out of memory.
        //  Even if that's not why we failed, this is such an infrequent path
        //  that it's a good enough error code.
        if (IsNullPtr(lpReplaceSubKey = RgGetKeyName(hSubKey))) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ErrorDestroyReplaceRootKey;
        }
    }

    //  Check if the specified subkey already exists and if it does, delete it.
    if (RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey, LK_OPEN) ==
        ERROR_SUCCESS) {
        RgDeleteKey(hReplaceSubKey);
        RgDestroyKeyHandle(hReplaceSubKey);
    }

    //  Create the specified subkey in the replacement registry and copy the
    //  new hive to that key.
    if ((ErrorCode = RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey,
        LK_CREATE)) == ERROR_SUCCESS) {

        //  If successful, tag the FILE_INFO so that on system exit, we'll go
        //  and rename the replacement file to actual filename.
        if ((ErrorCode = RgCopyBranch(hNewKey, hReplaceSubKey)) ==
            ERROR_SUCCESS)
            hKey-> lpFileInfo-> Flags |= FI_REPLACEMENTEXISTS;

        RgDestroyKeyHandle(hReplaceSubKey);

    }

    if (lpSubKey != lpReplaceSubKey)
        RgSmFreeMemory(lpReplaceSubKey);

ErrorDestroyReplaceRootKey:
    RgDestroyRootKeyForFile(hReplaceKey);

ErrorDestroyNewRootKey:
    RgDestroyRootKeyForFile(hNewKey);

ErrorDeleteReplaceFile:
    if (ErrorCode != ERROR_SUCCESS && fCreatedReplaceFile)
        RgDeleteHiveFile(ReplaceFileName);

ErrorDeleteOldFile:
    if (ErrorCode != ERROR_SUCCESS)
        RgDeleteHiveFile(lpOldFileName);

ErrorDestroySubKey:
    RgDestroyKeyHandle(hSubKey);

ErrorReturn:
    RgUnlockRegistry();

    return ErrorCode;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

//
//  RgReplaceFileOnSysExit
//
//  Essentially the same algorithm as rlReplaceFile from the Win95 registry
//  code with modifications for how file I/O is handled in this library.
//

int
INTERNAL
RgReplaceFileOnSysExit(
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    char ReplaceFileName[MAX_PATH];
    char SaveFileName[MAX_PATH];

    ErrorCode = ERROR_SUCCESS;

    if (RgGenerateAltFileName(lpFileName, ReplaceFileName, 'R') &&
        RgGetFileAttributes(ReplaceFileName) == (FILE_ATTRIBUTE_READONLY |
        FILE_ATTRIBUTE_HIDDEN)) {

        //  If we were able to generate the replace file name, then we must be
        //  able to generate the save file name, so ignore the result.
        RgGenerateAltFileName(lpFileName, SaveFileName, 'S');
        RgDeleteHiveFile(SaveFileName);

        //  Preserve the current hive in case something fails below.
        if (!RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE) ||
            !RgRenameFile(lpFileName, SaveFileName))
            ErrorCode = ERROR_REGISTRY_IO_FAILED;

        else {
            //  Now try to move the replacement in.
            if (!RgSetFileAttributes(ReplaceFileName, FILE_ATTRIBUTE_NONE) ||
                !RgRenameFile(ReplaceFileName, lpFileName)) {
                ErrorCode = ERROR_REGISTRY_IO_FAILED;
                RgRenameFile(SaveFileName, lpFileName);
            }
            else
                RgDeleteFile(SaveFileName);
        }

        RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_HIDDEN);

    }

    return ErrorCode;

}

//
//  RgReplaceFileInfo
//
//  Called during registry detach to do any necessary file replacements as a
//  result of calling RegReplaceKey.
//

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    if (lpFileInfo-> Flags & FI_REPLACEMENTEXISTS)
        RgReplaceFileOnSysExit(lpFileInfo-> FileName);

    return ERROR_SUCCESS;

}

#endif // WANT_REGREPLACEKEY

#endif // WANT_HIVE_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\reginit.c ===
//
//  REGINIT.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef DEBUG
extern int g_RgDatablockLockCount;
extern int g_RgKeynodeLockCount;
extern int g_RgMemoryBlockCount;
#endif

#ifdef WANT_DYNKEY_SUPPORT
#ifdef VXD
#pragma VMM_IDATA_SEG
#endif
const char g_RgNull[] = "";
#ifdef VXD
#pragma VMM_PAGEABLE_DATA_SEG
#endif
#endif

#ifdef VXD
//  Set when our post critical init routine is called indicating that it's safe
//  to make disk I/O calls.  May also be set early when RegFlushKey gets the
//  magic HKEY_CRITICAL_FLUSH.
BYTE g_RgPostCriticalInit = FALSE;
//  Set when RegFlushKey gets the magic HKEY_DISABLE_REG.  No disk I/O will be
//  allowed after this flag is set.
BYTE g_RgFileAccessDisabled = FALSE;
#endif

LPVOID g_RgWorkBuffer = NULL;
#ifdef DEBUG
BOOL g_RgWorkBufferBusy = FALSE;
#endif

#ifdef VXD
#pragma VxD_INIT_CODE_SEG
#endif

//
//  VMMRegLibAttach
//
//  Prepares the registry library for use by allocating any global resources.
//  If ERROR_SUCCESS is returned, then VMMRegLibDetach should be called to 
//  release these resources.
//

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    )
{

    if (IsNullPtr((g_RgWorkBuffer = RgAllocMemory(SIZEOF_WORK_BUFFER))))
        goto MemoryError;

#ifdef WANT_STATIC_KEYS
    if (!RgAllocKeyHandleStructures())
        goto MemoryError;
#endif
    RgInitPredefinedKeys();

#ifdef WANT_DYNKEY_SUPPORT
    //  Initialize HKEY_DYN_DATA.  If anything fails here, we won't stop the
    //  initialize of the entire registry.
    if (RgCreateFileInfoNew(&g_RgDynDataKey.lpFileInfo, g_RgNull,
        CFIN_VERSION20 | CFIN_VOLATILE) == ERROR_SUCCESS)
        RgInitRootKeyFromFileInfo(&g_RgDynDataKey);

    ASSERT(!(g_RgDynDataKey.Flags & KEYF_INVALID));
#endif

    return ERROR_SUCCESS;

MemoryError:
    //  Release anything that we may have allocated up to this point.
    VMMRegLibDetach();

    TRACE(("VMMRegLibAttach returning ERROR_OUTOFMEMORY\n"));
    return ERROR_OUTOFMEMORY;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgDetachPredefKey
//
//  Destroys the memory associated with a predefined key and marks the key
//  invalid.
//

VOID
INTERNAL
RgDetachPredefKey(
    HKEY hKey
    )
{

    if (!(hKey-> Flags & KEYF_INVALID)) {
        RgDestroyFileInfo(hKey-> lpFileInfo);
        hKey-> Flags |= KEYF_INVALID;
    }

}
#endif

//
//  VMMRegLibDetach
//
//  Releases resources allocated by VMMRegLibAttach.  This function may be
//  called after VMMRegLibDetach returns an error, so this function and all
//  functions it calls must be aware that their corresponding 'alloc' function
//  was not called.
//

VOID
REGAPI
VMMRegLibDetach(
    VOID
    )
{

    RgEnumFileInfos(RgFlushFileInfo);

#ifdef VXD
    //  Reduce the chance that we'll go and try to touch the file again!
    //g_RgFileAccessDisabled = TRUE;
    // Unfortunately, we cannot disable writing to the file in this case
    // because Win95 allowed it, and there is at least one VXD that attempts to write
    // to the registry when called with the Sys_VM_Terminate message.
    // However, it seemed like a good idea since the file system is shutting down.
#endif

#ifdef WANT_REGREPLACEKEY
    //  Win95 difference: file replacement used to take place on system startup,
    //  not system exit.  It's much easier to deal with file replacement now
    //  since we know somebody called RegReplaceKey and we only have to do the
    //  work in one component, instead of multiple copies in io.sys, VMM loader,
    //  and VMM.
    RgEnumFileInfos(RgReplaceFileInfo);
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
    //
    //  Delete the FILE_INFO of each of these top-level keys will cause all
    //  of their hives to be deleted.
    //

    RgDetachPredefKey(&g_RgLocalMachineKey);
    RgDetachPredefKey(&g_RgUsersKey);

#ifdef WANT_DYNKEY_SUPPORT
    RgDetachPredefKey(&g_RgDynDataKey);
#endif

    RgFreeKeyHandleStructures();

    if (!IsNullPtr(g_RgWorkBuffer))
        RgFreeMemory(g_RgWorkBuffer);
#endif

    ASSERT(g_RgDatablockLockCount == 0);
    ASSERT(g_RgKeynodeLockCount == 0);
#ifdef WANT_FULL_MEMORY_CLEANUP
    ASSERT(g_RgMemoryBlockCount == 0);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regkey.c ===
//
//  REGKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//
//  Implementation of RegCreateKey, RegOpenKey, RegCloseKey, and supporting
//  functions.
//

#include "pch.h"

//
//  RgIsBadSubKey
//
//  Returns TRUE if lpSubKey is a invalid subkey string.  An invalid subkey
//  string may be an invalid pointer or contain double-backslashes or elements
//  greater than MAXIMUM_SUB_KEY_LENGTH.
//

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    )
{

    LPCSTR lpString;
    UINT SubSubKeyLength;
    BYTE Char;

    if (IsNullPtr(lpSubKey))
        return FALSE;

    if (!IsBadStringPtr(lpSubKey, (UINT) -1)) {

        lpString = lpSubKey;
        SubSubKeyLength = 0;

        while (TRUE) {

            Char = *((LPBYTE) lpString);

            if (Char == '\0')
                return FALSE;

            else if (Char == '\\') {
                //  Catch double-backslashes and leading backslashes.  One
                //  leading backslash is acceptable...
                if (SubSubKeyLength == 0 && lpString != lpSubKey)
                    break;
                SubSubKeyLength = 0;
            }

            else {

                if (IsDBCSLeadByte(Char)) {
                    SubSubKeyLength++;
                    //  Catch an unpaired DBCS pair...
                    if (*lpString++ == '\0')
                        break;
                }

                //  Win95 compatibility: don't accept strings with control
                //  characters.
                else if (Char < ' ')
                    break;

                if (++SubSubKeyLength >= MAXIMUM_SUB_KEY_LENGTH)
                    break;

            }

            lpString++;

        }

    }

    return TRUE;

}

//
//  RgGetNextSubSubKey
//
//  Extracts the next subkey component tokenized by backslashes.  Works like
//  strtok where on the first call, lpSubKey points to the start of the subkey.
//  On subsequent calls, lpSubKey is NULL and the last offset is used to find
//  the next component.
//
//  Returns the length of the SubSubKey string.
//

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    )
{

    static LPCSTR lpLastSubSubKey = NULL;
    LPCSTR lpString;
    UINT SubSubKeyLength;

    if (!IsNullPtr(lpSubKey))
        lpLastSubSubKey = lpSubKey;

    lpString = lpLastSubSubKey;

    if (*lpString == '\0') {
        *lplpSubSubKey = NULL;
        *lpSubSubKeyLength = 0;
        return 0;
    }

    if (*lpString == '\\')
        lpString++;
    
    *lplpSubSubKey = lpString;

    while (*lpString != '\0') {

        if (*lpString == '\\')
            break;

        //  The subkey has already been validated, so we know there's a matching
        //  trail byte.
        if (IsDBCSLeadByte(*lpString))
            lpString++;                 //  Trail byte skipped immediately below

        lpString++;

    }

    lpLastSubSubKey = lpString;

    SubSubKeyLength = lpString - *lplpSubSubKey;
    *lpSubSubKeyLength = SubSubKeyLength;

    return SubSubKeyLength;

}

//
//  RgLookupKey
//

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    )
{

    int ErrorCode;
    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;
    BOOL fCreatedKeynode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif
    BOOL fPrevIsNextIndex;
    DWORD SubSubKeyHash;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
    BOOL fFound;
    DWORD PrevKeynodeIndex;
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    DWORD NotifyKeynodeIndex;
#endif
    LPKEYNODE lpNewKeynode;
    HKEY hSubKey;
#ifdef REALMODE
    BOOL secondTry;
#endif

    fCreatedKeynode = FALSE;

    //
    //  Check if the caller is trying to open a key with a NULL or zero-length
    //  sub key string.  If so, simply return hKey.
    //  This also ignores "\"
    //

    if (IsNullPtr(lpSubKey) || RgGetNextSubSubKey(lpSubKey, &lpSubSubKey,
        &SubSubKeyLength) == 0) {
        hSubKey = hKey;
        goto HaveSubKeyHandle;
    }

    //
    // The next two lines fix the problem with Publisher 97. It tries to open
    // HKEY_LOCAL_MACHINE, \KEY_NAME. This was being allowed to succeed by
    // this API. That is because, RlGetNextSubSubKey blasts off the starting
    // '\' and then this api is equivalent to HKEY_LOCAL_MACHINE, KEY_NAME.
    // This is a no-no since Publisher 97 proceeds to blast off the whole
    // registry if we let this call succeed.
    //
    
    if (!(Flags & LK_CREATE)) {
        SubSubKeyLength += (DWORD)lpSubSubKey - (DWORD)lpSubKey;
        lpSubSubKey = lpSubKey;
    }
    
    lpFileInfo = hKey-> lpFileInfo;
    KeynodeIndex = hKey-> ChildKeynodeIndex;
    PrevKeynodeIndex = hKey-> KeynodeIndex;

#ifdef WANT_HIVE_SUPPORT
    //
    //  If this key can have hives attached to it, check there for the first
    //  part of the subkey.  If we have a match, then switch into that
    //  FILE_INFO.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (SubSubKeyLength == lpHiveInfo-> NameLength &&  
                RgStrCmpNI(lpSubSubKey, lpHiveInfo-> Name,
                SubSubKeyLength) == 0) {

                lpFileInfo = lpHiveInfo-> lpFileInfo;
                KeynodeIndex = lpFileInfo-> KeynodeHeader.RootIndex;

                if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                    &lpKeynode)) != ERROR_SUCCESS)
                    return ErrorCode;

                if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
                    goto LookupComplete;

                PrevKeynodeIndex = KeynodeIndex;
                KeynodeIndex = lpKeynode-> ChildIndex;
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

                break;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;

        }

    }
#endif

    //
    //  Walk as deep as we can into the registry tree using existing key
    //  records.  For each subkey component, move to the child of the current
    //  tree position and walk each sibling looking for a match.  Repeat until
    //  we're out of subkey components or we hit the end of a branch.
    //

    fPrevIsNextIndex = FALSE;

    for (;;) {

        SubSubKeyHash = RgHashString(lpSubSubKey, SubSubKeyLength);

        while (!IsNullKeynodeIndex(KeynodeIndex)) {
#ifdef REALMODE
            secondTry = FALSE;
tryAgain:
#endif // REALMODE
            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            if (lpKeynode-> Hash == SubSubKeyHash) {

                if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode->
                    BlockIndex, (BYTE) lpKeynode-> KeyRecordIndex,
                    &lpKeyRecord)) != ERROR_SUCCESS) {
                    RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
#ifdef REALMODE
                    if (!secondTry)
                    {
                        // What happens in real mode, is that we get wedged with the
                        // Keynode block allocated and locked in the middle of the free
                        // space, and there is not a free block large enough for the data block.
                        // So, by unlocking and freeing the Keynode block and then restarting
                        // the operation, the Keynode block gets allocated at the bottom of the
                        // heap, leaving room for the data block.
                        secondTry = TRUE;
                        RgEnumFileInfos(RgSweepFileInfo);
                        RgEnumFileInfos(RgSweepFileInfo);
                        goto tryAgain;
                    }
#endif // REALMODE
                    return ErrorCode;
                }


                fFound = (!(Flags & LK_BIGKEYEXT) == !(lpKeynode-> Flags & KNF_BIGKEYEXT) &&
                    SubSubKeyLength == lpKeyRecord-> NameLength &&
                    RgStrCmpNI(lpSubSubKey, lpKeyRecord-> Name,
                    SubSubKeyLength) == 0);

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

                if (fFound)
                    break;

            }

            //  Unlock the current keynode and advance to its sibling.  Set
            //  fPrevIsNextIndex so that if we have to create, we know that
            //  we'll be inserting the new keynode as a sibling.
            fPrevIsNextIndex = TRUE;
            PrevKeynodeIndex = KeynodeIndex;
            KeynodeIndex = lpKeynode-> NextIndex;
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

        }

        //  Break out if we looped over all the siblings of the previous keynode
        //  or if the previous keynode didn't have any children.  If we're in
        //  create mode, then fPrevIsNextIndex and PrevKeynodeIndex will
        //  represent where we need to start inserting.
        if (IsNullKeynodeIndex(KeynodeIndex))
            break;

        //  Break out there are no more subkey components to lookup.
        //  KeynodeIndex represents the index of the matching key.  It's
        //  corresponding keynode is locked.
        if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
            break;

        //  Unlock the current keynode and advance to its child.  Clear
        //  fPrevIsNextIndex so that if we have to create, we know that we'll
        //  be inserting the new keynode as a child.
        fPrevIsNextIndex = FALSE;
        PrevKeynodeIndex = KeynodeIndex;
        KeynodeIndex = lpKeynode-> ChildIndex;
        RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

    }

    if (IsNullKeynodeIndex(KeynodeIndex)) {

        if (!(Flags & LK_CREATE))
            return ERROR_CANTOPEN16_FILENOTFOUND32;

        if ((IsDynDataKey(hKey) && !(Flags & LK_CREATEDYNDATA)) || (lpFileInfo->
            Flags & FI_READONLY))
            return ERROR_ACCESS_DENIED;

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, PrevKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS) {
            TRACE(("RgLookupKey: failed to lock keynode we just had?\n"));
            return ErrorCode;
        }

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        //  Which keynode index we'll notify of the subkeys we're creating
        //  depends on the state of fPrevIsNextIndex.
        NotifyKeynodeIndex = fPrevIsNextIndex ? lpKeynode-> ParentIndex :
            PrevKeynodeIndex;
#endif

        //  See if there's an open handle on the parent so that we can patch up
        //  its child keynode index member.  We only need this on the first
        //  pass.
        hSubKey = RgFindOpenKeyHandle(lpFileInfo, PrevKeynodeIndex);

        do {

            if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex,
                &lpNewKeynode)) != ERROR_SUCCESS)
                goto CreateAllocFailed1;

            if ((ErrorCode = RgAllocKeyRecord(lpFileInfo, sizeof(KEY_RECORD) +
                SubSubKeyLength - 1, &lpKeyRecord)) != ERROR_SUCCESS) {

                RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                RgFreeKeynode(lpFileInfo, KeynodeIndex);

CreateAllocFailed1:
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, fCreatedKeynode);

                DEBUG_OUT(("RgLookupKey: allocation failed\n"));
                goto SignalAndReturnErrorCode;

            }

            //  Fixup the previous keynode's next offset.
            if (fPrevIsNextIndex) {

                fPrevIsNextIndex = FALSE;
                hSubKey = NULL;
                lpNewKeynode-> ParentIndex = lpKeynode-> ParentIndex;
                lpKeynode-> NextIndex = KeynodeIndex;

            }

            //  Fixup the previous keynode's child offset.
            else {

                lpNewKeynode-> ParentIndex = PrevKeynodeIndex;
                lpKeynode-> ChildIndex = KeynodeIndex;

                //  If hSubKey is not NULL, then we may have to patch up the
                //  child offset cache to point to the newly created keynode.
                if (!IsNullPtr(hSubKey)) {
                    if (IsNullKeynodeIndex(hSubKey-> ChildKeynodeIndex))
                        hSubKey-> ChildKeynodeIndex = KeynodeIndex;
                    hSubKey = NULL;
                }

            }

            //  Fill in the keynode.
            lpNewKeynode-> NextIndex = REG_NULL;
            lpNewKeynode-> ChildIndex = REG_NULL;
            lpNewKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpNewKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;
            lpNewKeynode-> Hash = (WORD) RgHashString(lpSubSubKey,
                SubSubKeyLength);

            //  Fill in the key record.
            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD) + SubSubKeyLength - 1;
            lpKeyRecord-> NameLength = (WORD) SubSubKeyLength;
            MoveMemory(lpKeyRecord-> Name, lpSubSubKey, SubSubKeyLength);
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            //  Unlock the keynode that points to the new keynode and advance
            //  to the next keynode.
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, TRUE);
            PrevKeynodeIndex = KeynodeIndex;
            lpKeynode = lpNewKeynode;

            RgUnlockDatablock(lpFileInfo, lpKeyRecord-> BlockIndex, TRUE);

            fCreatedKeynode = TRUE;

            //  Following should already be zeroed for subsequent iterations.
            ASSERT(!fPrevIsNextIndex);
            ASSERT(IsNullPtr(hSubKey));

        }   while (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength));

    }

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Now we've got the keynode for the request subkey.  Check if it has been
    //  previously opened.  If not, then allocate a new key handle for it and
    //  initialize it.
    //

#ifdef WANT_HIVE_SUPPORT
LookupComplete:
#endif
    if (IsNullPtr(hSubKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex))) {

        if (IsNullPtr(hSubKey = RgCreateKeyHandle()))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            hSubKey-> lpFileInfo = lpFileInfo;
            hSubKey-> KeynodeIndex = KeynodeIndex;
            hSubKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
            hSubKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hSubKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;
            hSubKey-> PredefinedKeyIndex = hKey-> PredefinedKeyIndex;

            if (lpKeynode-> Flags & KNF_BIGKEYROOT)
                hSubKey-> Flags |= KEYF_BIGKEYROOT;
        }

    }

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, fCreatedKeynode);

    //
    //  Now we've got a key handle that references the requested subkey.
    //  Increment the reference count on the handle and return it to the caller.
    //  Note that this differs from NT semantic where they return a unique
    //  handle for every open.
    //

    if (!IsNullPtr(hSubKey)) {
HaveSubKeyHandle:
        RgIncrementKeyReferenceCount(hSubKey);
        *lphSubKey = hSubKey;
        ErrorCode = ERROR_SUCCESS;
    }

SignalAndReturnErrorCode:
    //  If we managed to create any keynodes, regardless of what ErrorCode is
    //  set to now, then we must signal any waiting events.
    if (fCreatedKeynode) {
        RgSignalWaitingNotifies(lpFileInfo, NotifyKeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);
    }

    return ErrorCode;

}

//
//  RgCreateOrOpenKey
//
//  Common routine for VMMRegCreateKey and VMMRegOpenKey.  Valids parameters,
//  locks the registry, and calls the real worker routine.
//

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    )
{

    int ErrorCode;

    if (RgIsBadSubKey(lpSubKey))
        return ERROR_BADKEY;

    if (IsBadHugeWritePtr(lphKey, sizeof(HKEY)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKey(hKey, lpSubKey, lphKey, Flags);

    RgUnlockRegistry();

    return ErrorCode;

}


//
//  VMMRegCreateKey
//
//  See Win32 documentation of RegCreateKey.
//

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_CREATE);

}

//
//  VMMRegOpenKey
//
//  See Win32 documentation of RegOpenKey.
//

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_OPEN);

}

//
//  VMMRegCloseKey
//
//  See Win32 documentation of RegCloseKey.
//

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    )
{

    int ErrorCode;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    ErrorCode = RgValidateAndConvertKeyHandle(&hKey);

    if (ErrorCode == ERROR_SUCCESS || ErrorCode == ERROR_KEY_DELETED) {
        RgDestroyKeyHandle(hKey);
        ErrorCode = ERROR_SUCCESS;
    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regknode.c ===
//
//  REGKNODE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgKeynodeLockCount);

#define HAS_COMPACT_KEYNODES(lpfi)      ((lpfi)-> Flags & FI_VERSION20)

#define SIZEOF_KEYNODE_BLOCK(lpfi)      \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE_BLOCK) : sizeof(W95KEYNODE_BLOCK))

#define SIZEOF_FILE_KEYNODE(lpfi)       \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE) : sizeof(W95KEYNODE))

#define ROUND_UP(i, basesize) (((((i) + (basesize) - 1) / (basesize))) * (basesize))

#define BLOCK_DESC_GROW_SIZE 0x400

#define W95KEYNODES_PER_PAGE            (PAGESIZE / sizeof(W95KEYNODE))

typedef BOOL (INTERNAL *LPPROCESSKEYNODEPROC)(LPKEYNODE, LPW95KEYNODE);

//
//  RgOffsetToIndex
//

DWORD
INTERNAL
RgOffsetToIndex(
    DWORD W95KeynodeOffset
    )
{

    return (W95KeynodeOffset == REG_NULL) ? W95KeynodeOffset :
	(W95KeynodeOffset / sizeof(W95KEYNODE));

}

//
//  RgIndexToOffset
//

DWORD
INTERNAL
RgIndexToOffset(
    DWORD KeynodeIndex
    )
{

    if (IsNullKeynodeIndex(KeynodeIndex))
        return REG_NULL;

    else {
        if (KeynodeIndex >= 2 * W95KEYNODES_PER_PAGE) {
            DWORD dwUnroundedOff = (KeynodeIndex * sizeof(W95KEYNODE))
				  + sizeof(W95KEYNODE)-1;
	    DWORD dwRoundPage = ((dwUnroundedOff & PAGEMASK) / sizeof(W95KEYNODE))
				  * sizeof(W95KEYNODE);
	    return((dwUnroundedOff & ~PAGEMASK) + dwRoundPage);
	} else {
            return(((KeynodeIndex-1)*sizeof(W95KEYNODE))+sizeof(KEYNODE_HEADER));
	}
    }

}

//
//  RgPackKeynode
//
//  Packs the data from the provided W95KEYNODE to the KEYNODE structure.
//

BOOL
INTERNAL
RgPackKeynode(
    LPKEYNODE lpKeynode,
    LPW95KEYNODE lpW95Keynode
    )
{
    lpKeynode->Flags = 0;

    //  Don't use a switch statement here.  Apparently the compiler will treat
    //  lpW95Keynode->W95State as an integer, so the 16-bit compiler ends up truncating
    //  the value.

    if (lpW95Keynode->W95State == KNS_USED ||
        lpW95Keynode->W95State == KNS_BIGUSED ||
        lpW95Keynode->W95State == KNS_BIGUSEDEXT) {
        lpKeynode->Flags = KNF_INUSE;
        lpKeynode->ParentIndex = RgOffsetToIndex(lpW95Keynode->W95ParentOffset);
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextOffset);
        lpKeynode->ChildIndex = RgOffsetToIndex(lpW95Keynode->W95ChildOffset);
        lpKeynode->KeyRecordIndex = LOWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->BlockIndex = HIWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->Hash = (WORD)lpW95Keynode->W95Hash;

        if (lpW95Keynode->W95State == KNS_BIGUSED)
            lpKeynode->Flags |= KNF_BIGKEYROOT;
        else if (lpW95Keynode->W95State == KNS_BIGUSEDEXT)
            lpKeynode->Flags |= KNF_BIGKEYEXT;

    }

    else if (lpW95Keynode->W95State == KNS_FREE || lpW95Keynode->W95State ==
	KNS_ALLFREE) {
	lpKeynode->FreeRecordSize = lpW95Keynode->W95FreeRecordSize;
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextFreeOffset);
	//  Review this later.  Previous versions of this code checked
	//  if the next index was REG_NULL and bailed out of the processing
	//  loop.  It's possible to have a registry with a free keynode sitting
	//  in the middle of some keynode block and that keynode is the last
	//  in the chain.  We don't want to bail out in those cases.
	//
	//  For now, just bail out if the free record size is greater than a
	//  couple keynodes indicating that this is probably the last free
	//  record and the last record of the keynode.
	if (lpKeynode-> FreeRecordSize > (sizeof(W95KEYNODE)*2))
	    return TRUE;
    }

    else {
        DEBUG_OUT(("RgPackKeynode: Unrecognized state (%lx)\n", lpW95Keynode->
            W95State));
    }

    return FALSE;
}

//
//  RgUnpackKeynode
//
//  Unpacks the data from the provided KEYNODE to the W95KEYNODE structure.
//

BOOL
INTERNAL
RgUnpackKeynode(
    LPKEYNODE lpKeynode,
    LPW95KEYNODE lpW95Keynode
    )
{

    if (lpKeynode->Flags & KNF_INUSE) {

        if (lpKeynode->Flags & KNF_BIGKEYROOT)
            lpW95Keynode->W95State = KNS_BIGUSED;
        else if (lpKeynode->Flags & KNF_BIGKEYEXT)
            lpW95Keynode->W95State = KNS_BIGUSEDEXT;
        else
            lpW95Keynode->W95State = KNS_USED;
        lpW95Keynode->W95ParentOffset = RgIndexToOffset(lpKeynode->ParentIndex);
        lpW95Keynode->W95NextOffset = RgIndexToOffset(lpKeynode->NextIndex);
        lpW95Keynode->W95ChildOffset = RgIndexToOffset(lpKeynode->ChildIndex);
        lpW95Keynode->W95Hash = lpKeynode->Hash;

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  The datablock address must be REG_NULL for Win95 to work.
        lpW95Keynode->W95DatablockAddress = IsNullBlockIndex(lpKeynode->
            BlockIndex) ? REG_NULL : MAKELONG(lpKeynode-> KeyRecordIndex,
            lpKeynode-> BlockIndex);

    }

    else {

        lpW95Keynode->W95State = KNS_FREE;
        lpW95Keynode->W95FreeRecordSize = lpKeynode->FreeRecordSize;
        lpW95Keynode->W95NextFreeOffset = RgIndexToOffset(lpKeynode->NextIndex);

    }

    return FALSE;

}

//
//  RgProcessKeynodeBlock
//
//  The provided callback function is called for each pair of KEYNODE and
//  W95KEYNODE structures from the given keynode blocks.
//

VOID
INTERNAL
RgProcessKeynodeBlock(
    DWORD dwStartOffset,
    DWORD dwBlockSize,
    LPKEYNODE_BLOCK lpKeynodeBlock,
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock,
    LPPROCESSKEYNODEPROC lpfnProcessKeynode
    )
{

    DWORD dwCurOffset;
    LPKEYNODE lpKeynode;
    LPW95KEYNODE lpW95Keynode;
    UINT SkipSize;

    dwCurOffset = dwStartOffset;
    lpW95Keynode = &lpW95KeynodeBlock->aW95KN[0];
    SkipSize = (dwStartOffset == 0) ? sizeof(KEYNODE_HEADER) : 0;

    for (;;) {

        lpW95Keynode = (LPW95KEYNODE)(((LPBYTE)lpW95Keynode)+SkipSize);
        dwCurOffset += SkipSize;

	if (dwCurOffset >= dwStartOffset+dwBlockSize) {
	    goto Done;
	}
        lpKeynode = &lpKeynodeBlock->aKN[KN_INDEX_IN_BLOCK(RgOffsetToIndex(dwCurOffset))];
	while ((dwCurOffset < dwStartOffset+dwBlockSize) &&
	       ((dwCurOffset >> PAGESHIFT) == 0) ||
	       ((dwCurOffset >> PAGESHIFT) ==
		((dwCurOffset + sizeof(W95KEYNODE)) >> PAGESHIFT))) {
            if (lpfnProcessKeynode(lpKeynode, lpW95Keynode)) {
		goto Done;
	    }
	    dwCurOffset += sizeof(W95KEYNODE);
            lpW95Keynode++;
            lpKeynode++;
	}
	//
	//  Compute the number of bytes to skip to get to the next page
	//
        SkipSize = PAGESIZE - (UINT) (dwCurOffset & PAGEMASK);
    }
    Done: {};

}

//
//  RgLockKeynode
//

int
INTERNAL
RgLockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    )
{

    int ErrorCode;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockSize;
    HFILE hFile;
    LPKEYNODE_BLOCK lpKeynodeBlock;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;
    DWORD BlockOffset;
    UINT ReadBlockSize;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);

    if (KeynodeBlockIndex > lpFileInfo-> KeynodeBlockCount) {
        DEBUG_OUT(("RgLockKeynode: invalid keynode offset\n"));
        return ERROR_BADDB;
    }

    //
    //  Is the keynode block currently in memory?
    //

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
        KeynodeBlockIndex);
    lpKeynodeBlock = lpKeynodeBlockInfo-> lpKeynodeBlock;

    if (IsNullPtr(lpKeynodeBlock)) {

        NOISE(("RgLockKeynode: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", KeynodeBlockIndex));

        if (IsNullPtr((lpKeynodeBlock = (LPKEYNODE_BLOCK)
            RgAllocMemory(sizeof(KEYNODE_BLOCK)))))
            return ERROR_OUTOFMEMORY;

        KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
        BlockOffset = (DWORD) KeynodeBlockIndex * KeynodeBlockSize;

        if (BlockOffset < lpFileInfo-> KeynodeHeader.FileKnSize) {

            ASSERT(!(lpFileInfo-> Flags & FI_VOLATILE));

            ReadBlockSize = (UINT) min(KeynodeBlockSize, (lpFileInfo->
                KeynodeHeader.FileKnSize - BlockOffset));

            if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
                HFILE_ERROR)
                goto CleanupAfterFileError;

            if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

                if (!RgSeekFile(hFile, sizeof(VERSION20_HEADER_PAGE) +
                    BlockOffset))
                    goto CleanupAfterFileError;

                if (!RgReadFile(hFile, lpKeynodeBlock, ReadBlockSize))
                    goto CleanupAfterFileError;

            }

            else {

                if (!RgSeekFile(hFile, sizeof(FILE_HEADER) + BlockOffset))
                    goto CleanupAfterFileError;

                lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();

                if (!RgReadFile(hFile, lpW95KeynodeBlock, ReadBlockSize)) {
                    RgUnlockWorkBuffer(lpW95KeynodeBlock);
                    goto CleanupAfterFileError;
                }

                RgProcessKeynodeBlock(BlockOffset, ReadBlockSize,
                    lpKeynodeBlock, lpW95KeynodeBlock, RgPackKeynode);

                RgUnlockWorkBuffer(lpW95KeynodeBlock);

            }

            RgCloseFile(hFile);

        }

        lpKeynodeBlockInfo-> lpKeynodeBlock = lpKeynodeBlock;
        lpKeynodeBlockInfo-> Flags = 0;
        lpKeynodeBlockInfo-> LockCount = 0;

    }

    *lplpKeynode = &lpKeynodeBlock-> aKN[KN_INDEX_IN_BLOCK(KeynodeIndex)];
    lpKeynodeBlockInfo-> Flags |= KBIF_ACCESSED;
    lpKeynodeBlockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);
    return ERROR_SUCCESS;

CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

    RgFreeMemory(lpKeynodeBlock);

    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    DEBUG_OUT(("RgLockKeynode() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgLockInUseKeynode
//
//  Wrapper for RgLockKeynode that guarantees that the returned keynode is
//  marked as being in-use.  If not, ERROR_BADDB is returned.
//

int
INTERNAL
RgLockInUseKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    )
{

    int ErrorCode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, lplpKeynode)) ==
        ERROR_SUCCESS) {
        if (!((*lplpKeynode)-> Flags & KNF_INUSE)) {
            DEBUG_OUT(("RgLockInUseKeynode: keynode unexpectedly not marked used\n"));
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            ErrorCode = ERROR_BADDB;
        }
    }

    return ErrorCode;

}

//
//  RgUnlockKeynode
//

VOID
INTERNAL
RgUnlockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    BOOL fMarkDirty
    )
{

    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);
    ASSERT(KeynodeBlockIndex < lpFileInfo-> KeynodeBlockCount);

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
        KeynodeBlockIndex);

    ASSERT(lpKeynodeBlockInfo-> LockCount > 0);
    lpKeynodeBlockInfo-> LockCount--;

    if (fMarkDirty) {
        lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);

}

//
//  RgAllocKeynode
//

int
INTERNAL
RgAllocKeynode(
    LPFILE_INFO lpFileInfo,
    LPDWORD lpKeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    )
{

    int ErrorCode;
    DWORD FreeKeynodeOffset;
    DWORD FreeKeynodeIndex;
    UINT FreeRecordSize;
    UINT ExtraPadding;
    UINT KeynodeBlockIndex;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPKEYNODE lpKeynode;
    DWORD NextFreeKeynodeIndex;
    LPKEYNODE lpNextFreeKeynode;
    UINT KeynodeSize;

    FreeKeynodeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  If no more free keynodes exist, then we try to extend the keynode table
    //  to provide more entries.
    if (IsNullKeynodeIndex(FreeKeynodeIndex)) {

        if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
            FreeKeynodeIndex = ROUND_UP(lpFileInfo-> CurTotalKnSize, PAGESIZE) /
                sizeof(KEYNODE);
            FreeRecordSize = PAGESIZE;
	    ExtraPadding = 0;
        }

        else {

            //  Handle the special case of a new file being created: for
            //  uncompacted keynode tables, the first offset is immediately
            //  after the keynode header and the size of the free record must
            //  account for  the size of this header.
            if (lpFileInfo-> CurTotalKnSize == sizeof(KEYNODE_HEADER)) {
                FreeKeynodeOffset = sizeof(KEYNODE_HEADER);
		    //  Win95 compatiblity:  Same initial table size, plus
		    //  causes us to stress the below special grow case.
		    FreeRecordSize = PAGESIZE - sizeof(KEYNODE_HEADER) * 2;
		    ExtraPadding = 0;
            }

            else {

		    FreeKeynodeOffset = ROUND_UP(lpFileInfo-> CurTotalKnSize,
                        PAGESIZE);
                    FreeRecordSize = PAGESIZE;
                    ExtraPadding = (UINT) (FreeKeynodeOffset - lpFileInfo->
                        CurTotalKnSize);

		    //  Handle the case of a keynode table with a non-integral
		    //  number of pages.  We'll place the new free keynode at the
		    //  top of the existing keynode table with a size including
		    //  the remaining bytes on the page plus a new page (effectively
		    //  the same as Win95).
		    if (ExtraPadding > sizeof(W95KEYNODE) || FreeKeynodeOffset ==
		        PAGESIZE) {
		        //	Although this code will work for any non-integral
		        //	number of pages, it should ONLY occur for <4K tables.
		        ASSERT(FreeKeynodeOffset == PAGESIZE);
		        FreeRecordSize += ExtraPadding;
		        FreeKeynodeOffset = lpFileInfo-> CurTotalKnSize;
		        ExtraPadding = 0;
                }

            }

            FreeKeynodeIndex = RgOffsetToIndex(FreeKeynodeOffset);

        }

        KeynodeBlockIndex = KN_BLOCK_NUMBER(FreeKeynodeIndex);

        //  Put in some sort of "max" count/KEYNODE_BLOCKS_PER_FILE
        //  check.

        //  Check if lpKeynodeBlockInfo is too small to hold the info for a new
        //  keynode block.  If so, then we must grow it a bit.
        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockInfoAllocCount) {

            AllocCount = KeynodeBlockIndex + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

            if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
                RgSmReAllocMemory(lpFileInfo-> lpKeynodeBlockInfo, AllocCount *
                sizeof(KEYNODE_BLOCK_INFO)))))
                return ERROR_OUTOFMEMORY;

            ZeroMemory(lpKeynodeBlockInfo + lpFileInfo->
                KeynodeBlockInfoAllocCount, (AllocCount - lpFileInfo->
                KeynodeBlockInfoAllocCount) * sizeof(KEYNODE_BLOCK_INFO));

            lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
            lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

        }

        if (KeynodeBlockIndex < lpFileInfo-> KeynodeBlockCount)
        {
    	    lpFileInfo-> CurTotalKnSize += (FreeRecordSize + ExtraPadding);
            lpFileInfo-> Flags |= FI_EXTENDED;
            lpFileInfo-> KeynodeHeader.FirstFreeIndex = FreeKeynodeIndex;
        }

        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockCount)
        {
            lpFileInfo-> KeynodeBlockCount = KeynodeBlockIndex + 1;

    	    lpFileInfo-> CurTotalKnSize += (FreeRecordSize + ExtraPadding);
            lpFileInfo-> Flags |= FI_EXTENDED;
            lpFileInfo-> KeynodeHeader.FirstFreeIndex = FreeKeynodeIndex;
        }
        
        lpKeynode-> NextIndex = REG_NULL;
        lpKeynode-> Flags = 0;
        lpKeynode-> FreeRecordSize = FreeRecordSize;

    }

    else {
        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;
    }

    NextFreeKeynodeIndex = lpKeynode-> NextIndex;
    KeynodeSize = SIZEOF_FILE_KEYNODE(lpFileInfo);

    //  If the free keynode record can be broken up into smaller chunks, then
    //  create another free record immediately after the one we're about to
    //  snag.
    if ((lpKeynode-> FreeRecordSize >= KeynodeSize * 2) &&
        (RgLockKeynode(lpFileInfo, FreeKeynodeIndex + 1, &lpNextFreeKeynode) ==
        ERROR_SUCCESS)) {

	//  Copy the next link from the current free keynode (likely REG_NULL).
        lpNextFreeKeynode-> NextIndex = NextFreeKeynodeIndex;
        lpNextFreeKeynode-> Flags = 0;
        lpNextFreeKeynode-> FreeRecordSize = lpKeynode-> FreeRecordSize -
            KeynodeSize;

        NextFreeKeynodeIndex = FreeKeynodeIndex + 1;
        RgUnlockKeynode(lpFileInfo, NextFreeKeynodeIndex, TRUE);

    }

    lpFileInfo-> KeynodeHeader.FirstFreeIndex = NextFreeKeynodeIndex;

    lpKeynode-> Flags |= KNF_INUSE;

    //  Mark the keynode block that holds this keynode dirty.
    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
        KN_BLOCK_NUMBER(FreeKeynodeIndex));
    lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
    lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
    RgDelayFlush();

    //  WARNING:  The following two statements used to be above the block that
    //  dirtied the keynode.  The 16-bit compiler messed up and
    //  lpKeynodeBlockInfo ended up with a bogus offset thus corrupting random
    //  memory.  Be sure to trace through this function if you change it!
    *lpKeynodeIndex = FreeKeynodeIndex;
    *lplpKeynode = lpKeynode;

    return ERROR_SUCCESS;

}

//
//  RgFreeKeynode
//
//  Marks the specified keynode index free and adds it to the hive's free
//  keynode list.
//

int
INTERNAL
RgFreeKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, &lpKeynode)) ==
        ERROR_SUCCESS) {

        lpKeynode-> Flags &= ~(KNF_INUSE | KNF_BIGKEYROOT | KNF_BIGKEYEXT);
        lpKeynode-> NextIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;
        lpKeynode-> FreeRecordSize = SIZEOF_FILE_KEYNODE(lpFileInfo);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = KeynodeIndex;

        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    }

    return ErrorCode;

}

//
//  RgGetKnBlockIOInfo
//

VOID
INTERNAL
RgGetKnBlockIOInfo(
    LPFILE_INFO lpFileInfo,
    DWORD       BaseKeynodeIndex,
    UINT FAR*   lpFileBlockSize,
    LONG FAR*   lpFileOffset
    )
{

    UINT FileBlockSize;
    DWORD FileOffset;
    DWORD BaseKeynodeOffset;

    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

        FileBlockSize = sizeof(KEYNODE_BLOCK);

        BaseKeynodeOffset = BaseKeynodeIndex * sizeof(KEYNODE);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                BaseKeynodeOffset);

        FileOffset = sizeof(VERSION20_HEADER_PAGE) + BaseKeynodeIndex *
            sizeof(KEYNODE);

    }

    else {

        FileBlockSize = sizeof(W95KEYNODE_BLOCK);

        //  The first keynode block of an uncompacted keynode table should
        //  start writing AFTER the keynode header.
        if (BaseKeynodeIndex == 0) {
            BaseKeynodeIndex = RgOffsetToIndex(sizeof(KEYNODE_HEADER));
            FileBlockSize -= sizeof(KEYNODE_HEADER);
	}

        BaseKeynodeOffset = RgIndexToOffset(BaseKeynodeIndex);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                BaseKeynodeOffset);

        FileOffset = sizeof(FILE_HEADER) + BaseKeynodeOffset;

    }

    *lpFileBlockSize = FileBlockSize;
    *lpFileOffset = FileOffset;

}



int
_inline
RgCopyKeynodeBlock(
    LPFILE_INFO lpFileInfo,
    DWORD BaseIndex,
    HFILE hSrcFile,
    HFILE hDestFile
    )
{
    UINT FileBlockSize;
    LONG FileOffset;
    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);
    return RgCopyFileBytes(hSrcFile,
			  FileOffset,
			  hDestFile,
			  FileOffset,
			  FileBlockSize);
}

//
//  RgWriteKeynodeBlock
//

int
INTERNAL
RgWriteKeynodeBlock(
    LPFILE_INFO lpFileInfo,
    DWORD BaseIndex,
    HFILE hDestFile,
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo
    )
{
    int ErrorCode;
    UINT FileBlockSize;
    LONG FileOffset;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;

    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;       // Assume I/O fails
    if (!RgSeekFile(hDestFile, FileOffset)) {
        goto Exit;
    }
    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
        if (RgWriteFile(hDestFile, lpKeynodeBlockInfo->lpKeynodeBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
    } else {
        LPBYTE lpWriteBlock;
        lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();
        RgProcessKeynodeBlock(
			    BaseIndex * sizeof(W95KEYNODE),
			    FileBlockSize,
                            lpKeynodeBlockInfo->lpKeynodeBlock,
                            lpW95KeynodeBlock,
                            RgUnpackKeynode);
        lpWriteBlock = (LPBYTE)lpW95KeynodeBlock;
        if (BaseIndex == 0) {
            lpWriteBlock += sizeof(KEYNODE_HEADER);
        }
        if (RgWriteFile(hDestFile, lpWriteBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
        RgUnlockWorkBuffer(lpW95KeynodeBlock);
    }
Exit:   ;
    return(ErrorCode);
}

//
//  RgWriteKeynodes
//

int
INTERNAL
RgWriteKeynodes(
    LPFILE_INFO lpFileInfo,
    HFILE hSrcFile,
    HFILE hDestFile
    )
{

    DWORD SavedRootIndex;
    DWORD SavedFreeIndex;
    DWORD SavedFileKnSize;
    BOOL fResult;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    if ((hSrcFile == HFILE_ERROR) && !(lpFileInfo->Flags & FI_KEYNODEDIRTY))
        return ERROR_SUCCESS;

    NOISE(("writing keynodes of "));
    NOISE((lpFileInfo-> FileName));
    NOISE(("\n"));

    //
    //	Write out the keynode header.  If the keynodes are not compact then
    //	convert to offsets before writing.
    //

    if (!RgSeekFile(hDestFile, sizeof(FILE_HEADER)))
        return ERROR_REGISTRY_IO_FAILED;

    SavedFileKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;
    SavedRootIndex = lpFileInfo-> KeynodeHeader.RootIndex;
    SavedFreeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  Write the real size of the keynode table to disk.
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    //  Convert keynode indexes back to offsets temporarily for uncompacted
    //  keynode tables.
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgIndexToOffset(lpFileInfo->
            KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgIndexToOffset(lpFileInfo->
            KeynodeHeader.FirstFreeIndex);
    }

    fResult = RgWriteFile(hDestFile, &lpFileInfo-> KeynodeHeader,
        sizeof(KEYNODE_HEADER));

    lpFileInfo-> KeynodeHeader.FileKnSize = SavedFileKnSize;
    lpFileInfo-> KeynodeHeader.RootIndex = SavedRootIndex;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = SavedFreeIndex;

    if (!fResult)
        return ERROR_REGISTRY_IO_FAILED;

    //
    //	Now loop through each block.
    //

    lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;

    for (KeynodeBlockIndex = 0; KeynodeBlockIndex < lpFileInfo->
        KeynodeBlockCount; KeynodeBlockIndex++, lpKeynodeBlockInfo++) {

        DWORD BaseKeynodeIndex = KeynodeBlockIndex * KEYNODES_PER_BLOCK;

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {
            if (hSrcFile != HFILE_ERROR || lpKeynodeBlockInfo-> Flags &
                KBIF_DIRTY) {
                if (RgWriteKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hDestFile,
                    lpKeynodeBlockInfo) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

        else {
            if (hSrcFile != HFILE_ERROR) {
                if (RgCopyKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hSrcFile,
                    hDestFile) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteKeynodesComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteKeynodesComplete(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    lpFileInfo-> Flags &= ~FI_KEYNODEDIRTY;
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
        lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++)
        lpKeynodeBlockInfo-> Flags &= ~KBIF_DIRTY;

}

//
//  RgSweepKeynodes
//
//  Makes a pass through all the present keynode blocks of the given FILE_INFO
//  structure and discards keynode blocks that have not been accessed since the
//  last sweep.
//

VOID
INTERNAL
RgSweepKeynodes(
    LPFILE_INFO lpFileInfo
    )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
        lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++) {

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {

            if (((lpKeynodeBlockInfo-> Flags & (KBIF_ACCESSED | KBIF_DIRTY)) ==
                0) && (lpKeynodeBlockInfo-> LockCount == 0)) {
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
                lpKeynodeBlockInfo-> lpKeynodeBlock = NULL;
            }

            lpKeynodeBlockInfo-> Flags &= ~KBIF_ACCESSED;

	}

    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitKeynodeInfo
//
//  Initializes fields in the provided FILE_INFO related to the keynode table.
//

int
INTERNAL
RgInitKeynodeInfo(
    LPFILE_INFO lpFileInfo
    )
{

    UINT KeynodeBlockSize;
    UINT BlockCount;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
    BlockCount = (UINT) ((DWORD) (lpFileInfo-> KeynodeHeader.FileKnSize +
        KeynodeBlockSize - 1) / (DWORD) KeynodeBlockSize);
    AllocCount = BlockCount + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

    if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
        RgSmAllocMemory(AllocCount * sizeof(KEYNODE_BLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpKeynodeBlockInfo, AllocCount * sizeof(KEYNODE_BLOCK_INFO));
    lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
    lpFileInfo-> KeynodeBlockCount = BlockCount;
    lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

    lpFileInfo-> KeynodeHeader.Flags &= ~(KHF_DIRTY | KHF_EXTENDED |
        KHF_HASCHECKSUM);

    //  Convert file offsets to index values for uncompressed files
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgOffsetToIndex(lpFileInfo->
            KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgOffsetToIndex(lpFileInfo->
            KeynodeHeader.FirstFreeIndex);
    }

    lpFileInfo-> CurTotalKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regknode.h ===
//
//  REGKNODE.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKNODE_
#define _REGKNODE_

int
INTERNAL
RgInitKeynodeInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgLockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgLockInUseKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

VOID
INTERNAL
RgUnlockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgWriteKeynodes(
    LPFILE_INFO lpFileInfo,
    HFILE hSrcFile,
    HFILE hDestFile
    );

VOID
INTERNAL
RgWriteKeynodesComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepKeynodes(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeynode(
    LPFILE_INFO lpFileInfo,
    LPDWORD lpKeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgFreeKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

#endif // _REGKNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regkylst.h ===
//
//  REGKYLST.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKYLST_
#define _REGKYLST_

VOID
INTERNAL
RgInitPredefinedKeys(
    VOID
    );

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    );

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    );

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    );

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    );

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    );

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    );

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    );

extern KEY g_RgLocalMachineKey;
extern KEY g_RgUsersKey;
#ifdef WANT_DYNKEY_SUPPORT
extern KEY g_RgDynDataKey;
#endif

#endif // _REGKYLST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regkylst.c ===
//
//  REGKYLST.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Declares the predefined key structures and manages dynamic HKEY structures.
//

#include "pch.h"
#include <limits.h>

//  We would rather just have one definition a
#ifdef WANT_DYNKEY_SUPPORT
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL,                                       \
        NULL                                            \
    }
#else
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL                                        \
    }
#endif

KEY g_RgLocalMachineKey =
    INITED_PREDEFINED_KEY(INDEX_LOCAL_MACHINE, KEYF_HIVESALLOWED);
KEY g_RgUsersKey = INITED_PREDEFINED_KEY(INDEX_USERS, KEYF_HIVESALLOWED);
#ifdef WANT_DYNKEY_SUPPORT
KEY g_RgDynDataKey = INITED_PREDEFINED_KEY(INDEX_DYN_DATA, 0);
#endif

HKEY g_RgPredefinedKeys[] = {
    NULL,                                       //  HKEY_CLASSES_ROOT
    NULL,                                       //  HKEY_CURRENT_USER
    &g_RgLocalMachineKey,                       //  HKEY_LOCAL_MACHINE
    &g_RgUsersKey,                              //  HKEY_USERS
    NULL,                                       //  HKEY_PERFORMANCE_DATA
    NULL,                                       //  HKEY_CURRENT_CONFIG
#ifdef WANT_DYNKEY_SUPPORT
    &g_RgDynDataKey,                            //  HKEY_DYN_DATA
#endif
};

#define NUMBER_PREDEF_KEYS      (sizeof(g_RgPredefinedKeys) / sizeof(HKEY))

#ifdef WANT_STATIC_KEYS
#define NUMBER_STATIC_KEYS              32
HKEY g_RgStaticKeyArray = NULL;
#endif

//  List of all dynamically allocated keys.
HKEY g_RgDynamicKeyList = NULL;

const char g_RgClassesRootSubKey[] = "SOFTWARE\\CLASSES";
const char g_RgCurrentUserSubKey[] = ".DEFAULT";


//
// RgInitPredefinedKeys
// 

VOID
INTERNAL
RgInitPredefinedKeys(
    VOID
    )
{
    KEY localMachineKey = INITED_PREDEFINED_KEY(INDEX_LOCAL_MACHINE, KEYF_HIVESALLOWED);
    KEY usersKey = INITED_PREDEFINED_KEY(INDEX_USERS, KEYF_HIVESALLOWED);

    g_RgLocalMachineKey = localMachineKey;
    g_RgUsersKey = usersKey;
}


#ifdef WANT_STATIC_KEYS
//
//  RgAllocKeyHandleStructures
//

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    )
{

    UINT Index;
    HKEY hKey;

    ASSERT(IsNullPtr(g_RgStaticKeyArray));
    ASSERT(IsNullPtr(g_RgDynamicKeyList));

    //
    //  Allocate and initialize the static key table.
    //

    g_RgStaticKeyArray = RgSmAllocMemory(NUMBER_STATIC_KEYS * sizeof(KEY));

    if (IsNullPtr(g_RgStaticKeyArray))
        return FALSE;

    for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
        Index--, hKey++) {
        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = KEYF_STATIC | KEYF_INVALID;
        hKey-> ReferenceCount = 0;
    }

    return TRUE;

}
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgFreeKeyHandleStructures
//
//  Releases resources allocated by RgAllocKeyHandleStructures.
//

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    )
{

    HKEY hTempKey;
    HKEY hKey;

    //
    //  Delete all of the dynamically allocated keys.
    //

    hKey = g_RgDynamicKeyList;

    if (!IsNullPtr(hKey)) {
        do {
            hTempKey = hKey;
            hKey = hKey-> lpNext;
#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hTempKey-> pProvider))
                RgSmFreeMemory(hTempKey-> pProvider);
#endif
            RgSmFreeMemory(hTempKey);
        }   while (hKey != g_RgDynamicKeyList);
    }

    g_RgDynamicKeyList = NULL;

#ifdef WANT_STATIC_KEYS
    //
    //  Delete the static key table.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {
        RgSmFreeMemory(g_RgStaticKeyArray);
        g_RgStaticKeyArray = NULL;
    }
#endif

}
#endif

//
//  RgCreateKeyHandle
//
//  Allocates one KEY structure, initializes some of its members, and links it
//  to the list of open key handles.
//

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    )
{

#ifdef WANT_STATIC_KEYS
    UINT Index;
#endif
    HKEY hKey;

#ifdef WANT_STATIC_KEYS
    //
    //  Check if any keys are available in the static pool.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> Flags & KEYF_INVALID) {
                ASSERT(hKey-> ReferenceCount == 0);
                hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED |
                    KEYF_ENUMKEYCACHED);
                return hKey;
            }
        }

    }
#endif

    //
    //  Must allocate a dynamic key.  Initialize it and add it to our list.
    //

    hKey = (HKEY) RgSmAllocMemory(sizeof(KEY));

    if (!IsNullPtr(hKey)) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = 0;
        hKey-> ReferenceCount = 0;
#ifdef WANT_DYNKEY_SUPPORT
        hKey-> pProvider = NULL;
#endif

        if (IsNullPtr(g_RgDynamicKeyList)) {
            hKey-> lpPrev = hKey;
            hKey-> lpNext = hKey;
        }

        else if (hKey != g_RgDynamicKeyList) {
            hKey-> lpNext = g_RgDynamicKeyList;
            hKey-> lpPrev = g_RgDynamicKeyList-> lpPrev;
            hKey-> lpPrev-> lpNext = hKey;
            g_RgDynamicKeyList-> lpPrev = hKey;
        }

        g_RgDynamicKeyList = hKey;

    }

    return hKey;

}

//
//  RgDeleteKeyHandle
//
//  Decrements the reference count on the given key handle.  If the count
//  reaches zero and the key was dynamically allocated, then the key is unlinked
//  from the key list and the key is freed.
//

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    )
{

    ASSERT(!IsNullPtr(hKey));

    //	Don't allow the reference count to underflow for predefined keys or
    //	keys marked "never delete".
    if (hKey-> ReferenceCount > 0)
        hKey-> ReferenceCount--;

    if (hKey-> ReferenceCount == 0) {

        if (!(hKey-> Flags & (KEYF_PREDEFINED | KEYF_NEVERDELETE))) {

#ifdef WANT_STATIC_KEYS
            if (hKey-> Flags & KEYF_STATIC) {
                hKey-> Flags |= KEYF_INVALID;
                return;
            }
#endif

            if (hKey == hKey-> lpNext)
                g_RgDynamicKeyList = NULL;

            else {

                hKey-> lpPrev-> lpNext = hKey-> lpNext;
                hKey-> lpNext-> lpPrev = hKey-> lpPrev;

                if (hKey == g_RgDynamicKeyList)
                    g_RgDynamicKeyList = hKey-> lpNext;

            }

#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hKey-> pProvider))
                RgSmFreeMemory(hKey-> pProvider);
#endif

            hKey-> Signature = 0;
            RgSmFreeMemory(hKey);

        }

    }

}

//
//  RgValidateAndConvertKeyHandle
//
//  Verifies the the given key handle is valid.  If the handle is one of the
//  special predefined constants, then it is converted to the handle of the
//  real KEY structure.
//

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    )
{

    HKEY hKey;
    UINT Index;
    HKEY hRootKey;
    LPCSTR lpSubKey;

    hKey = *lphKey;

    //
    //  Check if this is one of the predefined key handles.
    //

    if ((DWORD) HKEY_CLASSES_ROOT <= (DWORD) hKey &&
        (DWORD) hKey < (DWORD) HKEY_CLASSES_ROOT + NUMBER_PREDEF_KEYS) {

        Index = (UINT) ((DWORD) hKey - (DWORD) HKEY_CLASSES_ROOT);
        hKey = g_RgPredefinedKeys[Index];

        //  If the predefined handle is not valid, we'll try to (re)open it for
        //  use.  This isn't pretty, but in the typical case, this code path is
        //  only executed once per handle.
        if (IsNullPtr(hKey) || (hKey-> Flags & KEYF_DELETED)) {

            if (Index == INDEX_CLASSES_ROOT) {
                hRootKey = &g_RgLocalMachineKey;
                lpSubKey = g_RgClassesRootSubKey;
            }

            else if (Index == INDEX_CURRENT_USER) {
                hRootKey = &g_RgUsersKey;
                lpSubKey = g_RgCurrentUserSubKey;
            }
#ifndef VXD
			else if (Index == INDEX_USERS) {
				goto ReturnKeyAndSuccess;
			}
#endif
            else
                return ERROR_BADKEY;

            //  Extremely rare case: somebody has deleted one of the predefined
            //  key paths.  We'll clear the predefined bit on this key and throw
            //  it away.
            if (!IsNullPtr(hKey)) {
                g_RgPredefinedKeys[Index] = NULL;
                hKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hKey);
            }

            //  If the base root key for this predefined key is valid, attempt
            //  to open the key.  Mark the key as predefined so that bad apps
            //  can't close a key more times then it has opened it.
            if (!(hRootKey-> Flags & KEYF_INVALID) && RgLookupKey(hRootKey,
                lpSubKey, &hKey, LK_CREATE) == ERROR_SUCCESS) {
                g_RgPredefinedKeys[Index] = hKey;
                hKey-> Flags |= KEYF_PREDEFINED;
                hKey-> PredefinedKeyIndex = (BYTE) Index;
                goto ReturnKeyAndSuccess;
            }

            return ERROR_BADKEY;

        }

ReturnKeyAndSuccess:
        *lphKey = hKey;
        return (hKey-> Flags & KEYF_INVALID) ? ERROR_BADKEY : ERROR_SUCCESS;

    }

    else {

        if (IsBadHugeReadPtr(hKey, sizeof(KEY)) || hKey-> Signature !=
            KEY_SIGNATURE || (hKey-> Flags & KEYF_INVALID))
            return ERROR_BADKEY;

        return (hKey-> Flags & KEYF_DELETED) ? ERROR_KEY_DELETED :
            ERROR_SUCCESS;

    }

}

//
//  RgIncrementKeyReferenceCount
//
//  Safely increments the reference count of the specified KEY.  If the count
//  overflows, then the key is marked as "never delete" since the usage count
//  is now unknown.
//

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    )
{

    if (hKey-> ReferenceCount != UINT_MAX)
        hKey-> ReferenceCount++;
    else {
        if (!(hKey-> Flags & KEYF_NEVERDELETE)) {
            TRACE(("RgIncrementKeyReferenceCount: handle %lx has overflowed\n",
                hKey));
        }
        hKey-> Flags |= KEYF_NEVERDELETE;
    }

}

//
//  RgFindOpenKeyHandle
//
//  Searches the list of currently opened keys for a key that refers to the same
//  FILE_INFO structure and keynode offset.  If found, the HKEY is returned, or
//  if not, NULL.
//

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Check if this is one of the predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey) && hKey-> lpFileInfo == lpFileInfo && hKey->
            KeynodeIndex == KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED |
            KEYF_INVALID)))
            return hKey;

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Check if this is one of the static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo && hKey-> KeynodeIndex ==
                KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED | KEYF_INVALID)))
                return hKey;
        }

    }
#endif

    //
    //  Check if this is one of the dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> KeynodeIndex == KeynodeIndex && hKey-> lpFileInfo ==
                lpFileInfo && !(hKey-> Flags & KEYF_DELETED))
                return hKey;

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

    return NULL;

}

//
//  RgInvalidateKeyHandles
//
//  Generic routine to invalidate key handles based on a set of criteria.
//  If any key handle meets any of the given criteria, then it's marked invalid.
//

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    //
    //  Invalidate predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey)) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Invalidate static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }
#endif

    //
    //  Invalidate dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  VMMRegMapPredefKeyToKey
//

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hTargetKey,
    HKEY hPredefKey
    )
{

    int ErrorCode;
    UINT PredefinedKeyIndex;
    HKEY hOldKey;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hTargetKey)) ==
        ERROR_SUCCESS) {

        if ((hPredefKey == HKEY_CURRENT_USER && hTargetKey->
            PredefinedKeyIndex == INDEX_USERS) || (hPredefKey ==
            HKEY_CURRENT_CONFIG && hTargetKey-> PredefinedKeyIndex ==
            INDEX_LOCAL_MACHINE)) {

            PredefinedKeyIndex = (UINT) ((DWORD) hPredefKey - (DWORD)
                HKEY_CLASSES_ROOT);

            hOldKey = g_RgPredefinedKeys[PredefinedKeyIndex];

            if (!IsNullPtr(hOldKey)) {

                //  Invalidate open handles based off the existing predefined
                //  key handle.  Win95 behavior.
                RgInvalidateKeyHandles((LPFILE_INFO) -1L, (BYTE)
                    PredefinedKeyIndex);

                hOldKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hOldKey);

            }

            hTargetKey-> Flags |= KEYF_PREDEFINED;
            RgIncrementKeyReferenceCount(hTargetKey);
            g_RgPredefinedKeys[PredefinedKeyIndex] = hTargetKey;

        }

        else {
            DEBUG_OUT(("VMMRegMapPredefKeyToKey: invalid hTargetKey\n"));
            ErrorCode = ERROR_BADKEY;
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regmem.c ===
//
//  REGMEM.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Upper-level memory management functions that discards unlocked memory blocks
//  as required to fulfill allocation requests.
//
//  For the ring zero version of this code, only large requests will call these
//  functions.  For most registry files, these requests will already be an
//  integral number of pages, so it's best just to do page allocations.  Small
//  allocations, such as key handles,  will use the heap services and not go
//  through this code.
//
//  For all other models of this code, all memory requests will go through this
//  code and memory is allocated from the heap.
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgMemoryBlockCount);

//  For the ring zero version, only large allocations that should be page
//  aligned will pass through these functions.
#ifdef VXD

//  Converts number of bytes to number of whole pages.
#define ConvertToMemoryUnits(cb)        \
    ((((cb) + (PAGESIZE - 1)) & ~(PAGESIZE - 1)) >> PAGESHIFT)

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgAllocMemoryUnits(
    UINT nPages
    )
{

    return AllocPages(nPages);

}

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgReAllocMemoryUnits(
    LPVOID lpMemory,
    UINT nPages
    )
{

    return ReAllocPages(lpMemory, nPages);

}

#define RgFreeMemoryUnits           FreePages

//  For non-ring zero version of the registry code, all allocations will funnel
//  through these functions.  All allocations are off the heap.
#else
#define ConvertToMemoryUnits(cb)    (cb)
#define RgAllocMemoryUnits          AllocBytes
#define RgReAllocMemoryUnits        ReAllocBytes
#define RgFreeMemoryUnits           FreeBytes
#endif

//
//  RgAllocMemory
//

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    DEBUG_OUT(("RgAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;                    //  Must be NULL if we're here

}

//
//  RgReAllocMemory
//

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpOldMemory,
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(!IsNullPtr(lpOldMemory));
    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    DEBUG_OUT(("RgReAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;

}

#ifdef DEBUG
//
//  RgFreeMemory
//

VOID
INTERNAL
RgFreeMemory(
    LPVOID lpMemory
    )
{

    ASSERT(!IsNullPtr(lpMemory));

    DECREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);

#ifdef ZEROONFREE
    ZeroMemory(lpMemory, MemorySize(lpMemory));
#endif

    RgFreeMemoryUnits(lpMemory);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regnckey.h ===
//
//  REGNCKEY.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGNCKEY_
#define _REGNCKEY_

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
typedef struct _NOTIFY_CHANGE {
    struct _NOTIFY_CHANGE FAR* lpNextNotifyChange;
    DWORD ThreadId;
    HANDLE hEvent;
    DWORD KeynodeIndex;
    DWORD NotifyFilter;
}   NOTIFY_CHANGE, FAR* LPNOTIFY_CHANGE;

//  Map the bWatchSubtree flag to this bit tucked into the NotifyFilter field.
#define REG_NOTIFY_WATCH_SUBTREE        0x40
//  Only signal events that are watching the specified keynode index, not
//  parents of the keynode index.
#define REG_NOTIFY_NO_WATCH_SUBTREE     0x80

VOID
INTERNAL
RgSignalWaitingNotifies(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    UINT NotifyEvent
    );
#else
#define RgSignalWaitingNotifies(lpfi, ki, nevt)
#endif

#endif // _REGNCKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regqkey.c ===
//
//  REGQKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryInfoKey.
//

#include "pch.h"

//
//  VMMRegQueryInfoKey
//
//  See Win32 documentation of RegQueryInfoKey.  When VXD is defined, this
//  function does not take all of the parameters that we end up ignoring anyway
//  (class, security, timestamp parameters).
//

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData
    )
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData,
    LPVOID lpcbSecurityDescriptor,
    LPVOID lpftLastWriteTime
    )
#endif
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;
    UINT cItems;
    DWORD cbValueData;
    DWORD cbMaxValueData;
    DWORD cbStringLen;
    DWORD cbMaxStringLen;

    if (IsBadHugeOptionalWritePtr(lpcSubKeys, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxSubKeyLen, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcValues, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueName, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueData, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    //
    //  Compute cValues, cbMaxValueName, and cbMaxValueData.
    //

    if (!IsNullPtr(lpcValues) || !IsNullPtr(lpcbMaxValueName) ||
        !IsNullPtr(lpcbMaxValueData)) {

        cItems = 0;
        cbMaxStringLen = 0;
        cbMaxValueData = 0;

        while ((ErrorCode = RgLookupValueByIndex(hKey, cItems,
            &lpValueRecord)) == ERROR_SUCCESS) {

            cItems++;

            if (lpValueRecord-> NameLength > cbMaxStringLen)
                cbMaxStringLen = lpValueRecord-> NameLength;

            //  RgCopyFromValueRecord will handle static and dynamic keys...
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                NULL, NULL, &cbValueData);

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

            if (ErrorCode != ERROR_SUCCESS)
                goto ReturnErrorCode;

            if (cbValueData > cbMaxValueData)
                cbMaxValueData = cbValueData;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcValues))
                *lpcValues = cItems;

            if (!IsNullPtr(lpcbMaxValueName))
                *lpcbMaxValueName = cbMaxStringLen;

            if (!IsNullPtr(lpcbMaxValueData))
                *lpcbMaxValueData = cbMaxValueData;

            ErrorCode = ERROR_SUCCESS;

        }

    }

    //
    //  Compute cSubKeys and cbMaxSubKeyLen.  Somewhat painful because we must
    //  touch each child keynode and datablock.
    //

    if (!IsNullPtr(lpcSubKeys) || !IsNullPtr(lpcbMaxSubKeyLen)) {

        cItems = 0;
        cbMaxStringLen = 0;
        cbStringLen = 0;

        while (TRUE) {
            ErrorCode = RgLookupKeyByIndex(hKey, cItems, NULL,
                &cbStringLen, 0);

            if ((ErrorCode != ERROR_SUCCESS) && (ErrorCode != ERROR_MORE_DATA))
                break;
            cItems++;

            // Win95 compatibility: the old code included the null terminator, even
            // though the documentation for RegQueryInfoKey states that it doesn't.
            if (cbStringLen && (cbStringLen + 1 > cbMaxStringLen))
                cbMaxStringLen = cbStringLen + 1;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcSubKeys))
                *lpcSubKeys = cItems;

            if (!IsNullPtr(lpcbMaxSubKeyLen))
                *lpcbMaxSubKeyLen = cbMaxStringLen;

            ErrorCode = ERROR_SUCCESS;

        }

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

#ifndef VXD
    UNREFERENCED_PARAMETER(lpClass);
    UNREFERENCED_PARAMETER(lpcbClass);
    UNREFERENCED_PARAMETER(lpReserved);
    UNREFERENCED_PARAMETER(lpcbMaxClassLen);
    UNREFERENCED_PARAMETER(lpcbSecurityDescriptor);
    UNREFERENCED_PARAMETER(lpftLastWriteTime);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regqmval.c ===
//
//  REGQMVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//
//  Implementation of RegQueryMultipleValues and supporting functions.
//

#include "pch.h"

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

#ifdef IS_32

//
//  VMMRegQueryMultipleValues
//
//  See Win32 documentation of RegQueryMultipleValues.  However, the Win95
//  implementation breaks many of the rules that are described in the
//  documentation:
//      *  num_vals is a count of VALENT structures, not a size in bytes.
//      *  data is not DWORD aligned in lpValueBuffer.
//      *  if lpValueBuffer is too small, lpValueBuffer is not filled to the
//         size specified by lpdwTotalSize.
//
//  All of this plus dynamic keys makes this an extremely ugly routine, but
//  every attempt was made to be compatible with the Win95 semantics.
//

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    PVALENT val_list,
    DWORD num_vals,
    LPSTR lpValueBuffer,
    LPDWORD lpdwTotalSize
    )
{

    int ErrorCode;
    PVALENT pCurrentValent;
    DWORD Counter;
    DWORD BufferSize;
    DWORD RequiredSize;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    LPSTR lpCurrentBuffer;
#ifdef WANT_DYNKEY_SUPPORT
    PVALCONTEXT pValueContext;
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
#endif

    if (IsBadHugeReadPtr(val_list, sizeof(VALENT) * num_vals))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpdwTotalSize, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpValueBuffer, *lpdwTotalSize))
        return ERROR_INVALID_PARAMETER;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {
        if (IsBadStringPtr(pCurrentValent-> ve_valuename, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

#ifdef WANT_DYNKEY_SUPPORT
    //  Check if this a dynamic key that has a "get all" atomic callback.  If
    //  the dynamic key just has "get one" callback, then we'll fall into the
    //  non-dynamic case.
    if (IsDynDataKey(hKey) && !IsNullPtr(hKey-> pProvider-> ipi_R0_allvals)) {

        pProvider = hKey-> pProvider;

        pValueContext = RgSmAllocMemory(sizeof(struct val_context) * num_vals);

        if (IsNullPtr(pValueContext)) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ReturnErrorCode;
        }

        //
        //  Compute the required buffer size to hold all the value data and
        //  check it against the provided buffer size.
        //

        RequiredSize = 0;

        for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
            Counter++, pCurrentValent++) {

            if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
                ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
                goto ReturnErrorCode;

            //  The value data contains only part of a PROVIDER structure.
            pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
                lpValueRecord-> NameLength, PVALUE, pv_valuelen);

            pValueContext[Counter].value_context = pProviderValue->
                pv_value_context;
            pCurrentValent-> ve_type = pProviderValue-> pv_type;

            if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH) {

                //  Must zero it so that some providers don't try to stomp on
                //  lpData.
                pCurrentValent-> ve_valuelen = 0;

                ErrorCode = pProvider-> ipi_R0_1val(pProvider-> ipi_key_context,
                    &pValueContext[Counter], 1, NULL, &(pCurrentValent->
                    ve_valuelen), 0);

                //  Providers should really be returning either of these errors
                //  to us.
                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                    ERROR_MORE_DATA));

            }

            else {
                pCurrentValent-> ve_valuelen = pProviderValue-> pv_valuelen;
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

            pCurrentValent-> ve_valueptr = (DWORD) NULL;
            RequiredSize += pCurrentValent-> ve_valuelen;

        }

        BufferSize = *lpdwTotalSize;
        *lpdwTotalSize = RequiredSize;

        if (BufferSize < RequiredSize)
            ErrorCode = ERROR_MORE_DATA;

        else if (pProvider-> ipi_R0_allvals(pProvider-> ipi_key_context,
            pValueContext, num_vals, lpValueBuffer, lpdwTotalSize, 0) !=
            ERROR_SUCCESS)
            ErrorCode = ERROR_CANTREAD;

        else {

            ErrorCode = ERROR_SUCCESS;

            //  Copy the pointers to the value data back to the user's buffer.
            //  Don't ask me why, but the Win95 code copies the value length
            //  back again if the provider is maintaining it.
            for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
                Counter++, pCurrentValent++) {
                pCurrentValent-> ve_valueptr = (DWORD)
                    pValueContext[Counter].val_buff_ptr;
                if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)
                    pCurrentValent-> ve_valuelen = pValueContext[Counter].valuelen;
            }

        }

        RgSmFreeMemory(pValueContext);

        goto ReturnErrorCode;

    }
#endif

    //
    //  First pass over the value names checks for the existence of the value
    //  and its size.  We check the total size against the provided buffer size
    //  and bail out if necessary.
    //

    RequiredSize = 0;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorCode;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
            &(pCurrentValent-> ve_type), NULL, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS)
            goto ReturnErrorCode;

        pCurrentValent-> ve_valueptr = (DWORD) NULL;
        RequiredSize += pCurrentValent-> ve_valuelen;

    }

    BufferSize = *lpdwTotalSize;
    *lpdwTotalSize = RequiredSize;

    if (BufferSize < RequiredSize) {
        ErrorCode = ERROR_MORE_DATA;
        goto ReturnErrorCode;
    }

    //
    //  Second pass copies the value data back to the user's buffer now that we
    //  know the buffer is large enough to contain the data.
    //

    lpCurrentBuffer = lpValueBuffer;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorReading;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL, NULL,
            lpCurrentBuffer, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS) {
ReturnErrorReading:
            TRAP();                     //  Registry is internally inconsistent?
            ErrorCode = ERROR_CANTREAD;
            goto ReturnErrorCode;
        }

        pCurrentValent-> ve_valueptr = (DWORD) lpCurrentBuffer;
        lpCurrentBuffer += pCurrentValent-> ve_valuelen;

    }

    ErrorCode = ERROR_SUCCESS;

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regmem.h ===
//
//  REGMEM.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGMEM_
#define _REGMEM_

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    );

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpMemory,
    UINT cbBytes
    );

#ifdef DEBUG
VOID
INTERNAL
RgFreeMemory(
    LPVOID
    );
#else
#ifdef VXD
#define RgFreeMemory(lpv)           (FreePages(lpv))
#else
#define RgFreeMemory(lpv)           (FreeBytes(lpv))
#endif
#endif

//  Use the RgSm*Memory macros to allocate small chunks of memory off the heap.
//  For the VMM mode registry, the Rg*Memory functions will allocate pages,
//  while the RgSm*Memory functions will allocate from the heap.  For all other
//  modes, the two sets are equivalent.
#if defined(VXD)
#define RgSmAllocMemory             AllocBytes
#define RgSmFreeMemory              FreeBytes
#define RgSmReAllocMemory           ReAllocBytes
#else
#define RgSmAllocMemory             RgAllocMemory
#define RgSmFreeMemory              RgFreeMemory
#define RgSmReAllocMemory           RgReAllocMemory
#endif

#endif // _REGMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\snapshot\pch.h ===
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regmisc.c ===
//
//  REGMISC.C
//
//  Copyright (C) Microsoft Corporation, 1995-1996
//

#include "pch.h"
#include "mbstring.h"

//  We MUST calculate the hash consistently between the 16-bit and 32-bit
//  versions of the registry.
#define ToUpperHash(ch)                 ((int)(((ch>='a')&&(ch<='z'))?(ch-'a'+'A'):ch))

#if 0
//
//  RgChecksum
//

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    LPDWORD lpdwBuffer;
    DWORD Checksum;

    lpdwBuffer = (LPDWORD) lpBuffer;
    ByteCount >>= 2;
    Checksum = 0;

    while (ByteCount) {
        Checksum += *lpdwBuffer++;
        ByteCount--;
    }

    return Checksum;

}
#endif



//
//  RgHashString
//
//  Simple hash computation of a counted string.  All characters less than 0x80
//  0x80 and all DBCS characters are added up.
//
//  We MUST calculate the hash consistently between the 16-bit and
//  32-bit versions of the registry.  We will ignore all extended
//  characters because we cannot uppercase the character in 16-bit
//  mode.
//

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    )
{

    DWORD Hash;
    UINT Byte;

    Hash = 0;

    while (Length) {

        Byte = *((LPBYTE) lpString)++;

        if (IsDBCSLeadByte((BYTE) Byte)) {

            Hash += Byte;
            Length--;
            Hash += *lpString++; // Note that this is a signed char!

        }
        else if (Byte < 0x80)
            Hash += ToUpperHash(Byte);

        Length--;

    }

    return Hash;

}


//
//  RgAtoW
//  Convert an ascii string to a WORD
//

WORD
INTERNAL
RgAtoW(
    LPCSTR lpDec
      )
{
    WORD Dec;

    Dec = 0;

    while (*lpDec >= '0' && *lpDec <= '9') {
        Dec *= 10;
        Dec += *lpDec - '0';
        lpDec++;
    }

    return Dec;
}


//
// RgWtoA
// Convert a WORD to an ascii string
//

VOID
INTERNAL
RgWtoA(
    WORD Dec,
    LPSTR lpDec
      )
{
    WORD Divisor;
    WORD Digit;
    BOOL fSignificant = FALSE;

    Divisor = 10000;

    if (Dec) {
        while (Divisor) {
            Digit = Dec / Divisor;
            Dec -= Digit * Divisor;

            if (Digit)
                fSignificant = TRUE;

            if (fSignificant)
                *lpDec++ = '0' + Digit;

            Divisor /= 10;
        }
    }
    else {
        *lpDec++ = '0';
    }
    *lpDec = '\0';
}


//
//  RgStrCmpNI
//

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    )
{

    int Difference;

    while (Length) {

        if (IsDBCSLeadByte(*lpString1)) {

            Difference = _mbctoupper (_mbsnextc (lpString1))  - _mbctoupper (_mbsnextc (lpString2));

            if (Difference != 0)
                return Difference;

            lpString1+=2;
            lpString2+=2;

            if (Length < 2) {
                break;
            }
            Length -=2;
        }

        else {

            if ((Difference = (int) ToUpper(*lpString1) -
            (int) ToUpper(*lpString2)) != 0)
                return Difference;

            lpString1++;
            lpString2++;
            Length--;

        }

    }

    return 0;
}

//
//  RgCopyFileBytes
//
//  Copies the specified number of bytes from the source to the destination
//  starting at the specified offsets in each file.
//

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    )
{

    int ErrorCode;
    LPVOID lpWorkBuffer;
    UINT cbBytesThisPass;

    ASSERT(hSourceFile != HFILE_ERROR);
    ASSERT(hDestinationFile != HFILE_ERROR);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    lpWorkBuffer = RgLockWorkBuffer();

    if (!RgSeekFile(hSourceFile, SourceOffset))
        goto ErrorUnlockWorkBuffer;

    if (!RgSeekFile(hDestinationFile, DestinationOffset))
        goto ErrorUnlockWorkBuffer;

    while (cbSize) {

        cbBytesThisPass = (UINT) ((DWORD) min(cbSize, SIZEOF_WORK_BUFFER));

        if (!RgReadFile(hSourceFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        if (!RgWriteFile(hDestinationFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        cbSize -= cbBytesThisPass;

    }

    ErrorCode = ERROR_SUCCESS;

ErrorUnlockWorkBuffer:
    RgUnlockWorkBuffer(lpWorkBuffer);
    return ErrorCode;

}

#ifdef WANT_HIVE_SUPPORT
//
//  RgGenerateAltFileName
//

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    )
{

    LPSTR lpString;

    StrCpy(lpAltFileName, lpFileName);
    lpString = lpAltFileName + StrLen(lpAltFileName) - 3;

    *lpString++ = '~';
    *lpString++ = '~';
    *lpString = ExtensionChar;

    return TRUE;

}
#endif

#ifdef VXD

#pragma VxD_RARE_CODE_SEG

//
//  RgCopyFile
//

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    )
{

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    DWORD FileSize;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    if ((hSourceFile = RgOpenFile(lpSourceFile, OF_READ)) != HFILE_ERROR) {

        if ((FileSize = RgGetFileSize(hSourceFile)) != (DWORD) -1) {

            if ((hDestinationFile = RgCreateFile(lpDestinationFile)) !=
                HFILE_ERROR) {

                ErrorCode = RgCopyFileBytes(hSourceFile, 0, hDestinationFile, 0,
                    FileSize);

                RgCloseFile(hDestinationFile);

                if (ErrorCode != ERROR_SUCCESS)
                    RgDeleteFile(lpDestinationFile);

            }

        }

        RgCloseFile(hSourceFile);

    }

    return ErrorCode;

}

#endif // VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\utilw32c.c ===
//
//  UTILW32C.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Win32 environments.
//

#include "pch.h"

//
//  RgCreateTempFile
//
//  Returns the path through lpFileName and a file handle of a temporary file
//  located in the same directory as lpFileName.  lpFileName must specify the
//

HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    )
{

    HFILE hFile;

    if (GetTempFileName(lpFileName, "reg", 0, lpFileName) > 0) {
        if ((hFile = RgOpenFile(lpFileName, OF_WRITE)) != HFILE_ERROR)
            return hFile;
        DeleteFile(lpFileName);
    }

    DEBUG_OUT(("RgCreateTempFile failed\n"));
    return HFILE_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\win95reg\pch.h ===
#define COMMON_INCLUDES
#include "master.h"
#include "regapix.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regqval.c ===
//
//  REGQVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryValue, RegQueryValueEx and supporting functions.
//

#include "pch.h"


//
//  RgLookupValueByName
//  (BIGKEY aware)
//
//  Searches for the value with the specified name and returns a pointer to its
//  KEY_RECORD and VALUE_RECORD.
//
//  This locks the datablock associated with the KEY_RECORD and VALUE_RECORD.
//  This is always hKey->BigKeyLockedBlockIndex
//  It is the callers responsibility to unlock the datablock.  
//
int
INTERNAL
RgLookupValueByName(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    )
{
    int ErrorCode;
    HKEY hKeyExtent;
    UINT Index;
    LPSTR ExtentKeyName;
    DWORD cbExtentKeyName;

    hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
    ErrorCode = RgLookupValueByNameStd(hKey, lpValueName, lplpKeyRecord, lplpValueRecord);

    // If this is a big key and we couldn't find it in the first key extent, then
    // try the remaining extents.
    if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32 && (hKey->Flags & KEYF_BIGKEYROOT)) {

        if (IsNullPtr(ExtentKeyName = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
            return ERROR_OUTOFMEMORY;
        
        Index = 0;
        
        do {
            cbExtentKeyName = MAXIMUM_SUB_KEY_LENGTH;
            if (RgLookupKeyByIndex(hKey, Index++, ExtentKeyName, &cbExtentKeyName, LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;
                goto lFreeKeyName;
            }

            if (RgLookupKey(hKey, ExtentKeyName, &hKeyExtent, LK_OPEN | LK_BIGKEYEXT) != ERROR_SUCCESS) {
                ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;
                goto lFreeKeyName;
            }

            hKey-> BigKeyLockedBlockIndex = hKeyExtent-> BlockIndex;
            ErrorCode = RgLookupValueByNameStd(hKeyExtent, lpValueName,
                               lplpKeyRecord, lplpValueRecord);

            RgDestroyKeyHandle(hKeyExtent);

        } while (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32);

lFreeKeyName:
        RgSmFreeMemory(ExtentKeyName);
    }

    return ErrorCode;
}


//
//  RgLookupValueByNameStd
//
//  Searches for the value with the specified name and returns a pointer to its
//  KEY_RECORD and VALUE_RECORD.
//
//  This locks the datablock associated with the KEY_RECORD and VALUE_RECORD.
//  This is always hKey->BlockIndex.
//  It is the callers responsibility to unlock the datablock.  
//

int
INTERNAL
RgLookupValueByNameStd(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    UINT ValueNameLength;
    LPVALUE_RECORD lpValueRecord;
    UINT ValuesRemaining;

    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_CANTREAD16_FILENOTFOUND32;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
        hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT)
            StrLen(lpValueName));

        lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
            lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

        ValuesRemaining = lpKeyRecord-> ValueCount;

        //  Should probably do more sanity checking on lpValueRecord
        while (ValuesRemaining) {

            if (lpValueRecord-> NameLength == ValueNameLength &&
                (ValueNameLength == 0 || RgStrCmpNI(lpValueName, lpValueRecord->
                Name, ValueNameLength) == 0)) {
                *lplpKeyRecord = lpKeyRecord;
                *lplpValueRecord = lpValueRecord;
                return ERROR_SUCCESS;
            }

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                Name + lpValueRecord-> NameLength + lpValueRecord->
                DataLength);

            ValuesRemaining--;

        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;

    }

    return ErrorCode;

}

//
//  RgCopyFromValueRecord
//
//  Shared routine for RegQueryValue and RegEnumValue.  Copies the information
//  from the VALUE_RECORD to the user-provided buffers.  All parameters should
//  have already been validated.
//
//  Because all parameters have been validated, if lpData is valid, then
//  lpcbData MUST be valid.
//

int
INTERNAL
RgCopyFromValueRecord(
    HKEY hKey,
    LPVALUE_RECORD lpValueRecord,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    int ErrorCode;
    UINT BytesToTransfer;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
    struct val_context ValueContext;
#endif

#ifdef WANT_DYNKEY_SUPPORT
    if (IsDynDataKey(hKey)) {

        pProvider = hKey-> pProvider;

        if (IsNullPtr(pProvider))
            return ERROR_CANTOPEN;

        //  The value data contains only part of a PROVIDER structure.
        pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
            lpValueRecord-> NameLength, PVALUE, pv_valuelen);

        if (!IsNullPtr(lpType))
            *lpType = pProviderValue-> pv_type;

        if (!(hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)) {

            BytesToTransfer = pProviderValue-> pv_valuelen;

            if (IsNullPtr(lpData))
                goto ValueDataNotNeeded;

            if (BytesToTransfer > *lpcbData) {
                *lpcbData = BytesToTransfer;
                return ERROR_MORE_DATA;
            }

        //  Win95 compatibility: now that we know the required number of
        //  bytes, validate the data buffer.
        if (IsBadHugeWritePtr(lpData, BytesToTransfer))
        return ERROR_INVALID_PARAMETER;

        }

        ValueContext.value_context = pProviderValue-> pv_value_context;

        if (!IsNullPtr(lpcbData)) {

            //  Zero *lpcbData, if we aren't actually copying any data back to
            //  the user's buffer.  This keeps some providers from stomping on
            //  lpData.
            if (IsNullPtr(lpData))
                *lpcbData = 0;

            if ((ErrorCode = (int) pProvider-> ipi_R0_1val(pProvider->
                ipi_key_context, &ValueContext, 1, lpData, lpcbData, 0)) !=
                ERROR_SUCCESS) {

                //  Win95 compatibility: the old code ignored any errors if
                //  lpData is NULL.  The below ASSERT will verify that we aren't
                //  dropping errors.
                if (!IsNullPtr(lpData))
                    return ErrorCode;

                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                    ERROR_MORE_DATA));

            }

        }

        goto CopyValueName;

    }
#endif

    if (!IsNullPtr(lpType))
        *lpType = lpValueRecord-> DataType;

    BytesToTransfer = lpValueRecord-> DataLength;

    //  The terminating null is not stored in the value record.
    if (lpValueRecord-> DataType == REG_SZ)
        BytesToTransfer++;

    //
    //  Win32 compatibilty: lpData must be filled in before lpValueName.  Word
    //  NT and Excel NT broke when we validated lpValueName and failed the call
    //  before filling in lpData which was valid.  Don't rearrange this code!
    //

    if (!IsNullPtr(lpData)) {

        ErrorCode = ERROR_SUCCESS;

        if (BytesToTransfer > *lpcbData) {
            *lpcbData = BytesToTransfer;
            return ERROR_MORE_DATA;
        }

    //  Win95 compatibility: now that we know the required number of bytes,
    //  validate the data buffer.
        else if (IsBadHugeWritePtr(lpData, BytesToTransfer))
        return ERROR_INVALID_PARAMETER;

        else {

            MoveMemory(lpData, &lpValueRecord-> Name + lpValueRecord->
                NameLength, lpValueRecord-> DataLength);

            if (lpValueRecord-> DataType == REG_SZ)
                lpData[lpValueRecord-> DataLength] = '\0';

        }

    }

#ifdef WANT_DYNKEY_SUPPORT
ValueDataNotNeeded:
#endif
    if (!IsNullPtr(lpcbData))
        *lpcbData = BytesToTransfer;

#ifdef WANT_DYNKEY_SUPPORT
CopyValueName:
#endif
    if (!IsNullPtr(lpValueName)) {

        ErrorCode = ERROR_SUCCESS;

        if (*lpcbValueName <= lpValueRecord-> NameLength) {

            //  Although we will not touch the lpData buffer if it's too small
            //  to hold the value data, we will partially fill lpValueName if
            //  it's too small.
            ErrorCode = ERROR_MORE_DATA;

            if (*lpcbValueName == 0)
                return ErrorCode;

            BytesToTransfer = (UINT) *lpcbValueName - 1;

        }

        else
            BytesToTransfer = lpValueRecord-> NameLength;

        MoveMemory(lpValueName, &lpValueRecord-> Name, BytesToTransfer);
        lpValueName[BytesToTransfer] = '\0';

        //  Does not include terminating null.
        *lpcbValueName = BytesToTransfer;

        return ErrorCode;

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegQueryValueEx
//
//  See Win32 documentation of RegQueryValueEx.
//

LONG
REGAPI
VMMRegQueryValueEx(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;


    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (!IsNullPtr(lpType))
        *lpType = 0;        // assume unknown data type

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
    //  Win95 compatibility: don't validate lpData is of size *lpcbData.
    //  Instead of validating the entire buffer, we'll validate just the
    //  required buffer length in RgCopyFromValueRecord.
    if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord)) == ERROR_SUCCESS) {

            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);

        }

        else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

            //
            //  Windows 95 compatibility problem.  If the "value
            //  record" didn't exist in Windows 3.1, then it acted like it was
            //  really a null byte REG_SZ string.  This should have only been
            //  done in RegQueryValue, but we're stuck with it now...
            //

            if (IsNullPtr(lpValueName) || *lpValueName == '\0') {

                if (!IsNullPtr(lpType))
                    *lpType = REG_SZ;

                if (!IsNullPtr(lpData) && *lpcbData > 0)
                    *lpData = 0;

                if (!IsNullPtr(lpcbData))
                    *lpcbData = sizeof(char);

                ErrorCode = ERROR_SUCCESS;

            }

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}

//
//  VMMRegQueryValue
//
//  See Win32 documentation of RegQueryValue.
//

LONG
REGAPI
VMMRegQueryValue(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegQueryValueEx(hSubKey, NULL, NULL, NULL, lpData,
            lpcbData);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\utilwinc.c ===
//
//  UTILWINC.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Windows environments.
//

#include "pch.h"

BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesRead;

    BytesRead = _lread(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesRead;

}

BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesWritten;

    BytesWritten = _lwrite(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesWritten;

}

#ifndef FILE_BEGIN
#define FILE_BEGIN SEEK_SET
#endif

BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    )
{

    LONG NewFileOffset;

    NewFileOffset = _llseek(hFile, FileOffset, FILE_BEGIN);

    return FileOffset == NewFileOffset;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\snapshot\snapshot.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    snapshot.c

Abstract:

    Implements a memdb-based snapshot of all files, directories, registry keys and
    registry values.

Author:

    Jim Schmidt (jimschm) 13-Mar-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

#define S_SNAPSHOT_A        "Snapshot"

BOOL
pGetFullKeyA (
    IN OUT  PSTR Object
    )
{
    MEMDB_ENUMA e;
    CHAR Pattern[MEMDB_MAX];
    PSTR p;

    wsprintfA (Pattern, "%s*", Object);
    if (MemDbEnumFirstValue (&e, Pattern, MEMDB_THIS_LEVEL_ONLY, MEMDB_ENDPOINTS_ONLY)) {
        p = _mbsrchr (Object, TEXT('\\'));
        if (p) {
            p = _mbsinc (p);
        } else {
            p = Object;
        }

        StringCopyA (p, e.szName);
        return TRUE;
    } else {
        return FALSE;
    }
}


VOID
pSnapDirsA (
    IN      PCSTR Drive,
    IN      BOOL DiffMode,
    IN      HANDLE DiffHandle       OPTIONAL
    )
{
    TREE_ENUMA FileEnum;
    CHAR Node[MEMDB_MAX];
    DWORD Value;

    //
    // Enumerate the file system
    //

    if (EnumFirstFileInTreeA (&FileEnum, Drive, NULL, TRUE)) {
        do {
            wsprintfA (
                Node,
                "%s\\%s\\%u\\%u%u",
                S_SNAPSHOT_A,
                FileEnum.FullPath,
                FileEnum.FindData->nFileSizeLow,
                FileEnum.FindData->ftLastWriteTime.dwHighDateTime,
                FileEnum.FindData->ftLastWriteTime.dwLowDateTime
                );

            if (!DiffMode) {
                MemDbSetValueA (Node, SNAP_RESULT_DELETED);
            } else {
                Value = SNAP_RESULT_UNCHANGED;
                if (!MemDbGetValueA (Node, NULL)) {
                    if (DiffHandle) {
                        WriteFileStringA (DiffHandle, FileEnum.FullPath);
                        WriteFileStringA (DiffHandle, "\r\n");
                    }

                    wsprintfA (Node, "%s\\%s,", S_SNAPSHOT_A, FileEnum.FullPath);
                    
                    Value = SNAP_RESULT_CHANGED;
                    if (!pGetFullKeyA (Node)) {
                        wsprintfA (
                            Node,
                            "%s\\%s\\%u\\%u%u",
                            S_SNAPSHOT_A,
                            FileEnum.FullPath,
                            FileEnum.FindData->nFileSizeLow,
                            FileEnum.FindData->ftLastWriteTime.dwHighDateTime,
                            FileEnum.FindData->ftLastWriteTime.dwLowDateTime
                            );
                        Value = SNAP_RESULT_ADDED;
                    }
                }
                MemDbSetValueA (Node, Value);
            }
        } while (EnumNextFileInTreeA (&FileEnum));
    }
}

VOID
pSnapAllDrivesA (
    IN      BOOL DiffMode,
    IN      HANDLE  DiffHandle      OPTIONAL
    )
{
    CHAR Drives[256];
    MULTISZ_ENUMA e;

    if (GetLogicalDriveStringsA (256, Drives)) {
        if (EnumFirstMultiSzA (&e, Drives)) {
            do {
                if (DRIVE_FIXED == GetDriveTypeA (e.CurrentString)) {
                    pSnapDirsA (e.CurrentString, DiffMode, DiffHandle);
                    break;
                }
            } while (EnumNextMultiSzA (&e));
        }
    }
}

VOID
pSnapRegistryHiveA (
    IN      PCSTR Hive,
    IN      BOOL DiffMode,
    IN      HANDLE DiffHandle       OPTIONAL
    )
{
    REGTREE_ENUMA RegEnum;
    REGVALUE_ENUMA RegValue;
    CHAR Node[MEMDB_MAX];
    PBYTE Data;
    DWORD Checksum;
    PBYTE p;
    UINT Count;
    DWORD Value;

    if (EnumFirstRegKeyInTreeA (&RegEnum, Hive)) {
        do {
            wsprintfA (
                Node,
                "%s\\%s",
                S_SNAPSHOT_A,
                RegEnum.FullKeyName
                );

            if (!DiffMode) {
                MemDbSetValueA (Node, SNAP_RESULT_DELETED);
            } else {
                if (!MemDbGetValueA (Node, NULL)) {
                    if (DiffHandle) {
                        WriteFileStringA (DiffHandle, RegEnum.FullKeyName);
                        WriteFileStringA (DiffHandle, "\r\n");
                    }
                } else {
                    MemDbSetValueA (Node, SNAP_RESULT_UNCHANGED);
                }
            }

            if (EnumFirstRegValueA (&RegValue, RegEnum.CurrentKey->KeyHandle)) {
                do {
                    Data = GetRegValueData (RegValue.KeyHandle, RegValue.ValueName);
                    if (!Data) {
                        continue;
                    }

                    Checksum = RegValue.Type;
                    p = Data;

                    for (Count = 0 ; Count < RegValue.DataSize ; Count++) {
                        Checksum = (Checksum << 1) | (Checksum >> 31) | *p;
                        p++;
                    }

                    MemFree (g_hHeap, 0, Data);

                    wsprintfA (
                        Node,
                        "%s\\%s\\[%s],%u",
                        S_SNAPSHOT_A,
                        RegEnum.FullKeyName,
                        RegValue.ValueName,
                        Checksum
                        );

                    if (!DiffMode) {
                        MemDbSetValueA (Node, SNAP_RESULT_DELETED);
                    } else {
                        Value = SNAP_RESULT_UNCHANGED;
                        if (!MemDbGetValueA (Node, NULL)) {
                            WriteFileStringA (DiffHandle, RegEnum.FullKeyName);
                            WriteFileStringA (DiffHandle, " [");
                            WriteFileStringA (DiffHandle, RegValue.ValueName);
                            WriteFileStringA (DiffHandle, "]\r\n");

                            wsprintfA (
                                Node,
                                "%s\\%s\\[%s],",
                                S_SNAPSHOT_A,
                                RegEnum.FullKeyName,
                                RegValue.ValueName
                                );

                            Value = SNAP_RESULT_CHANGED;
                            if (!pGetFullKeyA (Node)) {
                                wsprintfA (
                                    Node,
                                    "%s\\%s\\[%s],%u",
                                    S_SNAPSHOT_A,
                                    RegEnum.FullKeyName,
                                    RegValue.ValueName,
                                    Checksum
                                    );
                                Value = SNAP_RESULT_ADDED;
                            }
                        }

                        MemDbSetValueA (Node, Value);
                    }

                } while (EnumNextRegValueA (&RegValue));
            }

        } while (EnumNextRegKeyInTreeA (&RegEnum));
    }
}

VOID
pSnapRegistryA (
    IN      BOOL DiffMode,
    IN      HANDLE DiffHandle       OPTIONAL
    )
{
    pSnapRegistryHiveA (TEXT("HKLM"), DiffMode, DiffHandle);
    pSnapRegistryHiveA (TEXT("HKU"), DiffMode, DiffHandle);
}

VOID
TakeSnapShotEx (
    IN      DWORD SnapFlags
    )
{
    MemDbCreateTemporaryKeyA (S_SNAPSHOT_A);

    if (SnapFlags & SNAP_FILES) {
        pSnapAllDrivesA (FALSE, NULL);
    }
    if (SnapFlags & SNAP_REGISTRY) {
        pSnapRegistryA (FALSE, NULL);
    }
}

BOOL
GenerateDiffOutputExA (
    IN      PCSTR FileName,
    IN      PCSTR Comment,      OPTIONAL
    IN      BOOL Append,
    IN      DWORD SnapFlags
    )
{
    HANDLE File = NULL;
    MEMDB_ENUMA e;

    if (FileName) {
        File = CreateFileA (
                   FileName,
                   GENERIC_WRITE,
                   0,
                   NULL,
                   Append ? OPEN_ALWAYS : CREATE_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL
                   );

        if (File == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Can't open %s for output", FileName));
            return FALSE;
        }

        if (Append) {
            SetFilePointer (File, 0, NULL, FILE_END);
        }

        if (Comment) {
            WriteFileStringA (File, Comment);
            WriteFileStringA (File, "\r\n");
        }

        WriteFileStringA (File, "Changes:\r\n");
    }
        
    if (SnapFlags & SNAP_FILES) {
        pSnapAllDrivesA (TRUE, File);
    }
    
    if (SnapFlags & SNAP_REGISTRY) {
        pSnapRegistryA (TRUE, File);
    }

    if (File) {
        WriteFileStringA (File, "\r\nDeleted Settings:\r\n");

        if (MemDbGetValueExA (&e, S_SNAPSHOT_A, NULL, NULL)) {
            do {
                if (e.dwValue == SNAP_RESULT_DELETED) {
                    WriteFileStringA (File, e.szName);
                    WriteFileStringA (File, "\r\n");
                }
            } while (MemDbEnumNextValue (&e));
        }

        WriteFileStringA (File, "\r\nEnd.\r\n\r\n");

        CloseHandle (File);
    }

    return TRUE;
}


BOOL
EnumFirstSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e,
    IN      PCSTR FilePattern,   OPTIONAL
    IN      DWORD SnapStatus
    )
{
    CHAR node[MEMDB_MAX];

    e->FilePattern = FilePattern;
    e->SnapStatus = SnapStatus;
    e->FirstCall = TRUE;
    MemDbBuildKeyA (node, S_SNAPSHOT_A, "*", NULL, NULL);
    
    if (!MemDbEnumFirstValue (&(e->mEnum), node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        return FALSE;
    }
    return EnumNextSnapFileA (e);
}

BOOL
EnumNextSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e
    )
{
    PSTR lastWack;

    while (e->FirstCall?(e->FirstCall = FALSE, TRUE):MemDbEnumNextValue (&(e->mEnum))) {
        StringCopyA (e->FileName, e->mEnum.szName);
        lastWack = _mbsrchr (e->FileName, '\\');
        if (lastWack) {
            *lastWack = 0;
            lastWack = _mbsrchr (e->FileName, '\\');
            if (lastWack) {
                *lastWack = 0;
            }
        }
        if (e->FilePattern && (!IsPatternMatch (e->FilePattern, e->FileName))) {
            continue;
        }
        if ((e->SnapStatus & e->mEnum.dwValue) == 0) {
            continue;
        }
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\regw32d\regsval.c ===
//
//  REGSVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegSetValue, RegSetValueEx and supporting functions.
//

#include "pch.h"

//
//  RgReAllocKeyRecord
//

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    int ErrorCode;
    LPKEY_RECORD lpOldKeyRecord;
    UINT BlockIndex;
    UINT KeyRecordIndex;
    LPDATABLOCK_INFO lpOldDatablockInfo;
    LPKEYNODE lpKeynode;

    if (Length > MAXIMUM_KEY_RECORD_SIZE) {
        return ERROR_BIGKEY_NEEDED;         // A big key is required
    }

    lpOldKeyRecord = *lplpKeyRecord;

    BlockIndex = HIWORD(lpOldKeyRecord-> DatablockAddress);
    KeyRecordIndex = LOWORD(lpOldKeyRecord-> DatablockAddress);

    //
    //  Check if we can simply extend this key record by taking space from an
    //  adjacent free record.
    //

    if (RgExtendKeyRecord(hKey-> lpFileInfo, BlockIndex, (UINT) Length,
        lpOldKeyRecord) == ERROR_SUCCESS)
        return ERROR_SUCCESS;

    //
    //  Check if there's enough space in the datablock lpCurrKeyRecord is in to
    //  contain a key record of the specified size.  If so, then we don't have
    //  to dirty the keynode.
    //

    if (RgAllocKeyRecordFromDatablock(hKey-> lpFileInfo, BlockIndex,
        (UINT) Length, lplpKeyRecord) == ERROR_SUCCESS) {

        //  After an alloc, we must refetch these pointers because they may be
        //  invalid.
        lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
            BlockIndex);
        lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
            KeyRecordIndex);

        //  Transfer all the data to the new record, except for the allocated
        //  size which is already correctly set.
        MoveMemory(&(*lplpKeyRecord)-> DatablockAddress, &lpOldKeyRecord->
            DatablockAddress, SmallDword(lpOldKeyRecord-> RecordSize) -
            sizeof(DWORD));

        RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);

        //  Update the key record table to point to the new key record.
        lpOldDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
            (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
            (LPBYTE) lpOldDatablockInfo-> lpDatablockHeader);

        return ERROR_SUCCESS;

    }

    //
    //  Check if we can allocate a key record from another datablock.  If so,
    //  then copy the key to the other datablock and update the keynode.
    //

    if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode) == ERROR_SUCCESS) {

        if ((ErrorCode = RgAllocKeyRecord(hKey-> lpFileInfo, (UINT) Length,
            lplpKeyRecord)) == ERROR_SUCCESS) {

            //  After an alloc, we must refetch these pointers because they may
            //  be invalid.
            lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
                BlockIndex);
            lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
                KeyRecordIndex);

            //  Transfer all the data to the new record, except for the
            //  allocated size which is already correctly set.
            MoveMemory(&(*lplpKeyRecord)-> RecordSize, &lpOldKeyRecord->
                RecordSize, SmallDword(lpOldKeyRecord-> RecordSize) -
                (sizeof(DWORD) * 2));

            RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);
            RgFreeKeyRecordIndex(lpOldDatablockInfo, KeyRecordIndex);

            //  Unlock the old datablock.
            RgUnlockDatablock(hKey-> lpFileInfo, BlockIndex, TRUE);

            //  Update the open key and keynode to point to the key record in
            //  the new datablock.
            hKey-> BlockIndex = (*lplpKeyRecord)-> BlockIndex;
            hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
            lpKeynode-> BlockIndex = hKey-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) (*lplpKeyRecord)-> KeyRecordIndex;
            lpKeynode-> KeyRecordIndex = hKey-> KeyRecordIndex;

        }

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

        return ErrorCode;

    }

    return ERROR_OUTOFMEMORY;

}


//
//  RgSetValue
//  (BIGKEY aware)
//

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    )
{
    int ErrorCode;
    HKEY hKeyExtent;
    UINT Index;
    LPSTR ExtentKeyName;
    DWORD cbExtentKeyName;
    WORD NameID = 1;
    WORD MaxNameID = 0;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    LPKEYNODE lpKeynode;
    BOOL fTryRoot = FALSE;


    ErrorCode = RgSetValueStd(hKey, lpValueName, Type, lpData, cbData, FALSE);

    if (ErrorCode == ERROR_BIGKEY_NEEDED)
    {
        //
        // Couldn't fit the value in the key, make it a big key
        // (if it isn't one already)
        //


        // First delete its old value if it exists
        ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord);

        if (ErrorCode == ERROR_SUCCESS)
        {
            // If a value record already existed, and it was not in the root of the big key
            // then we should try inserting the new value record into the root, after deleting
            // it from its old location.
            if (hKey-> BigKeyLockedBlockIndex != hKey-> BlockIndex)
                fTryRoot = TRUE;

            RgDeleteValueRecord(lpKeyRecord, lpValueRecord);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, TRUE);
        }
        else if (ErrorCode != ERROR_CANTREAD16_FILENOTFOUND32) {
            return ERROR_OUTOFMEMORY;
        }

        if (IsNullPtr(ExtentKeyName = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
            return ERROR_OUTOFMEMORY;

        // Second, search for room in each of the big key's extents
        // (we should never mark the root with an LK_BIGKEYEXT, otherwise it won't be found
        // by RgLookupKey and RgLookupKeyByIndex)
        if ((hKey-> Flags & KEYF_BIGKEYROOT)) {
            if (fTryRoot) {
                // This happens if the value record previously existed in a big key extension,
                // but the new value record doesn't fit in the same extension, so we want to try
                // the root of the big key.
                if ((ErrorCode = RgSetValueStd(hKey, lpValueName, Type, lpData, cbData, TRUE)) ==
                    ERROR_SUCCESS) {
                    goto lFreeKeyName;
                }
            }

            Index = 0;
        
            do {
                cbExtentKeyName = MAXIMUM_SUB_KEY_LENGTH;
                if (RgLookupKeyByIndex(hKey, Index++, ExtentKeyName, &cbExtentKeyName, LK_BIGKEYEXT) !=
                    ERROR_SUCCESS) {
                    goto lGrowKey;
                }

                NameID = RgAtoW(ExtentKeyName);

                if (NameID > MaxNameID)
                    MaxNameID = NameID;

                if (RgLookupKey(hKey, ExtentKeyName, &hKeyExtent, LK_OPEN | LK_BIGKEYEXT) != ERROR_SUCCESS) {
                    goto lGrowKey;
                }

                ErrorCode = RgSetValueStd(hKeyExtent, lpValueName, Type, lpData, cbData, TRUE);

                RgDestroyKeyHandle(hKeyExtent);

            } while (ErrorCode == ERROR_BIGKEY_NEEDED);

            goto lFreeKeyName;
        }

        // Third, make it a big key, or if it is a big key, then grow it
lGrowKey:
        // Create a unique name for the big key extent
        if (MaxNameID)
            NameID = MaxNameID + 1;

        RgWtoA(NameID, ExtentKeyName);

        if ((ErrorCode = RgLookupKey(hKey, ExtentKeyName, &hKeyExtent, LK_CREATE)) ==
            ERROR_SUCCESS) {

            // Mark the parent as the big key root, if it isn't already
            if (!(hKey-> Flags & KEYF_BIGKEYROOT))
            {
                if ((ErrorCode = RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    &lpKeynode)) != ERROR_SUCCESS)
                    goto lFreeKeyName;

                lpKeynode-> Flags |= KNF_BIGKEYROOT;
                hKey-> Flags |= KEYF_BIGKEYROOT;

                RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);
            }

            // Mark the new key as a big key extent
            if ((ErrorCode = RgLockInUseKeynode(hKeyExtent-> lpFileInfo, hKeyExtent-> KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                goto lFreeKeyName;

            lpKeynode-> Flags |= KNF_BIGKEYEXT;
            
            RgUnlockKeynode(hKeyExtent-> lpFileInfo, hKeyExtent-> KeynodeIndex, TRUE);

            // Now add the value record to the new key
            ErrorCode = RgSetValueStd(hKeyExtent, lpValueName, Type, lpData, cbData, TRUE);

            ASSERT(ErrorCode != ERROR_BIGKEY_NEEDED);
            RgDestroyKeyHandle(hKeyExtent);
        }

lFreeKeyName:
        RgSmFreeMemory(ExtentKeyName);

        if (ErrorCode == ERROR_BIGKEY_NEEDED)
            ErrorCode = ERROR_OUTOFMEMORY;
    }

    return ErrorCode;
}


//
//  RgSetValueStd
//

int
INTERNAL
RgSetValueStd(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData,
    BOOL fBigKeyExtent
    )
{

    int ErrorCode;
    UINT ValueNameLength;
    UINT NewValueRecordLength;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    UINT CurrentValueRecordLength;
    LPBYTE lpDestination;
    UINT BytesToExtend;
    UINT TempCount;
    LPKEYNODE lpKeynode;

    ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT) StrLen(lpValueName));

    if (ValueNameLength > MAXIMUM_VALUE_NAME_LENGTH - 1)
        return ERROR_INVALID_PARAMETER;

    NewValueRecordLength = sizeof(VALUE_RECORD) + ValueNameLength + cbData - 1;

    if (!fBigKeyExtent) {
        ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord);
    }
    else {
        // If we didn't find it searching from the root of a bigkey, then we won't
        // find it beginning from an extent.
        ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;
    }

    //
    //  A value with this name already exists, so update the existing
    //  VALUE_RECORD with the new information.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        CurrentValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord->
            NameLength + lpValueRecord-> DataLength - 1;

        // Is the value record staying the same?
        if (NewValueRecordLength == CurrentValueRecordLength) {
            if (lpValueRecord-> DataLength == cbData && lpValueRecord->
                DataType == Type && CompareMemory((LPBYTE) lpValueRecord->
                Name + ValueNameLength, lpData, cbData) == 0) {
                RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, FALSE);
                return ERROR_SUCCESS;
            }
        }

        // Is the value record shrinking?
        if (NewValueRecordLength < CurrentValueRecordLength) {
            lpKeyRecord-> RecordSize -= (CurrentValueRecordLength -
                NewValueRecordLength);
        }

        // Is the value record growing?
        else if (NewValueRecordLength > CurrentValueRecordLength) {

            BytesToExtend = NewValueRecordLength - CurrentValueRecordLength;

            // Does the value record fit in the allocated key size?
            if (BytesToExtend > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                TempCount = (LPBYTE) lpValueRecord - (LPBYTE) lpKeyRecord;

                // Grow the key record
                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + BytesToExtend, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex,
                        FALSE);
                    return ErrorCode;
                }

                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                    TempCount);

            }

            lpKeyRecord-> RecordSize += BytesToExtend;

        }

        lpDestination = (LPBYTE) lpValueRecord + NewValueRecordLength;
        TempCount = (UINT) ((LPBYTE) lpKeyRecord + SmallDword(lpKeyRecord->
            RecordSize) - lpDestination);

        if (TempCount > 0) {
            MoveMemory(lpDestination, (LPBYTE) lpValueRecord +
                CurrentValueRecordLength, TempCount);
        }

    }

    //
    //  No value exists with this name.  Place a new VALUE_RECORD at the end of
    //  the KEY_RECORD.
    //

    else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  We don't check if this is really the root key, but it doesn't
        //  matter much.
        if (IsNullBlockIndex(hKey-> BlockIndex)) {

            if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                &lpKeynode) != ERROR_SUCCESS)
                goto LockKeynodeFailed;

            if (RgAllocKeyRecord(hKey-> lpFileInfo, sizeof(KEY_RECORD) +
                NewValueRecordLength, &lpKeyRecord) != ERROR_SUCCESS) {
                RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);
LockKeynodeFailed:
                TRAP();
                return ERROR_CANTOPEN;          //  Win95 compatibility
            }

            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD);
            lpKeyRecord-> NameLength = 1;       //  Win95 compatibility
            lpKeyRecord-> Name[0] = '\0';       //  Win95 compatibility
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            lpKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;

            hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

            RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

            ErrorCode = ERROR_SUCCESS;
            goto AddValueRecord;

        }

        if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
            hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

            if (NewValueRecordLength > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + NewValueRecordLength, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex,
                        FALSE);
                    return ErrorCode;
                }

            }

AddValueRecord:
            hKey-> BigKeyLockedBlockIndex = hKey-> BlockIndex;
            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                SmallDword(lpKeyRecord-> RecordSize));
            lpKeyRecord-> RecordSize += NewValueRecordLength;
            lpKeyRecord-> ValueCount++;

        }

    }

    //
    //  If we're successful at this point, then lpValueRecord is valid and we
    //  should copy the data into this record.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        lpValueRecord-> DataType = Type;

        lpValueRecord-> NameLength = (WORD) ValueNameLength;
        MoveMemory(lpValueRecord-> Name, lpValueName, ValueNameLength);

        lpValueRecord-> DataLength = (WORD) cbData;
        MoveMemory((LPBYTE) lpValueRecord-> Name + ValueNameLength, lpData,
            cbData);

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BigKeyLockedBlockIndex, TRUE);

    }

    return ErrorCode;

}

//
//  VMMRegSetValueEx
//
//  See Win32 documentation of RegSetValueEx.
//

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    int ErrorCode;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    //
    //  bad Windows 95 compatibility problem.  If the type is REG_SZ,
    //  then override cbData with the length of the string pointed to by lpData.
    //  This should have only been done in RegSetValue, but we're stuck with it
    //  now...
    //

    if (Type == REG_SZ) {
        if (IsBadStringPtr(lpData, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
        cbData = StrLen(lpData);

        // Must leave room for the null terminator
        if (cbData >= MAXIMUM_DATA_LENGTH)
                return ERROR_INVALID_PARAMETER;
    }
    else {
        if (cbData > 0 && IsBadHugeReadPtr(lpData, cbData))
            return ERROR_INVALID_PARAMETER;
    }

    if (cbData > MAXIMUM_DATA_LENGTH)
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {
        if (IsDynDataKey(hKey) || (hKey-> lpFileInfo-> Flags & FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else {
            if ((ErrorCode = RgSetValue(hKey, lpValueName, Type, lpData,
                (UINT) cbData)) == ERROR_SUCCESS) {
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }
        }
    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(Reserved);

}

//
//  VMMRegSetValue
//
//  See Win32 documentation of RegSetValue.
//

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_CREATE)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegSetValueEx(hSubKey, NULL, 0, REG_SZ, lpData, 0);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(cbData);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\win95reg\reg95trk.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  w95track.c

Abstract:

  Routines to track calls to Win95Reg APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  30-Jan-1998

Revisions:


--*/


#include "pch.h"

#ifdef DEBUG


#undef Win95RegOpenKeyExA
#undef Win95RegCreateKeyExA
#undef Win95RegOpenKeyExW
#undef Win95RegCreateKeyExW

#define DBG_W95TRACK "W95Track"

#define NO_MATCH        0xffffffff

DWORD g_DontCare95;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList95 = GROWLIST_INIT;

DWORD
pFindKeyReference95 (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList95);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList95, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
pAddKeyReference95A (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    Size = sizeof (KEYTRACK) + SizeOfString (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopy (KeyTrack->SubKey, SubKey);

    GrowListAppend (&g_KeyTrackList95, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
pAddKeyReference95W (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    AnsiSubKey = ConvertWtoA (SubKey);
    pAddKeyReference95A (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference95 (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference95 (Key);
    if (Index != NO_MATCH) {
        GrowListDeleteItem (&g_KeyTrackList95, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys95 (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GrowListGetSize (&g_KeyTrackList95);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GrowListGetItem (&g_KeyTrackList95, d);
        DEBUGMSG ((DBG_W95TRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }
}

VOID
RegTrackTerminate95 (
    VOID
    )
{
    FreeGrowList (&g_KeyTrackList95);
}

VOID
DebugRegOpenRootKey95A (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReference95A (Key, SubKey, File, Line);
}


VOID
DebugRegOpenRootKey95W (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    pAddKeyReference95W (Key, SubKey, File, Line);
}


LONG
DebugRegOpenKeyEx95A (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = Win95RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        pAddKeyReference95A (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
DebugRegOpenKeyEx95W (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = Win95RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        pAddKeyReference95W (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
DebugCloseRegKey95 (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey95 (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference95 (Key)) {
            DEBUGMSG ((
                DBG_ERROR, 
                "Reg key handle closed via CloseRegKey95, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\win95reg\reg95.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    regutils.c

Abstract:

    Implements wrappers similar to migutil's reg.c, but for Win95 registry.
    
Author:

    Jim Schmidt (jimschm)  30-Jan-1998

Revisions:

--*/

#include "pch.h"

#ifdef DEBUG
#undef Win95RegCloseKey
#endif

#define DBG_REGUTILS     "RegUtils"

//
// Private prototypes
//

BOOL
pPopRegKeyInfo95A (
    IN      PREGTREE_ENUMA EnumPtr
    );

BOOL
pPopRegKeyInfo95W (
    IN      PREGTREE_ENUMW EnumPtr
    );

//
// Implementation
//


/*++

Routine Description:

  EnumFirstRegKey95A and EnumFirstRegKey95W begin an enumeration of registry
  subkeys.  They initialize the registy enumeration structure and
  call the registry APIs to enumerate subkeys of the specified key handle.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  Key       - Specifies the handle of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegKey95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKey95A (EnumPtr);
}


BOOL
EnumFirstRegKey95W (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKey95W (EnumPtr);
}


/*++

Routine Description:

  OpenRegKeyStr95A and OpenRegKeyStr95W parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStr95A (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKey95A (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = RealOpenRegKey95A (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);
    return Key;
}


HKEY
RealOpenRegKeyStr95W (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    PCSTR AnsiRegKey;
    HKEY Key;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return NULL;
    }

    Key = RealOpenRegKeyStr95A (AnsiRegKey /* , */ DEBUG_TRACKING_ARGS);

    FreeConvertedStr (AnsiRegKey);

    return Key;
}


/*++

Routine Description:

  EnumFirstRegKeyStr95A and EnumFirstRegKeyStr95W start an enumeration of
  subkeys within the given key.  In these functions, the key is specified
  via a string instead of an HKEY value.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  RegKey    - Specifies the full path of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
RealEnumFirstRegKeyStr95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStr95A (RegKey /* , */ DEBUG_TRACKING_ARGS);

    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKey95A (EnumPtr, Key);
    if (!b) {
        CloseRegKey95 (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


BOOL
RealEnumFirstRegKeyStr95W (
    IN      PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStr95W (RegKey /* , */ DEBUG_TRACKING_ARGS);
    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKey95W (EnumPtr, Key);
    if (!b) {
        CloseRegKey95 (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


/*++

Routine Description:

  AbortRegKeyEnum95A and AbortRegKeyEnum95W release all resources associated
  with a registry subkey enumeration.  Call this function to stop the
  enumeration before it completes by itself.

Arguments:

  EnumPtr   - Specifies the enumeration to stop.  Receives the updated 
              state of enumeration.

Return Value:


  none

--*/

VOID
AbortRegKeyEnum95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey95 (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


VOID
AbortRegKeyEnum95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey95 (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


/*++

Routine Description:

  EnumNextRegKey95A and EnumNextRegKey95W continue an enumeration started by
  one of the subkey enumeration routines above.  If all items have been
  enumerated, this function cleans up all resources and returns FALSE.

Arguments:

  EnumPtr   - Specifies the enumeration to continue.  Receives the updated 
              state of enumeration.  The structure can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegKey95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    )
{
    LONG rc;

    rc = Win95RegEnumKeyA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYA
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey95 (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegKey95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    LONG rc;

    rc = Win95RegEnumKeyW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_REGISTRY_KEYW
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey95 (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
pPushRegKeyInfo95A (
    IN      PREGTREE_ENUMA EnumPtr,
    IN      PCSTR KeyName
    )
{
    PREGKEYINFOA RetVal;
    PSTR p;

    RetVal = (PREGKEYINFOA) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool, 
                                sizeof (REGKEYINFOA)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOA));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing 
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    if (EnumPtr->FullKeyNameBytes) {
        StringCopyA (p, "\\");
        EnumPtr->FullKeyNameBytes += ByteCountA (p);
        p = _mbsinc (p);
    }

    _mbssafecpy (p, KeyName, MAX_REGISTRY_KEYA - EnumPtr->FullKeyNameBytes);
    EnumPtr->FullKeyNameBytes += ByteCountA (KeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _mbssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYA);
    RetVal->KeyHandle = OpenRegKeyStr95A (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfo95A (EnumPtr);
        return FALSE;
    }

    return TRUE;
}


BOOL
pPushRegKeyInfo95W (
    IN      PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR KeyName
    )
{
    PREGKEYINFOW RetVal;
    PWSTR p;

    RetVal = (PREGKEYINFOW) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool, 
                                sizeof (REGKEYINFOW)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOW));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing 
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    if (EnumPtr->FullKeyNameBytes) {
        StringCopyW (p, L"\\");
        EnumPtr->FullKeyNameBytes += ByteCountW (p);
        p++;
    }

    _wcssafecpy (p, KeyName, MAX_REGISTRY_KEYW - (EnumPtr->FullKeyNameBytes / sizeof (WCHAR)));
    EnumPtr->FullKeyNameBytes += ByteCountW (KeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    _wcssafecpy (RetVal->KeyName, KeyName, MAX_REGISTRY_KEYW);
    RetVal->KeyHandle = OpenRegKeyStr95W (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfo95W (EnumPtr);
        return FALSE;
    }

    return TRUE;
}



BOOL
pPopRegKeyInfo95A (
    IN      PREGTREE_ENUMA EnumPtr
    )
{
    PREGKEYINFOA FreeMe;
    PSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey95 (FreeMe->KeyHandle);
    }

    AbortRegKeyEnum95A (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
pPopRegKeyInfo95W (
    IN      PREGTREE_ENUMW EnumPtr
    )
{
    PREGKEYINFOW FreeMe;
    PWSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey95 (FreeMe->KeyHandle);
    }

    AbortRegKeyEnum95W (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
RealEnumFirstRegKeyInTree95A (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMA));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTree95A");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfo95A (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REGUTILS, "EnumFirstRegKeyInTree95A failed to push base key"));
        AbortRegKeyTreeEnum95A (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountA (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree95 knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumFirstRegKeyInTree95W (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMW));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTree95W");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);
    PoolMemDisableTracking (EnumPtr->EnumPool);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfo95W (EnumPtr, BaseKeyStr)) {
        DEBUGMSG ((DBG_REGUTILS, "EnumFirstRegKeyInTree95W failed to push base key"));
        AbortRegKeyTreeEnum95W (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountW (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree95 knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumNextRegKeyInTree95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    while (TRUE) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKey95A (
                    &EnumPtr->CurrentKey->KeyEnum, 
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKey95A (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfo95A (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnum95A (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfo95A (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGA ((
                    DBG_REGUTILS, 
                    "EnumFirstRegKeyInTree95A failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (CHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


BOOL
RealEnumNextRegKeyInTree95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    while (TRUE) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKey95W (
                    &EnumPtr->CurrentKey->KeyEnum, 
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKey95W (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfo95W (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnum95W (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfo95W (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                DEBUGMSGW ((
                    DBG_REGUTILS, 
                    "EnumFirstRegKeyInTree95A failed to push sub key %s",
                    EnumPtr->CurrentKey->KeyEnum.SubKeyName
                    ));

                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (WCHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            MYASSERT (EnumPtr->State == NO_MORE_ITEMS);
            return FALSE;
        }
    }
}


VOID
AbortRegKeyTreeEnum95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfo95A (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}


VOID
AbortRegKeyTreeEnum95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfo95W (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}



/*++

Routine Description:

  EnumFirstRegValue95A and EnumerateFirstRegvalueW enumerate the first registry 
  value name in the specified subkey.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  hKey      - Specifies handle of registry subkey to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegValue95A (
    IN      PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMA));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValue95A (EnumPtr);
}


BOOL
EnumFirstRegValue95W (
    IN      PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValue95W (EnumPtr);
}


/*++

Routine Description:

  EnumNextRegValue95A and EnumNextRegValue95W continue the enumeration started
  by EnumFirstRegValue95A/W.  The enumeration structure is updated to
  reflect the next value name in the subkey being enumerated.

Arguments:

  EnumPtr   - Specifies the registry subkey and enumeration position.
              Receives the updated state of enumeration.  The structure
              can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegValue95A (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEA;

    rc = Win95RegEnumValueA (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
EnumNextRegValue95W (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_REGISTRY_VALUE_NAMEW;

    rc = Win95RegEnumValueW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}



PVOID 
pMemAllocWrapper95 (
    IN      DWORD Size
    )

/*++

Routine Description:

  pMemAllocWrapper95 implements a default allocation routine.  The APIs 
  that have a "2" at the end allow the caller to supply an alternative 
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}


VOID
pMemFreeWrapper95 (
    IN      PVOID Mem
    )

/*++

Routine Description:

  pMemFreeWrapper95 implements a default deallocation routine.
  See pMemAllocWrapper95 above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        pMemAllocWrapper95 function.

Return Value:

  none

--*/

{
    MemFree (g_hHeap, 0, Mem);
}

    
/*++

Routine Description:

  GetRegValueDataEx95A and GetRegValueDataEx95W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free 
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  Free  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an 
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueDataEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = Win95RegQueryValueExA (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    DataBuf = (PBYTE) Alloc (BufSize + sizeof (CHAR));
    rc = Win95RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


PBYTE
GetRegValueDataEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = Win95RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }


    DataBuf = (PBYTE) Alloc (BufSize + sizeof(WCHAR));
    rc = Win95RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfTypeEx95A and GetRegValueDataOfTypeEx95W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  Alloc - Specifies the allocation routine, called to allocate the return data.

  Free - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfTypeEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = Win95RegQueryValueExA (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS || Type != MustBeType) {
        SetLastError (rc);
        return NULL;
    }

    DataBuf = (PBYTE) Alloc (BufSize + sizeof (CHAR));
    rc = Win95RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


PBYTE
GetRegValueDataOfTypeEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = Win95RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS || Type != MustBeType) {
        SetLastError (rc);
        return NULL;
    }

    DataBuf = (PBYTE) Alloc (BufSize + sizeof(WCHAR));
    rc = Win95RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


/*++

Routine Description:

  GetRegKeyDataEx95A and GetRegKeyDataEx95W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  Alloc  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  Free   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyDataEx95A (
    IN      HKEY Parent,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKey95A (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueDataEx95A (SubKeyHandle, "", Alloc, Free);

    CloseRegKey95 (SubKeyHandle);

    return Data;
}


PBYTE
GetRegKeyDataEx95W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKey95W (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueDataEx95W (SubKeyHandle, L"", Alloc, Free);

    CloseRegKey95 (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegDataEx95A and GetRegDataEx95W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  Alloc - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  Free  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegDataEx95A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStr95A (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueDataEx95A (Key, ValueName, Alloc, Free);

    CloseRegKey95 (Key);

    return Data;
}


PBYTE
GetRegDataEx95W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStr95W (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueDataEx95W (Key, ValueName, Alloc, Free);

    CloseRegKey95 (Key);

    return Data;
}


/*++

Routine Description:

  OpenRegKey95A and OpenRegKey95W open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain  
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/
    
HKEY
RealOpenRegKey95A (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY SubKey;
    LONG rc;

    rc = OurRegOpenKeyEx95A (
             ParentKey,
             KeyToOpen,
             0,
             KEY_ALL_ACCESS,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKey95W (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;

    rc = OurRegOpenKeyEx95W (
             ParentKey,
             KeyToOpen,
             0,
             KEY_ALL_ACCESS,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    return SubKey;
}


LONG
RealCloseRegKey95 (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey95 closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey95 macro resolves directly
  to this function in the free build, and to OurCloseRegKey95 in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    return Win95RegCloseKey (Key);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvdcheck\dvdcheck.h ===
#define NOCOMM
#define NOSOUND
#include <windows.h>

// IDs used to load RC strings

#define IDS_FNF               1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvddetect\crc32.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef crc32_h
#define crc32_h

// initial CRC should be 0xffffffff
class CRC32
{
public:
	CRC32( DWORD in) : m_crc32( in ) {};
	CRC32() : m_crc32( 0xffffffff ) {};
	CRC32( const CRC32& in ) : m_crc32( in.m_crc32 ) {};
	CRC32(const void* pPtr, unsigned dwNumBytes);
	template <class T>
	CRC32(const T* pPtr) : m_crc32(  0xffffffff )
		{ Update( pPtr ); }

	DWORD		Update( BYTE bNextByte );
	DWORD		Update( const void* pPtr, unsigned dwNumBytes );

	// template version for adding a structure, data type, or class
	// do not add classes with virtual functions
	template <class T>
	DWORD		Update( const T* pPtr )
				{ return Update( pPtr, sizeof(*pPtr));}

	// a conversion operator is used instead of a 'Get' method so
	// that you can use declarations like " DWORD myCRC = CRC32(ptr,len)"
	//
	//	This class can be used like a function or as an object
	//
	//	For example:
	//		CRC32 myCRC32;
	//		myCRC32.Update( ptr, len );
	//		DWORD myValue = myCRC32;
	//
	//		CRC32 myCRC32(ptr1, len1 );
	//		myCRC32.Update(ptr2, len2 );
	//
	//		DWORD myValue = CRC32(ptr, len )
	//
	operator	DWORD() const	{ return m_crc32; };

protected:
	DWORD		m_crc32;
};

#endif // CRC32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvdupgrd\dvdupgrd.h ===
#define NOCOMM
#define NOSOUND
#include <windows.h>

// IDs used to load RC strings

#define IDS_FNF               1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvdcheck\dvdcheck.cpp ===
// DVDCheck.cpp : Defines the entry point for the  application.
//

#include <streams.h>
#include "DVDDetect.h"

//
//  Generic utility functions
//

static bool AreEqual( const char* pStr1, const char* pStr2 )
{
    return lstrcmpA( pStr1, pStr2 ) ==0;
}

static void DetectForSetup()
{
    DVDDetectBuffer buffer;
    const DVDResult* pResult = buffer.Detect();
    if( pResult ) {
        const DVDResult& result = *pResult;
        bool fResult = result.ShouldUpgradeOnSetup();

        if( fResult ) {
            DVDDetectSetupRun::Add();
        }
    }
}

int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
{
    if( lpCmdLine && AreEqual( lpCmdLine, "/setup") ) {
           DetectForSetup();
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvddetect\crc32.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>

#include "crc32.h"

//
//  Computes the bit reversed CRC32 polynomial
//
// The faster table version.  Use the init routine below with the reversed CRC polynomial 0xedb88320 to create it
// Note: the actual poly is reversed 0xedb88320 but the leading '1' is implied
// (since X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
//  = %1 0000 0100 1100 0001 0001 1101 1011 0111
//  =    0000 0100 1100 0001 0001 1101 1011 0111 (mod x^32, drop the top bit)
//  reversed:
//  1110 1101 1011 1000 1000 0011 0010 0000
// =  e    d    b   8    8     3    2    0
//

static const DWORD dwCRC32_LOOKUP_TABLE [] = {
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

#if 0
    // this is actually calculating the reverse CRC
    // computing the reverse CRC of 0 gives the table entry above
    //
    static uint32 calc_entry( uint32 crc, unsigned index, uint32 poly )
    {
	    for(int i=0;i<8;i++)
	    {
		    if((crc ^ index) & 1)
                crc = (crc>>1)^poly;
		    else
                crc>>= 1;
		    index >>= 1;
	    }
	    return crc;
    }

    static void initcrc32table( uint32 poly, uint32 CrcXorTable[256] )
    {
        for (unsigned i = 0; i < 256; ++i) {
            uint32 entry = calc_entry( 0, i, poly );
		    CrcXorTable[i] = entry;

            // print out for embedding the table
            Dbg( logTrace(2) << dm_hex( CrcXorTable[i] ) << ", " );
            if( (i & 3) == 3 ) {
                Dbg( logTrace(2) << dm_endl );
            }
        }
    }
#endif

static inline DWORD NewCRC32(DWORD crc, BYTE bNextByte )
{
    // #define UPDC32(table, b, crc) (table[((int)crc ^ b) & 0xff] ^ ((crc >> 8) & 0x00FFFFFF))

	return	dwCRC32_LOOKUP_TABLE[ BYTE(crc ^ bNextByte) ] ^ (crc >> 8);
}

DWORD CRC32::Update( BYTE bNextByte )
{
	m_crc32 = NewCRC32(m_crc32, bNextByte);
	return m_crc32;
}

DWORD CRC32::Update( const void* pBuffer, unsigned uLength )
{
	// modifies the current state
	DWORD dwCurrentCRC32 = m_crc32;

	const BYTE* pByte= (const BYTE*)pBuffer;
	for(; uLength > 4; uLength-=4 ) {
		// constant unrolling 4x dramatically helps the crc code
		// beyond that there's not much gain
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
	}
	// finish up the remainder
	for(; uLength > 0; uLength-- ) {
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
	}
	m_crc32 = dwCurrentCRC32;
    return dwCurrentCRC32;
}

// This function is nearly identical, but we win out on a few assignments
// This is done for some speed (can avoid assigning m_crc32 several times)

CRC32::CRC32(const void* pPtr, unsigned uLength)
{
	// do not rely on the optimizer to treat m_crc32 as a local variable
	// assigned at the end
	DWORD dwCurrentCRC32 = 0xffffffff;

	const BYTE* pByte= (const BYTE*)pPtr;
	for(; uLength > 4; uLength-=4 ) {
		// constant unrolling 4x dramatically helps the crc code
		// beyond that there's not much gain
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
	}
	// finish up the remainder
	for(; uLength > 0; uLength-- ) {
		dwCurrentCRC32 = NewCRC32(dwCurrentCRC32, *pByte++);
	}
	m_crc32 = dwCurrentCRC32;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\common\win95reg\win95reg.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    win95reg.c

Abstract:

    Implements Win95-registry access functions callable from Win95 or WinNT.

Author:

    MCondra, 16 Oct 1996

Revision History:

    jimschm     11-Feb-1999     Rewrite of portions because of DBCS bugs
                                and static array problems
    calinn      29-Jan-1998     Added Win95RegOpenKeyStr function

--*/



#include "pch.h"

#define DBG_WIN95REG    "Win95Reg"



#ifdef UNICODE
#error "UNICODE builds not supported"
#endif

//
// Undefine tracking macros
//

#ifdef DEBUG

#undef Win95RegOpenKeyExA
#undef Win95RegOpenKeyExW
#undef Win95RegCloseKey

#endif

//
// Define globals for Win95 registry wrappers
//

#define DEFMAC(fn,name)     P##fn Win95##name;

REGWRAPPERS

#undef DEFMAC


#ifdef RegOpenKeyA

#undef RegOpenKeyA
#undef RegOpenKeyW
#undef RegOpenKeyExA
#undef RegOpenKeyExW

#endif


//
// Declare VMM W versions
//

REG_ENUM_KEY_W pVmmRegEnumKeyW;
REG_ENUM_KEY_EX_A pVmmRegEnumKeyExA;
REG_ENUM_KEY_EX_W pVmmRegEnumKeyExW;
REG_ENUM_VALUE_W pVmmRegEnumValueW;
REG_LOAD_KEY_W pVmmRegLoadKeyW;
REG_UNLOAD_KEY_W pVmmRegUnLoadKeyW;
REG_OPEN_KEY_W pVmmRegOpenKeyW;
REG_CLOSE_KEY pVmmRegCloseKey;
REG_OPEN_KEY_EX_A pVmmRegOpenKeyExA;
REG_OPEN_KEY_EX_W pVmmRegOpenKeyExW;
REG_QUERY_INFO_KEY_W pVmmRegQueryInfoKeyW;
REG_QUERY_VALUE_W pVmmRegQueryValueW;
REG_QUERY_VALUE_EX_W pVmmRegQueryValueExW;

VOID
pCleanupTempUser (
    VOID
    );

BOOL
pIsCurrentUser (
    IN      PCSTR UserNameAnsi
    );

LONG
pWin95RegSetCurrentUserCommonW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,               OPTIONAL
    OUT     PWSTR UserDatOut,                   OPTIONAL
    IN      PCWSTR UserDat                      OPTIONAL
    );

LONG
pWin95RegSetCurrentUserCommonA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,                OPTIONAL
    OUT     PSTR UserDatOut,                    OPTIONAL
    IN      PCSTR UserDat                       OPTIONAL
    );

LONG
pReplaceWinDirInPath (
    IN      PSTR ProfilePathMunged,
    IN      PCSTR ProfilePath,
    IN      PCSTR NewWinDir
    );

DWORD
pSetDefaultUserHelper (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller            OPTIONAL
    );


BOOL g_IsNt;
CHAR g_SystemHiveDir[MAX_MBCHAR_PATH];
CHAR g_SystemUserHive[MAX_MBCHAR_PATH];
BOOL g_UnloadLastUser = FALSE;
PCSTR g_UserKey;
BOOL g_UseClassesRootHive = FALSE;
HKEY g_ClassesRootKey = NULL;



//
// Wrappers of tracking API
//

LONG
pOurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr
    )
{
    return TrackedRegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
}

LONG
pOurRegOpenKeyA (
    HKEY Key,
    PCSTR SubKey,
    PHKEY Result
    )
{
    return TrackedRegOpenKeyA (Key, SubKey, Result);
}


LONG
WINAPI
pOurCloseRegKey (
    HKEY Key
    )
{
    return CloseRegKey (Key);
}


//
// Platform-dependent functions
//

VOID
InitWin95RegFnPointers (
    VOID
    )
{
    OSVERSIONINFO vi;

    vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&vi);

    g_IsNt = (vi.dwPlatformId == VER_PLATFORM_WIN32_NT);

    if (g_IsNt) {

        //
        //  Attach to VMM registry library
        //

        VMMRegLibAttach(0);

        //
        // Initialize global function pointers for NT
        //

        Win95RegFlushKey = VMMRegFlushKey;

        Win95RegEnumKeyA = VMMRegEnumKey;
        Win95RegEnumKeyW = pVmmRegEnumKeyW;

        Win95RegEnumKeyExA = pVmmRegEnumKeyExA;
        Win95RegEnumKeyExW = pVmmRegEnumKeyExW;

        Win95RegEnumValueA = VMMRegEnumValue;
        Win95RegEnumValueW = pVmmRegEnumValueW;

        Win95RegLoadKeyA = VMMRegLoadKey;
        Win95RegLoadKeyW = pVmmRegLoadKeyW;

        Win95RegUnLoadKeyA = VMMRegUnLoadKey;
        Win95RegUnLoadKeyW = pVmmRegUnLoadKeyW;

        Win95RegOpenKeyA = VMMRegOpenKey;
        Win95RegOpenKeyW = pVmmRegOpenKeyW;

        Win95RegOpenKeyExA = pVmmRegOpenKeyExA;
        Win95RegOpenKeyExW = pVmmRegOpenKeyExW;

        Win95RegCloseKey = pVmmRegCloseKey;

        Win95RegQueryInfoKeyA = VMMRegQueryInfoKey;
        Win95RegQueryInfoKeyW = pVmmRegQueryInfoKeyW;

        Win95RegQueryValueA = (PREG_QUERY_VALUE_A)VMMRegQueryValue;
        Win95RegQueryValueW = pVmmRegQueryValueW;

        Win95RegQueryValueExA = VMMRegQueryValueEx;
        Win95RegQueryValueExW = pVmmRegQueryValueExW;

    } else {
        //
        // Initialize global function pointers for NT
        //

        Win95RegFlushKey = RegFlushKey;

        Win95RegEnumKeyA = RegEnumKeyA;
        Win95RegEnumKeyW = RegEnumKeyW;

        Win95RegEnumKeyExA = RegEnumKeyExA;
        Win95RegEnumKeyExW = RegEnumKeyExW;

        Win95RegEnumValueA = RegEnumValueA;
        Win95RegEnumValueW = RegEnumValueW;

        Win95RegLoadKeyA = RegLoadKeyA;
        Win95RegLoadKeyW = RegLoadKeyW;

        Win95RegUnLoadKeyA = RegUnLoadKeyA;
        Win95RegUnLoadKeyW = RegUnLoadKeyW;

        Win95RegOpenKeyA = pOurRegOpenKeyA;
        Win95RegOpenKeyW = RegOpenKeyW;

        Win95RegOpenKeyExA = pOurRegOpenKeyExA;
        Win95RegOpenKeyExW = RegOpenKeyExW;

        Win95RegCloseKey = pOurCloseRegKey;

        Win95RegQueryInfoKeyA = RegQueryInfoKeyA;
        Win95RegQueryInfoKeyW = RegQueryInfoKeyW;

        Win95RegQueryValueA = RegQueryValueA;
        Win95RegQueryValueW = RegQueryValueW;

        Win95RegQueryValueExA = RegQueryValueExA;
        Win95RegQueryValueExW = RegQueryValueExW;

        //
        // Clear away HKLM\Migration
        //

        RegUnLoadKey(
            HKEY_LOCAL_MACHINE,
            S_MIGRATION
            );

        pSetupRegistryDelnode (
            HKEY_LOCAL_MACHINE,
            S_MIGRATION
            );
    }
}


VOID
Win95RegTerminate (
    VOID
    )
{
#ifdef DEBUG
    DumpOpenKeys95();
    RegTrackTerminate95();
#endif

    if (!g_IsNt) {
        pCleanupTempUser();
    } else {
        VMMRegLibDetach();
    }
}



BOOL
WINAPI
Win95Reg_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        InitWin95RegFnPointers();
    } else if (dwReason == DLL_PROCESS_DETACH) {
        Win95RegTerminate();
        pSetupUninitializeUtils();
    }

    return TRUE;
}


LONG
pVmmRegEnumKeyW (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PWSTR KeyName,
    IN      DWORD KeyNameSize
    )
{
    PSTR AnsiBuf;
    LONG rc;
    UINT Chars;

    AnsiBuf = AllocTextA (KeyNameSize);
    MYASSERT (AnsiBuf);

    rc = VMMRegEnumKey (Key, Index, AnsiBuf, KeyNameSize);

    if (rc == ERROR_SUCCESS) {

        Chars = CharCountA (AnsiBuf);

        //
        // Special case: if Chars is zero, then we have 1/2 of a DBCS char.
        //

        if (!Chars && *AnsiBuf) {
            if (KeyNameSize < 4) {
                rc = ERROR_MORE_DATA;
            }

            KeyName[0] = *AnsiBuf;
            KeyName[1] = 0;

        } else {

            //
            // Normal case
            //

            if (Chars >= KeyNameSize / sizeof (WCHAR)) {
                rc = ERROR_MORE_DATA;
            } else {
                KnownSizeDbcsToUnicodeN (KeyName, AnsiBuf, Chars);
            }

        }
    }

    FreeTextA (AnsiBuf);

    return rc;
}


LONG
pVmmRegEnumValueW (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PWSTR ValueName,
    IN OUT  PDWORD ValueNameChars,
            PDWORD Reserved,
    OUT     PDWORD Type,                OPTIONAL
    OUT     PBYTE Data,                 OPTIONAL
    IN OUT  PDWORD DataSize             OPTIONAL
    )
{
    PSTR AnsiValueName;
    LONG rc;
    PSTR AnsiData;
    UINT DataChars;
    UINT ValueChars;
    DWORD OurType;
    DWORD OrgValueNameChars;
    DWORD OrgDataSize;
    DWORD OurValueNameChars;
    DWORD OurValueNameCharsBackup;
    DWORD AnsiDataSize;
    BOOL HalfDbcs = FALSE;

    __try {
        MYASSERT (ValueNameChars);
        MYASSERT (ValueName);

        OrgValueNameChars = *ValueNameChars;
        OrgDataSize = DataSize ? *DataSize : 0;

        OurValueNameChars = min (*ValueNameChars, MAX_REGISTRY_VALUE_NAMEA);
        OurValueNameCharsBackup = OurValueNameChars;

        AnsiValueName = AllocTextA (OurValueNameChars);
        MYASSERT (AnsiValueName);

        AnsiData = NULL;

        if (Data) {

            MYASSERT (DataSize);
            AnsiData = AllocTextA (*DataSize + sizeof (CHAR) * 2);

        } else if (DataSize) {

            //
            // Data is not specified; allocate a buffer for the
            // proper calculation of DataSize.
            //

            rc = VMMRegEnumValue (
                    Key,
                    Index,
                    AnsiValueName,
                    &OurValueNameChars,
                    NULL,
                    &OurType,
                    NULL,
                    DataSize
                    );

            OurValueNameChars = OurValueNameCharsBackup;

            if (rc == ERROR_SUCCESS) {

                if (OurType == REG_SZ || OurType == REG_EXPAND_SZ || OurType == REG_MULTI_SZ) {
                    *DataSize += 2;
                    AnsiData = AllocTextA (*DataSize);
                }
            } else {
                //
                // Value name must be too small
                //

                __leave;
            }
        }

        rc = VMMRegEnumValue (
                Key,
                Index,
                AnsiValueName,
                &OurValueNameChars,
                NULL,
                &OurType,
                AnsiData,
                DataSize
                );

        if (DataSize) {
            AnsiDataSize = *DataSize;
        } else {
            AnsiDataSize = 0;
        }

        //
        // Return the type
        //

        if (Type) {
            *Type = OurType;
        }

        //
        // Return the sizes
        //

        if (rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA) {

            //
            // The inbound value name size is in characters, including the nul.
            // The outbound value name size is also in characteres, excluding
            // the nul.
            //

            ValueChars = CharCountA (AnsiValueName);

            //
            // Special case: if ValueChars is zero, and AnsiValueName is
            // not empty, then we have half of a DBCS character.
            //

            if (!ValueChars && *AnsiValueName) {
                ValueChars = 1;
                HalfDbcs = TRUE;
            }

            *ValueNameChars = ValueChars;
        }

        if (DataSize) {

            if (rc == ERROR_SUCCESS) {

                //
                // The inbound data size is in bytes, including any nuls that apply.
                // The outbound data size is the same.
                //

                if (AnsiData) {

                    MYASSERT (Data ||
                              OurType == REG_SZ ||
                              OurType == REG_EXPAND_SZ ||
                              OurType == REG_MULTI_SZ
                              );

                    //
                    // If the type is a string, then DataSize needs adjustment.
                    //

                    if (OurType == REG_SZ || OurType == REG_EXPAND_SZ || OurType == REG_MULTI_SZ) {
                        DataChars = CharCountInByteRangeA (AnsiData, AnsiDataSize);
                        *DataSize = DataChars * sizeof (WCHAR);
                    }
                }

                if (Data && *DataSize > OrgDataSize) {
                    rc = ERROR_MORE_DATA;
                }

            } else if (rc == ERROR_MORE_DATA) {

                //
                // Get the correct DataSize value
                //

                pVmmRegEnumValueW (
                    Key,
                    Index,
                    ValueName,
                    ValueNameChars,
                    NULL,
                    NULL,
                    NULL,
                    DataSize
                    );

                __leave;
            }
        }

        //
        // Convert the outbound strings
        //

        if (rc == ERROR_SUCCESS) {

            //
            // Convert value name
            //

            if (ValueChars >= OrgValueNameChars) {
                rc = ERROR_MORE_DATA;
            } else {
                if (!HalfDbcs) {
                    KnownSizeDbcsToUnicodeN (ValueName, AnsiValueName, ValueChars);
                } else {
                    ValueName[0] = *AnsiValueName;
                    ValueName[1] = 0;
                }
            }

            //
            // Convert data
            //

            if (Data) {

                MYASSERT (AnsiData);

                if (OurType == REG_SZ ||
                    OurType == REG_EXPAND_SZ ||
                    OurType == REG_MULTI_SZ
                    ) {

                    DirectDbcsToUnicodeN (
                        (PWSTR) Data,
                        AnsiData,
                        AnsiDataSize
                        );

                } else {

                    CopyMemory (Data, AnsiData, AnsiDataSize);

                }
            }
        }
    }
    __finally {

        FreeTextA (AnsiValueName);
        FreeTextA (AnsiData);
    }

    return rc;
}


LONG
pVmmRegLoadKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    IN      PCWSTR FileName
    )
{
    PCSTR AnsiSubKey;
    PCSTR AnsiFileName;
    LONG rc;

    AnsiSubKey = ConvertWtoA (SubKey);
    AnsiFileName = ConvertWtoA (FileName);

    rc = VMMRegLoadKey (Key, AnsiSubKey, AnsiFileName);

    FreeConvertedStr (AnsiSubKey);
    FreeConvertedStr (AnsiFileName);

    return rc;
}


LONG
pVmmRegUnLoadKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey
    )
{
    PCSTR AnsiSubKey;
    LONG rc;

    AnsiSubKey = ConvertWtoA (SubKey);

    rc = VMMRegUnLoadKey (Key, AnsiSubKey);

    FreeConvertedStr (AnsiSubKey);

    return rc;
}


LONG
pVmmRegOpenKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    OUT     HKEY *KeyPtr
    )
{
    PCSTR AnsiSubKey;
    LONG rc;
    CHAR mappedSubKey[MAXIMUM_SUB_KEY_LENGTH];
    PCSTR MappedAnsiSubKey;

    MappedAnsiSubKey = AnsiSubKey = ConvertWtoA (SubKey);
    //
    // if g_UseClassesRootHive is set, then perform some translations
    //
    if (g_UseClassesRootHive) {
        if (Key == HKEY_LOCAL_MACHINE) {
            if (StringIMatchCharCountA (
                    AnsiSubKey,
                    "SOFTWARE\\Classes",
                    sizeof ("SOFTWARE\\Classes") - 1
                    )) {

                StringCopyByteCountA (
                    mappedSubKey,
                    AnsiSubKey + sizeof ("SOFTWARE\\Classes") - 1,
                    MAXIMUM_SUB_KEY_LENGTH
                    );

                Key = g_ClassesRootKey;
                MappedAnsiSubKey = mappedSubKey;
                if (*MappedAnsiSubKey == '\\') {
                    MappedAnsiSubKey++;
                }
            }
        } else if (Key == HKEY_CLASSES_ROOT) {
            Key = g_ClassesRootKey;
        }
    }

    rc = VMMRegOpenKey (Key, MappedAnsiSubKey, KeyPtr);

    FreeConvertedStr (AnsiSubKey);

    return rc;
}


LONG
pVmmRegCloseKey (
    IN      HKEY Key
    )
{
    if (g_UseClassesRootHive) {
        if (Key == g_ClassesRootKey) {
            return ERROR_SUCCESS;
        }
    }

    return VMMRegCloseKey (Key);
}


LONG
pVmmRegEnumKeyExA (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PSTR KeyName,
    IN OUT  PDWORD KeyNameSize,
            PDWORD Reserved,
    OUT     PSTR Class,                     OPTIONAL
    IN OUT  PDWORD ClassSize,               OPTIONAL
    OUT     PFILETIME LastWriteTime         OPTIONAL
    )
{
    LONG rc;

    MYASSERT (KeyNameSize);
    MYASSERT (KeyName);

    rc = VMMRegEnumKey (
            Key,
            Index,
            KeyName,
            *KeyNameSize
            );

    if (rc == ERROR_SUCCESS) {
        //
        // Return length of key name, excluding delimiter
        //
        *KeyNameSize = ByteCount (KeyName);

        //
        // Return zero-length class
        //
        if (Class && *ClassSize) {
            *Class = 0;
        }

        if (ClassSize) {
            *ClassSize = 0;
        }

        //
        // Stuff last-write time with zero
        //
        if (LastWriteTime) {
            ZeroMemory (LastWriteTime, sizeof (FILETIME));
        }

    } else {
        *KeyNameSize = MAX_PATH + 1;

        if (ClassSize) {
            *ClassSize = 0;
        }
    }

    return rc;
}


LONG
pVmmRegEnumKeyExW (
    IN      HKEY Key,
    IN      DWORD Index,
    OUT     PWSTR KeyName,
    IN OUT  PDWORD KeyNameSize,
            PDWORD Reserved,
    OUT     PWSTR Class,                    OPTIONAL
    IN OUT  PDWORD ClassSize,               OPTIONAL
    OUT     PFILETIME LastWriteTime         OPTIONAL
    )
{
    LONG rc;
    PSTR AnsiKeyName;
    PSTR AnsiClass;
    UINT Chars;
    DWORD OrgKeyNameSize;
    DWORD OrgClassSize;
    BOOL HalfDbcs = FALSE;

    __try {
        MYASSERT (KeyName);
        MYASSERT (KeyNameSize);

        AnsiKeyName = AllocTextA (*KeyNameSize);

        if (Class) {
            MYASSERT (ClassSize);
            AnsiClass = AllocTextA (*ClassSize);
        } else {
            AnsiClass = NULL;
        }

        OrgKeyNameSize = *KeyNameSize;
        OrgClassSize = ClassSize ? *ClassSize : 0;

        rc = pVmmRegEnumKeyExA (
                Key,
                Index,
                AnsiKeyName,
                KeyNameSize,
                NULL,
                AnsiClass,
                ClassSize,
                LastWriteTime
                );

        if (rc == ERROR_SUCCESS) {

            Chars = CharCountA (AnsiKeyName);

            //
            // Special case: If Chars is zero, but AnsiKeyName is not empty,
            // then we have 1/2 of a DBCS character.
            //

            if (!Chars && *AnsiKeyName) {
                Chars = 1;
                HalfDbcs = TRUE;
            }

            *KeyNameSize = Chars;

            if (Chars >= OrgKeyNameSize / sizeof (WCHAR)) {
                rc = ERROR_MORE_DATA;
                __leave;
            }

            if (!HalfDbcs) {
                KnownSizeDbcsToUnicodeN (KeyName, AnsiKeyName, Chars);
            } else {
                KeyName[0] = *AnsiKeyName;
                KeyName[1] = 0;
            }

            HalfDbcs = FALSE;

            if (Class) {

                Chars = CharCountA (AnsiClass);

                //
                // Special case: If Chars is zero, but AnsiClass is not empty,
                // then we have 1/2 of a DBCS character.
                //

                if (!Chars && *AnsiClass) {
                    Chars = 1;
                    HalfDbcs = TRUE;
                }

                *ClassSize = Chars;

                if (Chars >= OrgClassSize / sizeof (WCHAR)) {
                    rc = ERROR_MORE_DATA;
                    __leave;
                }

                if (!HalfDbcs) {
                    KnownSizeDbcsToUnicodeN (Class, AnsiClass, Chars);
                } else {
                    Class[0] = *AnsiClass;
                    Class[1] = 0;
                }
            }
        }
    }
    __finally {
        FreeTextA (AnsiKeyName);
        FreeTextA (AnsiClass);
    }

    return rc;
}


LONG
pVmmRegOpenKeyExA (
    IN      HKEY Key,
    IN      PCSTR SubKey,
    IN      DWORD Options,
    IN      REGSAM SamDesired,
    OUT     HKEY *KeyPtr
    )
{
    CHAR mappedSubKey[MAXIMUM_SUB_KEY_LENGTH];
    PCSTR MappedSubKey = SubKey;

    //
    // if g_UseClassesRootHive is set, then perform some translations
    //
    if (g_UseClassesRootHive) {
        if (Key == HKEY_LOCAL_MACHINE) {
            if (StringIMatchByteCountA (
                    SubKey,
                    "SOFTWARE\\Classes",
                    sizeof ("SOFTWARE\\Classes") - 1
                    )) {

                StringCopyByteCountA (
                    mappedSubKey,
                    SubKey + sizeof ("SOFTWARE\\Classes") - 1,
                    MAXIMUM_SUB_KEY_LENGTH
                    );

                Key = g_ClassesRootKey;
                MappedSubKey = mappedSubKey;
                if (*MappedSubKey == '\\') {
                    MappedSubKey++;
                }
            }
        } else if (Key == HKEY_CLASSES_ROOT) {
            Key = g_ClassesRootKey;
        }
    }

    return VMMRegOpenKey (Key, MappedSubKey, KeyPtr);
}


LONG
pVmmRegOpenKeyExW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    IN      DWORD Options,
    IN      REGSAM SamDesired,
    OUT     HKEY *KeyPtr
    )
{
    return pVmmRegOpenKeyW (Key, SubKey, KeyPtr);
}


LONG
pVmmRegQueryInfoKeyW (
    IN      HKEY Key,
    OUT     PWSTR Class,                    OPTIONAL
    OUT     PDWORD ClassSize,               OPTIONAL
    OUT     PDWORD Reserved,                OPTIONAL
    OUT     PDWORD SubKeys,                 OPTIONAL
    OUT     PDWORD MaxSubKeyLen,            OPTIONAL
    OUT     PDWORD MaxClassLen,             OPTIONAL
    OUT     PDWORD Values,                  OPTIONAL
    OUT     PDWORD MaxValueName,            OPTIONAL
    OUT     PDWORD MaxValueData,            OPTIONAL
    OUT     PVOID SecurityDescriptor,       OPTIONAL
    OUT     PVOID LastWriteTime             OPTIONAL
    )
{
    PSTR AnsiClass;
    LONG rc = ERROR_NOACCESS;
    UINT Chars;
    DWORD OrgClassSize;
    BOOL HalfDbcs = FALSE;

    __try {

        if (Class) {
            MYASSERT (ClassSize);
            AnsiClass = AllocTextA (*ClassSize);
            if (!AnsiClass) {
                __leave;
            }
        } else {
            AnsiClass = NULL;
        }

        OrgClassSize = ClassSize ? *ClassSize : 0;

        rc = VMMRegQueryInfoKey (
                Key,
                AnsiClass,
                ClassSize,
                Reserved,
                SubKeys,
                MaxSubKeyLen,
                MaxClassLen,
                Values,
                MaxValueName,
                MaxValueData,
                SecurityDescriptor,
                LastWriteTime
                );

        if (MaxValueData) {
            *MaxValueData *= 2;
        }

        if (rc == ERROR_SUCCESS) {
            if (Class) {

                Chars = CharCountA (AnsiClass);

                //
                // Special case: If Chars is zero, but AnsiClass is not empty,
                // then we have 1/2 of a DBCS character.
                //

                if (!Chars && *AnsiClass) {
                    Chars = 1;
                    HalfDbcs = TRUE;
                }

                *ClassSize = Chars;

                if (Chars >= OrgClassSize / sizeof (WCHAR)) {
                    rc = ERROR_MORE_DATA;
                    __leave;
                }

                if (!HalfDbcs) {
                    KnownSizeDbcsToUnicodeN (Class, AnsiClass, Chars);
                } else {
                    Class[0] = *AnsiClass;
                    Class[1] = 0;
                }
            }
        }
    }
    __finally {
        FreeTextA (AnsiClass);
    }

    return rc;
}


LONG
pVmmRegQueryValueW (
    IN      HKEY Key,
    IN      PCWSTR SubKey,
    OUT     PWSTR Data,         OPTIONAL
    IN OUT  PLONG DataSize      OPTIONAL
    )
{
    PSTR AnsiData;
    PCSTR AnsiSubKey;
    LONG rc;
    UINT Chars;
    LONG OrgDataSize;
    DWORD AnsiDataSize;

    __try {
        AnsiSubKey = ConvertWtoA (SubKey);
        OrgDataSize = DataSize ? *DataSize : 0;
        AnsiData = NULL;

        if (Data) {

            MYASSERT (DataSize);
            AnsiData = AllocTextA (*DataSize + sizeof (CHAR) * 2);

        } else if (DataSize) {

            //
            // Data is not specified; allocate a buffer for the
            // proper computation of DataSize.
            //

            rc = VMMRegQueryValue (
                    Key,
                    AnsiSubKey,
                    NULL,
                    DataSize
                    );

            if (rc == ERROR_SUCCESS) {

                *DataSize += 2;
                AnsiData = AllocTextA (*DataSize);

            } else {
                //
                // An error usually means the sub key does not exist...
                //

                __leave;
            }
        }

        rc = VMMRegQueryValue (Key, AnsiSubKey, AnsiData, DataSize);

        if (DataSize) {
            AnsiDataSize = *DataSize;
        } else {
            AnsiDataSize = 0;
        }

        //
        // Adjust the outbound size
        //

        if (DataSize) {
            if (rc == ERROR_SUCCESS) {

                Chars = CharCountInByteRangeA (AnsiData, AnsiDataSize);

                MYASSERT (DataSize);
                *DataSize = (Chars + 1) * sizeof (WCHAR);

                if (Data && *DataSize > OrgDataSize) {
                    rc = ERROR_MORE_DATA;
                }

            } else if (rc == ERROR_MORE_DATA) {

                pVmmRegQueryValueW (Key, SubKey, NULL, DataSize);
                __leave;

            }
        }

        //
        // Convert the return strings
        //

        if (rc == ERROR_SUCCESS) {

            MYASSERT (AnsiData);

            if (Data) {

                DirectDbcsToUnicodeN ((PWSTR) Data, AnsiData, AnsiDataSize);

            } else {

                CopyMemory (Data, AnsiData, AnsiDataSize);

            }
        }
    }
    __finally {
        FreeTextA (AnsiData);
        FreeConvertedStr (AnsiSubKey);
    }

    return rc;
}


LONG
pVmmRegQueryValueExW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
            PDWORD Reserved,
    OUT     PDWORD Type,            OPTIONAL
    OUT     PBYTE Data,             OPTIONAL
    IN OUT  PDWORD DataSize         OPTIONAL
    )
{
    LONG rc;
    UINT Chars;
    PCSTR AnsiValueName;
    PSTR AnsiData;
    DWORD OurType;
    DWORD OrgDataSize;
    DWORD AnsiDataSize;

    __try {
        AnsiValueName = ConvertWtoA (ValueName);
        OrgDataSize = DataSize ? *DataSize : 0;
        AnsiData = NULL;

        if (Data) {

            MYASSERT (DataSize);
            AnsiData = AllocTextA (*DataSize + sizeof (CHAR) * 2);

        } else if (DataSize) {

            //
            // Data is not specified; allocate a buffer for the
            // proper computation of DataSize.
            //

            rc = VMMRegQueryValueEx (
                    Key,
                    AnsiValueName,
                    NULL,
                    &OurType,
                    NULL,
                    DataSize
                    );

            if (rc == ERROR_SUCCESS) {

                //
                // *DataSize is a byte count, but increase it to
                // accomodate multisz termination
                //

                *DataSize += 2;
                AnsiData = AllocTextA (*DataSize);

            } else {
                //
                // An error usually means the value does not exist...
                //

                __leave;
            }
        }

        rc = VMMRegQueryValueEx (
                Key,
                AnsiValueName,
                NULL,
                &OurType,
                AnsiData,
                DataSize
                );

        if (DataSize) {
            AnsiDataSize = *DataSize;
        } else {
            AnsiDataSize = 0;
        }

        //
        // Return the type
        //

        if (Type) {
            *Type = OurType;
        }

        //
        // Return the sizes
        //

        if (DataSize) {
            if (rc == ERROR_SUCCESS) {

                if (OurType == REG_SZ ||
                    OurType == REG_EXPAND_SZ ||
                    OurType == REG_MULTI_SZ
                    ) {

                    AnsiData[*DataSize] = 0;
                    AnsiData[*DataSize + 1] = 0;

                    Chars = CharCountInByteRangeA (AnsiData, AnsiDataSize);
                    *DataSize = Chars * sizeof (WCHAR);
                }

                if (Data && *DataSize > OrgDataSize) {
                    rc = ERROR_MORE_DATA;
                }
            } else if (rc == ERROR_MORE_DATA) {
                //
                // Get the correct data size
                //

                pVmmRegQueryValueExW (
                    Key,
                    ValueName,
                    NULL,
                    NULL,
                    NULL,
                    DataSize
                    );

                __leave;
            }
        }

        //
        // Convert the return strings
        //

        if (rc == ERROR_SUCCESS) {

            if (Data) {

                MYASSERT (AnsiData);

                if (OurType == REG_SZ ||
                    OurType == REG_EXPAND_SZ ||
                    OurType == REG_MULTI_SZ
                    ) {

                    DirectDbcsToUnicodeN ((PWSTR) Data, AnsiData, AnsiDataSize);

                } else {

                    CopyMemory (Data, AnsiData, AnsiDataSize);

                }
            }
        }
    }
    __finally {
        FreeConvertedStr (AnsiValueName);
        FreeTextA (AnsiData);
    }

    return rc;
}



LONG
Win95RegInitA (
    IN      PCSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    )
{
    LONG rc = ERROR_SUCCESS;
    CHAR SystemDatPath[MAX_MBCHAR_PATH];
    CHAR ConfigKey[MAX_REGISTRY_KEY];
    CHAR ConfigVersion[256];
    HKEY Key;
    DWORD Size;

    //
    // Save the system hive dir
    //

    StringCopyA (g_SystemHiveDir, SystemHiveDir);
    AppendWackA (g_SystemHiveDir);

    //
    // Save the system user.dat
    //

    StringCopyA (g_SystemUserHive, g_SystemHiveDir);
    StringCatA (g_SystemUserHive, "user.dat");

    //
    // If NT, set up HKLM and HKU
    //

    if (g_IsNt) {

        __try {
            Key = NULL;

            StringCopyA (SystemDatPath, g_SystemHiveDir);
            StringCatA (SystemDatPath, "system.dat");

            rc = VMMRegMapPredefKeyToFile (HKEY_LOCAL_MACHINE, SystemDatPath, 0);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "%s could not be loaded", SystemDatPath));
                __leave;
            }

            if (UseClassesRootHive) {

                StringCopyA (SystemDatPath, g_SystemHiveDir);
                StringCatA (SystemDatPath, "classes.dat");

                rc = VMMRegLoadKey (
                        HKEY_LOCAL_MACHINE,
                        "SOFTWARE$Classes",
                        SystemDatPath
                        );

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "%s could not be loaded", SystemDatPath));
                    __leave;
                }

                rc = VMMRegOpenKey (
                        HKEY_LOCAL_MACHINE,
                        "SOFTWARE$Classes",
                        &g_ClassesRootKey
                        );

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "%s could not be opened", "SOFTWARE$Classes"));
                    __leave;
                }

                g_UseClassesRootHive = TRUE;
            }

            rc = VMMRegMapPredefKeyToFile (HKEY_USERS, g_SystemUserHive, 0);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "%s could not be loaded", g_SystemUserHive));
                __leave;
            }

            rc = Win95RegOpenKeyA (
                    HKEY_LOCAL_MACHINE,
                    "System\\CurrentControlSet\\control\\IDConfigDB",
                    &Key
                    );

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "IDConfigDB could not be opened"));
                __leave;
            }

            Size = sizeof (ConfigVersion);

            rc = Win95RegQueryValueExA (
                    Key,
                    "CurrentConfig",
                    NULL,
                    NULL,
                    (PBYTE) ConfigVersion,
                    &Size
                    );

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "CurrentConfig could not be queried"));
                __leave;
            }

            StringCopyA (ConfigKey, "Config\\");
            StringCatA (ConfigKey, ConfigVersion);

            Win95RegCloseKey (Key);
            rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, ConfigKey, &Key);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "%s could not be opened", ConfigKey));

                rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, "Config", &Key);
                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "No Win9x hardware configuration keys available"));
                    Key = NULL;
                    __leave;
                }

                Size = 256;
                rc = Win95RegEnumKeyExA (
                        Key,
                        0,
                        ConfigVersion,
                        &Size,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

                Win95RegCloseKey (Key);

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "Can't enumerate Win9x hardware configuration keys"));
                    Key = NULL;
                    __leave;
                }

                StringCopyA (ConfigKey, "Config\\");
                StringCatA (ConfigKey, ConfigVersion);
                rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, ConfigKey, &Key);

                if (rc != ERROR_SUCCESS) {
                    LOGA ((LOG_ERROR, "Can't open enumerated Win9x hardware configuration key"));
                    Key = NULL;
                    __leave;
                }
            }

            rc = VMMRegMapPredefKeyToKey (Key, HKEY_CURRENT_CONFIG);

            if (rc != ERROR_SUCCESS) {
                LOGA ((LOG_ERROR, "HKCC could not be mapped"));
                __leave;
            }

        }
        __finally {
            if (Key) {
                Win95RegCloseKey (Key);
            }
        }
    }

    if (rc != ERROR_SUCCESS) {
        LOGA ((LOG_ERROR, "Registry files from previous operating system are damaged or missing"));
    }

    return rc;
}


LONG
Win95RegInitW (
    IN      PCWSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    )
{
    LONG rc;
    PCSTR AnsiSystemHiveDir;

    AnsiSystemHiveDir = ConvertWtoA (SystemHiveDir);

    //
    // Call ANSI version of function
    //
    rc = Win95RegInitA (AnsiSystemHiveDir, UseClassesRootHive);

    FreeConvertedStr (AnsiSystemHiveDir);

    return rc;
}


#define GU_VALID 0x5538

LONG
Win95RegGetFirstUserA (
    PUSERPOSITION Pos,
    PSTR UserNameAnsi
    )
{
    DWORD rc = ERROR_SUCCESS;
    DWORD Size;
    DWORD Enabled;
    HKEY Key;

    MYASSERT (UserNameAnsi);
    MYASSERT (Pos);

    //
    // Initialize profile enumeration state (USERPOSITION)
    //
    ZeroMemory (Pos, sizeof (USERPOSITION));
    Pos->Valid = GU_VALID;

    //
    // See whether registry supports per-user profiles.
    //
    rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, "Network\\Logon", &Key);

    if (rc == ERROR_SUCCESS) {

        Size = sizeof (DWORD);

        rc = Win95RegQueryValueExA (
                Key,
                "UserProfiles",
                NULL,
                NULL,
                (PBYTE) &Enabled,
                &Size
                );

        Pos->UseProfile = (rc == ERROR_SUCCESS && Enabled);

        //
        // Identify the last logged-on user.
        //

        Size = sizeof (Pos->LastLoggedOnUserName);
        rc = Win95RegQueryValueExA (
                Key,
                "UserName",
                NULL,
                NULL,
                Pos->LastLoggedOnUserName,
                &Size
                );

        if (rc == ERROR_SUCCESS) {
            OemToCharA (Pos->LastLoggedOnUserName, Pos->LastLoggedOnUserName);

            if (!Pos->UseProfile || Win95RegIsValidUser (NULL, Pos->LastLoggedOnUserName)) {
                Pos->LastLoggedOnUserNameExists = TRUE;
            } else {
                Pos->LastLoggedOnUserName[0] = 0;
            }
        }

        Win95RegCloseKey (Key);
    }

    //
    // On a common-profile machine, we'll return the last logged-on user name.
    // If no last logged-on user exists, or if the path to this registry value
    // doesn't exist, we'll return "", meaning "no user". Both cases are considered
    // valid.
    //

    if (!Pos->UseProfile) {
        //
        // Success.
        //

        _mbssafecpy (UserNameAnsi, Pos->LastLoggedOnUserName, MAX_USER_NAMEA);
        //StringCopyA (UserNameAnsi, Pos->LastLoggedOnUserName);

        if (UserNameAnsi[0]) {
            Pos->NumPos = 1;
        }

        Pos->IsLastLoggedOnUserName = Pos->LastLoggedOnUserNameExists;
        return ERROR_SUCCESS;
    }

    rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, S_PROFILELIST_KEYA, &Key);

    if (rc != ERROR_SUCCESS) {

        Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE

        //
        // This error code change was added by MikeCo.  It likely doesn't
        // do anything useful.
        //

        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_SUCCESS;
        }

    } else {
        //
        // Find the first valid profile
        //

        Win95RegQueryInfoKeyA (Key, NULL, NULL, NULL, &Pos->NumPos, NULL, NULL,
                               NULL, NULL, NULL, NULL, NULL);

        if (Pos->NumPos > 0) {

            do {

                Size = MAX_USER_NAMEA;

                rc = Win95RegEnumKeyExA (
                        Key,
                        Pos->CurPos,
                        UserNameAnsi,
                        &Size,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

                if (rc != ERROR_SUCCESS) {
                    Pos->NumPos = 0;
                    break;
                }

                if (Win95RegIsValidUser (Key, UserNameAnsi)) {

                    Pos->IsLastLoggedOnUserName = StringIMatch (
                                                    UserNameAnsi,
                                                    Pos->LastLoggedOnUserName
                                                    );
                    break;

                }

                Pos->CurPos++;

            } while (Pos->CurPos < Pos->NumPos);

            if (Pos->CurPos >= Pos->NumPos) {
                Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
            }
        }

        Win95RegCloseKey (Key);
    }

    DEBUGMSG_IF ((rc != ERROR_SUCCESS, DBG_ERROR, "WIN95REG: Error getting first user"));

    return rc;
}


LONG
Win95RegGetNextUserA (
    PUSERPOSITION Pos,
    PSTR UserNameAnsi
    )
{
    DWORD Size;
    LONG rc = ERROR_SUCCESS;
    HKEY Key;

    MYASSERT (Pos && GU_VALID == Pos->Valid);
    MYASSERT (UserNameAnsi);

    Pos->IsLastLoggedOnUserName = FALSE;

    //
    // On a common-profile machine, this function always returns
    // "no more users", since the call to Win95RegGetFirstUserA/W
    // returned the only named user (the logged-on user, if it
    // exists).
    //
    if (!Pos->UseProfile) {
        Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
        return rc;
    }

    //
    // Open key to profile list
    //
    rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, S_PROFILELIST_KEYA, &Key);

    if (rc != ERROR_SUCCESS) {
        Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
    } else {

        Pos->CurPos++;

        while (Pos->CurPos < Pos->NumPos) {

            //
            // Get first user's key name
            //
            Size = MAX_USER_NAMEA;

            rc = Win95RegEnumKeyExA(
                    Key,
                    Pos->CurPos,
                    UserNameAnsi,
                    &Size,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

            if (rc != ERROR_SUCCESS) {
                Pos->NumPos = 0;
                break;
            }

            if (Win95RegIsValidUser (Key, UserNameAnsi)) {

                Pos->IsLastLoggedOnUserName = StringIMatch (
                                                    UserNameAnsi,
                                                    Pos->LastLoggedOnUserName
                                                    );
                break;

            }

            Pos->CurPos++;
        }

        if (Pos->CurPos >= Pos->NumPos) {
            Pos->NumPos = 0;        // causes Win95RegHaveUser to return FALSE
        }

        Win95RegCloseKey (Key);
    }

    DEBUGMSG_IF ((rc != ERROR_SUCCESS, DBG_ERROR, "WIN95REG: Error getting next user"));

    return rc;
}


LONG
Win95RegGetFirstUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    )
{
    LONG rc;
    CHAR AnsiUserName[MAX_USER_NAMEA];
    PSTR p;

    MYASSERT (Pos && UserName);

    rc = Win95RegGetFirstUserA (Pos, AnsiUserName);

    if (rc == ERROR_SUCCESS) {

        if (CharCountA (AnsiUserName) > MAX_USER_NAMEW - 1) {
            p = CharCountToPointerA (AnsiUserName, MAX_USER_NAMEW - 1);
            *p = 0;
        }

        KnownSizeAtoW (UserName, AnsiUserName);
    }

    return rc;
}


LONG
Win95RegGetNextUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    )
{
    LONG rc;
    CHAR AnsiUserName[MAX_USER_NAMEA];
    PSTR p;

    MYASSERT (Pos);
    MYASSERT (UserName);

    rc = Win95RegGetNextUserA (Pos, AnsiUserName);

    if (rc == ERROR_SUCCESS) {

        if (CharCountA (AnsiUserName) > MAX_USER_NAMEW - 1) {
            p = CharCountToPointerA (AnsiUserName, MAX_USER_NAMEW - 1);
            *p = 0;
        }

        KnownSizeAtoW (UserName, AnsiUserName);
    }

    return rc;
}


BOOL
pIsCurrentUser (
    IN      PCSTR UserNameAnsi
    )
{
    DWORD subKeys;
    LONG rc;
    HKEY win9xUpgKey;
    CHAR userName[MAX_USER_NAME];
    DWORD userNameSize;
    BOOL result = FALSE;
    HKEY profileKey;

    rc = Win95RegOpenKeyA (
            HKEY_LOCAL_MACHINE,
            "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg",
            &win9xUpgKey
            );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    userNameSize = ARRAYSIZE(userName);

    rc = Win95RegQueryValueExA (
            win9xUpgKey,
            "CurrentUser",
            NULL,
            NULL,
            (PBYTE) userName,
            &userNameSize
            );

    if (rc == ERROR_SUCCESS) {
        result = StringIMatchA (UserNameAnsi, userName);
    }

    Win95RegCloseKey (win9xUpgKey);

    return result;
}


BOOL
Win95RegIsValidUser (
    HKEY ProfileListKey,            OPTIONAL
    PSTR UserNameAnsi
    )
{
    HKEY UserProfileKey;
    BOOL b = FALSE;
    BOOL CloseProfileListKey = FALSE;
    LONG rc;

    if (!ProfileListKey) {
        rc = Win95RegOpenKeyA (HKEY_LOCAL_MACHINE, S_PROFILELIST_KEYA, &ProfileListKey);
        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

        CloseProfileListKey = TRUE;
    }

    //
    // Open the user key
    //
    rc = Win95RegOpenKeyA (
            ProfileListKey,
            UserNameAnsi,
            &UserProfileKey
            );

    //
    // Does ProfileImagePath exist?
    // (The case where the user logged in but did not retain settings)
    //
    if (rc == ERROR_SUCCESS) {

        rc = Win95RegQueryValueExA (
                UserProfileKey,
                S_PROFILEIMAGEPATH,
                NULL,
                NULL,
                NULL,
                NULL
                );

        if (rc == ERROR_SUCCESS) {
            //
            // Add other tests here
            //

            b = TRUE;

        } else {
            //
            // Need to check if this is the current user. If it is, and we are
            // here, then the user doing the upgrade chose not to save his/her
            // settings.
            //

            b = pIsCurrentUser (UserNameAnsi);
        }

        Win95RegCloseKey (UserProfileKey);
    }

    if (CloseProfileListKey) {
        Win95RegCloseKey (ProfileListKey);
    }

    return b;
}


VOID
pCleanupTempUser (
    VOID
    )
{
    g_UserKey = NULL;

    if (!g_UnloadLastUser) {
        return;
    }

    //
    // Unload temp user hive
    //

    RegUnLoadKey(
        HKEY_LOCAL_MACHINE,
        S_MIGRATION
        );

    pSetupRegistryDelnode (
        HKEY_LOCAL_MACHINE,
        S_MIGRATION
        );

    g_UnloadLastUser = FALSE;
}


VOID
pGetCurrentUserDatPath (
    IN      PCSTR BaseDir,
    OUT     PSTR PathSpec
    )
{
    CHAR UserNameAnsi[MAX_USER_NAMEA];
    CHAR FullPath[MAX_MBCHAR_PATH];
    CHAR RegKey[MAX_REGISTRY_KEY];
    HKEY ProfileListKey;
    PCSTR Data;
    DWORD Size;

    Size = ARRAYSIZE(UserNameAnsi);

    if (!GetUserName (UserNameAnsi, &Size)) {
        *UserNameAnsi = 0;
    }

    *FullPath = 0;

    if (*UserNameAnsi) {
        //
        // Logged-in user case on a per-user profile machine.  Look in
        // Windows\CV\ProfileList\<user> for a ProfileImagePath value.
        //

        wsprintfA (RegKey, "%s\\%s", S_HKLM_PROFILELIST_KEY, UserNameAnsi);

        ProfileListKey = OpenRegKeyStrA (RegKey);
        if (!ProfileListKey) {
            //
            // No profile list!
            //

            DEBUGMSG ((DBG_WHOOPS, "pGetCurrentUserDatPath: No profile list found"));
        } else {
            //
            // Get the ProfileImagePath value
            //

            Data = GetRegValueDataOfTypeA (ProfileListKey, S_PROFILEIMAGEPATH, REG_SZ);

            if (Data) {
                _mbssafecpy (FullPath, Data, sizeof (FullPath));
                MemFree (g_hHeap, 0, Data);
            }
            ELSE_DEBUGMSG ((
                DBG_WARNING,
                "pGetCurrentUserDatPath: Profile for %s does not have a ProfileImagePath value",
                UserNameAnsi
                ));

            CloseRegKey (ProfileListKey);
        }

    } else {
        //
        // Default user case.  Prepare %windir%\user.dat.
        //

        StringCopyA (FullPath, BaseDir);
    }

    //
    // Append user.dat
    //

    if (*FullPath) {
        StringCopyA (AppendWackA (FullPath), "user.dat");
    }

    //
    // Convert to short name
    //

    if (!(*FullPath) || !OurGetShortPathName (FullPath, PathSpec, MAX_TCHAR_PATH)) {
        _mbssafecpy (PathSpec, FullPath, MAX_MBCHAR_PATH);
    }
}


PCSTR
pLoadUserDat (
    IN      PCSTR BaseDir,
    IN      PCSTR UserDatSpec
    )
{
    CHAR ShortPath[MAX_MBCHAR_PATH];
    CHAR CurrentUserDatPath[MAX_MBCHAR_PATH];
    DWORD rc;

    //
    // Unload last user if necessary
    //

    pCleanupTempUser();

    //
    // Determine if it is necessary to load UserDatSpec.  If not,
    // return HKEY_CURRENT_USER.  Otherwise, load the key into
    // HKLM\Migration, then open it.
    //

    //
    // Always use the short path name
    //

    if (!OurGetShortPathName (UserDatSpec, ShortPath, sizeof (ShortPath))) {
        DEBUGMSG ((
            DBG_WARNING,
            "pLoadUserDat: Could not get short name for %s",
            UserDatSpec
            ));

        return NULL;
    }

    //
    // Per-user profiles are enabled.  Determine if UserDatSpec
    // has already been mapped to HKCU.
    //

    pGetCurrentUserDatPath (BaseDir, CurrentUserDatPath);

    if (StringIMatch (ShortPath, CurrentUserDatPath)) {
        //
        // Yes -- return HKEY_CURRENT_USER
        //

        DEBUGMSG ((DBG_VERBOSE, "%s is the current user's hive.", CurrentUserDatPath));
        return "HKCU";
    }

    //
    // No -- load user.dat into HKLM\Migration
    //

    DEBUGMSG ((DBG_WIN95REG, "RegLoadKey: %s", ShortPath));

    rc = RegLoadKey (
            HKEY_LOCAL_MACHINE,
            S_MIGRATION,
            ShortPath
            );

    if (rc != ERROR_SUCCESS) {

        SetLastError (rc);

        DEBUGMSG ((
            DBG_WARNING,
            "pLoadUserDat: Could not load %s into HKLM\\Migration.  Original Path: %s",
            ShortPath,
            UserDatSpec
            ));

        return NULL;
    }

    g_UnloadLastUser = TRUE;

    return S_HKLM_MIGRATION;
}


LONG
Win95RegSetCurrentUserA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,        OPTIONAL
    OUT     PSTR UserDatOut             OPTIONAL
    )
{
    return pWin95RegSetCurrentUserCommonA (Pos, SystemHiveDir, UserDatOut, NULL);
}


LONG
Win95RegSetCurrentUserW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,       OPTIONAL
    OUT     PWSTR UserDatOut            OPTIONAL
    )
{
    return pWin95RegSetCurrentUserCommonW (Pos, SystemHiveDir, UserDatOut, NULL);
}


LONG
Win95RegSetCurrentUserNtA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR UserDat
    )
{
    return pWin95RegSetCurrentUserCommonA (Pos, NULL, NULL, UserDat);
}


LONG
Win95RegSetCurrentUserNtW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR UserDat
    )
{
    return pWin95RegSetCurrentUserCommonW (Pos, NULL, NULL, UserDat);
}


LONG
pWin95RegSetCurrentUserCommonW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,               OPTIONAL
    OUT     PWSTR UserDatOut,                   OPTIONAL
    IN      PCWSTR UserDat                      OPTIONAL
    )
{
    LONG rc;
    PCSTR AnsiSystemHiveDir;
    PCSTR AnsiUserDat;
    CHAR AnsiUserDatOut[MAX_MBCHAR_PATH];
    PSTR p;

    //
    // Convert args to ANSI
    //

    if (UserDat) {
        AnsiUserDat = ConvertWtoA (UserDat);
    } else {
        AnsiUserDat = NULL;
    }

    if (SystemHiveDir) {
        AnsiSystemHiveDir = ConvertWtoA (UserDat);
    } else {
        AnsiSystemHiveDir = NULL;
    }

    //
    // Call ANSI function
    //
    rc = pWin95RegSetCurrentUserCommonA (Pos, AnsiSystemHiveDir, AnsiUserDatOut, AnsiUserDat);

    if (rc == ERROR_SUCCESS) {

        //
        // Convert OUT arg
        //

        if (UserDatOut) {
            if (CharCountA (AnsiUserDatOut) > MAX_WCHAR_PATH - 1) {
                p = CharCountToPointerA (AnsiUserDatOut, MAX_USER_NAMEW - 1);
                *p = 0;
            }

            KnownSizeAtoW (UserDatOut, AnsiUserDatOut);
        }
    }

    return rc;
}


DWORD
FindAndLoadHive (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller,           OPTIONAL
    IN      BOOL MapTheHive
    )
{
    CHAR RegistryUserDatPath[MAX_MBCHAR_PATH];
    CHAR ActualUserDatPath[MAX_MBCHAR_PATH];
    CHAR UserNameAnsi[MAX_USER_NAMEA];
    DWORD Size;
    HKEY ProfileListKey;
    HKEY UserKey = NULL;
    CHAR WinDir[MAX_MBCHAR_PATH];
    DWORD rc = ERROR_SUCCESS;

    //
    // 1. Determine the path to ActualUserDatPath
    //
    // 2. If user.dat is from registry and caller supplied alternate
    //    %windir%, replace the %windir% with SystemHiveDir
    //
    // 3. If caller wants final path, copy it to their buffer
    //
    // 4. On NT, map the hive as HKCU.  On 95, load the key and open
    //    a reg handle.
    //


    if (UserDatFromCaller) {
        //
        // Caller says where to find user.dat
        //

        StringCopyA (ActualUserDatPath, UserDatFromCaller);

    } else {
        //
        // System.dat says us where to find user.dat
        //

        rc = Win95RegOpenKeyA (
                HKEY_LOCAL_MACHINE,
                S_PROFILELIST_KEYA,
                &ProfileListKey
                );

        if (rc != ERROR_SUCCESS) {
            return rc;
        }

        //
        // Get name of user
        //

        Size = ARRAYSIZE(UserNameAnsi);
        rc = Win95RegEnumKeyExA (
                ProfileListKey,
                (DWORD) Pos->CurPos,
                UserNameAnsi,
                &Size,
                NULL,
                NULL,
                NULL,
                NULL
                );

        if (rc == ERROR_SUCCESS) {
            //
            // Open key to user
            //

            rc = Win95RegOpenKeyA (
                    ProfileListKey,
                    UserNameAnsi,
                    &UserKey
                    );
        }

        Win95RegCloseKey (ProfileListKey);

        if (rc != ERROR_SUCCESS) {
            return rc;
        }

        //
        // Get user's profile path from registry. Optionally relocate it, if user
        // supplied a replacement for WinDir.
        //

        Size = sizeof (RegistryUserDatPath);
        rc = Win95RegQueryValueExA (
                UserKey,
                S_PROFILEIMAGEPATH,
                NULL,
                NULL,
                RegistryUserDatPath,
                &Size
                );

        Win95RegCloseKey (UserKey);

        if (rc != ERROR_SUCCESS) {
            if (!pIsCurrentUser (UserNameAnsi)) {
                return rc;
            }

            return pSetDefaultUserHelper (
                        Pos,
                        SystemHiveDir,
                        UserDatFromCaller,
                        UserDatToCaller
                        );
        }

        //
        // Substitute %WinDir% in path that registry supplied?
        //

        if (SystemHiveDir && *SystemHiveDir) {
            //
            // Munge profile path
            //

            rc = pReplaceWinDirInPath (
                    ActualUserDatPath,
                    RegistryUserDatPath,
                    SystemHiveDir
                    );

            if (rc != ERROR_SUCCESS) {
                return rc;
            }

        } else {

            //
            // Don't munge. Leave as is (correct behavior on Win95 with local profiles)
            //

            StringCopyA (ActualUserDatPath, RegistryUserDatPath);
        }

        //
        // Add name of hive file, "\\user.dat"
        //

        StringCopyA (AppendWackA (ActualUserDatPath), "user.dat");

    }

    //
    // Send path to caller if necessary
    //

    if (UserDatToCaller) {
        _mbssafecpy (UserDatToCaller, ActualUserDatPath, MAX_MBCHAR_PATH);
    }

    if (MapTheHive) {
        if (g_IsNt) {

            //
            // WinNT: Associate filename with HKCU
            //

            rc = VMMRegMapPredefKeyToFile (
                    HKEY_CURRENT_USER,
                    ActualUserDatPath,
                    0
                    );

        } else {

            //
            // Win9x: Load HKLM\Migration
            //

            if (!SystemHiveDir) {
                if (!GetWindowsDirectory (WinDir, sizeof (WinDir))) {
                    rc = GetLastError ();
                }
            }

            if (rc == ERROR_SUCCESS) {
                g_UserKey = pLoadUserDat (
                               SystemHiveDir ? SystemHiveDir : WinDir,
                               ActualUserDatPath
                               );

                if (!g_UserKey) {
                    rc = GetLastError();
                }
            }
        }
    }

    return rc;
}


DWORD
pSetDefaultUserHelper (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller            OPTIONAL
    )
{
    CHAR ActualUserDatPath[MAX_MBCHAR_PATH];
    DWORD rc = ERROR_SUCCESS;
    HKEY DefaultKey;

    //
    // Determine path to default user's user.dat
    //

    if (UserDatFromCaller) {

        //
        // Caller-supplied user.dat path
        //

        StringCopyA (ActualUserDatPath, UserDatFromCaller);

    } else {

        //
        // Use the string received from Init
        //

        StringCopyA (ActualUserDatPath, g_SystemUserHive);
    }

    //
    // NT: Map the user via VMMREG
    // 9x: Load & open the user hive
    //

    if (g_IsNt) {

        //
        // NT: Map .Default into HKCU.
        //

        //
        // Reload HKEY_USERS
        //

        rc = VMMRegMapPredefKeyToFile (
                  HKEY_USERS,
                  ActualUserDatPath,
                  0
                  );

        if (rc != ERROR_SUCCESS) {
            SetLastError(rc);

            DEBUGMSG ((
                DBG_ERROR,
                "pWin95RegSetCurrentUserCommonW: Cannot reload HKU from %s",
                ActualUserDatPath
                ));

            return rc;
        }

        //
        // Get handle to default profile
        //

        rc = Win95RegOpenKeyA (
                 HKEY_USERS,
                 ".Default",
                 &DefaultKey
                 );

        if (rc != ERROR_SUCCESS) {
            SetLastError(rc);

            DEBUGMSG ((
                DBG_ERROR,
                "pWin95RegSetCurrentUserCommonW: Expected to find key HKU\\.Default in %s",
                ActualUserDatPath
                ));

            return rc;
        }

        //
        // Associate default profile with HKEY_CURRENT_USER
        //

        rc = VMMRegMapPredefKeyToKey (
                DefaultKey,
                HKEY_CURRENT_USER
                );

        Win95RegCloseKey (DefaultKey);

        if (rc != ERROR_SUCCESS) {
            SetLastError(rc);

            DEBUGMSG((
                DBG_ERROR,
                "pWin95RegSetCurrentUserCommonW: Cannot map HKU\\.Default to HKCU from %s",
                ActualUserDatPath
                ));

            return rc;
        }

    } else {

        //
        // Win9x: Return HKU\.Default
        //

        g_UserKey = S_HKU_DEFAULT;
    }

    //
    // Send path to caller if necessary
    //

    if (UserDatToCaller) {
        _mbssafecpy (UserDatToCaller, ActualUserDatPath, MAX_MBCHAR_PATH);
    }

    return rc;
}


LONG
pWin95RegSetCurrentUserCommonA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,                OPTIONAL
    OUT     PSTR UserDatOut,                    OPTIONAL
    IN      PCSTR UserDat                       OPTIONAL
    )
{

    MYASSERT (!Pos || GU_VALID == Pos->Valid);

    //
    // Process per-user user.dat if
    //   (A) caller does not want default user
    //   (B) machine has per-user profiles
    //   (C) current user position is valid
    //

    if (Pos && Pos->UseProfile && Pos->CurPos < Pos->NumPos) {
        return (LONG) FindAndLoadHive (
                            Pos,
                            SystemHiveDir,
                            UserDat,
                            UserDatOut,
                            TRUE
                            );
    }

    //
    // For all other cases, use a default profile
    //

    return (LONG) pSetDefaultUserHelper (
                        Pos,
                        SystemHiveDir,
                        UserDat,
                        UserDatOut
                        );

}


LONG
pReplaceWinDirInPath (
    IN      PSTR ProfilePathMunged,
    IN      PCSTR ProfilePath,
    IN      PCSTR NewWinDir
    )
{
    PSTR EndOfWinDir;

    //
    // Test assumptions about profile dir. Expect x:\windir\...
    //
    if (!isalpha(ProfilePath[0]) ||
        ProfilePath[1] != ':' ||
        ProfilePath[2] != '\\'
        ) {
        return ERROR_INVALID_DATA;
    }

    //
    // Find the second slash (the first is at ptr+2)
    //
    EndOfWinDir = _mbschr (&ProfilePath[3], '\\');
    if (!EndOfWinDir) {
        return ERROR_INVALID_DATA;
    }

    //
    // Make munged dir
    //
    StringCopyA (ProfilePathMunged, NewWinDir);
    StringCopyA (AppendPathWack (ProfilePathMunged), _mbsinc (EndOfWinDir));

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvddetect\dvddetect.h ===
// DvdCheck.h : Determine if DVD exists on a system.  Differentiate between MCI and DirectShow Solutions
// 
//	Last Modified 3/31/99 by Steve Rowe (strowe)
//

#include <windows.h>
// #include <ostream.h>

//
//  DVD detection specific code
//

enum DecoderVendor
{
    vendor_Unknown,
    vendor_MediaMatics,
    vendor_CyberLink,
    vendor_MGI,
    vendor_Ravisent,
    vendor_NEC,
    vendor_Intervideo,
};

class DVDResult
{
public:
            DVDResult();
            ~DVDResult();

    void    SetFound( bool state );
    void    SetVersion( const UINT64 Version );
    void    SetCompanyName( const TCHAR* pCompanyName );
    void    SetName( const TCHAR* pName );
    void    SetCRC( DWORD crc32 );

    bool    Found() const               { return m_fFound; }
    UINT64  GetVersion() const          { return m_Version; }
    DWORD   GetCRC() const              { return m_dwCRC; }
    const TCHAR* GetName() const        { return m_pName; }
    const TCHAR* GetCompanyName() const { return m_pCompanyName; }
    DecoderVendor GetVendor() const;
    bool    ShouldUpgrade( bool fWillBe9xUpgrade = false ) const;

protected:
    bool    m_fFound;
    DWORD   m_dwCRC;
    UINT64  m_Version;
    TCHAR*  m_pName;
    TCHAR*  m_pCompanyName;
    DecoderVendor   m_Vendor;
};

/*
	Usage for DetectDVD is as follows:

		DetectDVD will be E_UNEXPECTED if something goes wrong. 
*/
struct DVDDetectBuffer
{
	DVDResult   mci, sw, hw;
    DVDResult*  Detect();
    HRESULT     DetectAll();
};

namespace DVDDetectSetupRun
{
    bool    Add();
    bool    Remove();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvdupgrd\dvdupgrd.cpp ===
// DVDUpgrd.cpp : Defines the entry point for the  application.
//
#define ASSERTERROR(x)  ASSERT( ! x )

#include <windows.h>
#include <streams.h>

#include "..\dvddetect\DVDDetect.h"

// for IShellLink
#include <wininet.h> // must include before shlobj to get IActiveDesktop
#include <shlobj.h>

#include <Userenv.h>
#include <intshcut.h>
#include <shellapi.h>

#define DBGBOX(x)
static TCHAR* Append( TCHAR* pOut, const TCHAR* pString )
{
    lstrcat( pOut, pString );
    return pOut + lstrlen(pOut);
}

static TCHAR* Print(TCHAR* pOut,  const DVDResult& result)
{
    UINT64 ullVersion = result.GetVersion();
    wsprintf(  pOut,
                TEXT("Name:\"%s\"\n Company Name:\"%s\"\n Version: %d.%d.%d.%d \n CRC32: 0x%08x\n"), 
                result.GetName(),
                result.GetCompanyName(),
                WORD(ullVersion>>48),
                WORD(ullVersion>>32),
                WORD(ullVersion>>16),
                WORD(ullVersion>>0),
                result.GetCRC()
    );
    return pOut + lstrlen(pOut );
}

//
//  Generic utility functions
//

static bool AreEquivalent( const char* pStr1, const char* pStr2 )
{
    return lstrcmpiA( pStr1, pStr2 ) ==0;
}

static bool AreEquivalent( const WCHAR* pStr1, const WCHAR* pStr2 )
{
    return lstrcmpiW( pStr1, pStr2 ) ==0;
}



static bool IsUserMemberOf( DWORD domainAlias )
{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    bool b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(false);
    }

    b = false;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = reinterpret_cast<PTOKEN_GROUPS>(new BYTE[BytesRequired]) )
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        if( AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                domainAlias,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                ))

        {

            //
            // See if the user has the administrator group.
            //
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = true;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        delete [] (BYTE *)Groups;
    }

    CloseHandle(Token);

    return(b);
}

// copied from ntfs\fu\utility
static bool IsUserAdmin()
{
    return IsUserMemberOf( DOMAIN_ALIAS_RID_ADMINS);
}

static bool IsUserPowerUser()
{
    return IsUserMemberOf( DOMAIN_ALIAS_RID_POWER_USERS );
}

static HRESULT CreateShortcutToURL(LPCTSTR pszURL, LPCTSTR pszLinkFile)
{
    CoInitialize(NULL);
    HRESULT hRes;
    IUniformResourceLocator *pURL = NULL;

    // Create an IUniformResourceLocator object
    hRes = CoCreateInstance (CLSID_InternetShortcut, NULL, 
    CLSCTX_INPROC_SERVER, IID_IUniformResourceLocator, (LPVOID*) &pURL);
    if (SUCCEEDED(hRes)) {
        IPersistFile *pPF = NULL;

        hRes = pURL->SetURL(pszURL, IURL_SETURL_FL_USE_DEFAULT_PROTOCOL );

        if (SUCCEEDED(hRes)) {
            hRes = pURL->QueryInterface (IID_IPersistFile, (void **)&pPF);
            if (SUCCEEDED(hRes)) {   
#ifndef UNICODE
                WCHAR wsz [MAX_PATH];   // buffer for Unicode string

                // Ensure that the string consists of ANSI characters.
                MultiByteToWideChar (CP_ACP, 0, pszLinkFile, -1, wsz, MAX_PATH);

                // Save the shortcut via the IPersistFile::Save member function.
                hRes = pPF->Save (wsz, TRUE);
#else
                hRes = pPF->Save (pszLinkFile, TRUE);
#endif

                // Release the pointer to IPersistFile.
                pPF->Release ();
            }
        }
        // Release the pointer to IUniformResourceLocator
        pURL->Release ();
    }
    CoUninitialize();
    return hRes;
} 

static bool IsAlphaNum( TCHAR t )
{
    return ( TEXT('a') <= t && t<= TEXT('z')) ||
            ( TEXT('A') <= t && t<= TEXT('Z')) ||
            ( TEXT('0') <= t && t<= TEXT('9'));
}

void AlphaNumStrCpy( TCHAR* pOut, const TCHAR* pIn )
{
    while( *pIn ) {
        if( IsAlphaNum(*pIn)) {
            *pOut++ = *pIn;
        } else {
            *pOut++ = TEXT('_');
        }
        pIn++;
    }
    *pOut=TEXT('\0');
}

// Company:    MGI Software Corp. 
// URL:  http://www.dvdmax.com/updates/
// 
// Company: Ravisent Technologies
// URL: http://www.ravisentdirect.com/upgrade/dvdup.html
// 
// Company: CyberLink Corp.
// URL: http://www.cyberlink.com.tw/english/download/download.asp#upgrade
// 
// Company: National Semiconductor Corporation 
// URL: http://www.national.com/appinfo/dvd/support/msft/
// 
// Company: InterVideo, Inc.
// URL: http:/www.intervideo.com/products/custom/ms/whistler/upgrade.html
// 

static void CreateRedirectorString( TCHAR* pWebsite, const DVDResult& result )
{
    TCHAR filteredName[2000];
    AlphaNumStrCpy( filteredName, result.GetCompanyName() );

    // Generate extended information for our redirector site
    DecoderVendor vendor = result.GetVendor();
    TCHAR pQuery[1000];
    wsprintf( pQuery, TEXT("vendorid=%d&version=%08x%08x&crc=%08x&company=%s"),
        vendor,
        DWORD(result.GetVersion()>>32), DWORD(result.GetVersion() ),
        result.GetCRC(),
        filteredName);

    switch( vendor ) {
    case vendor_MediaMatics:
        wsprintf( pWebsite, TEXT("www.national.com/appinfo/dvd/support/msft"));
        break;
    case vendor_Intervideo:
        wsprintf( pWebsite, TEXT("www.intervideo.com/products/custom/ms/whistler/upgrade.html") );
        break;
    case vendor_CyberLink:
        wsprintf( pWebsite, TEXT("www.cyberlink.com.tw/english/download/download.asp#upgrade") );
        break;
    case vendor_Ravisent:
        wsprintf( pWebsite, TEXT("www.ravisentdirect.com/upgrade/dvdup.htm") );
        break;
    case vendor_MGI:
        wsprintf( pWebsite, TEXT("www.dvdmax.com/updates") );
        break;
    default:
        wsprintf( pWebsite, TEXT("windowsupdate.microsoft.com/dvdupgrade.asp?%s"), pQuery );
        break;
    }
}

static bool LaunchURL( const TCHAR* pURL )
{
    ULONG uRC = (ULONG)(ULONG_PTR) ShellExecute(NULL, TEXT("open"), pURL, NULL, NULL, SW_SHOWNORMAL);

    if ( uRC <= 32 ) {
        return false;
    } else {
        return true;
    }
}

static bool CreateDesktopShortcut( const DVDResult& result )
{
    TCHAR website[1000];
    CreateRedirectorString( website, result );

    TCHAR path[MAX_PATH];
    DWORD dwLen=sizeof(path);
    if( GetAllUsersProfileDirectory( path, &dwLen )) {
        lstrcat( path, TEXT("\\desktop\\Upgrade DVD Decoder.url"));
        TCHAR url[1000];
        wsprintf( url, TEXT("http://%s"), website );
        HRESULT hres = CreateShortcutToURL( url, path );
        return SUCCEEDED(hres);
    } else {
        return false;
    }
}

static void LaunchUI( const DVDResult& result )
{
    TCHAR website[1000];
    CreateRedirectorString( website, result );
#if 0
    switch( MessageBoxW( NULL,
        L"Windows has detected an incompatible software DVD decoder.\n\n"
        L"Would you like to upgrade your decoder at this time ?\n\n"
        L"Select YES to download an upgrade\n"
        L"Select NO to have Windows create a desktop shortcut so that you can upgrade later",
        TEXT("DVD Decoder upgrade"),
        MB_YESNO ))
    {
        case IDYES:
            if(!LaunchURL( website ) ) {
                MessageBox( NULL, TEXT("Could not reach internet site.  A shortcut has been created for you to try again later"),
                    NULL, MB_OK );
            }
            break;

        case IDNO:
            CreateDesktopShortcut( result );
            DVDDetectSetupRun::Remove();
            break;

        default:
            break;
    }
#else
    TCHAR url[1000];
    wsprintf( url, TEXT("HCP://system/DVDUpgrd/dvdupgrd.htm?website=%s"), website);
    LaunchURL( url );
#endif
}

static void DetectForUpgrade( bool fForceUpgrade )
{
    DVDDetectBuffer buffer;
    const DVDResult* pResult = buffer.Detect();
    if( pResult ) {
        const DVDResult& result = *pResult;
        // map company name groups 
        bool fShouldUpgrade = (fForceUpgrade || result.ShouldUpgrade() );
        if(  fShouldUpgrade && (IsUserAdmin() || IsUserPowerUser()) )
        {
            LaunchUI( result );

        }
        if(!fShouldUpgrade ) {
            // if they don't need to upgrade (sounds like we're running after an upgrade)
            // 
            DVDDetectSetupRun::Remove();
        }
    }
}

static void DetectForSetup( bool fWillBeUpgrade )
{
    DVDDetectBuffer buffer;
    const DVDResult* pResult = buffer.Detect();
    if( pResult ) {
        const DVDResult& result = *pResult;
        bool fResult = result.ShouldUpgrade( fWillBeUpgrade );

        if( fResult ) {
            DBGBOX(MessageBox( NULL, TEXT("DetectDVDForSetup = true, add to setup run"), NULL, MB_OK ));
            DVDDetectSetupRun::Add();
        } else {
            DBGBOX(MessageBox( NULL, TEXT("DetectDVDForSetup = false, not added to setup run"), NULL, MB_OK ));
        }
    } else {
        DBGBOX(MessageBox( NULL, TEXT("DetectDVDForSetup = no decoder detected"), NULL, MB_OK ));
//__asm  int 3
        const DVDResult* pResult2 = buffer.Detect();
    }
}

static void DetectForRemove()
{
    DVDDetectBuffer buffer;
    const DVDResult* pResult = buffer.Detect();
    if( pResult ) {
        const DVDResult& result = *pResult;
        // Allows create it since we don't know the 9x info anymore
        // and this only comes from the PCHealth UI's method
        // if( result.ShouldUpgrade())
        CreateDesktopShortcut( result );
        DVDDetectSetupRun::Remove();
    }
}

static void DetectCurrent()
{
    DVDDetectBuffer buffer;
    TCHAR out[1024];
    out[0]=TEXT('\0');
	if(SUCCEEDED(buffer.DetectAll()))
    {
        TCHAR* pOut=out;

        if( buffer.mci.Found()) {
            pOut = Append(pOut, TEXT("\nMCI:\n"));
            pOut = Print(pOut, buffer.mci);
        }
        if( buffer.hw.Found()) {
            pOut = Append(pOut, TEXT("\nDShow HW:\n" ));
            pOut = Print(pOut, buffer.hw);
        }
        if( buffer.sw.Found()) {
            pOut = Append(pOut, TEXT("\nDShow SW:\n" ));
            pOut = Print(pOut, buffer.sw);
        }
        if( pOut == out ) {
            pOut = Append( pOut, TEXT("No decoders found"));
        }
    } else {
        Append( out, TEXT("DvdCheck Failed\n") );
    }
    OutputDebugString( out );
    MessageBox( NULL, out, TEXT("Detected DVD decoders"), MB_OK );
}

extern "C" BOOL IsDvdPresent (VOID);

int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
{
    if( lpCmdLine ) {
        if( AreEquivalent( lpCmdLine, "/setup") ) {
           DetectForSetup( false );
        } else if( AreEquivalent( lpCmdLine, "/setup98") ) {
           DetectForSetup( true );
        } else if( AreEquivalent( lpCmdLine, "/upgrade" ) ) {
           DetectForUpgrade( false );
        } else if( AreEquivalent( lpCmdLine, "/forceupgrade" ) ) {
           DetectForUpgrade( true );
        } else if( AreEquivalent( lpCmdLine, "/remove" ) ) {
           DetectForRemove();
        } else if( AreEquivalent( lpCmdLine, "/detect" ) ) {
           DetectCurrent();
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\dvdcheck\dvddetect\dvddetect.cpp ===
//  DvdCheck.cpp : Determine if DVD exists on a system.  Differentiate between MCI and DirectShow Solutions
// 
//	Modified 3/31/99 by Steve Rowe (strowe)
//  Modified 2000/10/11 by Glenn Evans (glenne) to hunt down version & company names & MCI solutions
//

#include <streams.h>

#include <windows.h>
#include <initguid.h>
#include <uuids.h>
#include "DvdDetect.h"
#include "crc32.h"

DVDResult::DVDResult()
: m_pName( NULL )
, m_pCompanyName( NULL )
, m_Version( 0 )
, m_fFound( false )
, m_dwCRC( 0 )
{
    SetName( TEXT("") );
    SetCompanyName( TEXT("") );
}

DVDResult::~DVDResult()
{
    delete [] m_pName;
    delete [] m_pCompanyName;
}

static TCHAR* CloneString( const TCHAR* pStr )
{
    if( pStr ) {
        TCHAR* pNew = new TCHAR[ lstrlen( pStr ) +1 ];
        if( pNew ) {
            lstrcpy( pNew, pStr );
            return pNew;
        }
    }
    return NULL;
}

void DVDResult::SetVersion( UINT64 version)
{
    m_Version = version;
}

void DVDResult::SetCRC( DWORD CRC)
{
    m_dwCRC = CRC;
}

void DVDResult::SetFound( bool fFound)
{
    m_fFound = fFound;
}

void DVDResult::SetName( const TCHAR* pName )
{
    delete [] m_pName;
    m_pName = CloneString( pName );
}

void DVDResult::SetCompanyName( const TCHAR* pName )
{
    delete [] m_pCompanyName;
    m_pCompanyName = CloneString( pName );
}

// NOTE:  strmiids.lib is necessary for this to compile.

// This is the KSProxy GUID.  
DEFINE_GUID(DVD_KSPROXY, 0x17CCA71BL, 0xECD7, 0x11D0, 0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 
			0x31, 0x96);


//
//  More or less lifted from the w2k SFP code
//
struct LANGANDCODEPAGE {
  WORD wLanguage;
  WORD wCodePage;
};

static HRESULT GetFileVersion (const TCHAR* pszFile, // file
                       DVDResult& result
                       )
{
    DWORD               dwSize, dwHandle;
    VS_FIXEDFILEINFO    *pFixedVersionInfo;
    DWORD               dwVersionInfoSize;
    DWORD               dwReturnCode;

    dwSize = GetFileVersionInfoSize( const_cast<TCHAR *>(pszFile), &dwHandle);

    HRESULT hr = S_OK;

    // .txt and .inf, etc files might not have versions
    if( dwSize == 0 )
    {
        dwReturnCode = GetLastError();
        hr = E_FAIL;
    } else {
        LPVOID pVersionInfo= new BYTE [dwSize];

        if( NULL == pVersionInfo) {
            hr = E_OUTOFMEMORY;
        } else {
            if( !GetFileVersionInfo( const_cast<TCHAR *>(pszFile), dwHandle, dwSize, pVersionInfo ) ) {
                dwReturnCode = GetLastError();
                DbgLog((LOG_ERROR, 1,  TEXT("Error in GetFileVersionInfo for %s. ec=%d"),
                           pszFile, dwReturnCode));
                hr = E_FAIL;
            } else {
                if( !VerQueryValue( pVersionInfo,
                        TEXT("\\"), // we need the root block
                        (LPVOID *) &pFixedVersionInfo,
                        (PUINT)  &dwVersionInfoSize ) )
                {
                    dwReturnCode = GetLastError();
                    hr = E_FAIL;
                } else {
                    result.SetVersion( ((UINT64(pFixedVersionInfo->dwFileVersionMS))<<32) + pFixedVersionInfo->dwFileVersionLS);
                }

                // Structure used to store enumerated languages and code pages.


                // Read the list of languages and code pages.
                LANGANDCODEPAGE *lpTranslate;
                UINT cbTranslate;

                if( VerQueryValue(pVersionInfo, 
                              TEXT("\\VarFileInfo\\Translation"),
                              (LPVOID*)&lpTranslate,
                              &cbTranslate) )
				{

					// Read the file description for each language and code page.

					for( DWORD i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++ )
					{
						TCHAR SubBlock[512];
						// Retrieve file description for language and code page "i". 
						TCHAR* lpBuffer;
						UINT dwBytes;
						wsprintf( SubBlock, 
								TEXT("\\StringFileInfo\\%04x%04x\\CompanyName"),
								lpTranslate[i].wLanguage,
								lpTranslate[i].wCodePage);


						if( VerQueryValue(pVersionInfo, 
									SubBlock, 
									(VOID **)&lpBuffer, 
									&dwBytes) )
						{
							result.SetCompanyName( lpBuffer );
						}
					}
				}
            }
            delete [] pVersionInfo;
        }
    }
    return hr;
}

static bool EndsIn(  const TCHAR* pStr, const TCHAR* pExtension )
{
    int iExtLen = lstrlen( pExtension );
    int iStrLen = lstrlen( pStr );
    if( iStrLen >= iExtLen ) {
        return lstrcmp( &pStr[iStrLen - iExtLen], pExtension ) == 0;
    } else {
        return false;
    }
}

#define MAKE_VER_NUM( v1, v2, v3, v4 ) (((UINT64(v1) << 16 | (v2) )<<16 | (v3) ) << 16 | (v4) )

static void StrCpy( TCHAR* pDest, WCHAR* pSrc, int iDestSize )
{
#ifdef UNICODE
    lstrcpyn(pDest, pSrc, iDestSize );
#else
    WideCharToMultiByte(
        CP_ACP,
        0,                      // flags
        pSrc,              // src
        -1,                     // cch
        pDest,                 // dest
        iDestSize,                 // cb
        0,                      // lpDefaultChar
        0);                     // lpUsedDefaultChar   
    
#endif
}

static HRESULT GetFilenameFromCLSID( const VARIANT& varFilterClsid, TCHAR szFilename[ MAX_PATH ] )
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[512];
    TCHAR szQuery[512];

    // Convert BSTR to string and free variant storage
    StrCpy( szQuery, varFilterClsid.bstrVal, sizeof( szQuery )/ sizeof( szQuery[0]) );
    SysFreeString(varFilterClsid.bstrVal);

    // Create key name for reading filename registry
    wsprintf(szKey, TEXT("Software\\Classes\\CLSID\\%s\\InprocServer32\0"),
             szQuery);

    // Variables needed for registry query
    HKEY hkeyFilter=0;
    DWORD dwSize=MAX_PATH;
    int rc=0;

    // Open the CLSID key that contains information about the filter
    rc = RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hkeyFilter);
    if (rc == ERROR_SUCCESS)
    {
        rc = RegQueryValueEx(hkeyFilter, NULL,  // Read (Default) value
                             NULL, NULL, (BYTE *)szFilename, &dwSize);

        if (rc == ERROR_SUCCESS)
        {
            hr = S_OK;
        }
        rc = RegCloseKey(hkeyFilter);
    }
    return hr;
}

static const TCHAR* FilenameFromPathname( const TCHAR* pStr )
{
    const TCHAR* pSlash=0;
    const TCHAR* pOrig = pStr;
    while( *pStr ) {
        if( *pStr == TEXT('\\') ) {
            pSlash = pStr;
        }
        pStr++;
    }
    if( pSlash ) {
        return pSlash +1;
    } else {
        return pOrig;
    }
}

static bool GetFileLength( const TCHAR* pszPathname, ULONGLONG* pullFileSize )
{
    WIN32_FIND_DATA wInfo;

    HANDLE hInfo = FindFirstFile( pszPathname, &wInfo );
    FindClose(hInfo);
    if (hInfo!=INVALID_HANDLE_VALUE) {
        if( pullFileSize ) {
            *pullFileSize = (ULONGLONG(wInfo.nFileSizeHigh) << 32) | wInfo.nFileSizeLow;
        }
        return true;
    } else {
        if( pullFileSize ) {
            *pullFileSize = 0;
        }
        return false;
    }
}

static DWORD CRCFromFile( const TCHAR* pFile )
{
    ULONGLONG length;
    DWORD dwCRC = 0;

    if( GetFileLength( pFile, &length )) {
        BYTE* pBuffer = new BYTE[ULONG(length)];
        if( pBuffer ) {
            HANDLE hFile = ::CreateFile( pFile, 
                  GENERIC_READ, FILE_SHARE_READ, 
                  NULL, OPEN_EXISTING, 
                  FILE_ATTRIBUTE_NORMAL, NULL);
            if( hFile != INVALID_HANDLE_VALUE ) {
                DWORD dwActual;
                if( ReadFile( hFile, pBuffer, ULONG(length),  &dwActual, NULL ) ) {
                    dwCRC=CRC32( pBuffer, ULONG(length));
                }
                CloseHandle( hFile );
            }
            delete [] pBuffer;
        }
    }
    return dwCRC;
}

static HRESULT AddSWFilter( IMoniker* pMon, DVDResult& result )
{
	IPropertyBag *pPropBag;
	HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
	if(SUCCEEDED(hr))
	{
		CLSID filterCLSID;
        HRESULT hrGotFilename=E_FAIL;
        TCHAR szFilename[ MAX_PATH ];

		// open clsid/{filter-clsid} key
		VARIANT varbstrClsid;
		varbstrClsid.vt = VT_BSTR;
		varbstrClsid.bstrVal = 0;
		hr = pPropBag->Read(L"CLSID", &varbstrClsid, 0);
		if(SUCCEEDED(hr)) {
			ASSERT(varbstrClsid.vt == VT_BSTR);
			WCHAR *strFilter = varbstrClsid.bstrVal;

			if (CLSIDFromString(varbstrClsid.bstrVal, &filterCLSID) == S_OK) {
			}
            hrGotFilename = GetFilenameFromCLSID( varbstrClsid, szFilename );

			SysFreeString(varbstrClsid.bstrVal);
		}
    
		pPropBag->Release();   
		
		if ( DVD_KSPROXY == filterCLSID || CLSID_AVIDec == filterCLSID ) {
			; // ignore this filter if it is the AVI Decompressor or KSProxy
        } else  {

            if(  S_OK == hrGotFilename ) {
                HRESULT hres = GetFileVersion( szFilename, result );
                if( S_OK == hres ) {
                    result.SetName( FilenameFromPathname( szFilename ));
                    result.SetFound( true );
                    result.SetCRC( CRCFromFile( szFilename ));
                }
            }
       }
    } else {
		DbgLog((LOG_ERROR, 1, TEXT("ERROR: WARNING: BindToStorage failed"))) ;
		return E_UNEXPECTED;
	}
    return S_OK;
}

static HRESULT AddHWFilter( IMoniker* pMon, DVDResult& result )
{
	IPropertyBag *pPropBag;
	HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
	if(SUCCEEDED(hr))
	{
        result.SetFound( true );

        VARIANT var ;
        var.vt = VT_EMPTY ;
        hr = pPropBag->Read(L"FriendlyName", &var, 0) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 5, TEXT("FriendlyName: %S"), var.bstrVal)) ;

            //
            // We have got a device under the required category. The proxy
            // for it is already instantiated. So add to the list of HW
            // decoders to be used for building the graph.
            //
            TCHAR szName[512];

            // Convert BSTR to string and free variant storage
            StrCpy( szName, var.bstrVal, sizeof( szName )/ sizeof( szName[0]) );

            result.SetName( szName );
            VariantClear(&var) ;
        }
        else
        {
            ASSERT(SUCCEEDED(hr)) ;  // so that we know
            result.SetName( TEXT("generic HW") );
        }    
		pPropBag->Release();   
    } else {
		DbgLog((LOG_ERROR, 1, TEXT("ERROR: WARNING: BindToStorage failed"))) ;
		return E_UNEXPECTED;
	}
    return S_OK;
}


// Check if there are any SW DVD Decoders 
static HRESULT SWCheck(DVDResult& result)
{
	HRESULT hres = S_OK; // result for the function
	HRESULT hr; // temporary result...

	// Create filter mapper to find software decoders
	IFilterMapper2 * pMapper ;    // filter mapper object pointer
    hr = CoCreateInstance(CLSID_FilterMapper2, NULL, CLSCTX_INPROC,
                          IID_IFilterMapper2, (LPVOID *)&pMapper) ;
	if (FAILED(hr) || NULL == pMapper)
	{
        DbgLog((LOG_ERROR, 0, 
			TEXT("ERROR: Couldn't create class FilterMapper for DVD SW Dec category (Error 0x%lx)"), 
			hr)) ;
        ASSERT( !"Can't create filtermapper" );
		return E_UNEXPECTED;
	}

	const UINT NUM_TYPES = 3; // the number of type/subtype pairs

	GUID types[NUM_TYPES * 2];
	types[0] = MEDIATYPE_MPEG2_PES;
	types[1] = MEDIASUBTYPE_MPEG2_VIDEO;
	types[2] = MEDIATYPE_DVD_ENCRYPTED_PACK;
	types[3] = MEDIASUBTYPE_MPEG2_VIDEO;
	types[4] = MEDIATYPE_Video;
	types[5] = MEDIASUBTYPE_MPEG2_VIDEO;

	IEnumMoniker *pEnumMon = NULL ;

	hr = pMapper->EnumMatchingFilters(&pEnumMon, 0, TRUE, MERIT_DO_NOT_USE+1,
		TRUE, NUM_TYPES, types, NULL, NULL, FALSE, TRUE, 0, NULL, 
		NULL, NULL);

	if (FAILED(hr) || NULL == pEnumMon)
	{
		DbgLog((LOG_ERROR, 1, TEXT("ERROR: No matching filter enum found (Error 0x%lx)"), hr)) ;
		pMapper->Release();
		return E_UNEXPECTED;
	}

	// now we check if we have a solution.
	// we ignore the AVI decompressor and KSProxy CLSID's.
	ULONG     ul ;
	IMoniker *pMon = NULL;

	while ( S_OK == pEnumMon->Next(1, &pMon, &ul)  &&  1 == ul)
	{
        hres = AddSWFilter( pMon, result );
    }

	// clean up after ourselves

	if (NULL != pEnumMon) {
		pEnumMon->Release();
	}
	if (NULL != pMapper) {
		pMapper->Release();
	}
    if( hres == S_OK && !result.Found()==false  ) {
        return S_FALSE;
    } else {
        return hres;
    }
}	// end of SWCheck

static TCHAR CharUpper( TCHAR c )
{
    // see the docs on CharUpper, single char if upper  address WORD is NULL
    return (TCHAR) CharUpper( (LPTSTR)c );
}

static void Truncate( TCHAR* pStr, const TCHAR* pTruncateAt )
{
    int iTruncLen = lstrlen( pTruncateAt );
    int iStrLen = lstrlen( pStr );

    for( int i=0; i < iStrLen - iTruncLen; i++ ) {
        for( int j=0; j < iTruncLen; j++ ) {
            if( CharUpper( pStr[i+j] ) != pTruncateAt[j] ) {
                goto NextLoop;
            }
        }
        pStr[i+iTruncLen]=TEXT('\0');
        break;
    NextLoop:
        ;
    }
}

// Determine if there are any MCI DVD devices present
static HRESULT MCICheck( DVDResult& result)
{
	TCHAR lpRetString[255];
	LPCTSTR lpDefault = TEXT("*!*");

	GetPrivateProfileString(
		TEXT("mci"),
		TEXT("DVDVideo"),
		lpDefault,
		lpRetString,
		255,
		TEXT("system.ini") );

    if (lstrcmp(lpRetString, lpDefault)) {// if they are not the same
        // truncate ret string to *.drv
        Truncate( lpRetString, TEXT(".DRV") );

        result.SetName( lpRetString );
        result.SetFound( true );

        // try to hunt down version info
        //
        //  File is in system
        //
        // Create key name for reading filename registry
        TCHAR szPathname[MAX_PATH];
        GetSystemDirectory( szPathname, sizeof(szPathname)/sizeof(szPathname[0]));
        lstrcat( szPathname, TEXT("\\") );
        lstrcat( szPathname, lpRetString );

        HRESULT hres = GetFileVersion( szPathname, result );
        if( S_OK == hres ) {
            result.SetCRC( CRCFromFile( szPathname ));
        } else {
            GetWindowsDirectory( szPathname, sizeof(szPathname)/sizeof(szPathname[0]));
            lstrcat( szPathname, TEXT("\\") );
            lstrcat( szPathname, lpRetString );
            hres = GetFileVersion( szPathname, result );
            if( S_OK == hres ) {
                result.SetCRC( CRCFromFile( szPathname ));
            } else {
                ASSERT(!"Can't find DVD MCI filename");
                return S_FALSE;
            }
        }
        return hres;
    } else {
	    return S_FALSE; // can't really fail this check
    }
} // end of MCICheck

// Check if there are any HW DVD Decoders 
// we use DevEnum to check for DVDHWDecodersCategory 
static HRESULT HWCheck(DVDResult& result)
{	
    ICreateDevEnum *pCreateDevEnum ;
    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
		                  IID_ICreateDevEnum, (void**)&pCreateDevEnum) ;
    if (FAILED(hr) || NULL == pCreateDevEnum)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't create system dev enum (Error 0x%lx)"), hr)) ;
		// need to put some better error handling in here
        return E_UNEXPECTED;
    }

    IEnumMoniker *pEnumMon ;
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_DVDHWDecodersCategory, 
		                                       &pEnumMon, 0) ;
    pCreateDevEnum->Release() ;
	
    if (S_FALSE == hr )
    {
		// should indicate that we have no enumerator but not an error because
		// this means there are no such devices.

        DbgLog((LOG_ERROR, 0, 
			TEXT("WARNING: Couldn't create class enum for DVD HW Dec category (Error 0x%lx)"), 
			hr)) ;
        return S_FALSE;
    }
	if (FAILED(hr) || NULL == pEnumMon)
	{
        DbgLog((LOG_ERROR, 0, 
			TEXT("ERROR: Couldn't create class enum for DVD HW Dec category (Error 0x%lx)"), 
			hr)) ;
		return E_UNEXPECTED;
	}
	
    hr = pEnumMon->Reset() ;

	ULONG     ul ;
    IMoniker *pMon ;

    if (S_OK == pEnumMon->Next(1, &pMon, &ul) && 1 == ul) {
        // Always comes back as WDM generic Filter Proxy (ksproxy.ax)
        hr = AddHWFilter( pMon, result );
	}

	if (NULL != pEnumMon) {
		pEnumMon->Release();
	}

    return result.Found() ? S_OK : S_FALSE;
} // end of HWCheck

HRESULT DVDDetect( DVDResult& mci, DVDResult& sw, DVDResult& hw )
// Primary entry point - will determine if any DVD is present
{
	HRESULT hres = CoInitialize(NULL);
    if( SUCCEEDED( hres )) {
	    //
	    // DSHOW HARDWARE CHECK
	    //
        hres = HWCheck(hw);
        if( SUCCEEDED( hres)) {
	        //
	        // DSHOW SOFTWARE CHECK
	        //
            hres = SWCheck(sw);
            if( SUCCEEDED( hres)) {
	            //
	            // MCI CHECK
	            //
                hres = MCICheck(mci);
            }
        }
	    CoUninitialize();
    } else {
        ASSERT( !"Can't CoInit" );
    }

	return hres;
}



//  Decoder                     exe             CompanyName                     version         crc        
//
// Ravisent 2000                "QIDVDF.AX"     "RAVISENT Technologies Inc."    1.2.0.115   0x786cd58f  
// Ravisent (ATIPlayer)         "QIDVDF.AX"     "Quadrant International, Inc."  1.1.0.37    0x41a24b10
// Intervideo 1.31 (WinDVD)     "IVIVIDEO.AX"   " InterVideo Inc."              1.0.0.1     0xadf3b652  Will have to get version through registry
// Intervideo 2.111 (WinDVD)    "IVIVIDEO.AX"   " InterVideo Inc."              1.0.0.1     0x42b020f8
// Mediamatics     "DVD Express AV Decoder.dll" "Mediamatics, Inc."             5.0.0.15
//                                                                              5.0.0.38
//                                                                              5.0.0.42
//                                                                              5.0.0.45
//                                                                              5.0.0.75    0xdf2fa5df
//                                                                              5.0.0.97
// 
// MGI (SoftDVDMax)             "ZVIDFLT.AX"    "MGI Software Corp."            1.0.0.1     0x4d91884f
//
// MGI Build 00089              "DVDVideo.ax"   "MGI Software Corp."            1.8.6.0     0x6bc2c0d4  can't find setup.ddl in Win2k, causes error in Whistler
// MGI Build 33959              "zvidflt.ax"    "MGI Software Corp."            1.0.0.1     0x0482b35b  works fine in both win2k and whistler
// MGI karaoke                  "zvidflt.ax"    "MGI Software Corp."            1.0.0.1     0x4d91884f  no disk in drive error on whistler, no windows 2000 compatible decoder on win2k
// MGI 4.00.0001                "zvidflt.ax"    "MGI Software Corp."            1.0.0.1     0xd6a7abc3  works fin in both Win2k and Whistler
// MGI 5.0DH                    "zvidflt.ax"    "MGI Software Corp."            1.0.0.1     0xd66f9452  works fine in both win2k and whistler
//
// Zoran 3.07.01                "Softpeg.drv"   ""                              0.0.0.0     0x0         Win2k cant install, whistler says software ot configured to run on your machine
// Zoran 3.25.02                "zvidflt.ax"    "Zoran/CompCore Corp."          1.0.0.0     0x1e44e3d6  DVD Authentication error in whistler, no video or error in win2k
// Zoran 3.25.03                "Softpeg.drv"   ""                              0.0.0.0     0x0         drive not ready or no disk in drive on both win2k and whistler
// Cyberlink PowerDVD 2.50      "clvsd.ax"      "CyberLink Corp."               2.0.0.0     0x964ef3b9  Generates errors in all dshow players in both Win2k and Whistler
// Cyberlink PowerDVD 2.5.5     "clvsd.ax       "CyberLink Corp."		        2.0.0.0		0x964ef3b9  Works fine in Whistler, Win2k there's no video        

#define MAKE_VER_NUM( v1, v2, v3, v4 ) (((UINT64(v1) << 16 | (v2) )<<16 | (v3) ) << 16 | (v4) )

static bool AreEquivalent( const char* pStr1, const char* pStr2 )
{
    return lstrcmpiA( pStr1, pStr2 ) ==0;
}

static bool AreEquivalent( const WCHAR* pStr1, const WCHAR* pStr2 )
{
    return lstrcmpiW( pStr1, pStr2 ) ==0;
}

DecoderVendor DVDResult::GetVendor() const
{
    const TCHAR* pName = GetCompanyName();

    //TBD:     vendor_NEC

    if(         AreEquivalent( pName, TEXT("Mediamatics, Inc.") )) {
        return vendor_MediaMatics;
    } else if(  AreEquivalent( pName, TEXT(" InterVideo Inc.")) ) {
        return vendor_Intervideo;
    } else if(  AreEquivalent( pName, TEXT("RAVISENT Technologies Inc.")) ||
                AreEquivalent( pName, TEXT("Quadrant International, Inc.")) )
    {
        return vendor_Ravisent;
    } else if(  AreEquivalent( pName, TEXT("CyberLink Corp.")) ) {
        return vendor_CyberLink;
    } else if(  AreEquivalent( pName, TEXT("MGI Software Corp.")) ||
                AreEquivalent( pName, TEXT("Zoran/CompCore Corp.")) )
    {
        return vendor_MGI;
    } else {
        return vendor_Unknown;
    }
}

#if 0
//
// only valid AFTER GUI setup and at first boot
//
static bool IsWin9xUpgrade()
{
//    The answer file has the answer (system32\$winnt$.inf)
// [data]
// win9xupgrade=yes
    TCHAR dir[MAX_PATH];
    UINT uiResult = GetWindowsDirectory( dir, sizeof(dir)/sizeof(dir[0]) );
    if( uiResult > 0 ) {
        lstrcat( dir, TEXT("\\system32\\$winnt$.inf") );
        TCHAR buffer[100];
        buffer[0]=0;
        DWORD dwResult = GetPrivateProfileString(
            TEXT("data"), // section name
            TEXT("win9xupgrade"),        // key name
            TEXT(""),        // default string
            buffer, // destination buffer
            sizeof(buffer)/sizeof(buffer[0]),              // size of destination buffer in TCHARS
            dir );// initialization file name

        bool fResult = ( dwResult > 0 ) && AreEquivalent( buffer, TEXT("yes") );

        return fResult;
    } else {
        return true;
    }
}
#endif

static bool DoesAspi32Exist( bool fWillBe9xUpgrade )
{
    if( fWillBe9xUpgrade ) {
        return false;
    } else {
        TCHAR szPathname[MAX_PATH];
        GetWindowsDirectory( szPathname, sizeof(szPathname)/sizeof(szPathname[0]));
        //
        // NOTE: this will fail under Win9x (since its system\drivers) implying there isn't going
        //       to be an aspi32 under Whislter (blocked & deleted).  So under 9x, we return true
        //       and under Whistler their apps only survive if its around.
        //
        lstrcat( szPathname, TEXT("\\system32\\drivers\\aspi32.sys") );
        ULONGLONG ullLength;
        return GetFileLength( szPathname, &ullLength );
    }
}

bool DVDResult::ShouldUpgrade( bool fWillBe9xUpgrade ) const
{
    switch( GetVendor() ) {
    case vendor_MediaMatics:
        return GetVersion() <= MAKE_VER_NUM( 5,1,0,5 ); // TBD: arbitrary right now for debugging purposes

        //        return GetVersion() <= MAKE_VER_NUM( 5,0,0,15 );

    case vendor_Intervideo:
    {
        // so far all versions require aspi32
        if( GetVersion() <= MAKE_VER_NUM(1,0,0,1 )) {
            bool fAspiExists = DoesAspi32Exist(fWillBe9xUpgrade);
            if( !fAspiExists ) {
                return true;
            }
        }
        // all unknown versions are 1.0.0.1
        // We correct the known ones to numbers above that
        switch( GetCRC()) {
            case 0xadf3b652: // 1.31.0.0
                return false;
            case 0x42b020f8: // 2.111.0.0
                return false;
            default:
                return true;
        }
    }
    default:
        return false;
    }
}

DVDResult*  DVDDetectBuffer::Detect()
{
	if(SUCCEEDED(DVDDetect( mci, sw, hw )))
    {
        const DVDResult* pResult;

        if( sw.Found()) {
            return &sw;
        } else  if( mci.Found()) {
            return &mci;
        } else {
            // hardware, so we don't care about the decoder OR the app for now
            return NULL;
        }
    }
    return NULL;
}

HRESULT DVDDetectBuffer::DetectAll()
{
    return DVDDetect( mci, sw, hw );
}

#define RUN_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run")

static bool RegSetRunValue( const TCHAR* pString, const TCHAR* pValue )
{
    HKEY hRunKey;
    LONG lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, RUN_KEY, 0, KEY_SET_VALUE, &hRunKey) ;
    if (ERROR_SUCCESS == lRet) {
        lRet = RegSetValueEx(hRunKey, pString, 0, REG_SZ, (BYTE *)pValue, sizeof(pValue[0])*(lstrlen(pValue)+1) );
        RegCloseKey( hRunKey );
        return ( ERROR_SUCCESS == lRet);
    }
    return false;
}

static bool RegRunDeleteValue( const TCHAR* pString )
{
    HKEY hRunKey;
    LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RUN_KEY, 0, KEY_SET_VALUE, &hRunKey) ;
    if (ERROR_SUCCESS == lRet) {
        lRet = RegDeleteValue( hRunKey, pString ) ;
        // either we nuked it or it didn't exist in the first place, either way its gone
        bool fWorked = ( lRet == ERROR_SUCCESS || lRet == ERROR_FILE_NOT_FOUND );
        ASSERT( fWorked ) ;
        RegCloseKey( hRunKey );
        return fWorked;
    }
    return false;
}

#define DVDUPGRADE_NAME TEXT("DVDUpgrade")
bool DVDDetectSetupRun::Remove()
{
    bool fOk = RegRunDeleteValue( DVDUPGRADE_NAME );
    ASSERT(fOk);
    return fOk;
}

bool DVDDetectSetupRun::Add()
{
    bool fOk;
    fOk = RegSetRunValue( DVDUPGRADE_NAME, TEXT("DVDUpgrd.exe /upgrade"));
    ASSERT(fOk);
    return fOk;
}

extern "C" BOOL
IsDvdPresent (
    VOID
    )
{
    DVDDetectBuffer buffer;
    const DVDResult* pResult = buffer.Detect();
    if( pResult ) {
        const DVDResult& result = *pResult;
        // at this point the $winnt$.inf doesn't exist, so we must assume 
        // that we're bing called from the win95upg
        const bool fInWin9xUpgrade = true;
        return result.ShouldUpgrade(fInWin9xUpgrade);
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\buildinf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    buildinf.h

Abstract:

    Declares the public interface for INF writing routines implemented
    in w95upg\winntsif\buildinf.c.

Author:

    Jim Schmidt (jimschm) 09-Nov-1996

Revision History:

    marcw   19-Jun-1998     More clean up
    marcw   15-Jan-1998     Cleaned up, made winntsif dir
    marcw   08-Jun-1997     Redesigned to use memdb

--*/


#pragma once

BOOL  BuildInf_Entry(IN HINSTANCE hinstDLL, IN DWORD dwReason, IN LPVOID lpv);
BOOL  WriteInfToDisk (IN PCTSTR OutputFile);
BOOL  MergeInf (IN PCTSTR InputFile);
BOOL  MergeMigrationDllInf (IN PCTSTR InputFile);
DWORD WriteInfKey   (PCTSTR Section, PCTSTR szKey, PCTSTR szVal);
DWORD WriteInfKeyEx (PCTSTR Section, PCTSTR szKey, PCTSTR szVal, DWORD ValueSectionId, BOOL EnsureKeyIsUnique);


//
// winntsif.c
//

DWORD BuildWinntSifFile (DWORD Request);
PTSTR GetNeededLangDirs (VOID);
DWORD CreateFileLists (DWORD Request);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\beta.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    beta.h

Abstract:

    Implements logging just for the beta releases.

Author:

    Jim Schmidt (jimschm) 11-Jun-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#define WIN9XUPG_BETA


#define BETA_FAILURE    "Failure"
#define BETA_INFO       "Info"
#define BETA_WARNING    "Warning"

VOID
InitBetaLog (
    BOOL EraseExistingLog
    );

VOID
CloseBetaLog (
    VOID
    );

VOID
SelectBetaLog (
    BOOL UseBetaLog
    );

VOID
_cdecl
BetaMessageA (
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                         // ANSI args
    );

VOID
_cdecl
BetaCondMessageA (
    IN      BOOL Expr,
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                         // ANSI args
    );

VOID
_cdecl
BetaErrorMessageA (
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                         // ANSI args
    );

VOID
_cdecl
BetaMessageW (
    IN      PCSTR AnsiCategory,
    IN      PCSTR AnsiFormatStr,
            ...                         // UNICODE args
    );

VOID
_cdecl
BetaCondMessageW (
    IN      BOOL Expr,
    IN      PCSTR AnsiCategory,
    IN      PCSTR AnsiFormatStr,
            ...                         // UNICODE args
    );

VOID
_cdecl
BetaErrorMessageW (
    IN      PCSTR AnsiCategory,
    IN      PCSTR AnsiFormatStr,
            ...                         // UNICODE args
    );

VOID
BetaCategory (
    IN      PCSTR Category
    );

VOID
BetaLogDirectA (
    IN      PCSTR Text
    );

VOID
BetaLogDirectW (
    IN      PCWSTR Text
    );

VOID
BetaLogLineA (
    IN      PCSTR FormatStr,
            ...                             // ANSI args
    );

VOID
BetaLogLineW (
    IN      PCSTR FormatStr,
            ...                             // UNICODE args
    );

VOID
BetaNoWrapA (
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                             // ANSI args
    );

VOID
BetaNoWrapW (
    IN      PCSTR Category,
    IN      PCSTR FormatStr,
            ...                             // UNICODE args
    );

#define CONFIGLOGA(x)       SelectBetaLog(FALSE);BetaLogLineA x;SelectBetaLog(TRUE)
#define CONFIGLOGW(x)       SelectBetaLog(FALSE);BetaLogLineW x;SelectBetaLog(TRUE)

#define BETAMSGA(x)         BetaMessageA x
#define BETAMSGW(x)         BetaMessageW x

#define BETAMSGA_IF(x)      BetaCondMessageA x
#define BETAMSGW_IF(x)      BetaCondMessageW x

#define BETAERRORA(x)       BetaErrorMessageA x
#define BETAERRORW(x)       BetaErrorMessageW x

#define ELSE_BETAMSGA(x)    else BetaMessageA x
#define ELSE_BETAMSGW(x)    else BetaMessageW x

#define ELSE_BETAMSGA_IF(x) else BetaCondMessageA x
#define ELSE_BETAMSGW_IF(x) else BetaCondMessageW x

#define BETAMSG_CATEGORY(x) BetaCategory x

#define BETAMSG_DIRECTA(x)  BetaLogDirectA x
#define BETAMSG_DIRECTW(x)  BetaLogDirectW x

#define BETAMSG_LINEA(x)    BetaLogLineA x
#define BETAMSG_LINEW(x)    BetaLogLineW x

#define BETAMSG_NOWRAPA(x)  BetaNoWrapA x
#define BETAMSG_NOWRAPW(x)  BetaNoWrapW x

#ifdef UNICODE

#define BETAMSG             BETAMSGW
#define BETAMSG_IF          BETAMSGW_IF
#define BETAERROR           BETAERRORW
#define ELSE_BETAMSG        ELSE_BETAMSGW
#define ELSE_BETAMSG_IF     ELSE_BETAMSGW_IF
#define BETAMSG_DIRECT      BETAMSG_DIRECTW
#define BETAMSG_LINE        BETAMSG_LINEW
#define BETAMSG_NOWRAP      BETAMSG_NOWRAPW

#define CONFIGLOG           CONFIGLOGW

#else

#define BETAMSG             BETAMSGA
#define BETAMSG_IF          BETAMSGA_IF
#define BETAERROR           BETAERRORA
#define ELSE_BETAMSG        ELSE_BETAMSGA
#define ELSE_BETAMSG_IF     ELSE_BETAMSGA_IF
#define BETAMSG_DIRECT      BETAMSG_DIRECTA
#define BETAMSG_LINE        BETAMSG_LINEA
#define BETAMSG_NOWRAP      BETAMSG_NOWRAPA

#define CONFIGLOG           CONFIGLOGA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\config.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    config.h

Abstract:

    Declares interfaces for configuration of:

    - User preferences (command line and unattend options)
    - The Win9x Upgrade's directories

    See implementation in w95upg\init9x\config.c.

Author:

    Marc R. Whitten (marcw) 26-May-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

BOOL Cfg_InitializeUserOptions(VOID);
BOOL Cfg_CreateWorkDirectories(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\chartype.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    chartype.h

Abstract:

    Declares macros and types for the multi-byte and Unicode
    character environment that the Win9x upgrade code requires.
    The following macros are defined:

    - Make sure UNICODE is defined if _UNICODE is defined
    - Make the type MBCHAR that holds both bytes of a multi-byte char
    - Make CHARTYPE point to wint_t for UNICODE and MBCHAR for not
      UNICODE

Author:

    Jim Schmidt (jimschm) 10-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#if defined _UNICODE && !defined UNICODE
#define UNICODE
#endif

#ifdef UNICODE

//
// If UNICODE, define _UNICODE for tchar.h, and make
// a type to represent a single character.
//

#ifndef _UNICODE
#define _UNICODE
#endif

#define CHARTYPE wint_t

#pragma message ("UNICODE version being built")

#else       // ifdef UNICODE

//
// If not UNICODE, we must assume multibyte characters.
// Define _MBCS for tchar.h, and make a type that can
// hold a complete multibyte character.
//

#ifndef _MBCS
#define _MBCS
#endif
#define CHARTYPE unsigned int

#pragma message ("MBCS version being built")

#endif      // ifdef UNICODE, else

#define MBCHAR unsigned int

#include <tchar.h>

//
// Constant pointer to a void
//

#ifndef PCVOID
typedef const void * PCVOID;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\common.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    common.h

Abstract:

    Declares types and interfaces common between w95upg.dll (the
    Win9x side of the upgrade), and w95upgnt.dll (the NT side of
    the upgrade).

Author:

    Calin Negreanu (calinn) 23-Jun-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

// posible values for Boot16 option
typedef enum {
    BOOT16_AUTOMATIC,
    BOOT16_YES,
    BOOT16_NO
} BOOT16_OPTIONS;

#define PROGID_SUPPRESSED   0
#define PROGID_LOSTDEFAULT  1


#ifdef PRERELEASE

#define AUTOSTRESS_PRIVATE          0x0001
#define AUTOSTRESS_MANUAL_TESTS     0x0002

#endif

#define MAX_GUID        128

typedef struct {
    //
    // Caller-specified members
    //

    PCSTR DetectPattern;
    PCSTR SearchList;           OPTIONAL
    PCSTR ReplaceWith;          OPTIONAL
    BOOL UpdatePath;

    //
    // Work members, caller must zero them
    //

    PVOID DetectPatternStruct;

} TOKENARG, *PTOKENARG;

typedef struct {
    UINT ArgCount;
    PCSTR CharsToIgnore;        OPTIONAL
    BOOL SelfRelative;
    BOOL UrlMode;
    TOKENARG Args[];
} TOKENSET, *PTOKENSET;

#define TOKEN_BASE_OFFSET       1000

//
// Flags for MEMDB_CATEGORY_STATE\MEMDB_ITEM_ADMIN_PASSWORD\<password> = <DWORD>
//
#define PASSWORD_ATTR_DEFAULT                   0x0000
#define PASSWORD_ATTR_RANDOM                    0x0001
#define PASSWORD_ATTR_ENCRYPTED                 0x0002
#define PASSWORD_ATTR_DONT_CHANGE_IF_EXIST      0x0004

//
// ARRAYSIZE (used to be borrowed from spapip.h)
//
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\cablib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.h

Abstract:

    APIs to manipulate CAB files.

Author:

    20-Oct-1999 Calin Negreanu (calinn)

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef BOOL(WINAPI CABGETCABINETNAMESA)(
                        IN      PCSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESA *PCABGETCABINETNAMESA;

typedef BOOL(WINAPI CABGETCABINETNAMESW)(
                        IN      PCWSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCWSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCWSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESW *PCABGETCABINETNAMESW;

typedef BOOL(WINAPI CABNOTIFICATIONA)(
                        IN      PCSTR FileName
                        );
typedef CABNOTIFICATIONA *PCABNOTIFICATIONA;

typedef BOOL(WINAPI CABNOTIFICATIONW)(
                        IN      PCWSTR FileName
                        );
typedef CABNOTIFICATIONW *PCABNOTIFICATIONW;

typedef PVOID CCABHANDLE;

typedef PVOID OCABHANDLE;

//
// API
//

CCABHANDLE
CabCreateCabinetA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    );

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    );

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetA(h)         CabFlushAndCloseCabinetExA(h,NULL,NULL,NULL,NULL)

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetW(h)         CabFlushAndCloseCabinetExW(h,NULL,NULL,NULL,NULL)

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    );

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    );

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    );

#define CabExtractAllFilesA(h,p) CabExtractAllFilesExA(h,p,NULL)

BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    );

#define CabExtractAllFilesW(h,p) CabExtractAllFilesExW(h,p,NULL)

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    );

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    );

BOOL
CabVerifyCabinet (
    IN      OCABHANDLE CabHandle
    );

//
// Macros
//

#ifdef UNICODE

#define CABGETCABINETNAMES          CABGETCABINETNAMESW
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESW
#define CABNOTIFICATION             CABNOTIFICATIONA
#define PCABNOTIFICATION            PCABNOTIFICATIONA
#define CabCreateCabinet            CabCreateCabinetW
#define CabCreateCabinetEx          CabCreateCabinetExW
#define CabAddFileToCabinet         CabAddFileToCabinetW
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetW
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExW
#define CabOpenCabinet              CabOpenCabinetW
#define CabExtractAllFilesEx        CabExtractAllFilesExW
#define CabExtractAllFiles          CabExtractAllFilesW
#define CabCloseCabinet             CabCloseCabinetW

#else

#define CABGETCABINETNAMES          CABGETCABINETNAMESA
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESA
#define CABNOTIFICATION             CABNOTIFICATIONW
#define PCABNOTIFICATION            PCABNOTIFICATIONW
#define CabCreateCabinet            CabCreateCabinetA
#define CabCreateCabinetEx          CabCreateCabinetExA
#define CabAddFileToCabinet         CabAddFileToCabinetA
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetA
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExA
#define CabOpenCabinet              CabOpenCabinetA
#define CabExtractAllFilesEx        CabExtractAllFilesExA
#define CabExtractAllFiles          CabExtractAllFilesA
#define CabCloseCabinet             CabCloseCabinetA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\dosmig.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dosmig.h

Abstract:

    Declares the interface for the Win9x side of DOS environment
    migration.

Author:

    Marc R. Whitten (marcw) 15-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    TCHAR   FullLine    [MEMDB_MAX];
    TCHAR   Path        [MEMDB_MAX];
    TCHAR   Command     [MEMDB_MAX];
    TCHAR   Arguments   [MEMDB_MAX];
    TCHAR   FullPath    [MEMDB_MAX];
    TCHAR   PathOnNt    [MEMDB_MAX];
    DWORD   StatusOnNt;
} LINESTRUCT, *PLINESTRUCT;


VOID
InitLineStruct (
    OUT PLINESTRUCT LineStruct,
    IN  PTSTR       Line
    );

BOOL
ParseDosFiles (
    VOID
    );



BOOL
WINAPI
DosMig_Entry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );


DWORD
ProcessDosConfigFiles (
    IN      DWORD Request
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\dosmignt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dosmignt.h

Abstract:

    Declares entry points for the NT-side of DOS environment
    migration.  There is a system-wide component and per-user
    component to migration.

Author:

    Marc R. Whitten (marcw) 15-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/

LONG
DosMigNt_System (
    VOID
    );

LONG
DosMigNt_User(
    HKEY UserKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\debug.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Implements macros and declares functions for:

    - Resource allocation tracking
    - Logging
    - Definition of DEBUG

Author:

    Jim Schmidt (jimschm) 01-Jan-1997

Revision History:

    Ovidiu Temereanca (ovidiut) 06-Nov-1998
        Took out log related function declarations and put them in log.h file

--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG

#ifndef DEBUG
#define DEBUG
#endif

#endif

#ifdef DEBUG

#ifndef DBG
#define DBG
#endif

#endif

//
// Debug-only constants
//

#ifdef DEBUG

// This option makes fat, slow binaries
//#define MEMORY_TRACKING

#include <stdarg.h>

typedef enum {
    MERGE_OBJECT,
    POOLMEM_POINTER,
    POOLMEM_POOL,
    INF_HANDLE
} ALLOCTYPE;


VOID InitAllocationTracking (VOID);
VOID FreeAllocationTracking (VOID);
VOID DebugRegisterAllocation (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line);
VOID DebugUnregisterAllocation (ALLOCTYPE Type, PVOID Ptr);
#define ALLOCATION_TRACKING_DEF , PCSTR File, UINT Line
#define ALLOCATION_TRACKING_CALL ,__FILE__,__LINE__
#define ALLOCATION_INLINE_CALL , File, Line

extern PCSTR g_TrackComment;
extern INT g_UseCount;
extern PCSTR g_TrackFile;
extern UINT g_TrackLine;
DWORD SetTrackComment (PCSTR Msg, PCSTR File, UINT Line);
DWORD ClrTrackComment (VOID);
VOID  DisableTrackComment (VOID);
VOID  EnableTrackComment (VOID);
#define SETTRACKCOMMENT(RetType, Msg,File,Line) ((RetType)(SetTrackComment(Msg,File,Line) | (DWORD) (
#define CLRTRACKCOMMENT                         ) | ClrTrackComment()))

#define SETTRACKCOMMENT_VOID(Msg,File,Line)     SetTrackComment(Msg,File,Line), (
#define CLRTRACKCOMMENT_VOID                    ), ClrTrackComment()

#define DISABLETRACKCOMMENT()                   DisableTrackComment()
#define ENABLETRACKCOMMENT()                    EnableTrackComment()

VOID InitLog (BOOL DeleteLog);

//
// Memory debug option
//

#define MemAlloc(heap,flags,size) DebugHeapAlloc(__FILE__,__LINE__,heap,flags,size)
#define MemReAlloc(heap,flags,ptr,size) DebugHeapReAlloc(__FILE__,__LINE__,heap,flags,ptr,size)
#define MemFree(heap,flags,ptr) DebugHeapFree(__FILE__,__LINE__,heap,flags,ptr)
#define MemCheck(heap) DebugHeapCheck(__FILE__,__LINE__,heap)

PVOID DebugHeapAlloc (PCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, DWORD dwSize);
PVOID DebugHeapReAlloc (PCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, PCVOID pMem, DWORD dwSize);
BOOL DebugHeapFree (PCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, PCVOID pMem);
VOID DebugHeapCheck (PCSTR File, DWORD Line, HANDLE hHeap);

void DumpHeapStats ();

#else

//
// No-debug constants
//

#define SETTRACKCOMMENT(RetType,Msg,File,Line)
#define CLRTRACKCOMMENT
#define SETTRACKCOMMENT_VOID(Msg,File,Line)
#define CLRTRACKCOMMENT_VOID
#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define MemAlloc SafeHeapAlloc
#define MemReAlloc SafeHeapReAlloc
#define MemFree(x,y,z) HeapFree(x,y,(LPVOID) z)
#define MemCheck(x)

#define DebugHeapCheck(x,y,z)
#define DumpHeapStats()

#define ALLOCATION_TRACKING_DEF
#define ALLOCATION_TRACKING_CALL
#define ALLOCATION_INLINE_CALL
#define InitAllocationTracking()
#define FreeAllocationTracking()
#define DebugRegisterAllocation(t,p,f,l)
#define DebugUnregisterAllocation(t,p)

#endif

#define MemAllocUninit(size)    MemAlloc(g_hHeap,0,size)
#define MemAllocZeroed(size)    MemAlloc(g_hHeap,HEAP_ZERO_MEMORY,size)
#define FreeMem(ptr)            MemFree(g_hHeap,0,ptr)




#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\drives.h ===
/*++

  Copyright (c) 1996 Microsoft Corporation

Module Name:

  drives.h

Abstract:

  Declares apis for managing accessible drives (Drives that are usable
  both on win9x side an NT side) and for managing the space on those
  drives.

Author:

  Marc R. Whitten (marcw) 03-Jul-1997

--*/

#pragma once

typedef struct _ACCESSIBLE_DRIVE_ENUM {

    PCTSTR                          Drive;
    LONGLONG                        UsableSpace;
    LONGLONG                        MaxUsableSpace;
    struct _ACCESSIBLE_DRIVE_ENUM * Next;
    UINT                            ClusterSize;
    BOOL                            SystemDrive;
    BOOL                            EnumSystemDriveOnly;

} * ACCESSIBLE_DRIVE_ENUM, ** PACCESSIBLE_DRIVE_ENUM;

extern DWORD g_ExclusionValue;
extern TCHAR g_ExclusionValueString[20];
extern BOOL  g_NotEnoughDiskSpace;



BOOL InitAccessibleDrives (VOID);
VOID CleanUpAccessibleDrives (VOID);
BOOL GetFirstAccessibleDriveEx (OUT PACCESSIBLE_DRIVE_ENUM AccessibleDriveEnum, IN BOOL SystemDriveOnly);
BOOL GetNextAccessibleDrive (IN OUT PACCESSIBLE_DRIVE_ENUM AccessibleDriveEnum);

#define GetFirstAccessibleDrive(p)  GetFirstAccessibleDriveEx (p,FALSE)

BOOL IsDriveAccessible (IN PCTSTR DriveString);
BOOL IsDriveExcluded (IN PCTSTR DriveOrPath);
UINT QueryClusterSize (IN PCTSTR DriveString);
LONGLONG QuerySpace (IN PCTSTR DriveString);
BOOL UseSpace (IN PCTSTR   DriveString,IN LONGLONG SpaceToUse);
BOOL FreeSpace (IN PCTSTR   DriveString,IN LONGLONG SpaceToUse);
PCTSTR FindSpace (IN LONGLONG SpaceNeeded);
VOID OutOfSpaceMessage (VOID);
VOID DetermineSpaceUsagePostReport (VOID);
PCTSTR GetNotEnoughSpaceMessage (VOID);

BOOL
OurSetDriveType (
    IN      UINT Drive,
    IN      UINT DriveType
    );

UINT
OurGetDriveType (
    IN      UINT Drive
    );


BOOL
GetUninstallMetrics (
     OUT PINT OutCompressionFactor,         OPTIONAL
     OUT PINT OutBackupImagePadding,        OPTIONAL
     OUT PINT OutBackupDiskPadding          OPTIONAL
     );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\expandit.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    expandit.h

Abstract:

    Routines for expanding CAB files.

Author:

    Marc R. Whitten (marcw) 03-Aug-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

BOOL
ExpandFileA (
    IN PCSTR FullPath,
    IN PCSTR TempDir
    );

ExpandFileW (
    IN PCWSTR FullPath,
    IN PCWSTR TempDir
    );

ExpandAllFilesA (
    IN PCSTR FileDir,
    IN PCSTR TempDir
    );

ExpandAllFilesW (
    IN PCWSTR FileDir,
    IN PCWSTR TempDir
    );

#ifdef UNICODE

#define ExpandFile      ExpandFileW
#define ExpandAllFiles  ExpandAllFilesW

#else

#define ExpandFile      ExpandFileA
#define ExpandAllFiles  ExpandAllFilesA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\dbattrib.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdbp.h

Abstract:

    Header file for implementing attributes

Author:

    Calin Negreanu (calinn) 07-Ian-1998

Revision History:

    Aghajanyan Souren (sourenag) 24-Apr-2001 separated from migdbp.h
	
--*/

typedef struct _MIGDB_ATTRIB {
    INT     AttribIndex;
    UINT    ArgCount;
    PCSTR   Arguments;
    BOOL    NotOperator;
    VOID   *ExtraData;
    struct _MIGDB_ATTRIB *Next;
} MIGDB_ATTRIB, *PMIGDB_ATTRIB;

typedef struct {
    PFILE_HELPER_PARAMS FileParams;
    VOID * ExtraData;
} DBATTRIB_PARAMS, *PDBATTRIB_PARAMS;

//
// Declare the attribute functions prototype
//
typedef BOOL (ATTRIBUTE_PROTOTYPE) (PDBATTRIB_PARAMS AttribParams, PCSTR Args);
typedef ATTRIBUTE_PROTOTYPE * PATTRIBUTE_PROTOTYPE;

PATTRIBUTE_PROTOTYPE
MigDb_GetAttributeAddr (
    IN      INT AttributeIdx
    );

INT
MigDb_GetAttributeIdx (
    IN      PCSTR AttributeStr
    );

UINT
MigDb_GetReqArgCount (
    IN      INT AttributeIndex
    );


PCSTR
MigDb_GetAttributeName (
    IN      INT AttributeIdx
    );

BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    );

PMIGDB_ATTRIB
LoadAttribData (
    IN      PCSTR MultiSzStr, 
    IN      POOLHANDLE hPool
    );

VOID 
FreeAttribData(
    IN      POOLHANDLE hPool, 
    IN      PMIGDB_ATTRIB pData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\file.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    file.h

Abstract:

    Declares interfaces for routines that simplify access to the
    file system.  These include:

    - Dealing with short/long file names on both Win9x and NT in a
      single binary
    - Checking for file existance
    - Forcing creation of a path
    - Packing files on a floppy (for research and data gathering purposes)
    - WriteFileString wrapper to simplify WriteFile of a string

Author:

    Jim Schmidt (jimschm) 13-Feb-1997

Revision History:

    jimschm 21-Jan-1999     Centralized cmd line parser
    marcw   15-May-1998     Packed file enum

--*/


#pragma once

#define INVALID_ATTRIBUTES      0xffffffff

BOOL
IsPathLengthOkA (
    IN      PCSTR FileSpec
    );

BOOL
IsPathLengthOkW (
    IN      PCWSTR FileSpec
    );

BOOL
OurGetLongPathNameA (
    IN      PCSTR ShortPath,
    OUT     PSTR Buffer,
    IN      INT BufferSizeInBytes
    );

BOOL
OurGetLongPathNameW (
    IN      PCWSTR ShortPath,
    OUT     PWSTR Buffer,
    IN      INT BufferSizeInChars
    );

DWORD
OurGetShortPathNameW (
    PCWSTR LongPath,
    PWSTR ShortPath,
    DWORD Size
    );

#define OurGetShortPathNameA    GetShortPathNameA

DWORD
OurGetFullPathNameW (
    PCWSTR FileName,
    DWORD Size,
    PWSTR FullPath,
    PWSTR *FilePtr
    );

#define OurGetFullPathNameA    GetFullPathNameA

BOOL
CopyFileSpecToLongA(
    IN      PCSTR FullFileSpecIn,
    OUT     PSTR OutPath
    );

BOOL
CopyFileSpecToLongW(
    IN      PCWSTR FullFileSpecIn,
    OUT     PWSTR OutPath
    );

BOOL
DoesFileExistExA(
    IN      PCSTR Path,
    OUT     PWIN32_FIND_DATAA FindData  OPTIONAL
    );

#define DoesFileExistA(x) DoesFileExistExA (x, NULL)

BOOL
DoesFileExistExW(
    IN      PCWSTR Path,
    OUT     PWIN32_FIND_DATAW FindData  OPTIONAL
    );

#define DoesFileExistW(x) DoesFileExistExW (x, NULL)

DWORD
MakeSurePathExistsA(
    IN LPCSTR szPath,
    IN BOOL   PathOnly
    );

DWORD
MakeSurePathExistsW(
    IN LPCWSTR szPath,
    IN BOOL    PathOnly
    );




typedef struct tagPACKFILEENUMA {

    CHAR    Identifier[MAX_MBCHAR_PATH];
    DWORD   SizeLow;
    DWORD   SizeHigh;
    HANDLE  Handle;

} PACKFILEENUMA, *PPACKFILEENUMA, PACKFILEENUMW, *PPACKFILEENUMW;




BOOL
PackedFile_AddFileA (
    IN      PCSTR PackFile,
    IN      PCSTR NewFile,
    IN      PCSTR Identifier            OPTIONAL
    );

BOOL
PackedFile_ExtractFileA (
    IN      PCSTR PackFile,
    IN      PCSTR FileIdentifier,
    IN      PCSTR FileName              OPTIONAL
    );

BOOL
PackedFile_EnumFirstA (
    IN      PCSTR PackFile,
    OUT     PPACKFILEENUMA Enum
    );

BOOL
PackedFile_EnumNextA (
    IN      PPACKFILEENUMA Enum
    );

VOID
PackedFile_AbortEnum (
    IN OUT  PPACKFILEENUMA Enum
    );

BOOL
PackedFile_ExtractFileUsingEnumA (
    IN      PPACKFILEENUMA Enum,
    IN      PCSTR FileName              OPTIONAL
    );



//
// The W versions of these functions are not functional...unimplemented.
//
BOOL
PackedFile_AddFileW (
    IN      PCSTR PackFile,
    IN      PCSTR NewFile,
    IN      PCSTR Identifier            OPTIONAL
    );

BOOL
PackedFile_ExtractFileW (
    IN      PCSTR PackFile,
    IN      PCSTR FileIdentifier,
    IN      PCSTR FileName              OPTIONAL
    );

BOOL
PackedFile_EnumFirstW (
    IN      PCSTR PackFile,
    OUT     PPACKFILEENUMA Enum
    );

BOOL
PackedFile_EnumNextW (
    IN      PPACKFILEENUMA Enum
    );

BOOL
PackedFile_ExtractFileUsingEnumW (
    IN      PPACKFILEENUMA Enum,
    IN      PCSTR FileName              OPTIONAL
    );

BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    );

BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    );


typedef struct {
    HANDLE FindHandle;
    WIN32_FIND_DATAA FindData;
    PSTR SavedEndOfFileBuffer;
    PSTR SavedEndOfPattern;
} FIND_DATAA, *PFIND_DATAA;

typedef struct {
    HANDLE FindHandle;
    WIN32_FIND_DATAW FindData;
    PWSTR SavedEndOfFileBuffer;
    PWSTR SavedEndOfPattern;
} FIND_DATAW, *PFIND_DATAW;

#define FILE_ENUM_ALL_LEVELS     0
#define FILE_ENUM_THIS_LEVEL     1

typedef enum {
    TREE_ENUM_INIT,
    TREE_ENUM_BEGIN,
    TREE_ENUM_FILES_BEGIN,
    TREE_ENUM_RETURN_ITEM,
    TREE_ENUM_FILES_NEXT,
    TREE_ENUM_DIRS_BEGIN,
    TREE_ENUM_DIRS_NEXT,
    TREE_ENUM_DIRS_FILTER,
    TREE_ENUM_PUSH,
    TREE_ENUM_POP,
    TREE_ENUM_DONE,
    TREE_ENUM_FAILED,
    TREE_ENUM_CLEANED_UP
} TREE_ENUM_STATE;

typedef struct {
    //
    // Enumerated items
    //

    PCSTR Name;
    PCSTR SubPath;
    PCSTR FullPath;
    PWIN32_FIND_DATAA FindData;
    BOOL Directory;
    UINT Level;
    UINT MaxLevel;

    //
    // Enumeration state -- private
    //

    BOOL EnumDirsFirst;
    BOOL EnumDepthFirst;
    CHAR RootPath[MAX_MBCHAR_PATH];
    UINT RootPathSize;
    CHAR Pattern[MAX_MBCHAR_PATH];
    PSTR EndOfPattern;
    CHAR FilePattern[MAX_MBCHAR_PATH];
    UINT FilePatternSize;
    CHAR FileBuffer[MAX_MBCHAR_PATH];
    PSTR EndOfFileBuffer;
    TREE_ENUM_STATE State;
    GROWBUFFER FindDataArray;
    PFIND_DATAA Current;
} TREE_ENUMA, *PTREE_ENUMA;

typedef struct {
    //
    // Enumerated items
    //

    PCWSTR Name;
    PCWSTR SubPath;
    PCWSTR FullPath;
    PWIN32_FIND_DATAW FindData;
    BOOL Directory;
    UINT Level;
    UINT MaxLevel;

    //
    // Enumeration state -- private
    //

    BOOL EnumDirsFirst;
    BOOL EnumDepthFirst;
    WCHAR RootPath[MAX_PATH * 2];
    UINT RootPathSize;
    WCHAR Pattern[MAX_PATH * 2];
    PWSTR EndOfPattern;
    WCHAR FilePattern[MAX_PATH * 2];
    UINT FilePatternSize;
    WCHAR FileBuffer[MAX_PATH * 2];
    PWSTR EndOfFileBuffer;
    TREE_ENUM_STATE State;
    GROWBUFFER FindDataArray;
    PFIND_DATAW Current;
} TREE_ENUMW, *PTREE_ENUMW;

BOOL
EnumFirstFileInTreeExA (
    OUT     PTREE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern,          OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    );

BOOL
EnumNextFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    );

VOID
AbortEnumFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    );

#define EnumFirstFileInTreeA(ptr, path, pattern, dirfirst)  EnumFirstFileInTreeExA((ptr), (path), (pattern), (dirfirst), FALSE, FILE_ENUM_ALL_LEVELS)


BOOL
EnumFirstFileInTreeExW (
    OUT     PTREE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern,          OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    );

BOOL
EnumNextFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    );

VOID
AbortEnumFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    );

#define EnumFirstFileInTreeW(ptr, path, pattern, dirfirst)  EnumFirstFileInTreeExW((ptr), (path), (pattern), (dirfirst), FALSE, FILE_ENUM_ALL_LEVELS)

VOID
AbortEnumCurrentDirA (
    IN OUT  PTREE_ENUMA EnumPtr
    );

VOID
AbortEnumCurrentDirW (
    IN OUT  PTREE_ENUMW EnumPtr
    );


typedef struct {
    PCSTR FileName;
    PCSTR FullPath;
    BOOL Directory;

    HANDLE Handle;
    CHAR RootPath[MAX_MBCHAR_PATH];
    PSTR EndOfRoot;
    HANDLE Enum;
    WIN32_FIND_DATAA fd;
} FILE_ENUMA, *PFILE_ENUMA;

typedef struct {
    PCWSTR FileName;
    PCWSTR FullPath;
    BOOL Directory;

    HANDLE Handle;
    WCHAR RootPath[MAX_WCHAR_PATH];
    PWSTR EndOfRoot;
    HANDLE Enum;
    WIN32_FIND_DATAW fd;
} FILE_ENUMW, *PFILE_ENUMW;

BOOL
EnumFirstFileA (
    OUT     PFILE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern           OPTIONAL
    );

BOOL
EnumFirstFileW (
    OUT     PFILE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern           OPTIONAL
    );

BOOL
EnumNextFileA (
    IN OUT  PFILE_ENUMA EnumPtr
    );

BOOL
EnumNextFileW (
    IN OUT  PFILE_ENUMW EnumPtr
    );

VOID
AbortFileEnumA (
    IN OUT  PFILE_ENUMA EnumPtr
    );

VOID
AbortFileEnumW (
    IN OUT  PFILE_ENUMW EnumPtr
    );


BOOL
ExtractIconImageFromFileA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,          // OPTIONAL if file is an ICO file
    IN OUT  PGROWBUFFER Buffer
    );

BOOL
ExtractIconImageFromFileW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,          // OPTIONAL if file is an ICO file
    IN OUT  PGROWBUFFER Buffer
    );


BOOL
ExtractIconImageFromFileExA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    );

BOOL
ExtractIconImageFromFileExW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    );


BOOL
WriteIconImageArrayToIcoFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    );

BOOL
WriteIconImageArrayToIcoFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    );


BOOL
WriteIconImageArrayToPeFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCSTR GroupIconId
    );

BOOL
WriteIconImageArrayToPeFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCWSTR GroupIconId
    );


BOOL
WriteIconImageArrayToPeFileExA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER IconImageArray,
    IN      PCSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    );

BOOL
WriteIconImageArrayToPeFileExW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER IconImageArray,
    IN      PCWSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    );


BOOL
WriteIconImageArrayToIcoFileEx (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File
    );


PCSTR
ExtractIconNamesFromFileA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    );

PCWSTR
ExtractIconNamesFromFileW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    );


PCSTR
ExtractIconNamesFromFileExA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    );

PCWSTR
ExtractIconNamesFromFileExW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    );


BOOL
IsFileAnIcoA (
    IN      PCSTR FileInQuestion
    );

BOOL
IsFileAnIcoW (
    IN      PCWSTR FileInQuestion
    );


typedef struct {
    WORD GroupId;
    WORD IconId;
    GROWBUFFER IconImages;
    GROWBUFFER IconList;
    CHAR DestFile[MAX_MBCHAR_PATH];
    HANDLE Module;
    HANDLE Module16;
    CHAR ModuleName[MAX_MBCHAR_PATH];
    HANDLE IcoFile;
    CHAR IcoFileName[MAX_MBCHAR_PATH];
    HANDLE Update;
    CHAR IconImageFileName[MAX_MBCHAR_PATH];
    HANDLE IconImageFile;
    BOOL SaveMode;
    BOOL Error;
} ICON_EXTRACT_CONTEXTA, *PICON_EXTRACT_CONTEXTA;

typedef struct {
    WORD GroupId;
    WORD IconId;
    GROWBUFFER IconImages;
    GROWBUFFER IconList;
    WCHAR DestFile[MAX_WCHAR_PATH];
    HANDLE Module;
    HANDLE Module16;
    WCHAR ModuleName[MAX_WCHAR_PATH];
    HANDLE IcoFile;
    WCHAR IcoFileName[MAX_WCHAR_PATH];
    HANDLE Update;
    WCHAR IconImageFileName[MAX_WCHAR_PATH];
    HANDLE IconImageFile;
    BOOL SaveMode;
    BOOL Error;
} ICON_EXTRACT_CONTEXTW, *PICON_EXTRACT_CONTEXTW;


BOOL
BeginIconExtractionA (
    OUT     PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR DestFile                      OPTIONAL
    );

BOOL
BeginIconExtractionW (
    OUT     PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR DestFile                     OPTIONAL
    );


BOOL
OpenIconImageFileA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileName,
    IN      BOOL SaveMode
    );

BOOL
OpenIconImageFileW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileName,
    IN      BOOL SaveMode
    );

BOOL
CopyIconA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcon,           OPTIONAL
    IN      PCSTR IconId,                       OPTIONAL
    IN      INT IconIndex                       OPTIONAL
    );

BOOL
CopyIconW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcon,          OPTIONAL
    IN      PCWSTR IconId,                      OPTIONAL
    IN      INT IconIndex                       OPTIONAL
    );


BOOL
CopyAllIconsA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcons
    );

BOOL
CopyAllIconsW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcons
    );


BOOL
EndIconExtractionA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context
    );

BOOL
EndIconExtractionW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context
    );



//
// New Executable resource access
//

HANDLE
OpenNeFileA (
    PCSTR FileName
    );

HANDLE
OpenNeFileW (
    PCWSTR FileName
    );

VOID
CloseNeFile (
    HANDLE Handle
    );

//
// Once upon a time ENUMRESTYPEPROC was defined as a TCHAR prototype,
// which was broken.  If ENUMRESTYPEPROCA isn't defined, we'll define
// it.  (NOTE: The current winbase.h has these typedefs.)
//

#ifndef ENUMRESTYPEPROCA

#if 0
typedef BOOL (CALLBACK* ENUMRESTYPEPROCA)(HMODULE hModule, PCSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(HMODULE hModule, PCWSTR lpType, LONG_PTR lParam);

#endif

//
//          to be consistent with winbase.h, the second arg is non-const.  But that's
//          actually a bug in winbase.h.
//

typedef BOOL (CALLBACK* ENUMRESTYPEPROCA)(HMODULE hModule, PSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(HMODULE hModule, PWSTR lpType, LONG_PTR lParam);

//
// These two prototypes are OK
//

typedef BOOL (CALLBACK* ENUMRESNAMEPROCA)(HMODULE hModule, PCSTR lpType,
        PSTR lpName, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCW)(HMODULE hModule, PCWSTR lpType,
        PWSTR lpName, LONG_PTR lParam);

#endif

BOOL
EnumNeResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG lParam
    );

BOOL
EnumNeResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG lParam
    );


BOOL
EnumNeResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG lParam
    );

BOOL
EnumNeResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG lParam
    );




DWORD
SizeofNeResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

DWORD
SizeofNeResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );

PBYTE
FindNeResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

PBYTE
FindNeResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );


#define FindNeResourceA(h,n,t) FindNeResourceExA(h,t,n)
#define FindNeResourceW(h,n,t) FindNeResourceExW(h,t,n)


#pragma pack(push, 1)

#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ
#define IMAGE_NE_SIGNATURE              0x454E      // NE
#define IMAGE_PE_SIGNATURE              0x00004550l // PE00

typedef struct _DOS_HEADER {  // DOS .EXE header
    WORD e_magic;           // Magic number
    WORD e_cblp;            // Bytes on last page of file
    WORD e_cp;              // Pages in file
    WORD e_crlc;            // Relocations
    WORD e_cparhdr;         // Size of header in paragraphs
    WORD e_minalloc;        // Minimum extra paragraphs needed
    WORD e_maxalloc;        // Maximum extra paragraphs needed
    WORD e_ss;              // Initial (relative) SS value
    WORD e_sp;              // Initial SP value
    WORD e_csum;            // Checksum
    WORD e_ip;              // Initial IP value
    WORD e_cs;              // Initial (relative) CS value
    WORD e_lfarlc;          // File address of relocation table
    WORD e_ovno;            // Overlay number
    WORD e_res[4];          // Reserved words
    WORD e_oemid;           // OEM identifier (for e_oeminfo)
    WORD e_oeminfo;         // OEM information; e_oemid specific
    WORD e_res2[10];        // Reserved words
    LONG e_lfanew;          // File address of new exe header
} DOS_HEADER, *PDOS_HEADER;

typedef struct {
    WORD Signature;                             // 00h
    BYTE LinkerVersion;                         // 02h
    BYTE LinkerRevision;                        // 03h
    WORD OffsetToEntryTable;                    // 04h
    WORD LengthOfEntryTable;                    // 06h
    DWORD Reserved;                             // 08h
    WORD Flags;                                 // 0ch
    WORD AutoDataSegment;                       // 0eh
    WORD LocalHeapSize;                         // 10h
    WORD StackSize;                             // 12h
    DWORD EntryAddress;                         // 14h
    DWORD StackAddress;                         // 18h
    WORD SegmentTableEntries;                   // 1ch
    WORD ModuleReferenceTableEntries;           // 1eh
    WORD NonResidentTableSize;                  // 20h
    WORD OffsetToSegmentTable;                  // 22h
    WORD OffsetToResourceTable;                 // 24h
    WORD OffsetToResidentNameTable;             // 26h
    WORD OffsetToModuleReferenceTable;          // 28h
    WORD OffsetToImportedNameTable;             // 2ah
    WORD OffsetToNonResidentNameTable;          // 2ch
    WORD Unused;                                // 2eh
    WORD MovableEntryPoints;                    // 30h
    WORD LogicalSectorShiftCount;               // 32h
    WORD ResourceSegments;                      // 34h
    BYTE TargetOS;                              // 36h
    BYTE AdditionalFlags;                       // 37h
    WORD FastLoadOffset;                        // 38h
    WORD SectorsInFastLoad;                     // 3ah
    WORD Reserved2;                             // 3ch
    WORD WindowsVersion;                        // 3eh
} NE_INFO_BLOCK, *PNE_INFO_BLOCK;


typedef struct {
    WORD Offset;
    WORD Length;
    WORD Flags;
    WORD Id;
    WORD Handle;
    WORD Usage;
} NE_RES_NAMEINFO, *PNE_RES_NAMEINFO;

typedef struct {
    WORD TypeId;
    WORD ResourceCount;
    DWORD Reserved;
    NE_RES_NAMEINFO NameInfo[];
} NE_RES_TYPEINFO, *PNE_RES_TYPEINFO;

#pragma pack(pop)

typedef struct {
    WORD AlignShift;
    GROWLIST TypeInfoArray;
    GROWLIST ResourceNames;
} NE_RESOURCES, *PNE_RESOURCES;


BOOL
LoadNeHeader (
    IN      HANDLE File,
    OUT     PNE_INFO_BLOCK Header
    );

BOOL
LoadNeResources (
    IN      HANDLE File,
    OUT     PNE_RESOURCES Resources
    );

VOID
FreeNeResources (
    PNE_RESOURCES Resources
    );

BOOL
LoadNeIconFromFileA (
    PCSTR FileName,
    INT IconIndex
    );


PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

#define MapFileIntoMemoryA(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExA(FileName,FileHandle,MapHandle,FALSE)
#define MapFileIntoMemoryW(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExW(FileName,FileHandle,MapHandle,FALSE)

BOOL
UnmapFile (
    IN PVOID  FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    );


BOOL
RemoveCompleteDirectoryA (
    IN      PCSTR Dir
    );

BOOL
RemoveCompleteDirectoryW (
    IN      PCWSTR Dir
    );

typedef struct {
    PCSTR OriginalArg;
    PCSTR CleanedUpArg;
    DWORD Attributes;
    BOOL Quoted;
} CMDLINEARGA, *PCMDLINEARGA;

typedef struct {
    PCSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGA Args[];
} CMDLINEA, *PCMDLINEA;

typedef struct {
    PCWSTR OriginalArg;
    PCWSTR CleanedUpArg;
    DWORD Attributes;
    BOOL Quoted;
} CMDLINEARGW, *PCMDLINEARGW;

typedef struct {
    PCWSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGW Args[];
} CMDLINEW, *PCMDLINEW;

PCMDLINEA
ParseCmdLineA (
    IN      PCSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    );

PCMDLINEW
ParseCmdLineW (
    IN      PCWSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    );

BOOL GetFileSizeFromFilePathA(
    IN  PCSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    );

BOOL GetFileSizeFromFilePathW(
    IN  PCWSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    );


#define NUMDRIVELETTERS      26
#define UNKNOWN_DRIVE        '?'

typedef struct {

    CHAR Letter[NUMDRIVELETTERS];
    BOOL ExistsOnSystem[NUMDRIVELETTERS];
    DWORD Type[NUMDRIVELETTERS];                        // Returned from GetDriveType:
                                                        // DRIVE_FIXED, DRIVE_CDROM or DRIVE_REMOVABLE
    CHAR IdentifierString[NUMDRIVELETTERS][MAX_PATH];   // For caller use

} DRIVELETTERSA, *PDRIVELETTERSA;

typedef struct {

    WCHAR Letter[NUMDRIVELETTERS];
    BOOL ExistsOnSystem[NUMDRIVELETTERS];
    DWORD Type[NUMDRIVELETTERS];                        // Returned from GetDriveType:
                                                        // DRIVE_FIXED, DRIVE_CDROM or DRIVE_REMOVABLE
    WCHAR IdentifierString[NUMDRIVELETTERS][MAX_PATH];  // For caller use

} DRIVELETTERSW, *PDRIVELETTERSW;

VOID
InitializeDriveLetterStructureA (
    OUT     PDRIVELETTERSA DriveLetters
    );

VOID
InitializeDriveLetterStructureW (
    OUT     PDRIVELETTERSW DriveLetters
    );

BOOL
GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

BOOL
GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

DWORD
QuietGetFileAttributesA (
    IN      PCSTR FilePath
    );

DWORD
QuietGetFileAttributesW (
    IN      PCWSTR FilePath
    );

BOOL
IsPathOnFixedDriveA (
    IN      PCSTR FileSpec          OPTIONAL
    );

BOOL
IsPathOnFixedDriveW (
    IN      PCWSTR FileSpec         OPTIONAL
    );

DWORD
MakeSureLongPathExistsW (
    IN      PCWSTR Path,
    IN      BOOL PathOnly
    );

DWORD
SetLongPathAttributesW (
    IN      PCWSTR Path,
    IN      DWORD Attributes
    );

DWORD
GetLongPathAttributesW (
    IN      PCWSTR Path
    );

BOOL
DeleteLongPathW (
    IN      PCWSTR Path
    );


BOOL
RemoveLongDirectoryPathW (
    IN      PCWSTR Path
    );


#ifdef UNICODE

#define MakeSureLongPathExists          MakeSureLongPathExistsW
#define SetLongPathAttributes           SetLongPathAttributesW
#define GetLongPathAttributes           GetLongPathAttributesW
#define DeleteLongPath                  DeleteLongPathW
#define RemoveLongDirectoryPath         RemoveLongDirectoryPathW

#define IsPathLengthOk                  IsPathLengthOkW
#define IsPathLengthOkT                 IsPathLengthOkW
#define OurGetLongPathName              OurGetLongPathNameW
#define OurGetShortPathName             OurGetShortPathNameW
#define OurGetFullPathName              OurGetFullPathNameW
#define CopyFileSpecToLong              CopyFileSpecToLongW
#define DoesFileExist                   DoesFileExistW
#define DoesFileExistEx                 DoesFileExistExW
#define MakeSurePathExists              MakeSurePathExistsW
#define PACKFILEENUM                    PACKFILEENUMW
#define PackedFile_ExtractFileUsingEnum PackedFile_ExtractFileUsingEnumW
#define PackedFile_AddFile              PackedFile_AddFileW
#define PackedFile_ExtractFile          PackedFile_ExtractFileW
#define PackedFile_EnumFirst            PackedFile_EnumFirstW
#define PackedFile_EnumNext             PackedFile_EnumNextW
#define WriteFileString                 WriteFileStringW
#define TREE_ENUM                       TREE_ENUMW
#define PTREE_ENUM                      PTREE_ENUMW
#define FILE_ENUM                       FILE_ENUMW
#define PFILE_ENUM                      PFILE_ENUMW
#define EnumFirstFileInTreeEx           EnumFirstFileInTreeExW
#define EnumFirstFileInTree             EnumFirstFileInTreeW
#define EnumNextFileInTree              EnumNextFileInTreeW
#define AbortEnumFileInTree             AbortEnumFileInTreeW
#define AbortEnumCurrentDir             AbortEnumCurrentDirW
#define EnumFirstFile                   EnumFirstFileW
#define EnumNextFile                    EnumNextFileW
#define AbortFileEnum                   AbortFileEnumW

#define ExtractIconImageFromFile        ExtractIconImageFromFileW
#define ExtractIconImageFromFileEx      ExtractIconImageFromFileExW
#define WriteIconImageArrayToIcoFile    WriteIconImageArrayToIcoFileW
#define WriteIconImageArrayToIcoFileEx  WriteIconImageArrayToIcoFileExW
#define WriteIconImageArrayToPeFile     WriteIconImageArrayToPeFileW
#define WriteIconImageArrayToPeFileEx   WriteIconImageArrayToPeFileExW
#define ExtractIconNamesFromFile        ExtractIconNamesFromFileW
#define ExtractIconNamesFromFileEx      ExtractIconNamesFromFileExW
#define IsFileAnIco                     IsFileAnIcoW
#define ICON_EXTRACT_CONTEXT            ICON_EXTRACT_CONTEXTW
#define PICON_EXTRACT_CONTEXT           PICON_EXTRACT_CONTEXTW
#define BeginIconExtraction             BeginIconExtractionW
#define OpenIconImageFile               OpenIconImageFileW
#define CopyIcon                        CopyIconW
#define CopyAllIcons                    CopyAllIconsW
#define EndIconExtraction               EndIconExtractionW

#define OpenNeFile                      OpenNeFileW
#define EnumNeResourceTypes             EnumNeResourceTypesW
#define EnumNeResourceNames             EnumNeResourceNamesW
#define SizeofNeResource                SizeofNeResourceW
#define FindNeResource                  FindNeResourceW
#define FindNeResourceEx                FindNeResourceExW

#define MapFileIntoMemory               MapFileIntoMemoryW
#define MapFileIntoMemoryEx             MapFileIntoMemoryExW

#define RemoveCompleteDirectory         RemoveCompleteDirectoryW

#define CMDLINE                         CMDLINEW
#define CMDLINEARG                      CMDLINEARGW
#define PCMDLINE                        PCMDLINEW
#define PCMDLINEARG                     PCMDLINEARGW
#define ParseCmdLine                    ParseCmdLineW

#define GetFileSizeFromFilePath         GetFileSizeFromFilePathW

#define GetDiskInfo                     GetDiskInfoW
#define GetIntegrityInfo                GetIntegrityInfoW

#define DRIVELETTERS                    DRIVELETTERSW
#define PDRIVELETTERS                   PDRIVELETTERSW
#define InitializeDriveLetterStructure  InitializeDriveLetterStructureW

#define GetDiskFreeSpaceNew             GetDiskFreeSpaceNewW
#define QuietGetFileAttributes          QuietGetFileAttributesW
#define IsPathOnFixedDrive              IsPathOnFixedDriveW

#else

#define IsPathLengthOk                  IsPathLengthOkA
#define IsPathLengthOkT                 IsPathLengthOkA
#define OurGetLongPathName              OurGetLongPathNameA
#define OurGetShortPathName             OurGetShortPathNameA
#define OurGetFullPathName              OurGetFullPathNameA
#define MakeSurePathExists              MakeSurePathExistsA
#define DoesFileExist                   DoesFileExistA
#define DoesFileExistEx                 DoesFileExistExA
#define CopyFileSpecToLong              CopyFileSpecToLongA
#define PACKFILEENUM                    PACKFILEENUMA
#define PackedFile_ExtractFileUsingEnum PackedFile_ExtractFileUsingEnumA
#define PackedFile_AddFile              PackedFile_AddFileA
#define PackedFile_ExtractFile          PackedFile_ExtractFileA
#define PackedFile_EnumFirst            PackedFile_EnumFirstA
#define PackedFile_EnumNext             PackedFile_EnumNextA
#define WriteFileString                 WriteFileStringA
#define TREE_ENUM                       TREE_ENUMA
#define PTREE_ENUM                      PTREE_ENUMA
#define FILE_ENUM                       FILE_ENUMA
#define PFILE_ENUM                      PFILE_ENUMA
#define EnumFirstFileInTreeEx           EnumFirstFileInTreeExA
#define EnumFirstFileInTree             EnumFirstFileInTreeA
#define EnumNextFileInTree              EnumNextFileInTreeA
#define AbortEnumFileInTree             AbortEnumFileInTreeA
#define AbortEnumCurrentDir             AbortEnumCurrentDirA
#define EnumFirstFile                   EnumFirstFileA
#define EnumNextFile                    EnumNextFileA
#define AbortFileEnum                   AbortFileEnumA

#define ExtractIconImageFromFile        ExtractIconImageFromFileA
#define ExtractIconImageFromFileEx      ExtractIconImageFromFileExA
#define WriteIconImageArrayToIcoFile    WriteIconImageArrayToIcoFileA
#define WriteIconImageArrayToIcoFileEx  WriteIconImageArrayToIcoFileExA
#define WriteIconImageArrayToPeFile     WriteIconImageArrayToPeFileA
#define WriteIconImageArrayToPeFileEx   WriteIconImageArrayToPeFileExA
#define ExtractIconNamesFromFile        ExtractIconNamesFromFileA
#define ExtractIconNamesFromFileEx      ExtractIconNamesFromFileExA
#define IsFileAnIco                     IsFileAnIcoA
#define ICON_EXTRACT_CONTEXT            ICON_EXTRACT_CONTEXTA
#define PICON_EXTRACT_CONTEXT           PICON_EXTRACT_CONTEXTA
#define BeginIconExtraction             BeginIconExtractionA
#define OpenIconImageFile               OpenIconImageFileA
#define CopyIcon                        CopyIconA
#define CopyAllIcons                    CopyAllIconsA
#define EndIconExtraction               EndIconExtractionA

#define OpenNeFile                      OpenNeFileA
#define EnumNeResourceTypes             EnumNeResourceTypesA
#define EnumNeResourceNames             EnumNeResourceNamesA
#define SizeofNeResource                SizeofNeResourceA
#define FindNeResource                  FindNeResourceA
#define FindNeResourceEx                FindNeResourceExA

#define MapFileIntoMemory               MapFileIntoMemoryA
#define MapFileIntoMemoryEx             MapFileIntoMemoryExA

#define RemoveCompleteDirectory         RemoveCompleteDirectoryA

#define CMDLINE                         CMDLINEA
#define CMDLINEARG                      CMDLINEARGA
#define PCMDLINE                        PCMDLINEA
#define PCMDLINEARG                     PCMDLINEARGA
#define ParseCmdLine                    ParseCmdLineA

#define GetFileSizeFromFilePath         GetFileSizeFromFilePathA

#define DRIVELETTERS                    DRIVELETTERSA
#define PDRIVELETTERS                   PDRIVELETTERSA
#define InitializeDriveLetterStructure  InitializeDriveLetterStructureA

#define GetDiskFreeSpaceNew             GetDiskFreeSpaceNewA
#define QuietGetFileAttributes          QuietGetFileAttributesA
#define IsPathOnFixedDrive              IsPathOnFixedDriveA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\fileenum.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fileenum.h

Abstract:

    Declares interface for callback-based file enumeration.  The
    file enumerator has several capabilities, such as directory-
    first or directory-last enumeration, enumeration depth limiting,
    suppression of files or directories, and a global hook ability.

    This is *OLD CODE* changed significantly by MikeCo.  And because
    of the callback interface, it is overly complex.

    ** Do not use these routines in new Win9x upgrade code.
       Instead, see file.h for much better routines.

    There is one handy routine in here: DeleteDirectoryContents

Author:

    Jim Schmidt (jimschm) 03-Dec-1996

Revision History:

    mikeco  ??-???-1997     Ran code through train_wreck.exe

--*/


#ifndef _FILEENUM_H
#define _FILEENUM_H

//
// Callback typedef -> return FALSE if enumeration should stop
//

typedef INT  (CALLBACK * FILEENUMPROCA)(LPCSTR szFullFileSpec,
                                        LPCSTR szDestFileSpec,
                                        WIN32_FIND_DATAA *pFindData,
                                        DWORD EnumTreeID,
                                        LPVOID pParam,
                                        PDWORD CurrentDirData
                                        );

typedef INT  (CALLBACK * FILEENUMPROCW)(LPCWSTR szFullFileSpec,
                                        LPCWSTR szDestFileSpec,
                                        WIN32_FIND_DATAW *pFindData,
                                        DWORD EnumTreeID,
                                        LPVOID pParam,
                                        PDWORD CurrentDirData
                                        );

//
// Failure-reporting callbacks -- sink the names of paths that
// fail for reasons of length or code-page incompatibility
//
typedef VOID (CALLBACK * FILEENUMFAILPROCA) (LPCSTR szFailPath);

typedef VOID (CALLBACK * FILEENUMFAILPROCW) (LPCWSTR szFailPath);

//
// CopyTree flags. If neither COPYTREE_DOCOPY or COPYTREE_DOMOVE is
// passed in, the CopyTree functions will just enumerate.
//

#define COPYTREE_DOCOPY         0x0001
#define COPYTREE_NOOVERWRITE    0x0002
#define COPYTREE_DOMOVE         0x0004
#define COPYTREE_DODELETE       0x0008
#define COPYTREE_IGNORE_ERRORS  0x0010

//
// Level flags
//

#define ENUM_ALL_LEVELS         0
#define ENUM_THIS_DIRECTORY     1
#define ENUM_MAX_LEVELS         MAX_PATH

//
// Filter flags
//

#define FILTER_DIRECTORIES      0x0001
#define FILTER_FILES            0x0002
#define FILTER_DIRS_LAST        0x0004
#define FILTER_ALL              (FILTER_DIRECTORIES|FILTER_FILES)
#define FILTER_ALL_DIRS_LAST    (FILTER_DIRECTORIES|FILTER_FILES|FILTER_DIRS_LAST)

//
// Callback return values
//
#define CALLBACK_DO_NOT_RECURSE_THIS_DIRECTORY (-3)
#define CALLBACK_FAILED             (-2)
#define CALLBACK_SUBDIR_DONE        (-1)
#define CALLBACK_CONTINUE           (0)
#define CALLBACK_THIS_LEVEL_ONLY    (1)

//
// CopyTree parameter block
//

#include <pshpack1.h>
typedef struct COPYTREE_PARAMS_STRUCTA
{
    LPCSTR szEnumRootInWack;            // Root of source tree
    LPCSTR szEnumRootOutWack;           // Root of target tree
    CHAR szFullFileSpecOut[MAX_MBCHAR_PATH];   // Proposed target filespec (callback may change)
    int nCharsInRootInWack;
    int nCharsInRootOutWack;
    DWORD flags;
    FILEENUMPROCA pfnCallback;
} COPYTREE_PARAMSA, *PCOPYTREE_PARAMSA;

typedef struct COPYTREE_PARAMS_STRUCTW
{
    LPCWSTR szEnumRootInWack;
    LPCWSTR szEnumRootOutWack;
    WCHAR szFullFileSpecOut[MAX_WCHAR_PATH * 2];
    int nCharsInRootInWack;
    int nCharsInRootOutWack;
    DWORD flags;
    FILEENUMPROCW pfnCallback;
} COPYTREE_PARAMSW, *PCOPYTREE_PARAMSW;
#include <poppack.h>


//
// Exported functions from FILEENUM.DLL
//

//
// EnumerateAllDrives first builds an exclusion list if an exclusion INF path
// is provided, and then enumerates every file on every drive that is not
// excluded.  The callback function is called once per file.  The pParam
// parameter is passed to the callback.
//
// fnEnumCallback     - A pointer to your callback function
// EnumTreeID         - A value used to identify the exclusion list
//                      (see GenerateEnumID)
// pParam             - LPVOID passed to callback function
// szExclusionInfPath - Path to INF file containing exclusions
// szPathSection      - A string that identifies the path exclusion
//                      section in the INF.
// szFileSection      - A string that identifies the file exclusion
//                      section in the INF.
//

typedef struct {
    LPCSTR ExclusionInfPath;
    LPCSTR PathSection;
    LPCSTR FileSection;
} EXCLUDEINFA, *PEXCLUDEINFA;

typedef struct {
    LPCWSTR ExclusionInfPath;
    LPCWSTR PathSection;
    LPCWSTR FileSection;
} EXCLUDEINFW, *PEXCLUDEINFW;

BOOL
EnumerateAllDrivesA (
                     IN  FILEENUMPROCA fnEnumCallback,
                     IN  FILEENUMFAILPROCA fnFailCallback,  OPTIONAL
                     IN  DWORD EnumTreeID,
                     IN  LPVOID pParam,
                     IN  PEXCLUDEINFA ExcludeInfStruct,     OPTIONAL
                     IN  DWORD AttributeFilter
                     );

BOOL
EnumerateAllDrivesW (
                     IN  FILEENUMPROCW fnEnumCallback,
                     IN  FILEENUMFAILPROCW fnFailCallback,  OPTIONAL
                     IN  DWORD EnumTreeID,
                     IN  LPVOID pParam,
                     IN  PEXCLUDEINFW ExcludeInfStruct,     OPTIONAL
                     IN  DWORD AttributeFilter
                     );

//
// EnumerateTree is similar to EnumarateAllDrives, except it allows you to
// enumerate a specific drive, or a specific subdir on a drive.  Supply the
// drive letter and optional subdirectory in szEnumRoot.  Before enumerating,
// EnumerateTree will first build an exclusion list if an exclusion INF path
// is provided.  Then every file below szEnumRoot is enumerated, and the
// callback is called once per file, passing pParam unchanged.
//
// szEnumRoot         - Drive and optional path to enumerate
// fnEnumCallback     - A pointer to your callback function
// fnFailCallback     - A pointer to optional callback that logs a path
//                      that be enumerated due to length or other reason.
// EnumTreeID         - A value used to identify the exclusion list
//                      (see GenerateEnumID)
// pParam             - LPVOID passed to callback function
// szExclusionInfPath - Path to INF file containing exclusions
// szPathSection      - A string that identifies the path exclusion
//                      section in the INF.
// szFileSection      - A string that identifies the file exclusion
//                      section in the INF.
//

BOOL
EnumerateTreeA (
                IN  LPCSTR szEnumRoot,
                IN  FILEENUMPROCA fnEnumCallback,
                IN  FILEENUMFAILPROCA fnFailCallback,
                IN  DWORD EnumTreeID,
                IN  LPVOID pParam,
                IN  DWORD  Level,
                IN  PEXCLUDEINFA ExcludeInfStruct,      OPTIONAL
                IN  DWORD AttributeFilter
                );

BOOL
EnumerateTreeW (
                IN  LPCWSTR szEnumRoot,
                IN  FILEENUMPROCW fnEnumCallback,
                IN  FILEENUMFAILPROCW fnFailCallback,
                IN  DWORD EnumTreeID,
                IN  LPVOID pParam,
                IN  DWORD  Level,
                IN  PEXCLUDEINFW ExcludeInfStruct,      OPTIONAL
                IN  DWORD AttributeFilter
                );


//
// ClearExclusions removes all enumaration exclusions.  It is called
// automatically at the end of enumeration when an exclusion INF file is
// used.  Use it when you need to programmatically build an exclusion list
// with ExcludePath and ExcludeFile.
//
// You can combine programmatic exclusions with an exclusion INF file, but
// beware that the programmatic exclusions will be cleared after
// EnumarteAllDrives or EnumerateTree completes.
//
// If you do not use an INF, the programmatic exclusions will NOT
// automatically be cleared.  This allows you to build exclusions and
// enumerate multiple times without having to rebuild the exclusion
// list.
//
// EnumTreeID    - The value that identifies the enumeration exclusion list
//                 (See GenerateEnumID)
//

void
ClearExclusionsA (DWORD EnumTreeID);

void
ClearExclusionsW (DWORD EnumTreeID);



//
// ExcludePath adds a path name to the exclusion list.  There are two
// cases:
//
//  1. If a drive letter is supplied, the exclusion will apply only to
//     that drive letter and path.  (Path may be only a drive letter,
//     colon and backslash to exclude an entire drive.)
//  2. If the path does not begin with a drive letter, it is considered
//     relative, and any occurance of the path will be excluded, regardless
//     of drive letter and parent directory.
//
// The dot and double-dot directories are not supported.  The entire path
// specification may contain wildcard characters.  (For example, ?:\ indicates
// any drive letter.)
//
// EnumTreeID  - The value that identifies the enumeration exclusion list
//                 (See GenerateEnumID)
// szPath        - The path specification as described above
//

void
ExcludePathA (
              IN  DWORD EnumTreeID,
              IN  LPCSTR szPath
              );

void
ExcludePathW (
              IN  DWORD EnumTreeID,
              IN  LPCWSTR szPath
              );

//
// ExcludeFile adds a file name to the exclusion list.  There are two
// cases:
//
// 1. If a drive letter is supplied, the exclusion will only apply to that
//    drive letter, path and file.
// 2. If the path does not begin with a drive letter, any occurance of the file
//    or path/file will be excluded, regardless of drive letter and
//    parent directory.
//
// Both the path and file name may contain wildcard characters.
//
// EnumTreeID    - The value that identifies the enumeration exclusion list
//                 (See GenerateEnumID)
// szFile        - The file specification as described above
//

void
ExcludeFileA (
              IN  DWORD EnumTreeID,
              IN  LPCSTR szFile
              );

void
ExcludeFileW (
              IN  DWORD EnumTreeID,
              IN  LPCWSTR szFile
              );


BOOL
IsPathExcludedA (
    DWORD EnumID,
    PCSTR Path
    );

BOOL
IsPathExcludedW (
    DWORD EnumID,
    PCWSTR Path
    );


//
//
// BuildExclusionsFromInf adds all of the files and paths in the specified exclude.inf into
// the memdb under the specified EnumId.
//
//

BOOL
BuildExclusionsFromInfW (
    IN DWORD EnumID,
    IN PEXCLUDEINFW ExcludeInfStruct
    );

BOOL
BuildExclusionsFromInfA (
    IN DWORD EnumID,
    IN PEXCLUDEINFA ExcludeInfStruct
    );



//
// GenerateEnumID returns a unique DWORD that an application may use to
// build an exclusion list.  While use of this function is not technically
// required, it is provided to allow multiple threads to obtain a unique
// value.  If one caller uses this function, all callers must as well.
//

DWORD
GenerateEnumID ();


//
// CopyTree enumerates a tree and optionally copies or moves its files
// to another location.  The caller is responsible to see that the source
// and target trees are disjoint. (If not, the results could be uncool.)
//
// The callback function can veto a copy or move by returning FALSE,
// or change the target destination by modifying the szFullFileSpecOut
// string in the COPY_PARAMS block, and returning TRUE.
//

BOOL
CopyTreeA(
    IN  LPCSTR szEnumRootIn,
    IN  LPCSTR szEnumRootOut,
    IN  DWORD EnumTreeID,
    IN  DWORD dwFlags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFA ExcludeInfStruct,      OPTIONAL
    IN  FILEENUMPROCA pfnCallback,          OPTIONAL
    IN  FILEENUMFAILPROCA pfnFailCallback   OPTIONAL
    );

BOOL
CopyTreeW(
    IN  LPCWSTR szEnumRootIn,
    IN  LPCWSTR szEnumRootOut,
    IN  DWORD EnumTreeID,
    IN  DWORD dwFlags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFW ExcludeInfStruct,    OPTIONAL
    IN  FILEENUMPROCW pfnCallback,        OPTIONAL
    IN  FILEENUMFAILPROCW pfnFailCallback OPTIONAL
    );


#define DeleteDirectoryContentsA(dir) CopyTreeA(dir,NULL,0,COPYTREE_DODELETE,\
                                                ENUM_ALL_LEVELS,FILTER_ALL_DIRS_LAST,\
                                                NULL,NULL,NULL)

#define DeleteDirectoryContentsW(dir) CopyTreeW(dir,NULL,0,COPYTREE_DODELETE,\
                                                ENUM_ALL_LEVELS,FILTER_ALL_DIRS_LAST,\
                                                NULL,NULL,NULL)


DWORD
GetShellLinkPath(
                IN  HWND hwnd,
                IN  LPCTSTR tszLinkFile,
                OUT LPTSTR tszPath);

HRESULT
SetShellLinkPath(
                IN  HWND hwnd,
                IN  LPCTSTR tszLinkFile,
                IN  LPCTSTR tszPath);

DWORD
CreateEmptyDirectoryA (
    PCSTR Dir
    );


DWORD
CreateEmptyDirectoryW (
    PCWSTR Dir
    );

#ifdef UNICODE

#define EnumerateAllDrives EnumerateAllDrivesW
#define EnumerateTree EnumerateTreeW
#define ExcludePath ExcludePathW
#define ExcludeFile ExcludeFileW
#define BuildExclusionsFromInf BuildExclusionsFromInfW
#define CopyTree CopyTreeW
#define IsPathExcluded IsPathExcludedW
#define ClearExclusions ClearExclusionsW
#define COPYTREE_PARAMS COPYTREE_PARAMSW
#define PCOPYTREE_PARAMS PCOPYTREE_PARAMSW
#define FILEENUMPROC FILEENUMPROCW
#define FILEENUMFAILPROC FILEENUMFAILPROCW
#define EXCLUDEINF EXCLUDEINFW
#define PEXCLUDEINF PEXCLUDEINFW
#define DeleteDirectoryContents DeleteDirectoryContentsW
#define CreateEmptyDirectory CreateEmptyDirectoryW

#else

#define EnumerateAllDrives EnumerateAllDrivesA
#define EnumerateTree EnumerateTreeA
#define ExcludePath ExcludePathA
#define ExcludeFile ExcludeFileA
#define IsPathExcluded IsPathExcludedA
#define BuildExclusionsFromInf BuildExclusionsFromInfA
#define CopyTree CopyTreeA
#define ClearExclusions ClearExclusionsA
#define COPYTREE_PARAMS COPYTREE_PARAMSA
#define PCOPYTREE_PARAMS PCOPYTREE_PARAMSA
#define FILEENUMPROC FILEENUMPROCA
#define FILEENUMFAILPROC FILEENUMFAILPROCA
#define EXCLUDEINF EXCLUDEINFA
#define PEXCLUDEINF PEXCLUDEINFA
#define DeleteDirectoryContents DeleteDirectoryContentsA
#define CreateEmptyDirectory CreateEmptyDirectoryA

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\growlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growlist.h

Abstract:

    Implements a dynamic array-indexed list of binary objects.  Typically,
    the binary objects are strings.  The list uses a GROWBUF for the array,
    and a pool for the binary data of each list item.

Author:

    Jim Schmidt (jimschm) 08-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    GROWBUFFER ListArray;
    POOLHANDLE ListData;
} GROWLIST, *PGROWLIST;

#define GROWLIST_INIT {GROWBUF_INIT, NULL}

#define GrowListGetPtrArray(listptr)           ((PVOID *) ((listptr)->ListArray.Buf))
#define GrowListGetStringPtrArrayA(listptr)    ((PCSTR *) ((listptr)->ListArray.Buf))
#define GrowListGetStringPtrArrayW(listptr)    ((PCWSTR *) ((listptr)->ListArray.Buf))

PBYTE
RealGrowListAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListAppend(list,data,size)  SETTRACKCOMMENT(PBYTE,"GrowListAppend",__FILE__,__LINE__)\
                                        RealGrowListAppend (list,data,size)\
                                        CLRTRACKCOMMENT

PBYTE
RealGrowListAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListAppendAddNul(list,data,size)    SETTRACKCOMMENT(PBYTE,"GrowListAppendAddNul",__FILE__,__LINE__)\
                                                RealGrowListAppendAddNul (list,data,size)\
                                                CLRTRACKCOMMENT

VOID
FreeGrowList (
    IN  PGROWLIST GrowList
    );

PBYTE
GrowListGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GrowListGetSize (
    IN      PGROWLIST GrowList
    );

PBYTE
RealGrowListInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListInsert(list,index,data,size)    SETTRACKCOMMENT(PBYTE,"GrowListInsert",__FILE__,__LINE__)\
                                                RealGrowListInsert (list,index,data,size)\
                                                CLRTRACKCOMMENT


PBYTE
RealGrowListInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListInsertAddNul(list,index,data,size)  SETTRACKCOMMENT(PBYTE,"GrowListInsertAddNul",__FILE__,__LINE__)\
                                                    RealGrowListInsertAddNul (list,index,data,size)\
                                                    CLRTRACKCOMMENT


BOOL
GrowListDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

BOOL
GrowListResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

PBYTE
RealGrowListSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToSet,            OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListSetItem(list,index,data,size)   SETTRACKCOMMENT(PBYTE,"GrowListSetItem",__FILE__,__LINE__)\
                                                RealGrowListSetItem (list,index,data,size)\
                                                CLRTRACKCOMMENT


__inline
PCSTR
RealGrowListAppendStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABA"));

    return (PCSTR) GrowListAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        String < End ? (PBYTE) End - (PBYTE) String : 0
                        );
}

__inline
PCWSTR
RealGrowListAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABW"));

    return (PCWSTR) GrowListAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        String < End ? (PBYTE) End - (PBYTE) String : 0
                        );
}

__inline
PCSTR
RealGrowListInsertStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABA"));

    return (PCSTR) GrowListInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        String < End ? (PBYTE) End - (PBYTE) String : 0
                        );
}

__inline
PCWSTR
RealGrowListInsertStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABW"));

    return (PCWSTR) GrowListInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        String < End ? (PBYTE) End - (PBYTE) String : 0
                        );
}

#define GrowListAppendStringABA(list,a,b) SETTRACKCOMMENT(PCSTR,"GrowListAppendStringABA", __FILE__, __LINE__)\
                                          RealGrowListAppendStringABA(list,a,b)\
                                          CLRTRACKCOMMENT

#define GrowListAppendStringABW(list,a,b) SETTRACKCOMMENT(PCWSTR,"GrowListAppendStringABW", __FILE__, __LINE__)\
                                          RealGrowListAppendStringABW(list,a,b)\
                                          CLRTRACKCOMMENT

#define GrowListInsertStringABA(list,index,a,b) SETTRACKCOMMENT(PCSTR,"GrowListInsertStringABA", __FILE__, __LINE__)\
                                                RealGrowListInsertStringABA(list,index,a,b)\
                                                CLRTRACKCOMMENT

#define GrowListInsertStringABW(list,index,a,b) SETTRACKCOMMENT(PCWSTR,"GrowListInsertStringABW", __FILE__, __LINE__)\
                                                RealGrowListInsertStringABW(list,index,a,b)\
                                                CLRTRACKCOMMENT



#define GrowListAppendStringA(list,str) GrowListAppendStringABA(list,str,GetEndOfStringA(str))
#define GrowListAppendStringW(list,str) GrowListAppendStringABW(list,str,GetEndOfStringW(str))

#define GrowListInsertStringA(list,index,str) GrowListInsertStringABA(list,index,str,GetEndOfStringA(str))
#define GrowListInsertStringW(list,index,str) GrowListInsertStringABW(list,index,str,GetEndOfStringW(str))

#define GrowListAppendStringNA(list,str,len) GrowListAppendStringABA(list,str,CharCountToPointerA(str,len))
#define GrowListAppendStringNW(list,str,len) GrowListAppendStringABW(list,str,CharCountToPointerW(str,len))

#define GrowListInsertStringNA(list,index,str,len) GrowListInsertStringABA(list,index,str,CharCountToPointerA(str,len))
#define GrowListInsertStringNW(list,index,str,len) GrowListInsertStringABW(list,index,str,CharCountToPointerW(str,len))

#define GrowListGetStringA(list,index) (PCSTR)(GrowListGetItem(list,index))
#define GrowListGetStringW(list,index) (PCWSTR)(GrowListGetItem(list,index))

#define GrowListAppendEmptyItem(list)           GrowListAppend (list,NULL,0)
#define GrowListInsertEmptyItem(list,index)     GrowListInsert (list,index,NULL,0)

#ifdef UNICODE

#define GrowListAppendString GrowListAppendStringW
#define GrowListInsertString GrowListInsertStringW
#define GrowListAppendStringAB GrowListAppendStringABW
#define GrowListInsertStringAB GrowListInsertStringABW
#define GrowListAppendStringN GrowListAppendStringNW
#define GrowListInsertStringN GrowListInsertStringNW
#define GrowListGetString GrowListGetStringW
#define GrowListGetStringPtrArray GrowListGetStringPtrArrayW

#else

#define GrowListAppendString GrowListAppendStringA
#define GrowListInsertString GrowListInsertStringA
#define GrowListAppendStringAB GrowListAppendStringABA
#define GrowListInsertStringAB GrowListInsertStringABA
#define GrowListAppendStringN GrowListAppendStringNA
#define GrowListInsertStringN GrowListInsertStringNA
#define GrowListGetString GrowListGetStringA
#define GrowListGetStringPtrArray GrowListGetStringPtrArrayA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\fileops.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fileops.h

Abstract:

    Declares the file operation data structures and macros that access
    the file operations.  Every operation on a file is recorded using
    routines declared here.  The file op code keeps conflicting operations
    from being set on a file.

    See common\memdb\fileops.c for implementation details.

Author:

    Jim Schmidt (jimschm) 23-Sep-1998   (complete redesign)

Revision History:

    mvander     26-Map-1999 Added MODULESTATUS defines

--*/

#pragma once

/*++

Macro Expansion List Description:

   PATH_OPERATIONS defines a list of characteristics for operations that
   can be performed on a file.

   Some operation combinations are prohibited.  See the code in fileops.c
   for a list of prohibited combinations.

   NOTES: - THERE CAN ONLY BE A MAX OF 16 DEFINITIONS!!
          - THE BITS MUST BE SORTED!!
          - CANNOT HAVE UNUSED BITS INBETWEEN OPERATIONS!!

Line Syntax:

   DEFMAC(Bit, Name, CooperativeOperations, MaxProperties)

Arguments:

    Bit - Specifies the single bit (MUST FIT IN 24 BITS), in sorted order

    Name - Specifies the name of the operation constant (will appear in
           OPERATION enum type)

    MemDbName - Specifies the name as stored in memdb

    MaxProperties - Specifies 0, 1 or UNLIMITED, indicating the number of
                    properties that can be applied to the operation

Variables and Types Generated From List:

   OPERATION
   g_OperationFlags

--*/

#define PATH_OPERATIONS        \
        DEFMAC(0x0001, OPERATION_FILE_DELETE, Op01, 0)                \
        DEFMAC(0x0002, OPERATION_FILE_DELETE_EXTERNAL, Op02, 0)       \
        DEFMAC(0x0004, OPERATION_FILE_MOVE, Op03, 1)                  \
        DEFMAC(0x0008, OPERATION_FILE_COPY, Op04, UNLIMITED)          \
        DEFMAC(0x0010, OPERATION_FILE_MOVE_EXTERNAL, Op05, 1)         \
        DEFMAC(0x0020, OPERATION_CLEANUP, Op06, 0)                    \
        DEFMAC(0x0040, OPERATION_MIGDLL_HANDLED, Op07, 0)             \
        DEFMAC(0x0080, OPERATION_CREATE_FILE, Op08, 0)                \
        DEFMAC(0x0100, OPERATION_SHORT_FILE_NAME, Op09, 1)            \
        DEFMAC(0x0200, OPERATION_LINK_EDIT, Op10, UNLIMITED)          \
        DEFMAC(0x0400, OPERATION_SHELL_FOLDER, Op11, UNLIMITED)       \
        DEFMAC(0x0800, OPERATION_TEMP_PATH, Op12, 2)                  \
        DEFMAC(0x1000, OPERATION_FILE_MOVE_BY_NT, Op13, 1)            \
        DEFMAC(0x2000, OPERATION_FILE_MOVE_SHELL_FOLDER, Op14, 1)     \
        DEFMAC(0x4000, OPERATION_PRESERVED_DIR, Op15, 0)              \
        DEFMAC(0x8000, OPERATION_OS_FILE, Op16, 0)                    \
        DEFMAC(0x010000, OPERATION_FILE_DISABLED, Op17, 0)            \
        DEFMAC(0x020000, OPERATION_LINK_STUB, Op18, UNLIMITED)        \
        DEFMAC(0x040000, OPERATION_LONG_FILE_NAME, Op19, 0)           \
        DEFMAC(0x080000, OPERATION_CHANGE_EXTERNAL, Op20, 0)          \
        DEFMAC(0x100000, OPERATION_NUL_3, Opn3, 0)                    \
        DEFMAC(0x200000, OPERATION_NUL_2, Opn2, 0)                    \
        DEFMAC(0x400000, OPERATION_NUL_1, Opn1, 0)                    \


//
// Combined constants
//

#define ALL_MOVE_OPERATIONS             (OPERATION_FILE_MOVE|OPERATION_FILE_MOVE_EXTERNAL|OPERATION_FILE_MOVE_BY_NT|OPERATION_FILE_MOVE_SHELL_FOLDER)
#define ALL_COPY_OPERATIONS             (OPERATION_FILE_COPY)
#define ALL_DELETE_OPERATIONS           (OPERATION_FILE_DELETE|OPERATION_CLEANUP|OPERATION_FILE_DELETE_EXTERNAL)
#define ALL_OPERATIONS                  (0xffffff)
#define ALL_DEST_CHANGE_OPERATIONS      (ALL_MOVE_OPERATIONS|ALL_COPY_OPERATIONS)
#define ALL_CHANGE_OPERATIONS           (OPERATION_FILE_DISABLED|OPERATION_LINK_EDIT|OPERATION_LINK_STUB|OPERATION_CREATE_FILE|ALL_DEST_CHANGE_OPERATIONS|ALL_DELETE_OPERATIONS|OPERATION_CHANGE_EXTERNAL)
#define ALL_CONTENT_CHANGE_OPERATIONS   (ALL_DELETE_OPERATIONS|OPERATION_MIGDLL_HANDLED|OPERATION_CREATE_FILE|OPERATION_LINK_EDIT|OPERATION_LINK_STUB|OPERATION_FILE_DISABLED|OPERATION_CHANGE_EXTERNAL)

//
// Declare OPERATION type
//

#define DEFMAC(bit,name,memdbname,maxattribs)   name = bit,

typedef enum {
    PATH_OPERATIONS
    LAST_OPERATION
} OPERATION;

#undef DEFMAC

#define INVALID_SEQUENCER       0

//
// File status flags returned by GetFileInfoOnNt and GetFileStatusOnNt
//

#define FILESTATUS_UNCHANGED        0x00
#define FILESTATUS_DELETED          0x01
#define FILESTATUS_MOVED            0x02
#define FILESTATUS_REPLACED         0x04
#define FILESTATUS_NTINSTALLED      0x08
#define FILESTATUS_BACKUP           0x10

//
// Backup flags (for CleanOut memdb category)
//

#define BACKUP_FILE                 0
#define BACKUP_SUBDIRECTORY_FILES   1
#define BACKUP_SUBDIRECTORY_TREE    2
#define BACKUP_AND_CLEAN_TREE       3
#define BACKUP_AND_CLEAN_SUBDIR     4


//
// When a file is announced, it can be announced with one of the following.
//
#define ACT_UNKNOWN             0
#define ACT_REINSTALL           1           // application that needs to be reinstalled
#define ACT_MINORPROBLEMS       2           // application with minor problems
#define ACT_INCOMPATIBLE        3           // incompatible application - migdb based
#define ACT_INC_SAFETY          4           // items removed for safety
#define ACT_INC_NOBADAPPS       5           // incompatible application - no CheckBadApps entry
#define ACT_REINSTALL_BLOCK     6           // application that needs to be reinstalled (highly suggested)
#define ACT_INC_PREINSTUTIL     7           // incompatible preinstalled utility
#define ACT_INC_SIMILAROSFUNC   8           // incompatible utility but NT has similar functionality
#define ACT_INC_IHVUTIL         9           // incompatible hardware accessory


#define USF_9X      TEXT("9X")
#define USF_9XA     "9X"
#define USF_9XW     L"9X"

#define USF_NT      TEXT("NT")
#define USF_NTA     "NT"
#define USF_NTW     L"NT"

//
// Module status for use with MEMDB_CATEGORY_MODULE_CHECK
//

#define MODULESTATUS_NT_MODULE    0
#define MODULESTATUS_CHECKED      1
#define MODULESTATUS_CHECKING     2
#define MODULESTATUS_UNCHECKED    3
#define MODULESTATUS_BAD          4
#define MODULESTATUS_FILENOTFOUND 5





//
// Enum types
//

typedef struct {
    // External members
    CHAR Path[MAX_MBCHAR_PATH];
    UINT Sequencer;

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_ENUMA, *PFILEOP_ENUMA;

typedef struct {
    // External members
    WCHAR Path[MAX_WCHAR_PATH];
    UINT Sequencer;

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_ENUMW, *PFILEOP_ENUMW;

typedef struct {
    // External members
    CHAR Property[MEMDB_MAX * 2];
    CHAR PropertyName[MEMDB_MAX * 2];

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_PROP_ENUMA, *PFILEOP_PROP_ENUMA;

typedef struct {
    // External members
    WCHAR Property[MEMDB_MAX];
    WCHAR PropertyName[MEMDB_MAX];

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_PROP_ENUMW, *PFILEOP_PROP_ENUMW;


typedef struct {
    // External
    PCWSTR Path;
    UINT Sequencer;
    PCWSTR Property;
    UINT PropertyNum;
    OPERATION CurrentOperation;
    BOOL PropertyValid;

    // Internal
    UINT State;
    DWORD Operations;
    UINT OperationNum;
    WCHAR FileSpec[MAX_WCHAR_PATH];
    FILEOP_ENUMW OpEnum;
    FILEOP_PROP_ENUMW PropEnum;
} ALL_FILEOPS_ENUMW, *PALL_FILEOPS_ENUMW;

typedef struct {
    // External
    CHAR Path[MAX_MBCHAR_PATH];
    UINT Sequencer;
    CHAR Property[MEMDB_MAX * 2];
    UINT PropertyNum;
    OPERATION CurrentOperation;
    BOOL PropertyValid;

    // Internal
    ALL_FILEOPS_ENUMW Enum;
} ALL_FILEOPS_ENUMA, *PALL_FILEOPS_ENUMA;

typedef struct _SHELLFOLDER_ENUMA {
    CHAR  ShellFolder[MEMDB_MAX];
    PCSTR UserFixedName;
    PCSTR Side;
    MEMDB_ENUMA e;
} SHELLFOLDER_ENUMA, *PSHELLFOLDER_ENUMA;

typedef struct _SHELLFOLDER_ENUMW {
    WCHAR  ShellFolder[MEMDB_MAX];
    PCWSTR UserFixedName;
    PCWSTR Side;
    MEMDB_ENUMW e;
} SHELLFOLDER_ENUMW, *PSHELLFOLDER_ENUMW;

typedef struct {
    CHAR SrcFile[MAX_MBCHAR_PATH];
    CHAR DestFile[MAX_MBCHAR_PATH];

    ALL_FILEOPS_ENUMA e;
} FILERELOC_ENUMA, *PFILERELOC_ENUMA;

//
// Generalized file operations
//

VOID
InitOperationTable (
    VOID
    );

UINT
AddOperationToPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    );

UINT
AddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    );


BOOL
AddPropertyToPathExA (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCSTR Property,
    IN      PCSTR AlternateDataSection      OPTIONAL
    );

#define AddPropertyToPathA(seq,op,attr)        AddPropertyToPathExA(seq,op,attr,NULL)

BOOL
AddPropertyToPathExW (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCWSTR Property,
    IN      PCWSTR AlternateDataSection     OPTIONAL
    );

#define AddPropertyToPathW(seq,op,attr)        AddPropertyToPathExW(seq,op,attr,NULL)


BOOL
AssociatePropertyWithPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCSTR Property
    );

BOOL
AssociatePropertyWithPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCWSTR Property
    );


UINT
GetSequencerFromPathA (
    IN      PCSTR FileSpec
    );

UINT
GetSequencerFromPathW (
    IN      PCWSTR FileSpec
    );


BOOL
GetPathFromSequencerA (
    IN      UINT Sequencer,
    OUT     PSTR PathBuf
    );

BOOL
GetPathFromSequencerW (
    IN      UINT Sequencer,
    OUT     PWSTR PathBuf
    );


DWORD
GetOperationsOnPathA (
    IN      PCSTR FileSpec
    );

DWORD
GetOperationsOnPathW (
    IN      PCWSTR FileSpec
    );


VOID
RemoveOperationsFromSequencer (
    IN      UINT Sequencer,
    IN      DWORD Operations
    );

VOID
RemoveOperationsFromPathA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    );

#define RemoveAllOperationsFromPathA(file)      RemoveOperationsFromPathA(file,ALL_OPERATIONS)

VOID
RemoveOperationsFromPathW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    );

#define RemoveAllOperationsFromPathW(file)      RemoveOperationsFromPathW(file,ALL_OPERATIONS)


UINT
ForceOperationOnPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    );

UINT
ForceOperationOnPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    );


BOOL
IsFileMarkedForOperationA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    );

BOOL
IsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    );


BOOL
IsFileMarkedInDataA (
    IN      PCSTR FileSpec
    );

BOOL
IsFileMarkedInDataW (
    IN      PCWSTR FileSpec
    );


DWORD
GetPathPropertyOffset (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      DWORD Property
    );


BOOL
GetPathPropertyA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PSTR PropertyBuf           OPTIONAL        // MEMDB_MAX
    );

BOOL
GetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL        // MEMDB_MAX
    );


BOOL
EnumFirstPathInOperationA (
    OUT     PFILEOP_ENUMA EnumPtr,
    IN      OPERATION Operation
    );

BOOL
EnumFirstPathInOperationW (
    OUT     PFILEOP_ENUMW EnumPtr,
    IN      OPERATION Operation
    );


BOOL
EnumNextPathInOperationA (
    IN OUT  PFILEOP_ENUMA EnumPtr
    );

BOOL
EnumNextPathInOperationW (
    IN OUT  PFILEOP_ENUMW EnumPtr
    );


BOOL
EnumFirstFileOpPropertyA (
    OUT     PFILEOP_PROP_ENUMA EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    );

BOOL
EnumFirstFileOpPropertyW (
    OUT     PFILEOP_PROP_ENUMW EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    );


BOOL
EnumNextFileOpPropertyA (
    IN OUT  PFILEOP_PROP_ENUMA EnumPtr
    );

BOOL
EnumNextFileOpPropertyW (
    IN OUT  PFILEOP_PROP_ENUMW EnumPtr
    );


BOOL
EnumFirstFileOpA (
    OUT     PALL_FILEOPS_ENUMA EnumPtr,
    IN      DWORD Operations,
    IN      PCSTR FileSpec                      OPTIONAL
    );

BOOL
EnumFirstFileOpW (
    OUT     PALL_FILEOPS_ENUMW EnumPtr,
    IN      DWORD Operations,
    IN      PCWSTR FileSpec                     OPTIONAL
    );


BOOL
EnumNextFileOpA (
    IN OUT  PALL_FILEOPS_ENUMA EnumPtr
    );

BOOL
EnumNextFileOpW (
    IN OUT  PALL_FILEOPS_ENUMW EnumPtr
    );


BOOL
TestPathsForOperationsA (
    IN      PCSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    );

BOOL
TestPathsForOperationsW (
    IN      PCWSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    );


BOOL
IsFileMarkedForAnnounceA (
    IN      PCSTR FileSpec
    );

BOOL
IsFileMarkedAsKnownGoodA (
    IN      PCSTR FileSpec
    );

BOOL
IsFileMarkedForAnnounceW (
    IN      PCWSTR FileSpec
    );

DWORD
GetFileAnnouncementA (
    IN      PCSTR FileSpec
    );

DWORD
GetFileAnnouncementW (
    IN      PCWSTR FileSpec
    );

DWORD
GetFileAnnouncementContextA (
    IN      PCSTR FileSpec
    );

DWORD
GetFileAnnouncementContextW (
    IN      PCWSTR FileSpec
    );


BOOL
IsFileProvidedByNtA (
    IN      PCSTR FileName
    );

BOOL
IsFileProvidedByNtW (
    IN      PCWSTR FileName
    );


BOOL
GetNewPathForFileA (
    IN      PCSTR SrcFileSpec,
    OUT     PSTR NewPath
    );

BOOL
GetNewPathForFileW (
    IN      PCWSTR SrcFileSpec,
    OUT     PWSTR NewPath
    );


BOOL
AnnounceFileInReportA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr,
    IN      DWORD  Action
    );

BOOL
MarkFileAsKnownGoodA (
    IN      PCSTR SrcFileSpec
    );


BOOL
AddCompatibleShellA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
AddCompatibleRunKeyA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
AddCompatibleDosA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
AddControlPanelAppletA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr,               OPTIONAL
    IN      DWORD Action
    );

BOOL
AddCompatibleHlpA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
MarkFileForTemporaryMoveExA (
    IN      PCSTR SrcFileSpec,
    IN      PCSTR FinalDest,
    IN      PCSTR TempSpec,
    IN      BOOL TempSpecIsFile
    );

#define MarkFileForTemporaryMoveA(s,d,t) MarkFileForTemporaryMoveExA(s,d,t,FALSE)


PCSTR
GetTemporaryLocationForFileA (
    IN      PCSTR SourceFile
    );


PCWSTR
GetTemporaryLocationForFileW (
    IN      PCWSTR SourceFile
    );


BOOL
MarkHiveForTemporaryMoveA (
    IN      PCSTR HivePath,
    IN      PCSTR TempDir,
    IN      PCSTR UserName,
    IN      BOOL DefaultHives,
    IN      BOOL CreateOnly
    );


VOID
ComputeTemporaryPathA (
    IN      PCSTR SourcePath,
    IN      PCSTR SourcePrefix,     OPTIONAL
    IN      PCSTR TempPrefix,       OPTIONAL
    IN      PCSTR SetupTempDir,
    OUT     PSTR TempPath
    );

VOID
MarkShellFolderForMoveA (
    IN      PCSTR SrcPath,
    IN      PCSTR TempPath
    );


BOOL
FileIsProvidedByNtA (
    IN      PCSTR FullPath,
    IN      PCSTR FileName,
    IN      DWORD UserFlags
    );


BOOL
DeclareTemporaryFileA (
    IN      PCSTR FileSpec
    );

BOOL
DeclareTemporaryFileW (
    IN      PCWSTR FileSpec
    );


BOOL
EnumFirstFileRelocA (
    OUT     PFILERELOC_ENUMA EnumPtr,
    IN      PCSTR FileSpec              OPTIONAL
    );

BOOL
EnumNextFileRelocA (
    IN OUT  PFILERELOC_ENUMA EnumPtr
    );


BOOL
GetNtFilePathA (
    IN      PCSTR FileName,
    OUT     PSTR FullPath
    );

BOOL
GetNtFilePathW (
    IN      PCWSTR FileName,
    OUT     PWSTR FullPath
    );


DWORD
GetFileInfoOnNtA (
    IN      PCSTR FileName,
    OUT     PSTR  NewFileName,  // optional
    IN      UINT  BufferSize    // required if NewFileName is specified, buffer size in chars
    );

DWORD
GetFileInfoOnNtW (
    IN      PCWSTR FileName,
    OUT     PWSTR  NewFileName,  // optional
    IN      UINT   BufferSize    // required if NewFileName is specified, buffer size in chars
    );


DWORD
GetFileStatusOnNtA (
    IN      PCSTR FileName
    );

DWORD
GetFileStatusOnNtW (
    IN      PCWSTR FileName
    );


PSTR
GetPathStringOnNtA (
    IN      PCSTR FileName
    );

PWSTR
GetPathStringOnNtW (
    IN      PCWSTR FileName
    );


PCWSTR
SetCurrentUserW (
    IN      PCWSTR User
    );


PCSTR
ExtractArgZeroExA (
    IN      PCSTR CmdLine,
    OUT     PSTR Buffer,
    IN      PCSTR TerminatingChars,         OPTIONAL
    IN      BOOL KeepQuotes
    );

#define ExtractArgZeroA(cmdline,buf)        ExtractArgZeroExA(cmdline,buf,NULL,TRUE)

PCWSTR
ExtractArgZeroExW (
    IN      PCWSTR CmdLine,
    OUT     PWSTR Buffer,
    IN      PCWSTR TerminatingChars,        OPTIONAL
    IN      BOOL KeepQuotes
    );

#define ExtractArgZeroW(cmdline,buf)        ExtractArgZeroExW(cmdline,buf,NULL,TRUE)

BOOL
CanSetOperationA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    );

BOOL
CanSetOperationW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    );

PCSTR
GetSourceFileLongNameA (
    IN      PCSTR ShortName
    );

PCWSTR
GetSourceFileLongNameW (
    IN      PCWSTR ShortName
    );

BOOL
WriteBackupFilesA (
    IN      BOOL Win9xSide,
    IN      PCSTR TempDir,
    OUT     ULARGE_INTEGER * OutAmountOfSpaceIfCompressed,  OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpace,              OPTIONAL
    IN      INT CompressionFactor,                          OPTIONAL
    IN      INT BootCabImagePadding,                        OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceForDelFiles,   OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceClusterAligned OPTIONAL
    );

BOOL
WriteHashTableToFileW (
    IN HANDLE File,
    IN HASHTABLE FileTable
    );

BOOL
IsDirEmptyW(
     IN      PCWSTR DirPathPtr
     );

BOOL
IsDirEmptyA(
     IN      PCSTR DirPathPtr
     );

VOID
AddDirPathToEmptyDirsCategoryA(
    IN      PCSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    );

VOID
AddDirPathToEmptyDirsCategoryW(
    IN      PCWSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    );
//
// Wrapper macros
//

#define IsFileMarkedForPreDeleteA(file)             IsFileMarkedForOperationA(file, OPERATION_FILE_DELETE)
#define IsFileMarkedForPreDeleteW(file)             IsFileMarkedForOperationW(file, OPERATION_FILE_DELETE)

#define IsFileMarkedForPostDeleteA(file)            IsFileMarkedForOperationA(file, OPERATION_CLEANUP)
#define IsFileMarkedForPostDeleteW(file)            IsFileMarkedForOperationW(file, OPERATION_CLEANUP)

#define IsFileMarkedForDeleteA(file)                IsFileMarkedForOperationA(file, ALL_DELETE_OPERATIONS)
#define IsFileMarkedForDeleteW(file)                IsFileMarkedForOperationW(file, ALL_DELETE_OPERATIONS)

#define IsFileMarkedAsDestA(file)                   IsFileMarkedInDataA(file)
#define IsFileMarkedAsDestW(file)                   IsFileMarkedInDataW(file)

#define IsFileMarkedAsCopyA(file)                   IsFileMarkedForOperationA(file, OPERATION_FILE_COPY)
#define IsFileMarkedAsCopyW(file)                   IsFileMarkedForOperationW(file, OPERATION_FILE_COPY)

#define IsFileMarkedForMoveA(file)                  IsFileMarkedForOperationA(file, ALL_MOVE_OPERATIONS)
#define IsFileMarkedForMoveW(file)                  IsFileMarkedForOperationW(file, ALL_MOVE_OPERATIONS)

#define IsFileMarkedAsHandledA(file)                IsFileMarkedForOperationA(file, OPERATION_MIGDLL_HANDLED)
#define IsFileMarkedAsHandledW(file)                IsFileMarkedForOperationW(file, OPERATION_MIGDLL_HANDLED)

#define IsFileMarkedForChangeA(file)                IsFileMarkedForOperationA(file, ALL_OPERATIONS)
#define IsFileMarkedForChangeW(file)                IsFileMarkedForOperationW(file, ALL_OPERATIONS)

#define IsFileMarkedForCreationA(file)              IsFileMarkedForOperationA(file, OPERATION_CREATE_FILE)
#define IsFileMarkedForCreationW(file)              IsFileMarkedForOperationW(file, OPERATION_CREATE_FILE)

#define IsDirectoryMarkedAsEmptyA(file)             IsFileMarkedForOperationA(file, OPERATION_PRESERVED_DIR)
#define IsDirectoryMarkedAsEmptyW(file)             IsFileMarkedForOperationW(file, OPERATION_PRESERVED_DIR)

#define IsFileMarkedAsOsFileA(file)                 IsFileMarkedForOperationA(file, OPERATION_OS_FILE)
#define IsFileMarkedAsOsFileW(file)                 IsFileMarkedForOperationW(file, OPERATION_OS_FILE)

#define IsFileDisabledA(file)                       IsFileMarkedForOperationA(file, OPERATION_FILE_DISABLED)
#define IsFileDisabledW(file)                       IsFileMarkedForOperationW(file, OPERATION_FILE_DISABLED)

#define IsFileMarkedForBackupA(file)                IsFileMarkedForOperationA(file, OPERATION_CHANGE_EXTERNAL)
#define IsFileMarkedForBackupW(file)                IsFileMarkedForOperationW(file, OPERATION_CHANGE_EXTERNAL)

#define MarkFileForDeleteA(file)                    (AddOperationToPathA(file, OPERATION_FILE_DELETE) != INVALID_SEQUENCER)
#define MarkFileForExternalDeleteA(file)            (AddOperationToPathA(file, OPERATION_FILE_DELETE_EXTERNAL) != INVALID_SEQUENCER)
#define MarkFileForMoveA(source,dest)               AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE, dest)
#define MarkFileForCopyA(source,dest)               AssociatePropertyWithPathA(source, OPERATION_FILE_COPY, dest)
#define MarkFileForMoveExternalA(source,dest)       AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE_EXTERNAL, dest)
#define MarkFileForShellFolderMoveA(source,dest)    AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE_SHELL_FOLDER, dest)
#define MarkFileForMoveByNtA(source,dest)           AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE_BY_NT, dest)
#define MarkFileForCleanUpA(file)                   (AddOperationToPathA(file, OPERATION_CLEANUP) != INVALID_SEQUENCER)
#define MarkPathAsHandledA(path)                    (AddOperationToPathA(path, OPERATION_MIGDLL_HANDLED) != INVALID_SEQUENCER)
#define MarkFileForCreationA(path)                  (AddOperationToPathA(path, OPERATION_CREATE_FILE) != INVALID_SEQUENCER)
#define MarkDirectoryAsPreservedA(file)             (AddOperationToPathA(file, OPERATION_PRESERVED_DIR) != INVALID_SEQUENCER)
#define MarkFileAsOsFileA(file)                     (AddOperationToPathA(file, OPERATION_OS_FILE) != INVALID_SEQUENCER)
#define MarkFileForBackupA(file)                    (AddOperationToPathA(file, OPERATION_CHANGE_EXTERNAL) != INVALID_SEQUENCER)
#define DisableFileA(file)                          (AddOperationToPathA(file, OPERATION_FILE_DISABLED) != INVALID_SEQUENCER)

#define MarkFileForDeleteW(file)                    (AddOperationToPathW(file, OPERATION_FILE_DELETE) != INVALID_SEQUENCER)
#define MarkFileForExternalDeleteW(file)            (AddOperationToPathW(file, OPERATION_FILE_DELETE_EXTERNAL) != INVALID_SEQUENCER)
#define MarkFileForMoveW(source,dest)               AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE, dest)
#define MarkFileForCopyW(source,dest)               AssociatePropertyWithPathW(source, OPERATION_FILE_COPY, dest)
#define MarkFileForMoveExternalW(source,dest)       AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE_EXTERNAL, dest)
#define MarkFileForShellFolderMoveW(source,dest)    AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE_SHELL_FOLDER, dest)
#define MarkFileForMoveByNtW(source,dest)           AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE_BY_NT, dest)
#define MarkFileForCleanUpW(file)                   (AddOperationToPathW(file, OPERATION_CLEANUP) != INVALID_SEQUENCER)
#define MarkPathAsHandledW(path)                    (AddOperationToPathW(path, OPERATION_MIGDLL_HANDLED) != INVALID_SEQUENCER)
#define MarkFileForCreationW(path)                  (AddOperationToPathW(path, OPERATION_CREATE_FILE) != INVALID_SEQUENCER)
#define MarkDirectoryAsPreservedW(file)             (AddOperationToPathW(file, OPERATION_PRESERVED_DIR) != INVALID_SEQUENCER)
#define MarkFileAsOsFileW(file)                     (AddOperationToPathW(file, OPERATION_OS_FILE) != INVALID_SEQUENCER)
#define MarkFileForBackupW(file)                    (AddOperationToPathW(file, OPERATION_CHANGE_EXTERNAL) != INVALID_SEQUENCER)
#define DisableFileW(file)                          (AddOperationToPathW(file, OPERATION_FILE_DISABLED) != INVALID_SEQUENCER)


#ifndef UNICODE

#define FILEOP_ENUM                             FILEOP_ENUMA
#define FILEOP_PROP_ENUM                        FILEOP_PROP_ENUMA
#define ALL_FILEOPS_ENUM                        ALL_FILEOPS_ENUMA
#define SHELLFOLDER_ENUM                        SHELLFOLDER_ENUMA
#define FILERELOC_ENUM                          FILERELOC_ENUMA

#define AddOperationToPath                      AddOperationToPathA
#define AddPropertyToPathEx                     AddPropertyToPathExA
#define AssociatePropertyWithPath               AssociatePropertyWithPathA
#define GetSequencerFromPath                    GetSequencerFromPathA
#define GetPathFromSequencer                    GetPathFromSequencerA
#define GetOperationsOnPath                     GetOperationsOnPathA
#define RemoveOperationsFromPath                RemoveOperationsFromPathA
#define IsFileMarkedForOperation                IsFileMarkedForOperationA
#define IsFileMarkedInData                      IsFileMarkedInDataA
#define GetPathProperty                         GetPathPropertyA
#define EnumFirstPathInOperation                EnumFirstPathInOperationA
#define EnumNextPathInOperation                 EnumNextPathInOperationA
#define EnumFirstFileOpProperty                 EnumFirstFileOpPropertyA
#define EnumNextFileOpProperty                  EnumNextFileOpPropertyA
#define EnumFirstFileOp                         EnumFirstFileOpA
#define EnumNextFileOp                          EnumNextFileOpA
#define TestPathsForOperations                  TestPathsForOperationsA
#define IsFileMarkedForAnnounce                 IsFileMarkedForAnnounceA
#define GetFileAnnouncement                     GetFileAnnouncementA
#define GetFileAnnouncementContext              GetFileAnnouncementContextA
#define IsFileMarkedAsKnownGood                 IsFileMarkedAsKnownGoodA
#define IsFileProvidedByNt                      IsFileProvidedByNtA
#define GetNewPathForFile                       GetNewPathForFileA
#define AnnounceFileInReport                    AnnounceFileInReportA
#define MarkFileAsKnownGood                     MarkFileAsKnownGoodA
#define AddCompatibleShell                      AddCompatibleShellA
#define AddCompatibleRunKey                     AddCompatibleRunKeyA
#define AddCompatibleDos                        AddCompatibleDosA
#define AddControlPanelApplet                   AddControlPanelAppletA
#define AddCompatibleHlp                        AddCompatibleHlpA
#define MarkFileForTemporaryMove                MarkFileForTemporaryMoveA
#define MarkFileForTemporaryMoveEx              MarkFileForTemporaryMoveExA
#define GetTemporaryLocationForFile             GetTemporaryLocationForFileA
#define MarkHiveForTemporaryMove                MarkHiveForTemporaryMoveA
#define ComputeTemporaryPath                    ComputeTemporaryPathA
#define MarkShellFolderForMove                  MarkShellFolderForMoveA
#define FileIsProvidedByNt                      FileIsProvidedByNtA
#define DeclareTemporaryFile                    DeclareTemporaryFileA
#define EnumFirstFileReloc                      EnumFirstFileRelocA
#define EnumNextFileReloc                       EnumNextFileRelocA
#define GetNtFilePath                           GetNtFilePathA
#define GetFileInfoOnNt                         GetFileInfoOnNtA
#define GetFileStatusOnNt                       GetFileStatusOnNtA
#define GetPathStringOnNt                       GetPathStringOnNtA
#define ExtractArgZeroEx                        ExtractArgZeroExA
#define IsFileMarkedForPreDelete                IsFileMarkedForPreDeleteA
#define IsFileMarkedForPostDelete               IsFileMarkedForPostDeleteA
#define IsFileMarkedForDelete                   IsFileMarkedForDeleteA
#define IsFileMarkedAsDest                      IsFileMarkedAsDestA
#define IsFileMarkedAsCopy                      IsFileMarkedAsCopyA
#define IsFileMarkedForMove                     IsFileMarkedForMoveA
#define IsFileMarkedAsHandled                   IsFileMarkedAsHandledA
#define IsFileMarkedForChange                   IsFileMarkedForChangeA
#define IsFileMarkedForCreation                 IsFileMarkedForCreationA
#define IsDirectoryMarkedAsEmpty                IsDirectoryMarkedAsEmptyA
#define MarkFileForDelete                       MarkFileForDeleteA
#define MarkFileForExternalDelete               MarkFileForExternalDeleteA
#define MarkFileForMove                         MarkFileForMoveA
#define MarkFileForCopy                         MarkFileForCopyA
#define MarkFileForMoveExternal                 MarkFileForMoveExternalA
#define MarkFileForShellFolderMove              MarkFileForShellFolderMoveA
#define MarkFileForMoveByNt                     MarkFileForMoveByNtA
#define MarkFileForCleanUp                      MarkFileForCleanUpA
#define MarkPathAsHandled                       MarkPathAsHandledA
#define MarkFileForCreation                     MarkFileForCreationA
#define MarkDirectoryAsPreserved                MarkDirectoryAsPreservedA
#define ExtractArgZero                          ExtractArgZeroA
#define AddPropertyToPath                       AddPropertyToPathA
#define RemoveAllOperationsFromPath             RemoveAllOperationsFromPathA
#define ForceOperationOnPath                    ForceOperationOnPathA
#define MarkFileAsOsFile                        MarkFileAsOsFileA
#define MarkFileForBackup                       MarkFileForBackupA
#define IsFileMarkedAsOsFile                    IsFileMarkedAsOsFileA
#define DisableFile                             DisableFileA
#define IsFileDisabled                          IsFileDisabledA
#define IsFileMarkedForBackup                   IsFileMarkedForBackupA
#define CanSetOperation                         CanSetOperationA
#define GetSourceFileLongName                   GetSourceFileLongNameA
#define IsDirEmpty                              IsDirEmptyA
#define AddDirPathToEmptyDirsCategory           AddDirPathToEmptyDirsCategoryA

#else

#define FILEOP_ENUM                             FILEOP_ENUMW
#define FILEOP_PROP_ENUM                        FILEOP_PROP_ENUMW
#define ALL_FILEOPS_ENUM                        ALL_FILEOPS_ENUMW
#define SHELLFOLDER_ENUM                        SHELLFOLDER_ENUMW
#define FILERELOC_ENUM                          FILERELOC_ENUMW

#define AddOperationToPath                      AddOperationToPathW
#define AddPropertyToPathEx                     AddPropertyToPathExW
#define AssociatePropertyWithPath               AssociatePropertyWithPathW
#define GetSequencerFromPath                    GetSequencerFromPathW
#define GetPathFromSequencer                    GetPathFromSequencerW
#define GetOperationsOnPath                     GetOperationsOnPathW
#define RemoveOperationsFromPath                RemoveOperationsFromPathW
#define IsFileMarkedForOperation                IsFileMarkedForOperationW
#define IsFileMarkedInData                      IsFileMarkedInDataW
#define GetPathProperty                         GetPathPropertyW
#define EnumFirstPathInOperation                EnumFirstPathInOperationW
#define EnumNextPathInOperation                 EnumNextPathInOperationW
#define EnumFirstFileOpProperty                 EnumFirstFileOpPropertyW
#define EnumNextFileOpProperty                  EnumNextFileOpPropertyW
#define EnumFirstFileOp                         EnumFirstFileOpW
#define EnumNextFileOp                          EnumNextFileOpW
#define TestPathsForOperations                  TestPathsForOperationsW
#define IsFileMarkedForAnnounce                 IsFileMarkedForAnnounceW
#define GetFileAnnouncement                     GetFileAnnouncementW
#define GetFileAnnouncementContext              GetFileAnnouncementContextW
#define IsFileProvidedByNt                      IsFileProvidedByNtW
#define GetNewPathForFile                       GetNewPathForFileW
#define GetTemporaryLocationForFile             GetTemporaryLocationForFileW
#define DeclareTemporaryFile                    DeclareTemporaryFileW
#define GetNtFilePath                           GetNtFilePathW
#define GetFileInfoOnNt                         GetFileInfoOnNtW
#define GetFileStatusOnNt                       GetFileStatusOnNtW
#define GetPathStringOnNt                       GetPathStringOnNtW
#define ExtractArgZeroEx                        ExtractArgZeroExW
#define IsFileMarkedForPreDelete                IsFileMarkedForPreDeleteW
#define IsFileMarkedForPostDelete               IsFileMarkedForPostDeleteW
#define IsFileMarkedForDelete                   IsFileMarkedForDeleteW
#define IsFileMarkedAsDest                      IsFileMarkedAsDestW
#define IsFileMarkedAsCopy                      IsFileMarkedAsCopyW
#define IsFileMarkedForMove                     IsFileMarkedForMoveW
#define IsFileMarkedAsHandled                   IsFileMarkedAsHandledW
#define IsFileMarkedForChange                   IsFileMarkedForChangeW
#define IsFileMarkedForCreation                 IsFileMarkedForCreationW
#define IsDirectoryMarkedAsEmpty                IsDirectoryMarkedAsEmptyW
#define MarkFileForDelete                       MarkFileForDeleteW
#define MarkFileForExternalDelete               MarkFileForExternalDeleteW
#define MarkFileForMove                         MarkFileForMoveW
#define MarkFileForCopy                         MarkFileForCopyW
#define MarkFileForMoveExternal                 MarkFileForMoveExternalW
#define MarkFileForShellFolderMove              MarkFileForShellFolderMoveW
#define MarkFileForMoveByNt                     MarkFileForMoveByNtW
#define MarkFileForCleanUp                      MarkFileForCleanUpW
#define MarkPathAsHandled                       MarkPathAsHandledW
#define MarkFileForCreation                     MarkFileForCreationW
#define MarkDirectoryAsPreserved                MarkDirectoryAsPreservedW
#define RecordSrcFromDest                       RecordSrcFromDestW
#define ExtractArgZero                          ExtractArgZeroW
#define AddPropertyToPath                       AddPropertyToPathW
#define RemoveAllOperationsFromPath             RemoveAllOperationsFromPathW
#define ForceOperationOnPath                    ForceOperationOnPathW
#define MarkFileAsOsFile                        MarkFileAsOsFileW
#define MarkFileForBackup                       MarkFileForBackupW
#define IsFileMarkedAsOsFile                    IsFileMarkedAsOsFileW
#define DisableFile                             DisableFileW
#define IsFileDisabled                          IsFileDisabledW
#define IsFileMarkedForBackup                   IsFileMarkedForBackupW
#define CanSetOperation                         CanSetOperationW
#define GetSourceFileLongName                   GetSourceFileLongNameW
#define IsDirEmpty                              IsDirEmptyW
#define AddDirPathToEmptyDirsCategory           AddDirPathToEmptyDirsCategoryW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\growbuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growbuf.h

Abstract:

    Implements the GROWBUFFER data type, a dynamically allocated buffer
    that grows (and potentially changes addresses).  GROWBUFFERs are
    typically used to maintain dynamic sized arrays, or multi-sz lists.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/



typedef struct {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
} GROWBUFFER, *PGROWBUFFER;

#define GROWBUF_INIT {NULL,0,0,0,0}

PBYTE
RealGrowBuffer (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    );

#define GrowBuffer(buf,size)    SETTRACKCOMMENT(PBYTE,"GrowBuffer",__FILE__,__LINE__)\
                                RealGrowBuffer(buf,size)\
                                CLRTRACKCOMMENT

VOID
FreeGrowBuffer (
    IN  PGROWBUFFER GrowBuf
    );


PBYTE
RealGrowBufferReserve (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    );

#define GrowBufferReserve(buf,size)     SETTRACKCOMMENT(PBYTE,"GrowBufferReserve",__FILE__,__LINE__)\
                                        RealGrowBufferReserve(buf,size)\
                                        CLRTRACKCOMMENT
BOOL
RealMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define MultiSzAppendA(buf,str) SETTRACKCOMMENT(BOOL,"MultiSzAppendA",__FILE__,__LINE__)\
                                RealMultiSzAppendA(buf,str)\
                                CLRTRACKCOMMENT

BOOL
RealMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define MultiSzAppendW(buf,str) SETTRACKCOMMENT(BOOL,"MultiSzAppendW",__FILE__,__LINE__)\
                                RealMultiSzAppendW(buf,str)\
                                CLRTRACKCOMMENT

BOOL
RealMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    );

#define MultiSzAppendValA(buf,k,v)  SETTRACKCOMMENT(BOOL,"MultiSzAppendValA",__FILE__,__LINE__)\
                                    RealMultiSzAppendValA(buf,k,v)\
                                    CLRTRACKCOMMENT

BOOL
RealMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    );

#define MultiSzAppendValW(buf,k,v)  SETTRACKCOMMENT(BOOL,"MultiSzAppendValW",__FILE__,__LINE__)\
                                    RealMultiSzAppendValW(buf,k,v)\
                                    CLRTRACKCOMMENT

BOOL
RealMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    );

#define MultiSzAppendStringA(buf,k,v)   SETTRACKCOMMENT(BOOL,"MultiSzAppendStringA",__FILE__,__LINE__)\
                                        RealMultiSzAppendStringA(buf,k,v)\
                                        CLRTRACKCOMMENT

BOOL
RealMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    );

#define MultiSzAppendStringW(buf,k,v)   SETTRACKCOMMENT(BOOL,"MultiSzAppendStringW",__FILE__,__LINE__)\
                                        RealMultiSzAppendStringW(buf,k,v)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    );

#define GrowBufAppendDword(buf,d)   SETTRACKCOMMENT(BOOL,"GrowBufAppendDword",__FILE__,__LINE__)\
                                    RealGrowBufAppendDword(buf,d)\
                                    CLRTRACKCOMMENT


BOOL
RealGrowBufAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GrowBufAppendStringA(buf,str)   SETTRACKCOMMENT(BOOL,"GrowBufAppendStringA",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringA(buf,str)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GrowBufAppendStringW(buf,str)   SETTRACKCOMMENT(BOOL,"GrowBufAppendStringW",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringW(buf,str)\
                                        CLRTRACKCOMMENT


BOOL
RealGrowBufAppendStringABA (
    PGROWBUFFER GrowBuf,
    PCSTR Start,
    PCSTR EndPlusOne
    );

#define GrowBufAppendStringABA(buf,a,b) SETTRACKCOMMENT(BOOL,"GrowBufAppendStringABA",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringABA(buf,a,b)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufAppendStringABW (
    PGROWBUFFER GrowBuf,
    PCWSTR Start,
    PCWSTR EndPlusOne
    );

#define GrowBufAppendStringABW(buf,a,b) SETTRACKCOMMENT(BOOL,"GrowBufAppendStringABW",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringABW(buf,a,b)\
                                        CLRTRACKCOMMENT



BOOL
RealGrowBufCopyStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GrowBufCopyStringA(buf,str)     SETTRACKCOMMENT(BOOL,"GrowBufCopyStringA",__FILE__,__LINE__)\
                                        RealGrowBufCopyStringA(buf,str)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufCopyStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GrowBufCopyStringW(buf,str)     SETTRACKCOMMENT(BOOL,"GrowBufCopyStringW",__FILE__,__LINE__)\
                                        RealGrowBufCopyStringW(buf,str)\
                                        CLRTRACKCOMMENT

#ifdef UNICODE

#define MultiSzAppend           MultiSzAppendW
#define MultiSzAppendVal        MultiSzAppendValW
#define MultiSzAppendString     MultiSzAppendStringW
#define GrowBufAppendString     GrowBufAppendStringW
#define GrowBufAppendStringAB   GrowBufAppendStringABW
#define GrowBufCopyString       GrowBufCopyStringW

#else

#define MultiSzAppend           MultiSzAppendA
#define MultiSzAppendVal        MultiSzAppendValA
#define MultiSzAppendString     MultiSzAppendStringA
#define GrowBufAppendString     GrowBufAppendStringA
#define GrowBufAppendStringAB   GrowBufAppendStringABA
#define GrowBufCopyString       GrowBufCopyStringA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\hwcomp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hwcomp.h

Abstract:

    This file declares the interface for hardware compatibility code.
    This includes the routines that build hwcomp.dat (the NT PNP ID
    list), that compare the hardware on Win9x to what is supported by
    NT, that enumerate the Win9x devices, and that manage the Have Disk
    capability for drivers.

Author:

    Jim Schmidt (jimschm) 06-Jul-1996

Revision History:

    jimschm     09-Jan-1998     Work on hwcomp.dat rebuild detection
    jimschm     11-Nov-1997     Have Disk capability, online detection
    jimschm     09-Oct-1997     Revised to use project's APIs

--*/


#pragma once

#define MAX_HARDWARE_STRING 256

//
// The list of fields needed from a device
//

#define DEVICE_FIELDS                                           \
    DECLARE(Class, TEXT("Class"))                               \
    DECLARE(DeviceDesc, TEXT("DeviceDesc"))                     \
    DECLARE(Mfg, TEXT("Mfg"))                                   \
    DECLARE(Driver, TEXT("Driver"))                             \
    DECLARE(HardwareID, TEXT("HardwareID"))                     \
    DECLARE(CompatibleIDs, TEXT("CompatibleIDs"))               \
    DECLARE(HWRevision, TEXT("HWRevision"))                     \
    DECLARE(BusType, TEXT("BusType"))                           \
    DECLARE(InfName, TEXT("InfName"))                           \
    DECLARE(CurrentDriveLetter, TEXT("CurrentDriveLetter"))     \
    DECLARE(ProductId, TEXT("ProductId"))                       \
    DECLARE(SCSILUN, TEXT("SCSILUN"))                           \
    DECLARE(SCSITargetID, TEXT("SCSITargetID"))                 \
    DECLARE(ClassGUID, TEXT("ClassGUID"))                       \
    DECLARE(MasterCopy, TEXT("MasterCopy"))                     \
    DECLARE(UserDriveLetter, TEXT("UserDriveLetter"))           \
    DECLARE(CurrentDriveLetterAssignment, TEXT("CurrentDriveLetterAssignment"))     \
    DECLARE(UserDriveLetterAssignment, TEXT("UserDriveLetterAssignment"))           \

#define DECLARE(varname,text) PCTSTR varname;

typedef enum {
    ENUM_ALL_DEVICES,
    ENUM_COMPATIBLE_DEVICES,
    ENUM_INCOMPATIBLE_DEVICES,
    ENUM_UNSUPPORTED_DEVICES,
    ENUM_NON_FUNCTIONAL_DEVICES
} TYPE_OF_ENUM;

//
// Things caller does NOT want from enumeration
// (makes enumeration faster)
//

#define ENUM_DONT_WANT_DEV_FIELDS       0x0001
#define ENUM_DONT_WANT_USER_SUPPLIED    0x0002

//
// Things caller wants from enumerations
//
#define ENUM_WANT_USER_SUPPLIED_ONLY    0x0004

#define ENUM_WANT_DEV_FIELDS            0x0000      // default!
#define ENUM_WANT_ONLINE_FLAG           0x0010
#define ENUM_WANT_COMPATIBLE_FLAG       0x0020
#define ENUM_WANT_USER_SUPPLIED_FLAG    0x0040

//
// Flag to supress the requirement for the Hardware ID.
//
#define ENUM_DONT_REQUIRE_HARDWAREID    0x0100


#define ENUM_WANT_ALL   (ENUM_WANT_DEV_FIELDS|          \
                         ENUM_WANT_ONLINE_FLAG|         \
                         ENUM_WANT_COMPATIBLE_FLAG|     \
                         ENUM_WANT_USER_SUPPLIED_FLAG)


typedef struct {
    //
    // Enumeration state
    //

    PCTSTR InstanceId;
    PCTSTR FullKey;
    HKEY KeyHandle;

    //
    // Optional enumeration elements
    //

    // Not filled when ENUM_DONT_WANT_DEV_FIELDS is specified in EnumFlags
    DEVICE_FIELDS

    // Only when ENUM_WANT_ONLINE_FLAG is specified in EnumFlags
    BOOL Online;

    // Only when ENUM_WANT_COMPATIBLE_FLAG is specified in EnumFlags
    BOOL HardwareIdCompatible;
    BOOL CompatibleIdCompatible;
    BOOL SuppliedByUi;
    BOOL Compatible;
    BOOL HardwareIdUnsupported;
    BOOL CompatibleIdUnsupported;
    BOOL Unsupported;

    //
    // Enumeration position
    //

    REGTREE_ENUM ek;
    REGVALUE_ENUM ev;
    UINT State;
    TYPE_OF_ENUM TypeOfEnum;
    DWORD EnumFlags;
} HARDWARE_ENUM, *PHARDWARE_ENUM;

#undef DECLARE



BOOL
WINAPI
HwComp_Entry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
RealEnumFirstHardware (
    OUT     PHARDWARE_ENUM EnumPtr,
    IN      TYPE_OF_ENUM TypeOfEnum,
    IN      DWORD EnumFlags
    );

#define EnumFirstHardware(e,type,flags)     SETTRACKCOMMENT(BOOL,"EnumFirstHardware",__FILE__,__LINE__)\
                                            RealEnumFirstHardware(e,type,flags)\
                                            CLRTRACKCOMMENT

BOOL
RealEnumNextHardware (
    IN OUT  PHARDWARE_ENUM EnumPtr
    );

#define EnumNextHardware(e)     SETTRACKCOMMENT(BOOL,"EnumNextHardware",__FILE__,__LINE__)\
                                RealEnumNextHardware(e)\
                                CLRTRACKCOMMENT


VOID
AbortHardwareEnum (
    IN OUT  PHARDWARE_ENUM EnumPtr
    );


BOOL
CreateNtHardwareList (
    IN      PCTSTR * NtInfPaths,
    IN      UINT NtInfPathCount,
    IN      PCTSTR HwCompDatPath,       OPTIONAL
    IN      INT UiMode
    );

BOOL
HwComp_ScanForCriticalDevices (
    VOID
    );


VOID
FreeNtHardwareList (
    VOID
    );


BOOL
FindHardwareId (
    IN  PCTSTR PnpId,
    OUT PTSTR InfFileName
    );

BOOL
FindUnsupportedHardwareId (
    IN  PCTSTR PnpId,
    OUT PTSTR InfFileName
    );

BOOL
FindUserSuppliedDriver (
    IN      PCTSTR HardwareIdList,      OPTIONAL
    IN      PCTSTR CompatibleIdList     OPTIONAL
    );

BOOL
FindHardwareIdInHashTable (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR InfFileName,      OPTIONAL
    IN      HASHTABLE StrTable,
    IN      BOOL UseOverrideList
    );


typedef enum {
    QUERY,
    LOAD,
    DUMP
} LOADOP;

BOOL
LoadDeviceList (
    IN      LOADOP QueryFlag,
    IN      PCTSTR HwCompDat
    );

BOOL
SaveDeviceList (
    PCTSTR HwCompDat
    );


PCTSTR
ExtractPnpId (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR PnpIdBuf
    );


BOOL
AddPnpIdsToHashTable (
    IN OUT  HASHTABLE Table,
    IN      PCTSTR PnpIdList
    );

BOOL
AddPnpIdsToGrowList (
    IN OUT  PGROWLIST GrowList,
    IN      PCTSTR PnpIdList
    );

PCTSTR
AddPnpIdsToGrowBuf (
    IN OUT  PGROWBUFFER GrowBuffer,
    IN      PCTSTR PnpIdList
    );



#define KNOWN_HARDWARE      TRUE
#define UNKNOWN_HARDWARE    FALSE


//
// Network adapter enumeration
//

typedef enum {
    BUSTYPE_ISA,
    BUSTYPE_EISA,
    BUSTYPE_MCA,
    BUSTYPE_PCI,
    BUSTYPE_PNPISA,
    BUSTYPE_PCMCIA,
    BUSTYPE_ROOT,
    BUSTYPE_UNKNOWN
} BUSTYPE;

extern PCTSTR g_BusType[];

typedef enum {
    TRANSCIEVERTYPE_AUTO,
    TRANSCIEVERTYPE_THICKNET,
    TRANSCIEVERTYPE_THINNET,
    TRANSCIEVERTYPE_TP,
    TRANSCIEVERTYPE_UNKNOWN
} TRANSCIEVERTYPE;

extern PCTSTR g_TranscieverType[];

typedef enum {
    IOCHANNELREADY_EARLY,
    IOCHANNELREADY_LATE,
    IOCHANNELREADY_NEVER,
    IOCHANNELREADY_AUTODETECT,
    IOCHANNELREADY_UNKNOWN
} IOCHANNELREADY;

extern PCTSTR g_IoChannelReady[];


typedef struct {
    // Enumeration output
    TCHAR HardwareId[MAX_HARDWARE_STRING];
    TCHAR CompatibleIDs[MAX_HARDWARE_STRING];
    TCHAR Description[MAX_HARDWARE_STRING];
    BUSTYPE BusType;
    TCHAR IoAddrs[MAX_HARDWARE_STRING];
    TCHAR Irqs[MAX_HARDWARE_STRING];
    TCHAR Dma[MAX_HARDWARE_STRING];
    TCHAR MemRanges[MAX_HARDWARE_STRING];
    TCHAR CurrentKey[MAX_HARDWARE_STRING];
    TRANSCIEVERTYPE TranscieverType;
    IOCHANNELREADY IoChannelReady;


    // Enumeration variables
    HARDWARE_ENUM HardwareEnum;
    UINT State;
} NETCARD_ENUM, *PNETCARD_ENUM;

BOOL
EnumFirstNetCard (
    OUT     PNETCARD_ENUM EnumPtr
    );

BOOL
EnumNextNetCard (
    IN OUT  PNETCARD_ENUM EnumPtr
    );

VOID
EnumNetCardAbort (
    IN      PNETCARD_ENUM EnumPtr
    );

BOOL
GetLegacyKeyboardId (
    OUT     PTSTR Buffer,
    IN      UINT BufferSize
    );

//
// HKEY_DYN_DATA enumeration functions
//

typedef struct {
    PTSTR ClassFilter;              // supplied by caller
    REGKEY_ENUM CurrentDevice;      // for enumeration
    HKEY ConfigMgrKey;              // key to HKDD\Config Manager
    HKEY EnumKey;                   // key to HKLM\Enum
    HKEY ActualDeviceKey;           // key to HKLM\Enum\<enumerator>\<pnpid>\<device>
    BOOL NotFirst;                  // for enumeration
    TCHAR RegLocation[MAX_REGISTRY_KEY];    // <enumerator>\<pnpid>\<instance>
} ACTIVE_HARDWARE_ENUM, *PACTIVE_HARDWARE_ENUM;

BOOL
EnumFirstActiveHardware (
    OUT     PACTIVE_HARDWARE_ENUM EnumPtr,
    IN      PCTSTR ClassFilter             OPTIONAL
    );

BOOL
EnumNextActiveHardware (
    IN OUT  PACTIVE_HARDWARE_ENUM EnumPtr
    );

VOID
AbortActiveHardwareEnum (
    IN      PACTIVE_HARDWARE_ENUM EnumPtr
    );

BOOL
IsPnpIdOnline (
    IN      PCTSTR PnpId,
    IN      PCTSTR Class            OPTIONAL
    );

BOOL
HwComp_DoesDatFileNeedRebuilding (
    VOID
    );

INT
HwComp_GetProgressMax (
    VOID
    );

LONG
HwComp_PrepareReport (
    VOID
    );

//
// PNPREPT encoding and decoding routines
//

#define MAX_INF_DESCRIPTION             512
#define MAX_PNPID_LENGTH                256
#define MAX_ENCODED_PNPID_LENGTH        (MAX_PNPID_LENGTH*2)

VOID
EncodePnpId (
    IN OUT  PSTR Id
    );

VOID
DecodePnpId (
    IN OUT  PSTR Id
    );


#define REGULAR_OUTPUT 0
#define VERBOSE_OUTPUT 1
#define PNPREPT_OUTPUT 2

BOOL
HwComp_DialUpAdapterFound (
    VOID
    );

BOOL
HwComp_NtUsableHardDriveExists (
    VOID
    );

BOOL
HwComp_NtUsableCdRomDriveExists (
    VOID
    );

BOOL
HwComp_MakeLocalSourceDeviceExists (
    VOID
    );

BOOL
HwComp_ReportIncompatibleController (
    VOID
    );

BOOL
ScanPathForDrivers (
    IN      HWND CopyDlgParent,     OPTIONAL
    IN      PCTSTR SourceInfDir,
    IN      PCTSTR TempDir,
    IN      HANDLE CancelEvent      OPTIONAL
    );


#define WMX_BEGIN_FILE_COPY     (WM_APP+100)



typedef struct {

    //
    // Enumeration return member
    //

    PBYTE Resource;
    DWORD Type;
    PBYTE ResourceData;

    //
    // Internal enumeration member (do not modify)
    //

    PBYTE Resources;
    PBYTE NextResource;

} DEVNODERESOURCE_ENUM, *PDEVNODERESOURCE_ENUM;


PBYTE
GetDevNodeResources (
    IN      PCTSTR RegKey
    );

VOID
FreeDevNodeResources (
    IN      PBYTE ResourceData
    );

BOOL
EnumFirstDevNodeResourceEx (
    OUT     PDEVNODERESOURCE_ENUM EnumPtr,
    IN      PBYTE DevNodeResources
    );

BOOL
EnumNextDevNodeResourceEx (
    IN OUT  PDEVNODERESOURCE_ENUM EnumPtr
    );

BOOL
EnumFirstDevNodeResource (
    OUT     PDEVNODERESOURCE_ENUM EnumPtr,
    IN      PCTSTR DevNode
    );

BOOL
EnumNextDevNodeResource (
    IN OUT  PDEVNODERESOURCE_ENUM EnumPtr
    );


#define MAX_RESOURCE_NAME   64
#define MAX_RESOURCE_VALUE  128

typedef struct {
    //
    // Enumeration output
    //

    TCHAR   ResourceName[MAX_RESOURCE_NAME];
    TCHAR   Value[MAX_RESOURCE_VALUE];

    //
    // Internal state
    //
    DEVNODERESOURCE_ENUM Enum;
} DEVNODESTRING_ENUM, *PDEVNODESTRING_ENUM;


BOOL
EnumFirstDevNodeString (
    OUT     PDEVNODESTRING_ENUM EnumPtr,
    IN      PCTSTR DevNodeKeyStr
    );

BOOL
EnumNextDevNodeString (
    IN OUT  PDEVNODESTRING_ENUM EnumPtr
    );

#pragma pack(push,1)

//
// MEM_RANGE Structure for Win9x
//
typedef struct {
   DWORD     MR_Align;     // specifies mask for base alignment
   DWORD     MR_nBytes;    // specifies number of bytes required
   DWORD     MR_Min;       // specifies minimum address of the range
   DWORD     MR_Max;       // specifies maximum address of the range
   WORD      MR_Flags;     // specifies flags describing range (fMD flags)
   WORD      MR_Reserved;
   DWORD     MR_PcCardFlags;
   DWORD     MR_MemCardAddr;
} MEM_RANGE_9X, *PMEM_RANGE_9X;

//
// MEM_DES structure for Win9x
//
typedef struct {
   WORD      MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
   WORD      MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
   DWORD     MD_Alloc_Base;   // base memory address of range allocated
   DWORD     MD_Alloc_End;    // end of allocated range
   WORD      MD_Flags;        // flags describing allocated range (fMD flags)
   WORD      MD_Reserved;
} MEM_DES_9X, *PMEM_DES_9X;

//
// MEM_RESOURCE structure for Win9x
//
typedef struct {
   MEM_DES_9X   MEM_Header;               // info about memory range list
   MEM_RANGE_9X MEM_Data[ANYSIZE_ARRAY];  // list of memory ranges
} MEM_RESOURCE_9X, *PMEM_RESOURCE_9X;


//
// IO_RANGE structure for Win9x
//
typedef struct {
   WORD      IOR_Align;      // mask for base alignment
   WORD      IOR_nPorts;     // number of ports
   WORD      IOR_Min;        // minimum port address
   WORD      IOR_Max;        // maximum port address
   WORD      IOR_RangeFlags; // flags for this port range
   BYTE      IOR_Alias;      // multiplier that generates aliases for port(s)
   BYTE      IOR_Decode;
   DWORD     PcCardFlags;
} IO_RANGE_9X, *PIO_RANGE_9X;

//
// IO_DES structure for Win9x
//
typedef struct {
   WORD      IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
   WORD      IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
   WORD      IOD_Alloc_Base;     // base of allocated port range
   WORD      IOD_Alloc_End;      // end of allocated port range
   WORD      IOD_DesFlags;       // flags relating to allocated port range
   BYTE      IOD_Alloc_Alias;
   BYTE      IOD_Alloc_Decode;
} IO_DES_9X, *PIO_DES_9X;

//
// IO_RESOURCE for Win9x
//
typedef struct {
   IO_DES_9X   IO_Header;                 // info about I/O port range list
   IO_RANGE_9X IO_Data[ANYSIZE_ARRAY];    // list of I/O port ranges
} IO_RESOURCE_9X, *PIO_RESOURCE_9X;


//
// DMA_RESOURCE for Win9x
//
typedef struct {
   WORD     DMA_Unknown;
   WORD     DMA_Bits;
} DMA_RESOURCE_9X, *PDMA_RESOURCE_9X;

#define DMA_CHANNEL_0       0x0001
#define DMA_CHANNEL_1       0x0002
#define DMA_CHANNEL_2       0x0004
#define DMA_CHANNEL_3       0x0008


//
// IRQ_RESOURCE for Win9x
//
typedef struct {
    WORD        Flags;
    WORD        AllocNum;
    WORD        ReqMask;
    WORD        Reserved;
    DWORD       PcCardFlags;
} IRQ_RESOURCE_9X, *PIRQ_RESOURCE_9X;


#pragma pack(pop)

BOOL
EjectDriverMedia (
    IN      PCSTR IgnoreMediaOnDrive        OPTIONAL
    );

BOOL
IsComputerOffline (
    VOID
    );

BOOL
HwComp_AnyNeededDrivers (
    VOID
    );

BOOL
AppendDynamicSuppliedDrivers (
    IN      PCTSTR DriversPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\init9x.h ===
#ifndef _INIT9X_H
#define _INIT9X_H

//
// Init routines to be called by w95upg.dll or tools that use the
// upgrade code (such as hwdatgen.exe).
//

BOOL
FirstInitRoutine (
    HINSTANCE hInstance
    );

BOOL
InitLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
FinalInitRoutine (
    VOID
    );

VOID
FirstCleanupRoutine (
    VOID
    );

VOID
TerminateLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

VOID
FinalCleanupRoutine (
    VOID
    );

BOOL
DeferredInit (
    HWND WizardPageHandle
    );

//
// Interface specifically for WINNT32.EXE
//

DWORD
Winnt32Init (
    IN PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK Info
    );

DWORD
Winnt32WriteParamsWorker (
    IN      PCTSTR WinntSifFile
    );

VOID
Winnt32CleanupWorker (
    VOID
    );

BOOL
Winnt32SetAutoBootWorker (
    IN    INT DrvLetter
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\hash.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    ovidiut     11-Oct-1999 Updated for new coding conventions and Win64 compliance

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define CASE_SENSITIVE      TRUE
#define CASE_INSENSITIVE    FALSE

#define UNKNOWN_LETTER_CASE FALSE
#define ALREADY_LOWERCASE   TRUE

#define DEFAULT_BUCKET_SIZE 0

//
// Types
//

typedef const void *HASHTABLE;

typedef const void *HASHITEM;

typedef struct {

    PCSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMA, *PHASHTABLE_ENUMA;

typedef struct {
    PCWSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMW, *PHASHTABLE_ENUMW;

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEA)(
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEW)(
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCWSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    );

typedef enum {
    WRITE_UNICODE_HEADER    = 0x0001,
    REVERSE_ORDER           = 0x0002
} HASHTABLEOUTPUTFLAGS;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes and wrapper macros
//

HASHTABLE
HtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT BucketCount            OPTIONAL
    );

#define HtAllocA()                                  HtAllocExAW(FALSE,FALSE,FALSE,0,0)
#define HtAllocW()                                  HtAllocExAW(FALSE,TRUE,FALSE,0,0)

#define HtAllocWithDataA(size)                      HtAllocExAW(FALSE,FALSE,FALSE,size,0)
#define HtAllocWithDataW(size)                      HtAllocExAW(FALSE,TRUE,FALSE,size,0)

#define HtAllocExA(cs,datasize,bucketcount)         HtAllocExAW(cs,FALSE,FALSE,datasize,bucketcount)
#define HtAllocExW(cs,datasize,bucketcount)         HtAllocExAW(cs,TRUE,FALSE,datasize,bucketcount)

#define HtAllocExternStrA()                         HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrW()                         HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrWithDataA(size)             HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrWithDataW(size)             HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrExA(cs,size,bucketcount)    HtAllocExAW(cs,FALSE,TRUE,size,bucketcount)
#define HtAllocExternStrExW(cs,size,bucketcount)    HtAllocExAW(cs,TRUE,TRUE,size,bucketcount)

VOID
HtFree (
    IN      HASHTABLE HashTable
    );

HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringA(table,string)              HtAddStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataA(table,string,data)  HtAddStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringW(table,string)              HtAddStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataW(table,string,data)  HtAddStringExW(table,string,data,UNKNOWN_LETTER_CASE)

BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    );

BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    );

BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    );


HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringA(table,string)             HtFindStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataA(table,string,data) HtFindStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringW(table,string)             HtFindStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataW(table,string,data) HtFindStringExW(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR StringStart,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixA(table,str,end)    HtFindPrefixExA(table,str,end,NULL,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR StringStart,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixW(table,str,end)     HtFindPrefixExW(table,str,end,NULL,UNKNOWN_LETTER_CASE)

BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    );

BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    );

BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    );

PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Index
    );

PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Index
    );

BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    );

BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    );


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    );

BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    );

BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    );

BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    );

BOOL
HtIsEmpty (
    IN      HASHTABLE HashTable
    );


BOOL
HtWriteToFile (
    IN      HASHTABLE HashTable,
    IN      HANDLE OutputFile,
    IN      HASHTABLEOUTPUTFLAGS Flags
    );


//
// Macro expansion definition
//

// None

//
// A & W macros
//

#ifdef UNICODE

#define HASHTABLE_ENUM              HASHTABLE_ENUMW
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMW
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEW
#define HtAlloc                     HtAllocW
#define HtAllocWithData             HtAllocWithDataW
#define HtAllocEx                   HtAllocExW
#define HtAllocExternStr            HtAllocExternStrW
#define HtAllocExternStrWithData    HtAllocExternStrWithDataW
#define HtAllocExternStrEx          HtAllocExternStrExW
#define HtAddString                 HtAddStringW
#define HtAddStringAndData          HtAddStringAndDataW
#define HtAddStringEx               HtAddStringExW
#define HtRemoveString              HtRemoveStringW
#define HtFindString                HtFindStringW
#define HtFindStringAndData         HtFindStringAndDataW
#define HtFindStringEx              HtFindStringExW
#define HtFindPrefix                HtFindPrefixW
#define HtFindPrefixEx              HtFindPrefixExW
#define HtGetStringFromItem         HtGetStringFromItemW
#define EnumFirstHashTableString    EnumFirstHashTableStringW
#define EnumNextHashTableString     EnumNextHashTableStringW
#define EnumHashTableWithCallback   EnumHashTableWithCallbackW

#else

#define HASHTABLE_ENUM              HASHTABLE_ENUMA
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMA
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEA
#define HtAlloc                     HtAllocA
#define HtAllocWithData             HtAllocWithDataA
#define HtAllocEx                   HtAllocExA
#define HtAllocExternStr            HtAllocExternStrA
#define HtAllocExternStrWithData    HtAllocExternStrWithDataA
#define HtAllocExternStrEx          HtAllocExternStrExA
#define HtAddString                 HtAddStringA
#define HtAddStringAndData          HtAddStringAndDataA
#define HtAddStringEx               HtAddStringExA
#define HtRemoveString              HtRemoveStringA
#define HtFindString                HtFindStringA
#define HtFindStringAndData         HtFindStringAndDataA
#define HtFindStringEx              HtFindStringExA
#define HtFindPrefix                HtFindPrefixA
#define HtFindPrefixEx              HtFindPrefixExA
#define HtGetStringFromItem         HtGetStringFromItemA
#define EnumFirstHashTableString    EnumFirstHashTableStringA
#define EnumNextHashTableString     EnumNextHashTableStringA
#define EnumHashTableWithCallback   EnumHashTableWithCallbackA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\inf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    inf.h

Abstract:

    Declares interface for INF wrapper routines.  These routines simplify
    access of INFs by wrapping the setup APIs with routines that use
    pools or grow buffers.

    The INF wrapper routines also implement append and replace capabilities,
    so any INF used by the Win9x upgrade can be appended in the future, or
    completely replaced.

Author:

    Marc R. Whitten (marcw) 20-Oct-1997

Revision History:

    jimschm     05-Jan-1999     INF parser moved to migutil
    marcw       28-Oct-1998     Append/Replace capability
    marcw       08-Aug-1997     Pool/Growbuf routines

--*/


typedef enum {
    INF_USE_POOLHANDLE,
    INF_USE_GROWBUFFER,
    INF_USE_PRIVATE_GROWBUFFER,
    INF_USE_PRIVATE_POOLHANDLE
} ALLOCATORTYPES;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    POOLHANDLE      PoolHandle;
    ALLOCATORTYPES  Allocator;
    PCSTR           KeyName;
} INFSTRUCTA, *PINFSTRUCTA;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    POOLHANDLE      PoolHandle;
    ALLOCATORTYPES  Allocator;
    PCWSTR          KeyName;
} INFSTRUCTW, *PINFSTRUCTW;

#define INFCONTEXT_INIT {NULL,NULL,0,0}
#define INITINFSTRUCT_GROWBUFFER {INFCONTEXT_INIT,GROWBUF_INIT,NULL,INF_USE_PRIVATE_GROWBUFFER,NULL}
#define INITINFSTRUCT_POOLHANDLE {INFCONTEXT_INIT,GROWBUF_INIT,NULL,INF_USE_PRIVATE_POOLHANDLE,NULL}
#define InfOpenAppendInfFile    SetupOpenAppendInfFile


extern PBOOL g_UpginfsUpdated;


VOID
InfCleanUpInfStructA (
    PINFSTRUCTA Context
    );

VOID
InfCleanUpInfStructW (
    PINFSTRUCTW Context
    );

VOID
InitInfStructA (
    OUT PINFSTRUCTA Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle  OPTIONAL
    );

VOID
InitInfStructW (
    OUT PINFSTRUCTW Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle  OPTIONAL
    );



#define InfOpenInfFileA(f)              SETTRACKCOMMENT(HINF,"InfOpenInfFile",__FILE__,__LINE__)\
                                        RealInfOpenInfFileA((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

#define InfOpenInfFileW(f)              SETTRACKCOMMENT(HINF,"InfOpenInfFile",__FILE__,__LINE__)\
                                        RealInfOpenInfFileW((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT



HINF
RealInfOpenInfFileA (
    IN PCSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

HINF
RealInfOpenInfFileW (
    IN PCWSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

VOID
InfCloseInfFile (HINF Inf);

//
// See the macros below before calling InfOpenInfInAllSourcesA or W.
//
HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    );

HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    );

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCTA
    );


PWSTR
InfGetLineTextW (
    IN OUT  PINFSTRUCTW
    );

PSTR
InfGetStringFieldA (
    IN OUT PINFSTRUCTA  Context,
    IN     UINT         FieldIndex
    );

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCTW  Context,
    IN     UINT         FieldIndex
    );

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCTA     Context,
    IN     UINT            FieldIndex
    ) ;

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCTW     Context,
    IN     UINT            FieldIndex
    ) ;


BOOL
InfGetIntFieldA (
    IN PINFSTRUCTA     Context,
    IN UINT            FieldIndex,
    IN PINT            Value
    );

BOOL
InfGetIntFieldW (
    IN PINFSTRUCTW     Context,
    IN UINT            FieldIndex,
    IN PINT            Value
    );

PBYTE
InfGetBinaryFieldA (
    IN  PINFSTRUCTA    Context,
    IN  UINT           FieldIndex
    );

PBYTE
InfGetBinaryFieldW (
    IN  PINFSTRUCTW    Context,
    IN  UINT           FieldIndex
    );

BOOL
InfGetLineByIndexA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN DWORD            Index,
    OUT PINFSTRUCTA     Context
);

BOOL
InfGetLineByIndexW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN DWORD            Index,
    OUT PINFSTRUCTW     Context
);

BOOL
InfFindFirstLineA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN PCSTR            Key,
    OUT PINFSTRUCTA     Context
    );

BOOL
InfFindFirstLineW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN PCWSTR           Key,
    OUT PINFSTRUCTW     Context
    );

BOOL
InfFindNextLineA (
    IN OUT PINFSTRUCTA  Context
    );

BOOL
InfFindNextLineW (
    IN OUT PINFSTRUCTW  Context
    );

UINT
InfGetFieldCountA (
    IN PINFSTRUCTA      Context
    );

UINT
InfGetFieldCountW (
    IN PINFSTRUCTW      Context
    );


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCTA Context,
    IN      UINT Field
    );

BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PTSTR ReturnBuffer,
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize
    );

VOID
InfResetInfStructA (
    IN OUT PINFSTRUCTA Context
    );

VOID
InfResetInfStructW (
    IN OUT PINFSTRUCTW Context
    );



//
// INF parser
//

typedef struct _tagINFLINE {
    PCWSTR Key;             OPTIONAL
    PCWSTR Data;
    DWORD LineFlags;
    struct _tagINFLINE *Next, *Prev;
    struct _tagINFSECTION *Section;
} INFLINE, *PINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagINFSECTION {
    PCWSTR Name;
    PINFLINE FirstLine;
    PINFLINE LastLine;
    UINT LineCount;
    struct _tagINFSECTION *Next, *Prev;
} INFSECTION, *PINFSECTION;

PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    );

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    );


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    );

PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    );

PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    );

PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    );

PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    );

PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    );

UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    );

BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    );

BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    );

HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileA(Path) OpenInfFileExA (Path, NULL, TRUE)

HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileW(Path) OpenInfFileExW (Path, NULL, TRUE)

VOID
CloseInfFile (
    HINF InfFile
    );

BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    );

BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    );

VOID
InitInfReplaceTable (
    VOID
    );

//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#   define INFSTRUCT                        INFSTRUCTW
#   define PINFSTRUCT                       PINFSTRUCTW
#   define InfCleanUpInfStruct              InfCleanUpInfStructW
#   define InitInfStruct                    InitInfStructW
#   define InfResetInfStruct                InfResetInfStructW
#   define InfFindFirstLine                 InfFindFirstLineW
#   define InfFindNextLine                  InfFindNextLineW
#   define InfGetLineByIndex                InfGetLineByIndexW
#   define InfGetStringField                InfGetStringFieldW
#   define InfGetMultiSzField               InfGetMultiSzFieldW
#   define InfGetLineText                   InfGetLineTextW
#   define InfOpenInfFile                   InfOpenInfFileW
#   define InfGetOemStringField             InfGetStringFieldW
#   define InfGetIntField                   InfGetIntFieldW
#   define InfGetBinaryField                InfGetBinaryFieldW
#   define InfGetFieldCount                 InfGetFieldCountW
#   define SetupGetOemStringField           SetupGetStringFieldW
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesW((x),1,&g_SourceDirectory);
#   define AddInfSectionToTable             AddInfSectionToTableW
#   define FindInfSectionInTable            FindInfSectionInTableW
#   define AddInfLineToTable                AddInfLineToTableW
#   define FindLineInInfSection             FindLineInInfSectionW
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrW
#   define OpenInfFileEx                    OpenInfFileExW
#   define OpenInfFile                      OpenInfFileW
#   define SaveInfFile                      SaveInfFileW


#else

#   define INFSTRUCT                        INFSTRUCTA
#   define PINFSTRUCT                       PINFSTRUCTA
#   define InfCleanUpInfStruct              InfCleanUpInfStructA
#   define InitInfStruct                    InitInfStructA
#   define InfResetInfStruct                InfResetInfStructA
#   define InfFindFirstLine                 InfFindFirstLineA
#   define InfFindNextLine                  InfFindNextLineA
#   define InfGetLineByIndex                InfGetLineByIndexA
#   define InfGetStringField                InfGetStringFieldA
#   define InfGetMultiSzField               InfGetMultiSzFieldA
#   define InfGetLineText                   InfGetLineTextA
#   define InfOpenInfFile                   InfOpenInfFileA
#   define InfGetOemStringField             InfGetOemStringFieldA
#   define InfGetIntField                   InfGetIntFieldA
#   define InfGetBinaryField                InfGetBinaryFieldA
#   define InfGetFieldCount                 InfGetFieldCountA
#   define SetupGetOemStringField           SetupGetOemStringFieldA
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesA((x),g_SourceDirectoryCount,g_SourceDirectories);
#   define AddInfSectionToTable             AddInfSectionToTableA
#   define FindInfSectionInTable            FindInfSectionInTableA
#   define AddInfLineToTable                AddInfLineToTableA
#   define FindLineInInfSection             FindLineInInfSectionA
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrA
#   define OpenInfFileEx                    OpenInfFileExA
#   define OpenInfFile                      OpenInfFileA
#   define SaveInfFile                      SaveInfFileA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\initnt.h ===
#ifndef _INITNT_H
#define _INITNT_H

//
// Init routines to be called by w95upg.dll or tools that use the
// upgrade code (such as hwdatgen.exe).
//

BOOL
FirstInitRoutine (
    HINSTANCE hInstance
    );

BOOL
InitLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
FinalInitRoutine (
    VOID
    );

VOID
FirstCleanupRoutine (
    VOID
    );

VOID
TerminateLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

VOID
FinalCleanupRoutine (
    VOID
    );

//
// Interface specifically for syssetup.dll
//

BOOL
SysSetupInit (
    IN  HWND hwndWizard,
    IN  PCWSTR UnattendFile,
    IN  PCWSTR SourceDir
    );

VOID
SysSetupTerminate (
    VOID
    );

BOOL
PerformMigration (
    IN  HWND hwndWizard,
    IN  PCWSTR UnattendFile,
    IN  PCWSTR SourceDir            // i.e. f:\i386
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\ismig.h ===
/*++

Module Name:

    ismig.h

Abstract:

    Header file for InstallSheild log file DLL.

Author:

    Tyler Robinson      17-Feb-1999

Revision History:

    <alias> <date> <comments>

--*/



/*++

Routine Description:

  ISUMigrate

Arguments:

  ISUFileName    - Pointer to a nul-terminated string that specifies the
                   full path and filename to the ISU file to be migrated. The
                   file must exist and the ISMIGRATE.DLL must have read/write
                   access.
  SearchMultiSz  - Pointer to a nul-separated double-nul terminated string
                   that specifies the strings to be replaced.
  ReplaceMultiSz - Pointer to a nul-terminated string that specifies the
                   location to be used for temporary manipulation of files.
                   The location must exist and the ISMIGRATE.DLL must have
                   read/write access.

Return Value:

  Win32 status code

--*/

typedef INT (WINAPI ISUMIGRATE)(
            PCSTR ISUFileName,      // pointer to ISU full filename
            PCSTR SearchMultiSz,    // pointer to strings to find
            PCSTR ReplaceMultiSz,   // pointer to strings to replace
            PCSTR TempDir           // pointer to the path of the temp dir
            );
typedef ISUMIGRATE * PISUMIGRATE;


/*++

Routine Description:

  This function can be used to find all the strings in an .ISU file

Arguments:

  ISUFileName - Specifies nul-terminated string that specifies the full path
                and filename to the ISU file from which the strings are to be
                read. The file must exist and the ISMIGRATE.DLL must have
                read/write access.

Return Value:

  If the function succeeds the return value is a HGLOBAL which contain all the
  strings in the .ISU file. The strings are nul-separated and double-nul
  terminated. It is the responsibility of the caller to free this HGLOBAL.

--*/

typedef HGLOBAL (WINAPI ISUGETALLSTRINGS)(PCSTR ISUFileName);
typedef ISUGETALLSTRINGS * PISUGETALLSTRINGS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\masterhw.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    masterhw.h

Abstract:

    Includes header files needed to use w95upg\hwcomp.

Author:

    Jim Schmidt (jimschm)   26-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// includes for tools that use hwcomp
//

#include <winnt32p.h>

#include "hwcomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\linkpif.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    linkpif.h

Abstract:

    Implements routines to manage .LNK and .PIF files.  This
    is a complete redesign from the work that MikeCo did.

Author:

    Calin Negreanu (calinn)     23-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct _LNK_EXTRA_DATAA {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    CHAR    FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAA, *PLNK_EXTRA_DATAA;

typedef struct _LNK_EXTRA_DATAW {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    WCHAR   FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAW, *PLNK_EXTRA_DATAW;

BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
ExtractPifInfoA(
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     BOOL  *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData,      OPTIONAL
    IN      PCSTR FileName
    );

BOOL
ExtractPifInfoW(
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     BOOL   *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData,      OPTIONAL
    IN      PCWSTR FileName
    );

BOOL
ExtractShellLinkInfoA (
    OUT     PSTR   Target,
    OUT     PSTR   Params,
    OUT     PSTR   WorkDir,
    OUT     PSTR   IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     PINT ShowMode,                  OPTIONAL
    IN      PCSTR  FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShellLinkInfoW (
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     PINT ShowMode,                  OPTIONAL
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoA (
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL  *DosApp,
    OUT     BOOL  *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAA ExtraData,     OPTIONAL
    IN      PCSTR FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoW (
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     BOOL   *DosApp,
    OUT     BOOL   *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAW ExtraData,     OPTIONAL
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

PVOID
FindEnhPifSignature (
    IN      PVOID FileImage,
    IN      PCSTR Signature
    );

#ifdef UNICODE

#define InitCOMLink             InitCOMLinkW
#define FreeCOMLink             FreeCOMLinkW
#define ExtractPifInfo          ExtractPifInfoW
#define ExtractShellLinkInfo    ExtractShellLinkInfoW
#define ExtractShortcutInfo     ExtractShortcutInfoW
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAW
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAW

#else

#define InitCOMLink             InitCOMLinkA
#define FreeCOMLink             FreeCOMLinkA
#define ExtractPifInfo          ExtractPifInfoA
#define ExtractShellLinkInfo    ExtractShellLinkInfoA
#define ExtractShortcutInfo     ExtractShortcutInfoA
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAA
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\ipc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ipc.h

Abstract:

    Implements IPC interface to allow setup to talk with migisol.exe,
    in order to run migration DLLs in separate processes.

Author:

    Jim Schmidt (jimschm)   28-Mar-1997

Revision History:

    jimschm 23-Sep-1998     Changed from mailslots to memory mapped files

--*/


#pragma once

BOOL
OpenIpcW (
    IN      BOOL Win95Side,
    IN      PCWSTR ExePath,                 OPTIONAL
    IN      PCWSTR MigrationDllPath,        OPTIONAL
    IN      PCWSTR WorkingDir               OPTIONAL
    );

BOOL
OpenIpcA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR MigrationDllPath,         OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    );

DWORD
CheckForWaitingData (
    IN      HANDLE Slot,
    IN      DWORD MinimumSize,
    IN      DWORD Timeout
    );

BOOL
IsIpcProcessAlive (
    VOID
    );

VOID
KillIpcProcess (
    VOID
    );

BOOL
SendIpcCommand (
    IN      DWORD Command,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

BOOL
GetIpcCommandResults (
    IN      DWORD Timeout,
    OUT     PBYTE *ReturnData,      OPTIONAL
    OUT     PDWORD ReturnDataSize,  OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    );

BOOL
GetIpcCommand (
    IN      DWORD Timeout,
    IN      PDWORD Command,         OPTIONAL
    IN      PBYTE *Data,            OPTIONAL
    IN      PDWORD DataSize         OPTIONAL
    );

BOOL
SendIpcCommandResults (
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

#define IPC_GET_RESULTS_WIN9X       1000
#define IPC_GET_RESULTS_NT          7500
#define IPC_GET_COMMAND_WIN9X       10000
#define IPC_GET_COMMAND_NT          10000




#ifdef UNICODE
#define OpenIpc OpenIpcW
#else
#define OpenIpc OpenIpcA
#endif

VOID
CloseIpc (
    VOID
    );

typedef LONG (WINAPI WINVERIFYTRUST_PROTOTYPE)(HWND hwnd, GUID *ActionId, PVOID Data);
typedef WINVERIFYTRUST_PROTOTYPE * WINVERIFYTRUST;

BOOL
IsDllSignedA (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCSTR DllSpec
    );

BOOL
IsDllSignedW (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCWSTR DllSpec
    );

#ifdef UNICODE
#define IsDllSigned IsDllSignedW
#else
#define IsDllSigned IsDllSignedA
#endif


//
// Remote commands
//

#define IPC_QUERY           1
#define IPC_INITIALIZE      2
#define IPC_MIGRATEUSER     3
#define IPC_MIGRATESYSTEM   4
#define IPC_TERMINATE       5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\master.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    master.h

Abstract:

    Includes the headers needed throughout the Win9x upgrade
    project.  This applies to both setup DLLs and all tools.

Author:

    Jim Schmidt (jimschm) 06-Jan-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "chartype.h"

#define COBJMACROS


//
// Windows
//

#include <windows.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <shlobj.h>
#include <objidl.h>
#include <mmsystem.h>

//
// Setup
//

#include <setupbat.h>
#include <sputils.h>

//
// Common includes
//

#include "common.h"
#include "migutil.h"
#include "fileenum.h"
#include "memdb.h"
#include "unattend.h"
#include "progbar.h"
#include "regops.h"
#include "fileops.h"
#include "win95reg.h"
#include "snapshot.h"
#include "linkpif.h"
#include "safemode.h"
#include "cablib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\log.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    log.h

Abstract:

    Implements routines that simplify the writing to setupact.log
    and setuperr.log.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    mikeco      23-May-1997     Ran code through train_wreck.exe
    Ovidiu Temereanca (ovidiut) 23-Oct-1998
        Added new logging capabilities

*/


//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
#ifndef DBG
#define DBG
#endif
#endif

//
// Redefine MYASSERT
//

#ifdef DEBUG

#ifdef MYASSERT
#undef MYASSERT
#endif

#define DBG_ASSERT          "Assert"

#define MYASSERT(expr)      LogIfA(                                     \
                                !(expr),                                \
                                DBG_ASSERT,                             \
                                "Assert Failure\n\n%s\n\n%s line %u",   \
                                #expr,                                  \
                                __FILE__,                               \
                                __LINE__                                \
                                );

#else

#ifndef MYASSERT
#define MYASSERT(x)
#endif

#endif

#define LOG_FATAL_ERROR   "Fatal Error"
#define LOG_ERROR         "Error"
#define LOG_WARNING       "Warning"
#define LOG_INFORMATION   "Info"
#define LOG_ACCOUNTS      "Accounts"
#define LOG_CONFIG        "Configuration"

BOOL
LogInit (
    IN      HWND LogPopupParentWnd
    );

BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    );


VOID
LogExit (
    VOID
    );

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title
    );

VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title
    );

VOID
LogLineA (
    IN      PCSTR Line
    );

VOID
LogLineW (
    IN      PCWSTR Line
    );

VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );

VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    );

#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    );

#endif

// Define W symbols

#define LOGW(x) LogW x
#define LOGW_IF(x) LogIfW x
#define ELSE_LOGW(x) else{LogW x;}
#define ELSE_LOGW_IF(x) else{LogIfW x;}
#define LOGTITLEW(type,title) LogTitleW (type,title)
#define LOGLINEW(title) LogLineW (title)
#define LOGDIRECTW(type,text) LogDirectW (type,text)

// Define A symbols

#define LOGA(x) LogA x
#define LOGA_IF(x) LogIfA x
#define ELSE_LOGA(x) else{LogA x;}
#define ELSE_LOGA_IF(x) else{LogIfA x;}
#define LOGTITLEA(type,title) LogTitleA (type,title)
#define LOGLINEA(line) LogLineA (line)
#define LOGDIRECTA(type,text) LogDirectA (type,text)

// Define generic symbols

#ifdef UNICODE

#define LOG(x) LOGW(x)
#define LOG_IF(x) LOGW_IF(x)
#define ELSE_LOG(x) ELSE_LOGW(x)
#define ELSE_LOG_IF(x) ELSE_LOGW_IF(x)
#define LOGTITLE(type,title) LOGTITLEW(type,title)
#define LOGLINE(title) LOGLINEW(title)
#define LOGDIRECT(type,text) LOGDIRECTW(type,text)

#else

#define LOG(x) LOGA(x)
#define LOG_IF(x) LOGA_IF(x)
#define ELSE_LOG(x) ELSE_LOGA(x)
#define ELSE_LOG_IF(x) ELSE_LOGA_IF(x)
#define LOGTITLE(type,title) LOGTITLEA(type,title)
#define LOGLINE(title) LOGLINEA(title)
#define LOGDIRECT(type,text) LOGDIRECTA(type,text)

#endif // UNICODE


#ifdef DEBUG

#define DBG_NAUSEA      "Nausea"
#define DBG_VERBOSE     "Verbose"
#define DBG_STATS       "Stats"
#define DBG_WARNING     "Warning"
#define DBG_ERROR       "Error"
#define DBG_WHOOPS      "Whoops"
#define DBG_TRACK       "Track"
#define DBG_TIME        "Time"

extern CHAR g_DebugInfPathBufA[];
extern WCHAR g_DebugInfPathBufW[];
#define g_DebugInfPath  g_DebugInfPathBufA
#define g_DebugInfPathA g_DebugInfPathBufA
#define g_DebugInfPathW g_DebugInfPathBufW

extern BOOL g_ResetLog;             // Defined in log.c
#define SET_RESETLOG()   g_ResetLog = TRUE
#define CLR_RESETLOG()   g_ResetLog = FALSE
#define RESETLOG()       (g_ResetLog)

extern BOOL g_DoLog;                // Defined in log.c
#define SET_DOLOG()     g_DoLog = TRUE
#define CLR_DOLOG()     g_DoLog = FALSE
#define DOLOG()         (g_DoLog)


#ifndef PROGRESS_BAR

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    );

#endif


// Define W symbols

#define DEBUGMSGW(x) LogW x
#define DEBUGMSGW_IF(x) LogIfW x
#define ELSE_DEBUGMSGW(x) else LogW x
#define ELSE_DEBUGMSGW_IF(x) else LogW x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEW(x) LogTime x
#else
#define DEBUGLOGTIMEW(x) DebugLogTimeW x
#endif


// Define A symbols

#define DEBUGMSGA(x) LogA x
#define DEBUGMSGA_IF(x) LogIfA x
#define ELSE_DEBUGMSGA(x) else LogA x
#define ELSE_DEBUGMSGA_IF(x) else LogIfA x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEA(x) LogTime x
#else
#define DEBUGLOGTIMEA(x) DebugLogTimeA x
#endif

// Define generic symbols

#ifdef UNICODE

#define DEBUGMSG(x) DEBUGMSGW(x)
#define DEBUGMSG_IF(x) DEBUGMSGW_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGW(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGW_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEW(x)

#else

#define DEBUGMSG(x) DEBUGMSGA(x)
#define DEBUGMSG_IF(x) DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGA_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEA(x)

#endif // UNICODE

#else // !defined(DEBUG)

//
// No-debug constants
//

#define SET_RESETLOG()
#define CLR_RESETLOG()
#define RESETLOG()

#define SET_DOLOG()
#define CLR_DOLOG()
#define DOLOG()

#define SETTRACKCOMMENT(RetType,Msg,File,Line)
#define CLRTRACKCOMMENT
#define SETTRACKCOMMENT_VOID(Msg,File,Line)
#define CLRTRACKCOMMENT_VOID
#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define DEBUGMSG(x)
#define DEBUGMSGA(x)
#define DEBUGMSGW(x)

#define DEBUGMSG_IF(x)
#define DEBUGMSGA_IF(x)
#define DEBUGMSGW_IF(x)

#define ELSE_DEBUGMSG(x)
#define ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSGW(x)

#define ELSE_DEBUGMSG_IF(x)
#define ELSE_DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSGW_IF(x)

#ifdef PROGRESS_BAR
#define DEBUGLOGTIME(x) LogTime x
#else
#define DEBUGLOGTIME(x)
#endif

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\master9x.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    master9x.h

Abstract:

    Includes headers needed for w95upg.dll only

Author:

    Jim Schmidt (jimschm)   26-Mar-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// includes for code that runs only on Win9x
//

#include <ras.h>
#include <pif.h>        /* windows\inc */
#include <tlhelp32.h>

#include <winnt32p.h>

#include <synceng.h>    /* private\inc */

#include "init9x.h"
#include "migui.h"
#include "w95upg.h"
#include "buildinf.h"
#include "w95res.h"
#include "config.h"
#include "migdlls.h"
#include "hwcomp.h"
#include "sysmig.h"
#include "msgmgr.h"
#include "migapp.h"
#include "rasmig.h"
#include "dosmig.h"
#include "drives.h"
#include "timezone.h"
#include "migdb.h"


#ifdef PRERELEASE

#include "w95resp.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\masternt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    masternt.h

Abstract:

    Includes all the header files specific to w95upgnt.dll.

Author:

    Jim Schmidt (jimschm)   26-Mar-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include <userenv.h>
#include <lm.h>
#include <ntsecapi.h>
#include <netlogon.h>       // private\inc
#include <userenvp.h>
#include <pif.h>            // windows\inc
#include <cmnres.h>         // setup\inc
/*
#include <shlobj.h>         // 
#include <shlapip.h>        // windows\inc
*/
#include <limits.h>
#include <linkinfo.h>
#define _SYNCENG_           // for synceng.h
#include <synceng.h>        // private\inc

//
// includes for code that runs only on WinNT
//

#include "initnt.h"
#include "w95upgnt.h"
#include "migmain.h"
#include "ntui.h"
#include "winntreg.h"
#include "plugin.h"
#include "dosmignt.h"
#include "merge.h"
#include "rasmignt.h"
#include "tapimig.h"
#include "object.h"
#include "rulehlpr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\migdlls.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migdlls.h

Abstract:

    Declares the types and interfaces to the migration DLL
    interface code.  This includes the routines that find the
    migration DLLs, routines that execute the DLLs, and
    routines to enumerate the DLLs that are valid.

Author:

    Jim Schmidt (jimschm)   12-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/


#include "plugin.h"

//
// Data structure maintained for each migration DLL
//

typedef struct _tagMIGDLL {
    struct _tagMIGDLL *Next;

    LONG Id;
    PCSTR ProductId;
    PVENDORINFO VendorInfo;
    PCSTR WorkingDir;
    UINT Version;
    PCSTR OriginalDir;
    PCSTR MigrateInfPath;
    BOOL WantsToRunOnNt;
    HANDLE MigInfAppend;
    PCSTR LastFnName;           // used for error messages
} MIGRATION_DLL_PROPS, *PMIGRATION_DLL_PROPS;

typedef struct {
    PCSTR ProductId;
    PVENDORINFO VendorInfo;
    PCSTR CurrentDir;
    LONG Id;

    PMIGRATION_DLL_PROPS AllDllProps;
} MIGDLL_ENUM, *PMIGDLL_ENUM;



//
// Globals needed by migration DLL code
//

extern BOOL g_UseMigIsol;

//
// Externally called functions
//

BOOL
BeginMigrationDllProcessing (
    VOID
    );

DWORD
EndMigrationDllProcessing (
    IN      DWORD Request
    );

UINT
ScanPathForMigrationDlls (
    IN      PCSTR PathSpec,
    IN      HANDLE CancelEvent,     OPTIONAL
    OUT     PBOOL MatchFound        OPTIONAL
    );

BOOL
ProcessDll (
    IN      PMIGDLL_ENUM EnumPtr
    );

DWORD
ProcessDllsOnCd (
    DWORD Request
    );

VOID
RemoveDllFromList (
    IN      LONG Id
    );

DWORD
ProcessAllLocalDlls (
    DWORD Request
    );

BOOL
UpdateFileSearch (
    IN      PCSTR FullFileSpec,
    IN      PCSTR FileOnly
    );

UINT
GetMigrationDllCount (
    VOID
    );

UINT
GetMediaMigrationDllCount (
    VOID
    );

UINT
GetTotalMigrationDllCount (
    VOID
    );


BOOL
EnumFirstMigrationDll (
    OUT     PMIGDLL_ENUM EnumPtr
    );

BOOL
EnumNextMigrationDll (
    IN OUT  PMIGDLL_ENUM EnumPtr
    );

typedef struct {
    TCHAR   Path[MAX_TCHAR_PATH];

    //
    // Internal enumeration members
    //

    TCHAR   Node[MEMDB_MAX];            // contains MemDb node of suppress value
    HKEY    Key;
    REGVALUE_ENUM eValue;
} PRELOADED_DLL_ENUM, *PPRELOADED_DLL_ENUM;


BOOL
EnumFirstPreLoadedDll (
    OUT     PPRELOADED_DLL_ENUM e
    );

BOOL
EnumNextPreLoadedDll (
    IN OUT  PPRELOADED_DLL_ENUM e
    );

VOID
AbortPreLoadedDllEnum (
    IN OUT  PPRELOADED_DLL_ENUM e
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\migapp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migapp.h

Abstract:

    This file declares the public interfaces into the migapp lib.
    See w95upg\migapp for implementation.

    NOTE: There are other files that are more useful for this lib,
          such as migdb.h.

Author:

    Mike Condra (mikeco)        18-Aug-1996


Revision History:

    jimschm 23-Nov-1998     Remove abandoned mikeco stuff
    calinn  12-Feb-1998     A lot of cleanup

--*/

#pragma once

BOOL
IsDriveRemoteOrSubstituted(
        UINT nDrive,            // 'A'==1, etc.
        BOOL *fRemote,
        BOOL *fSubstituted
        );

BOOL
IsFloppyDrive (
    UINT nDrive
    );         // 'A'==1, etc.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\memdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdb.h

Abstract:

    Declares interfaces for memdb, the memory database.  MemDb is
    used throughout the Win9x upgrade project to record OS state
    and to track operations on files and the registry.

    See common\memdb for implementation details.

Author:

    Jim Schmidt (jimschm) 15-Nov-1996

Revision History:

    jimschm     05-Apr-1999     MemDbGetStoredEndPatternValue
    jimschm     18-Jan-1999     Version APIs
    jimschm     23-Sep-1998     Proxy node capability
    jimschm     24-Jun-1998     MemDbMove capability
    jimschm     30-Oct-1997     Temporary hive capability
    jimschm     31-Jul-1997     Hashing for faster access
    jimschm     19-Mar-1997     Binary node capability
    jimschm     28-Feb-1997     Offset access capabilities
    jimschm     20-Dec-1996     Ex routines

--*/

#pragma once

#define INVALID_OFFSET 0xffffffff

#include "memdbdef.h"

#define MEMDB_MAX 2048

//
// My net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//

#define SHI50F_ACLS         0x1000

typedef BYTE const * PCBYTE;


//
// Enumerator struct
//

#define MAX_ENUM_POS (MEMDB_MAX/2)

typedef struct {
    // Outbound key and value
    WCHAR szName[MEMDB_MAX];

    BOOL bEndpoint;
    BOOL bBinary;
    BOOL bProxy;
    DWORD UserFlags;

    // if !bBinary
    DWORD dwValue;

    // if bBinary
    PCBYTE BinaryPtr;
    DWORD BinarySize;

    DWORD Offset;

    // Internally maintained members
    WCHAR PatternStr[MEMDB_MAX];
    PWSTR PatPos;
    DWORD LastPos[MAX_ENUM_POS];
    int PosCount;
    int Depth;
    int Start;
    DWORD Flags;
} MEMDB_ENUMW, *PMEMDB_ENUMW;

typedef struct {
    // Outbound key and value
    CHAR szName[MEMDB_MAX * sizeof (WCHAR)];

    BOOL bEndpoint;
    BOOL bBinary;
    BOOL bProxy;
    DWORD UserFlags;

    // if !bBinary
    DWORD dwValue;

    // if bBinary
    PCBYTE BinaryPtr;
    DWORD BinarySize;

    DWORD Offset;

    // Internally maintained members
    WCHAR PatternStr[MEMDB_MAX];
    PWSTR PatPos;
    DWORD LastPos[MAX_ENUM_POS];
    int PosCount;
    int Depth;
    int Start;
    DWORD Flags;
} MEMDB_ENUMA, *PMEMDB_ENUMA;

// enumeration flags
#define NO_FLAGS                0x00000000
#define MEMDB_ALL_MATCHES       0
#define MEMDB_ENDPOINTS_ONLY    1
#define MEMDB_BINARY_NODES_ONLY 2
#define MEMDB_PROXY_NODES_ONLY  3
#define MEMDB_ALL_BUT_PROXY     4

// enumeration level
#define MEMDB_ALL_SUBLEVELS     0
#define MEMDB_THIS_LEVEL_ONLY   1

typedef struct {
    BOOL Valid;
    BOOL Debug;
    UINT Version;
    BOOL CurrentVersion;
} MEMDB_VERSION, *PMEMDB_VERSION;

//
// Function prototypes
//

BOOL MemDbSetValueA (PCSTR szKeyName, DWORD dwValue);
BOOL MemDbSetValueW (PCWSTR szKeyName, DWORD dwValue);

BOOL MemDbSetValueAndFlagsA (PCSTR szKeyName, DWORD dwValue, DWORD SetFlags, DWORD ClearFlags);
BOOL MemDbSetValueAndFlagsW (PCWSTR szKeyName, DWORD dwValue, DWORD SetFlags, DWORD ClearFlags);

BOOL MemDbSetBinaryValueA (PCSTR szKeyName, PCBYTE Data, DWORD DataSize);
BOOL MemDbSetBinaryValueW (PCWSTR szKeyName, PCBYTE Data, DWORD DataSize);

BOOL MemDbGetValueA (PCSTR szKeyName, PDWORD lpdwValue);
BOOL MemDbGetValueW (PCWSTR szKeyName, PDWORD lpdwValue);

BOOL MemDbGetValueAndFlagsA (PCSTR szKeyName, PDWORD lpdwValue, PDWORD UserFlagsPtr);
BOOL MemDbGetValueAndFlagsW (PCWSTR szKeyName, PDWORD lpdwValue, PDWORD UserFlagsPtr);

PCBYTE MemDbGetBinaryValueA (PCSTR szKeyName, PDWORD DataSize);
PCBYTE MemDbGetBinaryValueW (PCWSTR szKeyName, PDWORD DataSize);

BOOL MemDbGetPatternValueA (PCSTR szKey, PDWORD lpdwValue);
BOOL MemDbGetPatternValueW (PCWSTR szKey, PDWORD lpdwValue);

BOOL MemDbGetStoredEndPatternValueA (PCSTR Key, PDWORD Value);
BOOL MemDbGetStoredEndPatternValueW (PCWSTR Key, PDWORD Value);

BOOL MemDbGetValueWithPatternA (PCSTR szKeyPattern, PDWORD lpdwValue);
BOOL MemDbGetValueWithPatternW (PCWSTR szKeyPattern, PDWORD lpdwValue);

BOOL MemDbGetPatternValueWithPatternA (PCSTR szKeyPattern, PDWORD lpdwValue);
BOOL MemDbGetPatternValueWithPatternW (PCWSTR szKeyPattern, PDWORD lpdwValue);

void MemDbDeleteValueA (PCSTR szKey);
void MemDbDeleteValueW (PCWSTR szKey);

void MemDbDeleteTreeA (PCSTR szKey);
void MemDbDeleteTreeW (PCWSTR szKey);

BOOL MemDbEnumFirstValueA (PMEMDB_ENUMA pEnum, PCSTR szPattern, int Depth, DWORD Flags);
BOOL MemDbEnumFirstValueW (PMEMDB_ENUMW pEnum, PCWSTR szPattern, int Depth, DWORD Flags);

BOOL MemDbEnumNextValueA (PMEMDB_ENUMA pEnum);
BOOL MemDbEnumNextValueW (PMEMDB_ENUMW pEnum);

BOOL MemDbSaveA (PCSTR szFile);
BOOL MemDbSaveW (PCWSTR szFile);

BOOL MemDbLoadA (PCSTR szFile);
BOOL MemDbLoadW (PCWSTR szFile);

VOID MemDbBuildKeyA (PSTR Buffer, PCSTR Category,  PCSTR Item,  PCSTR Field,  PCSTR Data);
VOID MemDbBuildKeyW (PWSTR Buffer, PCWSTR Category, PCWSTR Item, PCWSTR Field, PCWSTR Data);

BOOL MemDbSetValueExA (PCSTR Category,  PCSTR Item,  PCSTR Field,
                       PCSTR Data, DWORD Val, PDWORD Offset);

BOOL MemDbSetValueExW (PCWSTR Category, PCWSTR Item, PCWSTR Field,
                       PCWSTR Data, DWORD Val, PDWORD Offset);

BOOL MemDbSetBinaryValueExA (PCSTR Category,  PCSTR Item,  PCSTR Field,
                             PCBYTE Data, DWORD DataSize, PDWORD Offset);

BOOL MemDbSetBinaryValueExW (PCWSTR Category, PCWSTR Item, PCWSTR Field,
                             PCBYTE Data, DWORD DataSize, PDWORD Offset);

BOOL MemDbBuildKeyFromOffsetA (DWORD Offset, PSTR Buffer, DWORD StartLevel, PDWORD Val);
BOOL MemDbBuildKeyFromOffsetW (DWORD Offset, PWSTR Buffer, DWORD StartLevel, PDWORD Val);

BOOL MemDbBuildKeyFromOffsetExA (DWORD Offset, PSTR Buffer, PDWORD BufferLen, DWORD StartLevel, PDWORD Val, PDWORD UserFlags);
BOOL MemDbBuildKeyFromOffsetExW (DWORD Offset, PWSTR Buffer, PDWORD BufferLen, DWORD StartLevel, PDWORD Val, PDWORD UserFlags);

BOOL MemDbGetOffsetA(PCSTR Key,PDWORD Offset);
BOOL MemDbGetOffsetW(PCWSTR Key,PDWORD Offset);

BOOL MemDbGetOffsetExA(PCSTR Category, PCSTR Item, PCSTR Field, PCSTR Data, PDWORD Offset);
BOOL MemDbGetOffsetExW(PCWSTR Category, PCWSTR Item, PCWSTR Field, PCWSTR Data, PDWORD Offset);

BOOL MemDbEnumItemsA  (PMEMDB_ENUMA pEnum, PCSTR  Category);
BOOL MemDbEnumItemsW  (PMEMDB_ENUMW pEnum, PCWSTR Category);

BOOL MemDbEnumFieldsA (PMEMDB_ENUMA pEnum, PCSTR  Category, PCSTR  Item);
BOOL MemDbEnumFieldsW (PMEMDB_ENUMW pEnum, PCWSTR Category, PCWSTR Item);

BOOL MemDbGetValueExA (PMEMDB_ENUMA pEnum, PCSTR  Category, PCSTR  Item,  PCSTR Field);
BOOL MemDbGetValueExW (PMEMDB_ENUMW pEnum, PCWSTR Category, PCWSTR Item, PCWSTR Field);

BOOL MemDbGetEndpointValueA (PCSTR Pattern, PCSTR Item, PSTR Buffer);
BOOL MemDbGetEndpointValueW (PCWSTR Pattern, PCWSTR Item, PWSTR Buffer);

BOOL MemDbGetEndpointValueExA (PCSTR Category, PCSTR Item, PCSTR Field, PSTR Buffer);
BOOL MemDbGetEndpointValueExW (PCWSTR Category, PCWSTR Item, PCWSTR Field, PWSTR Buffer);

BOOL MemDbValidateDatabase (VOID);

BOOL MemDbQueryVersionA (PCSTR FileName, PMEMDB_VERSION Version);
BOOL MemDbQueryVersionW (PCWSTR FileName, PMEMDB_VERSION Version);

BOOL MemDbCreateTemporaryKeyA (PCSTR KeyName);
BOOL MemDbCreateTemporaryKeyW (PCWSTR KeyName);

BOOL
MemDbMoveTreeA (
    IN      PCSTR RootNode,
    IN      PCSTR NewRoot
    );

BOOL
MemDbMoveTreeW (
    IN      PCWSTR RootNode,
    IN      PCWSTR NewRoot
    );

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbImportA (
    IN      PCSTR FileName
    );

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    );



#define MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1            0x0001
#define MEMDB_CONVERT_WILD_STAR_TO_ASCII_2              0x0002
#define MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3             0x0002
// other conversion to be implemented when needed

VOID MemDbMakeNonPrintableKeyA (PSTR KeyName, DWORD Flags);
VOID MemDbMakeNonPrintableKeyW (PWSTR KeyName, DWORD Flags);

VOID MemDbMakePrintableKeyA (PSTR KeyName, DWORD Flags);
VOID MemDbMakePrintableKeyW (PWSTR KeyName, DWORD Flags);

VOID GetFixedUserNameA (PSTR UserName);
VOID GetFixedUserNameW (PWSTR UserName);

//
// Internal routines for memdbt
//

typedef struct {
    UINT NextItem : 28;
    UINT Hive : 4;
} HASHINFO;

typedef struct _tagHASHSTRUCT {
    DWORD Offset;
    HASHINFO Info;
} BUCKETSTRUCT, *PBUCKETSTRUCT;

typedef struct {
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT Bucket;
    DWORD LastOffset;
} HASHENUM, *PHASHENUM;


BOOL
EnumFirstHashEntry (
    OUT     PHASHENUM HashEnum
    );

BOOL
EnumNextHashEntry (
    IN OUT  PHASHENUM HashEnum
    );

//
// A & W
//

#ifdef UNICODE

#define MEMDB_ENUM MEMDB_ENUMW
#define PMEMDB_ENUM PMEMDB_ENUMW

#define MemDbSetValue MemDbSetValueW
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsW
#define MemDbSetBinaryValue MemDbSetBinaryValueW
#define MemDbGetValue MemDbGetValueW
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsW
#define MemDbGetBinaryValue MemDbGetBinaryValueW
#define MemDbGetPatternValue MemDbGetPatternValueW
#define MemDbGetValueWithPattern MemDbGetValueWithPatternW
#define MemDbGetPatternValueWithPattern MemDbGetPatternValueWithPatternW
#define MemDbGetStoredEndPatternValue MemDbGetStoredEndPatternValueW
#define MemDbDeleteValue MemDbDeleteValueW
#define MemDbDeleteTree MemDbDeleteTreeW
#define MemDbEnumFirstValue MemDbEnumFirstValueW
#define MemDbEnumNextValue MemDbEnumNextValueW
#define MemDbSave MemDbSaveW
#define MemDbLoad MemDbLoadW
#define MemDbBuildKey MemDbBuildKeyW
#define MemDbSetValueEx MemDbSetValueExW
#define MemDbSetBinaryValueEx MemDbSetBinaryValueExW
#define MemDbBuildKeyFromOffset MemDbBuildKeyFromOffsetW
#define MemDbBuildKeyFromOffsetEx MemDbBuildKeyFromOffsetExW
#define MemDbGetOffset MemDbGetOffsetW
#define MemDbGetOffsetEx MemDbGetOffsetExW
#define MemDbEnumItems MemDbEnumItemsW
#define MemDbEnumFields MemDbEnumFieldsW
#define MemDbGetValueEx MemDbGetValueExW
#define MemDbGetEndpointValue MemDbGetEndpointValueW
#define MemDbGetEndpointValueEx MemDbGetEndpointValueExW
#define MemDbQueryVersion MemDbQueryVersionW
#define MemDbCreateTemporaryKey MemDbCreateTemporaryKeyW
#define MemDbMoveTree MemDbMoveTreeW
#define MemDbExport MemDbExportW
#define MemDbImport MemDbImportW
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyW
#define MemDbMakePrintableKey MemDbMakePrintableKeyW
#define GetFixedUserName GetFixedUserNameW

#else

#define MEMDB_ENUM MEMDB_ENUMA
#define PMEMDB_ENUM PMEMDB_ENUMA

#define MemDbSetValue MemDbSetValueA
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsA
#define MemDbSetBinaryValue MemDbSetBinaryValueA
#define MemDbGetValue MemDbGetValueA
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsA
#define MemDbGetBinaryValue MemDbGetBinaryValueA
#define MemDbGetPatternValue MemDbGetPatternValueA
#define MemDbGetValueWithPattern MemDbGetValueWithPatternA
#define MemDbGetPatternValueWithPattern MemDbGetPatternValueWithPatternA
#define MemDbGetStoredEndPatternValue MemDbGetStoredEndPatternValueA
#define MemDbDeleteValue MemDbDeleteValueA
#define MemDbDeleteTree MemDbDeleteTreeA
#define MemDbEnumFirstValue MemDbEnumFirstValueA
#define MemDbEnumNextValue MemDbEnumNextValueA
#define MemDbSave MemDbSaveA
#define MemDbLoad MemDbLoadA
#define MemDbBuildKey MemDbBuildKeyA
#define MemDbSetValueEx MemDbSetValueExA
#define MemDbSetBinaryValueEx MemDbSetBinaryValueExA
#define MemDbBuildKeyFromOffset MemDbBuildKeyFromOffsetA
#define MemDbBuildKeyFromOffsetEx MemDbBuildKeyFromOffsetExA
#define MemDbGetOffset MemDbGetOffsetA
#define MemDbGetOffsetEx MemDbGetOffsetExA
#define MemDbEnumItems MemDbEnumItemsA
#define MemDbEnumFields MemDbEnumFieldsA
#define MemDbGetValueEx MemDbGetValueExA
#define MemDbGetEndpointValue MemDbGetEndpointValueA
#define MemDbGetEndpointValueEx MemDbGetEndpointValueExA
#define MemDbQueryVersion MemDbQueryVersionA
#define MemDbCreateTemporaryKey MemDbCreateTemporaryKeyA
#define MemDbMoveTree MemDbMoveTreeA
#define MemDbExport MemDbExportA
#define MemDbImport MemDbImportA
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyA
#define MemDbMakePrintableKey MemDbMakePrintableKeyA
#define GetFixedUserName GetFixedUserNameA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\memdbdef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdbdef.h

Abstract:

    Defines the memdb categories for the Win9x upgrade project.
    All information that is transferred to the NT side of setup
    is placed in a memdb category.  The comments below document
    each category used.

Authors:

    Jim Schmidt (jimschm) 16-Dec-1996

Revision History:

    Many changes - see SLM log

--*/

#pragma once

/*

  MemDb Structure

  MemDb is a binary tree structure that the migration code uses to save
  instructions, lists, account information, and so on.  The stored information
  is combined into a path form, and the path can have an optional DWORD
  associated with it.

  A generalized structure of all data that we store in memdb can be
  expressed as:

  <category>\<item>\<field>\<data>=<val>

  category  - A hard-coded category, a MEMDB_CATEGORY constant

  item      - An item may be:

              1. A runtime-defined string
              2. A runtime-generated enumeration string
              3. A hard-coded string (rare)
              4. Unused

  field     - Usually a hard-coded field related to item.  The field
              is used to match several lines of data with a single item.
              In some cases, field is not used.

  data      - The string-based data that needs to be stored.

  val       - A DWORD associated with <data>.  Often this value is
              not used and is zero.


  In general, if a field for an item is missing, the field is considered
  empty.

  Because memdb is internally a binary tree, all pieces of a path are sorted.
  A frequent use of this characteristic is to make enumerators that are numeric
  strings with zero leaders (001, 002, etc).  Such enumerators maintain order
  of items.

  -----

  The following categories are defined:

  HKR\<regpath> = <flags>

        HKR is used to suppress migration of a registry key in a user's hive.
        This is used primarily by usermig.inf's SuppressValue rule.

        regpath  - The path to a registry key, and an optional value appended
                   in brackets (HKR\key [val]).

        flags - Specifies the merge flags for the key.  See regops.h.

  HKLM\<regpath> = <flags>

        HKLM is used to suppress migration of a registry key in a the system's hive.
        This is used primarily by wkstamig.inf's SuppressValue rule.

        regpath  - The path to a registry key, and an optional value appended
                   in brackets (HKR\key [val]).

        flags - Specifies the merge flags for the key.  See regops.h.

  FileEnumExcl\<hex-val>\<Paths|Files>\<path>

        FileEnumExcl is used to exclude files or paths from file enumeration
        in fileenum.lib.

        hex-val     - The hex representation of the exclusion group DWORD
        Paths|Files - Paths if <path> represents a path pattern to exclude
                      Files if <path> represents a file pattern to exclude

       See FileEnum source for more information.

  LinkEdit

        OPERATION_LINK_EDIT holds all info for editing a LNK or PIF file
        on NT side (or for creating a new LNK file as special case for
        converting PIFs to command.com)

  LinkStrings\<path>

        LinkStrings holds a list of link files that have command lines with
        GUID arguments.  See LinkGuids below.

        path - Specifies the .LNK path in long format

  LinkGuids\<guid>\<seq> = <offset>

        LinkGuids holds a list of GUIDs which is used in one or more .LNK
        command line arguments.

        guid - Specifies the GUID extracted from the .LNK command line arguments

        seq - A numerical sequencer used to allow a one-to-many mapping

        offset - The offset of a LinkStrings entry

  AdministratorInfo\account\<name>

        AdministratorInfo holds information describing the details necessary to
        migrate the NT administrator account.

        account - This item designates the Win9x account for the administrator.
                  If the account item is missing, the default Win9x account is used.
                  The account name is the fixed user name.

  UserDatLoc\<user>\<path> = <create only>

        UserDatLoc is used to track the location of each user's user.dat
        file.  It is used by migmain to load up a user's hive, and also
        to suppress processing of a user.  If an entry is not given for
        a particular user (including Administrator and the default user),
        the user will not be migrated.

        user - The fixed user name matched with the path

        path - The full RELOCATED path to user.dat for the user, in
               %windir%\setup\temp

        create only - Specifies 1 if this account is only for creation
                      (i.e., Administrator), or 0 for full migration.

  FixedUserNames\<orgname-encoded>\<newname>

        FixedUserNames maps the original name of a user to the new name,
        if the original name was incompatible with NT.

        orgname-encoded - Specifies the original user name, encoded with
                          MemDbMakeNonPrintableKey

        newname - Specifies the new user name that is compatible with
                  NT

  UserProfileExt\<user>\<ext>

        If a Win9x profile path has an extension on it, the extension
        is written to UserProfileExt.  Setup preserves the extension
        by appending it to the new profile path it creates.

        user - The fixed Win9x user name matched with the extension

        ext - The exact name of the user's profile folder, such as
              joeblow.001

        If an entry does not exist, then the fixed user name is used as
        the profile directory name.

  FileRename\<srcname>\<newname>

        FileRename holds a master list of all files on Win9x that are renamed
        during upgrade.  This list can only contain file names that can
        be located by the SearchPath API on Win9x.  During the upgrade,
        all registry references to the specific file are updated to use
        the new name.

        srcname - Specifies the file name that exists on Win9x

        newname - Specifies the new name of the file that has the same
                  functionality on Win9x but has a different name.


  MigDll\<item>\<field>\<path>

        MigDll is used to pass a list of migration DLLs from Win95 to NT.
        All DLLs in the MigDll category are loaded and executed in GUI
        mode setup.

        item   - A numeric enumerator

        field  - DLL:  <path> gives the path to the migration DLL
                 WD:   <path> gives the working directory for the DLL
                 DESC: <path> gives a text description, truncated to MAX_PATH
                       characters.

        path   - The DLL path, working directory or description.

  SIF Restrictions\section\pattern

        This section describes the sections and keys in the unattend file
        that migration dlls are not allowed to use. It is pattern based so,
        for example, MassStorageDrivers=* would indicate that no migration
        dll can create any key in the MassStorageDrivers section of the
        unattend file.

        section - a section. May not contain a pattern.
        pattern - a key pattern.

  SIF Values\value

        The values used by buildinf.


  SIF Sections\Section\Key Sequence\Value Sequence

        This section holds all of the sections and keys of an answer file.

        section      - the section within an answer file
        Key sequence - a stringified 7 digit number that maintains order between keys
                       in a section. The associated value with this key is the offset
                       into the keys section where the key text is located.
        Value sequence - a stringified 7 digit number that maintains order between values in
                        a section. The associated value with this okey is the offset
                        into the Answer File Values section where the value is located.

  Ras Migration Data for <User>\Entry\Item\Data

        This section holds information for migrating phone book entrys of users.

        User - the fixed user name of the user this refers to..

        Entry - The Phone book entry name

        Item  - The win95 item name

        data  - the data of that item.

  NetShares\<share>\<field>\<data>

        NetShares is used to hold all Win95 share information as extracted
        by NetShareEnum.  All details are specified for the share, although
        not all of them may be supported.

        share     - The share name as configured in Win95

        field     - Path:   <data> specifies the path to share
                    Remark: <data> specifies a user-defined remark
                    ACL:    <data> specifies one or more users, and the
                            entire key's value is set to the permission
                            flags for the user.
                    ROP:    <data> specifies a read-only password
                    RWP:    <data> specifies a full-access password

        data      - The path, remark, ACL user list, or password

        Note that NetShares\<share> is also used.  The value of this key
        is set to the type of access permitted (ACL-defined, password-
        defined, etc.) with a special flag of SHI50F_ACLS (defined
        in memdb.h).

  UserPassword\<user>\<password>

        If <user> is a local account, The account will be created with <password>.

        user - Specifies the fixed Win9x user name

        password - Specifies the password, which may contain a backslash, asterisk or
                   question mark.

  DOSMIG SUMMARY\<item>\<field>\<data>

        Dosmig Summary is used to maintain summary information about the progress of
        migrating the dos configuration files config.sys and autoexec.bat.

        Item is either BAD, IGNORE, MIGRATE, USE, or UNKNOWN (referring to the type of
        classifications dosmig95 uses as it reads through the DOS configuration files) or
        LINES (referring to the total line count found.)

        The only currently supported field under this category is COUNT

        data contains a count of whatever the item field was, as a string.

  DOSMIG LINES\<item>\<field>\<data>

        The Dosmig lines category is used to hold information about the actual lines of
        the configuration fields.

        Item is a 5 digit enumerator string.

        Fields are one of the following:

        TYPE -- The type of the line
        TEXT -- The actual text of the line.
        DESC -- A description associated with the line by dosmig95's parse rules
        FILE -- either autoexec.bat or config.sys depending on where the line originated.

        The data is the type,text,description or file, as necessary.

  GUIDS\<guid>

        The GUIDS category holds a list of all suppressed GUIDs for OLE.  Each
        GUID in the list exists in the Win95 registry.  The actual list of
        suppressed GUIDs (both those that are in the registry and those that
        are not) is kept in win95upg.inf.

  AutosearchDomain\<user>

        The AutosearchDomain category holds a list of users who are marked for
        automatic domain lookup during GUI mode.  If one or more users are listed
        in AutosearchDomain, Setup checks all trusted domains for the specified
        user accounts, resolving them automatically.

        user - Specifies the fixed user name, without a domain

  KnownDomain\<domain>\<user>

        The KnownDomain category holds a list of users whos domain is known but
        needs to be verified.  This domain comes from network shares, the most
        recent logged on user, and the UI.

        domain - Specifies the domain name, such as REDMOND

        user - Specifies the fixed user name

  State\<data>=value

        A category used for misc state passing.  Data is one of the following:

            MSNP32  - If exists, the Microsoft Networking Client was installed
            PlatformName\<name> - Specifies the display name of Win95 or Win98
            MajorVersion = <DWORD> - Specifies Win9x major version
            MinorVersion = <DWORD> - Specifies Win9x minor version
            BuildNumber = <DWORD> - Specifies Win9x build number
            PlatformId = <DWORD> - Specifies platform ID flags
            VersionText - Specifies arbitrary version text
            CodePage = <DWORD> - Specifies Win9x code page
            Locale = <DWORD> - Specifies Win9x locale id
            AP\<password> = <DWORD> - Specifies the admin password and if it was
                                      randomly generated or not

  NtFiles\<filename> = <pathoffset>

        The NtFiles category is used to hold a list of filenames that are
        installed by standard NT installation.  This list comes from txtsetup.sif
        and does not have a directory spec.

        filename - The file that will be installed, in long filename format

        pathoffset - Specifies offset to NtPaths key for file

  NtFilesExcept\<filename>

        These are files installed by NT that don't have no overwrite restriction

        filename - The file name, in long filename format

  MyDocsMoveWarning\<user>\<path>

        Specifies paths to copy the shell "where are my documents"
        warning file.

        user - Specifies the fixed user name

        path - Specifies the path. On 9x, this is the symbolic shell
               folder location. On NT, this is fixed up to be the
               actual path.

  NtFilesRemoved\<filename> = <pathoffset>

        These are files removed by NT

        filename - The file name, in long filename format

        pathoffset - Specifies offset to NtPaths key for file

  NtPaths\<path>

        Specifies the path for a file listed in NtFiles.

        path - The path specification in long filename format

  NtFilesBad\<filename> = <pathoffset>

        This category is used to hold the files that are supposed to be installed by
        NT but never made it.

        filename - The file that should have been installed, in long filename format

        pathoffset - Specifies offset to NtPaths key for file

  Stf\<path>

        Specifies the name of a setup table file that needs to be converted.
        .STF files are used by the old Microsoft ACME setup.  We convert any
        path that has been moved.

        path - The path specification in long filename format

  StfTemp\<path> = <inf pointer>

        Used during STF processing in the migraiton phase to organize data.

        path - The path specification in long filename format, taken from the
               STF/INF pair

        inf pointer - A pointer to an INFLINE structure (see migmain\stf.c)

  StfSections\<path> = <section number>

        Used during STF processing in the migraiton phase to organize sections.

        path - The dir portion of an STF path; files in the STF section must all
               be in this directory.

        section number - The 32-bit section number.  When combined with win9xupg,
                         this number gives a unique section name.

  HelpFilesDll\<dllname>

        Specifies the extension DLL needed by a certain help file. Used to
        verify if the help file and the DLL are going to be loaded in
        the same subsystem in NT.

  Report\<category> = Item      (temporary category)

        category - Specifies the category, which may contain backslashes.  This
                   is the same category that is stored in msgmgr.

        Item - Specifies a pointer to the incompatibility message item

  UserSuppliedDrivers\<infname>\<local_driver_path>

        Specifies the INF of user-supplied hardware drivers and the
        location of the associated driver files.

        infname - Specifies INF to be installed

        local_driver_path - Specifies local path containing all driver files

  DisabledMigDlls\<productid>

        Specifies that a registry-specified migration DLL is disabled and
        will not be processed.

        productid - The migration DLL's product ID; the value name stored in
                    the registry and used for display.

  MissingImports\<missing import sample>
        Specifies a sample of a missing import for a certain module.


        MissingImports = the full path for the module
        missing import sample = is a sample for a missing import

  ModuleCheck\<full path module name>=<status value>
        Specifies a list of modules and their status.


        full path module name = self explanatory
        status value = MODULESTATUS_xxx constant defined in fileops.h

  HardwareIdList\<enum key entry>\<hardware Id list>

        Specifies a list of hardware Id's and compatible id's for specified enum key entry

  NewNames\<name group>\<field>\<name> = <value>  (**intended to be used on the Win9x-side only)

        Specifies a name collision resolution, used to correct names that are
        incompatible with NT.

        name group - Specifies the type of name, such as Computer Name, User Names, etc...

        field - Old: <name> specifies the Win9x name
                New: <name> specifies the NT-compatible name, either generated by Setup
                     or specified by the user

        name - Specifies the name text

        value - If <field> is Old, specifies offset to new name (i.e, the New field's data)

  InUseNames\<name group>\<name>  (**intended to be used on the Win9x-side only)

        Specifies names that are in use.  Used to make sure the user doesn't try to name
        two things to the same name.

        name group - Specifies the type of name, such as Computer Name, User Names, etc...

        name - Specifies the name that is in use

  DeferredAnnounce\<full path module name> = Offset
        If any of the files listed here have a link or pif pointing to them then we will
        announce the file using implicit values or MigDbContext (Offset is a pointer to this).
        UserFlags are used to identify the type of the file that can be one of the following:
            Reinstall
            MinorProblems
            Incompatible

  KnownGood\<full path module name>
        We record here all known good files found in the system.


  CompatibleShellModules\<full path module name> = Offset
        We list here all known good modules for Shell= line in Win.ini.
        When we will process this line we will check to see if modules listed there are
        "known good". If not we will either delete the entry or replace the module with a
        compatible one. Offset points to a MigDbContext or is NULL.

  CompatibleShellModulesNT\<full path module name>
        This is the part from CompatibleShellModules that actually goes to NT.

  CompatibleRunKeyModules\<full path module name> = Offset
        We list here all known good modules for Run key.
        When we will process this key we will check to see if modules listed there are
        "known good". If not we will either delete the entry or replace the module with a
        compatible one. Offset points to a MigDbContext or is NULL.

  CompatibleRunKeyModulesNT\<value name>
        This is the part from CompatibleRunKeyModules that actually goes to NT.

  IncompatibleRunKeyModulesNT\<value name>
        This lists the Run key value names that are known bad.

  CompatibleDosModules\<full path module name> = Offset
        We list here all known good Dos modules.

  CompatibleDosModulesNT\<full path module name>
        This is the part from CompatibleDosModules that actually goes to NT.

  CompatibleHlpFiles\<full path module name> = Offset
        We list here all known good HLP files.

  CompatibleHlpExtensions\<extension module>
        We list here HLP files extension modules that we know are going to work

  Shortcuts\<full path shortcut file name>
        Shortcuts stored here for further processing

  UninstallSection\<migdb section>

        Specifies a section name that needs to be processed.  This key is temporary and
        is generated during the file scan and deleted at the end of the file scan during
        the report phase.

        migdb section - Specifies the section name text, as specified by an arg in migdb.inf

  CleanUpDir\<path>

        Specifies a directory that should be deleted if it is empty

        path - Specifies the root path.  The subdirs are scaned as well.

  Win9x APIs\<DLL>\<api>

        Lists APIs that are supported only on Win9x.

        DLL - Specifies the DLL file name, such as kernel32.dll

        api - Specifies the API in the DLL


  Network Adapters\<Adapter Section>\<Protocol>= <NetTransOffset>
  Network Adapters\<Adapter Section>\<PnPId>
  NetTransKeys\<NetTransKey>

    Lists all Net Adapters on the system and the associated protocol bindings.

    Adapter Section - Specifies the Adapter Section that will be created in the answer file for
        this item (such as [Adapter1])

    Protocol - Under each adapter, each bound protocol is listed.

    PnPId - The base PNPID for the device.

    NetTransOffset An Offset into the NetTransKeys section.

  Icons\<path>\<seq> = offset, seq

        Lists extracted icons.

        <path> - Specifies the Win9x source file path (c:\windows\notepad.exe for example)
        <seq> - Specifies the sequential icon index in <path>, zero-based
        offset - Specifies the file position within the icon data file where the image is
        seq - Specifies the sequential icon index in migicons.exe, zero-based

  IconsMoved\<path>\<seq> = offset, seq

        Lists moved icons.

        <path> - Specifies the Win9x source file path (c:\windows\notepad.exe for example)
        <seq> - Specifies the sequential icon index in <path>, zero-based
        offset - Specifies the memdb key offset to the new OS file (Win9x path)
        seq - Specifies the sequential icon index in the new OS file, zero-based

  NicePaths\<path>=MessageId

        Lists paths that should be translated in user report using the message ID.

        path      - Specifies the path

        MessageId - Specifies the message ID

  MigrationPaths\<path>

        Lists paths that are considered "ours". The deal is that if we find OSFiles in these paths, we delete them, otherwise
        we just mark them for external deletion.

        path      - Specifies the path

  ReportLinks\<ReportEntry>\<Category>

  SuppressIniMappings\<suppressed path>

        Lists all INI settings that are not going to be mapped into registry

        suppressed path = <INI file>\<section name>\<key name>
        <section name> and <key name> may have wild characters

  NoOverwriteIniMappings\<no overwrite path>

        Lists all INI settings that are going to be mapped into registry,
        unless NT supplies a value, in which the registry value is mapped
        to the INI file.

        no overwrite path - Specifies <INI file>\<section name>\<key name>,
                            where <section name> and <key name> may have
                            wild characters.

  IniConv\<9xPath>

        Causes path conversion on a file (INI processing). Conversion is done
        in-place. The NT side code converts the 9x path to the NT path via
        GetPathStringOnNt.

  PnpIds\<pnp id>       (temporary -- Win9x side only)

        Lists all PNP IDs on the Win9x machine

  UserFileMoveDest\<path>

        Lists the destination for user files for a particular user. Used to
        easy record one to many copy

        path - Specifies the destination path

  UserFileMoveSrc\<path>\<user>

        Lists the source file for user files for a particular user. Used to
        easy record one to many copy

        path - Specifies the source path

        user - Specifies the user name

  NT TimeZones\<index>\<description>

        Lists nt timezones. Used for mapping timezones and to resolve ambigious timezone cases.

        <index>         - The index used by syssetup to specify the nt timezone.
        <description>   - The displayable description of the timezone.

  9x TimeZones\<description>\<index>

        Lists 9x timezones and the nt timezones that can possibly map to them.

        <description>   - The description of the timezone


  SfPaths\<path>

        Holds the paths for other categories (ShellFolders for example).  Used to
        consolidate the paths.

        path - Specifies the shell folder path (either an NT or Win9x location),
               in either long or short format.

  SfTemp\<path> = <offset> (temporary category)

        Specifies the path of the temporary location for a shell folder.  This is
        used only on the Win9x side to queue up a list of things to move.  The
        code in buildinf.c then transfers these paths into the win9xmov.txt file.

        path - Specifies the Win9x file or directory to move

        offset - Specifies the offset to the destination path (in SfPaths)

  SfOrderNameSrc\<identifier>\<path>\<sequencer> = <shell folder ptr>  (temporary category)

        Specifies the shell folder list, sorted by the shell folder identifier.
        This category is only for work purposes, do not rely on it for data
        transfer during the upgrade.

        identifier - Specifies the shell folder identifier (i.e., Desktop)

        path - Specifies the Win9x path

        sequencer - Random value that is used to make multiple instances of
                    identifier/path pairs unique

        shell folder ptr - Specifies the pointer to a Win9x-side SHELLFOLDER
                           struct

  SfOrderSrc\<path>\<sequencer> = <shell folder ptr>  (temporary category)

        Specifies the shell folder list, sorted by the path.  This category is
        only for work purposes, do not rely on it for data transfer during the
        upgrade.

        path - Specifies the Win9x shell folder path

        sequencer - Random value that is used to make multiple instances of
                    path unique

        shell folder ptr - Specifies the pointer to a Win9x-side SHELLFOLDER
                           struct

  SfMoved\<path>

        Specifies a path that has been processed.  This category is used only
        for work purposes, do not rely on it for data transfer during the
        upgrade.

        path - Specifies Win9x shell folder that was moved

  System32ForcedMove\<file pattern>
        Lists all patterns for files that should be moved from System to System32 no matter what.

        file pattern - pattern for files to be moved

  UserRegData\<value>

        This category lists REG_SZs for UserRegLoc.

        value - Specifies the REG_SZ

  UserRegData\<user>\<encoded key>=<offset to REG_SZ>

        This category holds a list of encoded reg key/value pairs for a pariticular
        user.  The data listed in this category is saved to the user's registry
        at the beginning of the migration of the user registry.

        user - Specifies the fixed, domain-less user name

        encoded key - Specifies the registry key and value, encoded with
                      CreateEncodedRegistryStringEx(key,value,FALSE)

        offset to REG_SZ - Specifies offset to a node in UserRegData

  SFFilesDest\<path>

        Destinations for files inside shell folders. We record this only to help
        the collision detection filter on 9x side. If two shell folders are going
        to be moved to the same location there is a potential of collision there.
        We need to see that and to add the proper move operation.

  NewLinks\<sequencer>\<various data>

        This is used for recording new links that need to be created on NT side. For now
        we do this only to convert PIFs pointing to command.com to LNKs to cmd.exe

  Mapi32Locations\<filename>

        This is used to store all mapi32.dll files on the system. At the end we look to see
        if they are all handled by a migration DLL. If not, we add a general message to report.

  StartupSF\<path>

        This will list all startup shell folders found on the system

  Good Imes\<imefile>

        This lists ime files that may be merged into the keybouard layout registry during NT
        side processing.

  Keyboard Layouts\<sequencer>\<layoutid>

        This lists preloads during NT side processing.

  DirsCollision\<src path>

        Files that need to be renamed because they are colliding with some NT dirs.

  MMedia\System\<System Settings>

        Multimedia-related system settings

  MMedia\Users\<UserName>\<User Settings>

        Multimedia-related user settings

  IgnoredCollisions\<pattern>

        These are files for which the collision with NT files (in shell folders merge) is ignored.

  Suppress Answer File Settings\<section>\<key>

        These are suppresed answer file settings from migration dlls.

  ChangedFileProps\<original file path>\<new file name>

        This is the set of files that were renamed on Win9x side (special files like
        %windir%\system32 cannot be renamed in textmode setup because the dir is created
        as setup starts, before the file is actually renamed)
        If user cancels Setup, all files in this set are restored to their previous state.

  Full Directory Deletes\<Path>

        Set of directories that are added to w9xddir.txt. These directories are deleted along
        with all of there contents during textmode.

  IniAct\First\<OrigIniPath>\<TempFileLocation>

        Set of INI files on which some actions will be performed before any other INI files
        processing is done and before shell folders are migrated; they are stored as original
        path followed by the temporary path where they are copied (so they don't get replaced
        by NT versions); the starting point of TempFileLocation is recognized by the : symbol
        after a drive letter.

  IniAct\Last\<OrigIniPath>\<TempFileLocation>

        Same semantics as above, except INI files stored here are processed last,
         after users are migrated and registries are merged.

  FileEdit\<path> (has optional binary value)

        This category lists files that are to be edited in GUI mode.  The
        optional binary value contains a TOKENSET.  The reader of the binary
        value must convert the offsets in TOKENSET into pointers.

  CleanOut\<path> = <type>

        This category is used to support uninstall. Files, directories and
        trees listed here are evaluated during GUI mode and are put in the delete
        txt file used by uninstall.

        <path> - Specifies the full file path or full subdirectory path
        <type> - Specifies 0 for file, 1 for directory, 2 for tree or 3 for a
                 tree that can't have user files

  EmptyDirs\<path>

        This category tells the uninstall algorithm to write files to mkdir.txt.

        <path> - Specifies the path to the directory that is empty on Win9x

  ShellFolderPerUser\<name> = <common offset>

        This category maps a per-user shell folder name to its common version

  ShellFolderCommon\<name> = <per-user offset>

        This category maps a common shell folder name to its per-user version

*/


//
// FileEnum exclude groups
//

#define MEMDB_CATEGORY_FILEENUM            TEXT("FileEnumExcl")
#define MEMDB_FIELD_FE_PATHS               TEXT("Paths")
#define MEMDB_FIELD_FE_FILES               TEXT("Files")

#define MEMDB_PROFILE_EXCLUSIONS    1
#define MEMDB_FILEDEL_EXCLUSIONS    4

//
// LinkEdit
//

#define MEMDB_CATEGORY_DEFAULT_PIF           TEXT("DefaultPif")
#define MEMDB_CATEGORY_DEFAULT_PIFA          "DefaultPif"
#define MEMDB_CATEGORY_DEFAULT_PIFW          L"DefaultPif"

#define MEMDB_CATEGORY_LINKEDIT              TEXT("LinkEdit")
#define MEMDB_CATEGORY_LINKEDITA             "LinkEdit"

#define MEMDB_CATEGORY_LINKEDIT_TARGET       TEXT("Target")
#define MEMDB_CATEGORY_LINKEDIT_ARGS         TEXT("Arguments")
#define MEMDB_CATEGORY_LINKEDIT_WORKDIR      TEXT("WorkDir")
#define MEMDB_CATEGORY_LINKEDIT_ICONPATH     TEXT("IconPath")
#define MEMDB_CATEGORY_LINKEDIT_ICONNUMBER   TEXT("IconNumber")
#define MEMDB_CATEGORY_LINKEDIT_FULLSCREEN   TEXT("FullScreen")
#define MEMDB_CATEGORY_LINKEDIT_XSIZE        TEXT("xSize")
#define MEMDB_CATEGORY_LINKEDIT_YSIZE        TEXT("ySize")
#define MEMDB_CATEGORY_LINKEDIT_QUICKEDIT    TEXT("QuickEdit")
#define MEMDB_CATEGORY_LINKEDIT_FONTNAME     TEXT("FontName")
#define MEMDB_CATEGORY_LINKEDIT_XFONTSIZE    TEXT("xFontSize")
#define MEMDB_CATEGORY_LINKEDIT_YFONTSIZE    TEXT("yFontSize")
#define MEMDB_CATEGORY_LINKEDIT_FONTWEIGHT   TEXT("FontWeight")
#define MEMDB_CATEGORY_LINKEDIT_FONTFAMILY   TEXT("FontFamily")
#define MEMDB_CATEGORY_LINKEDIT_CODEPAGE     TEXT("CodePage")
#define MEMDB_CATEGORY_LINKEDIT_SHOWNORMAL   TEXT("ShowNormal")

#define MEMDB_CATEGORY_LINKSTUB_TARGET       TEXT("StubTarget")
#define MEMDB_CATEGORY_LINKSTUB_ARGS         TEXT("StubArguments")
#define MEMDB_CATEGORY_LINKSTUB_WORKDIR      TEXT("StubWorkDir")
#define MEMDB_CATEGORY_LINKSTUB_ICONPATH     TEXT("StubIconPath")
#define MEMDB_CATEGORY_LINKSTUB_ICONNUMBER   TEXT("StubIconNumber")
#define MEMDB_CATEGORY_LINKSTUB_SEQUENCER    TEXT("StubSequencer")
#define MEMDB_CATEGORY_LINKSTUB_MAXSEQUENCE  TEXT("StubMaxSequence")
#define MEMDB_CATEGORY_LINKSTUB_ANNOUNCEMENT TEXT("StubAnnouncement")
#define MEMDB_CATEGORY_LINKSTUB_REQFILE      TEXT("StubReqFile")
#define MEMDB_CATEGORY_LINKSTUB_REPORTAVAIL  TEXT("PresentInReport")
#define MEMDB_CATEGORY_LINKSTUB_SHOWMODE     TEXT("ShowMode")

#define MEMDB_CATEGORY_REQFILES_MAIN         TEXT("TMP_HIVE\\ReqFilesMain")
#define MEMDB_CATEGORY_REQFILES_ADDNL        TEXT("TMP_HIVE\\ReqFilesAddnl")

// LinkStrings\<path>
#define MEMDB_CATEGORY_LINK_STRINGS         TEXT("LinkStrings")

// LinkGuids\<guid>\<seq> = <offset to LinkStrings>
#define MEMDB_CATEGORY_LINK_GUIDS           TEXT("LinkGUIDs")

// AdministratorInfo\account\<name>
#define MEMDB_CATEGORY_ADMINISTRATOR_INFO   TEXT("AdministratorInfo")
#define MEMDB_ITEM_AI_ACCOUNT               TEXT("Account")
#define MEMDB_ITEM_AI_USER_DOING_MIG        TEXT("UserDoingMig")

// UserDatLoc\<username>\location  (no fields)
#define MEMDB_CATEGORY_USER_DAT_LOC         TEXT("UserDatLoc")
#define MEMDB_CATEGORY_USER_DAT_LOCA        "UserDatLoc"

// FixedUserNames\<orguser_encoded>\<newuser>
#define MEMDB_CATEGORY_FIXEDUSERNAMES       TEXT("FixedUserNames")
#define MEMDB_CATEGORY_FIXEDUSERNAMESA      "FixedUserNames"
#define MEMDB_CATEGORY_FIXEDUSERNAMESW      L"FixedUserNames"

// UserProfileExt\<username>\location  (no fields)
#define MEMDB_CATEGORY_USER_PROFILE_EXT     TEXT("UserProfileExt")

// Paths\<pathitem>\<path>  (no fields)
#define MEMDB_CATEGORY_PATHS                TEXT("Paths")
#define MEMDB_CATEGORY_PATHSA               "Paths"
#define MEMDB_ITEM_RELOC_WINDIR             TEXT("RelocWinDir")
#define MEMDB_ITEM_RELOC_WINDIRA            "RelocWinDir"

// CancelFileDel\<path>
#define MEMDB_CATEGORY_CANCELFILEDEL        TEXT("CancelFileDel")
#define MEMDB_CATEGORY_CANCELFILEDELA       "CancelFileDel"
#define MEMDB_CATEGORY_CANCELFILEDELW       L"CancelFileDel"

// Answer File Restrictions\section\key pattern
#define MEMDB_CATEGORY_UNATTENDRESTRICTRIONS TEXT("SIF Restrictions")

// Answer File Values\<Id>\<Sequence>\Value
#define MEMDB_CATEGORY_AF_VALUES             TEXT("SIF Values")

// Answer File Sections And Keys\Section\<Key Sequence>\<Value sequence>

#define MEMDB_CATEGORY_AF_SECTIONS           TEXT("SIF Sections")


// Ras Migration Data\<user>\<entry>\<item>=<bindata>
#define MEMDB_CATEGORY_RAS_MIGRATION         TEXT("Ras Migration for ")
#define MEMDB_CATEGORY_RAS_INFO              TEXT("RAS Info")
#define MEMDB_CATEGORY_RAS_DATA              TEXT("Ras Data")
#define MEMDB_FIELD_USER_SETTINGS            TEXT("User Settings")

// LogSaveTo\<path>
#define MEMDB_CATEGORY_LOGSAVETO         TEXT("LogSaveTo")

// Pattern for Plug-In DLL list (used in enumeration)
#define MEMDB_CATEGORY_MIGRATION_DLL        TEXT("MigDll")
#define MEMDB_FIELD_DLL                     TEXT("dll")
#define MEMDB_FIELD_WD                      TEXT("wd")
#define MEMDB_FIELD_DESC                    TEXT("desc")
#define MEMDB_FIELD_COMPANY_NAME            TEXT("company")
#define MEMDB_FIELD_SUPPORT_PHONE           TEXT("phone")
#define MEMDB_FIELD_SUPPORT_URL             TEXT("url")
#define MEMDB_FIELD_SUPPORT_INSTRUCTIONS    TEXT("instructions")

// FileRename\<src>\<new>
#define MEMDB_CATEGORY_FILERENAME           TEXT("FileRename")
#define MEMDB_CATEGORY_FILERENAMEA          "FileRename"
#define MEMDB_CATEGORY_FILERENAMEW          L"FileRename"

// Network share conversion (NetShares\<share>\<field>\<data>)
#define MEMDB_CATEGORY_NETSHARES        TEXT("NetShares")
#define MEMDB_FIELD_PATH                TEXT("Path")
#define MEMDB_FIELD_TYPE                TEXT("Type")
#define MEMDB_FIELD_REMARK              TEXT("Remark")
#define MEMDB_FIELD_ACCESS_LIST         TEXT("ACL")
#define MEMDB_FIELD_RO_PASSWORD         TEXT("ROP")
#define MEMDB_FIELD_RW_PASSWORD         TEXT("RWP")

// DOSMIG Categories
#define MEMDB_CATEGORY_DM_LINES         TEXT("DOSMIG LINES")
#define MEMDB_CATEGORY_DM_FILES         TEXT("DOSMIG FILES")

// Registry Suppression
#define MEMDB_CATEGORY_HKR              TEXT("HKR")
#define MEMDB_CATEGORY_HKLM             TEXT("HKLM")

// OLE object suppression
#define MEMDB_CATEGORY_GUIDS            TEXT("GUIDs")
#define MEMDB_CATEGORY_UNSUP_GUIDS      TEXT("UGUIDs")
#define MEMDB_CATEGORY_PROGIDS          TEXT("ProgIDs")

// Domain categories
#define MEMDB_CATEGORY_AUTOSEARCH       TEXT("AutosearchDomain")
#define MEMDB_CATEGORY_KNOWNDOMAIN      TEXT("KnownDomain")


// User passwords
#define MEMDB_CATEGORY_USERPASSWORD     TEXT("UserPassword")

// State category
#define MEMDB_CATEGORY_STATE            TEXT("State")
#define MEMDB_ITEM_MSNP32               TEXT("MSNP32")
#define MEMDB_ITEM_PLATFORM_NAME        TEXT("PlatformName")
#define MEMDB_ITEM_MAJOR_VERSION        TEXT("MajorVersion")
#define MEMDB_ITEM_MINOR_VERSION        TEXT("MinorVersion")
#define MEMDB_ITEM_BUILD_NUMBER         TEXT("BuildNumber")
#define MEMDB_ITEM_PLATFORM_ID          TEXT("PlatformId")
#define MEMDB_ITEM_VERSION_TEXT         TEXT("VersionText")
#define MEMDB_ITEM_CODE_PAGE            TEXT("CodePage")
#define MEMDB_ITEM_LOCALE               TEXT("Locale")
#define MEMDB_ITEM_ADMIN_PASSWORD       TEXT("AP")
#define MEMDB_ITEM_ROLLBACK_SPACE       TEXT("DiskSpaceForRollback")
#define MEMDB_ITEM_MASTER_SEQUENCER     TEXT("MasterSequencer")

// MyDocsMoveWarning\<user>\<path>
#define MEMDB_CATEGORY_MYDOCS_WARNING   TEXT("MyDocsMoveWarning")

// NtFilesRemoved\<filename> = <offset to NtDirs>
#define MEMDB_CATEGORY_NT_DEL_FILES     TEXT("NtFilesRemoved")
#define MEMDB_CATEGORY_NT_DEL_FILESA    "NtFilesRemoved"
#define MEMDB_CATEGORY_NT_DEL_FILESW    L"NtFilesRemoved"

// NtFiles\<filename> = <offset to NtDirs>
#define MEMDB_CATEGORY_NT_FILES         TEXT("NtFiles")
#define MEMDB_CATEGORY_NT_FILESA        "NtFiles"
#define MEMDB_CATEGORY_NT_FILESW        L"NtFiles"
#define MEMDB_CATEGORY_NT_FILES_EXCEPT  TEXT("NtFilesExcept")
#define MEMDB_CATEGORY_NT_FILES_EXCEPTA "NtFilesExcept"
#define MEMDB_CATEGORY_NT_FILES_EXCEPTW L"NtFilesExcept"

// NtDirs\<path>
#define MEMDB_CATEGORY_NT_DIRS          TEXT("NtDirs")
#define MEMDB_CATEGORY_NT_DIRSA         "NtDirs"
#define MEMDB_CATEGORY_NT_DIRSW         L"NtDirs"

// NtFilesBad\<filename> = <offset to NtDirs>
#define MEMDB_CATEGORY_NT_FILES_BAD     TEXT("NtFilesBad")
#define MEMDB_CATEGORY_NT_FILES_BADA    "NtFilesBad"
#define MEMDB_CATEGORY_NT_FILES_BADW    L"NtFilesBad"

// ChangedFileProps\<original file path>\<new file name only>
#define MEMDB_CATEGORY_CHG_FILE_PROPS   TEXT("ChangedFileProps")
#define MEMDB_CATEGORY_CHG_FILE_PROPSA  "ChangedFileProps"
#define MEMDB_CATEGORY_CHG_FILE_PROPSW  L"ChangedFileProps"

// Stf\<path>
#define MEMDB_CATEGORY_STF              TEXT("Stf")

// StfTemp\<path>=<infptr>
#define MEMDB_CATEGORY_STF_TEMP         TEXT("StfTemp")

// StfSections\<path>=<section number>
#define MEMDB_CATEGORY_STF_SECTIONS     TEXT("StfSections")

// HelpFilesDll\<dllname>
#define MEMDB_CATEGORY_HELP_FILES_DLL   TEXT("HelpFilesDll")
#define MEMDB_CATEGORY_HELP_FILES_DLLA  "HelpFilesDll"
#define MEMDB_CATEGORY_HELP_FILES_DLLW  L"HelpFilesDll"

// \<dllname>
#define MEMDB_CATEGORY_REPORT           TEXT("Report")

// UserSuppliedDrivers\<infname>\<local_path>
#define MEMDB_CATEGORY_USER_SUPPLIED_DRIVERS    TEXT("UserSuppliedDrivers")

// DisabledMigDlls\<product id>
#define MEMDB_CATEGORY_DISABLED_MIGDLLS TEXT("DisabledMigDlls")

// MissingImports\<missing import sample>
#define MEMDB_CATEGORY_MISSING_IMPORTS   TEXT("MissingImports")
#define MEMDB_CATEGORY_MISSING_IMPORTSA  "MissingImports"
#define MEMDB_CATEGORY_MISSING_IMPORTSW  L"MissingImports"

#define MEMDB_TMP_HIVE                  TEXT("TMP_HIVE")
#define MEMDB_TMP_HIVEA                 "TMP_HIVE"
#define MEMDB_TMP_HIVEW                 L"TMP_HIVE"

// ModuleCheck\<full path module name>=<status value>
#define MEMDB_CATEGORY_MODULE_CHECK     TEXT("TMP_HIVE\\ModuleCheck")
#define MEMDB_CATEGORY_MODULE_CHECKA    "TMP_HIVE\\ModuleCheck"
#define MEMDB_CATEGORY_MODULE_CHECKW    L"TMP_HIVE\\ModuleCheck"

// NewNames\<name group>\<field>\<name>
#define MEMDB_CATEGORY_NEWNAMES             TEXT("NewNames")
#define MEMDB_FIELD_NEW                     TEXT("New")
#define MEMDB_FIELD_OLD                     TEXT("Old")

// InUseNames\<name group>\<name>
#define MEMDB_CATEGORY_INUSENAMES           TEXT("InUseNames")

// DeferredAnnounce\<full path module name> = Offset
#define MEMDB_CATEGORY_DEFERREDANNOUNCE  TEXT("TMP_HIVE\\DeferredAnnounce")
#define MEMDB_CATEGORY_DEFERREDANNOUNCEA "TMP_HIVE\\DeferredAnnounce"
#define MEMDB_CATEGORY_DEFERREDANNOUNCEW L"TMP_HIVE\\DeferredAnnounce"

// KnonwnGood\<full path module name>
#define MEMDB_CATEGORY_KNOWN_GOOD        TEXT("TMP_HIVE\\KnownGood")
#define MEMDB_CATEGORY_KNOWN_GOODA       "TMP_HIVE\\KnownGood"
#define MEMDB_CATEGORY_KNOWN_GOODW       L"TMP_HIVE\\KnownGood"

// CompatibleShellModules\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_SHELL  TEXT("TMP_HIVE\\CompatibleShellModules")
#define MEMDB_CATEGORY_COMPATIBLE_SHELLA "TMP_HIVE\\CompatibleShellModules"
#define MEMDB_CATEGORY_COMPATIBLE_SHELLW L"TMP_HIVE\\CompatibleShellModules"

// CompatibleShellModulesNT\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_SHELL_NT  TEXT("CompatibleShellModules")
#define MEMDB_CATEGORY_COMPATIBLE_SHELL_NTA "CompatibleShellModules"
#define MEMDB_CATEGORY_COMPATIBLE_SHELL_NTW L"CompatibleShellModules"

// CompatibleRunKeyModules\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY  TEXT("TMP_HIVE\\CompatibleRunKeyModules")
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEYA "TMP_HIVE\\CompatibleRunKeyModules"
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEYW L"TMP_HIVE\\CompatibleRunKeyModules"

// CompatibleRunKeyModulesNT\<value name>
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NT  TEXT("CompatibleRunKeyModules")
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NTA "CompatibleRunKeyModules"
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NTW L"CompatibleRunKeyModules"

// IncompatibleRunKeyModulesNT\<value name>
#define MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NT  TEXT("IncompatibleRunKeyModules")
#define MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NTA "IncompatibleRunKeyModules"
#define MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NTW L"IncompatibleRunKeyModules"

// CompatibleDosModules\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_DOS  TEXT("TMP_HIVE\\CompatibleDosModules")
#define MEMDB_CATEGORY_COMPATIBLE_DOSA "TMP_HIVE\\CompatibleDosModules"
#define MEMDB_CATEGORY_COMPATIBLE_DOSW L"TMP_HIVE\\CompatibleDosModules"

// CompatibleDosModulesNT\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_DOS_NT  TEXT("CompatibleDosModules")
#define MEMDB_CATEGORY_COMPATIBLE_DOS_NTA "CompatibleDosModules"
#define MEMDB_CATEGORY_COMPATIBLE_DOS_NTW L"CompatibleDosModules"

// CompatibleHlpExtensions\<extension module>
#define MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS  TEXT("TMP_HIVE\\GoodHlpExtensions")

// CompatibleHlpFiles\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_HLP  TEXT("TMP_HIVE\\CompatibleHlpFiles")
#define MEMDB_CATEGORY_COMPATIBLE_HLPA "TMP_HIVE\\CompatibleHlpFiles"
#define MEMDB_CATEGORY_COMPATIBLE_HLPW L"TMP_HIVE\\CompatibleHlpFiles"

// Shortcuts\<full path shortcut name>
#define MEMDB_CATEGORY_SHORTCUTS        TEXT("TMP_HIVE\\Shortcuts")
#define MEMDB_CATEGORY_SHORTCUTSA       "TMP_HIVE\\Shortcuts"
#define MEMDB_CATEGORY_SHORTCUTSW       L"TMP_HIVE\\Shortcuts"

// BackupDirs\<full path backup dir>
#define MEMDB_CATEGORY_BACKUPDIRS       TEXT("TMP_HIVE\\BackupDirs")
#define MEMDB_CATEGORY_BACKUPDIRSA      "TMP_HIVE\\BackupDirs"
#define MEMDB_CATEGORY_BACKUPDIRSW      L"TMP_HIVE\\BackupDirs"

// ProcessSection\<migdb section>
#define MEMDB_CATEGORY_MIGRATION_SECTION  TEXT("MigrationSection")

// CleanUpDir\<path>
#define MEMDB_CATEGORY_CLEAN_UP_DIR         TEXT("CleanUpDir")

// Win9x APIs
#define MEMDB_CATEGORY_WIN9X_APIS           TEXT("TMP_HIVE\\Win9x APIs")

//
//  Network Adapters and NetTransKeys
//
#define MEMDB_CATEGORY_NETTRANSKEYS     TEXT("NetTransKeys")
#define MEMDB_CATEGORY_NETADAPTERS      TEXT("Network Adapters")
#define MEMDB_FIELD_PNPID               TEXT("PNPID")
#define MEMDB_FIELD_DRIVER              TEXT("Driver")

// Icons\<path>\<index> = offset inside icon data file, flags give new seq
#define MEMDB_CATEGORY_ICONS                TEXT("Icons")

// MovedIcons\<path>\<index> = offset to new path, flags give new seq
#define MEMDB_CATEGORY_ICONS_MOVED          TEXT("IconsMoved")

// NicePaths\<path> = MessageId
#define MEMDB_CATEGORY_NICE_PATHS           TEXT("NicePaths")

// MigrationPaths\<path>
#define MEMDB_CATEGORY_MIGRATION_PATHS      TEXT("MigrationPaths")

// ReportLinks\<ReportEntry>\<Category>
#define MEMDB_CATEGORY_REPORT_LINKS         TEXT("ReportLinks")

// SuppressIniMappings\<suppressed path>
#define MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGS        TEXT("SuppressIniMappings")
#define MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW       L"SuppressIniMappings"

// NoOverwriteIniMappings\<no overwrite path>
#define MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGS        TEXT("NoOverwriteIniMappings")
#define MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW       L"NoOverwriteIniMappings"

// IniConv\<9xIniPath>
#define MEMDB_CATEGORY_INIFILES_CONVERT     TEXT("IniConv")

// TMP_HIVE\ActFirst\<IniPattern>
#define MEMDB_CATEGORY_INIFILES_ACT_FIRST   TEXT("TMP_HIVE\\ActFirst")
// TMP_HIVE\ActLast\<IniPattern>
#define MEMDB_CATEGORY_INIFILES_ACT_LAST    TEXT("TMP_HIVE\\ActLast")

// IniAct\First\<OrigIniPath>\<TempFileLocation>
#define MEMDB_CATEGORY_INIACT_FIRST         TEXT("IniAct\\First")
// IniAct\Last\<OrigIniPath>\<TempFileLocation>
#define MEMDB_CATEGORY_INIACT_LAST          TEXT("IniAct\\Last")

// TMP_HIVE\IgnoreInis\<ignored INI filename>
#define MEMDB_CATEGORY_INIFILES_IGNORE      TEXT("TMP_HIVE\\IgnoreInis")

// PNPIDs\<pnpid>
#define MEMDB_CATEGORY_PNPIDS   TEXT("TMP_HIVE\\PnpIDs")


// UserFileMoveDest\<path>
#define MEMDB_CATEGORY_USERFILEMOVE_DEST    TEXT("UserFileMoveDest")
#define MEMDB_CATEGORY_USERFILEMOVE_DESTA   "UserFileMoveDest"
#define MEMDB_CATEGORY_USERFILEMOVE_DESTW   L"UserFileMoveDest"

// UserFileMoveSrc\<path>\<user>
#define MEMDB_CATEGORY_USERFILEMOVE_SRC    TEXT("UserFileMoveSrc")
#define MEMDB_CATEGORY_USERFILEMOVE_SRCA   "UserFileMoveSrc"
#define MEMDB_CATEGORY_USERFILEMOVE_SRCW   L"UserFileMoveSrc"


// NT Time Zones\<index>\<display>
#define MEMDB_CATEGORY_NT_TIMEZONES         TEXT("TMP_HIVE\\NT Time Zones")

// 9x Time Zones\<display>\<index>
#define MEMDB_CATEGORY_9X_TIMEZONES         TEXT("TMP_HIVE\\9x Time Zones")
#define MEMDB_FIELD_COUNT                   TEXT("Count")
#define MEMDB_FIELD_INDEX                   TEXT("Index")


// SfPath\<path>
#define MEMDB_CATEGORY_SHELL_FOLDERS_PATH       TEXT("SfPath")
#define MEMDB_CATEGORY_SHELL_FOLDERS_PATHA      "SfPath"
#define MEMDB_CATEGORY_SHELL_FOLDERS_PATHW      L"SfPath"

// SfTemp\<path> = <offset> (temporary category)
#define MEMDB_CATEGORY_SF_TEMP                  TEXT("TMP_HIVE\\SfTemp")
#define MEMDB_CATEGORY_SF_TEMPA                 "TMP_HIVE\\SfTemp"
#define MEMDB_CATEGORY_SF_TEMPW                 L"TMP_HIVE\\SfTemp"

// SfOrderNameSrc\<identifier>\<path>\<sequencer> = <shell folder ptr>
#define MEMDB_CATEGORY_SF_ORDER_NAME_SRC    TEXT("TMP_HIVE\\SfOrderNameSrc")

// SfOrderSrc\<path>\<sequencer> = <shell folder ptr>
#define MEMDB_CATEGORY_SF_ORDER_SRC         TEXT("TMP_HIVE\\SfOrderSrc")

// SfMoved\<path>
#define MEMDB_CATEGORY_SHELL_FOLDERS_MOVED  TEXT("TMP_HIVE\\SfMoved")

// ShellFoldersDest
#define MEMDB_CATEGORY_SHELLFOLDERS_DEST            TEXT("ShellFoldersDest")
#define MEMDB_CATEGORY_SHELLFOLDERS_SRC             TEXT("ShellFoldersSrc")
#define MEMDB_CATEGORY_SHELLFOLDERS_ORIGINAL_SRC    TEXT("ShellFoldersOriginalSrc")


// System32ForcedMove\<file pattern>
#define MEMDB_CATEGORY_SYSTEM32_FORCED_MOVE     TEXT("TMP_HIVE\\System32ForcedMove")
#define MEMDB_CATEGORY_SYSTEM32_FORCED_MOVEA    "TMP_HIVE\\System32ForcedMove"
#define MEMDB_CATEGORY_SYSTEM32_FORCED_MOVEW    L"TMP_HIVE\\System32ForcedMove"

// PathRoot\<path>=<sequencer>,<operations>
#define MEMDB_CATEGORY_PATHROOT             TEXT("PathRoot")
#define MEMDB_CATEGORY_PATHROOTA            "PathRoot"
#define MEMDB_CATEGORY_PATHROOTW            L"PathRoot"

// Data\<data>
// OPTIMIZATION: Overlap with PathRoot
#define MEMDB_CATEGORY_DATA                 TEXT("PathRoot")    //TEXT("Data")
#define MEMDB_CATEGORY_DATAA                "PathRoot"          //"Data"
#define MEMDB_CATEGORY_DATAW                L"PathRoot"         //L"Data"

// UserRegData\<value>
#define MEMDB_CATEGORY_USER_REGISTRY_VALUE      TEXT("UserRegData")

// UserRegLoc\<user>\<encoded key>=<offset to REG_SZ>
#define MEMDB_CATEGORY_SET_USER_REGISTRY        TEXT("UserRegLoc")


// SFFilesDest\<path>
#define MEMDB_CATEGORY_SF_FILES_DEST        TEXT("TMP_HIVE\\SFFilesDest")

// SFMigDirs\<SFName>\<Subdir>=<Levels>
#define MEMDB_CATEGORY_SFMIGDIRS            TEXT("TMP_HIVE\\SFMigDirs")

// Mapi32Locations\<filename>
#define MEMDB_CATEGORY_MAPI32_LOCATIONS     TEXT("TMP_HIVE\\Mapi32Locations")

// StartupSF\<path>
#define MEMDB_CATEGORY_SF_STARTUP           TEXT("TMP_HIVE\\StartupSF")
// Keyboard Layouts\<sequencer>\<layoutid>
#define MEMDB_CATEGORY_KEYBOARD_LAYOUTS TEXT("Keyboard Layouts")

// Good Imes\<layoutid>
#define MEMDB_CATEGORY_GOOD_IMES TEXT("Good Imes")

// DirsCollision\<src path>
#define MEMDB_CATEGORY_DIRS_COLLISION       TEXT("DirsCollision")
#define MEMDB_CATEGORY_DIRS_COLLISIONA      "DirsCollision"
#define MEMDB_CATEGORY_DIRS_COLLISIONW      L"DirsCollision"

// IgnoredCollisions\<pattern>
#define MEMDB_CATEGORY_IGNORED_COLLISIONS   TEXT("IgnoredCollisions")
#define MEMDB_CATEGORY_IGNORED_COLLISIONSA  "IgnoredCollisions"
#define MEMDB_CATEGORY_IGNORED_COLLISIONSW  L"IgnoredCollisions"

// Dun Files\full path
#define MEMDB_CATEGORY_DUN_FILES  TEXT("TMP_HIVE\\DUN Files")

// MMedia\System\<System Settings>
#define MEMDB_CATEGORY_MMEDIA_SYSTEM        TEXT("MMedia\\System")
#define MEMDB_CATEGORY_MMEDIA_SYSTEMA       "MMedia\\System"
#define MEMDB_CATEGORY_MMEDIA_SYSTEMW       L"MMedia\\System"

// MMedia\Users\<UserName>\<User Settings>
#define MEMDB_CATEGORY_MMEDIA_USERS         TEXT("MMedia\\Users")
#define MEMDB_CATEGORY_MMEDIA_USERSA        "MMedia\\Users"
#define MEMDB_CATEGORY_MMEDIA_USERSW        L"MMedia\\Users"

//
// Suppress Answer File Setting\<section>\<key>
//
#define MEMDB_CATEGORY_SUPPRESS_ANSWER_FILE_SETTINGS TEXT("Suppress Answer File Setting")

//
// Delete directories and all there contents in textmode.
//
#define MEMDB_CATEGORY_FULL_DIR_DELETES TEXT("Full Directory Deletes")
#define MEMDB_CATEGORY_FULL_DIR_DELETESA "Full Directory Deletes"
#define MEMDB_CATEGORY_FULL_DIR_DELETESW L"Full Directory Deletes"

// Briefcases\<BriefcasePath>
#define MEMDB_CATEGORY_BRIEFCASES       TEXT("Briefcases")

// FileEdit\<path> = <optional binary value>
#define MEMDB_CATEGORY_FILEEDIT             TEXT("FileEdit")
#define MEMDB_CATEGORY_FILEEDITA            "FileEdit"

// CleanOut\<path> = <type>
#define MEMDB_CATEGORY_CLEAN_OUT            TEXT("CleanOut")
#define MEMDB_CATEGORY_CLEAN_OUTW           L"CleanOut"

// EmptyDirs\<path> = <type>
#define MEMDB_CATEGORY_EMPTY_DIRS           TEXT("EmptyDirs")
#define MEMDB_CATEGORY_EMPTY_DIRSA          "EmptyDirs"
#define MEMDB_CATEGORY_EMPTY_DIRSW          L"EmptyDirs"

// CPLs\<CPL name>
#define MEMDB_CATEGORY_CPLS         TEXT("TMP_HIVE\\CPLs")
#define MEMDB_CATEGORY_CPLSA        "TMP_HIVE\\CPLs"
#define MEMDB_CATEGORY_CPLSW        L"TMP_HIVE\\CPLs"

// TMP_HIVE\BadFusion\ComponentName\<AppPath>
#define MEMDB_CATEGORY_BAD_FUSION       TEXT("TMP_HIVE\\BadFusion")

// UseNtFiles\<Win9xName>\<NTName>
#define MEMDB_CATEGORY_USE_NT_FILES     TEXT("UseNtFiles")

// Autologon = <TRUE if should remain on, FALSE if migpwd should run>
#define MEMDB_CATEGORY_AUTOLOGON        TEXT("Autologon")

// ForceCopy section holds win9x keys that are dynamically added to the [Force Win9x Settings]
// section in wkstamig.inx and usermig.inx
// ForceCopy\<Source> = offset
// ForceCopy\<Destination>
#define MEMDB_CATEGORY_FORCECOPY        TEXT("ForceCopy")
#define MEMDB_CATEGORY_FORCECOPYA       "ForceCopy"
#define MEMDB_CATEGORY_FORCECOPYW       L"ForceCopy"

// TMP_HIVE\\CompatReport\Components = <Compatibility Report Component>
// TMP_HIVE\\CompatReport\Objects = <Component pointer>
#define MEMDB_CATEGORY_COMPATREPORT     TEXT("TMP_HIVE\\CompatReport")
#define MEMDB_ITEM_OBJECTS              TEXT("Objects")
#define MEMDB_ITEM_COMPONENTS           TEXT("Components")

// SfPerUser\<shell folder tag> = <offset to common>
#define MEMDB_CATEGORY_SF_PERUSER       TEXT("SfPerUser")

// SfCommon\<shell folder tag> = <offset to per-user>
#define MEMDB_CATEGORY_SF_COMMON        TEXT("SfCommon")

// TMP_HIVE\\UserSfCollisions\<ShellFolderId>\<ShellFolderPath>
#define MEMDB_CATEGORY_PROFILES_SF_COLLISIONS       TEXT("TMP_HIVE\\ProfilesSfCollisions")
#define MEMDB_CATEGORY_PROFILES_SF_COLLISIONSA      "TMP_HIVE\\ProfilesSfCollisions"
#define MEMDB_CATEGORY_PROFILES_SF_COLLISIONSW      L"TMP_HIVE\\ProfilesSfCollisions"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\merge.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    merge.h

Abstract:

    Declares the interface for the Win9x to NT registry merge code.
    These routines are used only in GUI mode.  See w95upgnt\merge
    for implementation details.

Author:

    Jim Schmidt (jimschm) 23-Jan-1997

Revision History:

    jimschm 25-Mar-1998     Support for hkcr.c

--*/

//
// merge.h -- public interface for merge.lib
//
//

#pragma once

#define REGMERGE_95_SUPPRESS        0x00000001
#define REGMERGE_95_RENAME_SUPPRESS 0x00000002
#define REGMERGE_95_RENAME          0x00000004

#define REGMERGE_NT_MASK            0x0000ff00
#define REGMERGE_NT_SUPPRESS        0x00000100
#define REGMERGE_NT_IGNORE_DEFAULTS 0x00000200
#define REGMERGE_NT_PRIORITY_NT     0x00000400


BOOL
WINAPI
Merge_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN LPVOID lpv
    );


BOOL
MergeRegistry (
    IN  LPCTSTR FileName,
    IN  LPCTSTR User
    );


BOOL
SuppressWin95Object (
    IN  LPCTSTR ObjectStr
    );

PBYTE
FilterRegValue (
    IN      PBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD DataType,
    IN      PCTSTR KeyForDbgMsg,        OPTIONAL
    OUT     PDWORD NewDataSize
    );
//
// HKCR merge code
//

typedef enum {
    ANY_CONTEXT,
    ROOT_BASE,
    CLSID_BASE,
    CLSID_COPY,
    CLSID_INSTANCE_COPY,
    TYPELIB_BASE,
    TYPELIB_VERSION_COPY,
    INTERFACE_BASE,
    TREE_COPY,
    TREE_COPY_NO_OVERWRITE,
    KEY_COPY,
    COPY_DEFAULT_VALUE,
    COPY_DEFAULT_ICON
} MERGE_CONTEXT;

BOOL
MergeRegistryNode (
    IN      PCTSTR RootKey,
    IN      MERGE_CONTEXT Context
    );

#ifdef DEBUG
#define DEBUGENCODER    DebugEncoder
#else
#define DEBUGENCODER(x) NULL
#endif

PCTSTR
DebugEncoder (
    PVOID ObPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\migdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migdb.h

Abstract:

    Declares interfaces that are used to access the migdb.inf engine.
    Aside from w95upg.dll, there are several tools that use this code.

    See w95upg\migapp for details.

Author:

    Calin Negreanu (calinn)     15-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    PCTSTR            FullFileSpec;
    DWORD             Handled;
    WIN32_FIND_DATA * FindData;
    TCHAR             DirSpec[MAX_TCHAR_PATH];
    BOOL              IsDirectory;
    PCTSTR            Extension;
    BOOL              VirtualFile;
    PDWORD            CurrentDirData;
} FILE_HELPER_PARAMS, * PFILE_HELPER_PARAMS;


DWORD
InitMigDb (
    DWORD Request
    );

BOOL
InitMigDbEx (
    PCSTR MigDbFile
    );

DWORD
DoneMigDb (
    DWORD Request
    );

BOOL
CleanupMigDb (
    VOID
    );

BOOL
MigDbTestFile (
    IN PFILE_HELPER_PARAMS Params
    );

//
// This routine checks to see if FileName is listed in
// any migdb.inf section.
//

BOOL
IsKnownMigDbFile (
    IN      PCTSTR FileName
    );


BOOL
AddFileToMigDbLinkage (
    IN      PCTSTR FileName,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex            OPTIONAL
    );

//
// Routine to compute a file's checksum
//

UINT
ComputeCheckSum (
    PFILE_HELPER_PARAMS Params
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\migui.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migui.h

Abstract:

    Prototypes for Windows 95 user interface functions.

    See w95upg\ui for implementation.

Author:

    Jim Schmidt (jimschm)   26-Nov-1996

Revision History:

    marcw    14-Apr-1997  Took out UI_* functions related to progress bar.
    jimschm  04-Mar-1997  Added compatibility table API
    mikeco   05-Feb-1997  Removing dead stuff

--*/

#pragma once

//
// Code in report.c
//

BOOL
AddBadSoftware (
    IN  PCTSTR Component,
    IN  PCTSTR Message,
    IN  BOOL IncludeOnShortReport
    );


typedef struct {
    TCHAR MsgGroup[MEMDB_MAX];
    PCTSTR Message;

    // private enumeration fields
    MEMDB_ENUM e;
    UINT Index;
    DWORD EnumLevel;
} REPORT_MESSAGE_ENUM, *PREPORT_MESSAGE_ENUM;

BOOL
EnumFirstRootMsgGroup (
    OUT     PREPORT_MESSAGE_ENUM EnumPtr,
    IN      DWORD Level
    );

BOOL
EnumNextRootMsgGroup (
    IN OUT  PREPORT_MESSAGE_ENUM EnumPtr
    );


BOOL
EnumFirstMessage (
    OUT     PREPORT_MESSAGE_ENUM EnumPtr,
    IN      PCTSTR RootMsgGroup,            OPTIONAL
    IN      DWORD Level
    );

BOOL
EnumNextMessage (
    IN OUT  PREPORT_MESSAGE_ENUM EnumPtr
    );

PCTSTR
BuildMessageGroup (
    IN      UINT RootGroupId,
    IN      UINT SubGroupId,            OPTIONAL
    IN      PCTSTR Item
    );

BOOL
IsPreDefinedMessageGroup (
    IN      PCTSTR Group
    );

PCTSTR
GetPreDefinedMessageGroupText (
    IN      UINT GroupNumber
    );

//
// ui.c
//

extern HWND g_ParentWndAlwaysValid;

//
// APIs to retrieve strings from incompatability item
//

PCTSTR GetComponentString (IN  PVOID IncompatPtr);
PCTSTR GetDescriptionString (IN  PVOID IncompatPtr);

// Use MemFree to free return ptr
PCTSTR
CreateIndentedString (
    IN      PCTSTR UnwrappedStr,
    IN      UINT Indent,
    IN      INT HangingIndentAdjustment,
    IN      UINT LineLen
    );


//
// UI in ui.c in w95upg\ui
//

DWORD
UI_GetWizardPages (
    OUT    UINT *FirstCountPtr,
    OUT    PROPSHEETPAGE **FirstArray,
    OUT    UINT *SecondCountPtr,
    OUT    PROPSHEETPAGE **SecondArray,
    OUT    UINT *ThirdCountPtr,
    OUT    PROPSHEETPAGE **ThirdArray
    );

VOID
UI_Cleanup (
    VOID
    );

PCTSTR
UI_GetMemDbDat (
    VOID
    );



// utility for report-view list ctrls
VOID
UI_InsertItemsIntoListCtrl (
    HWND ListCtrl,
    INT Item,                   // zero-based index
    PTSTR ItemStrs,             // tab-separated list
    LPARAM lParam                // lParam for item
    );

UINT
UI_UntrustedDll (
    IN      PCTSTR DllPath
    );


//
// Message symbols in dll (msg.h created by mc)
//

#include "msg.h"

//
// Background copy thread routines
//

VOID StartCopyThread (VOID);
VOID EndCopyThread (VOID);
BOOL DidCopyThreadFail (VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\migmain.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migmain.h

Abstract:

    Declares routines for w95upgnt\migmain, the NT-side migration
    library that does all the work.

Author:

    Jim Schmidt (jimschm) 12-Sep-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// migmain.h -- public interface for migmain.lib
//
//

BOOL MigMain_Init (void);
BOOL MigMain_Migrate (void);
BOOL MigMain_Cleanup (void);

VOID
TerminateProcessingTable (
    VOID
    );


//
// filter functions in migmain.c
//

typedef enum {
    CONVERTPATH_NOT_REMAPPED,
    CONVERTPATH_REMAPPED,
    CONVERTPATH_DELETED
} CONVERTPATH_RC;

CONVERTPATH_RC
ConvertWin9xPath (
    IN OUT  PTSTR PathBuf
    );


//
// User enum
//

typedef enum {
    WIN9X_USER_ACCOUNT,
    ADMINISTRATOR_ACCOUNT,
    LOGON_USER_SETTINGS,
    DEFAULT_USER_ACCOUNT
} ACCOUNTTYPE;

typedef struct {
    HKEY UserHiveRoot;
    TCHAR TempProfile[MAX_TCHAR_PATH];
    TCHAR ProfileToDelete[MAX_TCHAR_PATH];
    BOOL UserHiveRootOpen;
    BOOL UserHiveRootCreated;
    BOOL DefaultHiveSaved;
    BOOL LastUserWasDefault;
} USERMIGDATA, *PUSERMIGDATA;

typedef struct {
    //
    // These members are information to the caller
    //

    UINT TotalUsers;
    UINT ActiveUsers;
    TCHAR Win9xUserName[MAX_USER_NAME];
    TCHAR FixedUserName[MAX_USER_NAME];
    TCHAR FixedDomainName[MAX_USER_NAME];
    ACCOUNTTYPE AccountType;
    TCHAR UserDatLocation[MAX_TCHAR_PATH];
    BOOL Valid;
    BOOL CreateOnly;
    BOOL UserDoingTheUpgrade;
    PUSERMIGDATA ExtraData;         // NULL if not available

    //
    // These members are for internal use by the
    // enumeration routines.
    //

    UINT UserNumber;
    DWORD Flags;
    TCHAR Win95RegName[MAX_USER_NAME];
    USERPOSITION up;
} MIGRATE_USER_ENUM, *PMIGRATE_USER_ENUM;

#define ENUM_SET_WIN9X_HKR      0x0001
#define ENUM_ALL_USERS          0x0002
#define ENUM_NO_FLAGS           0


BOOL
EnumFirstUserToMigrate (
    OUT     PMIGRATE_USER_ENUM e,
    IN      DWORD Flags
    );

BOOL
EnumNextUserToMigrate (
    IN OUT  PMIGRATE_USER_ENUM e
    );

#define REQUEST_QUERYTICKS          1
#define REQUEST_RUN                 2
#define REQUEST_BEGINUSERPROCESSING 3
#define REQUEST_ENDUSERPROCESSING   4

//
// tapi.c
//

BOOL
Tapi_MigrateSystem (
    VOID
    );

BOOL
Tapi_MigrateUser (
    IN PCTSTR UserName,
    IN HKEY UserRoot
    );

DWORD
DeleteSysTapiSettings (
    IN DWORD Request
    );

DWORD
DeleteUserTapiSettings (
    IN DWORD Request,
    IN PMIGRATE_USER_ENUM EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\migutil.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migutil.h

Abstract:

    Includes all header files necessary to use the lib generated by
    common\migutil.  Declares a bunch of utility functions and macros.
    Declares project-wide MAX constants.

Author:

    Jim Schmidt (jimschm) 23-Aug-1996

Revision History:

    Many changes, see SLM log for details.

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// MAX constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_PATH)
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_TRANSLATION             32
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_PATH)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

#define MAX_CMDLINEW	            1024            // maximum number of chars in a Win95 command line

#ifdef UNICODE

#define MAX_SERVER_NAME             MAX_SERVER_NAMEW
#define MAX_USER_NAME               MAX_USER_NAMEW
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYW
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEW
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEW
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEW
#define MAX_CMDLINE	                MAX_CMDLINEW

#define MAX_TCHAR_PATH              MAX_WCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_WCHAR_PRINTABLE_PATH

#else

#define MAX_SERVER_NAME             MAX_SERVER_NAMEA
#define MAX_USER_NAME               MAX_USER_NAMEA
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYA
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEA
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEA
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEA
#define MAX_CMDLINE	                MAX_CMDLINEA

#define MAX_TCHAR_PATH              MAX_MBCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_MBCHAR_PRINTABLE_PATH

#endif



//
// Critical Section APIs, implemented because TryEnterCriticalSection is
// supported only on NT, and we need it on Win9x.
//

typedef struct {
    HANDLE EventHandle;
} OUR_CRITICAL_SECTION, *POUR_CRITICAL_SECTION;

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

PSTR
UnicodeToCcs (
    PCWSTR Source
    );

//
// Fail-proof memory allocators
//

PVOID
SafeHeapAlloc (
    HANDLE g_hHeap,
    DWORD Flags,
    DWORD Size
    );

PVOID
SafeHeapReAlloc (
    HANDLE g_hHeap,
    DWORD Flags,
    PVOID OldBlock,
    DWORD Size
    );

//
// Includes of util modules
//

#include "chartype.h"
#include "debug.h"
#include "log.h"
#include "staticsz.h"
#include "growbuf.h"        // must appear before strings.h and file.h
#include "strings.h"
#include "poolmem.h"
#include "growlist.h"
#include "file.h"
#include "reg.h"
#include "ipc.h"
#include "fileenum.h"
#include "inf.h"
#include "unicode.h"
#include "expandit.h"
#include "hash.h"
#include "uninstall.h"
#include "persist.h"

extern HINSTANCE g_hInst;
extern HANDLE g_hHeap;
extern OSVERSIONINFOA g_OsInfo;


VOID
CenterWindow (
    HWND Wnd,
    HWND Parent     OPTIONAL
    );

VOID
TurnOnWaitCursor (
    VOID
    );

VOID
TurnOffWaitCursor (
    VOID
    );


//
// Version APIs
//

typedef struct {
    WORD CodePage;
    WORD Language;
} TRANSLATION, *PTRANSLATION;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    CHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCSTR FileSpec;
    PCSTR VersionField;
} VERSION_STRUCTA, *PVERSION_STRUCTA;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    WCHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCWSTR FileSpec;
    PCWSTR VersionField;
} VERSION_STRUCTW, *PVERSION_STRUCTW;

BOOL
CreateVersionStructA (
    OUT     PVERSION_STRUCTA VersionStruct,
    IN      PCSTR FileSpec
    );

VOID
DestroyVersionStructA (
    IN      PVERSION_STRUCTA VersionStruct
    );

PCSTR
EnumFirstVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

PCSTR
EnumNextVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

PCSTR
EnumFirstVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct,
    IN      PCSTR VersionField
    );

PCSTR
EnumNextVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

BOOL
CreateVersionStructW (
    OUT     PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR FileSpec
    );

VOID
DestroyVersionStructW (
    IN      PVERSION_STRUCTW VersionStruct
    );

PCWSTR
EnumFirstVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );

PCWSTR
EnumNextVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );

PCWSTR
EnumFirstVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR VersionField
    );

PCWSTR
EnumNextVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );

ULONGLONG
VerGetFileVer (
    IN      PVERSION_STRUCTA VersionStruct
    );

ULONGLONG
VerGetProductVer (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileDateLo (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileDateHi (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileVerOs (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileVerType (
    IN      PVERSION_STRUCTA VersionStruct
    );

//
// Reusable memory alloc, kind of like a GROWBUFFER but more simple
//

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    DWORD SizeNeeded
    );

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    );


VOID
OutOfMemory_Terminate (
    VOID
    );


VOID
SetOutOfMemoryParent (
    HWND hwnd
    );




//
// Error condition tags.
//
// These tags should be used for all error conditions.
//

#define ERROR_CRITICAL
#define ERROR_NONCRITICAL
#define ERROR_TRIVIAL
#define ERROR_ABNORMAL_CONDITION

//
// OSVERSION macros...
//
#define BUILDNUMBER()       (LOWORD(g_OsInfo.dwBuildNumber))
#define ISNT()              (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISWIN9X()           (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#define ISWIN95_GOLDEN()    (ISWIN95() && BUILDNUMBER() <= 1000)
#define ISWIN95_OSR2()      (ISWIN95() && BUILDNUMBER() > 1000)
#define ISWIN95()           (ISWIN9X() && !ISATLEASTWIN98())
#define ISMEMPHIS()         (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==10)
#define ISMILLENNIUM()      (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==90)
#define ISATLEASTOSR2()     (ISWIN9X() && g_OsInfo.dwMajorVersion>=4 && BUILDNUMBER()>1000)
#define ISATLEASTWIN98()    (ISWIN9X() && g_OsInfo.dwMajorVersion>=4 && g_OsInfo.dwMinorVersion>=10)

//
// Platform macros...
//

extern BOOL g_IsPc98;
#define ISPC98()            (g_IsPc98)

//
// Boot drive letter
//

extern PCSTR g_BootDrivePathA;
extern PCWSTR g_BootDrivePathW;
extern PCSTR g_BootDriveA;
extern PCWSTR g_BootDriveW;
extern CHAR g_BootDriveLetterA;
extern WCHAR g_BootDriveLetterW;

//
// String Mapping
//

#define STRMAP_ANY_MATCH                            0
#define STRMAP_COMPLETE_MATCH_ONLY                  0x0001
#define STRMAP_FIRST_CHAR_MUST_MATCH                0x0002
#define STRMAP_RETURN_AFTER_FIRST_REPLACE           0x0004
#define STRMAP_REQUIRE_WACK_OR_NUL                  0x0008

typedef struct {
    BOOL UnicodeData;

    //
    // The filter can replace NewSubString.  (The filter must also
    // set NewSubStringSizeInBytes when replacing NewSubString.)
    //

    union {
        struct {
            PCWSTR OriginalString;
            PCWSTR BeginningOfMatch;
            PCWSTR CurrentString;
            PCWSTR OldSubString;
            PCWSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Unicode;

        struct {
            PCSTR OriginalString;
            PCSTR BeginningOfMatch;
            PCSTR CurrentString;
            PCSTR OldSubString;
            PCSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Ansi;
    };
} REG_REPLACE_DATA, *PREG_REPLACE_DATA;

typedef BOOL(REG_REPLACE_FILTER_PROTOTYPE)(PREG_REPLACE_DATA Data);
typedef REG_REPLACE_FILTER_PROTOTYPE * REG_REPLACE_FILTER;

typedef struct TAG_CHARNODE {
    WORD Char;
    WORD Flags;
    PVOID OriginalStr;
    PVOID ReplacementStr;
    INT ReplacementBytes;

    struct TAG_CHARNODE *NextLevel;
    struct TAG_CHARNODE *NextPeer;

} CHARNODE, *PCHARNODE;

typedef struct {
    CHARNODE Node;
    REG_REPLACE_FILTER Filter;
    ULONG_PTR ExtraData;
} CHARNODEEX, *PCHARNODEEX;


typedef struct {
    POOLHANDLE Pool;
    PCHARNODE FirstLevelRoot;
    BOOL UsesExNode;
    BOOL UsesFilter;
    BOOL UsesExtraData;
} MAPSTRUCT, *PMAPSTRUCT;

//
// APIs
//

PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilter,
    IN      BOOL UsesExtraData
    );

#define CreateStringMapping()   CreateStringMappingEx(FALSE,FALSE)

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    );

VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairA(Map,Old,New) AddStringMappingPairExA(Map,Old,New,NULL,0,0)

VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairW(Map,Old,New) AddStringMappingPairExW(Map,Old,New,NULL,0,0)

BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingSearchAndReplaceA(map,buffer,maxbytes)   MappingSearchAndReplaceExA(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingSearchAndReplaceW(map,buffer,maxbytes)   MappingSearchAndReplaceExW(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceA(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExA(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceW(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExW(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );



typedef struct {
    WCHAR DisplayName[80];
    ULONGLONG Checksum;

    WCHAR Version[80];
    WCHAR Publisher[80];
    WCHAR ProductID[80];
    WCHAR RegisteredOwner[80];
    WCHAR RegisteredCompany[80];
    WCHAR Language[80];
    WCHAR SupportUrl[80];
    WCHAR SupportTelephone[80];
    WCHAR HelpLink[80];
    WCHAR InstallLocation[80];
    WCHAR InstallSource[80];
    WCHAR InstallDate[80];
    WCHAR Contact[80];
    WCHAR Comments[80];
    WCHAR Image[80];
    WCHAR ReadmeUrl[80];
    WCHAR UpdateInfoUrl[80];
} INSTALLEDAPPW, *PINSTALLEDAPPW;

PINSTALLEDAPPW
GetInstalledAppsW (
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT Count             OPTIONAL
    );

typedef PVOID MOVELISTW;


MOVELISTW
AllocateMoveListW (
    IN      POOLHANDLE PoolHandle
    );

//
// Free move list by destrying the pool it was allocated from
//

BOOL
InsertMoveIntoListW (
    IN      MOVELISTW List,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    );

MOVELISTW
RemoveMoveListOverlapW (
    IN      MOVELISTW List
    );

BOOL
OutputMoveListW (
    IN      HANDLE File,
    IN      MOVELISTW List,         OPTIONAL
    IN      BOOL AddNestedMoves
    );



#ifdef UNICODE

#define g_BootDrivePath     g_BootDrivePathW
#define g_BootDrive         g_BootDriveW
#define g_BootDriveLetter   g_BootDriveLetterW

#define MOVELIST                        MOVELISTW
#define AllocateMoveList                AllocateMoveListW
#define InsertMoveIntoList              InsertMoveIntoListW
#define RemoveMoveListOverlap           RemoveMoveListOverlapW
#define OutputMoveList                  OutputMoveListW

#define VERSION_STRUCT                  VERSION_STRUCTW
#define PVERSION_STRUCT                 PVERSION_STRUCTW
#define CreateVersionStruct             CreateVersionStructW
#define DestroyVersionStruct            DestroyVersionStructW
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationW
#define EnumNextVersionTranslation      EnumNextVersionTranslationW
#define EnumFirstVersionValue           EnumFirstVersionValueW
#define EnumNextVersionValue            EnumNextVersionValueW

#define PINSTALLEDAPP                   PINSTALLEDAPPW
#define GetInstalledApps                GetInstalledAppsW

#define AddStringMappingPairEx                  AddStringMappingPairExW
#define AddStringMappingPair                    AddStringMappingPairW
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExW
#define MappingSearchAndReplace                 MappingSearchAndReplaceW
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExW
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceW

#else

#define g_BootDrivePath     g_BootDrivePathA
#define g_BootDrive         g_BootDriveA
#define g_BootDriveLetter   g_BootDriveLetterA

#define VERSION_STRUCT                  VERSION_STRUCTA
#define PVERSION_STRUCT                 PVERSION_STRUCTA
#define CreateVersionStruct             CreateVersionStructA
#define DestroyVersionStruct            DestroyVersionStructA
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationA
#define EnumNextVersionTranslation      EnumNextVersionTranslationA
#define EnumFirstVersionValue           EnumFirstVersionValueA
#define EnumNextVersionValue            EnumNextVersionValueA

#define AddStringMappingPairEx                  AddStringMappingPairExA
#define AddStringMappingPair                    AddStringMappingPairA
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExA
#define MappingSearchAndReplace                 MappingSearchAndReplaceA
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExA
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceA

#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\ntui.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ntui.h

Abstract:

    Includes the NT-side resources and implements the code
    for the GUI mode UI.  There is very little UI in GUI mode;
    what's implemented only appears during error conditions.

Author:

    Jim Schmidt (jimschm) 15-May-1997

Revision History:

    jimschm 20-Sep-1998     Rewrote the network error dialog code

--*/


#include "ntres.h"
#include "msg.h"

//
// ResolveAccountsDlg proc
//

typedef struct {
    PCTSTR UserName;       // NULL = end of list
    PCTSTR *DomainArray;
    PCTSTR OutboundDomain;
    BOOL RetryFlag;
} RESOLVE_ACCOUNTS_ARRAY, *PRESOLVE_ACCOUNTS_ARRAY;

VOID
ResolveAccounts (
    PRESOLVE_ACCOUNTS_ARRAY Array
    );

BOOL
CALLBACK
NetworkDownDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
CreateStatusPopup (
    VOID
    );

VOID
UpdateStatusPopup (
    PCTSTR NewMessage
    );

VOID
HideStatusPopup (
    UINT TimeToHide
    );

VOID
ShowStatusPopup (
    VOID
    );

BOOL
IsStatusPopupVisible (
    VOID
    );

VOID
DestroyStatusPopup (
    VOID
    );


#define STATUS_DELAY        12000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\msgmgr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    msgmgr.h

Abstract:

    Declares the interface to the message manager.  The message manager
    associates a message with a context and one or more objects (files,
    registry keys, or whatever).  The objects can also be handled.  At
    the end of Win9x-side processing, message manager enumerates all
    the messages and adds unhandled messages to the incompatibility
    report.

    This code was written by MikeCo.  It does not conform to our coding
    standards, and is implemented inefficiently.  Be very careful when
    fixing bugs in message manager.

Author:

    Mike Condra (mikeco) 20-May-1997

Revision History:

    jimschm     15-Jan-1999     Added HandleReportObject, cleaned up some formatting

--*/


#pragma once

//
// Function marks an object as "handled"
//
VOID
HandleObject(
    IN      PCTSTR Object,
    IN      PCTSTR ObjectType
    );

//
// Function puts object in a list so that it appears in the short list view
//

VOID
ElevateObject (
    IN      PCTSTR Object
    );

//
// Function marks an object as "handled", but only for the incompatibility report
//
VOID
HandleReportObject (
    IN      PCTSTR Object
    );

//
// Function marks an object as "blocking"
//
VOID
AddBlockingObject (
    IN      PCTSTR Object
    );



//
// Function encodes a registry key and optional value name into a string
// that can identify a Handleable Object.
//
PCTSTR
EncodedObjectNameFromRegKey(
    PCTSTR Key,
    PCTSTR ValueName OPTIONAL
    );

//
// Function records a pairing between a link-target-type Handleable Object and
// its description, taken from the name of a link to the target.
//
VOID
LnkTargToDescription_Add(
    IN PCTSTR Target,
    IN PCTSTR Desc
    );

//
// PUBLIC ROUTINES: Intialization, deferred message resolution, cleanup.
//

//
// Function allocates tables and whatever else is needed to support
// deferred messaging, handled-object tracking, and contexts.
//
VOID
MsgMgr_Init (
    VOID
    );

//
// Function associates a message with an object
//
VOID
MsgMgr_ObjectMsg_Add(
    IN PCTSTR Object,
    IN PCTSTR Component,
    IN PCTSTR Msg
    );

//
// Function associates a message with a context. The context is created
// when first mentioned in a call to this function.
//
VOID
MsgMgr_ContextMsg_Add(
    IN PCTSTR Context,
    IN PCTSTR Component,
    IN PCTSTR Msg
    );

//
// Function makes a context message dependent on the handled state of an object.
//
VOID
MsgMgr_LinkObjectWithContext(
    IN PCTSTR Context,
    IN PCTSTR Object
    );

//
// Function compares the set of handled objects with the set of deferred
// messages; issues context messages if any of their objects remain unhandled:
// issues object messages if the objects are unhandled.
//
VOID
MsgMgr_Resolve (
    VOID
    );

//
// Function cleans up the data structures used by deferred messaging.
//
VOID
MsgMgr_Cleanup (
    VOID
    );

BOOL
IsReportObjectIncompatible (
    IN  PCTSTR Object
    );

BOOL
IsReportObjectHandled (
    IN  PCTSTR Object
    );

VOID
MsgMgr_InitStringMap (
    VOID
    );


typedef struct {
    BOOL Disabled;
    PCTSTR Object;
    PCTSTR Context;
    //
    // internal
    //
    INT Index;
} MSGMGROBJENUM, *PMSGMGROBJENUM;

BOOL
MsgMgr_EnumFirstObject (
    OUT     PMSGMGROBJENUM EnumPtr
    );

BOOL
MsgMgr_EnumNextObject (
    IN OUT  PMSGMGROBJENUM EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\mmediap.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mmediap.h

Abstract:

    Common defines between w95upg\sysmig\mmedia.c and w95upgnt\migmain\mmedia.c.
    If a MM setting should be migrated, just add its generic name to
    MM_SYSTEM_SETTINGS or MM_USER_SETTINGS list and implement 2 functions:
        - pSave##YourSetting in w95upg\sysmig\mmedia.c
        - pRestore##YourSetting in w95upgnt\migmain\mmedia.c

Author:

    Ovidiu Temereanca (ovidiut) 16-Feb-1999

Revision History:

--*/

#pragma once


#ifdef DEBUG
#define DBG_MMEDIA  "MMedia"
#else
#define DBG_MMEDIA
#endif

#define MM_SYSTEM_SETTINGS                              \
                DEFMAC (MMSystemMixerSettings)          \
                DEFMAC (MMSystemDirectSound)            \
                DEFMAC (MMSystemCDSettings)             \
                DEFMAC (MMSystemMCISoundSettings)       \

#define MM_USER_SETTINGS                                \
                DEFMAC (MMUserPreferredOnly)            \
                DEFMAC (MMUserShowVolume)               \
                DEFMAC (MMUserVideoSettings)            \
                DEFMAC (MMUserPreferredPlayback)        \
                DEFMAC (MMUserPreferredRecord)          \
                DEFMAC (MMUserSndVol32)                 \


typedef BOOL (*MM_SETTING_ACTION) (VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\ntres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by d:\nt\private\windows\setup\win9xupg\w95upgnt\ntui\visualc.rc
//
#define IDD_NETWORK_DOWN                103
#define IDD_CHOOSE_DOMAIN               104
#define IDD_RESOLVE_ACCOUNTS            105
#define IDC_USER_LIST                   1015
#define IDC_DOMAIN_LIST                 1017
#define IDC_DOMAIN_LIST_TITLE           1019
#define IDC_TEXT                        1020
#define IDC_DOMAINS_TITLE               1020
#define IDC_INSTRUCTIONS                2000
#define IDC_STATIC                      2001
#define IDC_TEXT1                       2002
#define IDC_USER_TITLE                  2002
#define IDC_USER_NAME                   2003
#define IDC_RETRY                       2004
#define IDC_DOMAIN_TITLE                2004
#define IDC_DOMAIN                      2005
#define IDC_POSSIBLE_DOMAINS            2006
#define IDC_BACK                        2007
#define IDC_NEXT                        2008
#define IDC_FINISH                      2009
#define IDC_NO_RETRY                    2010
#define IDC_STOP                        2011
#define IDC_INSTRUCTIONS2               2012
#define IDC_INSTRUCTIONS3               2013
#define IDD_NETWORK_SLOW                3000
#define IDD_NETWORK_STATUS              3000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\persist.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    persist.h

Abstract:

    General structure persistence functions, structure and definitions.

Author:

    Aghajanyan Souren 27-Mar-2001

Revision History:

--*/

#ifndef _PERSIST_H_
#define _PERSIST_H_

#define BYVALUE TRUE
#define BYREF   FALSE

#define END_OF_STRUCT   (BYTE*)0xffffffff

typedef enum tagPersistResultsEnum{
    Persist_Success = 0, 
    Persist_BadParameters, 
    Persist_Fail, 
    Persist_WrongSignature, 
    Persist_WrongVersion
} PersistResultsEnum;

typedef struct {
    DWORD dwSignature;
    DWORD dwVersion;
    DWORD dwReserved;
} PERSIST_HEADER, * PPERSIST_HEADER;

typedef enum tagStringType{
    NoStr, 
    AnsiStr, 
    UnicodeStr
}StringType;

typedef struct tagFIELD_DESCRIPTION{
    BYTE * Offset;
    StringType  IsString;
    DWORD  Size;
    BOOL   byValue;
    UINT * ArraySizeFieldOffset;
    struct tagFIELD_DESCRIPTION * FieldDescription;
    //
    //For structures with variable size
    //struct VariableSizeStruct{
    //    ......
    //    UINT    uiNumberOfItem;
    //    ITEM    items[1];
    //};
    //Where InitialNumberOfItemInArrayForVariableStructMember is 
    //number of element in items array initialy
    //
    UINT   InitialNumberOfItem;
}FIELD_DESCRIPTION, *PFIELD_DESCRIPTION;


typedef struct tagSTRUCT_DEFINITION{
    DWORD   dwVersion;
    DWORD   dwReserved;
    PFIELD_DESCRIPTION  FieldDescriptions;
}STRUCT_DEFINITION, *PSTRUCT_DEFINITION;


#define GET_STRUCT_MEMBER_OFFSET(structname, fieldname) ((BYTE *)&((structname *)NULL)->fieldname)
#define GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(type, structptr, offset) ((type)(((BYTE *)structptr) + ((DWORD)offset)))
#define GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(type, structptr, offset) ((type)*((DWORD *)(((BYTE *)structptr) + ((DWORD)offset))))
#define GET_TYPE_DEFINITION_FROM_NAME(name, version)     g_DefinitionOf_##name##_##version
#define GET_TYPE_DESCRIPTION_FROM_NAME(name, version)    g_DescriptionOf_##name##_##version

#define PERSIST_BEGIN_DECLARE_STRUCT(name, version) FIELD_DESCRIPTION GET_TYPE_DESCRIPTION_FROM_NAME(name, version)[] = {
#define PERSIST_END_DECLARE_STRUCT(name, version)   {END_OF_STRUCT, NoStr, 0, 0, 0, 0}};\
                                                    STRUCT_DEFINITION GET_TYPE_DEFINITION_FROM_NAME(name, version) = {version, 0, GET_TYPE_DESCRIPTION_FROM_NAME(name, version)};
#define PERSISTENCE_IMPLEMENTATION(name) name;

#define PERSIST_FIELD(structname, type, version, fieldname, isString, byValue, arraySizeVar) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        (isString), \
        sizeof(type), \
        (byValue), \
        GET_STRUCT_MEMBER_OFFSET(structname, arraySizeVar), \
        GET_TYPE_DESCRIPTION_FROM_NAME(type, version), \
        0, \
    }

#define PERSIST_FIELD_BY_VALUE(structname, type, fieldname) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        TRUE, \
        NULL, \
        NULL, \
        0, \
    }

#define PERSIST_FIELD_STRINGW(structname, fieldname) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        UnicodeStr, \
        0, \
        BYREF, \
        NULL, \
        NULL, \
        0, \
    }

#define PERSIST_STRUCT_BY_VALUE_VARIABLE_LENGTH(structname, type, fieldname, arraySizeVar, InitialNumberOfItem) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        TRUE, \
        (UINT *)GET_STRUCT_MEMBER_OFFSET(structname, arraySizeVar), \
        NULL, \
        InitialNumberOfItem, \
    }

#define PERSIST_FIELD_NESTED_TYPE(structname, type, version, fieldname, byValue) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        (byValue), \
        NULL, \
        GET_TYPE_DESCRIPTION_FROM_NAME(type, version), \
        0, \
    }

#define PERSIST_FIELD_NESTED_TYPE_CYCLE(structname, type, version, fieldname, byValue, arraySizeVar) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        (byValue), \
        (UINT *)GET_STRUCT_MEMBER_OFFSET(structname, arraySizeVar), \
        GET_TYPE_DESCRIPTION_FROM_NAME(type, version), \
        0, \
    }


PersistResultsEnum 
PersistStore(
    IN      BYTE ** pBuffer, 
    IN      UINT *Size, 
    IN      BYTE * pStructure, 
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    );

PersistResultsEnum 
PersistLoad(
    IN      BYTE * pBuffer, 
    IN      UINT Size, 
    IN      BYTE * pStructure, 
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    );

VOID  
PersistReleaseMemory(
    IN      BYTE * pStructure, 
    IN      PFIELD_DESCRIPTION pFieldsDescription
    );

BOOL 
CompareStructures(
    IN      BYTE * pStructure1, 
    IN      BYTE * pStructure2, 
    IN      PFIELD_DESCRIPTION pFieldsDescription
    );

#define PERSIST_STORE(pBufferPtr, SizePtr, structname, version, pStructurePtr) PersistStore(pBufferPtr, SizePtr, (BYTE*)pStructurePtr, &(GET_TYPE_DEFINITION_FROM_NAME(structname, version)))
#define PERSIST_LOAD(pBufferPtr, Size, structname, version, pStructurePtr)     PersistLoad(pBufferPtr, Size, (BYTE*)pStructurePtr, &(GET_TYPE_DEFINITION_FROM_NAME(structname, version)))

#define PERSIST_RELEASE_STRUCT_MEMORY(structname, version, pStructurePtr)   PersistReleaseMemory((BYTE*)pStructurePtr, GET_TYPE_DEFINITION_FROM_NAME(structname, version).FieldDescriptions)
#define PERSIST_RELEASE_BUFFER(pBuffer) FreeMem(pBuffer)

#define PERSIST_COMPARE_STRUCTURES(structname, version, pStructurePtr1, pStructurePtr2) CompareStructures((BYTE*)pStructurePtr1, (BYTE*)pStructurePtr2, GET_TYPE_DEFINITION_FROM_NAME(structname, version).FieldDescriptions)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\object.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    object.h

Abstract:

    Declares the interface for "objects" that are used in the Win9x
    to NT registry merge.  The initial goal was to make a single
    merge routine work for all objects -- registry data, INI file
    data and file data.  But this was abandoned because the approach
    was complex.

    So when you see object, think "registry object."

    See w95upgnt\merge\object.c for implementation details.

Author:

    Jim Schmidt (jimschm)   14-Jan-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#define MAX_ENCODED_OBJECT (MAX_OBJECT*6)

extern POOLHANDLE g_TempPool;

extern HKEY g_hKeyRootNT;
extern HKEY g_hKeyRoot95;

typedef struct {
    WORD UseCount;
    WORD OpenCount;
    HKEY OpenKey;
    BOOL Win95;
    TCHAR KeyString[];          // full key path, without root
} KEYPROPS, *PKEYPROPS;

typedef struct {
    DWORD Size;
    DWORD AllocatedSize;
    PBYTE Buffer;
} BINARY_BUFFER, *PBINARY_BUFFER;

typedef struct _tagDATAOBJECT {
    DWORD ObjectType;

    union {
        struct {
            INT             RootItem;
            PKEYPROPS       ParentKeyPtr;
            PCTSTR         ChildKey;
            PKEYPROPS       KeyPtr;
            PCTSTR         ValueName;
            DWORD           Type;
            BINARY_BUFFER   Class;
            DWORD           KeyEnum;
            DWORD           ValNameEnum;
        };
    };

    BINARY_BUFFER Value;
} DATAOBJECT, *PDATAOBJECT;

typedef const PDATAOBJECT CPDATAOBJECT;

#define MAX_CLASS_SIZE 2048


typedef enum {               // FILTER_RETURN_HANDLED        FILTER_RETURN_CONTINUE
    FILTER_KEY_ENUM,         //  Sub objects not enumerated   Sub objects enumerated
    FILTER_CREATE_KEY,       //  Skips empty object creation  Creates the dest object
    FILTER_PROCESS_VALUES,   //  Object values not processed  Object values processed
    FILTER_VALUENAME_ENUM,   //  Specific value skipped       Specific value processed
    FILTER_VALUE_COPY        //  Object read but not written  Object copied
} FILTERTYPE;

typedef enum {
    FILTER_RETURN_CONTINUE,
    FILTER_RETURN_FAIL,
    FILTER_RETURN_HANDLED,
    FILTER_RETURN_DONE,     // return to parent key (if any)
    FILTER_RETURN_DELETED   // object was deleted -- for object.c internal use only
} FILTERRETURN;

// DestObPtr may be NULL
typedef FILTERRETURN(*FILTERFUNCTION)(CPDATAOBJECT ObjectPtr, CPDATAOBJECT DestObPtr, FILTERTYPE FilterType, PVOID Arg);


#ifdef DEBUG

#define OS_TRACKING_DEF , PCSTR File, UINT Line

#else

#define OS_TRACKING_DEF

#endif


VOID
FixUpUserSpecifiedObject (
    PTSTR Object
    );


//
// The following functions modify the object structure, but not the
// object itself.
//

BOOL
TrackedCreateObjectStruct (
    IN  PCTSTR ObjectStr,
    OUT PDATAOBJECT OutObPtr,
    IN  BOOL ObjectType  /* , */                 // either WIN95OBJECT or WINNTOBJECT
    ALLOCATION_TRACKING_DEF
    );

#define CreateObjectStruct(os,oop,ot)  TrackedCreateObjectStruct(os,oop,ot /* , */ ALLOCATION_TRACKING_CALL)

VOID
CreateObjectString (
    IN  CPDATAOBJECT InObPtr,
    OUT PTSTR ObjectStr
    );

BOOL
CombineObjectStructs (
    IN OUT PDATAOBJECT DestObPtr,
    IN     CPDATAOBJECT SrcObPtr
    );

VOID
FreeObjectStruct (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
TrackedDuplicateObjectStruct (
    OUT     PDATAOBJECT DestObPtr,
    IN      CPDATAOBJECT SrcObPtr/* , */
    ALLOCATION_TRACKING_DEF
    );

#define DuplicateObjectStruct(dest,src)  TrackedDuplicateObjectStruct(dest,src /* , */ ALLOCATION_TRACKING_CALL)

//
// The following functions modify the object itself
//

FILTERRETURN
CopyObject (
    IN OUT  PDATAOBJECT SrcObPtr,
    IN      CPDATAOBJECT DestObPtr,
    IN      FILTERFUNCTION FilterFn,    OPTIONAL
    IN      PVOID FilterArg            OPTIONAL
    );


BOOL
CreateObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
OpenObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
WriteObject (
    IN     CPDATAOBJECT DestObPtr
    );

BOOL
ReadObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
ReadObjectEx (
    IN OUT  PDATAOBJECT SrcObPtr,
    IN      BOOL QueryOnly
    );

VOID
FreeObjectVal (
    IN OUT  PDATAOBJECT SrcObPtr
    );

VOID
CloseObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

//
// These functions are private utilities
//

PCTSTR
ConvertKeyToRootString (
    HKEY RegRoot
    );

HKEY
ConvertRootStringToKey (
    PCTSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    );


//
// Below are the DATAOBJECT flags and macros
//

// Values common to all object types
#define OT_VALUE                        0x00000001
#define OT_TREE                         0x00000002
#define OT_WIN95                        0x00000004      // if not specified, object is NT
#define OT_OPEN                         0x00000008

// Values specific to the registry
#define OT_REGISTRY_TYPE                0x00000010
#define OT_REGISTRY_RELATIVE            0x00000100      // used for key renaming
#define OT_REGISTRY_ENUM_KEY            0x00001000
#define OT_REGISTRY_ENUM_VALUENAME      0x00002000
#define OT_REGISTRY_CLASS               0x00010000

#define WIN95OBJECT     1
#define WINNTOBJECT     0

// Flags that indicate which type of object
#define OT_REGISTRY                     0x80000000


__inline BOOL DoesObjectHaveRegistryKey (CPDATAOBJECT p) {
    if (p->KeyPtr) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL DoesObjectHaveRegistryValName (CPDATAOBJECT p) {
    if (p->ValueName) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsObjectRegistryKeyOnly (CPDATAOBJECT p) {
    if (p->KeyPtr && !p->ValueName) {
        return TRUE;
    }
    return FALSE;
}


__inline BOOL IsObjectRegistryKeyAndVal (CPDATAOBJECT p) {
    if (p->KeyPtr && p->ValueName) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsObjectRegistryKeyComplete (CPDATAOBJECT p) {
    if (p->KeyPtr && p->KeyPtr->OpenKey) {
        return TRUE;
    }

    return FALSE;
}

__inline BOOL DoesObjectHaveValue (CPDATAOBJECT p) {
    if (p->ObjectType & OT_VALUE) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsWin95Object (CPDATAOBJECT p) {
    if (p->ObjectType & OT_WIN95) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsRegistryKeyOpen (CPDATAOBJECT p) {
    if (p->KeyPtr && p->KeyPtr->OpenKey) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsRegistryTypeSpecified (CPDATAOBJECT p) {
    if (p->ObjectType & OT_REGISTRY_TYPE) {
        return TRUE;
    }
    return FALSE;
}

BOOL
SetRegistryKey (
    PDATAOBJECT p,
    PCTSTR Key
    );

BOOL
GetRegistryKeyStrFromObject (
    IN  CPDATAOBJECT InObPtr,
    OUT PTSTR RegKey
    );

VOID
FreeRegistryKey (
    PDATAOBJECT p
    );

VOID
FreeRegistryParentKey (
    PDATAOBJECT p
    );

BOOL
SetRegistryValueName (
    PDATAOBJECT p,
    PCTSTR ValueName
    );

VOID
FreeRegistryValueName (
    PDATAOBJECT p
    );

BOOL
SetRegistryClass (
    PDATAOBJECT p,
    PBYTE Class,
    DWORD ClassSize
    );

VOID
FreeRegistryClass (
    PDATAOBJECT p
    );

VOID
SetRegistryType (
    PDATAOBJECT p,
    DWORD Type
    );

BOOL
SetPlatformType (
    PDATAOBJECT p,
    BOOL Win95Type
    );

BOOL
ReadWin95ObjectString (
    PCTSTR ObjectStr,
    PDATAOBJECT ObPtr
    );

BOOL
WriteWinNTObjectString (
    PCTSTR ObjectStr,
    CPDATAOBJECT SrcObPtr
    );

BOOL
ReplaceValue (
    PDATAOBJECT ObPtr,
    PBYTE NewValue,
    DWORD Size
    );

BOOL
GetDwordFromObject (
    CPDATAOBJECT ObPtr,
    PDWORD DwordPtr            OPTIONAL
    );

PCTSTR
GetStringFromObject (
    CPDATAOBJECT ObPtr
    );

#define ReplaceValueWithString(x,s) ReplaceValue((x),(PBYTE)(s),SizeOfString(s))

BOOL
DeleteDataObject (
    IN   PDATAOBJECT ObjectPtr
    );

BOOL
DeleteDataObjectValue(
    IN      CPDATAOBJECT ObPtr
    );

BOOL
RenameDataObject (
    IN      CPDATAOBJECT SrcObPtr,
    IN      CPDATAOBJECT DestObPtr
    );

BOOL
CheckIfNtKeyExists (
    IN      CPDATAOBJECT SrcObjectPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\poolmem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    poolmem.h

Abstract:

    Declares the pool memory interface.  A pool of memory is a set of
    blocks (typically 8K each) that are used for several allocations,
    and then freed at the end of processing.  See below for routines.

Author:

    Marc R. Whitten (marcw)     02-Feb-1997

Revision History:

    jimschm     04-Feb-1998     Named pools for tracking

--*/

#pragma once

typedef PVOID POOLHANDLE;


/*++

  Create and destroy routines:

    POOLHANDLE
    PoolMemInitPool (
        VOID
        );

    POOLHANDLE
    PoolMemInitNamedPool (
        IN      PCSTR Name
        );

    VOID
    PoolMemDestroyPool (
        IN      POOLHANDLE Handle
        );

  Primitive routines:

    PVOID
    PoolMemGetMemory (
        IN      POOLHANDLE Handle,
        IN      DWORD Size
        );

    PVOID
    PoolMemGetAlignedMemory (
        IN      POOLHANDLE Handle,
        IN      DWORD Size
        );

    VOID
    PoolMemReleaseMemory (
        IN      POOLHANDLE Handle,
        IN      PVOID Memory
        );

  Performance and debugging control:

    VOID
    PoolMemSetMinimumGrowthSize (
        IN      POOLHANDLE Handle,
        IN      DWORD GrowthSize
        );

    VOID
    PoolMemEmptyPool (
        IN      POOLHANDLE Handle
        );

    VOID
    PoolMemDisableTracking (
        IN      POOLHANDLE Handle
        );

  Allocation and duplication of data types:

    PCTSTR
    PoolMemCreateString (
        IN      POOLHANDLE Handle,
        IN      UINT TcharCount
        );

    PCTSTR
    PoolMemCreateDword (
        IN      POOLHANDLE Handle
        );

    PBYTE
    PoolMemDuplicateMemory (
        IN      POOLHANDLE Handle,
        IN      PBYTE Data,
        IN      UINT DataSize
        );

    PDWORD
    PoolMemDuplciateDword (
        IN      POOLHANDLE Handle,
        IN      DWORD Data
        );

    PTSTR
    PoolMemDuplicateString (
        IN      POOLHANDLE Handle,
        IN      PCTSTR String
        );

    PTSTR
    PoolMemDuplicateMultiSz (
        IN      POOLHANDLE Handle,
        IN      PCTSTR MultiSz
        );


--*/


//
// Default size of memory pool blocks. This can be changed on a per-pool basis
// by calling PoolMemSetMinimumGrowthSize().
//

#define POOLMEMORYBLOCKSIZE 8192

//
// if DEBUG is defined, poolmem keeps a tally of common statistics on all
// pools. These include number of alloc and free requests, number of
// actual allocations and frees, and various size measures.
//
// PoolMem also checks each PoolMemReleaseMemory() call to ensure that the
// address passed is a valid poolmem address that has not yet been freed.
//

#ifdef DEBUG

#define POOLMEMTRACKDEF  LPCSTR File, DWORD Line,
#define POOLMEMTRACKCALL g_TrackFile,g_TrackLine,

#else

#define POOLMEMTRACKDEF
#define POOLMEMTRACKCALL

#endif


POOLHANDLE
PoolMemInitPool (
    VOID
    );

#ifdef DEBUG

POOLHANDLE
PoolMemInitNamedPool (
    IN      PCSTR Name
    );

#else

#define PoolMemInitNamedPool(x) PoolMemInitPool()

#endif

VOID
PoolMemDestroyPool (
    IN POOLHANDLE Handle
    );


//
// Callers should use PoolMemGetMemory or PoolMemGetAlignedMemory. These each decay into
// PoolMemRealGetMemory.
//
#define PoolMemGetMemory(h,s)           SETTRACKCOMMENT(PVOID,"PoolMemGetMemory",__FILE__,__LINE__)\
                                        PoolMemRealGetMemory((h),(s),0 /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

#define PoolMemGetAlignedMemory(h,s)    SETTRACKCOMMENT(PVOID,"PoolMemGetAlignedMemory",__FILE__,__LINE__)\
                                        PoolMemRealGetMemory((h),(s),sizeof(DWORD) /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

PVOID PoolMemRealGetMemory(IN POOLHANDLE Handle, IN DWORD Size, IN DWORD AlignSize /*,*/ ALLOCATION_TRACKING_DEF);

VOID PoolMemReleaseMemory (IN POOLHANDLE Handle, IN PVOID Memory);
VOID PoolMemSetMinimumGrowthSize(IN POOLHANDLE Handle, IN DWORD Size);


VOID
PoolMemEmptyPool (
    IN      POOLHANDLE Handle
    );


//
// PoolMem created strings are always aligned on DWORD boundaries.
//
#define PoolMemCreateString(h,x) ((LPTSTR) PoolMemGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PoolMemCreateDword(h)    ((PDWORD) PoolMemGetMemory((h),sizeof(DWORD)))


__inline
PBYTE
PoolMemDuplicateMemory (
    IN POOLHANDLE Handle,
    IN PBYTE DataToCopy,
    IN UINT SizeOfData
    )
{
    PBYTE Data;

    Data = (PBYTE) PoolMemGetAlignedMemory (Handle, SizeOfData);
    if (Data) {
        CopyMemory (Data, DataToCopy, SizeOfData);
    }

    return Data;
}


__inline
PDWORD PoolMemDuplicateDword (
    IN POOLHANDLE Handle,
    IN DWORD ValueToCopy
    )
{
    PDWORD rWord;

    rWord = (PDWORD) PoolMemGetMemory (Handle, sizeof (ValueToCopy));
    if (rWord) {
        *rWord = ValueToCopy;
    }

    return rWord;
}


__inline
PSTR
RealPoolMemDuplicateStringA (
    IN POOLHANDLE    Handle,
    IN PCSTR         StringToCopy /*,*/
       ALLOCATION_TRACKING_DEF
    )

{
    PSTR rString = (PSTR) PoolMemRealGetMemory(Handle,SizeOfStringA(StringToCopy),sizeof(WCHAR) /*,*/ ALLOCATION_INLINE_CALL);

    if (rString) {

        StringCopyA((unsigned char *) rString, (const unsigned char *) StringToCopy);
    }

    return rString;
}


__inline
PWSTR
RealPoolMemDuplicateStringW (
    IN POOLHANDLE    Handle,
    IN PCWSTR        StringToCopy /*,*/
       ALLOCATION_TRACKING_DEF
    )

{
    PWSTR rString = (PWSTR) PoolMemRealGetMemory(Handle,SizeOfStringW(StringToCopy),sizeof(WCHAR) /*,*/ ALLOCATION_INLINE_CALL);

    if (rString) {

        StringCopyW(rString,StringToCopy);
    }

    return rString;
}


#define PoolMemDuplicateStringA(h,s)    SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringA",__FILE__,__LINE__)\
                                        RealPoolMemDuplicateStringA((h),(s) /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

#define PoolMemDuplicateStringW(h,s)    SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringW",__FILE__,__LINE__)\
                                        RealPoolMemDuplicateStringW((h),(s) /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

__inline
PSTR
RealPoolMemDuplicateStringABA (
    IN      POOLHANDLE Handle,
    IN      PCSTR StringStart,
    IN      PCSTR End /*,*/
            ALLOCATION_TRACKING_DEF
    )

{
    PSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = (PSTR) PoolMemRealGetMemory (
                        Handle,
                        (PBYTE) End - (PBYTE) StringStart + sizeof (CHAR),
                        sizeof(WCHAR) /*,*/
                        ALLOCATION_INLINE_CALL
                        );

    if (rString) {

        StringCopyABA(rString,StringStart,End);
    }

    return rString;
}


__inline
PWSTR
RealPoolMemDuplicateStringABW (
    IN      POOLHANDLE Handle,
    IN      PCWSTR StringStart,
    IN      PCWSTR End /*,*/
            ALLOCATION_TRACKING_DEF
    )

{
    PWSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = (PWSTR) PoolMemRealGetMemory (
                            Handle,
                            (PBYTE) End - (PBYTE) StringStart + sizeof (WCHAR),
                            sizeof(WCHAR) /*,*/
                            ALLOCATION_INLINE_CALL
                            );

    if (rString) {

        StringCopyABW(rString,StringStart,End);
    }

    return rString;
}

#define PoolMemDuplicateStringABA(h,s,e) SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringABA",__FILE__,__LINE__)\
                                         RealPoolMemDuplicateStringABA((h),(s),(e) /*,*/ ALLOCATION_TRACKING_CALL)\
                                         CLRTRACKCOMMENT

#define PoolMemDuplicateStringABW(h,s,e) SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringABW",__FILE__,__LINE__)\
                                         RealPoolMemDuplicateStringABW((h),(s),(e) /*,*/ ALLOCATION_TRACKING_CALL)\
                                         CLRTRACKCOMMENT



PSTR
PoolMemDuplicateMultiSzA (
    IN POOLHANDLE    Handle,
    IN PCSTR         MultiSzToCopy
    );

PWSTR
PoolMemDuplicateMultiSzW (
    IN POOLHANDLE    Handle,
    IN PCWSTR        MultiSzToCopy
    );

#ifdef UNICODE
#define PoolMemDuplicateString  PoolMemDuplicateStringW
#define PoolMemDuplicateMultiSz PoolMemDuplicateMultiSzW
#else
#define PoolMemDuplicateString  PoolMemDuplicateStringA
#define PoolMemDuplicateMultiSz PoolMemDuplicateMultiSzA
#endif

#ifdef DEBUG

VOID
PoolMemDisableTracking (
    IN POOLHANDLE Handle
    );

#else

#define PoolMemDisableTracking(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\rasmig.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rasmig.h

Abstract:

    Declares the interface for gathering RAS settings during
    the Win9x phase of the upgrade.

Author:

    Marc R. Whitten (marcw) 06-Jun-1997

Revision History:

    <alias> <date> <comments>

--*/


extern GROWLIST g_DunPaths;

BOOL
IsRasInstalled (
    VOID
    );


DWORD
ProcessRasSettings (
    IN      DWORD Request,
    IN      PUSERENUM EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\rasmignt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rasmignt.h

Abstract:

    Declares the public interface into the RAS migration code.
    There is a system-wide component and a per-user component to
    RAS migration.

Author:

    Marc R. Whitten (marcw)     06-Jun-1997

Revision History:

    <alias> <date> <comments>

--*/



BOOL
Ras_MigrateUser (
    LPCTSTR User,
    HKEY    UserRoot
    );

BOOL
Ras_MigrateSystem (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\progbar.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    progbar.h

Abstract:

    Declares the functions, variables and macros for the progress
    bar utilities.  The progress bar utilities manage a single
    progress bar by dividing it into slices.  Each slice has
    an initial static size.  The count for each slice is scaled
    independently, so code can dynamically change the slice
    count as an aid to help tick the progress bar more smoothly.

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm 01-Jul-1998     Rewrite

--*/

#pragma once

//
// Variables for macros
//
extern HWND    g_Component;
extern HWND    g_SubComponent;
extern HANDLE  g_ComponentCancelEvent;
extern HANDLE  g_SubComponentCancelEvent;

//
// Initialization and termination
//

VOID
InitializeProgressBar (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    );


VOID
TerminateProgressBar (
    VOID
    );

//
// Registration, estimate revision and ticking
//

UINT
RegisterProgressBarSlice (
    IN      UINT InitialEstimate
    );

VOID
ReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    );

VOID
BeginSliceProcessing (
    IN      UINT SliceId
    );

BOOL
TickProgressBarDelta (
    IN      UINT Ticks
    );

BOOL
TickProgressBar (
    VOID
    );

VOID
EndSliceProcessing (
    VOID
    );


//
// Delayed titles
//

BOOL
ProgressBar_SetWindowStringA (
    IN HWND     Window,
    IN HANDLE   CancelEvent,
    IN LPCSTR   Message,            OPTIONAL
    IN DWORD    MessageId           OPTIONAL
    );

BOOL
ProgressBar_SetDelayedMessageA (
    IN HWND             Window,
    IN HANDLE           CancelEvent,
    IN LPCSTR           Message,
    IN DWORD            MessageId,
    IN DWORD            Delay
    );

VOID
ProgressBar_CancelDelayedMessage (
    IN HANDLE           CancelEvent
    );

#if 0

BOOL
ProgressBar_CreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    );

BOOL
ProgressBar_CancelTickThread (
    IN HANDLE CancelEvent
    );

#endif

//
// Macros
//

#define ProgressBar_CancelDelayedComponent() ProgressBar_CancelDelayedMessage(g_ComponentCancelEvent);
#define ProgressBar_CancelDelayedSubComponent() ProgressBar_CancelDelayedMessage(g_SubComponentCancelEvent);

#ifndef UNICODE

#define ProgressBar_SetComponent(s)                  ProgressBar_SetWindowStringA(g_Component,g_ComponentCancelEvent,(s),0)

#if !defined PRERELEASE || !defined DEBUG

#define ProgressBar_SetSubComponent(s)               ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define ProgressBar_SetFnName(s)
#define ProgressBar_ClearFnName()

#else

#define ProgressBar_SetSubComponent(s)               ((s) == NULL ? 1 : ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0))
#define ProgressBar_SetFnName(s)                     ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define ProgressBar_ClearFnName()                    ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,0)

#endif

#define ProgressBar_SetComponentById(n)              ProgressBar_SetWindowStringA(g_Component,g_ComponentCancelEvent,NULL,(n))
#define ProgressBar_SetSubComponentById(n)           ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n))
#define ProgressBar_SetDelayedComponent(s,d)         ProgressBar_SetDelayedMessageA(g_Component,g_ComponentCancelEvent,(s),0,(d))
#define ProgressBar_SetDelayedSubComponent(s,d)      ProgressBar_SetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,(s),0,(d))
#define ProgressBar_SetDelayedComponentById(n,d)     ProgressBar_SetDelayedMessageA(g_Component,g_ComponentCancelEvent,NULL,(n),(d))
#define ProgressBar_SetDelayedSubComponentById(n,d)  ProgressBar_SetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n),(d))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\rascmn.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rascmn.h

Abstract:

    Defines constants needed for both the Win9x and NT sides of
    RAS migration.

Author:

    Marc R. Whitten (marcw)     22-Nov-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

// Whistler bug 34270 Win9x: Upgrade: Require Data Encryption setting for VPN
// connections is not migrated
//
// Session configuration options
//
// from win9x\TELECOM\rna\inc\rnaspi.h
//
#define SMMCFG_SW_COMPRESSION       0x00000001  // Software compression is on
#define SMMCFG_PW_ENCRYPTED         0x00000002  // Encrypted password only
#define SMMCFG_NW_LOGON             0x00000004  // Logon to the network
#define SMMCFG_UNUSED               0x00000010  // Not used, legacy
#define SMMCFG_LOGGING              0x00000100  // Record a log file
#define SMMCFG_SW_ENCRYPTION        0x00000200  // 40 bit encryption is required
#define SMMCFG_SW_ENCRYPTION_STRONG 0x00000400  // 128 bit encryption is required
#define SMMCFG_MULTILINK            0x80000000  // Use multilink

// 'DwDataEncryption' codes.  These are now bitmask-ish for the convenience of
// the UI in building capability masks, though more than one bit will never be
// set in 'dwDataEncryption'.
///
// FYI - We store these are decimal values in the pbk
//
// from nt\net\rras\ras\ui\inc\pbk.h
//
#define DE_None       TEXT("0")   // Do not encrypt
#define DE_IfPossible TEXT("8")   // Request encryption but none OK
#define DE_Require    TEXT("256") // Require encryption of any strength
#define DE_RequireMax TEXT("512") // Require maximum strength encryption

// Base protocol definitions (see dwBaseProtocol).
//
// from nt\net\rras\ras\ui\inc\pbk.h
//
#define BP_Ppp  TEXT("1")
#define BP_Slip TEXT("2")
#define BP_Ras  TEXT("3")

// VPN Strategy
//
// from nt\net\published\inc\ras.w
//
#define VS_Default   TEXT("0") // default (PPTP for now)
#define VS_PptpOnly  TEXT("1") // Only PPTP is attempted.
#define VS_PptpFirst TEXT("2") // PPTP is tried first.
#define VS_L2tpOnly  TEXT("3") // Only L2TP is attempted.
#define VS_L2tpFirst TEXT("4") // L2TP is tried first.

// The entry type used to determine which UI properties
// are to be presented to user.  This generally corresponds
// to a Connections "add" wizard selection.
//
// from nt\net\rras\ras\ui\inc\pbk.h
//
#define RASET_Phone     TEXT("1") // Phone lines: modem, ISDN, X.25, etc
#define RASET_Vpn       TEXT("2") // Virtual private network
#define RASET_Direct    TEXT("3") // Direct connect: serial, parallel
#define RASET_Internet  TEXT("4") // BaseCamp internet
#define RASET_Broadband TEXT("5") // Broadband

// Media strings
//
#define RASMT_Rastapi TEXT("rastapi") // media for RASET_Vpn/RASET_Broadband
#define RASMT_Serial  TEXT("serial")  // media for RASET_Phone/RASET_Direct
#define RASMT_Vpn     TEXT("WAN Miniport (PPTP)")

// RASENTRY 'szDeviceType' strings
//
// from win9x\TELECOM\rna\inc\rnaph.h
//
#define RASDT_Modem TEXT("modem") // Modem
#define RASDT_Isdn  TEXT("isdn")  // ISDN
//#define RASDT_X25   TEXT("x25")   // X.25
#define RASDT_Vpn   TEXT("vpn")   // VPN
//#define RASDT_Pad   TEXT("pad")   // PAD
#define RASDT_Atm   TEXT("atm")   // ATM

// Internal, used to track what device type is being used
//
#define RASDT_Modem_V 1 // Modem
#define RASDT_Isdn_V  2 // ISDN
//#define RASDT_X25_V   3 // X.25
#define RASDT_Vpn_V   4 // VPN
//#define RASDT_Pad_V   5 // PAD
#define RASDT_Atm_V   6 // ATM

// RASENTRY 'szDeviceType' default strings
//
// from: nt\net\published\inc\ras.w
//
#define RASDT_Modem_NT      TEXT("modem")
#define RASDT_Isdn_NT       TEXT("isdn")
//#define RASDT_X25_NT        TEXT("x25")
#define RASDT_Vpn_NT        TEXT("vpn")
//#define RASDT_Pad_NT        TEXT("pad")
#define RASDT_Generic_NT    TEXT("GENERIC")
#define RASDT_Serial_NT     TEXT("SERIAL")
#define RASDT_FrameRelay_NT TEXT("FRAMERELAY")
#define RASDT_Atm_NT        TEXT("ATM")
#define RASDT_Sonet_NT      TEXT("SONET")
#define RASDT_SW56_NT       TEXT("SW56")
#define RASDT_Irda_NT       TEXT("IRDA")
#define RASDT_Parallel_NT   TEXT("PARALLEL")
#define RASDT_PPPoE_NT      TEXT("PPPoE")

// from: nt\net\rras\ras\inc\rasmxs.h
//
#define  MXS_SWITCH_TXT TEXT("switch")
#define  MXS_NULL_TXT   TEXT("null")

// Negotiated protocols
//
#define SMMPROT_NB  0x00000001  // NetBEUI
#define SMMPROT_IPX 0x00000002  // IPX
#define SMMPROT_IP  0x00000004  // TCP/IP

// from: win9x\TELECOM\rna\inc\rnap.h
//
#define DIALUI_NO_PROMPT    0x00000001 // Do not display connect prompt
#define DIALUI_NO_CONFIRM   0x00000002 // Do not display connect confirm
#define DIALUI_NO_TRAY      0x00000004 // No tray icon
#define DIALUI_NO_NW_LOGOFF 0x00000008 // Do not display NetWare logoff dialog

// "Typical" authentication setting masks.See 'dwAuthRestrictions'
//
// Values have been converted to decimal from nt\net\rras\ras\ui\inc\pbk.h
//
// AR_F_TypicalUnsecure = AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP |
//                        AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2
// AR_F_TypicalSecure   = AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2
//
#define AR_F_TypicalUnsecure TEXT("632")
#define AR_F_TypicalSecure   TEXT("608")

// Flags for the fdwTCPIP field
//
// from: win9x\TELECOM\rna\inc\rnap.h
//
#define IPF_IP_SPECIFIED    0x00000001
#define IPF_NAME_SPECIFIED  0x00000002
#define IPF_NO_COMPRESS     0x00000004
#define IPF_NO_WAN_PRI      0x00000008

// IP address source definitions (see dwIpAddressSource)
//
// from: nt\net\rras\ras\ui\inc\pbk.h
//
#define ASRC_ServerAssigned  TEXT("1") // For router means "the ones in NCPA"
#define ASRC_RequireSpecific TEXT("2")
#define ASRC_None            TEXT("3") // Router only

// Entry Defaults
//
#define DEF_IpFrameSize    TEXT("1006")
#define DEF_HangUpSeconds  TEXT("120")
#define DEF_HangUpPercent  TEXT("10")
#define DEF_DialSeconds    TEXT("120")
#define DEF_DialPercent    TEXT("75")
#define DEF_RedialAttempts TEXT("3")
#define DEF_RedialSeconds  TEXT("60")
#define DEF_NetAddress     TEXT("0.0.0.0")
#define DEF_CustomAuthKey  TEXT("-1")
#define DEF_VPNPort        TEXT("VPN2-0")
#define DEF_ATMPort        TEXT("ATM1-0")
//
// 'OverridePref' bits.  Set indicates the corresponding value read from the
// phonebook should be used.  Clear indicates the global user preference
// should be used.
//
// from: nt\net\rras\ras\ui\inc\pbk.h
//
// RASOR_RedialAttempts | RASOR_RedialSeconds | RASOR_IdleDisconnectSeconds |
// RASOR_RedialOnLinkFailure
//
#define DEF_OverridePref   TEXT("15")
//
// RASENTRY 'dwDialMode' values.
//
// from: nt\net\published\inc\ras.w
//
#define DEF_DialMode       TEXT("1")

// "Typical" authentication setting constants.  See 'dwTypicalAuth'.
//
// from: nt\net\rras\ras\ui\inc\pbk.h
//
#define TA_Unsecure   TEXT("1")
#define TA_Secure     TEXT("2")
#define TA_CardOrCert TEXT("3")

#define RAS_UI_FLAG_TERMBEFOREDIAL      0x1
#define RAS_UI_FLAG_TERMAFTERDIAL       0x2
#define RAS_UI_FLAG_OPERATORASSISTED    0x4
#define RAS_UI_FLAG_MODEMSTATUS         0x8

#define RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL  0x00000010
#define RAS_CFG_FLAG_SOFTWARE_FLOW_CONTROL  0x00000020
#define RAS_CFG_FLAG_STANDARD_EMULATION     0x00000040
#define RAS_CFG_FLAG_COMPRESS_DATA          0x00000001
#define RAS_CFG_FLAG_USE_ERROR_CONTROL      0x00000002
#define RAS_CFG_FLAG_ERROR_CONTROL_REQUIRED 0x00000004
#define RAS_CFG_FLAG_USE_CELLULAR_PROTOCOL  0x00000008
#define RAS_CFG_FLAG_NO_WAIT_FOR_DIALTONE   0x00000200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\reg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg.h

Abstract:

    Implements macros to simplify the registry APIs and to track
    the resource allocations.

Author:

    Jim Schmidt (jimschm) 24-Mar-1997

Revision History:

    jimschm 09-Apr-1997     Expanded Get functionality

--*/

#pragma once

#define HKEY_ROOT   ((HKEY) 0X7FFFFFFF)

BOOL
RegInitialize (
    VOID
    );

VOID
RegTerminate (
    VOID
    );


VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    );

VOID
RegTerminateCache (
    VOID
    );

//
// APIs to set access mode
//

REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    );

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Our* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys()

#define TrackedRegOpenKey             RegOpenKey
#define TrackedRegCreateKey           RegCreateKey
#define TrackedRegOpenKeyEx           RegOpenKeyEx
#define TrackedRegCreateKeyEx         RegCreateKeyEx

#define TrackedRegOpenKeyA            RegOpenKeyA
#define TrackedRegCreateKeyA          RegCreateKeyA
#define TrackedRegOpenKeyExA          RegOpenKeyExA
#define TrackedRegCreateKeyExA        RegCreateKeyExA

#define TrackedRegOpenKeyW            RegOpenKeyW
#define TrackedRegCreateKeyW          RegCreateKeyW
#define TrackedRegOpenKeyExW          RegOpenKeyExW
#define TrackedRegCreateKeyExW        RegCreateKeyExW

#define OurRegOpenKeyExA            RegOpenKeyExA
#define OurRegCreateKeyExA          RegCreateKeyExA

#define OurRegOpenRootKeyA(a,b)
#define OurRegOpenRootKeyW(a,b)

#define OurRegOpenKeyExW            RegOpenKeyExW
#define OurRegCreateKeyExW          RegCreateKeyExW

#define CloseRegKey                 RealCloseRegKey

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys (
    VOID
    );

LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );


VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define OurRegOpenRootKey OurRegOpenRootKeyW
#else
#define OurRegOpenRootKey OurRegOpenRootKeyA
#endif


LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey(k) OurCloseRegKey(k,__FILE__,__LINE__)


#define TrackedRegOpenKeyEx(key,subkey,u,sam,res) OurRegOpenKeyEx(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKey(k,sk,rp) OurRegOpenKeyEx(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKey(k,sk,rp) OurRegCreateKeyEx(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExA(key,subkey,u,sam,res) OurRegOpenKeyExA(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyA(k,sk,rp) OurRegOpenKeyExA(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyA(k,sk,rp) OurRegCreateKeyExA(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExW(key,subkey,u,sam,res) OurRegOpenKeyExW(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyW(k,sk,rp) OurRegOpenKeyExW(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyW(K,sk,rp) OurRegCreateKeyExW(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef RegOpenKey
#undef RegCreateKey
#undef RegOpenKeyEx
#undef RegCreateKeyEx

#define RegCloseKey USE_CloseRegKey
#define RegOpenKeyA USE_TrackedRegOpenKeyA
#define RegCreateKeyA USE_TrackedRegCreateKeyA
#define RegOpenKeyExA USE_TrackedRegOpenKeyExA
#define RegCreateKeyExA USE_TrackedRegCreateKeyExA
#define RegOpenKeyW USE_TrackedRegOpenKeyw
#define RegCreateKeyW USE_TrackedRegCreateKeyW
#define RegOpenKeyExW USE_TrackedRegOpenKeyExW
#define RegCreateKeyExW USE_TrackedRegCreateKeyExW

#endif


#ifdef UNICODE
#define OurRegOpenKeyEx         OurRegOpenKeyExW
#define OurRegCreateKeyEx       OurRegCreateKeyExW
#else
#define OurRegOpenKeyEx         OurRegOpenKeyExA
#define OurRegCreateKeyEx       OurRegCreateKeyExA
#endif

//
// Reg API simplification routines
//

typedef struct {
    HKEY KeyHandle;
    BOOL OpenedByEnum;
    DWORD Index;
    CHAR SubKeyName[MAX_REGISTRY_KEYA];
} REGKEY_ENUMA, *PREGKEY_ENUMA;

typedef struct {
    HKEY KeyHandle;
    BOOL OpenedByEnum;
    DWORD Index;
    WCHAR SubKeyName[MAX_REGISTRY_KEYW];
} REGKEY_ENUMW, *PREGKEY_ENUMW;

typedef struct {
    HKEY KeyHandle;
    DWORD Index;
    CHAR ValueName[MAX_REGISTRY_VALUE_NAMEA];
    DWORD Type;
    DWORD DataSize;
} REGVALUE_ENUMA, *PREGVALUE_ENUMA;

typedef struct {
    HKEY KeyHandle;
    DWORD Index;
    WCHAR ValueName[MAX_REGISTRY_VALUE_NAMEW];
    DWORD Type;
    DWORD DataSize;
} REGVALUE_ENUMW, *PREGVALUE_ENUMW;

typedef struct _tagREGKEYINFOA {
    CHAR KeyName[MAX_REGISTRY_KEYA];
    HKEY KeyHandle;
    REGKEY_ENUMA KeyEnum;
    UINT BaseKeyBytes;
    struct _tagREGKEYINFOA *Parent, *Child;
} REGKEYINFOA, *PREGKEYINFOA;

typedef struct _tagREGKEYINFOW {
    WCHAR KeyName[MAX_REGISTRY_KEYW];
    HKEY KeyHandle;
    REGKEY_ENUMW KeyEnum;
    UINT BaseKeyBytes;
    struct _tagREGKEYINFOW *Parent, *Child;
} REGKEYINFOW, *PREGKEYINFOW;

typedef enum {
    ENUMERATE_SUBKEY_BEGIN,
    ENUMERATE_SUBKEY_RETURN,
    ENUMERATE_SUBKEY_NEXT,
    ENUMERATE_SUBKEY_DONE,
    NO_MORE_ITEMS
} REGTREESTATE;

typedef struct {
    CHAR FullKeyName[MAX_REGISTRY_KEYA];
    UINT FullKeyNameBytes;
    UINT EnumBaseBytes;
    PREGKEYINFOA CurrentKey;
    POOLHANDLE EnumPool;
    REGTREESTATE State;
    BOOL FirstEnumerated;
} REGTREE_ENUMA, *PREGTREE_ENUMA;

typedef struct {
    WCHAR FullKeyName[MAX_REGISTRY_KEYW];
    UINT FullKeyNameBytes;
    UINT EnumBaseBytes;
    PREGKEYINFOW CurrentKey;
    POOLHANDLE EnumPool;
    REGTREESTATE State;
    BOOL FirstEnumerated;
} REGTREE_ENUMW, *PREGTREE_ENUMW;


//
// Enum functions
//

BOOL
EnumFirstRegKeyA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegKeyW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
RealEnumFirstRegKeyStrA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

BOOL
RealEnumFirstRegKeyStrW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

#ifdef DEBUG

#define EnumFirstRegKeyStrA(a,b) RealEnumFirstRegKeyStrA(a,b,__FILE__,__LINE__)
#define EnumFirstRegKeyStrW(a,b) RealEnumFirstRegKeyStrW(a,b,__FILE__,__LINE__)

#else

#define EnumFirstRegKeyStrA RealEnumFirstRegKeyStrA
#define EnumFirstRegKeyStrW RealEnumFirstRegKeyStrW

#endif



BOOL
EnumNextRegKeyA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

BOOL
EnumNextRegKeyW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

VOID
AbortRegKeyEnumA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

VOID
AbortRegKeyEnumW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

BOOL
RealEnumFirstRegKeyInTreeA (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTreeA(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTreeA",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTreeA(e,base)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumFirstRegKeyInTreeW (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTreeW(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTreeW",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTreeW(e,base)\
                                        CLRTRACKCOMMENT


BOOL
RealEnumNextRegKeyInTreeA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

#define EnumNextRegKeyInTreeA(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTreeA",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTreeA(e)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumNextRegKeyInTreeW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );

#define EnumNextRegKeyInTreeW(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTreeW",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTreeW(e)\
                                        CLRTRACKCOMMENT

VOID
AbortRegKeyTreeEnumA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

VOID
AbortRegKeyTreeEnumW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );


BOOL
EnumFirstRegValueA (
    OUT     PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegValueW (
    OUT     PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumNextRegValueA (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    );

BOOL
EnumNextRegValueW (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    );

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    );

PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    );

#define CreateEncodedRegistryStringA(k,v) CreateEncodedRegistryStringExA(k,v,TRUE)
#define CreateEncodedRegistryStringW(k,v) CreateEncodedRegistryStringExW(k,v,TRUE)

VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    );

VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    );


BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );

BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );


//
// Versions that allow caller to specify allocator, and macro that uses
// MemAllocWrapper
//

typedef PVOID (ALLOCATOR_PROTOTYPE)(DWORD Size);
typedef ALLOCATOR_PROTOTYPE * ALLOCATOR;

ALLOCATOR_PROTOTYPE MemAllocWrapper;

typedef VOID (DEALLOCATOR_PROTOTYPE)(PCVOID Mem);
typedef DEALLOCATOR_PROTOTYPE * DEALLOCATOR;

DEALLOCATOR_PROTOTYPE MemFreeWrapper;

BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataA(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueDataA",__FILE__, __LINE__)\
                                        GetRegValueData2A((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        CLRTRACKCOMMENT


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataW(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueDataW",__FILE__, __LINE__)\
                                        GetRegValueData2W((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeA(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfTypeA",__FILE__,__LINE__)\
                                                    GetRegValueDataOfType2A((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeW(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfTypeW",__FILE__,__LINE__)\
                                                    GetRegValueDataOfType2W((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyData2A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataA(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyDataA",__FILE__,__LINE__)\
                                    GetRegKeyData2A((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyData2W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataW(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyDataW",__FILE__,__LINE__)\
                                    GetRegKeyData2W((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataA(keystr,value) SETTRACKCOMMENT(PBYTE, "GetRegDataA",__FILE__,__LINE__)\
                                  GetRegData2A((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                  CLRTRACKCOMMENT

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataW(keystr,value)   SETTRACKCOMMENT(PBYTE, "GetRegDataW",__FILE__,__LINE__)\
                                    GetRegData2W((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                    CLRTRACKCOMMENT

BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    );


//
// Reg key create & open
//

HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey (
    IN      HKEY Key
    );

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    );

#ifdef DEBUG

#define CreateRegKeyA(a,b) RealCreateRegKeyA(a,b,__FILE__,__LINE__)
#define CreateRegKeyW(a,b) RealCreateRegKeyW(a,b,__FILE__,__LINE__)
#define CreateRegKeyStrA(a) RealCreateRegKeyStrA(a,__FILE__,__LINE__)
#define CreateRegKeyStrW(a) RealCreateRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyStrA(a) RealOpenRegKeyStrA(a,__FILE__,__LINE__)
#define OpenRegKeyStrW(a) RealOpenRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyA(a,b) RealOpenRegKeyA(a,b,__FILE__,__LINE__)
#define OpenRegKeyW(a,b) RealOpenRegKeyW(a,b,__FILE__,__LINE__)

#else

#define CreateRegKeyA RealCreateRegKeyA
#define CreateRegKeyW RealCreateRegKeyW
#define CreateRegKeyStrA RealCreateRegKeyStrA
#define CreateRegKeyStrW RealCreateRegKeyStrW
#define OpenRegKeyStrA RealOpenRegKeyStrA
#define OpenRegKeyStrW RealOpenRegKeyStrW
#define OpenRegKeyA RealOpenRegKeyA
#define OpenRegKeyW RealOpenRegKeyW

#endif


//
// Registry root functions
//

VOID
SetRegRoot (
    IN      HKEY Root
    );

HKEY
GetRegRoot (
    VOID
    );


// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootStringA (PCSTR RootString, PDWORD LengthPtr OPTIONAL);
INT GetOffsetOfRootStringW (PCWSTR RootString, PDWORD LengthPtr OPTIONAL);

// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootKey (HKEY RootKey);

// Given non-zero array offset to root, returns string or NULL if element
// is out of bounds
PCSTR GetRootStringFromOffsetA (INT i);
PCWSTR GetRootStringFromOffsetW (INT i);

// Given non-zero array offset to root, returns registry handle or NULL if
// element is out of bounds
HKEY GetRootKeyFromOffset (INT i);

// Converts the root at the head of RegPath to an HKEY and gives the number
// of characters occupied by the root string (including optional wack)
HKEY ConvertRootStringToKeyA (PCSTR RegPath, PDWORD LengthPtr OPTIONAL);
HKEY ConvertRootStringToKeyW (PCWSTR RegPath, PDWORD LengthPtr OPTIONAL);

// Returns a pointer to a static string for the matching root, or NULL if
// RegRoot does not point to a valid root
PCSTR ConvertKeyToRootStringA (HKEY RegRoot);
PCWSTR ConvertKeyToRootStringW (HKEY RegRoot);



//
// Macros
//

#define GetRegValueStringA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_SZ)
#define GetRegValueBinaryA(key,valuename) (PBYTE) GetRegValueDataOfTypeA((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordA(key,valuename) (PDWORD) GetRegValueDataOfTypeA((key),(valuename),REG_DWORD)

#define GetRegValueStringW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_SZ)
#define GetRegValueBinaryW(key,valuename) (PBYTE) GetRegValueDataOfTypeW((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordW(key,valuename) (PDWORD) GetRegValueDataOfTypeW((key),(valuename),REG_DWORD)

#define GetRegValueString2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueString2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define REGKEY_ENUM                     REGKEY_ENUMW
#define PREGKEY_ENUM                    PREGKEY_ENUMW
#define REGVALUE_ENUM                   REGVALUE_ENUMW
#define PREGVALUE_ENUM                  PREGVALUE_ENUMW
#define REGTREE_ENUM                    REGTREE_ENUMW
#define PREGTREE_ENUM                   PREGTREE_ENUMW

#define EnumFirstRegKey                 EnumFirstRegKeyW
#define EnumFirstRegKeyStr              EnumFirstRegKeyStrW
#define EnumNextRegKey                  EnumNextRegKeyW
#define AbortRegKeyEnum                 AbortRegKeyEnumW
#define EnumFirstRegKeyInTree           EnumFirstRegKeyInTreeW
#define EnumNextRegKeyInTree            EnumNextRegKeyInTreeW
#define AbortRegKeyTreeEnum             AbortRegKeyTreeEnumW
#define EnumFirstRegValue               EnumFirstRegValueW
#define EnumNextRegValue                EnumNextRegValueW

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeW
#define GetRegValueData                 GetRegValueDataW
#define GetRegValueDataOfType           GetRegValueDataOfTypeW
#define GetRegKeyData                   GetRegKeyDataW
#define GetRegValueData2                GetRegValueData2W
#define GetRegValueDataOfType2          GetRegValueDataOfType2W
#define GetRegKeyData2                  GetRegKeyData2W
#define GetRegValueString               GetRegValueStringW
#define GetRegValueBinary               GetRegValueBinaryW
#define GetRegValueMultiSz              GetRegValueMultiSzW
#define GetRegValueDword                GetRegValueDwordW
#define GetRegValueString2              GetRegValueString2W
#define GetRegValueBinary2              GetRegValueBinary2W
#define GetRegValueMultiSz2             GetRegValueMultiSz2W
#define GetRegValueDword2               GetRegValueDword2W
#define GetRegData2                     GetRegData2W
#define GetRegData                      GetRegDataW

#define CreateRegKey                    CreateRegKeyW
#define CreateRegKeyStr                 CreateRegKeyStrW
#define OpenRegKey                      OpenRegKeyW
#define OpenRegKeyStr                   OpenRegKeyStrW
#define DeleteRegKeyStr                 DeleteRegKeyStrW
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrW
#define GetOffsetOfRootString           GetOffsetOfRootStringW
#define GetRootStringFromOffset         GetRootStringFromOffsetW
#define ConvertRootStringToKey          ConvertRootStringToKeyW
#define ConvertKeyToRootString          ConvertKeyToRootStringW
#define CreateEncodedRegistryString     CreateEncodedRegistryStringW
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExW
#define FreeEncodedRegistryString       FreeEncodedRegistryStringW
#define DecodeRegistryString            DecodeRegistryStringW


#else

#define REGKEY_ENUM                     REGKEY_ENUMA
#define PREGKEY_ENUM                    PREGKEY_ENUMA
#define REGVALUE_ENUM                   REGVALUE_ENUMA
#define PREGVALUE_ENUM                  PREGVALUE_ENUMA
#define REGTREE_ENUM                    REGTREE_ENUMA
#define PREGTREE_ENUM                   PREGTREE_ENUMA

#define EnumFirstRegKey                 EnumFirstRegKeyA
#define EnumFirstRegKeyStr              EnumFirstRegKeyStrA
#define EnumNextRegKey                  EnumNextRegKeyA
#define AbortRegKeyEnum                 AbortRegKeyEnumA
#define EnumFirstRegKeyInTree           EnumFirstRegKeyInTreeA
#define EnumNextRegKeyInTree            EnumNextRegKeyInTreeA
#define AbortRegKeyTreeEnum             AbortRegKeyTreeEnumA
#define EnumFirstRegValue               EnumFirstRegValueA
#define EnumNextRegValue                EnumNextRegValueA

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeA
#define GetRegValueData                 GetRegValueDataA
#define GetRegValueDataOfType           GetRegValueDataOfTypeA
#define GetRegKeyData                   GetRegKeyDataA
#define GetRegValueData2                GetRegValueData2A
#define GetRegValueDataOfType2          GetRegValueDataOfType2A
#define GetRegKeyData2                  GetRegKeyData2A
#define GetRegValueString               GetRegValueStringA
#define GetRegValueBinary               GetRegValueBinaryA
#define GetRegValueMultiSz              GetRegValueMultiSzA
#define GetRegValueDword                GetRegValueDwordA
#define GetRegValueString2              GetRegValueString2A
#define GetRegValueBinary2              GetRegValueBinary2A
#define GetRegValueMultiSz2             GetRegValueMultiSz2A
#define GetRegValueDword2               GetRegValueDword2A
#define GetRegData2                     GetRegData2A
#define GetRegData                      GetRegDataA

#define CreateRegKey                    CreateRegKeyA
#define CreateRegKeyStr                 CreateRegKeyStrA
#define OpenRegKey                      OpenRegKeyA
#define OpenRegKeyStr                   OpenRegKeyStrA
#define DeleteRegKeyStr                 DeleteRegKeyStrA
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrA
#define GetOffsetOfRootString           GetOffsetOfRootStringA
#define GetRootStringFromOffset         GetRootStringFromOffsetA
#define ConvertRootStringToKey          ConvertRootStringToKeyA
#define ConvertKeyToRootString          ConvertKeyToRootStringA
#define CreateEncodedRegistryString     CreateEncodedRegistryStringA
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExA
#define FreeEncodedRegistryString       FreeEncodedRegistryStringA
#define DecodeRegistryString            DecodeRegistryStringA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\reg95.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg95.h

Abstract:

    Implements wrappers to the Win95Reg APIs.

Author:

    Jim Schmidt (jimschm) 04-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Debug* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys95()
#define RegTrackTerminate95()

#define TrackedRegOpenKey95             Win95RegOpenKey
#define TrackedRegOpenKeyEx95           Win95RegOpenKeyEx

#define TrackedRegOpenKey95A            Win95RegOpenKeyA
#define TrackedRegOpenKeyEx95A          Win95RegOpenKeyExA

#define TrackedRegOpenKey95W            Win95RegOpenKeyW
#define TrackedRegOpenKeyEx95W          Win95RegOpenKeyExW

#define OurRegOpenKeyEx95A              Win95RegOpenKeyExA

#define OurRegOpenRootKey95A(a,b)
#define OurRegOpenRootKey95W(a,b)

#define OurRegOpenKeyEx95W              Win95RegOpenKeyExW

#define CloseRegKey95                   RealCloseRegKey95

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare95;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys95 (
    VOID
    );

VOID
RegTrackTerminate95 (
    VOID
    );


LONG
DebugRegOpenKeyEx95A (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
DebugRegOpenKeyEx95W (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

VOID
DebugRegOpenRootKey95A (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
DebugRegOpenRootKey95W (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define DebugRegOpenRootKey95 DebugRegOpenRootKey95W
#else
#define DebugRegOpenRootKey95 DebugRegOpenRootKey95A
#endif


LONG
DebugCloseRegKey95 (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey95(k) DebugCloseRegKey95(k,__FILE__,__LINE__)


#define OurRegOpenKeyEx95A              DebugRegOpenKeyEx95A
#define OurRegOpenRootKey95A            DebugRegOpenRootKey95A
#define OurRegOpenRootKey95W            DebugRegOpenRootKey95W
#define OurRegOpenKeyEx95W              DebugRegOpenKeyEx95W


#define TrackedRegOpenKeyEx95(key,subkey,u,sam,res) DebugRegOpenKeyEx95(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegOpenKey95(k,sk,rp) DebugRegOpenKeyEx95(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)

#define TrackedRegOpenKeyEx95A(key,subkey,u,sam,res) DebugRegOpenKeyEx95A(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegOpenKey95A(k,sk,rp) DebugRegOpenKeyEx95A(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)

#define TrackedRegOpenKeyEx95W(key,subkey,u,sam,res) DebugRegOpenKeyEx95W(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegOpenKey95W(k,sk,rp) DebugRegOpenKeyEx95W(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef Win95RegOpenKey
#undef Win95RegOpenKeyEx

#define Win95RegCloseKey    USE_CloseRegKey95
#define Win95RegOpenKeyA    USE_TrackedRegOpenKey95A
#define Win95RegOpenKeyExA  USE_TrackedRegOpenKeyExA
#define Win95RegOpenKeyW    USE_TrackedRegOpenKey95W
#define Win95RegOpenKeyExW  USE_TrackedRegOpenKeyEx95W
#define Win95RegOpenKey     USE_TrackedRegOpenKey95
#define Win95RegOpenKeyEx   USE_TrackedRegOpenKeyEx95

#endif


#ifdef UNICODE
#define DebugRegOpenKeyEx95         DebugRegOpenKeyEx95W
#else
#define DebugRegOpenKeyEx95         DebugRegOpenKeyEx95A
#endif


//
// Enum functions
//

BOOL
EnumFirstRegKey95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegKey95W (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
RealEnumFirstRegKeyStr95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

BOOL
RealEnumFirstRegKeyStr95W (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

#ifdef DEBUG

#define EnumFirstRegKeyStr95A(a,b) RealEnumFirstRegKeyStr95A(a,b,__FILE__,__LINE__)
#define EnumFirstRegKeyStr95W(a,b) RealEnumFirstRegKeyStr95W(a,b,__FILE__,__LINE__)

#else

#define EnumFirstRegKeyStr95A RealEnumFirstRegKeyStr95A
#define EnumFirstRegKeyStr95W RealEnumFirstRegKeyStr95W

#endif



BOOL
EnumNextRegKey95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

BOOL
EnumNextRegKey95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

VOID
AbortRegKeyEnum95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

VOID
AbortRegKeyEnum95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

BOOL
RealEnumFirstRegKeyInTree95A (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTree95A(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTree95A",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTree95A(e,base)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumFirstRegKeyInTree95W (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTree95W(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTree95W",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTree95W(e,base)\
                                        CLRTRACKCOMMENT


BOOL
RealEnumNextRegKeyInTree95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

#define EnumNextRegKeyInTree95A(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTree95A",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTree95A(e)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumNextRegKeyInTree95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );

#define EnumNextRegKeyInTree95W(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTree95W",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTree95W(e)\
                                        CLRTRACKCOMMENT

VOID
AbortRegKeyTreeEnum95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

VOID
AbortRegKeyTreeEnum95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );


BOOL
EnumFirstRegValue95A (
    OUT     PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegValue95W (
    OUT     PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumNextRegValue95A (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    );

BOOL
EnumNextRegValue95W (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    );

//
// Versions that allow caller to specify allocator, and macro that uses
// pMemAllocWrapper95
//

ALLOCATOR_PROTOTYPE pMemAllocWrapper95;
DEALLOCATOR_PROTOTYPE pMemFreeWrapper95;

PBYTE
GetRegValueDataEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueData95A(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueData95A",__FILE__, __LINE__)\
                                        GetRegValueDataEx95A((key),(valuename),pMemAllocWrapper95,pMemFreeWrapper95)\
                                        CLRTRACKCOMMENT


PBYTE
GetRegValueDataEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueData95W(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueData95W",__FILE__, __LINE__)\
                                        GetRegValueDataEx95W((key),(valuename),pMemAllocWrapper95,pMemFreeWrapper95)\
                                        CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfTypeEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfType95A(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfType95A",__FILE__,__LINE__)\
                                                    GetRegValueDataOfTypeEx95A((key),(valuename),(type),pMemAllocWrapper95,pMemFreeWrapper95)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfTypeEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfType95W(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfType95W",__FILE__,__LINE__)\
                                                    GetRegValueDataOfTypeEx95W((key),(valuename),(type),pMemAllocWrapper95,pMemFreeWrapper95)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyDataEx95A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyData95A(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyData95A",__FILE__,__LINE__)\
                                    GetRegKeyDataEx95A((key),(subkey),pMemAllocWrapper95,pMemFreeWrapper95)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyDataEx95W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyData95W(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyData95W",__FILE__,__LINE__)\
                                    GetRegKeyDataEx95W((key),(subkey),pMemAllocWrapper95,pMemFreeWrapper95)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegDataEx95A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegData95A(keystr,value) SETTRACKCOMMENT(PBYTE, "GetRegData95A",__FILE__,__LINE__)\
                                  GetRegDataEx95A((keystr),(value),pMemAllocWrapper95,pMemFreeWrapper95)\
                                  CLRTRACKCOMMENT

PBYTE
GetRegDataEx95W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegData95W(keystr,value)   SETTRACKCOMMENT(PBYTE, "GetRegData95W",__FILE__,__LINE__)\
                                    GetRegDataEx95W((keystr),(value),pMemAllocWrapper95,pMemFreeWrapper95)\
                                    CLRTRACKCOMMENT

//
// Win95Reg key open
//

HKEY
RealOpenRegKeyStr95A (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStr95W (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKey95A (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKey95W (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey95 (
    IN      HKEY Key
    );


#ifdef DEBUG

#define OpenRegKeyStr95A(a)      RealOpenRegKeyStr95A(a,__FILE__,__LINE__)
#define OpenRegKeyStr95W(a)      RealOpenRegKeyStr95W(a,__FILE__,__LINE__)
#define OpenRegKey95A(a,b)       RealOpenRegKey95A(a,b,__FILE__,__LINE__)
#define OpenRegKey95W(a,b)       RealOpenRegKey95W(a,b,__FILE__,__LINE__)

#else

#define OpenRegKeyStr95A RealOpenRegKeyStr95A
#define OpenRegKeyStr95W RealOpenRegKeyStr95W
#define OpenRegKey95A RealOpenRegKey95A
#define OpenRegKey95W RealOpenRegKey95W

#endif


//
// Macros
//

#define GetRegValueString95A(key,valuename) (PCSTR) GetRegValueDataOfType95A((key),(valuename),REG_SZ)
#define GetRegValueBinary95A(key,valuename) (PBYTE) GetRegValueDataOfType95A((key),(valuename),REG_BINARY)
#define GetRegValueMultiSz95A(key,valuename) (PCSTR) GetRegValueDataOfType95A((key),(valuename),REG_MULTISZ)
#define GetRegValueDword95A(key,valuename) (PDWORD) GetRegValueDataOfType95A((key),(valuename),REG_DWORD)

#define GetRegValueString95W(key,valuename) (PCWSTR) GetRegValueDataOfType95W((key),(valuename),REG_SZ)
#define GetRegValueBinary95W(key,valuename) (PBYTE) GetRegValueDataOfType95W((key),(valuename),REG_BINARY)
#define GetRegValueMultiSz95W(key,valuename) (PCWSTR) GetRegValueDataOfType95W((key),(valuename),REG_MULTISZ)
#define GetRegValueDword95W(key,valuename) (PDWORD) GetRegValueDataOfType95W((key),(valuename),REG_DWORD)

#define GetRegValueStringEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinaryEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSzEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDwordEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueStringEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinaryEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSzEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDwordEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define EnumFirstRegKey95           EnumFirstRegKey95W
#define EnumFirstRegKeyStr95        EnumFirstRegKeyStr95W
#define EnumNextRegKey95            EnumNextRegKey95W
#define AbortRegKeyEnum95           AbortRegKeyEnum95W
#define EnumFirstRegKeyInTree95     EnumFirstRegKeyInTree95W
#define EnumNextRegKeyInTree95      EnumNextRegKeyInTree95W
#define AbortRegKeyTreeEnum95       AbortRegKeyTreeEnum95W
#define EnumFirstRegValue95         EnumFirstRegValue95W
#define EnumNextRegValue95          EnumNextRegValue95W

#define GetRegValueData95           GetRegValueData95W
#define GetRegValueDataOfType95     GetRegValueDataOfType95W
#define GetRegKeyData95             GetRegKeyData95W
#define GetRegValueDataEx95         GetRegValueDataEx95W
#define GetRegValueDataOfTypeEx95   GetRegValueDataOfTypeEx95W
#define GetRegKeyDataEx95           GetRegKeyDataEx95W
#define GetRegValueString95         GetRegValueString95W
#define GetRegValueBinary95         GetRegValueBinary95W
#define GetRegValueMultiSz95        GetRegValueMultiSz95W
#define GetRegValueDword95          GetRegValueDword95W
#define GetRegValueStringEx95       GetRegValueStringEx95W
#define GetRegValueBinaryEx95       GetRegValueBinaryEx95W
#define GetRegValueMultiSzEx95      GetRegValueMultiSzEx95W
#define GetRegValueDwordEx95        GetRegValueDwordEx95W
#define GetRegDataEx95              GetRegDataEx95W
#define GetRegData95                GetRegData95W

#define OpenRegKey95                OpenRegKey95W
#define OpenRegKeyStr95             OpenRegKeyStr95W


#else

#define EnumFirstRegKey95           EnumFirstRegKey95A
#define EnumFirstRegKeyStr95        EnumFirstRegKeyStr95A
#define EnumNextRegKey95            EnumNextRegKey95A
#define AbortRegKeyEnum95           AbortRegKeyEnum95A
#define EnumFirstRegKeyInTree95     EnumFirstRegKeyInTree95A
#define EnumNextRegKeyInTree95      EnumNextRegKeyInTree95A
#define AbortRegKeyTreeEnum95       AbortRegKeyTreeEnum95A
#define EnumFirstRegValue95         EnumFirstRegValue95A
#define EnumNextRegValue95          EnumNextRegValue95A

#define GetRegValueData95           GetRegValueData95A
#define GetRegValueDataOfType95     GetRegValueDataOfType95A
#define GetRegKeyData95             GetRegKeyData95A
#define GetRegValueDataEx95         GetRegValueDataEx95A
#define GetRegValueDataOfTypeEx95   GetRegValueDataOfTypeEx95A
#define GetRegKeyDataEx95           GetRegKeyDataEx95A
#define GetRegValueString95         GetRegValueString95A
#define GetRegValueBinary95         GetRegValueBinary95A
#define GetRegValueMultiSz95        GetRegValueMultiSz95A
#define GetRegValueDword95          GetRegValueDword95A
#define GetRegValueStringEx95       GetRegValueStringEx95A
#define GetRegValueBinaryEx95       GetRegValueBinaryEx95A
#define GetRegValueMultiSzEx95      GetRegValueMultiSzEx95A
#define GetRegValueDwordEx95        GetRegValueDwordEx95A
#define GetRegDataEx95              GetRegDataEx95A
#define GetRegData95                GetRegData95A

#define OpenRegKey95                OpenRegKey95A
#define OpenRegKeyStr95             OpenRegKeyStr95A


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\regapix.h ===
//
//  REGAPIX.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Public definitions for the VMM registry library (all modes).
//

#ifndef _REGAPIX_
#define _REGAPIX_

/*XLATOFF*/
#ifdef __cplusplus
extern "C" {
#endif
/*XLATON*/

/*XLATOFF*/
#if defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
#define REGAPI                      WINAPI
#else
#if defined(IS_32)
#ifndef FAR
#define FAR
#endif
#define REGAPI                      __cdecl
#else
#ifndef FAR
#define FAR                         _far
#endif 
#define REGAPI                      _far _cdecl
#endif // defined(IS_32)
#endif // defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
/*XLATON*/

#ifndef _REGPRIV_
#ifndef _INC_WINDOWS
typedef DWORD HKEY;
#endif
#endif
typedef HKEY FAR* LPHKEY;

//
//  Predefined key handles.
//

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_CLASSES_ROOT           ((HKEY) 0x80000000)
#define HKEY_CURRENT_USER           ((HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE          ((HKEY) 0x80000002)
#define HKEY_USERS                  ((HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA       ((HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG         ((HKEY) 0x80000005)
#define HKEY_DYN_DATA               ((HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS            7
#endif

//
//  Maximum size of registry data elements.
//

#define MAXIMUM_SUB_KEY_LENGTH      256
#define MAXIMUM_VALUE_NAME_LENGTH   256
#define MAXIMUM_DATA_LENGTH         16384

//
//  Standard data types.
//

#ifndef REG_SZ
#define REG_SZ                      1
#endif

#ifndef REG_BINARY
#define REG_BINARY                  3
#endif

#ifndef REG_DWORD
#define REG_DWORD                   4
#endif

//
//  Registry error codes.
//
#ifndef NOREGERRORDEFS
#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS               0
#endif

#ifndef ERROR_INVALID_FUNCTION
#define ERROR_INVALID_FUNCTION      1
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED         5
#endif

#ifndef ERROR_INVALID_HANDLE
#define ERROR_INVALID_HANDLE        6
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY           14
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER     87
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED           167
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA             234
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS         259
#endif

#ifndef ERROR_IO_PENDING
#define ERROR_IO_PENDING            997
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                 1009
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY                1010
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN              1011
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD              1012
#endif

#ifndef ERROR_CANTWRITE
#define ERROR_CANTWRITE             1013
#endif

#ifndef ERROR_REGISTRY_IO_FAILED
#define ERROR_REGISTRY_IO_FAILED    1016
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED           1018
#endif

//  Internal registry error codes.  Not exposed to most clients.
#if defined(VXD)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ((ERROR_CANTOPEN << 16) | ERROR_FILE_NOT_FOUND)
#define ERROR_CANTREAD16_FILENOTFOUND32 ((ERROR_CANTREAD << 16) | ERROR_FILE_NOT_FOUND)
#else
#if defined(WIN32)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#else
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_CANTOPEN
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_CANTREAD
#endif
#endif

#endif 

//
//  Registry application interfaces.
//

/*XLATOFF*/

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    );

VOID
REGAPI
VMMRegLibDetach(
    VOID
    );

/*XLATON*/
#define GRFT_SYSTEM                 0       //  SYSTEM.DAT
#define GRFT_USER                   1       //  USER.DAT
/*XLATOFF*/

BOOL
REGAPI
VMMRegGetRegistryFile(
    char FAR* lpBuffer,
    UINT BufferSize,
    UINT FileType
    );

//  Creates a new registry file.  Fails if the specified file already exists.
#define MPKF_CREATENEW              0x0001

//  If MPKF_VERSION20 is specified, create the file using compact keynodes.
//  Such a file will only be readable by users of this library, not Win95
//  clients.  Use only for system registries (SYSTEM.DAT, USER.DAT).
#define MPKF_VERSION20              0x0002

LONG
REGAPI
VMMRegMapPredefKeyToFile(
    HKEY hKey,
    const char FAR* lpFileName,
    UINT Flags
    );

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hSourceKey,
    HKEY hPredefKey
    );

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegQueryValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    void FAR* val_list,
    DWORD num_vals,
    char FAR* lpValueBuffer,
    DWORD FAR* lpdwTotalSize
    );

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD Reserved,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    const char FAR* lpValueName
    );

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    char FAR* lpKeyName,
    DWORD cbKeyName
    );

LONG
REGAPI
VMMRegEnumValue(
    HKEY hKey,
    DWORD Index,
    char FAR* lpValueName,
    DWORD FAR* lpcbValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData
    );
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    char FAR* lpClass,
    DWORD FAR* lpcbClass,
    DWORD FAR* lpReserved,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcbMaxClassLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData,
    void FAR* lpcbSecurityDescriptor,
    void FAR* lpftLastWriteTime
    );
#endif

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpFileName
    );

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    const char FAR* lpFileName,
    void FAR* lpSecurityAttributes
    );

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpNewFileName,
    const char FAR* lpOldFileName
    );

//
//  Optional macros for callers (typically 16-bit) that map the registry APIs
//  to the equivalent Win32 API name.
//

#if defined(IS_16) || defined(WANTREGAPIMACROS)
#if !defined(NOREGAPIMACROS) && !defined(SETUPX_INC)
#define RegCreateKey                VMMRegCreateKey
#define RegOpenKey                  VMMRegOpenKey
#define RegCloseKey                 VMMRegCloseKey
#define RegFlushKey                 VMMRegFlushKey
#define RegQueryValue               VMMRegQueryValue
#define RegQueryValueEx             VMMRegQueryValueEx
#define RegQueryMultipleValues      VMMRegQueryMultipleValues
#define RegSetValue                 VMMRegSetValue
#define RegSetValueEx               VMMRegSetValueEx
#define RegDeleteKey                VMMRegDeleteKey
#define RegDeleteValue              VMMRegDeleteValue
#define RegEnumKey                  VMMRegEnumKey
#define RegEnumValue                VMMRegEnumValue
#define RegQueryInfoKey             VMMRegQueryInfoKey
#define RegLoadKey                  VMMRegLoadKey
#define RegUnLoadKey                VMMRegUnLoadKey
#define RegSaveKey                  VMMRegSaveKey
#define RegReplaceKey               VMMRegReplaceKey
#endif
#endif

/*XLATON*/


//
//  Registry services available via VMM's interrupt 2Fh handler.
//

#ifndef RegOpenKey_Idx
#define RegOpenKey_Idx              0x0100
#define RegCreateKey_Idx            0x0101
#define RegCloseKey_Idx             0x0102
#define RegDeleteKey_Idx            0x0103
#define RegSetValue_Idx             0x0104
#define RegQueryValue_Idx           0x0105
#define RegEnumKey_Idx              0x0106
#define RegDeleteValue_Idx          0x0107
#define RegEnumValue_Idx            0x0108
#define RegQueryValueEx_Idx         0x0109
#define RegSetValueEx_Idx           0x010A
#define RegFlushKey_Idx             0x010B
#define RegLoadKey_Idx              0x010C
#define RegUnLoadKey_Idx            0x010D
#define RegSaveKey_Idx              0x010E
#define RegRestore_Idx              0x010F
#define RegRemapPreDefKey_Idx       0x0110
#endif

/*XLATOFF*/
#ifdef __cplusplus
}
#endif
/*XLATON*/

#endif // _REGAPIX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\rulehlpr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rulehlpr.h

Abstract:

    Declares the public routines implemented in w95upgnt\rulehlpr.

    The name rulehlpr comes from history: the original Win9x upgrade code
    used a set of rules, controlled by an INF.  Rule Helpers were functions
    that converted data.  These functions are still valid today, and
    they are still controlled by usermig.inf and wkstamig.inf.  However,
    the syntax is no longer a rule, but instead is just an entry.

    Rule Helpers implement various types of registry data conversion.

Author:

    Jim Schmidt (jimschm)   11-Mar-1997

Revision History:

    <alias> <date> <comments>

--*/


#include "object.h"

typedef BOOL (PROCESSINGFN_PROTOTYPE)(PCTSTR Src, PCTSTR Dest, PCTSTR User, PVOID Data);
typedef PROCESSINGFN_PROTOTYPE * PROCESSINGFN;

typedef BOOL (REGVALFN_PROTOTYPE)(PDATAOBJECT ObPtr);
typedef REGVALFN_PROTOTYPE * REGVALFN;

typedef struct {
    DATAOBJECT  Object;
    BOOL        EnumeratingSubKeys;
} KEYTOVALUEARG, *PKEYTOVALUEARG;

BOOL
WINAPI
RuleHlpr_Entry(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved);

PROCESSINGFN
RuleHlpr_GetFunctionAddr (
    PCTSTR Function,
    PVOID *ArgPtrToPtr
    );


FILTERRETURN
Standard9xSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    );



BOOL
ConvertCommandToCmd (
    PCTSTR InputLine,
    PTSTR OutputLine   // must be 2x length of input line
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\snapshot.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    snapshot.h

Abstract:

    Declares the interface to common\snapshot.  The snapshot code uses
    memdb to capture and compare the system state.

Author:

    Jim Schmidt (jimschm)   26-Mar-1998

Revision History:

    calinn  15-Oct-1998     Extensions and improvements

--*/

#pragma once

#define SNAP_RESULT_DELETED    1
#define SNAP_RESULT_UNCHANGED  2
#define SNAP_RESULT_CHANGED    4
#define SNAP_RESULT_ADDED      8

#define SNAP_FILES      1
#define SNAP_REGISTRY   2

VOID
TakeSnapShotEx (
    IN      DWORD SnapFlags
    );

BOOL
GenerateDiffOutputExA (
    IN      PCSTR FileName,
    IN      PCSTR Comment,      OPTIONAL
    IN      BOOL Append,
    IN      DWORD SnapFlags
    );

typedef struct _SNAP_FILE_ENUMA {
    CHAR FileName [MEMDB_MAX];
    PCSTR FilePattern;
    DWORD SnapStatus;
    BOOL FirstCall;
    MEMDB_ENUMA mEnum;
} SNAP_FILE_ENUMA, *PSNAP_FILE_ENUMA;

BOOL
EnumNextSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e
    );

BOOL
EnumFirstSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e,
    IN      PCSTR FilePattern,   OPTIONAL
    IN      DWORD SnapStatus
    );


#define TakeSnapShot()              TakeSnapShotEx(SNAP_FILES|SNAP_REGISTRY)
#define GenerateDiffOutputA(f,c,a)  GenerateDiffOutputExA(f,c,a,SNAP_FILES|SNAP_REGISTRY)

#ifndef UNICODE
#define GenerateDiffOutputEx        GenerateDiffOutputExA
#define GenerateDiffOutput          GenerateDiffOutputA
#define SNAP_FILE_ENUM              SNAP_FILE_ENUMA
#define PSNAP_FILE_ENUM             PSNAP_FILE_ENUMA
#define EnumFirstSnapFile           EnumFirstSnapFileA
#define EnumNextSnapFile            EnumNextSnapFileA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\safemode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    recovery.h

Abstract:

    A number of utilities for safe/recovery mode

Author:

    Calin Negreanu (calinn) 6-Aug-1999

Revision History:

--*/


#pragma once

// posible values for safe mode identifiers
typedef enum {
    SAFEMODEID_FIRST,
    SAFEMODEID_DRIVE,
    SAFEMODEID_FILES,
    SAFEMODEID_LNK9X,
    SAFEMODEID_LAST
} SAFEMODE_OPTIONS;

BOOL
SafeModeInitializeA (
    BOOL Forced
    );

BOOL
SafeModeInitializeW (
    BOOL Forced
    );

BOOL
SafeModeShutDownA (
    VOID
    );

BOOL
SafeModeShutDownW (
    VOID
    );

BOOL
SafeModeRegisterActionA (
    IN      ULONG Id,
    IN      PCSTR String
    );

BOOL
SafeModeRegisterActionW (
    IN      ULONG Id,
    IN      PCWSTR String
    );

BOOL
SafeModeUnregisterActionA (
    VOID
    );

BOOL
SafeModeUnregisterActionW (
    VOID
    );

BOOL
SafeModeActionCrashedA (
    IN      ULONG Id,
    IN      PCSTR String
    );

BOOL
SafeModeActionCrashedW (
    IN      ULONG Id,
    IN      PCWSTR String
    );

VOID
SafeModeExceptionOccured (
    VOID
    );

#ifdef UNICODE

#define SafeModeInitialize          SafeModeInitializeW
#define SafeModeShutDown            SafeModeShutDownW
#define SafeModeRegisterAction      SafeModeRegisterActionW
#define SafeModeUnregisterAction    SafeModeUnregisterActionW
#define SafeModeActionCrashed       SafeModeActionCrashedW

#else

#define SafeModeInitialize          SafeModeInitializeA
#define SafeModeShutDown            SafeModeShutDownA
#define SafeModeRegisterAction      SafeModeRegisterActionA
#define SafeModeUnregisterAction    SafeModeUnregisterActionA
#define SafeModeActionCrashed       SafeModeActionCrashedA

#endif

#define SAFEMODE_GUARD(id,str)      if(!SafeModeActionCrashed(id,str)){SafeModeRegisterAction(id,str);
#define END_SAFEMODE_GUARD          SafeModeUnregisterAction();}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\regops.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    regops.h

Abstract:

    This file declares routines to mark operations on the registry.
    During the Win9x side of processing, registry operations are
    recorded in memdb to suppress Win9x settings, or to overwrite
    NT settings.  The memdb entries are queried during the registry
    merge in GUI mode.

    Use the macros at the bottom of this file.

Author:

    Marc R. Whitten (marcw)   18-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/



#pragma once
#include "merge.h"

typedef enum {
    KEY_ONLY,
    KEY_TREE,
    TREE_OPTIONAL
} TREE_STATE;

BOOL
IsRegObjectMarkedForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,                OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    );

BOOL
IsRegObjectMarkedForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,               OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    );

BOOL
MarkRegObjectForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    );

BOOL
MarkRegObjectForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    );

BOOL
MarkObjectForOperationA (
    IN      PCSTR Object,
    IN      DWORD OperationMask
    );

BOOL
MarkObjectForOperationW (
    IN      PCWSTR Object,
    IN      DWORD OperationMask
    );

BOOL
ForceWin9xSettingA (
    IN      PCSTR SourceKey,
    IN      PCSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCSTR DestinationKey,
    IN      PCSTR DestinationValue,
    IN      BOOL DestinationTree
    );

BOOL
ForceWin9xSettingW (
    IN      PCWSTR SourceKey,
    IN      PCWSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCWSTR DestinationKey,
    IN      PCWSTR DestinationValue,
    IN      BOOL DestinationTree
    );

#ifdef UNICODE
#define IsRegObjectMarkedForOperation       IsRegObjectMarkedForOperationW
#define MarkRegObjectForOperation           MarkRegObjectForOperationW
#define Suppress95RegSetting(k,v)           MarkRegObjectForOperationW(k,v,TRUE,REGMERGE_95_SUPPRESS)
#define SuppressNtRegSetting(k,v)           MarkRegObjectForOperationW(k,v,TRUE,REG_NT_SUPPRESS)
#define Is95RegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationW(k,v,TREE_OPTIONAL,REGMERGE_95_SUPPRESS)
#define IsNtRegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationW(k,v,TREE_OPTIONAL,REGMERGE_NT_SUPPRESS)
#define Is95RegKeySuppressed(k)             IsRegObjectMarkedForOperationW(k,NULL,KEY_ONLY,REGMERGE_95_SUPPRESS)
#define IsNtRegKeySuppressed(k)             IsRegObjectMarkedForOperationW(k,NULL,KEY_ONLY,REGMERGE_NT_SUPPRESS)
#define Is95RegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationW(k,NULL,KEY_TREE,REGMERGE_95_SUPPRESS)
#define IsNtRegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationW(k,NULL,KEY_TREE,REGMERGE_NT_SUPPRESS)
#define IsRegObjectInMemdb(k,v)             IsRegObjectMarkedForOperationW(k,v,0xffffffff)
#define MarkObjectForOperation              MarkObjectForOperationW
#define Suppress95Object(x)                 MarkObjectForOperationW(x,REGMERGE_95_SUPPRESS)
#define SuppressNtObject(x)                 MarkObjectForOperationW(x,REGMERGE_NT_SUPPRESS)
#define ForceWin9xSetting                   ForceWin9xSettingW

#else

#define IsRegObjectMarkedForOperation       IsRegObjectMarkedForOperationA
#define MarkRegObjectForOperation           MarkRegObjectForOperationA
#define Suppress95RegSetting(k,v)           MarkRegObjectForOperationA(k,v,TRUE,REGMERGE_95_SUPPRESS)
#define SuppressNtRegSetting(k,v)           MarkRegObjectForOperationA(k,v,TRUE,REGMERGE_NT_SUPPRESS)
#define Is95RegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationA(k,v,TREE_OPTIONAL,REGMERGE_95_SUPPRESS)
#define IsNtRegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationA(k,v,TREE_OPTIONAL,REGMERGE_NT_SUPPRESS)
#define Is95RegKeySuppressed(k)             IsRegObjectMarkedForOperationA(k,NULL,KEY_ONLY,REGMERGE_95_SUPPRESS)
#define IsNtRegKeySuppressed(k)             IsRegObjectMarkedForOperationA(k,NULL,KEY_ONLY,REGMERGE_NT_SUPPRESS)
#define Is95RegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationA(k,NULL,KEY_TREE,REGMERGE_95_SUPPRESS)
#define IsNtRegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationA(k,NULL,KEY_TREE,REGMERGE_NT_SUPPRESS)
#define IsRegObjectInMemdb(k,v)             IsRegObjectMarkedForOperationA(k,v,0xffffffff)
#define MarkObjectForOperation              MarkObjectForOperationA
#define Suppress95Object(x)                 MarkObjectForOperationA(x,REGMERGE_95_SUPPRESS)
#define SuppressNtObject(x)                 MarkObjectForOperationA(x,REGMERGE_NT_SUPPRESS)
#define ForceWin9xSetting                   ForceWin9xSettingA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\tapimig.h ===
#ifndef TAPIMIG_H
#define TAPIMIG_H

#endif //TAPIMIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\sysmig.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    sysmig.h

Abstract:

    This file declares the functions for the main Win9x side lib.
    See w95upg\sysmig for implementation details.

Author:

    Jim Schmidt (jimschm) 11-Nov-1996

Revision History:

    mvander     27-May-1999     Added OBJECTTYPEs and DEAD_FILE
    ovidiut     09-Mar-1999     UndoChangedFileProps
    jimschm     01-Oct-1998     TWAIN support
    calinn      10-Jul-1998     Reorganization
    jimschm     01-Jul-1998     Progress bar changes
    jimschm     05-May-1998     Icon extraction
    jimschm     10-Mar-1998     ExpandNtEnvVars
    calinn      05-Mar-1998     MapFileIntoMemory
    jimschm     22-Jan-1998     Domain enumeration
    jimschm     06-Jan-1998     Name fix routines
    jimschm     31-Jul-1997     User profile enumeration

--*/

#pragma once


#define DEAD_FILE   TEXT("dead.ini")
#define OBJECTTYPE_COUNT         5
#define OBJECTTYPE_UNKNOWN       0
#define OBJECTTYPE_APP           1
#define OBJECTTYPE_CPL           2
#define OBJECTTYPE_RUNKEY        3
#define OBJECTTYPE_LINK          4


VOID
ExpandNtEnvVars (
    IN OUT  PTSTR PathBuf,
    IN      PCTSTR UserProfileDir
    );

BOOL
ExtractIconIntoDatFile (
    IN      PCTSTR LongPath,
    IN      INT IconIndex,
    IN OUT  PICON_EXTRACT_CONTEXT Context,
    OUT     PINT NewIconIndex                   OPTIONAL
    );

#define REQUEST_QUERYTICKS          1
#define REQUEST_RUN                 2
#define REQUEST_BEGINUSERPROCESSING 3
#define REQUEST_ENDUSERPROCESSING   4


VOID
PrepareProcessingProgressBar (
    VOID
    );

DWORD
RunSysFirstMigrationRoutines (
    VOID
    );

DWORD
RunUserMigrationRoutines (
    VOID
    );

DWORD
RunSysLastMigrationRoutines (
    VOID
    );



//
// compacct.c
//

#define MAX_NETENUM_DEPTH       2

typedef enum {
    NETRES_INIT,
    NETRES_OPEN_ENUM,
    NETRES_ENUM_BLOCK,
    NETRES_ENUM_BLOCK_NEXT,
    NETRES_RETURN_ITEM,
    NETRES_CLOSE_ENUM,
    NETRES_DONE
} NETRESSTATE;

typedef struct {
    //
    // Members returned to the caller
    //

    BOOL Connected:1;
    BOOL GlobalNet:1;
    BOOL Persistent:1;
    BOOL DiskResource:1;
    BOOL PrintResource:1;
    BOOL TypeUnknown:1;
    BOOL Domain:1;
    BOOL Generic:1;
    BOOL Server:1;
    BOOL Share:1;
    BOOL Connectable:1;
    BOOL Container:1;
    PCTSTR RemoteName;
    PCTSTR LocalName;
    PCTSTR Comment;
    PCTSTR Provider;

    //
    // Private enumeration members
    //

    DWORD EnumScope;
    DWORD EnumType;
    DWORD EnumUsage;
    NETRESSTATE State;
    HANDLE HandleStack[MAX_NETENUM_DEPTH];
    UINT StackPos;
    PBYTE ResStack[MAX_NETENUM_DEPTH];
    UINT Entries[MAX_NETENUM_DEPTH];
    UINT Pos[MAX_NETENUM_DEPTH];
} NETRESOURCE_ENUM, *PNETRESOURCE_ENUM;


LONG
DoesComputerAccountExistOnDomain (
    IN      PCTSTR DomainName,
    IN      PCTSTR LookUpName,
    IN      BOOL WaitCursorEnable
    );

BOOL
EnumFirstNetResource (
    OUT     PNETRESOURCE_ENUM EnumPtr,
    IN      DWORD WNetScope,                OPTIONAL
    IN      DWORD WNetType,                 OPTIONAL
    IN      DWORD WNetUsage                 OPTIONAL
    );

BOOL
EnumNextNetResource (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    );

VOID
AbortNetResourceEnum (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    );

BOOL
ReadNtFilesEx (
    IN      PCSTR FileListName,    //optional, if null default is opened
    IN      BOOL ConvertPath
    );

BOOL
UndoChangedFileProps (
    VOID
    );

//
// Beta only!!
//

//VOID
//SaveConfigurationForBeta (
//    VOID
//    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\timezone.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    timezone.h

Abstract:

    Declares types, constants and enum interfaces for time zone
    mapping and migration.

Author:

    Marc R. Whitten (marcw) 10-Jul-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

// common stuff
//#include "common.h"

#define MAX_TIMEZONE MAX_TCHAR_PATH

#define TZFLAG_USE_FORCED_MAPPINGS 0x00000001
#define TZFLAG_ENUM_ALL 0x00000002


typedef struct {

    PCTSTR CurTimeZone;
    TCHAR  NtTimeZone[MAX_TIMEZONE];
    PCTSTR MapIndex;
    UINT  MapCount;
    DWORD Flags;
    MEMDB_ENUM Enum;

} TIMEZONE_ENUM, *PTIMEZONE_ENUM;

BOOL
EnumFirstTimeZone (
    IN PTIMEZONE_ENUM EnumPtr,
    IN DWORD Flags
    );

BOOL
EnumNextTimeZone (
    IN PTIMEZONE_ENUM EnumPtr
    );
BOOL
ForceTimeZoneMap (
    PCTSTR NtTimeZone
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\staticsz.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    staticsz.h

Abstract:

    staticsz serves as a central repository for all string constants across the
    win9x upgrade project.

Author:

    Marc R. Whitten (marcw) 24-Mar-1997

Revision History:

--*/


#ifndef STATICSZ_H
#define STATICSZ_H

//
// staticsz naming standard:
// All names begin with S_ this indicates that they came from this file.
//
// Example:
//  #define S_UNATTENDED                 TEXT("Unattended")
//
// Each section in this file should begin with the following header:

//
// STRING SECTION <name if desired>
// Used By: <list of files using these strings>
//

//
// STRING SECTION (MigIsol)
// Used By: migisol, migapp\plugin.c, migmain\migdlls.c
//

#define S_MIGISOL_EXE                   TEXT("migisol.exe")
#define S_MIGICONS_DAT                  TEXT("migicons.dat")

//
// STRING SECTION (MigApp's Migration DLL Processing)
// Used By: migapp\plugin.c
//

#define S_FILE                          TEXT("File")
#define S_DIRECTORY                     TEXT("Directory")
#define S_REGISTRY                      TEXT("Registry")

#define S_PREINSTALLED_MIGRATION_DLLS   TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Migration DLLs")

// On-CD location for migration DLLs. A subdirectory of g_SourceDirWack.
#define S_WIN9XMIG                      TEXT("win9xmig")

// MIGRATE.INF section names
#define S_MIGRATE_INF                   TEXT("migrate.inf")
#define S_INCOMPATIBLE_MSGS             TEXT("Incompatible Messages")
#define S_HANDLED                       TEXT("Handled")
#define S_MOVED                         TEXT("Moved")

#define S_TEMP_INF                      TEXT("temp.inf")

#define S_MIGRATION_DEFAULT_KEY         TEXT("HKLM\\Migration\\.Default")
#define S_MIGRATION_KEY                 TEXT("HKLM\\Migration")



//
// STRING SECTION (Project File Names)
// Used By: dllentry.c,config.c,init9x.c
//
#define S_DEBUG9XLOG                    TEXT("debug9x.log")
#define S_SYSTEMDAT                     TEXT("system.dat")
#define S_USERDAT                       TEXT("user.dat")
#define S_CLASSESDAT                    TEXT("classes.dat")
#define S_WINNTSIF                      TEXT("winnt.sif")
#define S_NTSETUPDAT                    TEXT("ntsetup.dat")
#define S_USERMIG_INF                   TEXT("usermig.inf")
#define S_WKSTAMIG_INF                  TEXT("wkstamig.inf")
#define S_OPTIONS_INF                   TEXT("domain.inf")
#define S_E95ONLY_DAT                   TEXT("e95only.dat")
#define S_WIN9XUPGUSEROPTIONS           WINNT_D_WIN9XUPG_USEROPTIONS
#define S_UPGRADETXT                    TEXT("upgrade.txt")
#define S_UPGRADEHTM                    TEXT("upgrade.htm")
#define S_STATIC_MOVE_FILES             TEXT("StaticMoveFiles")
#define S_STATIC_COPY_FILES             TEXT("StaticCopyFiles")
#define S_STATIC_INSTALLED_FILES        TEXT("StaticInstalledFiles")
#define S_EXTERNAL_PROCESSES            TEXT("External Processes")
#define S_UNINSTALL_PROFILE_CLEAN_OUT TEXT("Uninstall.UserProfileCleanup")

//
// STRING SECTION (MigApp)
// Used By: migapp\*.c
//
#define S_DEFAULT_PASSWORD              TEXT("")
#define S_TEMP_USER_KEY                 TEXT("$$$")
#define S_MAPPED_DEFAULT_USER_KEY       TEXT("MappedDefaultUser")
#define S_FULL_TEMP_USER_KEY            (TEXT("HKCC\\") S_TEMP_USER_KEY)
#define S_HIVE_TEMP                     TEXT("$hive$")
#define S_DOT_DEFAULT                   TEXT(".Default")
#define S_DOT_ALLUSERS                  TEXT(".AllUsers")
#define S_DOT_DEFAULTA                  ".Default"
#define S_ALL_USERS                     TEXT("All Users")
#define S_DEFAULT_USER                  TEXT("Default User")
#define S_LOCALSERVICE_USER             TEXT("LocalService")
#define S_NETWORKSERVICE_USER           TEXT("NetworkService")

#define S_WINLOGON_REGKEY               TEXT("HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define S_AUTOADMIN_LOGON_VALUE         TEXT("AutoAdminLogon")
#define S_DEFAULT_PASSWORD_VALUE        TEXT("DefaultPassword")
#define S_DEFAULT_USER_NAME_VALUE       TEXT("DefaultUserName")
#define S_DEFAULT_DOMAIN_NAME_VALUE     TEXT("DefaultDomainName")

#define S_SOFTWARE_PROFILELIST          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define S_WIN9XUPG_FLAG_VALNAME         TEXT("Win9xUpg")
#define S_DEFAULT_USER_KEY              TEXT("HKU\\.Default")
#define S_PROFILESDIRECTORY             TEXT("ProfilesDirectory")

#define S_SETUPDATA         TEXT("SetupData")
#define S_PRODUCTTYPE       TEXT("ProductType")
#define S_WORKSTATIONA      "Workstation"
#define S_PERSONALA         "Personal"
#define S_PROFESSIONALA     "Professional"
#define S_SERVERA           "Server"
#define S_STRINGS           "Strings"
#define S_SKEY_APP_PATHS    "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths"

#define S_HKLM                  "HKLM"
#define S_CHECK_BAD_APPS        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps"
#define S_CHECK_BAD_APPS_400    "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps400"

#define S_COMMAND_PIF           TEXT("COMMAND.PIF")
#define S_CMDATTRIB_KEY         TEXT("Console\\%SystemRoot%_System32_cmd.exe")
#define S_CMD_FULLSCREEN        TEXT("FullScreen")
#define S_CMD_WINDOWSIZE        TEXT("WindowSize")
#define S_CMD_QUICKEDIT         TEXT("QuickEdit")
#define S_CMD_FACENAME          TEXT("FaceName")
#define S_CMD_FONTSIZE          TEXT("FontSize")
#define S_CMD_FONTWEIGHT        TEXT("FontWeight")
#define S_CMD_FONTFAMILY        TEXT("FontFamily")
#define S_CMD_EXE               TEXT("CMD.EXE")
#define S_COMMAND_COM           TEXT("COMMAND.COM")

//
// STRING SECTION (SysMig Strings)
// Used By: sysmig.c
//

#define S_LOGON_KEY                     TEXT("HKLM\\Network\\Logon")
#define S_LM_LOGON                      TEXT("LMLogon")
#define S_USERNAME_VALUE                TEXT("username")
#define S_PRIMARY_PROVIDER              TEXT("PrimaryProvider")
#define S_LANMAN                        TEXT("Microsoft Network")
#define S_MSNP32                        TEXT("HKLM\\System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider")
#define S_AUTHENTICATING_AGENT          TEXT("AuthenticatingAgent")
#define S_VNETSUP                       TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define S_WORKGROUP                     TEXT("Workgroup")
#define S_FILELIST_UNCOMPRESSED         TEXT("FILELIST.DAT")
#define S_FILELIST_COMPRESSED           TEXT("FILELIST.DA_")
#define S_WINNTDIRECTORIES              TEXT("WinntDirectories")
#define S_INI_FILES_IGNORE              TEXT("INI Files.Ignore")
#define S_INBOX_CFG                     TEXT("HKCU\\Software\\Microsoft\\Windows Messaging Subsystem\\Profiles")

//
// STRING SECTION (NT system environment variable names)
// Used By: userloop.c
//

#define S_USERPROFILE_ENV               TEXT("%USERPROFILE%")
#define S_ALLUSERSPROFILE_ENV           TEXT("%ALLUSERSPROFILE%")
#define S_SYSTEMROOT_ENV                TEXT("%SYSTEMROOT%")
#define S_SYSTEMDRIVE_ENV               TEXT("%SYSTEMDRIVE%")
#define S_BOOTDRIVE_ENV                 TEXT("%BOOTDRIVE%")
#define S_USERPROFILE                   TEXT("USERPROFILE")
#define S_USERPROFILEW                  L"USERPROFILE"
#define S_WINDIR_ENV                    TEXT("%WINDIR%")
#define S_SYSTEMDIR_ENV                 TEXT("%SYSTEMDIR%")
#define S_SYSTEM32DIR_ENV               TEXT("%SYSTEM32DIR%")
#define S_PROGRAMFILES_ENV              TEXT("%PROGRAMFILES%")
#define S_COMMONPROGRAMFILES_ENV        TEXT("%COMMONPROGRAMFILES%")
#define S_APPDIR_ENV                    TEXT("%APPDIR%")

//
// STRING SECTION (INF Section Names)
// Used By:
//
#define S_WIN9XUPGRADE                  TEXT("Win9xUpg")
#define S_WIN9XUPGRADEINTERNALUNATTEND  TEXT("Win9x.Upgrade.Internal")
#define S_ATTENDED                      TEXT("Attended")
#define S_REPORTONLY                    TEXT("ReportOnly")
#define S_APPENDCOMPUTERNAMETOPATHS     TEXT("AppendComputerNameToPaths")
#define S_PNP_DESCRIPTIONS              TEXT("Better PNP Descriptions")
#define S_REINSTALL_PNP_IDS             TEXT("Reinstall PNP IDs")
#define S_STANDARD_PNP_IDS              TEXT("Standard PNP IDs")
#define S_COMPATIBLE_PNP_IDS            TEXT("Compatible PNP IDs")
#define S_UNINSTALL                     TEXT("Uninstall")

#define S_PATHDEFAULT                   TEXT("")
#define S_SAVEREPORTTO                  TEXT("SaveReportTo")
#define S_MIGRATIONDLLPATH              TEXT("MigrationDllPath")
#define S_EXCLUDEDMIGRATIONDLLS         TEXT("ExcludedMigrationDlls")
#define S_EXCLUDEDMIGDLLSBYATTR         TEXT("ExcludedMigDllsByAttr")
#define S_CD_MIGRATION_DLLS             TEXT("MigrationDllPaths")
#define S_SAVELOGTO                     TEXT("SaveLogTo")
#define S_SAVEPROFILETO                 TEXT("SaveProfileTo")
#define S_SAVEREGISTRYTO                TEXT("SaveRegistryTo")
#define S_SAVEWINNTSIFTO                TEXT("SaveWinntSifTo")
#define S_SAVENTSETUPDATTO              TEXT("SaveNtSetupDatTo")
#define S_COMPRESSFILES                 TEXT("CompressFiles")
#define S_DEBUG_MIGRATION_DLLS          TEXT("DebugMigrationDlls")
#define S_GOODDRIVE                     TEXT("GOODDRIVE")
#define S_NOFEAR                        TEXT("NOFEAR")
#define S_DOLOG                         TEXT("DOLOG")
#define S_COMPRESSCOMMAND               TEXT("MSTOOLS\\COMPRESS.EXE")
#define S_MEGAGROVEL                    TEXT("MegaGrovel")
#define S_MEGAGROVELFILE                TEXT("setup.pck")
#define S_MEGAGROVELTMP                 TEXT("temp.pck")
#define S_MEGAGROVELTMPCOMPRESSED       TEXT("tempc.pck")
#define S_HARDWARETXT                   TEXT("hardware.txt")
#define S_SOFTWARETXT                   TEXT("software.txt")
#define S_FILELST                       TEXT("allfile.lst")
#define S_DOTDAT                        TEXT(".dat")
#define S_DOTLNK                        TEXT(".lnk")
#define S_PROFILE                       TEXT("profiles")
#define S_DIRRENAMESECT                 TEXT("Profiles.Rename")
#define S_INIFILES_ACTIONS_FIRST        TEXT("INI Files Actions.First")
#define S_INIFILES_ACTIONS_LAST         TEXT("INI Files Actions.Last")
#define S_PROFILES_SF_COLLISIONS        TEXT("Profiles.SFCollisions")

//
// STRING SECTION (sysmig strings)
// Used By: w95upg\sysmig\*.c
//

#define S_WIN9XSIF                   TEXT("win9x.sif")
#define S_UNATTENDED                 TEXT("Unattended")
#define S_FILESYSTEM                 TEXT("FileSystem")
#define S_PROFILEDIR                 TEXT("ProfileDir")
#define S_NOWAITAFTERTEXTMODE        TEXT("NoWaitAfterTextMode")
#define S_NOWAITAFTERGUIMODE         TEXT("NoWaitAfterGuiMode")
#define S_ZERO                       TEXT("0")
#define S_ONE                        TEXT("1")
#define S_TWO                        TEXT("2")
#define S_CONFIRMHARDWARE            TEXT("ConfirmHardware")
#define S_REQUIRED                   TEXT("Required")
#define S_YES                        TEXT("Yes")
#define S_NO                         TEXT("No")
#define S_AUTO                       TEXT("Auto")
#define S_TRUE                       TEXT("True")
#define S_STR_FALSE                  TEXT("False")
#define S_ALL                        TEXT("ALL")
#define S_ENABLED                    TEXT("Enabled")
#define S_DHCP                       TEXT("DHCP")
#define S_KEYBOARDLAYOUT             TEXT("KeyboardLayout")
#define S_KEYBOARDHARDWARE           TEXT("KeyboardHardware")
#define S_QUOTEDKEYBOARDLAYOUT       TEXT("\"Keyboard Layout\"")

#define S_GUIUNATTENDED              TEXT("GuiUnattended")
#define S_TIMEZONE                   TEXT("TimeZone")
#define S_SERVERTYPE                 TEXT("AdvServerType")
#define S_STANDALONE                 TEXT("SERVERNT")
#define S_INDEX                      TEXT("Index")

#define S_USERDATA                   TEXT("UserData")
#define S_FULLNAME                   TEXT("FullName")
#define S_ORGNAME                    TEXT("OrgName")
#define S_COMPUTERNAME               TEXT("ComputerName")

#define S_DISPLAY                    TEXT("Display")
#define S_AUTOCONFIRM                TEXT("AutoConfirm")
#define S_BITSPERPEL                 TEXT("BitsPerPel")
#define S_XRESOLUTION                TEXT("Xresolution")
#define S_YRESOLUTION                TEXT("Yresolution")
#define S_VREFRESH                   TEXT("VRefresh")

#define S_NETWORK                    TEXT("Network")
#define S_JOINWORKGROUP              TEXT("JoinWorkgroup")
#define S_JOINDOMAIN                 TEXT("JoinDomain")
#define S_USERDOMAIN                 TEXT("UserDomain")
#define S_DETECTADAPTERS             TEXT("DetectAdapters")
#define S_INSTALLPROTOCOLS           TEXT("InstallProtocols")
#define S_INSTALLSERVICES            TEXT("InstallServices")
#define S_ONLYONERROR                TEXT("OnlyOnError")

#define S_ENABLE_BACKUP              TEXT("EnableBackup")
#define S_PATH_FOR_BACKUP            TEXT("PathForBackup")
#define S_ROLLBACK_MK_DIRS           TEXT("RollbackMkDirs")
#define S_UNINSTALL_TEMP_DIR         TEXT("uninstall")
#define S_ROLLBACK_MOVED_TXT         TEXT("moved.txt")
#define S_ROLLBACK_DELFILES_TXT      TEXT("delfiles.txt")
#define S_ROLLBACK_DELDIRS_TXT       TEXT("deldirs.txt")
#define S_ROLLBACK_MKDIRS_TXT        TEXT("mkdirs.txt")
#define S_UNINSTALL_DISP_STR         TEXT("ProgressText")

#define S_DETECTADAPTERS             TEXT("DetectAdapters")
#define S_DETECTCOUNT                TEXT("DetectCount")

#define S_PROTOCOLS                  TEXT("Protocols")
#define S_NBF                        TEXT("NBF")
#define S_NWLNKIPX                   TEXT("NWLNKIPX")
#define S_TC                         TEXT("TC")

#define S_NETBEUIPARAMETERS          TEXT("NetBeui")
#define S_STUBKEY                    TEXT("NoParamsNeeded")
#define S_STUBVAL                    TEXT("1")

#define S_IPXPARAMETERS              TEXT("IPX")

#define S_TCPIPPARAMETERS            TEXT("TCPIP")
#define S_SCOPEID                    TEXT("ScopeID")
#define S_WINS                       TEXT("WINS")
#define S_IPADDRESS                  TEXT("IPAddress")
#define S_SUBNET                     TEXT("Subnet")
#define S_TCPIP_ADAPTER              TEXT("TCPIP.Adapter")
#define S_IPX_ADAPTER                TEXT("IPC.Adapter")
#define S_SPECIFICTO                 TEXT("SpecificTo")
#define S_ADAPTERSECTIONS            TEXT("AdapterSections")
#define S_DEFAULTGATEWAY             TEXT("DefaultGateway")
#define S_DNSSERVER                  TEXT("DNSServer")
#define S_WINSPRIMARY                TEXT("WINSPrimary")
#define S_WINSSECONDARY              TEXT("WINSSecondary")
#define S_WINSSERVERLIST             TEXT("WinsServerList")
#define S_DNSNAME                    TEXT("DNSName")
#define S_DNSHOSTNAME                TEXT("DNSHostName")
#define S_SEARCHLIST                 TEXT("SearchList")
#define S_LMHOSTS                    TEXT("LMHostFile")
#define S_PKTTYPE                    TEXT("PktType")
#define S_NETWORKNUMBER              TEXT("NetworkNumber")
#define S_NETWORK_ID                 TEXT("Network_Id")
#define S_NETBIOSOPTION              TEXT("NetBiosOption")

//--------------------------------------------------------------
//Those strings are used in winntsif.c to upgrade ICS settings
#define S_ICSHARE                       TEXT("ICSHARE")
#define S_HOMENET                       TEXT("Homenet")
#define S_ICS_KEY                       TEXT("HKLM\\System\\CurrentControlSet\\Services\\ICSharing\\Settings\\General")
#define S_INET_SETTINGS                 TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define S_NET_DRIVER_KEY                TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class\\Net")
#define S_REMOTEACCESS_KEY              TEXT("HKEY_CURRENT_USER\\RemoteAccess")
#define S_RAS_DEFAULT                   TEXT("Default")
#define S_EXTERNAL_ADAPTER              TEXT("ExternalAdapter")
#define S_EXTERNAL_CONNECTION_NAME      TEXT("ExternalConnectionName")
#define S_INTERNAL_IS_BRIDGE            TEXT("InternalIsBridge")
#define S_INTERNAL_ADAPTER              TEXT("InternalAdapter")
#define S_INTERNAL_ADAPTER2             TEXT("InternalAdapter2")
#define S_BRIDGE                        TEXT("Bridge")
#define S_ENABLE_AUTODIAL               TEXT("EnableAutodial")
#define S_DIAL_ON_DEMAND                TEXT("DialOnDemand")
#define S_ENABLEICS                     TEXT("EnableICS")
#define S_SHOW_TRAY_ICON                TEXT("ShowTrayIcon")
#define S_ISW9XUPGRADE                  TEXT("IsW9xUpgrade")
#define S_NET_PREFIX                    TEXT("Net\\")
//---------------------------------------------------------------

#define S_DEVICE_DRIVERS                TEXT("DeviceDrivers")
#define S_MODEM                         TEXT("Modem")
#define S_MODEMMODEL                    TEXT("Model")
#define S_COM                           TEXT("COM")
#define S_NICIDMAP                      TEXT("NIC ID Map")
#define S_MODEM_UI_OPTIONS              TEXT("__UiOptions")
#define S_MODEM_CFG_OPTIONS             TEXT("__CfgOptions")
#define S_MODEM_SPEED                   TEXT("__Speed")
#define S_MODEM_SPEAKER_VOLUME          TEXT("__SpeakerVolume")
#define S_MODEM_IDLE_DISCONNECT_SECONDS TEXT("__IdleDisconnect")
#define S_MODEM_CANCEL_SECONDS          TEXT("__CancelSeconds")
#define S_MODEM_CFG_OPTIONS             TEXT("__CfgOptions")
#define S_DEVICECOUNT                   TEXT("__DeviceCount")
#define S_SERVICESSECTION               TEXT("Services")
#define S_RAS                           TEXT("RAS")
#define S_MSRASCLI                      TEXT("MS_RasCli")
#define S_PARAMSSECTION                 TEXT("ParamsSection")
#define S_PARAMSRASCLI                  TEXT("Params.RasCli")
#define S_PORTSECTIONS                  TEXT("PortSections")
#define S_DIALOUTPROTOCOLS              TEXT("DialoutProtocols")
#define S_PORTNAME                      TEXT("PortName")
#define S_DEVICETYPE                    TEXT("DeviceType")
#define S_PORTUSAGE                     TEXT("PortUsage")
#define S_DIALINOUT                     TEXT("DialInOut")
#define S_DIALOUT                       TEXT("DialOut")
#define S_INSTALLMODEM                  TEXT("InstallModem")

#define S_MERGE_FORCECOPY            TEXT("Force Win9x Settings")
#define S_MERGE_RENAME               TEXT("Map Win9x to WinNT")
#define S_MERGE_WIN9X_CONVERSION     TEXT("Win9x Data Conversion")
#define S_MERGE_WINNT_CONVERSION     TEXT("WinNT Data Conversion")
#define S_MERGE_WIN9X_SUPPRESS       TEXT("Suppress Win9x Settings")
#define S_MERGE_WIN9X_SUPPRESS_DU    TEXT("Suppress Win9x Settings.Default User")
#define S_MERGE_WIN9X_SUPPRESS_LU    TEXT("Suppress Win9x Settings.Logon Account")
#define S_MERGE_WIN9X_SUPPRESS_HW    TEXT("Suppress Win9x Hardware Profile")
#define S_MERGE_WIN9X_SUPPRESS_SFT_D TEXT("Default Software Keys Of Win9x Hardware Profile")

#define S_MERGE_WINNT_SUPPRESS       TEXT("Suppress WinNT Settings")
#define S_MERGE_DONT_COMBINE_WITH_DEFAULT TEXT("Dont Merge WinNT with Win9x")
#define S_MERGE_FORCE_NT_DEFAULTS    TEXT("Force WinNT Settings")
#define S_MIGRATION_INF_CLASS        TEXT("Migration")
#define S_MERGE_HKCC_SUPPRESS        TEXT("Suppress HKCC Settings")
#define S_WKSTAMIG_REDIR_MAPPING     TEXT("Redirector Name Mapping")
#define S_WKSTAMIG_HIVE_FILES        TEXT("HiveFilesToConvert")

#define S_WIN95_DIRECTORIES          TEXT("Win95.Directories")
#define S_WIN95_INSTALL              TEXT("Win95.Install")
#define S_MEMDB_TEMP_RUNTIME_DLLS    TEXT("Temp: Runtime Dlls")

#define S_SYSTEM32                   TEXT("system32")
#define S_CTL3D32DLL                 TEXT("ctl3d32.dll")
#define S_MOVEBEFOREMIGRATION        TEXT("Files.MoveBeforeMigration")
#define S_DELETEBEFOREMIGRATION      TEXT("Files.DeleteBeforeMigration")
#define S_INF                        TEXT("inf")
#define S_WINDOWS_CURRENTVERSION     TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion")
#define S_USER_LIST_KEY              TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg\\Users")
#define S_WINLOGON_USER_LIST_KEY     TEXT("HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\\LocalUsers")
#define S_WIN9XUPG_KEY               TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg")
#define S_USERS_SUBKEY               TEXT("Users")
#define S_CURRENT_USER_VALUENAME     TEXT("CurrentUser")
#define S_RUN_KEY                    TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCE_KEY                TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_AUTOSTRESS_KEY             TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg\\AutoStress")
#define S_REG_SHARED_DLLS            TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs")
#define S_DEVICEPATH                 TEXT("DevicePath")
#define S_REGKEY_DARWIN_COMPONENTS   S_WINDOWS_CURRENTVERSION TEXT("\\Installer\\Components")
#define S_REG_KEY_UNDO_PATH          TEXT("Win9xUndoDirPath")
#define S_REG_KEY_UNDO_INTEGRITY     TEXT("Win9xUndoIntegrityInfo")
#define S_REG_KEY_UNDO_APP_LIST      TEXT("PreviousOsAppList")
#define S_REGKEY_WIN_SETUP           TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup")
#define S_AUTOSTRESS_USER            TEXT("User")
#define S_AUTOSTRESS_PASSWORD        TEXT("Password")
#define S_AUTOSTRESS_OFFICE          TEXT("Office")
#define S_AUTOSTRESS_DBG             TEXT("DbgMachine")
#define S_AUTOSTRESS_FLAGS           TEXT("Flags")

#define S_NETWORKING                 TEXT("Networking")
#define S_PROCESSPAGESECTIONS        TEXT("ProcessPageSections")
#define S_DIALUP_ADAPTER_DESC        TEXT("Dial-Up Adapter")
#define S_DIALUP_PNP                 TEXT("*PNP8387")
#define S_NETWORK_BRANCH             TEXT("HKLM\\Enum\\Network")
#define S_BINDINGS                   TEXT("Bindings")

#define S_PAGE_IDENTIFICATION        TEXT("Identification")
#define S_DOMAIN_ACCT_CREATE         TEXT("CreateComputerAccountInDomain")
#define S_DOMAIN_ADMIN               TEXT("DomainAdmin")
#define S_DOMAIN_ADMIN_PW            TEXT("DomainAdminPassword")
#define S_ENCRYPTED_DOMAIN_ADMIN_PW  TEXT("EncryptedDomainAdminPassword")
#define S_COMPUTERNAME               TEXT("ComputerName")
#define S_MODEM_COM_PORT             TEXT("ComPort")
#define S_BUILDNUMBER                TEXT("BuildNumber")

#define S_SVRAPI_DLL                 TEXT("svrapi.dll")
#define S_ANSI_NETSHAREENUM          "NetShareEnum"
#define S_ANSI_NETACCESSENUM         "NetAccessEnum"

#define S_SHELL_FOLDERS_KEY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define S_USER_SHELL_FOLDERS_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define S_SYSTEM_STARTUP             TEXT("Common Startup")
#define S_USER_STARTUP               TEXT("Startup")
#define S_SENDTO                     TEXT("SendTo")
#define S_SENDTO_SUPPRESS            TEXT("SendTo.SuppressFiles")
#define S_ADDREG                     TEXT("AddReg")
#define S_SHELL_FOLDERS_KEY_SYSTEM   TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define S_SHELL_FOLDERS_KEY_USER     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define S_USHELL_FOLDERS_KEY_SYSTEM  TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define S_USHELL_FOLDERS_KEY_USER    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define S_HIVEDEF_INF                TEXT("HIVEDEF.INF")
#define S_HIVESFT_INF                TEXT("HIVESFT.INF")
#define S_HIVESYS_INF                TEXT("HIVESYS.INF")
#define S_TXTSETUP_SIF               TEXT("TXTSETUP.SIF")
#define S_HDC                        TEXT("HDC")
#define S_REGISTEREDOWNER            TEXT("RegisteredOwner")
#define S_REGISTEREDORGANIZATION     TEXT("RegisteredOrganization")
#define S_DISPLAYSETTINGS            TEXT("HKCC\\Display\\Settings")
#define S_BITSPERPIXEL               TEXT("BitsPerPixel")
#define S_RESOLUTION                 TEXT("Resolution")
#define S_FRAME_TYPE                 TEXT("frame_type")
#define S_PKTTYPE                    TEXT("PktType")
#define S_IPX_SUFFIX                 TEXT(".ipx")
#define S_TCPIP_SUFFIX               TEXT(".tcpip")
#define S_STD                        TEXT("std")
#define S_DLT                        TEXT("dlt")

#define S_VIRTUAL_FILES              TEXT("Win95.VirtualFiles")


//
// UI
//

#define S_TEXTVIEW_CLASS                TEXT("TextView")


//
// Registry value names
//

#define S_DRIVERVAL                  TEXT("Driver")
#define S_IPADDRVAL                  TEXT("IPAddress")
#define S_SUBNETVAL                  TEXT("IPMask")
#define S_DEFGATEWAYVAL              TEXT("DefaultGateway")
#define S_HOSTNAMEVAL                TEXT("HostName")
#define S_NAMESERVERVAL              TEXT("NameServer")
#define S_NAMESERVER1VAL             TEXT("NameServer1")
#define S_NAMESERVER2VAL             TEXT("NameServer2")
#define S_DOMAINVAL                  TEXT("Domain")
#define S_DAYLIGHTNAME               TEXT("DaylightName")
#define S_STANDARDNAME               TEXT("StandardName")
#define S_DAYLIGHTFLAG               TEXT("DaylightFlag")
#define S_ORDER                      TEXT("Order")

//
// Registry key locations and value names
//

#define S_KEYBOARDLAYOUTNUM          TEXT("HKCU\\keyboard layout\\preload\\1")
#define S_TIMEZONEINFORMATION        TEXT("HKLM\\System\\CurrentControlSet\\control\\TimeZoneInformation")
#define S_TIMEZONES                  TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Time Zones")
#define S_NETWORKMSTCP               TEXT("HKLM\\Enum\\Network\\MSTCP")
#define S_MSTCP_KEY                  TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\MSTCP")
#define S_SERVICECLASS               TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class")
#define S_SERVICEREMOTEACCESS        TEXT("HKLM\\System\\CurrentControlSet\\Services\\RemoteAccess")
#define S_MODEMS                     TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class\\Modem")
#define S_PERSISTENT_CONNECTIONS     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections")
#define S_SAGE                       TEXT("HKLM\\SOFTWARE\\Microsoft\\Plus!\\System Agent\\SAGE")
#define S_SAGE_FRIENDLY_NAME         TEXT("Friendly Name")
#define S_SAGE_PROGRAM               TEXT("Program")
#define S_SHELL_ICONS_REG_KEY        TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\explorer\\Shell Icons")
#define S_MIGRATION                  TEXT("Migration")
#define S_SOFTWARE                   TEXT("\\Software")



//
// STRING SECTION (NT 5 network unattend strings)
// Used By: unattend.c
//

#define S_PAGE_NETADAPTERS              TEXT("NetAdapters")
#define S_DETECT                        TEXT("Detect")
#define S_BUSTYPE                       TEXT("BusType")
#define S_IOADDR                        TEXT("IoAddr")
#define S_IRQ                           TEXT("IRQ")
#define S_DMA                           TEXT("DMA")
#define S_MEM                           TEXT("MEM")
#define S_TRANSCIEVERTYPE               TEXT("TranscieverType")
#define S_IOCHANNELREADY                TEXT("IoChannelReady")

#define S_PREFERREDSERVER               TEXT("PreferredServer")
#define S_AUTHENTICATINGAGENT           TEXT("AuthenticatingAgent")
#define S_AUTHAGENTREG                  TEXT("HKLM\\System\\CurrentControlSet\\Services\\NWNP32\\NetworkProvider")
#define S_NWREDIRREG                    TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\NWReDir")
#define S_NETWORKLOGON                  TEXT("HKLM\\Network\\Logon")
#define S_PROCESSLOGINSCRIPT            TEXT("ProcessLoginScript")
#define S_LOGONSCRIPT                   TEXT("LogonScript")
#define S_DEFAULTCONTEXT                TEXT("DefaultContext")
#define S_DEFAULTTREE                   TEXT("DefaultTree")
#define S_DEFAULTNAMECONTEXT            TEXT("DefaultNameContext")
#define S_PREFERREDTREE                 TEXT("PreferredTree")
#define S_PREFERREDNDSTREE              TEXT("PreferredNDSTree")
#define S_FIRSTNETWORKDRIVE             TEXT("FirstNetworkDrive")
#define S_PRESERVECASE                  TEXT("PreserveCase")
#define S_MS_NWLINK                     TEXT("MS_NWLINK")


#define S_NETBEUI                       TEXT("NETBEUI")
#define S_MSDLC                         TEXT("MSDLC")
#define S_MSDLC32                       TEXT("MSDLC32")
#define S_MSTCP                         TEXT("MSTCP")
#define S_NWLINK                        TEXT("NWLINK")
#define S_NWLINKREG                     TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\NWLink")
#define S_CACHESIZE                     TEXT("cachesize")
#define S_NWREDIR                       TEXT("NWREDIR")
#define S_VREDIR                        TEXT("VREDIR")
#define S_VSERVER                       TEXT("VSERVER")
#define S_BROWSER                       TEXT("Browser")
#define S_SERVICESTARTTYPES             TEXT("ServiceStartTypes")
#define S_MS_TCPIP                      TEXT("MS_TCPIP")
#define S_MS_NWIPX                      TEXT("MS_NWIPX")
#define S_MS_DLC                        TEXT("MS_DLC")
#define S_MS_NETBEUI                    TEXT("MS_NETBEUI")
#define S_PAGE_NETPROTOCOLS             TEXT("NetProtocols")
#define S_NETBINDINGS                   TEXT("NetBindings")
#define S_DISABLED                      TEXT("Disable")
#define S_SUBNETMASK                    TEXT("SubnetMask")
#define S_DNSSERVERSEARCHORDER          TEXT("DNSServerSearchOrder")
#define S_DNSSUFFIXSEARCHORDER          TEXT("DNSSuffixSearchOrder")
#define S_DNS                           TEXT("DNS")
#define S_DNSHOST                       TEXT("DNSHostName")
#define S_DNSDOMAIN                     TEXT("DNSDomain")
#define S_IMPORTLMHOSTSFILE             TEXT("ImportLMHostsFile")
#define S_PAGE_NETSERVICES              TEXT("NetServices")
#define S_MS_NETCLIENT                  TEXT("MS_MSClient")
#define S_PAGE_NETCLIENTS               TEXT("NetClients")
#define S_MS_RASCLI                     TEXT("MS_RasCli")
#define S_CLIENT                        TEXT("Client")
#define S_MS_NETBT                      TEXT("MS_NetBT")
#define S_MS_SERVER                     TEXT("MS_Server")
#define S_MS_NWCLIENT                   TEXT("MS_NWClient")
#define S_ENUM_NETWORK_KEY              TEXT("HKLM\\Enum\\Network")
#define S_MS_NBT                        TEXT("MS_NBT")
#define S_UPGRADEFROMPRODUCT            TEXT("UpgradeFromProduct")
#define S_WINDOWS95                     TEXT("Windows95")
#define S_SOURCEROUTING                 TEXT("SourceRouting")
#define S_INFID                         TEXT("InfID")
#define S_DISPLAY_SETTINGS              TEXT("HKCC\\Display\\Settings")
#define S_BITSPERPIXEL                  TEXT("BitsPerPixel")
#define S_RESOLUTION                    TEXT("Resolution")
#define S_ENABLEDNS                     TEXT("EnableDns")
#define S_SCOPEID                       TEXT("ScopeID")
#define S_NODEVAL                       TEXT("NodeType")
#define S_SNMP                          TEXT("SNMP")
#define S_UPNP                          TEXT("UPNP")
#define S_REGKEY_UPNP                   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UPnP")
#define S_NETOPTIONALCOMPONENTS         TEXT("NetOptionalComponents")




//
// Win95upg.inf sections
//

#define S_TIMEZONEMAPPINGS                  TEXT("TimeZoneMappings")
#define S_CONDITIONAL_INCOMPATIBILITIES     TEXT("Conditional Incompatibilities")
#define S_SUPPORTED_PROTOCOLS               TEXT("Supported Protocols")
#define S_SUPPORTED_PASSWORD_PROVIDERS      TEXT("Supported Password Providers")
#define S_SAGE_EXCLUSIONS                   TEXT("Standard System Agents")
#define S_SHELL_FOLDERS_PRESERVED           TEXT("ShellFolders.Preserved")
#define S_SHELL_FOLDERS_SKIPPED             TEXT("ShellFolders.Skipped")
#define S_SHELL_FOLDERS_DEFAULT             TEXT("ShellFolders.Default")
#define S_SHELL_FOLDERS_ALT_DEFAULT         TEXT("ShellFolders.AlternateDefault")
#define S_SHELL_FOLDERS_PERUSER_TO_COMMON   TEXT("ShellFolders.PerUserToCommon")
#define S_SHELL_FOLDERS_NTINSTALLED_USER    TEXT("ShellFolders.NtInstalled_User")
#define S_SHELL_FOLDERS_NTINSTALLED_COMMON  TEXT("ShellFolders.NtInstalled_Common")
#define S_SHELL_FOLDERS_MASSIVE             TEXT("ShellFolders.DontMove")
#define S_SHELL_FOLDERS_DONT_COLLAPSE       TEXT("ShellFolders.KeepPerUser")
#define S_SHELL_FOLDERS_SHORT               TEXT("ShellFolders.ShortNames")
#define S_SHELL_FOLDERS_RENAMED             TEXT("ShellFolders.Renamed")
#define S_SHELL_FOLDERS_DISK_SPACE          TEXT("ShellFolders.SpaceRequirements")
#define S_VIRTUAL_SF                        TEXT("ShellFolders.VirtualSF")
#define S_ONE_USER_SHELL_FOLDERS            TEXT("ShellFolders.ForcePerUser")
#define S_SHELL_FOLDER_PRIORITY             TEXT("ShellFolders.Priority")
#define S_FILES_TO_REMOVE                   TEXT("Delete Files")
#define S_MOVED_ICONS                       TEXT("Moved Icons")
#define S_SUPPRESSED_GUIDS                  TEXT("Suppressed GUIDs")
#define S_FORCED_GUIDS                      TEXT("Forced GUIDs")
#define S_ANSWER_FILE_DETECTION             TEXT("Answer File Detection")
#define S_KNOWN_GOOD_ICON_MODULES           TEXT("Compatible Icon Indexes")
#define S_SHELLFOLDERSMIGRATIONDIRS         TEXT("ShellFolders.MigrationDirs")
#define S_APPROVED_GUID_LAUNCHER            TEXT("ApprovedGUIDLauncher")
#define S_STRINGMAP                         TEXT("String Map")
#define S_UNINSTALL_DISKSPACEESTIMATION     TEXT("Uninstall.DiskSpaceEstimation")

//
// STRING SECTION (Hardware Strings)
// Used By: hwcomp.c, online.c, hwdisk.c
//

#define S_ISA       TEXT("ISA")
#define S_EISA      TEXT("EISA")
#define S_MCA       TEXT("MCA")
#define S_PCI       TEXT("PCI")
#define S_PNPISA    TEXT("PNPISA")
#define S_PCMCIA    TEXT("PCMCIA")
#define S_ROOT      TEXT("ROOT")

#define S_NET       TEXT("net")
#define S_IOADDR    TEXT("IoAddr")
#define S_IRQ       TEXT("IRQ")
#define S_DMA       TEXT("DMA")
#define S_MEMRANGE  TEXT("Memory")

#define S_LAYOUT_INF TEXT("layout.inf")

#define S_IGNORE_REG_KEY    TEXT("Ignore PNP Key")

#define S_FORCEDCONFIG      TEXT("ForcedConfig")
#define S_BOOTCONFIG        TEXT("BootConfig")
#define S_ALLOCATION        TEXT("Allocation")

#define S_CONFIG_MANAGER        TEXT("Config Manager\\Enum")
#define S_HARDWAREKEY_VALUENAME TEXT("HardWareKey")
#define S_ENUM_BRANCH           TEXT("Enum")
#define S_CLASS_VALUENAME       TEXT("Class")

#define S_KEYBOARD_CLASS        TEXT("keyboard")
#define S_KEYBOARD_IN_          TEXT("keyboard.in_")
#define S_KEYBOARD_INF          TEXT("keyboard.inf")
#define S_LEGACY_XLATE_DEVID    TEXT("LegacyXlate.DevId")

#define S_MANUFACTURER              TEXT("Manufacturer")
#define S_DOLLAR_WINDOWS_NT_DOLLAR  TEXT("$WINDOWS NT$")
#define S_VERSION                   TEXT("Version")
#define S_SIGNATURE                 TEXT("Signature")
#define S_COPYFILES                 TEXT("CopyFiles")
#define S_CATALOGFILE               TEXT("CatalogFile")
#define S_SOURCEDISKSFILES          TEXT("SourceDisksFiles")
#define S_LAYOUTFILES               TEXT("LayoutFiles")

//
// STRING SECTION (Drive Letter preservation strings)
// Used By: drvlettr.c
//

#define S_CLASS                     TEXT("Class")
#define S_CDROM                     TEXT("CDROM")
#define S_SCSITARGETID              TEXT("SCSITargetId")
#define S_SCSILUN                   TEXT("SCSILUN")
#define S_CURRENTDRIVELETTER        TEXT("CurrentDriveLetterAssignment")
#define S_ENUMSCSI                  TEXT("Enum\\SCSI")


//
// STRING SECTION (migmain strings)
// Used By: w95upgnt\migmain\filemig.c, w95upgnt\migmain\migmain.c, w95upgnt\migmain\iniact.c
//
#define S_DEFAULTUSER               TEXT(".default")
#define S_PROFILES                  TEXT("Profiles")
#define S_SETUP                     TEXT("setup")
#define S_EMPTY                     TEXT("")
#define S_WINLOGON_KEY                      TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define S_INIFILEMAPPING_KEY                TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping")
#define S_SUPPRESS_INI_FILE_MAPPINGS        TEXT("INI File Mapping.Suppress")
#define S_NO_OVERWRITE_INI_FILE_MAPPINGS    TEXT("INI File Mapping.Preserve Fresh Install")
#define S_MOVEINISETTINGS           TEXT("MoveIniSettings")
#define S_SHELL_KEY                 TEXT("SYSTEM.INI\\BOOT\\SHELL")
#define S_SF_PROFILES               TEXT("Profiles")
#define S_SF_COMMON_PROFILES        TEXT("Common Profiles")
#define S_SHELLEXT_APPROVED         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")
#define S_DEFAULT                   TEXT("Default")


//
// STRING SECTION (migmain strings)
// Used By: w95upgnt\migmain\acctlist.c
//
#define S_UNKNOWN_DOMAIN            TEXT("\\unknown")
#define S_FAILED_DOMAIN             TEXT("\\failed")
#define S_LOCAL_DOMAIN              TEXT("\\local")

//
// STRING SECTION (Dos Migration strings)
// Used By: dosmig95.c dosmignt.c
//

#define S_CONSOLEKEY                    TEXT("console")
#define S_INSERTMODEVALUE               TEXT("insertmode")
#define S_ENVIRONMENTKEY                TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")
#define S_WINLOGONKEY                   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define S_AUTOPARSEVALUE                TEXT("ParseAutoexec")
#define S_COMSPEC_PATTERN               TEXT("comspec*")

//
// STRING SECTION (Hardware Profile Registry Strings)
// Used By: w95upgnt\merge
//

#define S_HW_ID_0001                    TEXT("0001")
#define S_HW_DEFAULT                    TEXT("Default")
#define S_TREE                          TEXT("\\*")

#define S_BASE_IDCONFIGDB_KEY           TEXT("HKLM\\System\\CurrentControlSet\\Control\\IDConfigDB")
#define S_IDCONFIGDB_HW_KEY             S_BASE_IDCONFIGDB_KEY TEXT("\\Hardware Profiles")
#define S_NT_HW_ID_MASK                 S_IDCONFIGDB_HW_KEY TEXT("\\%04u")
#define S_CURRENT_CONFIG                S_BASE_IDCONFIGDB_KEY TEXT("\\[CurrentConfig]")

#define S_9X_CONFIG_KEY                 TEXT("HKLM\\Config")
#define S_9X_CONFIG_MASK                S_9X_CONFIG_KEY TEXT("\\%04u")
#define S_NT_CONFIG_KEY                 TEXT("HKLM\\System\\CurrentControlSet\\Hardware Profiles")
#define S_NT_CONFIG_MASK                S_NT_CONFIG_KEY TEXT("\\%04u")

#define S_NT_DEFAULT_HW_ID_KEY          S_IDCONFIGDB_HW_KEY TEXT("\\") S_HW_DEFAULT
#define S_NT_DEFAULT_HW_KEY             S_NT_CONFIG_KEY TEXT("\\") S_HW_DEFAULT

#define S_FRIENDLYNAME                  TEXT("FriendlyName")
#define S_PREFERENCEORDER               TEXT("PreferenceOrder")


#define S_NT_HARDWARE_PROFILE_SPRINTF   TEXT("HKLM\\System\\CurrentControlSet\\Hardware Profiles\\%04u\\*")
#define S_9X_HARDWARE_PROFILE_NAMES     TEXT("HKLM\\System\\CurrentControlSet\\Control\\IDConfigDB")
#define S_NT_HARDWARE_PROFILE_TREE      TEXT("HKLM\\System\\CurrentControlSet\\Hardware Profiles\\*")
#define S_NT_HWPROFILE_NAME_REGVAL      TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Control\\IDConfigDB\\Hardware Profiles\\%04u\\[FriendlyName]")
#define S_NT_HWPROFILE_NAME_REGKEY      TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Control\\IDConfigDB\\Hardware Profiles\\%04u\\*")
#define S_NT_HWPROFILE_NAME_ENUM        TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Control\\IDConfigDB\\Hardware Profiles\\*")


//
// Conditional messages section (of sysmig)
//

#define S_NET_FILTER                    TEXT("Net")
#define S_HARDWAREID_VALUENAME          TEXT("HardwareID")
#define S_PNP8387                       TEXT("*PNP8387")
#define S_HKCUEUDC                      TEXT("HKLM\\System\\CurrentControlSet\\Control\\NLS\\CodePage\\EUDCCodeRange")
#define S_HKLMEUDC                      TEXT("HKCU\\EUDC")
#define S_PASSWORDPROVIDER              TEXT("HKLM\\System\\CurrentControlSet\\Control\\PwdProvider")
#define S_PASSWORDPROVIDER_DESCRIPTION  TEXT("Description")
#define S_CONFIG_KEY                    TEXT("HKLM\\Config")
#define S_ENUM_SUBKEY                   TEXT("Enum")
#define S_FRIENDLYNAME_SPRINTF          TEXT("FriendlyName%04u")
#define S_FRIENDLYNAME_KEY              TEXT("HKLM\\System\\CurrentControlSet\\Control\\IDConfigDB")
#define S_DRIVER                        TEXT("Driver")
#define S_CLASS_KEY                     TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class")
#define S_DRIVERDESC                    TEXT("DriverDesc")
#define S_MFG                           TEXT("Mfg")
#define S_ATTACHEDTO                    TEXT("AttachedTo")
#define S_MODEL                         TEXT("Model")
#define S_PARENTDEVNODE                 TEXT("ParentDevNode")
#define S_ENUM                          TEXT("HKLM\\Enum")

//
// Common strings
//

#define S_DEVICE                  TEXT("Device")
#define S_DEVICEHIGH              TEXT("DeviceHigh")
#define S_INSTALL                 TEXT("Install")
#define S_MENU                    TEXT("MENU")
#define S_DOSCOMPINFNAME          TEXT("doscomp.inf")
#define S_DOSMIGBADBLOCK          TEXT("Incompatible")
#define S_DOSMIGUSEBLOCK          TEXT("Use")
#define S_DOSMIGIGNOREBLOCK       TEXT("Ignore")
#define S_DOSMIGCONDITIONALBLOCK  TEXT("Conditional Compatibility")
#define S_ENVVARS                 TEXT("@@ENVVARS@@")
#define S_SUPPRESSED_ENV_VARS     TEXT("SuppressedEnvSettings")

#define S_DOSMIGBAD               TEXT("incompatible")
#define S_DOSMIGRULEFILESIZE      TEXT("filesize")
#define S_DOSMIGRULEFILEDATE      TEXT("filedate")
#define S_DOSMIGRULECOMMANDLINE   TEXT("commandline")
#define S_DOSMIGIGNORE            TEXT("ignoreable")
#define S_DOSMIGUSE               TEXT("use")
#define S_DOSMIGMIGRATE           TEXT("migrate")
#define S_DOSMIGUNKNOWN           TEXT("unknown")
#define S_CONFIGSYSPATH           TEXT("c:\\config.sys")
#define S_AUTOEXECPATH            TEXT("c:\\autoexec.bat")
#define S_CONFIGSYS               TEXT("config.sys")
#define S_AUTOEXECBAT             TEXT("autoexec.bat")
#define S_DOSMIGRULEFILESPEC      TEXT("filespec")
#define S_DOSMIGCOMPATIBILITY     TEXT("compatibility")
#define S_PROMPT                  TEXT("PROMPT")
#define S_COMPATIBLE              TEXT("COMPATIBLE")
#define S_MIGRATION_DIRS          TEXT("MigrationDirs")
#define S_OEM_MIGRATION_DIRS      TEXT("OemMigrationDirs")
#define S_OBSOLETE_LINKS          TEXT("ObsoleteLinks")
#define S_KNOWN_NT_LINKS          TEXT("KnownNTLinks")
#define S_UPGINFSDIR              TEXT("UpgInfs")
#define S_TARGETINF               TEXT("TargetInf")
#define S_LANGUAGE                TEXT("Language")
#define S_LANGUAGEGROUP           TEXT("LanguageGroup")
#define S_SYSTEMLOCALEREG         TEXT("HKLM\\System\\CurrentControlSet\\control\\Nls\\Locale")
#define S_LOCALES                 TEXT("Locales")
#define S_LANGUAGEGROUPS          TEXT("LanguageGroups")
#define S_INTLINF                 TEXT("Intl.Inf")
#define S_IGNORED_COLLISIONS      TEXT("IgnoredCollisions")
#define S_BACKUPFILESIGNORE       TEXT("BackupFiles.IgnoreInReport")


//
// STRING SECTION (RAS strings)
// Used By: ras.c
//
#define S_DBG_RAS                      "Ras Migrate"
#define S_DUN_ENTRY_SECTION            TEXT("Entry")
#define S_DUN_ENTRYNAME                TEXT("Entry_Name")
#define S_DUN_MULTILINK                TEXT("MultiLink")
#define S_DUN_TCPIP_SECTION            TEXT("TCP/IP")
#define S_DUN_IP_ADDRESS               TEXT("IP_Address")
#define S_DUN_DNS_ADDRESS              TEXT("DNS_Address")
#define S_DUN_DNS_ALT_ADDRESS          TEXT("DNS_Alt_Address")
#define S_DUN_WINS_ADDRESS             TEXT("Wins_Address")
#define S_DUN_WINS_ALT_ADDRESS         TEXT("Wins_Alt_Address")
#define S_DUN_IP_HEADER_COMPRESS       TEXT("Ip_Header_Compress")
#define S_DUN_GATEWAY_ON_REMOTE        TEXT("Gateway_On_Remote")
#define S_DUN_SPECIFY_IP_ADDRESS       TEXT("Specify_Ip_Address")
#define S_DUN_SPECIFY_SERVER_ADDRESS   TEXT("Specify_Ip_Address")
#define S_DUN_SERVER_SECTION           TEXT("Server")
#define S_DUN_TYPE                     TEXT("Type")
#define S_DUN_SW_COMPRESS              TEXT("Sw_Compress")
#define S_DUN_PW_ENCRYPT               TEXT("Pw_Encrypt")
#define S_DUN_NETWORK_LOGIN            TEXT("Network_Login")
#define S_DUN_SW_ENCRYPT               TEXT("Sw_Encrypt")
#define S_DUN_NETBEUI                  TEXT("Negotiable_NetBeui")
#define S_DUN_IPXSPX                   TEXT("Negotiable_Ipx/Spx")
#define S_DUN_TCPIP                    TEXT("Negotiable_Tcp/Ip")
#define S_DUN_SCRIPTFILE_SECTION       TEXT("Script_File")
#define S_DUN_NAME                     TEXT("Name")
#define S_DUN_PHONE_SECTION            TEXT("Phone")
#define S_DUN_PHONE_NUMBER             TEXT("Phone_Number")
#define S_DUN_AREA_CODE                TEXT("Area_Code")
#define S_DUN_COUNTRY_CODE             TEXT("Country_Code")
#define S_DUN_COUNTRY_ID               TEXT("Country_Id")
#define S_AE_PHONE                     TEXT("PhoneNumber")
#define S_AE_AREACODE                  TEXT("AreaCode")
#define S_AE_COUNTRYCODE               TEXT("CountryCode")
#define S_AE_COUNTRYID                 TEXT("CountryID")
#define S_IP_FTCPIP                    TEXT("_IP_FTCPIP")
#define S_IP_IPADDR                    TEXT("IpAddress")
#define S_IP_DNSADDR                   TEXT("IpDnsAddress")
#define S_IP_DNSADDR2                  TEXT("IpDns2Address")
#define S_IP_WINSADDR                  TEXT("IpWinsAddress")
#define S_IP_WINSADDR2                 TEXT("IpWins2Address")
#define S_DOMAIN                       TEXT("Domain")
#define S_CALLBACK                     TEXT("Number"))
#define S_PBE_DESCRIPTION              TEXT("Description")
#define S_PBE_AREACODE                 TEXT("AreaCode")
#define S_PBE_COUNTRYID                TEXT("CountryID")
#define S_PBE_COUNTRYCODE              TEXT("CountryCode")
#define S_PBE_USECOUNTRYANDAREACODES   TEXT("UseCountryAndAreaCodes")
#define S_PBE_DIALMODE                 TEXT("DialMode")
#define S_PBE_DIALPERCENT              TEXT("DialPercent")
#define S_PBE_DIALSECONDS              TEXT("DialSeconds")
#define S_PBE_HANGUPPERCENT            TEXT("HangUpPercent")
#define S_PBE_HANGUPSECONDS            TEXT("HangUpSeconds")
#define S_PBE_IPPRIORITIZEREMOTE       TEXT("IpPrioritizeRemote")
#define S_PBE_IPHEADERCOMPRESSION      TEXT("IpHeaderCompression")
#define S_PBE_IPADDRESS                TEXT("IpAddress")
#define S_PBE_IPDNSADDRESS             TEXT("IpDnsAddress")
#define S_PBE_IPDNSADDRESS2            TEXT("IpDns2Address")
#define S_PBE_IPWINSADDRESS            TEXT("IpWinsAddress")
#define S_PBE_IPWINSADDRESS2           TEXT("IpWins2Address")
#define S_PBE_IPASSIGN                 TEXT("IpAssign")
#define S_PBE_IPNAMEASSIGN             TEXT("IpNameAssign")
#define S_PBE_IPFRAMESIZE              TEXT("IpFrameSize")
#define S_PBE_AUTHRESTRICTIONS         TEXT("AuthRestrictions")
#define S_PBE_AUTHENTICATESERVER       TEXT("AuthenticateServer")
#define S_PBE_DATAENCRYPTION           TEXT("DataEncryption")
#define S_PBE_AUTOLOGON                TEXT("AutoLogon")
#define S_PBE_SECURELOCALFILES         TEXT("SecureLocalFiles")
#define S_PBE_OVERRIDEPREF             TEXT("OverridePref")
#define S_PBE_REDIALATTEMPTS           TEXT("RedialAttempts")
#define S_PBE_REDIALSECONDS            TEXT("RedialSeconds")
#define S_PBE_IDLEDISCONNECTSECONDS    TEXT("IdleDisconnectSeconds")
#define S_PBE_REDIALONLINKFAILURE      TEXT("RedialOnLinkFailure")
#define S_PBE_POPUPONTOPWHENREDIALIING TEXT("PopupOnTopWhenRedialing")
#define S_PBE_CALLBACKMODE             TEXT("CallbackMode")
#define S_PBE_CUSTOMDIALDLL            TEXT("CustomDialDll")
#define S_PBE_CUSTOMDIALFUNC           TEXT("CustomDialFunc")
#define S_PBE_USEPWFORNETWORK          TEXT("USePwForNetwork")
#define S_PBE_DIALPARAMSUID            TEXT("DialParamsUID")
#define S_PBE_BASEPROTOCOL             TEXT("BaseProtocol")
#define S_PBE_EXCLUDEDPROTOCOLS        TEXT("ExcludedProtocols")
#define S_PBE_LCPEXTENSIONS            TEXT("LcpExtensions")
#define S_PBE_AUTHENTICATION           TEXT("Authentication")
#define S_PBE_SKIPNWCWARNING           TEXT("SkipNwcWarning")
#define S_PBE_SKIPDOWNLEVELDIALOG      TEXT("SkipDownLevelDialog")
#define S_PBE_SWCOMPRESSION            TEXT("SwCompression")
#define S_RASMANSLIB                   TEXT("rasmans.dll")
#define S_SETENTRYDIALPARAMS           "SetEntryDialParams"
#define S_RASAPI32LIB                  TEXT("rasapi32.dll")
#define S_RNAGETDEFAUTODIALCON         TEXT("RnaGetDefaultAutodialConnection")
#define S_PROFILEMASK                  TEXT("HKU\\%s\\RemoteAccess\\Profile")
#define S_PROFILEENTRYMASK             TEXT("HKU\\%s\\RemoteAccess\\Profile\\%s")
#define S_ADDRESSESMASK                TEXT("HKU\\%s\\RemoteAccess\\Addresses")
#define S_ADDRESSENTRY                 TEXT("_ADDRESSESENTRY")
#define S_PASSWORD                     TEXT("_PASSWORD")
#define S_RESOURCEMASK                 TEXT("*Rna\\%s\\%s")
#define S_RNAPWL                       TEXT("*Rna")
#define S_NULL                         TEXT("")
#define S_USER                         TEXT("User")
#define S_HKU                          TEXT("HKU")
#define S_IPINFO                       TEXT("IP")
#define S_ZEROIPADDR                   TEXT("0.0.0.0")
#define S_SERIAL                       TEXT("serial")
#define S_LOCATIONS_REGKEY             TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations")
#define S_NAME                         TEXT("Name")
#define S_AREACODE                     TEXT("AreaCode")
#define S_COUNTRY                      TEXT("Country")
#define S_DISABLECALLWAITING           TEXT("DisableCallWaiting")
#define S_LONGDISTANCEACCESS           TEXT("LongDistanceAccess")
#define S_OUTSIDEACCESS                TEXT("OutsideAccess")
#define S_FLAGS                        TEXT("Flags")
#define S_ID                           TEXT("ID")
#define S_TELEPHON_INI                 TEXT("telephon.ini")
#define S_LOCATIONS                    TEXT("Locations")
#define S_CURRENTLOCATION              TEXT("CurrentLocation")
#define S_CURRENTID                    TEXT("CurrentID")
#define S_NEXTID                       TEXT("NextID")
#define S_NUMENTRIES                   TEXT("NumEntries")
#define S_RASPHONE_SUBPATH             TEXT("system32\\ras\\rasphone.pbk")
#define S_PPP                          TEXT("PPP")
#define S_SLIP                         TEXT("Slip")
#define S_CSLIP                        TEXT("CSlip")
#define S_REMOTE_ACCESS_KEY            TEXT("RemoteAccess")
#define S_PROFILE_KEY                  TEXT("RemoteAccess\\Profile")
#define S_ADDRESSES_KEY                TEXT("RemoteAccess\\Addresses")
#define S_AUTODIAL_KEY                 TEXT("Software\\Microsoft\\RAS AutoDial\\Default")
#define S_DIALUI                       TEXT("DialUI")
#define S_ENABLE_REDIAL                TEXT("EnableRedial")
#define S_REDIAL_WAIT                  TEXT("RedialWait")
#define S_REDIAL_TRY                   TEXT("RedialTry")
#define S_ENABLE_IMPLICIT              TEXT("EnableImplicit")
#define S_TERMINAL                     TEXT("Terminal")
#define S_MODE                         TEXT("Mode")
#define S_MULTILINK                    TEXT("MultiLink")
#define S_PHONE_NUMBER                 TEXT("Phone Number")
#define S_AREA_CODE                    TEXT("Area Code")
#define S_SMM                          TEXT("SMM")
#define S_COUNTRY_CODE                 TEXT("Country Code")
#define S_COUNTRY_ID                   TEXT("Country Id")
#define S_DEVICE_NAME                  TEXT("Device Name")
#define S_DEVICE_TYPE                  TEXT("Device Type")
#define S_DEVICE_ID                    TEXT("Device Id")
#define S_SMM_OPTIONS                  TEXT("SMM Options")
#define S_SUBENTRIES                   TEXT("SubEntries")
#define S_DEFINTERNETCON               TEXT("DefaultInternet")
#define S_PPPSCRIPT                    TEXT("PPPSCRIPT")
#define S_SPEED_DIAL_SETTINGS          TEXT("Speed Dial Settings")
#define S_SPEEDDIALKEY                 TEXT("Software\\Microsoft\\Dialer\\Speeddial")
#define S_MODEMREG                     TEXT("HKLM\\System\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}")
#define S_DIALER_INI                   TEXT("dialer.ini")

//
// STRING SECTION (Network Migration Strings)
// Used By: migmain\wkstamig.c
//

#define S_SHELL32_DLL                   TEXT("shell32.dll")
#define S_ANSI_SHUPDATERECYCLEBINICON   "SHUpdateRecycleBinIcon"
#define S_NONE_GROUP                    TEXT("none")
#define S_FONTS                         TEXT("Fonts")
#define S_MMFONTS                       TEXT("MMFonts")
#define S_TRANSFER_HIVE                 TEXT("$$temp$$")

//
// STRINGSECTION (User Migration Strings)
// Used By: w95upgnt\migmain\usermig.c

#define S_DESKTOP_KEY           TEXT("Control Panel\\desktop")
#define S_INTERNATIONAL_KEY     TEXT("Control Panel\\International")
#define S_WALLPAPER             TEXT("Wallpaper")
#define S_WALLPAPER_STYLE       TEXT("WallpaperStyle")
#define S_TILE_WALLPAPER        TEXT("TileWallpaper")
#define S_HKR                   TEXT("HKR")
#define S_SHORT_DATE_VALUE      TEXT("sShortDate")


//
// STRINGSECTION (common strings)
// Used By: w95upg\common

//
// ipc.c strings..
//
#define S_ONLINE_EVENT      TEXT("IsolIsOnline")
#define S_ACK_EVENT         TEXT("SetupAck")

//
// buildinf strings..
//
#define S_ANSWERFILE_SECTIONMASK    TEXT("SIF %s Keys")


//
// win95reg strings..
//
#define S_WIN95REG_NAME TEXT("Win95reg")
#define S_SYSDAT        TEXT("system.dat")
#define S_USERDAT       TEXT("user.dat")
#define S_WACK_USERDAT  TEXT("\\user.dat")

#define S_HKLM_PROFILELIST_KEY  TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList")
#define S_HKLM_PROFILELIST_KEYA "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList"
#define S_PROFILELIST_KEYA      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList"
#define S_PROFILEIMAGEPATH      TEXT("ProfileImagePath")
#define S_HKU_DEFAULT           TEXT("HKU\\.Default")

// These two refer to the same key!!  Please keep in sync.
#define S_MIGRATION         TEXT("Migration")
#define S_HKLM_MIGRATION    TEXT("HKLM\\Migration")

// FreeCell fixup
#define S_FREECELL_PLAYED   TEXT("AlreadyPlayed")

//
// 16 bit environment boot strings..
//
#define S_BOOT16_DOS_DIR            TEXT("MSDOS7")
#define S_BOOT16_SECTION            TEXT("Win95-DOS files")
#define S_BOOT16_AUTOEXEC_SECTION   TEXT("Boot16 AutoExec")
#define S_BOOT16_CONFIGSYS_SECTION  TEXT("Boot16 ConfigSys")
#define S_BOOT16_COMMAND_DIR        TEXT("\\COMMAND")
#define S_BOOT16_SYSMAIN_FILE       TEXT("IO.SYS")
#define S_BOOT16_BOOTSECT_FILE      TEXT("BOOTSECT.DOS")
#define S_BOOT16_CONFIG_FILE        TEXT("CONFIG.SYS")
#define S_BOOT16_CONFIGUPG_FILE     TEXT("CONFIG.UPG")
#define S_BOOT16_STARTUP_FILE       TEXT("AUTOEXEC.BAT")
#define S_BOOT16_STARTUPUPG_FILE    TEXT("AUTOEXEC.UPG")
#define S_BOOT16_DOSINI_FILE        TEXT("MSDOS.SYS")
#define S_BOOT16_BOOTINI_FILE       TEXT("BOOT.INI")
#define S_BOOT16_BOOTDOS_FILE       TEXT("BOOT.DOS")
#define S_BOOT16_OS_SECTION         TEXT("OPERATING SYSTEMS")
#define S_BOOT16_OS_ENTRY           TEXT("MS-DOS")
#define S_BOOT16_UNSPECIFIED        TEXT("Unspecified")
#define S_BOOT16_AUTOMATIC          TEXT("Automatic")

//
// Run key enumeration
//
#define S_RUNKEY                    TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCEKEY                TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_RUNONCEEXKEY              TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define S_RUNSERVICESKEY            TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define S_RUNSERVICESONCEKEY        TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
#define S_RUNKEY_USER               TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCEKEY_USER           TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_RUNONCEEXKEY_USER         TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define S_RUNKEY_DEFAULTUSER        TEXT("HKU\\.Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCEKEY_DEFAULTUSER    TEXT("HKU\\.Default\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_RUNONCEEXKEY_DEFAULTUSER  TEXT("HKU\\.Default\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define S_RUNKEYFOLDER              TEXT("RunKey")

//
// NT various directory names
//
#define S_DRIVERSDIR       TEXT("drivers")
#define S_INFDIR           TEXT("INF")
#define S_HELPDIR          TEXT("Help")
#define S_CATROOTDIR       TEXT("CatRoot")
#define S_FONTSDIR         TEXT("Fonts")
#define S_VIEWERSDIR       TEXT("viewers")
#define S_SPOOLDIR         TEXT("spool")
#define S_SPOOLDRIVERSDIR  TEXT("drivers")
#define S_COLORDIR         TEXT("color")
#define S_COMMONDIR        TEXT("common")
#define S_PRINTPROCDIR     TEXT("prtprocs")

//
// MigPwd.exe
//

#define S_MIGPWD            TEXT("MigPwd")
#define S_MIGPWD_EXE        TEXT("migpwd.exe")


//
// lnkstub.exe
//

#define S_LNKSTUB           TEXT("LnkStub")
#define S_LNKSTUB_EXE       TEXT("LnkStub.exe")
#define S_LNKSTUB_DAT       TEXT("LnkStub.dat")


//
// These are used only NEC98
//
#define S_C98PNP            TEXT("C98PNP")

#define WINNT_D_WIN9XBOOTDRIVE_A     "Win9xBootDrive"
#define WINNT_D_WIN9XBOOTDRIVE_W    L"Win9xBootDrive"
#ifdef UNICODE
#define WINNT_D_WIN9XBOOTDRIVE    WINNT_D_WIN9XBOOTDRIVE_W
#else
#define WINNT_D_WIN9XBOOTDRIVE    WINNT_D_WIN9XBOOTDRIVE_A
#endif


//
// STRING SECTION (mmedia strings)
// Used By: w95upgnt\migmain\mmedia.c, w95upg\sysmig\mmedia.c
//

// keys under HKLM
#define S_SKEY_MEDIARESOURCES   TEXT("System\\CurrentControlSet\\Control\\MediaResources")
#define S_SKEY_WAVEDEVICES      S_SKEY_MEDIARESOURCES TEXT("\\wave")
#define S_SKEY_CDAUDIO          S_SKEY_MEDIARESOURCES TEXT("\\mci\\cdaudio")
#define S_SKEY_CDUNIT           S_SKEY_CDAUDIO TEXT("\\unit %d")

// keys under HKCU
#define S_SKEY_SCHEMES          TEXT("AppEvents\\Schemes")
#define S_SKEY_NAMES            TEXT("Names")
#define S_SKEY_APPS             TEXT("Apps")
#define S_SKEY_APPLETS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets")
#define S_SKEY_SYSTRAY          S_SKEY_APPLETS TEXT("\\SysTray")
#define S_SKEY_DELUXECDSETTINGS S_SKEY_APPLETS TEXT("\\DeluxeCD\\Settings")
#define S_SKEY_VOLUMECONTROL    S_SKEY_APPLETS TEXT("\\Volume Control")
#define S_SKEY_VOLCTL_OPTIONS   S_SKEY_VOLUMECONTROL TEXT("\\Options")
#define S_SKEY_MMEDIA           TEXT("Software\\Microsoft\\Multimedia")
#define S_SKEY_SOUNDMAPPER      S_SKEY_MMEDIA TEXT("\\Sound Mapper")
#define S_SKEY_VIDEOUSER        S_SKEY_MMEDIA TEXT("\\Video For Windows\\MCIAVI")
#define S_SKEY_CPANEL_SOUNDS    TEXT("Control Panel\\Sounds")

// WinNT specific
#define S_SKEY_WINNT_MCI        TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\MCI32")

// DSound library name
#define S_DSOUNDLIB             TEXT("DSOUND.DLL")
// System.ini file name
#define S_SYSTEM_INI            TEXT("SYSTEM.INI")

#define S_BOOTINI               TEXT("BOOT.INI")
#define S_BOOTINI_BACKUP        TEXT("bootini.bak")
#define S_BOOTSECT_BACKUP       TEXT("bootsect.bak")
#define S_BOOTFONT_BIN          TEXT("bootfont.bin")
#define S_BOOTFONT_BACKUP       TEXT("bootfont.bak")
#define S_NTLDR                 TEXT("NTLDR")
#define S_NTLDR_BACKUP          TEXT("NTLDR.bak")
#define S_NTDETECT              TEXT("NTDETECT.COM")
#define S_NTDETECT_BACKUP       TEXT("NTDETECT.bak")

// value and subkey names
#define S_MIXERDEFAULTS         TEXT("Mixer Defaults")
#define S_SPEAKERCONFIG         TEXT("Speaker Configuration")
#define S_SPEAKERTYPE           TEXT("Speaker Type")
#define S_ACCELERATION          TEXT("Acceleration")
#define S_SRCQUALITY            TEXT("SRC Quality")
#define S_DIRECTSOUND           TEXT("DirectSound")
#define S_DSMIXERDEFAULTS       S_DIRECTSOUND TEXT("\\") S_MIXERDEFAULTS
#define S_DSSPEAKERCONFIG       S_DIRECTSOUND TEXT("\\") S_SPEAKERCONFIG
#define S_DSSPEAKERTYPE         S_DIRECTSOUND TEXT("\\") S_SPEAKERTYPE
#define S_DIRECTSOUNDCAPTURE    TEXT("DirectSoundCapture")
#define S_DSCMIXERDEFAULTS      S_DIRECTSOUNDCAPTURE TEXT("\\") S_MIXERDEFAULTS
#define S_SOFTWAREKEY           TEXT("SOFTWAREKEY")
#define S_DEFAULTDRIVE          TEXT("Default Drive")
#define S_VOLUMESETTINGS        TEXT("Volume Settings")
#define S_SERVICES              TEXT("Services")
#define S_DEFAULTOPTIONS        TEXT("DefaultOptions")
#define S_USERPLAYBACK          TEXT("UserPlayback")
#define S_USERRECORD            TEXT("UserRecord")
#define S_MIXERNUMDEVS          TEXT("MixerNumDevs")
#define S_MIXERID               TEXT("Mixer%u")
#define S_NUMLINES              TEXT("NumLines")
#define S_LINEID                TEXT("Line%u")
#define S_NUMSOURCES            TEXT("NumSources")
#define S_NUMCONTROLS           TEXT("NumCtls")
#define S_SRCID                 TEXT("Src%u")
#define S_WAVENUMDEVS           TEXT("WaveNumDevs")
#define S_WAVEID                TEXT("Wave%u")
#define S_MCI                   TEXT("MCI")
#define S_WAVEAUDIO             TEXT("waveaudio")
#define S_CDROM                 TEXT("CDROM")
#define S_AUDIO                 TEXT("Audio")
#define S_SHOWVOLUME            TEXT("ShowVolOnTaskbar")
#define S_PREFERREDONLY         TEXT("PreferredOnly")
#define S_WAVEOUTNUMDEVS        TEXT("WaveOutNumDevs")
#define S_WAVEINNUMDEVS         TEXT("WaveInNumDevs")
#define S_PREFERREDPLAY         TEXT("PrefPlay")
#define S_PREFERREDREC          TEXT("PrefRec")
#define S_PLAYBACK              TEXT("Playback")
#define S_RECORD                TEXT("Record")
#define S_USERPLAYBACK          TEXT("UserPlayback")
#define S_USERRECORD            TEXT("UserRecord")
#define S_VIDEO                 TEXT("Video")
#define S_VIDEOSETTINGS         TEXT("VideoSettings")
#define S_SNDVOL32              TEXT("SndVol32")
#define S_SHOWADVANCED          TEXT("ShowAdvanced")
#define S_STYLE                 TEXT("Style")
#define S_X                     TEXT("X")
#define S_Y                     TEXT("Y")
#define S_SYSTEMDEFAULT         TEXT("SystemDefault")
#define S_DUMMYVALUE            TEXT(",")

// Flags used by various services/apps
#define SERVICE_SHOWVOLUME      0x00000004
#define STYLE_SHOWADVANCED      0x00000800

//
// Multimedia preservation - stop
//


//
// Accessibility registry values
//

#define S_ACCESS_AVAILABLE              TEXT("Available")
#define S_ACCESS_CLICKON                TEXT("ClickOn")
#define S_ACCESS_CONFIRMHOTKEY          TEXT("ConfirmHotKey")
#define S_ACCESS_HOTKEYACTIVE           TEXT("HotKeyActive")
#define S_ACCESS_HOTKEYSOUND            TEXT("HotKeySound")
#define S_ACCESS_ON                     TEXT("On")
#define S_ACCESS_ONOFFFEEDBACK          TEXT("OnOffFeedback")
#define S_ACCESS_SHOWSTATUSINDICATOR    TEXT("ShowStatusIndicator")
#define S_ACCESS_MODIFIERS              TEXT("Modifiers")
#define S_ACCESS_REPLACENUMBERS         TEXT("ReplaceNumbers")
#define S_ACCESS_AUDIBLEFEEDBACK        TEXT("AudibleFeedback")
#define S_ACCESS_TRISTATE               TEXT("TriState")
#define S_ACCESS_TWOKEYSOFF             TEXT("TwoKeysOff")
#define S_ACCESS_HOTKEYAVAILABLE        TEXT("HotKeyAvailable")


//
// Keyboard layout registry values.
//
#define S_LAYOUT_FILE TEXT("Layout File")
#define S_KBDJPDOTKBD TEXT("KBDJP.KBD")
#define S_KBDJPNDOTDLL TEXT("KBDJPN.DLL")
#define S_DLL           TEXT(".dll")
#define S_KEYBOARD_LAYOUT_REG TEXT("HKLM\\System\\CurrentControlSet\\Control\\Keyboard Layouts")
#define S_KEYBOARD_PRELOADS_REG TEXT("HKR\\keyboard layout\\preload")


#define S_OPERATING_SYSTEMS TEXT("Operating Systems")

#define S_MAKELOCALSOURCEDEVICES TEXT("MakeLSDevices")

#define S_JPN_USB_KEYBOARDS TEXT("Japanese USB Keyboards")

#define S_ALLOWEDCODEPAGEOVERRIDES TEXT("Allowed Code Page Overrides")
#define S_CODEPAGESTOIGNORE TEXT("Code Pages To Ignore")

//
// migdb.inf section names
//
#define S_USENTFILES                TEXT("UseNtFiles")

//
// Safe mode / Recovery mode
//
#define S_SAFE_MODE_FILEA           "win9xupg.sfm"
#define S_SAFE_MODE_FILEW           L"win9xupg.sfm"

//
// Shell folder temp dir
//

#define S_SHELL_TEMP_NORMALA        "user~tmp.@01"
#define S_SHELL_TEMP_NORMALW        L"user~tmp.@01"

#define S_SHELL_TEMP_LONGA          "user~tmp.@02"
#define S_SHELL_TEMP_LONGW          L"user~tmp.@02"

#define S_SHELL_TEMP_NORMAL_PATHA   "?:\\" S_SHELL_TEMP_NORMALA
#define S_SHELL_TEMP_NORMAL_PATHW   L"?:\\" S_SHELL_TEMP_NORMALW

#define S_SHELL_TEMP_LONG_PATHA     "?:\\" S_SHELL_TEMP_LONGA
#define S_SHELL_TEMP_LONG_PATHW     L"?:\\" S_SHELL_TEMP_LONGW

#ifdef UNICODE
#define S_SHELL_TEMP_NORMAL         S_SHELL_TEMP_NORMALW
#define S_SHELL_TEMP_LONG           S_SHELL_TEMP_LONGW
#define S_SHELL_TEMP_NORMAL_PATH    S_SHELL_TEMP_NORMAL_PATHW
#define S_SHELL_TEMP_LONG_PATH      S_SHELL_TEMP_LONG_PATHW
#else
#define S_SHELL_TEMP_NORMAL         S_SHELL_TEMP_NORMALA
#define S_SHELL_TEMP_LONG           S_SHELL_TEMP_LONGA
#define S_SHELL_TEMP_NORMAL_PATH    S_SHELL_TEMP_NORMAL_PATHA
#define S_SHELL_TEMP_LONG_PATH      S_SHELL_TEMP_LONG_PATHA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\svrapi.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1995-1996          **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession, NetShare and     *
 *  NetSecurity APIs.                                               *
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 *      Description of level of Win95 peer server support           *
 *
 *  For background information refer to the Lan Manager Programmer's
 *  Reference.
 *
 *  WARNING:
 *      The APIs documented herein are not guaranteed to be supported
 * in future versions of Windows. Their primary purpose is to       *
 * administer Win95 peer servers.                                   *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 *
 *      User names, computer names and share names should be
 *      upper-cased by the caller and drawn from the ANSI 
 *      character set.
 * 
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *
 * 	Requires User level security to be enabled
 *                                                              *
 *	Peer Server Support:
 *      Remote support of these APIs on NWSERVER is limited as
 *      described below:
 *
 *		NetAccessAdd -
 *				local and remote VSERVER - level 2
 *              remote NWSERVER -          level 2
 *	    NetAccessCheck - local only
 *      NetAccessDel - 
 *              local, remote NWSERVER and remote VSERVER
 *      NetAccessEnum -
 *              sLevel 0 on remote NWSERVER (fRecursive = 1),
 *              slevel 0, 1, 2 on local and remote VSERVER
 *		NetAccessGetInfo -
 *               all sLevels on local and remote VSERVER,
 *      		 sLevel 0, 12 on remote NWSERVER
 *      NetAccessSetInfo - 
 *              sLevel 1, 12 on local and remote VSERVER,
 *              sLevel 12 on remote NWSERVER
 *              parmnum = PARMNUM_ALL only
 *      NetAccessGetUserPerms - local and remote VSERVER only
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */
             
struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */
             
struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2 
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12 
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
#define         ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM|ACCESS_FINDFIRST)
/*INC*/
#define         ACCESS_READ     0x1
#define         ACCESS_WRITE    0x2
#define         ACCESS_CREATE   0x4
#define         ACCESS_EXEC     0x8
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 *	Peer Server Support
 * 		NetShareAdd() - sLevel 50 on VSERVER and NWSERVER
 * 		NetShareDel() - VSERVER and NWSERVER
 *		NetShareEnum() - sLevel 1,50 on VSERVER; 50 on NWSERVER
 *      NetShareGetInfo() - sLevel 50 on VSERVER, NWSERVER
 * 		NetShareSetInfo() - sLevel 50, sParmNum PARMNUM_ALL
 *						 on VSERVER, NWSERVER
 ****************************************************************/

/***	NetShareAdd - add a new share to the server tables
 *
 *	NetShareAdd( servername, level, buf, buflen )
 *
 *	ENTRY:	servername - asciz string containing name of server
 *                       or NULL if local
 *		level- Must be 50 for Win95 peer servers.
 *		buf - far ptr to struct share_info
 *		buflen - unsigned int length of buffer
 *
 *	EXIT:	0 = success
 *		ERROR_INVALID_LEVEL
 *      ERROR_BAD_NETPATH
 *		ERROR_INVALID_PARAMETER
 *		NERR_UnknownDevDir
 *		NERR_ShareExists
 *		NERR_UnknownServer
 *		NERR_ServerNotStarted
 *		NERR_RedirectedPath
 *		NERR_DuplicateShare
 *		NERR_BufTooSmall
 *		ERROR_NOT_ENOUGH_MEMORY
 *
 */
extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

/***	NetShareDel (Admin only)
 *
 *	API_FUNCTION NetShareDel( servername, netname, reserved )
 *
 *	ENTRY
 *
 *	char FAR *  servername;     asciz remote srv name, NULL if local
 *	char FAR *  netname;        asciz network name of share being deleted
 *	unsigned short reserved;    MBZ
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_PARAMETER
 *
 *
 *	Note:  Deleting a share will also delete any existing connections
 *		to the shared resource, and close open files within the
 *		connections.
 */
extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

/* 2.1  NetShareEnum
 *
 * API_FUNCTION
 * NetShareEnum( servername, level, buf, buflen, entriesread, totalentries )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * short               sLevel;         level of detail requested; 1 or 50
 * char FAR *          pbBuffer;       buffer to return entries in
 * unsigned short      cbBuffer;       size of buffer on call
 * unsigned short FAR *pcEntriesRead;  # of entries supplied on return
 * unsigned short FAR *pcTotalAvail ;  total # of entries available
 *
 * Supply information about existing shares at specified level.
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct share_info_1".
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  ERROR_MORE_DATA
 */
extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

/* 2.2  NetShareGetInfo
 *
 * Purpose: Read complete information about a single outstanding share.
 *
 * API_FUNCTION
 * NetShareGetInfo( servername, netname, level, buf, buflen, totalavail )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * char FAR *          netname;        asciz network name of share being queried
 * short               level;          level of info requested (50 for Win95 peer servers)
 * char FAR *          buf;            for returned entry
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response:
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_INVALID_PARAMETER
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  NERR_NetNameNotFound
 *  NERR_MoreData
 *  NERR_BufTooSmall
 */
extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

/***	NetShareSetInfo (Admin only)
 *
 *	API_FUNCTION NetShareSetInfo( servername,
 *					netname,
 *					level,
 *					buf,
 *					buflen,
 *					parmnum )
 *					
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	netname;        asciz network name of share being set
 *	level;		level of info provided (50 for Win95 peer servers)
 *	buf;            contents described below
 *	buflen;         size of buffer
 *	parmnum;        must be PARMNUM_ALL for Win95 peer servers
 *
 *	Buffer contents on call if parmnum is zero:
 *   	    Level 50 contains a "struct share_info_50".
 *
 *	Settable fields are:
 *          shi_remark
 *          shi_passwd
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_LEVEL
 * 	NERR_BufTooSmall
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 *	ERROR_INVALID_PARAMETER
 ***/
extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write password (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

/* The share is restored on system startup */
#define	SHI50F_PERSIST		0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#ifndef PARMNUM_ALL
#define PARMNUM_ALL				0
#endif

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types .
 *  
 *  STYPE_DISKTREE and STYPE_PRINTQ are recognized on peer servers
 */

#define STYPE_DISKTREE 			0       /* disk share */
#define STYPE_PRINTQ   			1       /* printer share */
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *
 *	Peer Server Support                                         *
 *  	NetSessionDel() - NWSERVER and VSERVER 					*
 *	    NetSessionEnum() - sLevel 50 on NWSERVER and VSERVER    *
 *		NetSessionGetInfo() - not supported on peer servers     *
 ****************************************************************/

/***	NetSessionDel (Admin only)
 *
 *
 *	API_FUNCTION NetSessionDel( servername, clientname, reserved )
 *
 *	ENTRY
 *
 * 	servername;     asciz remote srv name, NULL if local
 *	clientname;     asciz remote computer name (returned by NetSessionEnum)
 *                               	of session being deleted
 *                  In the case of a Win95 NWSERVER, the clientname should be the
 *                  ascii connection number
 *	reserved;       session key returned by NetSessionEnum
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly
 * 	ERROR_ACCESS_DENIED
 *	NERR_BufTooSmall
 *	NERR_ClientNameNotFound
 *
 ***/
extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

/***	NetSessionEnum
 *
 *	API_FUNCTION NetSessionEnum( servername,
 *				       level,
 *				       buf,
 *				       buflen,
 *				       entriesread,
 *				       totalentries )
 *	ENTRY
 *				
 *	servername;     asciz remote srv name, NULL if local
 * 	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call;
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *  ERROR_BAD_NETPATH
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	Buffer contains an array of session_info structures.
 *
 ***/
extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );


extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;            //remote computer name (connection id in Netware)
	char FAR * sesi50_username;
	unsigned long sesi50_key;           // used to delete session (not used in Netware)
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;    //not available in Netware
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;		//not available in Netware
	unsigned char sesi50_protocol;
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 *  Peer Server Support
 * 		NetConnectionEnum -
 *               sLevel 50 on VSERVER and NWSERVER              *
 *               On NWSERVER, this API doesnt provide more      *
 *               information than NetSessionEnum
 ****************************************************************/

/***	NetConnectionEnum (Admin only)
 *
 *	API_FUNCTION NetConnectionEnum( servername, 
 *					  qualifier, 
 *					  level, 
 *					  buf, 
 *					  buflen, 
 *					  totalavail )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	qualifier;      netname or client computer name.
 *                  computer name should be prefaced by '\\'.
 *	level;	    	level of info requested
 *	buf;            for returned entry
 *	buflen;         size of buffer 
 *	totalavail;     total size needed for buffer
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly		(DOS)
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *	NERR_ClientNameNotFound
 *	NERR_NetNameNotFound
 *
 *	Buffer contents on response (format for a single entry):
 *   	    Level 50 contains a "struct connection_info_50".
 ***/
extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,   /* upper case */
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;         // share type
	unsigned short coni50_num_opens;	//not used in Netware
	unsigned long coni50_time;
	char FAR * coni50_netname;          // share name          
	char FAR * coni50_username;         // user connected to share
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 *  Peer Server Support
 * 		NetFileEnum - sLevel 50 on VSERVER and NWSERVER        *
 *      NetFileClose2 - VSERVER only
 ****************************************************************/

/***	NetFileClose2
 *
 *	int FAR PASCAL	NetFileClose2( servername, fileid )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	fileid;     	file id supplied by NetFileEnum
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_RemoteErr
 * 	ERROR_ACCESS_DENIED
 *	NERR_FileIdNotFound
 *
 ***/
extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

/***	NetFileEnum (Admin Only)
 *
 *	int FAR PASCAL NetFileEnum( servername,
 *				    level, 
 *				    buf, 
 *				    buflen, 
 *				    entriesread, 
 *				    totalentries )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	basepath;	path qualifier for file matching
 *              (not used for Win95 NWSERVER)
 *	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call; 
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_RemoteOnly
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	
 *	Buffer contents on response (format for a single entry):
 *   	    Level 0 contains a "struct file_info_0".
 *   	    Level 50 contains a "struct file_info_50".
 *
 ***/

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;              // not used on NWSERVER
	unsigned short fi50_permissions;    // not available on NWSERVER
	unsigned short fi50_num_locks;      // not available on NWSERVER
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 * Peer Server Support
 * 	NetServerGetInfo - sLevel 1,50 on NWSERVER, VSERVER
 ****************************************************************/

/* 6.2  NetServerGetInfo 
 *
 * Purpose: Read the current configuration parameters of the server.
 *
 * int FAR PASCAL
 * NetServerGetInfo( servername, level, buf, buflen, totalavail )
 * char FAR *          servername;   asciz remote server name or NULL if local
 * short               level;          level of information to be returned
 * char FAR *          buf;            for returned data
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct server_info_1".
 *     Level 50 contains a "struct server_info_50".
 *
 * If the buflen is not large enough for all of the information, the call
 * will return as much as will fit in the buffer.
 *
 * Returns 0 if successful. Error return information:
 *
 *     - ERROR_INVALID_LEVEL       - Level parameter specified is invalid
 *     - ERROR_INVALID_PARAMETER   - An invalid input parameter was detected.
 *     - NERR_NetNotStarted        - Network not installed on local machine
 *     - NERR_ServerNotStarted     - Server is not started
 *     - NERR_BufTooSmall          - The buffer supplied was to small to
 *                                   return the fixed length structure
 *				     requested.
 *     - NERR_MoreData             - The buffer supplied was too small to
 *				     return all the information available
 *				     for this server.
 *
 */


extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080      /* This flag is also set by Win95 NWSERVER */
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 *  For Win95 NWSERVER, the only possible returned value is SV_SECURITY_NETWARE.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\unicode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unicode.h

Abstract:

    Declares the interfaces for unicode/ansi conversion.

    When specific conversion is needed, use:

        unicode = ConvertAtoW (ansi) / FreeConvertedStr (unicode)
        ansi = ConvertWtoA (unicode) / FreeConvertedStr (ansi)

        KnownSizeAtoW (unicode,ansi)
        KnownSizeWtoA (ansi,unicode)

    When TCHAR conversion is needed, use:

        ansi = CreateDbcs (tchar) / DestroyDbcs (ansi)
        unicode = CreateUnicode (tchar) / DestroyUnicode (unicode)
        tchar = ConvertAtoT (ansi) / FreeAtoT (tchar)
        tchar = ConvertWtoT (ansi) / FreeWtoT (tchar)

Author:

    Jim Schmidt (jimschm)   02-Sep-1997

Revision History:

    jimschm 15-Feb-1999     Eliminated AnsiFromUnicode and UnicodeFromAnsi
    calinn  07-Jul-1998     SetGlobalPage/GetGlobalPage
    mikeco  03-Nov-1997     AnsiFromUnicode/UnicodeFromAnsi

--*/

#pragma once

extern WORD g_GlobalCodePage;

#define OurGetACP() (g_GlobalCodePage)

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    );


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    );


#define INVALID_CHAR_COUNT      0xffffffff

//
// Explicit conversions, pool-based, unlimited size
//

PCSTR
RealUnicodeToDbcsN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    );

PCWSTR
RealDbcsToUnicodeN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    );

#define UnicodeToDbcsN(p,s,c)       SETTRACKCOMMENT(PCSTR,"UnicodeToDbcsN",__FILE__,__LINE__)\
                                    RealUnicodeToDbcsN(p,s,c)\
                                    CLRTRACKCOMMENT

#define DbcsToUnicodeN(p,s,c)       SETTRACKCOMMENT(PCWSTR,"DbcsToUnicodeN",__FILE__,__LINE__)\
                                    RealDbcsToUnicodeN(p,s,c)\
                                    CLRTRACKCOMMENT

#define UnicodeToDbcs(pool,str) UnicodeToDbcsN(pool,str,wcslen(str))
#define DbcsToUnicode(pool,str) DbcsToUnicodeN(pool,str,CharCountA(str))

#define ConvertWtoA(unicode_str) UnicodeToDbcsN(NULL,unicode_str,wcslen(unicode_str))
#define ConvertAtoW(dbcs_str) DbcsToUnicodeN(NULL,dbcs_str,CharCountA(dbcs_str))

VOID
FreeConvertedPoolStr (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    );

#define FreeConvertedStr(str) FreeConvertedPoolStr(NULL,(PVOID)(str))

//
// In-place explicit conversions, caller handles buffer sizing
//

PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD CharCount
    );

PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD CharCount
    );

#define KnownSizeUnicodeToDbcs(out,in)      KnownSizeUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define KnownSizeDbcsToUnicode(out,in)      KnownSizeDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define KnownSizeWtoA                       KnownSizeUnicodeToDbcs
#define KnownSizeAtoW                       KnownSizeDbcsToUnicode

PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    );

PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    );

#define DirectUnicodeToDbcs(out,in)         DirectUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define DirectDbcsToUnicode(out,in)         DirectDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define DirectWtoA                          DirectUnicodeToDbcs
#define DirectAtoW                          DirectDbcsToUnicode




//
// TCHAR conversions -- do not call A & W versions directly
//

#define CreateDbcsW(unicode_str)            ConvertWtoA(unicode_str)
#define DestroyDbcsW(unicode_str)           FreeConvertedStr(unicode_str)
#define CreateUnicodeW(unicode_str)         (unicode_str)
#define DestroyUnicodeW(unicode_str)
#define CreateDbcsA(dbcs_str)               (dbcs_str)
#define DestroyDbcsA(dbcs_str)
#define CreateUnicodeA(dbcs_str)            ConvertAtoW(dbcs_str)
#define DestroyUnicodeA(dbcs_str)           FreeConvertedStr(dbcs_str)

#ifdef UNICODE

#define CreateDbcs          CreateDbcsW
#define CreateUnicode       CreateUnicodeW
#define DestroyDbcs         DestroyDbcsW
#define DestroyUnicode      DestroyUnicodeW
#define ConvertAtoT         ConvertAtoW
#define ConvertWtoT(x)      (x)
#define FreeAtoT            FreeConvertedStr
#define FreeWtoT(x)

#define KnownSizeAtoT           KnownSizeAtoW
#define KnownSizeWtoT(out,in)   (in)

#define DirectAtoT              DirectAtoW
#define DirectWtoT(out,in)      (in)

#else

#define CreateDbcs          CreateDbcsA
#define CreateUnicode       CreateUnicodeA
#define DestroyDbcs         DestroyDbcsA
#define DestroyUnicode      DestroyUnicodeA
#define ConvertAtoT(x)      (x)
#define ConvertWtoT         ConvertWtoA
#define FreeAtoT(x)
#define FreeWtoT            FreeConvertedStr

#define KnownSizeAtoT(out,in)   (in)
#define KnownSizeWtoT           KnownSizeWtoA

#define DirectAtoT(out,in)      (in)
#define DirectWtoT              DirectWtoA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\strings.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Declares the string utilities implemented in common\migutil.

Author:

    Several

Revision History:

    See SLM log

--*/

#include <mbstring.h>
#include <wchar.h>

typedef PVOID POOLHANDLE;

#pragma once

#define MAX_ENCODED_RULE   (256*6)


//
// String sizing routines and unit conversion
//

#define CharCountA      _mbslen
#define CharCountW      wcslen

__inline
PSTR
CharCountToPointerA (
    PCSTR String,
    UINT Char
    )
{
    while (Char > 0) {
        MYASSERT (*String != 0);
        Char--;
        String = (PCSTR) _mbsinc ((const unsigned char *) String);
    }

    return (PSTR) String;
}

__inline
PWSTR
CharCountToPointerW (
    PCWSTR String,
    UINT Char
    )
{
#ifdef DEBUG
    UINT u;
    for (u = 0 ; u < Char ; u++) {
        MYASSERT (String[u] != 0);
    }
#endif

    return (PWSTR) (&String[Char]);
}


__inline
UINT
CharCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
    register UINT Count;

    Count = 0;
    while (Start < EndPlusOne) {
        MYASSERT (*Start != 0);
        Count++;
        Start = (PCSTR) _mbsinc ((const unsigned char *) Start);
    }

    return Count;
}

__inline
UINT
CharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}


__inline
UINT
CharCountInByteRangeA (
    IN      PCSTR Start,
    IN      UINT Bytes
    )
{
    register UINT Count;
    PCSTR EndPlusOne = (PCSTR) ((PBYTE) Start + Bytes);

    Count = 0;
    while (Start < EndPlusOne) {
        Count++;
        Start = (PCSTR) _mbsinc ((const unsigned char *) Start);
    }

    return Count;
}

__inline
UINT
CharCountInByteRangeW (
    IN      PCWSTR Start,
    IN      UINT Bytes
    )
{
    PCWSTR EndPlusOne = (PCWSTR) ((PBYTE) Start + Bytes);

    if (Start < EndPlusOne) {
        return (EndPlusOne - Start);
    }

    MYASSERT (FALSE);
    return 0;
}

__inline
UINT
CharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT CharCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = CharCountToPointerA (Start, CharCount);
    return EndPlusOne - Start;
}

__inline
UINT
CharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount * sizeof (WCHAR);
}

#define CharCountToTcharsA   CharCountToBytesA

__inline
UINT
CharCountToTcharsW (
    IN      PCWSTR Start,
    IN      UINT CharCount
    )
{
    return CharCount;
}


#define ByteCountA          strlen
#define ByteCountW(x)       (wcslen(x)*sizeof(WCHAR))

#define SizeOfStringA(str)  (ByteCountA(str) + sizeof (CHAR))
#define SizeOfStringW(str)  (ByteCountW(str) + sizeof (WCHAR))

__inline
PSTR
ByteCountToPointerA (
    PCSTR String,
    UINT BytePos
    )
{
    return (PSTR)((PBYTE) String + BytePos);
}

__inline
PWSTR
ByteCountToPointerW (
    PCWSTR String,
    UINT BytePos
    )
{
    return (PWSTR)((PBYTE) String + BytePos);
}


__inline
UINT
ByteCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCSTR p;
    for (p = Start ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

__inline
UINT
ByteCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) * sizeof (WCHAR) : 0;
}

__inline
UINT
ByteCountToCharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = Start + ByteCount;
    return CharCountABA (Start, EndPlusOne);
}

__inline
UINT
ByteCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = (PCWSTR) ((PBYTE) Start + ByteCount);

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount / sizeof (WCHAR);
}

__inline
UINT
ByteCountToTcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + ByteCount;

    for (p = Start ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount;
}

#define ByteCountToTcharsW  ByteCountToCharsW


#define TcharCountA     strlen
#define TcharCountW     wcslen

__inline
PSTR
TcharCountToPointerA (
    PCSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return (PSTR) (String + Tchars);
}

__inline
PWSTR
TcharCountToPointerW (
    PCWSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return (PWSTR) (String + Tchars);
}


#define TcharCountABA       ByteCountABA

__inline
UINT
TcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

#define TcharCountToCharsA      ByteCountToCharsA

__inline
UINT
TcharCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars * sizeof (WCHAR);
}


#define StackStringCopyA(stackbuf,src)                  _mbssafecpy(stackbuf,src,sizeof(stackbuf))
#define StackStringCopyW(stackbuf,src)                  _wcssafecpy(stackbuf,src,sizeof(stackbuf))


//
// String comparison routines
//

#define StringCompareA                                  _mbscmp
#define StringCompareW                                  wcscmp

#define StringMatchA(str1,str2)                         (_mbscmp(str1,str2)==0)
#define StringMatchW(str1,str2)                         (wcscmp(str1,str2)==0)

#define StringICompareA                                 _mbsicmp
#define StringICompareW                                 _wcsicmp

#define StringIMatchA(str1,str2)                        (_mbsicmp(str1,str2)==0)
#define StringIMatchW(str1,str2)                        (_wcsicmp(str1,str2)==0)

#define StringCompareByteCountA(str1,str2,bytes)        _mbsncmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringCompareByteCountW(str1,str2,bytes)        wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringMatchByteCountA(str1,str2,bytes)          (strncmp(str1,str2,bytes)==0)
#define StringMatchByteCountW(str1,str2,bytes)          (wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringICompareByteCountA(str1,str2,bytes)       _mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))
#define StringICompareByteCountW(str1,str2,bytes)       _wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringIMatchByteCountA(str1,str2,bytes)         (_mbsnicmp(str1,str2,ByteCountToCharsA(str1,bytes))==0)
#define StringIMatchByteCountW(str1,str2,bytes)         (_wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringCompareCharCountA(str1,str2,chars)        _mbsncmp(str1,str2,chars)
#define StringCompareCharCountW(str1,str2,chars)        wcsncmp(str1,str2,chars)

#define StringMatchCharCountA(str1,str2,chars)          (_mbsncmp(str1,str2,chars)==0)
#define StringMatchCharCountW(str1,str2,chars)          (wcsncmp(str1,str2,chars)==0)

#define StringICompareCharCountA(str1,str2,chars)       _mbsnicmp(str1,str2,chars)
#define StringICompareCharCountW(str1,str2,chars)       _wcsnicmp(str1,str2,chars)

#define StringIMatchCharCountA(str1,str2,chars)         (_mbsnicmp(str1,str2,chars)==0)
#define StringIMatchCharCountW(str1,str2,chars)         (_wcsnicmp(str1,str2,chars)==0)

#define StringCompareTcharCountA(str1,str2,tchars)      _mbsncmp(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringCompareTcharCountW(str1,str2,tchars)      wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringMatchTcharCountA(str1,str2,tchars)        (strncmp(str1,str2,tchars)==0)
#define StringMatchTcharCountW(str1,str2,tchars)        (wcsncmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)

#define StringICompareTcharCountA(str1,str2,tchars)     _mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))
#define StringICompareTcharCountW(str1,str2,tchars)     _wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))

#define StringIMatchTcharCountA(str1,str2,tchars)       (_mbsnicmp(str1,str2,TcharCountToCharsA(str1,tchars))==0)
#define StringIMatchTcharCountW(str1,str2,tchars)       (_wcsnicmp(str1,str2,TcharCountToCharsW(str1,tchars))==0)


INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

#define StringMatchABA(String,Start,End)                (StringCompareABA(String,Start,End)==0)
#define StringMatchABW(String,Start,End)                (StringCompareABW(String,Start,End)==0)


// stricmp that takes an end pointer instead of a length
INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PWSTR
our_lstrcpynW (
    OUT     PWSTR Dest,
    IN      PCWSTR Src,
    IN      INT NumChars
    );


#define StringIMatchABA(String,Start,End)               (StringICompareABA(String,Start,End)==0)
#define StringIMatchABW(String,Start,End)               (StringICompareABW(String,Start,End)==0)



//
// String copy routines
//

#define StringCopyA             _mbscpy
#define StringCopyW             wcscpy

// bytes
#define StringCopyByteCountA(str1,str2,bytes)        lstrcpynA(str1,str2,bytes)
#define StringCopyByteCountW(str1,str2,bytes)        our_lstrcpynW(str1,str2,(bytes)/sizeof(WCHAR))

// logical characters (IMPORTANT: logical chars != TcharCount)
#define StringCopyCharCountA(str1,str2,mbchars)      lstrcpynA(str1,str2,CharCountToBytesA(str2,mbchars))
#define StringCopyCharCountW(str1,str2,wchars)       our_lstrcpynW(str1,str2,wchars)

// CHARs (A version) or WCHARs (W version)
#define StringCopyTcharCountA(str1,str2,tchars)      lstrcpynA(str1,str2,tchars)
#define StringCopyTcharCountW(str1,str2,tchars)      our_lstrcpynW(str1,str2,tchars)

#define StringCopyABA(dest,stra,strb)                StringCopyByteCountA((dest),(stra),((PBYTE)(strb)-(PBYTE)(stra)+(INT)sizeof(CHAR)))
#define StringCopyABW(dest,stra,strb)                StringCopyByteCountW((dest),(stra),((PBYTE)(strb)-(PBYTE)(stra)+(INT)sizeof(WCHAR)))

//
// String cat routines
//

#define StringCatA              _mbsappend
#define StringCatW              _wcsappend

//
// Character search routines
//

#define GetEndOfStringA(s)      strchr(s,0)
#define GetEndOfStringW(s)      wcschr(s,0)

__inline
UINT
SizeOfMultiSzA (
    PCSTR MultiSz
    )
{
    PCSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringA (MultiSz) + 1;
    }

    MultiSz++;

    return (PBYTE) MultiSz - (PBYTE) Base;
}


__inline
UINT
SizeOfMultiSzW (
    PCWSTR MultiSz
    )
{
    PCWSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringW (MultiSz) + 1;
    }

    MultiSz++;

    return (PBYTE) MultiSz - (PBYTE) Base;
}


__inline
UINT
MultiSzSizeInCharsA (
    PCSTR MultiSz
    )
{
    UINT Chars = 0;

    while (*MultiSz) {

        do {
            Chars++;
            MultiSz = (PCSTR) _mbsinc ((const unsigned char *) MultiSz);
        } while (*MultiSz);

        Chars++;
        MultiSz++;
    }

    Chars++;

    return Chars;
}


#define MultiSzSizeInCharsW(msz)  (SizeOfMultiSzW(msz)/sizeof(WCHAR))

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      CHARTYPE SearchChar
    );

PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    );

//
// Pool allocation routines
//

PSTR
RealAllocTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      UINT ByteSize
    );

PWSTR
RealAllocTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      UINT WcharSize
    );

#define AllocTextExA(p,s)   SETTRACKCOMMENT(PSTR,"AllocTextExA",__FILE__,__LINE__)\
                            RealAllocTextExA(p,s)\
                            CLRTRACKCOMMENT

#define AllocTextExW(p,s)   SETTRACKCOMMENT(PWSTR,"AllocTextExW",__FILE__,__LINE__)\
                            RealAllocTextExW(p,s)\
                            CLRTRACKCOMMENT

#define AllocTextA(s)       AllocTextExA(NULL,(s))
#define AllocTextW(s)       AllocTextExW(NULL,(s))



VOID
FreeTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    );

VOID
FreeTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    );

#define FreeTextA(t)    FreeTextExA(NULL,t)
#define FreeTextW(t)    FreeTextExW(NULL,t)

PSTR
RealDuplicateTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    );

PWSTR
RealDuplicateTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    );

#define DuplicateTextExA(p,t,c,n)   SETTRACKCOMMENT(PSTR,"DuplicateTextExA",__FILE__,__LINE__)\
                                    RealDuplicateTextExA(p,t,c,n)\
                                    CLRTRACKCOMMENT

#define DuplicateTextExW(p,t,c,n)   SETTRACKCOMMENT(PWSTR,"DuplicateTextExW",__FILE__,__LINE__)\
                                    RealDuplicateTextExW(p,t,c,n)\
                                    CLRTRACKCOMMENT

#define DuplicateTextA(text) DuplicateTextExA(NULL,text,0,NULL)
#define DuplicateTextW(text) DuplicateTextExW(NULL,text,0,NULL)

PSTR
RealJoinTextExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR DelimeterString,  OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    );

PWSTR
RealJoinTextExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    );

#define JoinTextExA(p,s1,s2,cs,ec,nc)   SETTRACKCOMMENT(PSTR,"JoinTextExA",__FILE__,__LINE__)\
                                        RealJoinTextExA(p,s1,s2,cs,ec,nc)\
                                        CLRTRACKCOMMENT

#define JoinTextExW(p,s1,s2,cs,ec,nc)   SETTRACKCOMMENT(PWSTR,"JoinTextExW",__FILE__,__LINE__)\
                                        RealJoinTextExW(p,s1,s2,cs,ec,nc)\
                                        CLRTRACKCOMMENT

#define JoinTextA(str1,str2) JoinTextExA(NULL,str1,str2,NULL,0,NULL)
#define JoinTextW(str1,str2) JoinTextExW(NULL,str1,str2,NULL,0,NULL)


PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR   InString,
    IN PCSTR * ExtraEnvironmentVariables OPTIONAL
    );

PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR   InString,
    IN PCWSTR * ExtraEnvironmentVariables OPTIONAL
    );

#define ExpandEnvironmentTextExA(str,ev)    SETTRACKCOMMENT(PSTR,"ExpandEnvironmentTextExA",__FILE__,__LINE__)\
                                            RealExpandEnvironmentTextExA(str,ev)\
                                            CLRTRACKCOMMENT

#define ExpandEnvironmentTextExW(str,ev)    SETTRACKCOMMENT(PWSTR,"ExpandEnvironmentTextExW",__FILE__,__LINE__)\
                                            RealExpandEnvironmentTextExW(str,ev)\
                                            CLRTRACKCOMMENT

#define ExpandEnvironmentTextA(string) ExpandEnvironmentTextExA(string,NULL)
#define ExpandEnvironmentTextW(string) ExpandEnvironmentTextExW(string,NULL)

//
// Function wraps IsDBCSLeadByte(), which tests ACP. Do not use
// isleadbyte().
//
#define IsLeadByte(b)   IsDBCSLeadByte(b)

//
// Command line routines
//

// Converts ANSI command line to array of args
PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     INT *NumArgs
    );


//
// Need both MBCS and UNICODE versions
//

// an atoi that supports decimal or hex
DWORD   _mbsnum (IN PCSTR szNum);
DWORD   _wcsnum (IN PCWSTR szNum);

// a strcat that returns a pointer to the end of the string
PSTR   _mbsappend (OUT PSTR szDest, IN PCSTR szSrc);
PWSTR  _wcsappend (OUT PWSTR szDest, IN PCWSTR szSrc);

// determines if an entire string is printable chars
int     _mbsisprint (PCSTR szStr);
int     _wcsisprint (PCWSTR szStr);

// case-insensitive strstr
PCSTR  _mbsistr (PCSTR szStr, PCSTR szSubStr);
PCWSTR _wcsistr (PCWSTR szStr, PCWSTR szSubStr);

// copies the first character of str2 to str
void    _copymbchar (PSTR str1, PCSTR str2);
#define _copywchar(dest,src)    (*(dest)=*(src))

// replaces a character in a multi-byte char string and maintains
// the string integrity (may grow string by one byte)
void    _setmbchar  (PSTR str, MBCHAR c);
#define _setwchar(str,c)        (*(str)=(c))

// removes specified character from the end of a string, if it exists
BOOL    _mbsctrim (PSTR str, MBCHAR c);
BOOL    _wcsctrim (PWSTR str, WCHAR c);

// Always adds a backslash, returns ptr to nul terminator
PSTR    AppendWackA (IN PSTR str);
PWSTR   AppendWackW (IN PWSTR str);

// Adds a backslash to the end of a DOS path (unless str is empty
// or is only a drive letter)
PSTR    AppendDosWackA (IN PSTR str);
PWSTR   AppendDosWackW (IN PWSTR str);

// Adds a backslash unless str is empty
PSTR    AppendUncWackA (IN PSTR str);
PWSTR   AppendUncWackW (IN PWSTR str);

// Adds a backslash and identifies the correct naming convention (DOS,
// or UNC)
PSTR    AppendPathWackA (IN PSTR str);
PWSTR   AppendPathWackW (IN PWSTR str);

// Joins two paths together, allocates string in g_PathsPool
PSTR
RealJoinPathsExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR PathA,
    IN      PCSTR PathB
    );

PWSTR
RealJoinPathsExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR PathA,
    IN      PCWSTR PathB
    );

#define JoinPathsExA(pool,p1,p2)    SETTRACKCOMMENT(PSTR,"JoinPathsA",__FILE__,__LINE__)\
                                    RealJoinPathsExA(pool,p1,p2)\
                                    CLRTRACKCOMMENT

#define JoinPathsExW(pool,p1,p2)    SETTRACKCOMMENT(PWSTR,"JoinPathsW",__FILE__,__LINE__)\
                                    RealJoinPathsExW(pool,p1,p2)\
                                    CLRTRACKCOMMENT

#define JoinPathsA(p1,p2)           JoinPathsExA(NULL,p1,p2)
#define JoinPathsW(p1,p2)           JoinPathsExW(NULL,p1,p2)


// Routine to allocate a 1K buffer for path manipulation, allocated in g_PathsPool
PSTR    RealAllocPathStringA (IN DWORD Chars);
PWSTR   RealAllocPathStringW (IN DWORD Chars);
#define DEFSIZE 0

#define AllocPathStringA(chars)     SETTRACKCOMMENT(PSTR,"AllocPathStringA",__FILE__,__LINE__)\
                                    RealAllocPathStringA(chars)\
                                    CLRTRACKCOMMENT

#define AllocPathStringW(chars)     SETTRACKCOMMENT(PWSTR,"AllocPathStringW",__FILE__,__LINE__)\
                                    RealAllocPathStringW(chars)\
                                    CLRTRACKCOMMENT

// Routine to divide path into separate strings, each allocated in g_PathsPool
VOID    RealSplitPathA (IN PCSTR Path, OUT PSTR *Drive, OUT PSTR *Dir, OUT PSTR *File, OUT PSTR *Ext);
VOID    RealSplitPathW (IN PCWSTR Path, OUT PWSTR *Drive, OUT PWSTR *Dir, OUT PWSTR *File, OUT PWSTR *Ext);

#define SplitPathA(path,dv,dir,f,e) SETTRACKCOMMENT_VOID ("SplitPathA",__FILE__,__LINE__)\
                                    RealSplitPathA(path,dv,dir,f,e)\
                                    CLRTRACKCOMMENT_VOID

#define SplitPathW(path,dv,dir,f,e) SETTRACKCOMMENT_VOID ("SplitPathW",__FILE__,__LINE__)\
                                    RealSplitPathW(path,dv,dir,f,e)\
                                    CLRTRACKCOMMENT_VOID

// Routine to extract the file from a path
PCSTR  GetFileNameFromPathA (IN PCSTR Path);
PCWSTR GetFileNameFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path
PCSTR  GetFileExtensionFromPathA (IN PCSTR Path);
PCWSTR GetFileExtensionFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path, including the dot, or the
// end of the string if no extension exists
PCSTR  GetDotExtensionFromPathA (IN PCSTR Path);
PCWSTR GetDotExtensionFromPathW (IN PCWSTR Path);

// Routine to duplicate a path and allocate space for cat processing
PSTR    RealDuplicatePathStringA (IN PCSTR Path, IN DWORD ExtraBytes);
PWSTR   RealDuplicatePathStringW (IN PCWSTR Path, IN DWORD ExtraBytes);

#define DuplicatePathStringA(path,eb)   SETTRACKCOMMENT(PSTR,"DuplicatePathStringA",__FILE__,__LINE__)\
                                        RealDuplicatePathStringA(path,eb)\
                                        CLRTRACKCOMMENT

#define DuplicatePathStringW(path,eb)   SETTRACKCOMMENT(PWSTR,"DuplicatePathStringW",__FILE__,__LINE__)\
                                        RealDuplicatePathStringW(path,eb)\
                                        CLRTRACKCOMMENT

// Routines to enumerate the PATH variable
typedef struct _PATH_ENUMA {
    PSTR  BufferPtr;
    PSTR  PtrNextPath;
    PSTR  PtrCurrPath;
} PATH_ENUMA, *PPATH_ENUMA;

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathA(e,a,w,s) EnumFirstPathExA(e,a,w,s,TRUE)

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    );

BOOL
EnumPathAbortA (
    IN OUT  PPATH_ENUMA PathEnum
    );



// Frees a string allocated in g_PathsPool
VOID
FreePathStringExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    );

VOID
FreePathStringExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    );

#define FreePathStringA(p) FreePathStringExA(NULL,p)
#define FreePathStringW(p) FreePathStringExW(NULL,p)

// Removes a trailing backslash, if it exists
#define RemoveWackAtEndA(str)  _mbsctrim(str,'\\')
#define RemoveWackAtEndW(str)  _wcsctrim(str,L'\\')

// Rule encoding functions used to encode a number of syntax-related
// characters (backslash, brackets, asterisk, etc)
PSTR   EncodeRuleCharsA (PSTR szEncRule, PCSTR szRule);
PWSTR  EncodeRuleCharsW (PWSTR szEncRule, PCWSTR szRule);

// Rule decoding functions used to restore an encoded string
MBCHAR  GetNextRuleCharA (PCSTR *p_szRule, BOOL *p_bFromHex);
WCHAR   GetNextRuleCharW (PCWSTR *p_szRule, BOOL *p_bFromHex);
PSTR   DecodeRuleCharsA (PSTR szRule, PCSTR szEncRule);
PWSTR  DecodeRuleCharsW (PWSTR szRule, PCWSTR szEncRule);
PSTR   DecodeRuleCharsABA (PSTR szRule, PCSTR szEncRuleStart, PCSTR End);
PWSTR  DecodeRuleCharsABW (PWSTR szRule, PCWSTR szEncRuleStart, PCWSTR End);

// Returns a pointer to the next non-space character (uses isspace)
PCSTR  SkipSpaceA (PCSTR szStr);
PCWSTR SkipSpaceW (PCWSTR szStr);

// Returns a pointer to the first space character at the end of a string,
// or a pointer to the terminating nul if no space exists at the end of the
// string.  (Used for trimming space.)
PCSTR  SkipSpaceRA (PCSTR szBaseStr, PCSTR szStr);
PCWSTR SkipSpaceRW (PCWSTR szBaseStr, PCWSTR szStr);

// Truncates a string after the last non-whitepace character
VOID TruncateTrailingSpaceA (IN OUT  PSTR Str);
VOID TruncateTrailingSpaceW (IN OUT  PWSTR Str);


// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchA (PCSTR wstrPattern, PCSTR wstrStr);
BOOL IsPatternMatchW (PCWSTR wstrPattern, PCWSTR wstrStr);

// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchABA (PCSTR Pattern, PCSTR Start, PCSTR End);
BOOL IsPatternMatchABW (PCWSTR Pattern, PCWSTR Start, PCWSTR End);

//
// More powerful pattern matching
//

#define SEGMENTTYPE_UNKNOWN         0
#define SEGMENTTYPE_EXACTMATCH      1
#define SEGMENTTYPE_OPTIONAL        2
#define SEGMENTTYPE_REQUIRED        3

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // optional
        struct {
            UINT MaxLen;                // zero if any length
            PCSTR IncludeSet;           OPTIONAL
            PCSTR ExcludeSet;           OPTIONAL
        } Wildcard;
    };
} SEGMENTA, *PSEGMENTA;

typedef struct {
    UINT SegmentCount;
    PSEGMENTA Segment;
} PATTERNPROPSA, *PPATTERNPROPSA;

typedef struct {
    UINT PatternCount;
    POOLHANDLE Pool;
    PPATTERNPROPSA Pattern;
} PARSEDPATTERNA, *PPARSEDPATTERNA;

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCWSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // wildcard
        struct {
            UINT MaxLen;                // zero if any length
            PCWSTR IncludeSet;          OPTIONAL
            PCWSTR ExcludeSet;          OPTIONAL
        } Wildcard;
    };
} SEGMENTW, *PSEGMENTW;

typedef struct {
    UINT SegmentCount;
    PSEGMENTW Segment;
} PATTERNPROPSW, *PPATTERNPROPSW;

typedef struct {
    UINT PatternCount;
    POOLHANDLE Pool;
    PPATTERNPROPSW Pattern;
} PARSEDPATTERNW, *PPARSEDPATTERNW;


BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    );

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    );

PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    );

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    );

BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    );

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    );

BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    );

VOID
PrintPattern (
    PCSTR Pattern,
    PPARSEDPATTERNA Struct
    );

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );





// Character counters
UINT CountInstancesOfCharA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharW (PCWSTR String, WCHAR Char);

UINT CountInstancesOfCharIA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharIW (PCWSTR String, WCHAR Char);


//
// Message Functions
//
// An AllocTable is an array of HLOCAL pointers that the message routines
// return.  This table is maintained to allow a single function to clean up
// all strings at once.
//
// All "Ex" functions (ParseMessageEx, GetStringResourceEx, and so on)
// require a valid AllocTable pointer.  A caller obtains this pointer by
// calling CreateAllocTable before processing any message.  The caller
// cleans up the entire table by calling DestroyAllocTable.
//
// A set of macros can be used for short-term strings.  ParseMessage and
// GetStringResource work the same as their Ex counterparts, but operate
// on the process-wide g_ShortTermAllocTable.  Short-term strings are
// freed with FreeStringResource.
//
// A routine that calls ParseMessage and/or GetStringResource several times
// in the same function wrap the calls between BeginMessageProcessing and
// EndMessageProcessing.  Only one thread in the process can do this at a
// time, and when EndMessageProcessing is called, all strings allocated
// by ParseMessage or GetResourceString in the processing section are
// automatically freed.
//

// AllocTable creation/deletion
PGROWBUFFER CreateAllocTable (VOID);
VOID DestroyAllocTable (PGROWBUFFER AllocTable);

// The "Ex" functions
// ParseMessageEx retrieves the string resource via FormatMessage
PCSTR ParseMessageExA (PGROWBUFFER AllocTable, PCSTR Template, PCSTR ArgArray[]);
PCWSTR ParseMessageExW (PGROWBUFFER AllocTable, PCWSTR Template, PCWSTR ArgArray[]);

// GetStringResourceEx retrives an argument-less string resource
PCSTR GetStringResourceExA (PGROWBUFFER AllocTable, UINT ID);
PCWSTR GetStringResourceExW (PGROWBUFFER AllocTable, UINT ID);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros
VOID FreeStringResourceExA (PGROWBUFFER AllocTable, PCSTR String);
VOID FreeStringResourceExW (PGROWBUFFER AllocTable, PCWSTR String);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros.
// Tests String first; nulls when freed.
VOID FreeStringResourcePtrExA (PGROWBUFFER AllocTable, PCSTR * String);
VOID FreeStringResourcePtrExW (PGROWBUFFER AllocTable, PCWSTR * String);

// Macros
extern PGROWBUFFER g_ShortTermAllocTable;
#define ParseMessageA(strid,args) ParseMessageExA(g_ShortTermAllocTable, strid, args)
#define ParseMessageW(strid,args) ParseMessageExW(g_ShortTermAllocTable, strid, args)
#define ParseMessageIDA(id,args) ParseMessageExA(g_ShortTermAllocTable, (PCSTR) (id), args)
#define ParseMessageIDW(id,args) ParseMessageExW(g_ShortTermAllocTable, (PCWSTR) (id), args)
#define ParseMessageIDExA(table,id,args) ParseMessageExA(table, (PCSTR) (id), args)
#define ParseMessageIDExW(table,id,args) ParseMessageExW(table, (PCWSTR) (id), args)
#define GetStringResourceA(id) GetStringResourceExA(g_ShortTermAllocTable, id)
#define GetStringResourceW(id) GetStringResourceExW(g_ShortTermAllocTable, id)
#define FreeStringResourceA(str) FreeStringResourceExA(g_ShortTermAllocTable, str)
#define FreeStringResourceW(str) FreeStringResourceExW(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrA(str) FreeStringResourcePtrExA(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrW(str) FreeStringResourcePtrExW(g_ShortTermAllocTable, str)

// Functions for single-threaded message-intensive processing loops
BOOL BeginMessageProcessing (VOID);
VOID EndMessageProcessing (VOID);


//
// The following message functions do not return strings, so they do not
// need cleanup.
//

// An odd variant--obtains message ID from a window's text and replaces
// it with the actual message.  Useful in dialog box initialization.
VOID ParseMessageInWndA (HWND hwnd, PCSTR ArgArray[]);
VOID ParseMessageInWndW (HWND hwnd, PCWSTR ArgArray[]);

// Displays a message box using a message string
INT ResourceMessageBoxA (HWND hwndOwner, UINT ID, UINT Flags, PCSTR ArgArray[]);
INT ResourceMessageBoxW (HWND hwndOwner, UINT ID, UINT Flags, PCWSTR ArgArray[]);


//
// Functions that don't care about UNICODE or MBCS
// and realy shouldn't be in strings.h/.c
//

// Pushes dwError on a global error stack
void    PushNewError (DWORD dwError);

// Pushes the return of GetLastError() on a global error stack
void    PushError (void);

// Pops the last error from the global error stack, calls SetLastError
// and returns the popped error code.
DWORD   PopError (void);

// Returns an int value for chars 0-9, a-f, A-F, and -1 for all others
int     GetHexDigit (IN  int c);


//
// Inline functions
//

// Returns the character at str[pos]
__inline MBCHAR _mbsgetc(PCSTR str, DWORD pos) {
    return (MBCHAR) _mbsnextc((const unsigned char *) CharCountToPointerA ((PSTR) str, pos));
}

__inline WCHAR _wcsgetc(PCWSTR str, DWORD pos) {
    return *CharCountToPointerW ((PWSTR) str, pos);
}

// Sets the character at str[pos]
// Multibyte version may grow string by one byte.
__inline void _mbssetc(PSTR str, DWORD pos, MBCHAR c) {
    _setmbchar (CharCountToPointerA (str, pos), c);
}

__inline void _wcssetc(PWSTR str, DWORD pos, WCHAR c) {
    *CharCountToPointerW (str, pos) = c;
}

// Bug fix for C Runtime _tcsdec
__inline PWSTR _wcsdec2(PCWSTR base, PCWSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PWSTR) (p-1);
}

// Bug fix for C Runtime _tcsdec
__inline PSTR _mbsdec2(PCSTR base, PCSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PSTR) _mbsdec((const unsigned char *) base, (const unsigned char *) p);
}


// A handy strncpy with forced termination
PSTR _mbsnzcpy (PSTR dest, PCSTR src, int count);
PWSTR _wcsnzcpy (PWSTR dest, PCWSTR src, int count);

// A handy strncpy used for buffer overrun containment
#define _mbssafecpy(dest,src,bufsize) _mbsnzcpy(dest,src,(bufsize)-sizeof(CHAR))
#define _wcssafecpy(dest,src,bufsize) _wcsnzcpy(dest,src,(bufsize)-sizeof(WCHAR))

// strcpyab with forced termination and termination guard
PSTR _mbsnzcpyab (PSTR Dest, PCSTR Start, PCSTR End, int count);
PWSTR _wcsnzcpyab (PWSTR Dest, PCWSTR Start, PCWSTR End, int count);

// A handy strncpyab used for buffer overrun containment
#define _mbssafecpyab(dest,start,end,bufsize) _mbsnzcpyab(dest,start,end,(bufsize)-sizeof(CHAR))
#define _wcssafecpyab(dest,start,end,bufsize) _wcsnzcpyab(dest,start,end,(bufsize)-sizeof(WCHAR))

// Routine that checks string for a prefix
#define StringPrefixA(str,prefix) StringMatchCharCountA(str,prefix,CharCountA(prefix))
#define StringIPrefixA(str,prefix) StringIMatchCharCountA(str,prefix,CharCountA(prefix))
#define StringPrefixW(str,prefix) StringMatchCharCountW(str,prefix,CharCountW(prefix))
#define StringIPrefixW(str,prefix) StringIMatchCharCountW(str,prefix,CharCountW(prefix))

//
// Sub String Replacement functions.
//
BOOL StringReplaceW (PWSTR Buffer,DWORD MaxSize,PWSTR ReplaceStartPos,PWSTR ReplaceEndPos,PCWSTR NewString);
BOOL StringReplaceA (PSTR Buffer,DWORD MaxSize,PSTR ReplaceStartPos,PSTR ReplaceEndPos,PCSTR NewString);

//
// String table population from INF section
//

typedef enum {
    CALLBACK_CONTINUE,
    CALLBACK_SKIP,
    CALLBACK_STOP
} CALLBACK_RESULT;

typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEA)(PCSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEW)(PCWSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef ADDINFSECTION_PROTOTYPEA * ADDINFSECTION_PROCA;
typedef ADDINFSECTION_PROTOTYPEW * ADDINFSECTION_PROCW;

#if 0
BOOL AddInfSectionToStringTableA (PVOID, HINF, PCSTR, INT, ADDINFSECTION_PROCA, PVOID);
BOOL AddInfSectionToStringTableW (PVOID, HINF, PCWSTR, INT, ADDINFSECTION_PROCW, PVOID);
#endif

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    );

PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    );

typedef struct _MULTISZ_ENUMA {
    PCSTR   Buffer;
    PCSTR   CurrentString;
} MULTISZ_ENUMA, *PMULTISZ_ENUMA;

typedef struct _MULTISZ_ENUMW {
    PCWSTR  Buffer;
    PCWSTR  CurrentString;
} MULTISZ_ENUMW, *PMULTISZ_ENUMW;

BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    );

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    );

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    );

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    );


VOID
ToggleWacksW (
    IN OUT PWSTR String,
    IN BOOL Operation
    );

VOID
ToggleWacksA (
    IN OUT PSTR String,
    IN BOOL Operation
    );


PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    );

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    );

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    );

//
// TCHAR mappings
//

#ifdef UNICODE

#define CharCount                   CharCountW
#define CharCountToPointer          CharCountToPointerW
#define CharCountAB                 CharCountABW
#define CharCountInByteRange        CharCountInByteRangeW
#define CharCountToBytes            CharCountToBytesW
#define CharCountToTchars           CharCountToTcharsW
#define ByteCount                   ByteCountW
#define SizeOfString                SizeOfStringW
#define SizeOfMultiSz               SizeOfMultiSzW
#define MultiSzSizeInChars          MultiSzSizeInCharsW
#define ByteCountToPointer          ByteCountToPointerW
#define ByteCountAB                 ByteCountABW
#define ByteCountToChars            ByteCountToCharsW
#define ByteCountToTchars           ByteCountToTcharsW
#define TcharCount                  TcharCountW
#define TcharCountToPointer         TcharCountToPointerW
#define TcharCountAB                TcharCountABW
#define TcharCountToChars           TcharCountToCharsW
#define TcharCountToBytes           TcharCountToBytesW
#define StackStringCopy             StackStringCopyW
#define StringCompare               StringCompareW
#define StringMatch                 StringMatchW
#define StringICompare              StringICompareW
#define StringIMatch                StringIMatchW
#define StringCompareByteCount      StringCompareByteCountW
#define StringMatchByteCount        StringMatchByteCountW
#define StringICompareByteCount     StringICompareByteCountW
#define StringIMatchByteCount       StringIMatchByteCountW
#define StringCompareCharCount      StringCompareCharCountW
#define StringMatchCharCount        StringMatchCharCountW
#define StringICompareCharCount     StringICompareCharCountW
#define StringIMatchCharCount       StringIMatchCharCountW
#define StringCompareTcharCount     StringCompareTcharCountW
#define StringMatchTcharCount       StringMatchTcharCountW
#define StringICompareTcharCount    StringICompareTcharCountW
#define StringIMatchTcharCount      StringIMatchTcharCountW
#define StringCompareAB             StringCompareABW
#define StringMatchAB               StringMatchABW
#define StringICompareAB            StringICompareABW
#define StringIMatchAB              StringIMatchABW
#define StringCopy                  StringCopyW
#define StringCopyByteCount         StringCopyByteCountW
#define StringCopyCharCount         StringCopyCharCountW
#define StringCopyTcharCount        StringCopyTcharCountW
#define StringCopyAB                StringCopyABW
#define StringCat                   StringCatW
#define GetEndOfString              GetEndOfStringW
#define GetPrevChar                 GetPrevCharW

#define AllocTextEx                 AllocTextExW
#define AllocText                   AllocTextW
#define FreeTextEx                  FreeTextExW
#define FreeText                    FreeTextW
#define DuplicateText               DuplicateTextW
#define DuplicateTextEx             DuplicateTextExW
#define JoinTextEx                  JoinTextExW
#define JoinText                    JoinTextW
#define ExpandEnvironmentText       ExpandEnvironmentTextW
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExW
#define CommandLineToArgv           CommandLineToArgvW

#define _tcsdec2                    _wcsdec2
#define _copytchar                  _copywchar
#define _settchar                   _setwchar
#define _tcsgetc                    _wcsgetc
#define _tcssetc                    _wcssetc
#define _tcsnum                     _wcsnum
#define _tcsappend                  _wcsappend
#define _tcsistr                    _wcsistr
#define _tcsisprint                 _wcsisprint
#define _tcsnzcpy                   _wcsnzcpy
#define _tcssafecpy                 _wcssafecpy
#define _tcsnzcpyab                 _wcsnzcpyab
#define _tcssafecpyab               _wcssafecpyab
#define StringPrefix                StringPrefixW
#define StringIPrefix               StringIPrefixW
#define _tcsctrim                   _wcsctrim

#define AppendWack                  AppendWackW
#define AppendDosWack               AppendDosWackW
#define AppendUncWack               AppendUncWackW
#define AppendPathWack              AppendPathWackW
#define RemoveWackAtEnd             RemoveWackAtEndW
#define JoinPathsEx                 JoinPathsExW
#define JoinPaths                   JoinPathsW
#define AllocPathString             AllocPathStringW
#define SplitPath                   SplitPathW
#define GetFileNameFromPath         GetFileNameFromPathW
#define GetFileExtensionFromPath    GetFileExtensionFromPathW
#define GetDotExtensionFromPath     GetDotExtensionFromPathW
#define DuplicatePathString         DuplicatePathStringW
#define FreePathStringEx            FreePathStringExW
#define FreePathString              FreePathStringW

#define GetNextRuleChar             GetNextRuleCharW
#define DecodeRuleChars             DecodeRuleCharsW
#define DecodeRuleCharsAB           DecodeRuleCharsABW
#define EncodeRuleChars             EncodeRuleCharsW

#define SkipSpace                   SkipSpaceW
#define SkipSpaceR                  SkipSpaceRW
#define TruncateTrailingSpace       TruncateTrailingSpaceW
#define IsPatternMatch              IsPatternMatchW
#define IsPatternMatchAB            IsPatternMatchABW

#define PPARSEDPATTERN              PPARSEDPATTERNW
#define PARSEDPATTERN               PARSEDPATTERNW
#define CreateParsedPattern         CreateParsedPatternW
#define IsPatternMatchEx            IsPatternMatchExW
#define TestParsedPattern           TestParsedPatternW
#define TestParsedPatternAB         TestParsedPatternABW
#define DestroyParsedPattern        DestroyParsedPatternW

#define CountInstancesOfChar        CountInstancesOfCharW
#define CountInstancesOfCharI       CountInstancesOfCharIW
#define StringReplace               StringReplaceW
#define CountInstancesOfSubString   CountInstancesOfSubStringW
#define StringSearchAndReplace      StringSearchAndReplaceW
#define MULTISZ_ENUM                MULTISZ_ENUMW
#define EnumFirstMultiSz            EnumFirstMultiSzW
#define EnumNextMultiSz             EnumNextMultiSzW

#define ParseMessage                ParseMessageW
#define ParseMessageEx              ParseMessageExW
#define ParseMessageID              ParseMessageIDW
#define ParseMessageIDEx            ParseMessageIDExW
#define GetStringResource           GetStringResourceW
#define GetStringResourceEx         GetStringResourceExW
#define FreeStringResource          FreeStringResourceW
#define ParseMessageInWnd           ParseMessageInWndW
#define ResourceMessageBox          ResourceMessageBoxW

#if 0
#define AddInfSectionToStringTable  AddInfSectionToStringTableW
#endif
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCW

#define ReplaceWacks(f)             ToggleWacksW(f,FALSE)
#define RestoreWacks(f)             ToggleWacksW(f,TRUE)

#define SanitizePath                SanitizePathW

#else

#define CharCount                   CharCountA
#define CharCountToPointer          CharCountToPointerA
#define CharCountAB                 CharCountABA
#define CharCountInByteRange        CharCountInByteRangeA
#define CharCountToBytes            CharCountToBytesA
#define CharCountToTchars           CharCountToTcharsA
#define ByteCount                   ByteCountA
#define SizeOfString                SizeOfStringA
#define SizeOfMultiSz               SizeOfMultiSzA
#define MultiSzSizeInChars          MultiSzSizeInCharsA
#define ByteCountToPointer          ByteCountToPointerA
#define ByteCountAB                 ByteCountABA
#define ByteCountToChars            ByteCountToCharsA
#define ByteCountToTchars           ByteCountToTcharsA
#define TcharCount                  TcharCountA
#define TcharCountToPointer         TcharCountToPointerA
#define TcharCountAB                TcharCountABA
#define TcharCountToChars           TcharCountToCharsA
#define TcharCountToBytes           TcharCountToBytesA
#define StackStringCopy             StackStringCopyA
#define StringCompare               StringCompareA
#define StringMatch                 StringMatchA
#define StringICompare              StringICompareA
#define StringIMatch                StringIMatchA
#define StringCompareByteCount      StringCompareByteCountA
#define StringMatchByteCount        StringMatchByteCountA
#define StringICompareByteCount     StringICompareByteCountA
#define StringIMatchByteCount       StringIMatchByteCountA
#define StringCompareCharCount      StringCompareCharCountA
#define StringMatchCharCount        StringMatchCharCountA
#define StringICompareCharCount     StringICompareCharCountA
#define StringIMatchCharCount       StringIMatchCharCountA
#define StringCompareTcharCount     StringCompareTcharCountA
#define StringMatchTcharCount       StringMatchTcharCountA
#define StringICompareTcharCount    StringICompareTcharCountA
#define StringIMatchTcharCount      StringIMatchTcharCountA
#define StringCompareAB             StringCompareABA
#define StringMatchAB               StringMatchABA
#define StringICompareAB            StringICompareABA
#define StringIMatchAB              StringIMatchABA

#define StringCopy                  StringCopyA
#define StringCopyByteCount         StringCopyByteCountA
#define StringCopyCharCount         StringCopyCharCountA
#define StringCopyTcharCount        StringCopyTcharCountA
#define StringCopyAB                StringCopyABA
#define StringCat                   StringCatA
#define GetEndOfString              GetEndOfStringA
#define GetPrevChar                 GetPrevCharA

#define AllocTextEx                 AllocTextExA
#define AllocText                   AllocTextA
#define FreeTextEx                  FreeTextExA
#define FreeText                    FreeTextA
#define DuplicateText               DuplicateTextA
#define DuplicateTextEx             DuplicateTextExA
#define JoinTextEx                  JoinTextExA
#define JoinText                    JoinTextA
#define ExpandEnvironmentText       ExpandEnvironmentTextA
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExA
#define CommandLineToArgv           CommandLineToArgvA

#define _tcsdec2                    _mbsdec2
#define _copytchar                  _copymbchar
#define _settchar                   _setmbchar
#define _tcsgetc                    _mbsgetc
#define _tcssetc                    _mbssetc
#define _tcsnum                     _mbsnum
#define _tcsappend                  _mbsappend
#define _tcsistr                    _mbsistr
#define _tcsisprint                 _mbsisprint
#define _tcsnzcpy                   _mbsnzcpy
#define _tcssafecpy                 _mbssafecpy
#define _tcsnzcpyab                 _mbsnzcpyab
#define _tcssafecpyab               _mbssafecpyab
#define StringPrefix                StringPrefixA
#define StringIPrefix               StringIPrefixA
#define _tcsctrim                   _mbsctrim

#define AppendWack                  AppendWackA
#define AppendDosWack               AppendDosWackA
#define AppendUncWack               AppendUncWackA
#define AppendPathWack              AppendPathWackA
#define RemoveWackAtEnd             RemoveWackAtEndA
#define JoinPathsEx                 JoinPathsExA
#define JoinPaths                   JoinPathsA
#define AllocPathString             AllocPathStringA
#define SplitPath                   SplitPathA
#define GetFileNameFromPath         GetFileNameFromPathA
#define GetFileExtensionFromPath    GetFileExtensionFromPathA
#define GetDotExtensionFromPath     GetDotExtensionFromPathA
#define DuplicatePathString         DuplicatePathStringA

#define PATH_ENUM                   PATH_ENUMA
#define PPATH_ENUM                  PPATH_ENUMA
#define EnumFirstPathEx             EnumFirstPathExA
#define EnumFirstPath               EnumFirstPathA
#define EnumNextPath                EnumNextPathA
#define EnumPathAbort               EnumPathAbortA
#define FreePathStringEx            FreePathStringExA
#define FreePathString              FreePathStringA

#define GetNextRuleChar             GetNextRuleCharA
#define DecodeRuleChars             DecodeRuleCharsA
#define DecodeRuleCharsAB           DecodeRuleCharsABA
#define EncodeRuleChars             EncodeRuleCharsA

#define SkipSpace                   SkipSpaceA
#define SkipSpaceR                  SkipSpaceRA
#define TruncateTrailingSpace       TruncateTrailingSpaceA
#define IsPatternMatch              IsPatternMatchA
#define IsPatternMatchAB            IsPatternMatchABA

#define PPARSEDPATTERN              PPARSEDPATTERNA
#define PARSEDPATTERN               PARSEDPATTERNA
#define CreateParsedPattern         CreateParsedPatternA
#define IsPatternMatchEx            IsPatternMatchExA
#define TestParsedPattern           TestParsedPatternA
#define TestParsedPatternAB         TestParsedPatternABA
#define DestroyParsedPattern        DestroyParsedPatternA

#define CountInstancesOfChar        CountInstancesOfCharA
#define CountInstancesOfCharI       CountInstancesOfCharIA
#define StringReplace               StringReplaceA
#define CountInstancesOfSubString   CountInstancesOfSubStringA
#define StringSearchAndReplace      StringSearchAndReplaceA
#define MULTISZ_ENUM                MULTISZ_ENUMA
#define EnumFirstMultiSz            EnumFirstMultiSzA
#define EnumNextMultiSz             EnumNextMultiSzA

#define ParseMessage                ParseMessageA
#define ParseMessageEx              ParseMessageExA
#define ParseMessageID              ParseMessageIDA
#define ParseMessageIDEx            ParseMessageIDExA
#define GetStringResource           GetStringResourceA
#define GetStringResourceEx         GetStringResourceExA
#define FreeStringResource          FreeStringResourceA
#define ParseMessageInWnd           ParseMessageInWndA
#define ResourceMessageBox          ResourceMessageBoxA

#if 0
#define AddInfSectionToStringTable  AddInfSectionToStringTableA
#endif
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCA

#define ReplaceWacks(f)             ToggleWacksA(f,FALSE)
#define RestoreWacks(f)             ToggleWacksA(f,TRUE)

#define SanitizePath                SanitizePathA

#endif

//
// MessageBox macros
//

#define YesNoBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNO|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define YesNoCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNOCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define OkBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OK|MB_ICONINFORMATION|MB_SETFOREGROUND,NULL)
#define OkCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OKCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define RetryCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_RETRYCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\unattend.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unattend.h

Abstract:

    Declares all of the command line options and unattend options used
    in the Win9x upgrade.

Author:

    Marc R. Whitten (marcw) 15-Jan-1997

Revision History:

    marcw       05-Aug-1998     Clean up!

--*/


#pragma once

#define TRISTATE_NO         0
#define TRISTATE_YES        1
#define TRISTATE_AUTO       2
#define TRISTATE_REQUIRED   TRISTATE_YES
#define TRISTATE_PARTIAL    TRISTATE_AUTO

/*++

Macro Expansion Lists Description:

  The following list is used to implement the unattend/command line options available
  for the Windows NT 5.0 Win9x Upgrade. Each of the options defined below can appear either
  on the command line (common for switches) and in the unattend file (more common for
  paths)

Line Syntax:

   BOOLOPTION(Option, SpecialHandler, Default)
   STRINGOPTION(Option, SpecialHandler, Default)
   MULTISZOPTION(Option, SpecialHandler, Default)

Arguments:

   Option - The name of the option. This is used both as the option member name in the options
            structure and as the text necessary to invoke it on the command line or in the
            unattend file.

   SpecialHandler - The name of a special handling function to be used to set the value of the
            option. If this is NULL, the default handler will be used. (There is a seperate
            default handler for each option type, BOOL, STRING, and MULTISTRING)

   Default - The Default value of the option.

Variables Generated From List:

   g_ConfigOptions
   g_OptionsList

--*/

#define OPTION_LIST                                         \
    BOOLOPTION(ReportOnly,NULL,FALSE)                       \
    BOOLOPTION(PauseAtReport,NULL,FALSE)                    \
    BOOLOPTION(DoLog,NULL,FALSE)                            \
    BOOLOPTION(NoFear,NULL,FALSE)                           \
    BOOLOPTION(GoodDrive,NULL,FALSE)                        \
    BOOLOPTION(TestDlls,NULL,FALSE)                         \
    MULTISZOPTION(MigrationDlls,NULL,NULL)                  \
    STRINGOPTION(SaveReportTo,pHandleSaveReportTo,NULL)     \
    BOOLOPTION(UseLocalAccountOnError,NULL,FALSE)           \
    BOOLOPTION(IgnoreNetworkErrors,NULL,FALSE)              \
    STRINGOPTION(UserDomain,NULL,NULL)                      \
    STRINGOPTION(UserPassword,NULL,NULL)                    \
    STRINGOPTION(DefaultPassword,pGetDefaultPassword,NULL)  \
    BOOLOPTION(EncryptedUserPasswords,NULL,FALSE)           \
    BOOLOPTION(ForcePasswordChange,NULL,FALSE)              \
    BOOLOPTION(MigrateUsersAsAdmin,NULL,TRUE)               \
    BOOLOPTION(MigrateUsersAsPowerUsers,NULL,FALSE)         \
    STRINGOPTION(Boot16,pHandleBoot16,S_NO)                 \
    BOOLOPTION(Stress,NULL,FALSE)                           \
    BOOLOPTION(Fast,NULL,FALSE)                             \
    BOOLOPTION(AutoStress,NULL,FALSE)                       \
    BOOLOPTION(DiffMode,NULL,FALSE)                         \
    BOOLOPTION(MigrateDefaultUser,NULL,TRUE)                \
    BOOLOPTION(AnyVersion,NULL,FALSE)                       \
    BOOLOPTION(KeepTempFiles,NULL,FALSE)                    \
    BOOLOPTION(Help,NULL,FALSE)                             \
    MULTISZOPTION(ScanDrives,NULL,NULL)                     \
    BOOLOPTION(AllLog,NULL,FALSE)                           \
    BOOLOPTION(KeepBadLinks,NULL,TRUE)                      \
    BOOLOPTION(CheckNtFiles,NULL,FALSE)                     \
    BOOLOPTION(ShowPacks,NULL,FALSE)                        \
    BOOLOPTION(ForceWorkgroup,NULL,FALSE)                   \
    BOOLOPTION(DevPause,NULL,FALSE)                         \
    STRINGOPTION(DomainJoinText,NULL,NULL)                  \
    BOOLOPTION(SafeMode,NULL,FALSE)                         \
    BOOLOPTION(ShowAllReport,NULL,TRUE)                     \
    BOOLOPTION(EnableEncryption,NULL,FALSE)                 \
    TRISTATEOPTION(EnableBackup,NULL,TRISTATE_AUTO)         \
    STRINGOPTION(PathForBackup,NULL,NULL)                   \
    TRISTATEOPTION(DisableCompression,NULL,TRISTATE_AUTO)   \
    BOOLOPTION(IgnoreOtherOS,NULL,FALSE)                    \
    TRISTATEOPTION(ShowReport,NULL,TRISTATE_AUTO)           \

//
// ISSUE - eliminate EnableEncryption when all teams using encrypted passwords
// are finished
//

/*++

Macro Expansion Lists Description:

  The following list is used to define aliases of an option. Each alias may be used
  in place of the original option name.

Line Syntax:

   ALIAS(Alias,OriginalOption)

Arguments:

   Alias - The text to use as a synonym of the second argument.

   OriginalOption - The actual option to modify when the alias is specified.

Variables Generated From List:

   g_AliasList

--*/

#define ALIAS_LIST                                          \
    ALIAS(Pr,PauseAtReport)                                 \
    ALIAS(H,Help)                                           \
    ALIAS(dp,DevPause)                                      \
    ALIAS(EnableUninstall,EnableBackup)                     \



#define BOOLOPTION(o,h,d) BOOL o;
#define MULTISZOPTION(o,h,d) PTSTR o;
#define STRINGOPTION(o,h,d) PTSTR o;
#define INTOPTION(o,h,d) INT o;
#define TRISTATEOPTION(o,h,d) INT o;

typedef struct {

OPTION_LIST

} USEROPTIONS, *PUSEROPTIONS;

#undef BOOLOPTION
#undef MULTISZOPTION
#undef STRINGOPTION
#undef INTOPTION
#undef TRISTATEOPTION
#undef ALIAS


extern POOLHANDLE g_UserOptionPool;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\w95resp.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\nt\private\windows\setup\win9xupg\w95upg\ui\stress.rc
//
#define IDD_STRESS                      200

#define IDC_USERNAME                    3500
#define IDC_PRIVATE                     3501
#define IDC_OFFICE                      3502
#define IDC_DBGMACHINE                  3503
#define IDC_MANUAL_TESTS                3504

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1114
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\uninstall.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    uninstall.h

Abstract:

    General uninstall-related functions and structure.

Author:

    Aghajanyan Souren 27-Mar-2001

Revision History:

    sourenag 27-Mar-2001 persistence support

--*/
#if (_WIN32_WINNT >= 0x500)
                           
#ifndef _UNINSTALL_GENERAL_
#define _UNINSTALL_GENERAL_

#include "winioctl.h"

#define MAX_DRIVE_NUMBER ('Z' - 'A' + 1)

typedef enum{
    DiskInfoCmp_Equal, 
    DiskInfoCmp_DifferentLetter, 
    DiskInfoCmp_FileSystemHasChanged, 
    DiskInfoCmp_GeometryHasChanged, 
    DiskInfoCmp_WrongParameters, 
    DiskInfoCmp_DriveMountPointHasChanged, 
    DiskInfoCmp_PartitionPlaceHasChanged, 
    DiskInfoCmp_PartitionLengthHasChanged, 
    DiskInfoCmp_PartitionTypeHasChanged, 
    DiskInfoCmp_PartitionStyleHasChanged, 
    DiskInfoCmp_PartitionCountHasChanged, 
    DiskInfoCmp_PartitionNumberHasChanged, 
    DiskInfoCmp_RewritePartitionHasChanged, 
    DiskInfoCmp_PartitionAttributesHasChanged
}DISKINFO_COMPARATION_STATUS, *PDISKINFO_COMPARATION_STATUS;

typedef struct {
    DISK_GEOMETRY                   DiskGeometry;
    DRIVE_LAYOUT_INFORMATION_EX *   DiskLayout;
} DISKINFO, *PDISKINFO;

typedef struct {
    WCHAR   Drive;
    
    PCWSTR  FileSystemName;
    DWORD   FileSystemFlags;

    PCWSTR  VolumeNTPath;
} DRIVEINFO, *PDRIVEINFO;


typedef struct {
    PCWSTR FileName;
    BOOL   IsCab;
    ULARGE_INTEGER FileSize;
} FILEINTEGRITYINFO, *PFILEINTEGRITYINFO;

typedef struct {
    ULARGE_INTEGER BootFilesDiskSpace;
    ULARGE_INTEGER BackupFilesDiskSpace;
    ULARGE_INTEGER UndoFilesDiskSpace;

    UINT NumberOfDrives;
    PDRIVEINFO  DrivesInfo;
    
    UINT NumberOfDisks;
    PDISKINFO   DisksInfo;

    UINT NumberOfFiles;
    PFILEINTEGRITYINFO   FilesInfo;
} BACKUPIMAGEINFO, *PBACKUPIMAGEINFO;


BOOL 
GetDriveInfo(
    IN      WCHAR Drive, 
    IN OUT  DRIVEINFO * pInfo
    );

BOOL 
GetDrivesInfo(
    IN OUT      DRIVEINFO *  pInfo, 
    IN OUT      UINT      *  pDiskInfoRealCount, 
    IN          UINT         DiskInfoMaxCount
    );

BOOL 
GetPhysycalDiskNumber(
    OUT UINT * pNumberOfPhysicalDisks
    );

BOOL 
GetDiskInfo(
    IN      UINT    Drive, 
    IN OUT  DISKINFO * pInfo
    );

BOOL 
GetDisksInfo(
    OUT     DISKINFO ** pInfo, 
    OUT     UINT * pNumberOfItem
    );

BOOL 
GetIntegrityInfoW(
    IN  PCWSTR FileName, 
    IN  PCWSTR DirPath, 
    OUT FILEINTEGRITYINFO * IntegrityInfoPtr
);

VOID 
FreeDisksInfo(
    IN  DISKINFO *  pInfo, 
    IN  UINT        NumberOfItem
    );

BOOL 
GetDrivesInfo(
    IN OUT      DRIVEINFO *  pInfo, 
    IN OUT      UINT     *  pDiskInfoRealCount, 
    IN          UINT        DiskInfoMaxCount
);

BOOL 
GetUndoDrivesInfo(
    OUT DRIVEINFO * pInfo, 
    OUT UINT      * pNumberOfDrive, 
    IN  WCHAR       BootDrive, 
    IN  WCHAR       SystemDrive, 
    IN  WCHAR       UndoDrive
    );
    
DISKINFO_COMPARATION_STATUS 
CompareDriveInfo(
    IN      DRIVEINFO * FirstInfo,
    IN      DRIVEINFO * SecondInfo
    );

BOOL 
CompareDrivesInfo(
    IN      DRIVEINFO *                     FirstInfo,
    IN      DRIVEINFO *                     SecondInfo, 
    IN      UINT                            DriveInfoCount, 
    OUT     PDISKINFO_COMPARATION_STATUS    OutDiskCmpStatus,           OPTIONAL
    OUT     UINT     *                      OutIfFailedDiskInfoIndex    OPTIONAL
    );

DISKINFO_COMPARATION_STATUS 
CompareDiskInfo(
    IN      DISKINFO * FirstInfo,
    IN      DISKINFO * SecondInfo
    );

BOOL 
CompareDisksInfo(
    IN      DISKINFO *                      FirstInfo,
    IN      DISKINFO *                      SecondInfo, 
    IN      UINT                            DiskInfoCount, 
    OUT     PDISKINFO_COMPARATION_STATUS    OutDiskCmpStatus,           OPTIONAL
    OUT     UINT     *                      OutIfFailedDiskInfoIndex    OPTIONAL
    );

#define BACKUPIMAGEINFO_VERSION         2

#define DRIVE_LAYOUT_INFORMATION_EX_PERSISTENCE \
                                        PERSIST_BEGIN_DECLARE_STRUCT(DRIVE_LAYOUT_INFORMATION_EX, BACKUPIMAGEINFO_VERSION)  \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DWORD, PartitionStyle), \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DWORD, PartitionCount), \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DRIVE_LAYOUT_INFORMATION_MBR, Mbr), \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DRIVE_LAYOUT_INFORMATION_GPT, Gpt), \
                                            PERSIST_STRUCT_BY_VALUE_VARIABLE_LENGTH(DRIVE_LAYOUT_INFORMATION_EX, PARTITION_INFORMATION_EX, PartitionEntry, PartitionCount, 1), \
                                        PERSIST_END_DECLARE_STRUCT(DRIVE_LAYOUT_INFORMATION_EX, BACKUPIMAGEINFO_VERSION)

#define DISKINFO_PERSISTENCE            PERSIST_BEGIN_DECLARE_STRUCT(DISKINFO, BACKUPIMAGEINFO_VERSION)     \
                                            PERSIST_FIELD_BY_VALUE(DISKINFO, DISK_GEOMETRY, DiskGeometry),  \
                                            PERSIST_FIELD_NESTED_TYPE(DISKINFO, DRIVE_LAYOUT_INFORMATION_EX, BACKUPIMAGEINFO_VERSION, DiskLayout, BYREF),   \
                                        PERSIST_END_DECLARE_STRUCT(DISKINFO, BACKUPIMAGEINFO_VERSION)

#define DRIVEINFO_PERSISTENCE           PERSIST_BEGIN_DECLARE_STRUCT(DRIVEINFO, BACKUPIMAGEINFO_VERSION)\
                                            PERSIST_FIELD_BY_VALUE(DRIVEINFO, WCHAR, Drive),    \
                                            PERSIST_FIELD_STRINGW(DRIVEINFO, FileSystemName),   \
                                            PERSIST_FIELD_BY_VALUE(DRIVEINFO, DWORD, FileSystemFlags),   \
                                            PERSIST_FIELD_STRINGW(DRIVEINFO, VolumeNTPath),     \
                                        PERSIST_END_DECLARE_STRUCT(DRIVEINFO, BACKUPIMAGEINFO_VERSION)

#define FILEINTEGRITYINFO_PERSISTENCE   PERSIST_BEGIN_DECLARE_STRUCT(FILEINTEGRITYINFO, BACKUPIMAGEINFO_VERSION)\
                                            PERSIST_FIELD_STRINGW(FILEINTEGRITYINFO, FileName), \
                                            PERSIST_FIELD_BY_VALUE(FILEINTEGRITYINFO, BOOL, IsCab),   \
                                            PERSIST_FIELD_BY_VALUE(FILEINTEGRITYINFO, ULARGE_INTEGER, FileSize),   \
                                        PERSIST_END_DECLARE_STRUCT(FILEINTEGRITYINFO, BACKUPIMAGEINFO_VERSION)

#define BACKUPIMAGEINFO_PERSISTENCE     PERSIST_BEGIN_DECLARE_STRUCT(BACKUPIMAGEINFO, BACKUPIMAGEINFO_VERSION)\
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, ULARGE_INTEGER, BootFilesDiskSpace),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, ULARGE_INTEGER, BackupFilesDiskSpace), \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, ULARGE_INTEGER, UndoFilesDiskSpace),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, UINT, NumberOfDisks),   \
                                            PERSIST_FIELD_NESTED_TYPE_CYCLE(BACKUPIMAGEINFO, DISKINFO, BACKUPIMAGEINFO_VERSION, DisksInfo, BYREF, NumberOfDisks),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, UINT, NumberOfDrives),   \
                                            PERSIST_FIELD_NESTED_TYPE_CYCLE(BACKUPIMAGEINFO, DRIVEINFO, BACKUPIMAGEINFO_VERSION, DrivesInfo, BYREF, NumberOfDrives),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, UINT, NumberOfFiles),   \
                                            PERSIST_FIELD_NESTED_TYPE_CYCLE(BACKUPIMAGEINFO, FILEINTEGRITYINFO, BACKUPIMAGEINFO_VERSION, FilesInfo, BYREF, NumberOfFiles),   \
                                        PERSIST_END_DECLARE_STRUCT(BACKUPIMAGEINFO, BACKUPIMAGEINFO_VERSION)


BOOL 
IsFloppyDiskInDrive(
    VOID
    );

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\winntreg.h ===
#ifndef WinNTRegOpenKey
#define WinNTRegOpenKey RegOpenKey
#endif

#ifndef WinNTRegOpenKeyEx
#define WinNTRegOpenKeyEx RegOpenKeyEx
#endif

#ifndef WinNTRegCloseKey
#define WinNTRegCloseKey RegCloseKey
#endif

#ifndef WinNTRegQueryValue
#define WinNTRegQueryValue RegQueryValue
#endif

#ifndef WinNTRegQueryValueEx
#define WinNTRegQueryValueEx RegQueryValueEx
#endif

#ifndef WinNTRegEnumKey
#define WinNTRegEnumKey RegEnumKey
#endif

#ifndef WinNTRegEnumKeyEx
#define WinNTRegEnumKeyEx RegEnumKeyEx
#endif

#ifndef WinNTRegDeleteKey
#define WinNTRegDeleteKey RegDeleteKey
#endif

#ifndef WinNTRegDeleteValue
#define WinNTRegDeleteValue RegDeleteValue
#endif

#ifndef WinNTRegEnumValue
#define WinNTRegEnumValue RegEnumValue
#endif

#ifndef WinNTRegFlushKey
#define WinNTRegFlushKey RegFlushKey
#endif

#ifndef WinNTRegQueryInfoKey
#define WinNTRegQueryInfoKey RegQueryInfoKey
#endif

#ifndef WinNTRegQueryMultipleValues
#define WinNTRegQueryMultipleValues RegQueryMultipleValues
#endif

#ifndef WinNTRegReplaceKey
#define WinNTRegReplaceKey RegReplaceKey
#endif

#ifndef WinNTRegSetValue
#define WinNTRegSetValue RegSetValue
#endif

#ifndef WinNTRegSetValueEx
#define WinNTRegSetValueEx RegSetValueEx
#endif

#ifndef WinNTRegCreateKey
#define WinNTRegCreateKey RegCreateKey
#endif

#ifndef WinNTRegCreateKeyEx
#define WinNTRegCreateKeyEx RegCreateKeyEx
#endif

#ifndef WinNTRegSaveKey
#define WinNTRegSaveKey RegSaveKey
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\w95upgnt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    w95upgnt.h

Abstract:

    Declares the variables and defines the progress bar ticks for
    w95upgnt.dll.

Author:

    Jim Schmidt (jimschm)   10-Oct-1996

Revision History:

    See SLM log

--*/

//
// w95upgnt.h -- public interface for w95upgnt.dll
//
//

#pragma once

// common stuff
#include "common.h"

#include "unattend.h"

BOOL
ConvertWin9xCmdLine (
    IN OUT  PTSTR CmdLine,                      // MAX_CMDLINE buffer
    IN      PCTSTR ObjectForDbgMsg,             OPTIONAL
    OUT     PBOOL PointsToDeletedItem           OPTIONAL
    );


BOOL
RenameOnRestartOfGuiMode(
    IN      PCWSTR PathName,
    IN      PCWSTR PathNameNew
    );

BOOL
RenameListOnRestartOfGuiMode (
    IN      PGROWLIST SourceList,
    IN      PGROWLIST DestList
    );


extern TCHAR g_WinDir[MAX_TCHAR_PATH];
extern TCHAR g_WinDrive[MAX_TCHAR_PATH];
extern TCHAR g_System32Dir[MAX_TCHAR_PATH];
extern TCHAR g_SystemDir[MAX_TCHAR_PATH];
extern TCHAR g_ProgramFiles[MAX_TCHAR_PATH];
extern TCHAR g_ProgramFilesCommon[MAX_TCHAR_PATH];
extern TCHAR g_TempDir[MAX_TCHAR_PATH];
extern PCTSTR g_SourceDir;
extern TCHAR g_Win95Name[MAX_TCHAR_PATH];
extern PCTSTR g_DomainUserName; // NULL for local machine
extern PCTSTR g_Win9xUserName;  // NULL for local machine
extern PCTSTR g_FixedUserName;  // NULL for local machine
extern TCHAR g_IconBin[MAX_TCHAR_PATH];
extern TCHAR g_Win9xBootDrivePath[];
extern TCHAR g_ComputerName[];


extern HWND g_ParentWnd;
extern HWND g_ProgressBar;
extern HINF g_UnattendInf;
extern HINF g_WkstaMigInf;
extern HINF g_UserMigInf;

extern UINT g_Boot16;

extern USEROPTIONS g_ConfigOptions;

extern PCTSTR   g_AdministratorStr;


//
// Registry string maps
//

extern PMAPSTRUCT g_CompleteMatchMap;
extern PMAPSTRUCT g_SubStringMap;



#define PROCESSING_DLL_MAIN


#ifdef VAR_PROGRESS_BAR

#define TICKS_INIT                      550
#define TICKS_DOMAIN_SEARCH             24500
#define TICKS_DELETESYSTAPI             100
#define TICKS_INI_ACTIONS_FIRST         100
#define TICKS_INI_MOVE                  100
#define TICKS_INI_CONVERSION            2400
#define TICKS_INI_MIGRATION             3000
#define TICKS_SYSTEM_SHELL_MIGRATION    20000
#define TICKS_GHOST_SYSTEM_MIGRATION    1000
#define TICKS_PERUSER_INIT              500
#define TICKS_DELETEUSERTAPI            100
#define TICKS_USER_REGISTRY_MIGRATION   10000
#define TICKS_LOGON_PROMPT_SETTINGS     100
#define TICKS_USER_SETTINGS             1000
#define TICKS_USER_EXTERN_PROCESSES     100
#define TICKS_USER_UNINSTALL_CLEANUP    100
#define TICKS_SAVE_USER_HIVE            1000
#define TICKS_COPYFILE                  700
#define TICKS_INI_MERGE                 1500
#define TICKS_HKLM                      500000
#define TICKS_SHARES                    150
#define TICKS_LINK_EDIT                 350
#define TICKS_DOSMIG_SYS                200
#define TICKS_UPDATERECYCLEBIN          500
#define TICKS_STF                       25000
#define TICKS_RAS                       300
#define TICKS_TAPI                      300
#define TICKS_MULTIMEDIA                100
#define TICKS_INI_ACTIONS_LAST          3000
#define TICKS_HIVE_CONVERSION           300
#define TICKS_ATM_MIGRATION             100
#define TICKS_SYSTEM_EXTERN_PROCESSES   3000
#define TICKS_SYSTEM_UNINSTALL_CLEANUP  100
#define TICKS_MIGRATION_DLL             2000
#define TICKS_MIGRATE_BRIEFCASES        120
#define TICKS_FILE_EDIT                 100

#else // !defined VAR_PROGRESS_BAR

//#define TickProgressBar() TickProgressBarDelta(1)

#define TICKS_INIT                      5
#define TICKS_DOMAIN_SEARCH             100
#define TICKS_INI_ACTIONS_FIRST         1
#define TICKS_INI_ACTIONS_LAST          20
#define TICKS_INI_MOVE                  25
#define TICKS_INI_CONVERSION            30
#define TICKS_INI_MIGRATION             30
#define TICKS_INI_MERGE                 30
#define TICKS_HKLM                      1600
#define TICKS_SHARES                    15
#define TICKS_LINK_EDIT                 30
#define TICKS_DOSMIG_SYS                10
#define TICKS_UPDATERECYCLEBIN          20
#define TICKS_STF                       80
#define TICKS_RAS                       20
#define TICKS_TAPI                      10
#define TICKS_MULTIMEDIA                10
#define TICKS_MIGRATION_DLL             50
#define TICKS_COPYFILE                  80
#define TICKS_MOVEFILE                  50
#define TICKS_PERUSER_INIT              2
#define TICKS_USER_REGISTRY_MIGRATION   90
#define TICKS_LOGON_PROMPT_SETTINGS     1
#define TICKS_USER_SETTINGS             5
#define TICKS_SAVE_USER_HIVE            3
#define TICKS_SYSTEM_SHELL_MIGRATION    250
#define TICKS_GHOST_SYSTEM_MIGRATION    20
#define TICKS_USER_SHELL_MIGRATION      1
#define TICKS_HIVE_CONVERSION           5
#define TICKS_ATM_MIGRATION             8
#define TICKS_DELETEUSERTAPI            5
#define TICKS_DELETESYSTAPI             5
#define TICKS_USER_EXTERN_PROCESSES     3
#define TICKS_SYSTEM_EXTERN_PROCESSES   3
#define TICKS_USER_UNINSTALL_CLEANUP    3
#define TICKS_SYSTEM_UNINSTALL_CLEANUP  3
#define TICKS_MIGRATE_BRIEFCASES        3
#define TICKS_FILE_EDIT                 3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\win95reg.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    win95reg.h

Abstract:

    Public interface to win95reg.dll

    Externally exposed routines:

        (Many; list to follow)

Author:

    8-Jul-1996 Mike Condra (mikeco)

Revision History:

    11-Feb-1999 jimschm     Rewrote significant portions to fix major bugs

--*/


//
// Prototypes of all the VMMREG routines Win95Reg supports
//

typedef LONG (REG_FLUSH_KEY)(HKEY hKey);
typedef REG_FLUSH_KEY WINAPI * PREG_FLUSH_KEY;

typedef LONG (REG_ENUM_KEY_A)(
            HKEY Key,
            DWORD Index,
            PSTR KeyName,
            DWORD KeyNameSize
            );
typedef REG_ENUM_KEY_A WINAPI * PREG_ENUM_KEY_A;

typedef LONG (REG_ENUM_KEY_W)(
            HKEY Key,
            DWORD Index,
            PWSTR KeyName,
            DWORD KeyNameSize
            );
typedef REG_ENUM_KEY_W WINAPI * PREG_ENUM_KEY_W;

typedef LONG (REG_ENUM_KEY_EX_A)(
            HKEY Key,
            DWORD Index,
            PSTR KeyName,
            PDWORD KeyNameSize,
            PDWORD Reserved,
            PSTR Class,
            PDWORD ClassSize,
            PFILETIME LastWriteTime
            );
typedef REG_ENUM_KEY_EX_A WINAPI * PREG_ENUM_KEY_EX_A;

typedef LONG (REG_ENUM_KEY_EX_W)(
            HKEY Key,
            DWORD Index,
            PWSTR KeyName,
            PDWORD KeyNameSize,
            PDWORD Reserved,
            PWSTR Class,
            PDWORD ClassSize,
            PFILETIME LastWriteTime
            );
typedef REG_ENUM_KEY_EX_W WINAPI * PREG_ENUM_KEY_EX_W;

typedef LONG (REG_ENUM_VALUE_A)(
            HKEY Key,
            DWORD Index,
            PSTR ValueName,
            PDWORD ValueNameSize,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_ENUM_VALUE_A WINAPI * PREG_ENUM_VALUE_A;

typedef LONG (REG_ENUM_VALUE_W)(
            HKEY Key,
            DWORD Index,
            PWSTR ValueName,
            PDWORD ValueNameSize,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_ENUM_VALUE_W WINAPI * PREG_ENUM_VALUE_W;

typedef LONG (REG_LOAD_KEY_A)(
            HKEY Key,
            PCSTR SubKey,
            PCSTR FileName
            );
typedef REG_LOAD_KEY_A WINAPI * PREG_LOAD_KEY_A;

typedef LONG (REG_LOAD_KEY_W)(
            HKEY Key,
            PCWSTR SubKey,
            PCWSTR FileName
            );
typedef REG_LOAD_KEY_W WINAPI * PREG_LOAD_KEY_W;

typedef LONG (REG_UNLOAD_KEY_A)(
            HKEY Key,
            PCSTR SubKey
            );
typedef REG_UNLOAD_KEY_A WINAPI * PREG_UNLOAD_KEY_A;

typedef LONG (REG_UNLOAD_KEY_W)(
            HKEY Key,
            PCWSTR SubKey
            );
typedef REG_UNLOAD_KEY_W WINAPI * PREG_UNLOAD_KEY_W;

typedef LONG (REG_OPEN_KEY_EX_A)(
            HKEY Key,
            PCSTR SubKey,
            DWORD Options,
            REGSAM SamDesired,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_EX_A WINAPI * PREG_OPEN_KEY_EX_A;

typedef LONG (REG_OPEN_KEY_EX_W)(
            HKEY Key,
            PCWSTR SubKey,
            DWORD Options,
            REGSAM SamDesired,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_EX_W WINAPI * PREG_OPEN_KEY_EX_W;

typedef LONG (REG_OPEN_KEY_A)(
            HKEY Key,
            PCSTR SubKey,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_A WINAPI * PREG_OPEN_KEY_A;

typedef LONG (REG_OPEN_KEY_W)(
            HKEY Key,
            PCWSTR SubKey,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_W WINAPI * PREG_OPEN_KEY_W;

typedef LONG (REG_CLOSE_KEY)(HKEY Key);
typedef REG_CLOSE_KEY WINAPI * PREG_CLOSE_KEY;

typedef LONG (REG_QUERY_INFO_KEY_A)(
            HKEY Key,
            PSTR Class,
            PDWORD ClassSize,
            PDWORD Reserved,
            PDWORD SubKeys,
            PDWORD MaxSubKeyLen,
            PDWORD MaxClassLen,
            PDWORD Values,
            PDWORD MaxValueName,
            PDWORD MaxValueData,
            PVOID SecurityDescriptor,
            PVOID LastWriteTime
            );
typedef REG_QUERY_INFO_KEY_A WINAPI * PREG_QUERY_INFO_KEY_A;

typedef LONG (REG_QUERY_INFO_KEY_W)(
            HKEY Key,
            PWSTR Class,
            PDWORD ClassSize,
            PDWORD Reserved,
            PDWORD SubKeys,
            PDWORD MaxSubKeyLen,
            PDWORD MaxClassLen,
            PDWORD Values,
            PDWORD MaxValueName,
            PDWORD MaxValueData,
            PVOID SecurityDescriptor,
            PVOID LastWriteTime
            );
typedef REG_QUERY_INFO_KEY_W WINAPI * PREG_QUERY_INFO_KEY_W;

typedef LONG (REG_QUERY_VALUE_A)(
            HKEY Key,
            PCSTR SubKey,
            PSTR Data,
            PLONG DataSize
            );
typedef REG_QUERY_VALUE_A WINAPI * PREG_QUERY_VALUE_A;

typedef LONG (REG_QUERY_VALUE_W)(
            HKEY Key,
            PCWSTR SubKey,
            PWSTR Data,
            PLONG DataSize
            );
typedef REG_QUERY_VALUE_W WINAPI * PREG_QUERY_VALUE_W;

typedef LONG (REG_QUERY_VALUE_EX_A)(
            HKEY Key,
            PCSTR ValueName,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_QUERY_VALUE_EX_A WINAPI * PREG_QUERY_VALUE_EX_A;

typedef LONG (REG_QUERY_VALUE_EX_W)(
            HKEY Key,
            PCWSTR ValueName,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_QUERY_VALUE_EX_W WINAPI * PREG_QUERY_VALUE_EX_W;


//
// USERPOSITION -- for user enumeration
//

typedef struct {
    BOOL UseProfile;
    UINT NumPos;
    UINT CurPos;
    WORD Valid;
    BOOL IsLastLoggedOnUserName;
    BOOL LastLoggedOnUserNameExists;
    HKEY Win9xUserKey;
    // Private structure member
    CHAR LastLoggedOnUserName[MAX_MBCHAR_PATH]; // not TCHAR, WCHAR
} USERPOSITION, *PUSERPOSITION;


//
// Macro expansion list of all the wrappers
//

#define REGWRAPPERS         \
    DEFMAC(REG_FLUSH_KEY, RegFlushKey)                          \
    DEFMAC(REG_ENUM_KEY_A, RegEnumKeyA)                         \
    DEFMAC(REG_ENUM_KEY_W, RegEnumKeyW)                         \
    DEFMAC(REG_ENUM_KEY_EX_A, RegEnumKeyExA)                    \
    DEFMAC(REG_ENUM_KEY_EX_W, RegEnumKeyExW)                    \
    DEFMAC(REG_ENUM_VALUE_A, RegEnumValueA)                     \
    DEFMAC(REG_ENUM_VALUE_W, RegEnumValueW)                     \
    DEFMAC(REG_LOAD_KEY_A, RegLoadKeyA)                         \
    DEFMAC(REG_LOAD_KEY_W, RegLoadKeyW)                         \
    DEFMAC(REG_UNLOAD_KEY_A, RegUnLoadKeyA)                     \
    DEFMAC(REG_UNLOAD_KEY_W, RegUnLoadKeyW)                     \
    DEFMAC(REG_OPEN_KEY_EX_A, RegOpenKeyExA)                    \
    DEFMAC(REG_OPEN_KEY_EX_W, RegOpenKeyExW)                    \
    DEFMAC(REG_OPEN_KEY_A, RegOpenKeyA)                         \
    DEFMAC(REG_OPEN_KEY_W, RegOpenKeyW)                         \
    DEFMAC(REG_CLOSE_KEY, RegCloseKey)                          \
    DEFMAC(REG_QUERY_INFO_KEY_A, RegQueryInfoKeyA)              \
    DEFMAC(REG_QUERY_INFO_KEY_W, RegQueryInfoKeyW)              \
    DEFMAC(REG_QUERY_VALUE_A, RegQueryValueA)                   \
    DEFMAC(REG_QUERY_VALUE_W, RegQueryValueW)                   \
    DEFMAC(REG_QUERY_VALUE_EX_A, RegQueryValueExA)              \
    DEFMAC(REG_QUERY_VALUE_EX_W, RegQueryValueExW)              \

//
// Declare globals for Win95 registry wrappers
//

#define DEFMAC(fn,name)     extern P##fn Win95##name;

REGWRAPPERS

#undef DEFMAC

//
// Extension routines
//

VOID
InitWin95RegFnPointers (
    VOID
    );

LONG
Win95RegInitA (
    IN      PCSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    );

LONG
Win95RegInitW (
    IN      PCWSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    );

LONG
Win95RegSetCurrentUserA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,        OPTIONAL
    OUT     PSTR UserDatOut             OPTIONAL
    );

LONG
Win95RegSetCurrentUserW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,       OPTIONAL
    OUT     PWSTR UserDatOut            OPTIONAL
    );

LONG
Win95RegSetCurrentUserNtA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR UserDat
    );

LONG
Win95RegSetCurrentUserNtW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR UserDat
    );

DWORD
FindAndLoadHive (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller,           OPTIONAL
    IN      BOOL MapTheHive
    );

extern PCSTR g_UserKey;
extern CHAR g_SystemHiveDir[MAX_MBCHAR_PATH];

LONG
Win95RegGetFirstUserA (
    PUSERPOSITION Pos,
    PSTR UserName
    );

LONG
Win95RegGetFirstUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    );

LONG
Win95RegGetNextUserA (
    PUSERPOSITION Pos,
    PSTR UserName
    );

LONG
Win95RegGetNextUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    );

#define Win95RegHaveUser(Pos) ((Pos)->NumPos > 0)


BOOL
Win95RegIsValidUser (
    HKEY ProfileListKey,        OPTIONAL
    PSTR UserNameAnsi
    );



//
// A & W macros
//

#ifdef UNICODE

#define Win95RegEnumKey             Win95RegEnumKeyW
#define Win95RegEnumKeyEx           Win95RegEnumKeyExW
#define Win95RegEnumValue           Win95RegEnumValueW
#define Win95RegLoadKey             Win95RegLoadKeyW
#define Win95RegUnLoadKey           Win95RegUnLoadKeyW
#define Win95RegOpenKeyEx           Win95RegOpenKeyExW
#define Win95RegOpenKey             Win95RegOpenKeyW
#define Win95RegQueryInfoKey        Win95RegQueryInfoKeyW
#define Win95RegQueryValue          Win95RegQueryValueW
#define Win95RegQueryValueEx        Win95RegQueryValueExW

#define Win95RegInit                Win95RegInitW
#define Win95RegSetCurrentUser      Win95RegSetCurrentUserW
#define Win95RegSetCurrentUserNt    Win95RegSetCurrentUserNtW
#define Win95RegGetFirstUser        Win95RegGetFirstUserW
#define Win95RegGetNextUser         Win95RegGetNextUserW

#else

#define Win95RegEnumKey             Win95RegEnumKeyA
#define Win95RegEnumKeyEx           Win95RegEnumKeyExA
#define Win95RegEnumValue           Win95RegEnumValueA
#define Win95RegLoadKey             Win95RegLoadKeyA
#define Win95RegUnLoadKey           Win95RegUnLoadKeyA
#define Win95RegOpenKeyEx           Win95RegOpenKeyExA
#define Win95RegOpenKey             Win95RegOpenKeyA
#define Win95RegQueryInfoKey        Win95RegQueryInfoKeyA
#define Win95RegQueryValue          Win95RegQueryValueA
#define Win95RegQueryValueEx        Win95RegQueryValueExA

#define Win95RegInit                Win95RegInitA
#define Win95RegSetCurrentUser      Win95RegSetCurrentUserA
#define Win95RegSetCurrentUserNt    Win95RegSetCurrentUserNtA
#define Win95RegGetFirstUser        Win95RegGetFirstUserA
#define Win95RegGetNextUser         Win95RegGetNextUserA

#endif

//
// Now include registry wrapper APIs in reg95.h; it redefines Win95RegOpenKeyExA,
// Win95RegOpenKeyExW and Win95RegCloseKey for tracking purposes.
//

#include "reg95.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\w95upg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    w95upg.h

Abstract:

    Defines types and functions, and declares globals used for
    w95upg.dll only.

Author:

    Jim Schmidt (jimschm) 25-Sep-1996

Revision History:

    See SLM log

--*/

#pragma once

// property sheet
#include <prsht.h>

// twain data structs
#include <twain.h>

#include "unattend.h"

WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE Winnt32PluginInit;
WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE Winnt32PluginGetPages;
WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE Winnt32WriteParams;
WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE Winnt32Cleanup;

extern UINT g_ProgressBarTime;

//
// Macro returns true if setup is running in unattended mode.
//
#define UNATTENDED() (g_UnattendedFlagPtr && *g_UnattendedFlagPtr)
//
// Macro returns true if setup is running in upgrade mode.
//
#define UPGRADE()    (g_UpgradeFlagPtr && *g_UpgradeFlagPtr)
//
// Macro returns true if setup is running in report-only mode.
//
#define REPORTONLY() (g_ConfigOptions.ReportOnly)
//
// Macro returns true if setup is running in typical mode.
//
#define TYPICAL() (g_SetupFlags && (*g_SetupFlags & UPG_FLAG_TYPICAL))
//
// Macros for setting, clearing, and checking the cancel flag.
//
#define SETCANCEL()     (g_CancelFlagPtr ? *g_CancelFlagPtr = TRUE : 0)
#define CLEARCANCEL()   (g_CancelFlagPtr ? *g_CancelFlagPtr = FALSE : 0)
#define CANCELLED()     (g_CancelFlagPtr && *g_CancelFlagPtr)

#define SOURCEDIRECTORYCOUNT()  (g_SourceDirectoryCount)
#define SOURCEDIRECTORYARRAY()  (g_SourceDirectories)
#define SOURCEDIRECTORY(n)      (g_SourceDirectories[n])

#define OPTIONALDIRECTORYCOUNT()  (g_OptionalDirectoryCount)
#define OPTIONALDIRECTORYARRAY()  (g_OptionalDirectories)
#define OPTIONALDIRECTORY(n)      (g_OptionalDirectories[n])



//
// Globals in dllentry.c
//

extern PTSTR    g_WinDir;
extern PTSTR    g_WinDirWack;
extern PTSTR    g_WinDrive;
extern PTSTR    g_PlugInDir;
extern PTSTR    g_PlugInDirWack;
extern PTSTR    g_PlugInTempDir;
extern PTSTR    g_TempDir;
extern PTSTR    g_Win9xSifDir;
extern PTSTR    g_TempDirWack;
extern PTSTR    g_SystemDir;
extern PTSTR    g_SystemDirWack;
extern PTSTR    g_System32Dir;
extern PTSTR    g_System32DirWack;
extern PTSTR    g_ProgramFilesDir;
extern PTSTR    g_ProgramFilesDirWack;
extern PTSTR    g_ProgramFilesCommonDir;
extern PTSTR    g_RecycledDirWack;
extern PTSTR    g_Win95UpgInfFile;
extern PTSTR    g_ProfileDirNt;
extern PTSTR    g_ProfileDir;
extern PTSTR    g_ProfileDirWack;
extern PTSTR    g_CommonProfileDir;
extern PTSTR    g_DriversDir;
extern PTSTR    g_InfDir;
extern PTSTR    g_HelpDir;
extern PTSTR    g_HelpDirWack;
extern PTSTR    g_CatRootDir;
extern PTSTR    g_CatRootDirWack;
extern PTSTR    g_FontsDir;
extern PTSTR    g_ViewersDir;
extern PTSTR    g_ColorDir;
extern PTSTR    g_SharedDir;
extern PTSTR    g_SpoolDir;
extern PTSTR    g_SpoolDriversDir;
extern PTSTR    g_PrintProcDir;
extern PCTSTR   g_SourceDirectories[MAX_SOURCE_COUNT];
extern DWORD    g_SourceDirectoryCount;
extern PCTSTR   g_OptionalDirectories[MAX_SOURCE_COUNT];
extern DWORD    g_OptionalDirectoryCount;
extern PCTSTR*  g_SourceDirectoriesFromWinnt32;
extern PDWORD   g_SourceDirectoryCountFromWinnt32;
extern PCTSTR*  g_OptionalDirectoriesFromWinnt32;
extern PDWORD   g_OptionalDirectoryCountFromWinnt32;
extern PCTSTR*  g_UnattendScriptFile;
extern PCTSTR*  g_CmdLineOptions;
extern TCHAR    g_DllDir[];
extern TCHAR    g_UpgradeSources[];
extern BOOL *   g_UnattendedFlagPtr;
extern BOOL *   g_CancelFlagPtr;
extern BOOL *   g_AbortFlagPtr;
extern BOOL *   g_UpgradeFlagPtr;
extern BOOL *   g_MakeLocalSourcePtr;
extern BOOL *   g_CdRomInstallPtr;
extern BOOL *   g_BlockOnNotEnoughSpace;
extern PDWORD   g_LocalSourceDrive;
extern PLONGLONG g_LocalSourceSpace;
extern PLONGLONG g_WinDirSpace;
extern PUINT    g_RamNeeded;
extern PUINT    g_RamAvailable;
extern HINF     g_Win95UpgInf;
extern HINF     g_TxtSetupSif;
extern TCHAR    g_Win95Name[MAX_TCHAR_PATH];
extern BOOL *   g_ForceNTFSConversion;
extern UINT *   g_ProductFlavor;
extern BOOL     g_PersonalSKU;
extern PDWORD   g_SetupFlags;
extern PTSTR    g_DynamicUpdateLocalDir;
extern PTSTR    g_DynamicUpdateDrivers;
extern BOOL *   g_UnattendSwitchSpecified;

extern INT      g_TempDirWackChars;
extern INT      g_WinDirWackChars;
extern INT      g_HelpDirWackChars;
extern INT      g_CatRootDirWackChars;
extern INT      g_SystemDirWackChars;
extern INT      g_System32DirWackChars;
extern INT      g_PlugInDirWackChars;
extern INT      g_RecycledDirWackChars;
extern INT      g_ProfileDirWackChars;
extern INT      g_ProgramFilesDirWackChars;


extern PRODUCTTYPE * g_ProductType;
extern USEROPTIONS  g_ConfigOptions;

extern BOOL     g_UseSystemFont;

extern LPCTSTR  g_ProfileName;

extern HWND     g_ParentWnd;

extern PCTSTR   g_AdministratorStr;

#ifdef PRERELEASE
extern BOOL     g_Stress;               // private stress mode
#endif

extern POOLHANDLE g_GlobalPool;         // for global strings that last for the complete runtime

extern UINT *   g_Boot16;


extern BOOL g_BadVirusScannerFound;
extern BOOL g_BlockingFileFound;
extern BOOL g_BlockingHardwareFound;
extern BOOL g_BlockingAppFound;
extern BOOL g_KillNav;
extern GROWLIST g_BadVirusScannerGrowList;
extern BOOL g_OtherOsExists;
extern BOOL g_UnknownOs;
extern BOOL g_ToolMode;

extern DWORD g_BackupDirCount;

extern PMAPSTRUCT g_CacheShellFolders;

//
// Globals in sysmig\migmain.c
//

extern ICON_EXTRACT_CONTEXT g_IconContext;

//
// Tool Mode: Routines specific to non-shipping tools
//

BOOL
InitToolMode (
    HINSTANCE Instance
    );

VOID
TerminateToolMode (
    HINSTANCE Instance
    );



//
// COMMON9X: common9x.c
//

VOID
InitializeKnownGoodIconMap (
    VOID
    );

VOID
CleanUpKnownGoodIconMap (
    VOID
    );

BOOL
IsIconKnownGood (
    IN      PCTSTR FileSpec,
    IN      INT Index
    );

typedef struct {
    TCHAR   JoystickDriver[MAX_TCHAR_PATH];
    TCHAR   JoystickName[MAX_TCHAR_PATH];

    HKEY Root;
    UINT JoyId;
} JOYSTICK_ENUM, *PJOYSTICK_ENUM;

BOOL
EnumFirstJoystick (
    OUT     PJOYSTICK_ENUM EnumPtr
    );

BOOL
EnumNextJoystick (
    IN OUT  PJOYSTICK_ENUM EnumPtr
    );

VOID
AbortJoystickEnum (
    IN OUT  PJOYSTICK_ENUM EnumPtr
    );


LRESULT
TwoButtonBox (
    IN HWND Window,
    IN PCTSTR Text,
    IN PCTSTR Button1,
    IN PCTSTR Button2
    );

BOOL
DontTouchThisFile (
    IN      PCTSTR FileName
    );

VOID
ReplaceOneEnvVar (
    IN OUT  PCTSTR *NewString,
    IN      PCTSTR Base,
    IN      PCTSTR Variable,
    IN      PCTSTR Value
    );


VOID
Init9xEnvironmentVariables (
    VOID
    );

BOOL
Expand9xEnvironmentVariables (
    IN      PCSTR SourceString,
    OUT     PSTR DestinationString,     // can be the same as SourceString
    IN      INT DestSizeInBytes
    );

VOID
CleanUp9xEnvironmentVariables (
    VOID
    );

BOOL
FixGuid (
    IN      PCTSTR Guid,
    OUT     PTSTR NewGuid           // can be the same as Guid
    );

BOOL
IsGuid (
    IN      PCTSTR Guid,
    IN      BOOL MustHaveBraces
    );


//
// COMMON9X: userenum.c
//

typedef enum {
    NAMED_USER          = 0x0001,
    DEFAULT_USER        = 0x0002,
    ADMINISTRATOR       = 0x0004,
    LAST_LOGGED_ON_USER = 0x0008,
    INVALID_ACCOUNT     = 0x0010,
    LOGON_PROMPT        = 0x0020,
    CURRENT_USER        = 0x0040
} ACCOUNTTYPE;

typedef enum {
    UE_STATE_INIT,
    UE_STATE_BEGIN_WIN95REG,
    UE_STATE_NEXT_WIN95REG,
    UE_STATE_NO_USERS,
    UE_STATE_ADMINISTRATOR,
    UE_STATE_LOGON_PROMPT,
    UE_STATE_DEFAULT_USER,
    UE_STATE_RETURN,
    UE_STATE_CLEANUP,
    UE_STATE_END
} USERENUM_STATE;

typedef struct {
    // Enumeration Output
    TCHAR UserName[MAX_USER_NAME];              // always filled, even for logon prompt or default user
    TCHAR FixedUserName[MAX_USER_NAME];         // always filled, unless caller specifically turns this off
    TCHAR AdminUserName[MAX_USER_NAME];         // filled if AccountType is ADMINISTRATOR
    TCHAR FixedAdminUserName[MAX_USER_NAME];    // filled if AccountType is ADMINISTRATOR
    TCHAR UserDatPath[MAX_TCHAR_PATH];          // is empty if AccountType has INVALID_ACCOUNT
    TCHAR ProfileDirName[MAX_TCHAR_PATH];       // is empty if AccountType has INVALID_ACCOUNT
    TCHAR OrgProfilePath[MAX_TCHAR_PATH];       // is empty if AccountType has INVALID_ACCOUNT
    TCHAR NewProfilePath[MAX_TCHAR_PATH];       // symbolic path because actual path is not known
    ACCOUNTTYPE AccountType;                    // always filled
    BOOL CreateAccountOnly;                     // TRUE for valid accounts that won't be migrated
    HKEY UserRegKey;                            // NULL if AccountType has INVALID_ACCOUNT, or caller specifies no hive flag
    BOOL CommonProfilesEnabled;                 // filled by EnumFirstUser

    // Privates for enumeration
    BOOL EnableNameFix;
    BOOL DoNotMapHive;
    BOOL WantCreateOnly;
    BOOL WantLogonPrompt;

    USERPOSITION pos;
    BOOL DefaultUserHive;
    BOOL RealAdminAccountExists;
    BOOL LastEnumWasAdmin;
    TCHAR LastLoggedOnUserName[MAX_USER_NAME];
    TCHAR CurrentUserName[MAX_USER_NAME];
    PVOID ProfileDirTable;
    USERENUM_STATE State;
    USERENUM_STATE NextState;
} USERENUM, *PUSERENUM;

#define ENUMUSER_ENABLE_NAME_FIX        0x0001
#define ENUMUSER_DO_NOT_MAP_HIVE        0x0002
#define ENUMUSER_ADMINISTRATOR_ALWAYS   0x0004
#define ENUMUSER_NO_LOGON_PROMPT        0x0008

BOOL
EnumFirstUser (
    OUT     PUSERENUM EnumPtr,
    IN      DWORD Flags
    );

BOOL
EnumNextUser (
    IN OUT  PUSERENUM EnumPtr
    );

VOID
EnumUserAbort (
    IN OUT  PUSERENUM EnumPtr
    );

//
// COMMON9X: ntenv.c
//

VOID
InitNtEnvironment (
    VOID
    );

VOID
TerminateNtEnvironment (
    VOID
    );

VOID
InitNtUserEnvironment (
    IN      PUSERENUM UserEnumPtr
    );

VOID
TerminateNtUserEnvironment (
    VOID
    );

VOID
MapNtUserEnvironmentVariable (
    IN      PCSTR Variable,
    IN      PCSTR Value
    );

VOID
MapNtSystemEnvironmentVariable (
    IN      PCSTR Variable,
    IN      PCSTR Value
    );

BOOL
ExpandNtEnvironmentVariables (
    IN      PCSTR SourceString,
    OUT     PSTR DestinationString,     // can be the same as SourceString
    IN      INT DestSizeInBytes
    );

//
// COMMON9X: namefix.c
//

BOOL
ValidateName (
    IN      HWND ParentWnd,             OPTIONAL
    IN      PCTSTR NameGroup,
    IN      PCTSTR NameCandidate
    );

BOOL
ValidateDomainNameChars (
    IN      PCTSTR NameCandidate
    );

BOOL
ValidateUserNameChars (
    IN      PCTSTR NameCandidate
    );

VOID
CreateNameTables (
    VOID
    );

BOOL
IsIncompatibleNamesTableEmpty (
    VOID
    );

BOOL
GetUpgradeComputerName (
    OUT     PTSTR NewComputerName
    );

BOOL
GetUpgradeDomainName (
    OUT     PTSTR ComputerDomainName
    );

BOOL
GetUpgradeWorkgroupName (
    OUT     PTSTR WorkgroupName
    );

BOOL
GetUpgradeUserName (
    IN      PCTSTR User,
    OUT     PTSTR NewUserName
    );

BOOL
WarnAboutBadNames (
    IN      HWND PopupParent
    );

BOOL
IsOriginalDomainNameValid (
    VOID
    );

//
// COMMON9X: twain.c
//

//
// TWAIN support
//

typedef enum {
    TE_INIT,
    TE_BEGIN_ENUM,
    TE_EVALUATE,
    TE_RETURN,
    TE_NEXT,
    TE_END_ENUM,
    TE_DONE
} TWAIN_ENUM_STATE;


typedef struct {
    // externally used members
    TW_STR32    Manufacturer;
    TW_STR32    ProductFamily;
    TW_STR32    DisplayName;
    CHAR        DataSourceModule[MAX_MBCHAR_PATH];

    // internal enum members
    TWAIN_ENUM_STATE State;
    PCTSTR Dir;
    TREE_ENUM Enum;
} TWAINDATASOURCE_ENUM, *PTWAINDATASOURCE_ENUM;


BOOL
EnumFirstTwainDataSource (
    OUT     PTWAINDATASOURCE_ENUM EnumPtr
    );

BOOL
EnumNextTwainDataSource (
    IN OUT  PTWAINDATASOURCE_ENUM EnumPtr
    );

VOID
AbortTwainDataSourceEnum (
    IN OUT  PTWAINDATASOURCE_ENUM EnumPtr
    );


//
// Routine to add paths to Migration paths; defined in migapp\filescan.c
//

VOID
AddMigrationPathEx (
    IN      PCTSTR PathLong,
    IN      DWORD Levels,
    IN      BOOL Win9xOsPath
    );

#define AddMigrationPath(p,l)   AddMigrationPathEx(p,l,FALSE)

//
// Routine to check if a file is a Win32 DLL (migapp\modules.c)
//

BOOL
IsWin32Library (
    IN      PCTSTR ModuleName
    );

//
// Routine to check if a file is a Win32 EXE (migapp\modules.c)
//

BOOL
IsWin32Exe (
    IN      PCTSTR ModuleName
    );


//
// Routine to check if the currently generated report is empty,
// given a Level of filtration
//

BOOL
IsReportEmpty (
    IN      DWORD Level
    );


//
// SYSMIG: userloop.c
//

PCTSTR
ShellFolderGetPath (
    IN      PUSERENUM EnumPtr,
    IN      PCTSTR ShellFolderId
    );


//
// constant to identify the whole subtree of a path
//
#define MAX_DEEP_LEVELS 0xFFFFFFFF




//
// Enumeration structs
//

typedef enum {
    ENUM_STATE_INIT,
    ENUM_STATE_ENUM_FIRST_GROUP_ITEM,
    ENUM_STATE_RETURN_GROUP_ITEM,
    ENUM_STATE_ENUM_NEXT_GROUP_ITEM,
    ENUM_STATE_ENUM_NEXT_GROUP,
    ENUM_STATE_DONE
} INVALID_NAME_STATE;

typedef struct {
    //
    // Enumeration state
    //

    PCTSTR GroupName;
    TCHAR DisplayGroupName[256];
    PCTSTR OriginalName;
    TCHAR NewName[MEMDB_MAX];
    DWORD Identifier;

    //
    // Private enumeration members
    //

    MEMDB_ENUM NameGroup;
    MEMDB_ENUM Name;
    INVALID_NAME_STATE State;
} INVALID_NAME_ENUM, *PINVALID_NAME_ENUM;


//
// Enumeration routines
//

BOOL
EnumFirstInvalidName (
    OUT     PINVALID_NAME_ENUM EnumPtr
    );

BOOL
EnumNextInvalidName (
    IN OUT  PINVALID_NAME_ENUM EnumPtr
    );

//
// Maintenence routines
//

VOID
GetNamesFromIdentifier (
    IN      DWORD Identifier,
    IN      PTSTR NameGroup,        OPTIONAL
    IN      PTSTR OriginalName,     OPTIONAL
    IN      PTSTR NewName           OPTIONAL
    );

VOID
ChangeName (
    IN      DWORD Identifier,
    IN      PCTSTR NewName
    );

VOID
DisableDomainChecks (
    VOID
    );

VOID
EnableDomainChecks (
    VOID
    );

DWORD
GetDomainIdentifier (
    VOID
    );


BOOL
TreatAsGood (
    IN      PCTSTR FullPath
    );


VOID
TerminateWinntSifBuilder (
    VOID
    );



//
// win95upg.inf sections and keys
//

#define SECTION_MIGRATION_FILES         TEXT("MigrationFiles")
#define SECTION_MIGRATION_DIRECTORIES   TEXT("MigrationDirectories")
#define KEY_TEMP_BASE                   TEXT("TempBase")
#define KEY_MIG_EXT_ROOT                TEXT("MigExtRoot")
#define KEY_PATHS_FILE                  TEXT("MigExtPathsFile")
#define WINDIR_SYSTEM_FIXED_FILES       TEXT("WinDirSystemFixedFiles")
#define SYSTEM32_FORCED_MOVE            TEXT("System32ForcedMove")

//
// Other string constants
//
#define STR_WIN95UPG_INF TEXT("win95upg.inf")
#define STR_SYSTEM32 TEXT("System32")

// ticks for all functions

#define TICKS_READ_NT_FILES                     3000
#define TICKS_MISC_MESSAGES                        1
#define TICKS_BUILD_UNATTEND                     700
#define TICKS_PRESERVE_SHELL_ICONS              1300
#define TICKS_DELETE_WIN_DIR_WACK_INF           2100
#define TICKS_MOVE_INI_FILES                      30
#define TICKS_SAVE_DOS_FILES                      10
#define TICKS_INIT_WIN95_REGISTRY                 10
#define TICKS_SAVE_SHARES                        130
#define TICKS_BAD_NAMES_WARNING                   10
#define TICKS_SAVE_MM_SETTINGS_SYSTEM             50
#define TICKS_SAVE_MM_SETTINGS_USER             1100
#define TICKS_CONDITIONAL_INCOMPATIBILITIES      200
#define TICKS_HARDWARE_PROFILE_WARNING            10
#define TICKS_UNSUPPORTED_PROTOCOLS_WARNING       30
#define TICKS_RAS_PREPARE_REPORT                 100
#define TICKS_END_MIGRATION_DLL_PROCESSING       100
#define TICKS_PREPARE_PROCESS_MODULES           5000
#define TICKS_PROCESS_MODULES                  10000
#define TICKS_PROCESS_COMPATIBLE_SECTION         100
#define TICKS_INIT_MIGDB                        6200
#define TICKS_DONE_MIGDB                        4100
#define TICKS_PROCESS_RUN_KEY                     20
#define TICKS_PROCESS_SHELL_SETTINGS              25
#define TICKS_CHECK_NT_DIRS                      300
#define TICKS_MOVE_SYSTEM_DIR                   6200
#define TICKS_PROCESS_LINKS                     3000
#define TICKS_PROCESS_CPLS                      3000
#define TICKS_FILESCAN_DIR_INCREMENT             400
#define TICKS_DOSMIG_PREPARE_REPORT              300
#define TICKS_MIGDLL_QUERYVERSION                500
#define TICKS_MIGDLL_DELTA                      1000
#define TICKS_MOVE_STATIC_FILES                   15
#define TICKS_COPY_STATIC_FILES                   15
#define TICKS_USERPROFILE_MIGRATION              250
#define TICKS_MOVE_SYSTEMREGISTRY                 10
#define TICKS_OLEREG                            8000
#define TICKS_TWAIN                              100
#define TICKS_BACKUP_LAYOUT_OUTPUT              7000
#define TICKS_SPACECHECK                        5000
#define TICKS_JOYSTICK_DETECTION                  50
#define TICKS_RECYCLEBINS                       2000
#define TICKS_GATHER_IME_INFO                   2000
#define TICKS_INIT_HLP_PROCESSING                 50
#define TICKS_ANSWER_FILE_DETECTION               20
#define TICKS_INIT_APP_COMPAT                   1000
#define TICKS_DONE_APP_COMPAT                    100
#define TICKS_GATHERDEAD                         120
#define TICKS_CREATE_FILE_LISTS                 7000

#define TICKS_PREPAREPNPIDLIST                      450
#define TICKS_ADDDEFAULTCLEANUPDIRS                 155
#define TICKS_INITINIPROCESSING                     255
#define TICKS_DELETESTATICFILES                     320
#define TICKS_PROCESSMIGRATIONSECTIONS              2400
#define TICKS_REPORTMAPIIFNOTHANDLED                200
#define TICKS_FUSIONFILES                           300
#define TICKS_REPORTDARWINIFNOTHANDLED              200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\lnkstub\pch.h ===
#define MIGISOL_INCLUDES
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\lnkstub\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDD_PASSWORD_DLG                102
#define IDI_KEYS                        103
#define IDD_ADMIN_PASSWORD_DLG          103
#define IDD_LNK_STUB_DLG                103
#define IDD_INCOMP_DLG                  103
#define IDD_REINST_DLG                  104
#define IDD_PREINSTUTIL_DLG             105
#define IDD_SIMILAROSFUNCT_DLG          106
#define IDD_IHVUTIL_DLG                 107
#define IDC_LIST                        1000
#define IDC_EDIT1                       1001
#define IDC_PASSWORD                    1001
#define IDC_EDIT2                       1002
#define IDC_CONFIRM                     1002
#define IDC_REMOVE                      1006
#define IDC_REPORTBUTTON                1007
#define IDC_PROGICON                    1010
#define IDC_REPORTTEXT                  1011
#define IDC_REINSTTEXT                  1015
#define IDC_INCOMPTEXT                  1016
#define IDC_PREINSTUTILTEXT             1017
#define IDC_SIMILAROSFUNCTEXT           1018
#define IDC_DLG_SIZE_SEPARATOR          1019
#define IDC_IHVUTILTEXT                 1020
#define IDC_OPTIONS                     2000
#define IDC_RESTORE                     2002
#define IDC_START                       2003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\devupgrd\makefile.inc ===
$(O)\migrate.res: migrate.rc

$(O)\msg.mc: $(PRIVATE_INC_PATH)\vendinfo.mc migrate.mc
        copy /b migrate.mc+$(PRIVATE_INC_PATH)\vendinfo.mc $(O)\msg.mc

$(O)\msg.h $(O)\msg00001.bin $(O)\msg.rc: $(O)\msg.mc
        mc -A -v -h .\$(O) -r .\$(O) $(O)\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\inc\w95res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by M:\nt\base\ntsetup\win95upg\w95upg\ui\visualc.rc
//
#define IDD_SUPPLY_DRIVER_PAGE2         100
#define IDD_SUPPLY_MIGDLL_PAGE2         101
#define IDD_NAME_CHANGE_DLG             102
#define IDD_TRUST_FAIL_DLG              103
#define IDD_BADHARDDRIVE_PAGE           104
#define IDD_BADCDROM_PAGE               105
#define IDD_RESULTS_PAGE2               106
#define IDD_HWCOMPDAT_PAGE              107
#define IDD_BACKUP_PAGE                 108
#define IDC_OUR_HAND                    109
#define IDD_SCANNING_PAGE               110
#define IDD_LAST_PAGE                   111
#define IDD_CONSIDERING_DLG             112
#define IDD_SEARCHING_DLG               115
#define IDD_NAME_COLLISION_PAGE         116
#define IDD_DOMAIN_PAGE                 117
#define IDD_BAD_TIMEZONE_PAGE           118
#define IDD_DOMAIN_CREDENTIALS_DLG      119
#define IDD_DISKSPACE_DLG               120
#define IDD_TWOBUTTON_DLG               122
#define IDD_APPBLOCK_DLG                123
#define IDD_PREDOMAIN_PAGE              124
#define IDD_BACKUP_YES_NO_PAGE          127
#define IDD_BACKUP_DRIVE_SELECTION_PAGE 129
#define IDD_BACKUP_IMPOSSIBLE_INFO_PAGE 130
#define IDD_INCOMPATIBLE_DEVICES        131
#define IDD_BACKUP_IMPOSSIBLE_INFO_1_PAGE 132
#define IDD_REPORT_HELP                 133
#define IDI_INCOMPHW                    134
#define IDI_CHECKMARK                   136
#define IDT_TITLE                       1000
#define IDT_SUBTITLE                    1025
#define IDT_SUPER_TITLE                 1028
#define IDC_NAMES                       1035
#define IDC_USER_NAME_LABEL             1120
#define IDC_PASSWORD_LABEL              1121
#define IDC_DOMAIN_LABEL                1122
#define IDC_USER_NAME                   1123
#define IDC_NOTE_LABEL3                 1126
#define IDC_INSTRUCTIONS                1127
#define IDC_SPACE_NEEDED                1130
#define IDQUIT                          1131
#define IDC_TWOBUTTON_TEXT              1132
#define IDBUTTON1                       1133
#define IDBUTTON2                       1134
#define IDI_TWOBUTTON_ICON              1135
#define IDC_DOMAIN_HELP                 1137
#define IDC_JOIN_DOMAIN                 1138
#define IDC_JOIN_WORKGROUP              1139
#define IDC_DIALUP                      1140
#define IDC_ROOT_LIST                   1141
#define IDC_HIDEDETAILS                 1142
#define IDC_DISKSPACE_FIRST             1143
#define IDC_FULL_REPORT                 1143
#define IDC_DISKSPACE_FIRST2            1144
#define IDC_REPORT_HEADER               1144
#define IDC_REPORT_HEADER_ICON          1145
#define IDC_COMBO1                      1146
#define IDC_CRITICAL_ISSUES             1147
#define IDC_ALL_ISSUES                  1148
#define IDA_FIND_FILE                   1500
#define IDA_FIND_COMP                   1501
#define IDI_WATCH_OUT                   2000
#define IDI_FLOPPY_INSTALL              2001
#define IDI_INSTALL_LIST                2002
#define IDI_UNINSTALL                   2003
#define IDI_APPWIZ                      2004
#define IDI_NEW_DEVICE                  2005
#define IDI_BACKUP                      2006
#define IDI_PC_USERS                    2007
#define IDI_DOT                         2008
#define IDI_SMALL_WARNING               2009
#define IDI_NETWORK                     2010
#define IDI_CDROM_WARNING               2011
#define IDI_HD_WARNING                  2012
#define IDI_WARN                        2013
#define IDI_INCOMPATIBLE                2014
#define IDI_WORLD                       2015
#define IDI_SAMPLE_ICON                 2016
#define IDI_STOP                        2017
#define IDI_BULLET                      2017
#define IDC_PLACEHOLDER                 3001
#define IDC_NAME_LIST                   3002
#define IDC_REMOVE                      3003
#define IDC_ANIMATE                     3004
#define IDC_ORIGINAL_NAME               3005
#define IDC_NEW_NAME                    3006
#define IDC_CHANGE                      3007
#define IDC_CATEGORY                    3009
#define IDC_CURRENTNAME                 3010
#define IDC_NEWNAME                     3011
#define IDC_IGNORE                      3012
#define IDC_NO_MIGDLLS                  3013
#define IDC_SKIP                        3013
#define IDC_DOMAIN                      3014
#define IDC_HAVE_MIGDLLS                3015
#define IDC_TRUST_IT                    3016
#define IDC_SPECIFY_DOMAIN              3017
#define IDC_COMPUTER_NAME               3018
#define IDC_DONT_TRUST_IT               3019
#define IDC_TRUST_ANY                   3020
#define IDC_TITLE                       3021
#define IDC_PACK_LIST                   3022
#define IDC_HOTLINK                     3023
#define IDC_HOTLINK2                    3024
#define IDC_PASSWORD                    3025
#define IDC_TIMEZONE_LIST               3030
#define IDC_CURTIMEZONE                 3031
#define IDC_TEXT1                       3032
#define IDC_TEXT2                       3033
#define IDC_TEXT3                       3034
#define IDC_TEXT4                       3035
#define IDC_TEXT6                       3036
#define IDC_HAVE_DISK                   3037
#define IDC_PROGRESS                    3038
#define IDC_TEXT5                       3038
#define IDC_COMPONENT                   3039
#define IDC_SUBCOMPONENT                3040
#define IDC_LIST                        3041
#define IDC_DIALOG_ICON                 3042
#define IDC_REPORTNOTE                  3043
#define IDC_PRINT                       3044
#define IDC_SAVE_AS                     3045
#define IDC_DISKSPACE                   3046
#define IDC_DETAILS                     3046
#define IDC_BACKUP_YES                  3047
#define IDC_BACKUP_NO                   3048
#define IDC_BACKUP_FIRST                3049
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1148
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\lnkstub\lnkstub.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    lnkstub.c

Abstract:

    Implements a simple application that replaces incompatible applications
    detected dynamically during Win9x upgrade to Windows 2000.

Author:

    Calin Negreanu (calinn) 25-Feb-1999

Revision History:

--*/

#include "pch.h"
#include "resource.h"
#include "msg.h"
#include <winbasep.h>
#include <shellapi.h>

//
// Globals
//

HINSTANCE g_hInst;
HANDLE g_hHeap;
BOOL g_RemoveLnk = FALSE;
BOOL g_RestoreLnk = FALSE;
BOOL g_RunOrgApp = FALSE;
HICON g_hIcon = NULL;
BOOL g_ReportAvailable = FALSE;
BOOL g_StartAppAvailable = FALSE;
BOOL g_RemoveLnkAvailable = FALSE;
BOOL g_RestoreLnkAvailable = FALSE;
PCTSTR g_ReportPath = NULL;
DWORD g_Announcement = ACT_INC_NOBADAPPS;
DWORD g_Availability = 1;
PCTSTR g_ActualLnkName = NULL;

//
// Library prototypes
//

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    );


//
// Local prototypes
//

BOOL
CALLBACK
DialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );


//
// Implementation
//


VOID
pSetProgramIcon (
    PCTSTR      OrigIconPath,
    INT         OrigIconNr
    )
{
    HINSTANCE iconFile;

    iconFile = LoadLibraryEx (OrigIconPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (iconFile) {
        g_hIcon = LoadIcon (iconFile, MAKEINTRESOURCE(OrigIconNr));
        FreeLibrary (iconFile);
    }
    if (g_hIcon == NULL) {
        g_hIcon = LoadIcon (NULL, IDI_EXCLAMATION);
    }
}

BOOL
pIsFileAccessible (
    IN      PCTSTR FileName,
    IN      DWORD DesiredAccess
    )
{
    HANDLE fileHandle;

    fileHandle = CreateFile (
                    FileName,
                    DesiredAccess,
                    FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    CloseHandle (fileHandle);
    return TRUE;
}

BOOL
pRestoreLnk (
    IN      PCTSTR LnkName,
    IN      PCTSTR LnkTarget,
    IN      PCTSTR LnkArgs,
    IN      PCTSTR LnkWorkDir,
    IN      PCTSTR LnkIconPath,
    IN      INT LnkIconNr,
    IN      INT ShowMode
    )
{
    IShellLink   *psl = NULL;
    IPersistFile *ppf = NULL;
    BOOL result = FALSE;

    HRESULT comResult;

    comResult = CoInitialize (NULL);
    if (FAILED (comResult)) {
        return FALSE;
    }

    __try {
        if (!DoesFileExist (LnkName)) {
            __leave;
        }
        if (((LnkTarget   == NULL) || (LnkTarget   [0] == 0)) &&
            ((LnkWorkDir  == NULL) || (LnkWorkDir  [0] == 0)) &&
            ((LnkIconPath == NULL) || (LnkIconPath [0] == 0)) &&
            (LnkIconNr == 0)
            ) {
            __leave;
        }

        comResult = CoCreateInstance (
                        &CLSID_ShellLink,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        &IID_IShellLink,
                        (void **) &psl);
        if (comResult != S_OK) {
            __leave;
        }

        comResult = psl->lpVtbl->QueryInterface (psl, &IID_IPersistFile, (void **) &ppf);
        if (comResult != S_OK) {
            __leave;
        }

        //
        // We only load if the file was really a LNK
        //
        comResult = ppf->lpVtbl->Load(ppf, LnkName, STGM_READ);
        if (comResult != S_OK) {
            __leave;
        }

        if (LnkTarget != NULL) {
            comResult = psl->lpVtbl->SetPath (psl, LnkTarget);
            if (comResult != S_OK) {
                __leave;
            }
        }
        if (LnkArgs != NULL) {
            comResult = psl->lpVtbl->SetArguments (psl, LnkArgs);
            if (comResult != S_OK) {
                __leave;
            }
        }
        if (LnkWorkDir != NULL) {
            comResult = psl->lpVtbl->SetWorkingDirectory (psl, LnkWorkDir);
            if (comResult != S_OK) {
                __leave;
            }
        }
        if (LnkIconPath != NULL) {
            comResult = psl->lpVtbl->SetIconLocation (psl, LnkIconPath, LnkIconNr);
            if (comResult != S_OK) {
                __leave;
            }
        }

        comResult = psl->lpVtbl->SetShowCmd (psl, ShowMode);
        if (comResult != S_OK) {
            __leave;
        }

        comResult = ppf->lpVtbl->Save (ppf, LnkName, FALSE);
        if (comResult != S_OK) {
            __leave;
        }

        comResult = ppf->lpVtbl->SaveCompleted (ppf, LnkName);
        if (comResult != S_OK) {
            __leave;
        }
        result = TRUE;
    }
    __finally {
        if (ppf != NULL) {
            ppf->lpVtbl->Release (ppf);
            ppf = NULL;
        }
        if (psl != NULL) {
            psl->lpVtbl->Release (psl);
            psl = NULL;
        }
        CoUninitialize ();
    }
    return result;
}

INT
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    PSTR AnsiCmdLine,
    INT CmdShow
    )

/*++

Routine Description:

  The entry point to lnkstub.exe.  All the work is done in a dialog box,
  so no message loop is necessary.

Arguments:

  hInstance     - The instance handle of this EXE
  hPrevInstance - The previous instance handle of this EXE if it is
                  running, or NULL if no other instances exist.
  AnsiCmdLine   - The command line (ANSI version)
  CmdShow       - The ShowWindow command passed by the shell

Return Value:

  Returns -1 if an error occurred, or 0 if the exe completed.

--*/

{
    UINT Result;
    TCHAR winDir [MAX_PATH];
    STARTUPINFO startInfo;
    PCTSTR OrigLnkName = NULL;
    PCTSTR OrigTarget = NULL;
    PCTSTR OrigArgs = NULL;
    PCTSTR OrigWorkDir = NULL;
    PCTSTR OrigIconPath = NULL;
    INT OrigIconNr = 0;
    INT OrigShowMode = SW_NORMAL;
    PCTSTR LnkStubDatFile = NULL;
    PBYTE LnkStubDatPtr = NULL;
    PBYTE LnkStubDatPtrTmp = NULL;
    HANDLE StubMapHandle = NULL;
    HANDLE StubFileHandle = NULL;
    INT ofsHeader;
    PDWORD offset;
    FILETIME fileTime;
    FILETIME reqFileTime;
    WIN32_FIND_DATA findData;
    BOOL shouldRestoreLnk = FALSE;
    PCTSTR reqFilePath = NULL;
    PCTSTR reqFileFullPath = NULL;
    PCTSTR oldFileSpec = NULL;
    PTSTR oldFilePtr = NULL;
    INITCOMMONCONTROLSEX init = {sizeof (INITCOMMONCONTROLSEX), 0};

    InitCommonControlsEx (&init);

    g_hInst = hInstance;
    g_hHeap = GetProcessHeap();

    MigUtil_Entry (hInstance, DLL_PROCESS_ATTACH, NULL);

    if (GetWindowsDirectory (winDir, MAX_PATH)) {
        g_ReportPath = JoinPaths (winDir, S_UPGRADEHTM);
        g_ReportAvailable = DoesFileExist (g_ReportPath) && pIsFileAccessible (g_ReportPath, GENERIC_READ);
        LnkStubDatFile = JoinPaths (winDir, S_LNKSTUB_DAT);
    }

    // let's see if we can get the LNK that launched us.
    GetStartupInfo (&startInfo);
    if (startInfo.dwFlags & STARTF_TITLEISLINKNAME) {
        g_ActualLnkName = DuplicatePathString (startInfo.lpTitle, 0);
        g_RemoveLnkAvailable = DoesFileExist (g_ActualLnkName) && pIsFileAccessible (g_ActualLnkName, GENERIC_READ|GENERIC_WRITE);
    }

    // now let's see if we can find data about our original LNK
    if (LnkStubDatFile) {
        __try {

            LnkStubDatPtr = MapFileIntoMemoryEx (LnkStubDatFile, &StubMapHandle, &StubFileHandle, TRUE);
            if (LnkStubDatPtr) {
                ofsHeader = atoi (AnsiCmdLine) - 1;
                if (ofsHeader >= 0) {

                    //
                    // Read details about original LNK. See w95upgnt\filemig.c
                    // for format of lnkstub.dat
                    //

                    offset = (PDWORD) (LnkStubDatPtr + ofsHeader * sizeof (DWORD));

                    OrigLnkName  = (PCTSTR) (LnkStubDatPtr + *offset);
                    OrigTarget   = GetEndOfString (OrigLnkName) + 1;
                    OrigArgs     = GetEndOfString (OrigTarget) + 1;
                    OrigWorkDir  = GetEndOfString (OrigArgs) + 1;
                    OrigIconPath = GetEndOfString (OrigWorkDir) + 1;
                    LnkStubDatPtrTmp = (PBYTE) (GetEndOfString (OrigIconPath) + 1);

                    OrigIconNr = *((PINT) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (INT);

                    OrigShowMode = *((PINT) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (INT);

                    g_Announcement = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    g_Availability = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    fileTime.dwLowDateTime = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    fileTime.dwHighDateTime = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    reqFilePath = (PTSTR)LnkStubDatPtrTmp;

                    //
                    // Continue reading [in a loop] the list of required
                    // files. This is how lnkstub detects changes from a
                    // reinstall or uninstall, and auto-removes itself.
                    //

                    shouldRestoreLnk = FALSE;
                    while (reqFilePath [0]) {
                        if (!shouldRestoreLnk) {
                            oldFileSpec = DuplicatePathString (OrigTarget, 0);
                            oldFilePtr = (PTSTR)GetFileNameFromPath (oldFileSpec);
                            if (oldFilePtr) {
                                *oldFilePtr = 0;
                            }
                            reqFileFullPath = JoinPaths (oldFileSpec, reqFilePath);
                            if (!DoesFileExistEx (reqFileFullPath, &findData)) {
                                shouldRestoreLnk = FALSE;
                            }
                            FreePathString (reqFileFullPath);
                            FreePathString (oldFileSpec);
                        }

                        LnkStubDatPtrTmp = (PBYTE) (GetEndOfString (reqFilePath) + 1);

                        reqFileTime.dwLowDateTime = *((PDWORD) LnkStubDatPtrTmp);
                        LnkStubDatPtrTmp += sizeof (DWORD);

                        reqFileTime.dwHighDateTime = *((PDWORD) LnkStubDatPtrTmp);
                        LnkStubDatPtrTmp += sizeof (DWORD);

                        reqFilePath = (PTSTR)LnkStubDatPtrTmp;

                        if (!shouldRestoreLnk) {
                            if ((findData.ftLastWriteTime.dwLowDateTime != reqFileTime.dwLowDateTime) ||
                                (findData.ftLastWriteTime.dwHighDateTime != reqFileTime.dwHighDateTime)
                                ) {
                                shouldRestoreLnk = TRUE;
                            }
                        }
                    }

                    //
                    // Save data from memory mapped lnkstub.dat into path pool
                    //

                    OrigLnkName = DuplicatePathString (OrigLnkName, 0);
                    OrigTarget = DuplicatePathString (OrigTarget, 0);
                    OrigArgs = DuplicatePathString (OrigArgs, 0);
                    OrigWorkDir = DuplicatePathString (OrigWorkDir, 0);
                    OrigIconPath = DuplicatePathString (OrigIconPath, 0);
                    g_StartAppAvailable = DoesFileExistEx (OrigTarget, &findData);
                    g_RestoreLnkAvailable = g_RemoveLnkAvailable && g_StartAppAvailable;
                    if (!shouldRestoreLnk) {
                        if ((findData.ftLastWriteTime.dwLowDateTime != fileTime.dwLowDateTime) ||
                            (findData.ftLastWriteTime.dwHighDateTime != fileTime.dwHighDateTime)
                            ) {
                            shouldRestoreLnk = TRUE;
                        }
                    }
                    shouldRestoreLnk = shouldRestoreLnk && g_StartAppAvailable;
                }
            }
        } __except (1) {
            UnmapFile (LnkStubDatPtr, StubMapHandle, StubFileHandle);
            LnkStubDatPtr = NULL;
            OrigLnkName = NULL;
            OrigTarget = NULL;
            OrigArgs = NULL;
            OrigWorkDir = NULL;
            OrigIconPath = NULL;
            g_StartAppAvailable = FALSE;
            g_RestoreLnkAvailable = FALSE;
        }

        if (LnkStubDatPtr) {
            UnmapFile (LnkStubDatPtr, StubMapHandle, StubFileHandle);
            LnkStubDatPtr = NULL;
        }
    }

    if (OrigIconPath && *OrigIconPath) {
        pSetProgramIcon (OrigIconPath, OrigIconNr);
    } else {
        pSetProgramIcon (OrigTarget, OrigIconNr);
    }

    if (shouldRestoreLnk) {
        g_RestoreLnk = TRUE;
        g_RunOrgApp = TRUE;
    } else {
        switch (g_Announcement) {
        case ACT_REINSTALL:
        case ACT_REINSTALL_BLOCK:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_REINST_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        case ACT_INC_PREINSTUTIL:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_PREINSTUTIL_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        case ACT_INC_SIMILAROSFUNC:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_SIMILAROSFUNCT_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        case ACT_INC_IHVUTIL:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_IHVUTIL_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        default:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_INCOMP_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        }
    }

    if (g_RestoreLnk) {
        MYASSERT (!g_RemoveLnk);
        if (!pRestoreLnk (
                g_ActualLnkName,
                OrigTarget,
                OrigArgs,
                OrigWorkDir,
                OrigIconPath,
                OrigIconNr-1,
                OrigShowMode
                )) {
            DEBUGMSG ((DBG_ERROR, "Cannot restore %s", g_ActualLnkName));
        }
    }

    if (g_RunOrgApp) {
        MYASSERT (!g_RemoveLnk);
        if (ShellExecute (NULL, NULL, OrigTarget, OrigArgs, OrigWorkDir, SW_SHOWDEFAULT) <= (HINSTANCE)32) {
            DEBUGMSG ((DBG_ERROR, "Cannot start %s", OrigTarget));
        }
    }

    if (g_RemoveLnk) {
        if (!DeleteFile (g_ActualLnkName)) {
            DEBUGMSG ((DBG_ERROR, "Cannot remove %s", g_ActualLnkName));
        }
    }

    if (OrigIconPath) {
        FreePathString (OrigIconPath);
    }

    if (OrigWorkDir) {
        FreePathString (OrigWorkDir);
    }

    if (OrigArgs) {
        FreePathString (OrigArgs);
    }

    if (OrigTarget) {
        FreePathString (OrigTarget);
    }

    if (OrigLnkName) {
        FreePathString (OrigLnkName);
    }

    if (g_ActualLnkName) {
        FreePathString (g_ActualLnkName);
        g_ActualLnkName = NULL;
    }

    if (LnkStubDatFile) {
        FreePathString (LnkStubDatFile);
    }

    if (g_ReportPath) {
        FreePathString (g_ReportPath);
    }

    MigUtil_Entry (hInstance, DLL_PROCESS_DETACH, NULL);

    return 0;
}


BOOL
CALLBACK
DialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  DialogProc is the dialog procedure for the main dialog.

Arguments:

  hdlg   - Dialog window handle
  uMsg   - Message to process
  wParam - Message-specific
  lParam - Message-specific

Return Value:

  TRUE if the message was processed, or FALSE if the message should be
  processed by the OS.

--*/

{
    static RECT LargeWndRect;
    static RECT SmallWndRect;
    static TCHAR LargeCaption[128];
    static TCHAR SmallCaption[128];
    static BOOL LargeWnd;
    RECT ButtonRect;
    PTSTR lnkName = NULL;
    PTSTR extPtr = NULL;
    BOOL showReport = TRUE;

    HINSTANCE result;

    switch (uMsg) {

    case WM_INITDIALOG:
        if (g_ActualLnkName) {
            lnkName = DuplicatePathString (GetFileNameFromPath (g_ActualLnkName), 0);
            if (lnkName) {
                extPtr = (PTSTR)GetFileExtensionFromPath (lnkName);
                if (extPtr) {
                    extPtr = _tcsdec (lnkName, extPtr);
                    if (extPtr) {
                        *extPtr = 0;
                        SetWindowText (hdlg, lnkName);
                    }
                }
                FreePathString (lnkName);
            }
        }
        showReport = g_Availability && g_ReportAvailable;
        GetWindowText (GetDlgItem (hdlg, IDC_OPTIONS), LargeCaption, 125);
        GetWindowText (GetDlgItem (hdlg, IDC_OPTIONS), SmallCaption, 125);
        _tcscat (LargeCaption, TEXT(" <<"));
        _tcscat (SmallCaption, TEXT(" >>"));
        SetDlgItemText (hdlg, IDC_OPTIONS, SmallCaption);

        GetWindowRect (hdlg, &LargeWndRect);
        GetWindowRect (GetDlgItem (hdlg, IDC_DLG_SIZE_SEPARATOR), &ButtonRect);
        CopyMemory (&SmallWndRect, &LargeWndRect, sizeof (RECT));
        SmallWndRect.bottom = ButtonRect.bottom;

        SetWindowPos (
            hdlg,
            NULL,
            0,
            0,
            SmallWndRect.right-SmallWndRect.left,
            SmallWndRect.bottom-SmallWndRect.top,
            SWP_NOMOVE|SWP_NOZORDER
            );
        EnableWindow (GetDlgItem (hdlg, IDC_START), FALSE);
        EnableWindow (GetDlgItem (hdlg, IDC_REMOVE), FALSE);
        EnableWindow (GetDlgItem (hdlg, IDC_RESTORE), FALSE);
        LargeWnd = FALSE;
        if (!showReport) {
            EnableWindow (GetDlgItem (hdlg, IDC_REPORTBUTTON), FALSE);
            ShowWindow (GetDlgItem (hdlg, IDC_REPORTTEXT), SW_HIDE);
        } else {
            EnableWindow (GetDlgItem (hdlg, IDC_REPORTBUTTON), TRUE);
            ShowWindow (GetDlgItem (hdlg, IDC_REPORTTEXT), SW_SHOW);
        }
        SendDlgItemMessage (hdlg, IDC_PROGICON, STM_SETICON, (LPARAM)g_hIcon, 0);
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog (hdlg, LOWORD (wParam));
            break;
        case IDC_REPORTBUTTON:
            if (HIWORD (wParam) == BN_CLICKED) {
                result = ShellExecute (
                            hdlg,
                            NULL,
                            g_ReportPath,
                            NULL,
                            NULL,
                            SW_SHOW
                            );
            }
            break;
        case IDC_OPTIONS:
            if (HIWORD (wParam) == BN_CLICKED) {
                LargeWnd = !LargeWnd;
                SetWindowPos (
                    hdlg,
                    NULL,
                    0,
                    0,
                    LargeWnd?LargeWndRect.right-LargeWndRect.left:SmallWndRect.right-SmallWndRect.left,
                    LargeWnd?LargeWndRect.bottom-LargeWndRect.top:SmallWndRect.bottom-SmallWndRect.top,
                    SWP_NOMOVE|SWP_NOZORDER
                    );
                SetDlgItemText (hdlg, IDC_OPTIONS, LargeWnd?LargeCaption:SmallCaption);
                EnableWindow (GetDlgItem (hdlg, IDC_START), LargeWnd & g_StartAppAvailable);
                EnableWindow (GetDlgItem (hdlg, IDC_REMOVE), LargeWnd & g_RemoveLnkAvailable);
                EnableWindow (GetDlgItem (hdlg, IDC_RESTORE), LargeWnd & g_RestoreLnkAvailable);
            }
            break;
        case IDC_START:
            if (HIWORD (wParam) == BN_CLICKED) {
                g_RunOrgApp = TRUE;
                EndDialog (hdlg, LOWORD (wParam));
            }
            break;
        case IDC_REMOVE:
            if (HIWORD (wParam) == BN_CLICKED) {
                g_RemoveLnk = TRUE;
                EndDialog (hdlg, LOWORD (wParam));
            }
            break;
        case IDC_RESTORE:
            if (HIWORD (wParam) == BN_CLICKED) {
                g_RestoreLnk = TRUE;
                EndDialog (hdlg, LOWORD (wParam));
            }
            break;
        }
        break;

    case WM_DESTROY:

        break;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\devupgrd\migrate.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.h

Abstract:

    Includes the headers needed throughout the Setup migration DLL

Author:

    Calin Negreanu (calinn) 22-Dec-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "chartype.h"

//
// Windows
//

#include <windows.h>
#include <winnt.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <shlobj.h>
#include <objidl.h>

//
// Setup
//

#include <setupbat.h>

//
// Common includes
//

#include "common.h"
#include "migutil.h"
#include "fileenum.h"
#include "memdb.h"
#include "unattend.h"
#include "progbar.h"
#include "regops.h"
#include "fileops.h"
#include "win95reg.h"
#include "snapshot.h"
#include "linkpif.h"
#include "migdb.h"
#include "..\w95upg\migapp\migdbp.h"



//
// includes for code that runs only on Win9x
//

#include <ras.h>
#include <pif.h>        /* windows\inc */
#include <tlhelp32.h>

#include <winnt32p.h>

#include "init9x.h"
#include "w95upg.h"
#include "buildinf.h"
#include "msg.h"
#include "config.h"
#include "migdlls.h"
#include "hwcomp.h"
#include "sysmig.h"
#include "msgmgr.h"
#include "migapp.h"
#include "rasmig.h"
#include "dosmig.h"
#include "drives.h"
#include "timezone.h"
#include "migdb.h"


//
// DLL globals
//

extern PCSTR g_MigrateInfPath;
extern HINF g_MigrateInf;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\devupgrd\pch.h ===
#include "migrate.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\devupgrd\migrate.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.c

Abstract:

    This source file implements the windows 9x DEVUPGRD migration dll.

Author:

    Marc R. Whitten (marcw) 07-January-2000

Revision History:

    Ovidiu Temereanca (ovidiut) 04-Aug-2000     Fixed bugs and support for INF-less paths

--*/


#include "pch.h"

VENDORINFO g_VendorInfo = {"", "", "", ""};
CHAR g_ProductId [MAX_PATH];
PCSTR g_MigrateInfPath = NULL;
HINF g_MigrateInf = INVALID_HANDLE_VALUE;
HANDLE g_hHeap;
HINSTANCE g_hInst;
TCHAR g_DllDir[MAX_TCHAR_PATH];


#define D_DLLVERSION    2




#undef DEFMAC

#define MEMDB_CATEGORY_DLLENTRIES       "MigDllEntries"
#define S_ACTIVE                        "Active"
#define DBG_MIGDLL                      "SMIGDLL"

//
// the temp file that records original sources location
//
#define S_MIGRATEDATA                   "migrate.dat"
#define S_MIGRATEDATW                   L"migrate.dat"
#define S_SECTION_DATAA                 "Data"
#define S_SECTION_DATAW                 L"Data"
#define S_KEY_SOURCESA                  "Sources"
#define S_KEY_SOURCESW                  L"Sources"

PCSTR g_WorkingDir = NULL;
PCSTR g_DataFileA = NULL;
PCWSTR g_DataFileW = NULL;

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
POOLHANDLE g_GlobalPool;

#define DEVREGKEY "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\UpgradeDrivers"


BOOL
WINAPI
DllMain (
    IN      HINSTANCE DllInstance,
    IN      ULONG  ReasonForCall,
    IN      LPVOID Reserved
    )
{
    PSTR p;
    BOOL result = TRUE;

    switch (ReasonForCall)  {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
        //
        DisableThreadLibraryCalls (DllInstance);

        //
        // Global init
        //
        g_hHeap = GetProcessHeap();
        g_hInst = DllInstance;

        //
        // Init common controls
        //
        InitCommonControls();

        //
        // Get DLL path and strip directory
        //
        GetModuleFileNameA (DllInstance, g_DllDir, MAX_TCHAR_PATH);
        p = strrchr (g_DllDir, '\\');
        MYASSERT (p);
        if (p) {
            *p = 0;
        }

        if (!MigUtil_Entry (DllInstance, DLL_PROCESS_ATTACH, NULL)) {
            return FALSE;
        }

        //
        // Allocate a global pool
        //
        g_GlobalPool = PoolMemInitNamedPool ("Global Pool");


        break;

    case DLL_PROCESS_DETACH:

        if (g_MigrateInfPath) {
            FreePathStringA (g_MigrateInfPath);
            g_MigrateInfPath = NULL;
        }

        if (g_MigrateInf != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (g_MigrateInf);
            g_MigrateInf = INVALID_HANDLE_VALUE;
        }

        //
        // Free standard pools
        //
        if (g_GlobalPool) {
            PoolMemDestroyPool (g_GlobalPool);
            g_GlobalPool = NULL;
        }

        MigUtil_Entry (DllInstance, DLL_PROCESS_DETACH, NULL);

        break;
    }

    return result;
}

LONG
CALLBACK
QueryVersion (
    OUT     PCSTR *ProductID,
    OUT     PUINT DllVersion,
    OUT     PINT *CodePageArray,       OPTIONAL
    OUT     PCSTR *ExeNamesBuf,        OPTIONAL
    OUT     PVENDORINFO *VendorInfo
    )
{

    LONG result = ERROR_NOT_INSTALLED;
    PCSTR tempStr;
    HANDLE h;

    //
    // Fill the data.
    //
    tempStr = GetStringResourceA (MSG_PRODUCT_ID);
    if (tempStr) {
        StringCopyByteCountA (g_ProductId, tempStr, MAX_PATH);
        FreeStringResourceA (tempStr);
    }

    *ProductID  = g_ProductId;
    *DllVersion = D_DLLVERSION;
    *CodePageArray = NULL;
    *VendorInfo = &g_VendorInfo;

    // now get the VendorInfo data from resources
    tempStr = GetStringResourceA (MSG_VI_COMPANY_NAME);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.CompanyName, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_NUMBER);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportNumber, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_URL);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportUrl, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_INSTRUCTIONS);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.InstructionsToUser, tempStr, 1024);
        FreeStringResourceA (tempStr);
    }

    *ExeNamesBuf = NULL;


    //
    // See if the registry key exists. If it does not, return ERROR_NOT_INSTALLED.
    //
    h = OpenRegKeyStr (DEVREGKEY);
    if (h && h != INVALID_HANDLE_VALUE) {
        result = ERROR_SUCCESS;
        CloseRegKey (h);
    }


    return result;
}


LONG
CALLBACK
Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories,
    IN      PCSTR MediaDir
    )
{
    //
    // remember source directory, so it can be removed on cleanup
    //
    g_DataFileA = JoinPathsExA (g_GlobalPool, WorkingDirectory, S_MIGRATEDATA);
    WritePrivateProfileStringA (S_SECTION_DATAA, S_KEY_SOURCESA, MediaDir, g_DataFileA);
    g_WorkingDir = DuplicatePathString (WorkingDirectory, 0);
    g_MigrateInfPath = JoinPathsExA (g_GlobalPool, WorkingDirectory, S_MIGRATE_INF);
    g_MigrateInf = InfOpenInfFileA (g_MigrateInfPath);


    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName,
            PVOID Reserved
    )
{

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
            PVOID Reserved
    )
{

    HANDLE h;
    REGVALUE_ENUM eValue;
    REGTREE_ENUM eTree;
    BOOL found;
    PSTR value;
    PSTR p;
    PSTR end;
    PSTR dir;
    CHAR deviceInf [MEMDB_MAX];
    HASHTABLE table;
    PSTR pnpId;
    DWORD attr;

    table = HtAllocWithData (sizeof (PSTR));
    if (!table) {
        return ERROR_OUTOFMEMORY;
    }
    __try {

        //
        // Gather list of pnpids registered on this machine.
        //
        h = OpenRegKeyStrA (DEVREGKEY);
        if (!h || h == INVALID_HANDLE_VALUE) {
            return ERROR_NOT_INSTALLED;
        }

        if (EnumFirstRegValue (&eValue, h)) {
            do {

                p = GetRegValueStringA (h, eValue.ValueName);
                if (!p) {
                    continue;
                }

                value = PoolMemDuplicateStringA (g_GlobalPool, p);
                MemFree (g_hHeap, 0, p);
                if (!value) {
                    return ERROR_OUTOFMEMORY;
                }

                HtAddStringAndDataA (table, eValue.ValueName, &value);


            } while (EnumNextRegValue (&eValue));
        }

        CloseRegKey (h);

        //
        // Now, enumerate the registry.
        //
        if (EnumFirstRegKeyInTreeA (&eTree, "HKLM\\Enum")) {
            do {
                //
                // For each registry key, look to see if we have a compatible id or hardware id
                // that is in our hash table.
                //
                found = FALSE;
                value = GetRegValueStringA (eTree.CurrentKey->KeyHandle, "HardwareId");

                if (value) {

                    if (HtFindStringAndDataA (table, value, &dir)) {
                        found = TRUE;
                        pnpId = PoolMemDuplicateStringA (g_GlobalPool, value);
                    } else {
                        p = value;
                        while (p && !found) {
                            end = _mbschr (p, ',');
                            if (end) {
                                *end = 0;
                            }

                            if (HtFindStringAndDataA (table, p, &dir)) {
                                found = TRUE;
                                pnpId = PoolMemDuplicateStringA (g_GlobalPool, p);
                            }
                            else {
                                p = end;
                                if (p) {
                                    p++;
                                }
                            }
                        }
                    }

                    MemFree (g_hHeap, 0, value);
                }

                if (!found) {

                    value = GetRegValueStringA (eTree.CurrentKey->KeyHandle, "CompatibleIds");

                    if (value) {

                        if (HtFindStringAndDataA (table, value, &dir)) {
                            found = TRUE;
                            pnpId = PoolMemDuplicateStringA (g_GlobalPool, value);
                        }
                        p = value;
                        while (p && !found) {
                            end = _mbschr (p, ',');
                            if (end) {
                                *end = 0;
                            }

                            if (HtFindStringAndDataA (table, p, &dir)) {
                                found = TRUE;
                                pnpId = PoolMemDuplicateStringA (g_GlobalPool, p);
                            }
                            else {
                                p = end;
                                if (p) {
                                    p++;
                                }
                            }
                        }

                        MemFree (g_hHeap, 0, value);
                    }
                }

                if (found) {

                    //
                    // build path to deviceInf (no OriginalInstallMedia since the directory will be blown away)
                    //
                    lstrcpyA (deviceInf, dir);

                    //
                    // GUI setup expects a path to the actual INF, not a directory,
                    // so let's fix it if this is the case
                    //
                    attr = GetFileAttributesA (deviceInf);
                    if (attr == (DWORD)-1) {
                        //
                        // invalid path spec; ignore it
                        //
                        continue;
                    }

                    if (attr & FILE_ATTRIBUTE_DIRECTORY) {
                        //
                        // just pick up the first INF
                        //
                        HANDLE h;
                        WIN32_FIND_DATAA fd;
                        PSTR pattern;

                        pattern = JoinPathsExA (g_GlobalPool, deviceInf, "*.inf");
                        h = FindFirstFileA (pattern, &fd);

                        if (h == INVALID_HANDLE_VALUE) {
                            //
                            // no INF found here; skip
                            //
                            continue;
                        }
                        FindClose (h);

                        //
                        // build path to the INF; also handle the case when deviceInf ends with a \
                        //
                        pattern = JoinPathsExA (g_GlobalPool, deviceInf, fd.cFileName);
                        lstrcpyA (deviceInf, pattern);
                    }

                    //
                    // Handle the key (remove the message from the compatibility report).
                    //
                    WritePrivateProfileStringA (
                        "HANDLED",
                        eTree.FullKeyName,
                        "REGISTRY",
                        g_MigrateInfPath
                        );

                    //
                    // Add to the appropriate section of the SIF file.
                    //
                    WritePrivateProfileString (
                        "DeviceDrivers",
                        pnpId,
                        deviceInf,
                        UnattendFile
                        );

                    //
                    // Flush to disk.
                    //
                    WritePrivateProfileString (NULL, NULL, NULL, g_MigrateInfPath);
                    WritePrivateProfileString (NULL, NULL, NULL, UnattendFile);
                }

            } while (EnumNextRegKeyInTree (&eTree));
        }
    }
    __finally {

        //
        // Clean up resources.
        //
        HtFree (table);
    }


    return ERROR_SUCCESS;
}


LONG
CALLBACK
InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories,
            PVOID Reserved
    )
{
    g_DataFileW = JoinPathsExW (g_GlobalPool, WorkingDirectory, S_MIGRATEDATW);

    return ERROR_SUCCESS;
}



LONG
CALLBACK
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName,
            PVOID Reserved
    )
{
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            PVOID Reserved
    )
{
    WCHAR SourceDirectory[MAX_PATH + 2];

    //
    // remove original sources directories
    //
    if (GetPrivateProfileStringW (
            S_SECTION_DATAW,
            S_KEY_SOURCESW,
            L"",
            SourceDirectory,
            MAX_PATH + 2,
            g_DataFileW
            )) {
        RemoveCompleteDirectoryW (SourceDirectory);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\pview\poolmem.c ===
#include "poolmem.h"


 
// Tree Memory Allocation structure.


typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    DWORD                 Index;
    DWORD                 Size;
    PPOOLMEMORYBLOCK      NextBlock;
    PPOOLMEMORYBLOCK      PrevBlock;
    PBYTE                 RawMemory;  
};

typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;
    HANDLE           Heap;
} POOLHEADER, *PPOOLHEADER;


BOOL
PoolMemAddMemory (
    IN  POOLHANDLE  Handle,
    IN  DWORD       Size
    )
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    DWORD               sizeNeeded;

    assert(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > POOLMEMORYBLOCKSIZE) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = POOLMEMORYBLOCKSIZE;
    }

    allocedMemory = HeapAlloc(poolHeader -> Heap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
    
        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;


    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;
}


POOLHANDLE
WINAPI
PoolMemInitPool (
    )
{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;
    HANDLE      procHeap;


    procHeap = GetProcessHeap();
    //
    // Allocate the header of this pool.
    //
    header = HeapAlloc(procHeap,0,sizeof(POOLHEADER));

    if (header) {

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> PoolHead = NULL;
        header -> Heap = procHeap;

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = PoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            HeapFree(header -> Heap,0,header);
            header = NULL;
        }

    }
    return (POOLHANDLE) header;
}


VOID
WINAPI
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree; 
    PPOOLHEADER      poolHeader;

    assert(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {
    
        nextBlock = blockToFree->NextBlock;
        HeapFree(poolHeader -> Heap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    HeapFree(poolHeader -> Heap,0,poolHeader);

}

PVOID
WINAPI
PoolMemGetAlignedMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size,
    IN DWORD      AlignSize
    )

{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    DWORD               sizeNeeded;
    DWORD               padLength;

    assert(poolHeader != NULL);

    currentBlock = poolHeader -> PoolHead;

    // Determine if more memory is needed, attempt to add if needed.
    sizeNeeded = Size;

    if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

        haveEnoughMemory = PoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);
        currentBlock = poolHeader -> PoolHead;
    }

    // If there is enough memory available, return it.
    if (haveEnoughMemory) {
        if (AlignSize) {

            padLength = (DWORD) currentBlock + sizeof(POOLMEMORYBLOCK) 
                + currentBlock -> Index;
            currentBlock -> Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

        }
      
         
        //Now, get the address of the memory to return.
        rMemory = (PVOID) 
            &(currentBlock->RawMemory[currentBlock -> Index]);
 
        currentBlock->Index += sizeNeeded;
    }

    return rMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\pview\poolmem.h ===
#ifndef POOLMEM_H
#define POOLMEM_H

#define STRICT
#define LEAN_AND_MEAN
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <mbstring.h>


typedef LPVOID POOLHANDLE;


#define POOLMEMORYBLOCKSIZE 8192



POOLHANDLE WINAPI PoolMemInitPool ();
VOID       WINAPI PoolMemDestroyPool (IN POOLHANDLE Handle);
LPVOID     WINAPI PoolMemGetAlignedMemory(IN POOLHANDLE Handle, IN DWORD Size, IN DWORD AlignSize);


#define PoolMemCreateString(h,x)        ((LPTSTR) PoolMemGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PoolMemCreateDword(h)           ((PDWORD) PoolMemGetMemory((h),sizeof(DWORD)))


__inline
LPVOID 
PoolMemGetMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{

    return PoolMemGetAlignedMemory(Handle,Size,0);

}

__inline
LPTSTR 
PoolMemCreateStringA ( 
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(CHAR),sizeof(CHAR));
}

__inline
LPWSTR 
PoolMemCreateStringW (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPWSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(WCHAR),sizeof(WCHAR));
}


__inline
PTSTR 
PoolMemDuplicateStringA (
    IN POOLHANDLE    Handle,
    IN LPCSTR       StringToCopy
    )

{

    
    DWORD   stringLength;
    PSTR    rString;

    assert(StringToCopy);

    stringLength = (DWORD) _mbschr(StringToCopy,0) - (DWORD) StringToCopy + 1;
    rString      = PoolMemGetAlignedMemory(Handle,stringLength,sizeof(CHAR));

    if (rString) {

        _mbscpy(rString,StringToCopy);
    }

    return rString;
}


__inline
PWSTR 
PoolMemDuplicateStringW (
    IN POOLHANDLE    Handle,
    IN LPCWSTR       StringToCopy
    )

{

    
    DWORD    stringLength;
    PWSTR    rString;

    assert(StringToCopy);

    stringLength = ((wcslen(StringToCopy)+1)*sizeof(WCHAR));
    rString      = PoolMemGetAlignedMemory(Handle,stringLength,sizeof(WCHAR));

    if (rString) {

        wcscpy(rString,StringToCopy);
    }

    return rString;
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\pview\miginf.h ===
#ifndef MIGINF_H
#define MIGINF_H


#define SECTION_MIGRATIONPATHS  "Migration Paths"
#define SECTION_EXCLUDEDPATHS   "Excluded Paths"
#define SECTION_HANDLED         "Handled"
#define SECTION_MOVED           "Moved"
#define SECTION_INCOMPATIBLE    "Incompatible Messages"
#define SECTION_DISKSPACEUSED   "NT Disk Space Requirements"


typedef enum {

    MIG_FIRSTTYPE,
    MIG_FILE,
    MIG_PATH,
    MIG_REGKEY,
    MIG_MESSAGE,
    MIG_LASTTYPE

} MIGTYPE, *PMIGTYPE;

typedef struct tagMIGINFSECTIONENUM {

    PCSTR        Key;
    PCSTR        Value;
    PVOID        EnumKey;            // Internal.

} MIGINFSECTIONENUM, * PMIGINFSECTIONENUM;



BOOL MigInf_Initialize (VOID);
VOID MigInf_CleanUp (VOID);
BOOL MigInf_PathIsExcluded (IN PCSTR Path);
BOOL MigInf_FirstInSection(IN PCSTR SectionName, OUT PMIGINFSECTIONENUM Enum);
BOOL MigInf_NextInSection(IN OUT PMIGINFSECTIONENUM Enum);
BOOL MigInf_AddObject (IN MIGTYPE ObjectType,IN PCSTR SectionString,IN PCSTR ParamOne,IN PCSTR ParamTwo);
BOOL MigInf_WriteInfToDisk (VOID);
BOOL MigInf_UseSpace (IN PCSTR DriveRoot,IN LONGLONG Space);



//
// Macros for common miginf actions.
//

//
// Adding Objects.
//
#define MigInf_AddHandledFile(file)                      MigInf_AddObject(MIGTYPE_FILE,SECTION_HANDLED,(file),NULL)
#define MigInf_AddHandledDirectory(directory)            MigInf_AddObject(MIGTYPE_PATH,SECTION_HANDLED,(directory),NULL)
#define MigInf_AddHandledRegistry(key,value)             MigInf_AddObject(MIGTYPE_REGKEY,SECTION_HANDLED,(key),(value))

#define MigInf_AddMovedFile(from,to)                     MigInf_AddObject(MIGTYPE_FILE,SECTION_MOVED,(from),(to))
#define MigInf_AddMovedDirectory(from,to)                MigInf_AddObject(MIGTYPE_PATH,SECTION_MOVED,(from),(to))

#define MigInf_AddMessage(msgSection,msg)                MigInf_AddObject(MIGTYPE_MESSAGE,SECTION_INCOMPATIBLE,(msgSection),(msg))

#define MigInf_AddMessageFile(msgSection,file)           MigInf_AddObject(MIGTYPE_FILE,(msgSection),(file),NULL)
#define MigInf_AddMessageDirectory(msgSection,directory) MigInf_AddObject(MIGTYPE_PATH,(msgSection,(directory),NULL)
#define MigInf_AddMessageRegistry(msgSection,key,value)  MigInf_AddObject(MIGTYPE_REGKEY,(msgSection),(key),(value))

//
// Enumerating Sections
//
#define MigInf_GetFirstMigrationPath(Enum)               MigInf_FirstInSection(SECTION_MIGRATIONPATHS,(Enum))
#define MigInf_GetFirstExcludedPath(Enum)                MigInf_FirstInSection(SECTION_EXCLUDEDPATHS,(Enum))



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\pview\pviewmig.c ===
#define STRICT
#define LEAN_AND_MEAN
#include <windows.h>
#include <setupapi.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <mbstring.h>
#include "miginf.h"


#define DIRECTORYKEY                "SOFTWARE\\Microsoft\\DevStudio\\5.0\\Products\\Microsoft Visual C++"
#define DIRECTORYVALUE               "ProductDir"
#define DIR_95SPECIFIC               "\\bin\\win95"
#define FILE_PVIEW                   "pview.exe"
#define MESSAGE                                                                                 \
    "PVIEW.EXE has been found in one or more directories outside of your Visual C++ 5.0"        \
    " installation directory. These copies will not be updated with the NT version."            \

#define MESSAGE_SECTION              "Microsoft\\Visual C++ 5.0\\Process Viewer"
#define SIZENEEDED                   100000L        

#define CP_USASCII          1252

//
// 9x side globals.
//
const CHAR  g_ProductId[]                       = {"Microsoft Visual C++ 5.0"};
UINT        g_DllVersion                        = 1;
INT         g_CodePageArray[]                   = {CP_USASCII,-1};
CHAR        g_ExeNamesBuffer[]                  = {"pview95.exe\0""\0"};

//
// Nt side globals.
//

//
// Uncomment next line to get popups.
//
//#define MYDEBUG
#ifdef  MYDEBUG
#   define INFO(x)     (MessageBoxA(NULL,(x),"PVIEW Sample Migration Dll",MB_OK | MB_ICONINFORMATION))
#else
#   define INFO(x)
#endif




static
BOOL
PathIsInPath(
    IN PCSTR    SubPath,
    IN PCSTR    ParentPath
    )
{
    DWORD parentLength;
    BOOL  rInPath;

    //
    // This function assumes both parameters are non-NULL.
    //
    assert(SubPath);
    assert(ParentPath);
    
    parentLength = _mbslen(ParentPath);

    //
    // A path is considered "in" another path if the path is in the ParentPath
    // or a subdirectory of it.
    //
    rInPath = !_mbsnicmp(SubPath,ParentPath,parentLength);

    if (rInPath) {
        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\';
    }

    return rInPath;

}


static
PSTR
GetPviewDirectoryNt (
    VOID
    )
{
    HKEY    softwareKey;
    LONG    rc;
    LONG    valueType;
    LONG    sizeNeeded;
    PSTR    rString = NULL;

    //
    // First, open the key.
    //
    rc = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        DIRECTORYKEY,
        0,
        KEY_READ,
        &softwareKey
        );

    
    if (rc == ERROR_SUCCESS) {
        
        //
        // Determine how large of a buffer to allocate.
        //
        
        rc = RegQueryValueEx(
            softwareKey,
            DIRECTORYVALUE,
            0,
            &valueType,
            NULL,
            &sizeNeeded
            );

        //
        // Allocate enough space for the registry path, with the additional
        // subpath to Visual C++ 5.0's win 95 specific binaries.
        //
        rString = LocalAlloc(0,sizeNeeded + lstrlen(DIR_95SPECIFIC) + 1);
        
    }
    
    if (rc == ERROR_SUCCESS && rString != NULL) {
        
        //
        // Read in the buffer.
        //
        
        rc = RegQueryValueEx(
            softwareKey,
            DIRECTORYVALUE,
            0,
            &valueType,
            (PBYTE) rString,
            &sizeNeeded
            );

        if (rc == ERROR_SUCCESS) {
            
            if (valueType != REG_SZ) {
                rc = ERROR_INVALID_DATATYPE;
            }
        }
    }


    //
    // If we didn't complete successfully, set the last error, and free the
    // return string if it was allocated.
    //
    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);

        if (rString) {
            LocalFree(rString);
            rString = NULL;
        }
    }

    return rString;
}


static
PSTR
GetPviewDirectory9x (
    VOID
    )
{
    HKEY    softwareKey;
    LONG    rc;
    LONG    valueType;
    LONG    sizeNeeded;
    PSTR    rString = NULL;

    //
    // First, open the key.
    //
    rc = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        DIRECTORYKEY,
        0,
        KEY_READ,
        &softwareKey
        );

    
    if (rc == ERROR_SUCCESS) {
        
        //
        // Determine how large of a buffer to allocate.
        //
        
        rc = RegQueryValueEx(
            softwareKey,
            DIRECTORYVALUE,
            0,
            &valueType,
            NULL,
            &sizeNeeded
            );

        //
        // Allocate enough space for the registry path, with the additional
        // subpath to Visual C++ 5.0's win 95 specific binaries.
        //
        rString = LocalAlloc(0,sizeNeeded + lstrlen(DIR_95SPECIFIC) + 1);
        
    }
    
    if (rc == ERROR_SUCCESS && rString != NULL) {
        
        //
        // Read in the buffer.
        //
        
        rc = RegQueryValueEx(
            softwareKey,
            DIRECTORYVALUE,
            0,
            &valueType,
            (PBYTE) rString,
            &sizeNeeded
            );

        if (rc == ERROR_SUCCESS) {
            
            if (valueType == REG_SZ) {

                //
                // We have successfully read in the value of the installation
                // directory into rString. Now, all we need to do is tack on
                // the win 95 specific portion that we care about.
                //
                lstrcat(rString,DIR_95SPECIFIC);

            }
            else {
                rc = ERROR_INVALID_DATATYPE;
            }
        }
    }


    //
    // If we didn't complete successfully, set the last error, and free the
    // return string if it was allocated.
    //
    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);

        if (rString) {
            LocalFree(rString);
            rString = NULL;
        }
    }

    return rString;
}

static
LONG
CheckForInstalledComponents (
    VOID
    )
{
    BOOL    rc;
    HKEY    softwareKey;


    //
    // Attempt to open the key.
    //
    rc = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        DIRECTORYKEY,
        0,
        KEY_READ,
        &softwareKey
        );

    //
    // If the key exists, then assume that Microsoft Visual C++ 5.0 is installed.
    //
    RegCloseKey(softwareKey);

    return rc;
}



BOOL
WINAPI
DllMain (
    IN      HANDLE Instance,
    IN      ULONG  Reason,
    IN      LPVOID Reserved
    )
{


    switch (Reason)  {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        //
        // Ensure that the MigInf structure is cleaned up before unloading this DLL.
        //
        MigInf_CleanUp();
        break;
    }

    return TRUE;
}

LONG
CALLBACK 
QueryVersion (
    OUT LPCSTR  *   ProductId,
    OUT LPUINT      DllVersion,
    OUT LPINT   *   CodePageArray,	OPTIONAL
    OUT LPCSTR  *   ExeNamesBuf,	OPTIONAL
        LPVOID      Reserved
    )
{

    LONG rc;

    INFO("Entering QueryVersion.");

    assert(ProductId);
    assert(DllVersion);
    assert(CodePageArray);
    assert(ExeNamesBuf);

    //
    // Setup is calling us to query our version information and to identify if 
    // we need processing. We always need to provide the product ID and the 
    // DLL version.
    //
    *ProductId = g_ProductId;
    *DllVersion = g_DllVersion;
    
    //
    // Check to see if there is anything to do.
    //
    if (CheckForInstalledComponents() == ERROR_SUCCESS) {
        
        //
        // There are installed components. Return the information Setup is
        // asking for.
        //
        *CodePageArray  = g_CodePageArray; // Use the CP_ACP code page for conversion to unicode,
        *ExeNamesBuf    = g_ExeNamesBuffer;
        
        //
        // Since there is work to do, return EXIT_SUCCESS. This informs Setup
        // that this dll does require processing during migration.
        //
        rc = ERROR_SUCCESS;
    }
    else {
        rc = ERROR_NOT_INSTALLED;
    }

    return rc;

}



LONG
CALLBACK
Initialize9x (
    IN      LPCSTR   WorkingDirectory,
    IN      LPCSTR   SourceDirectories,
            LPVOID   Reserved
            )
{
    LONG rc;

    //
    // Setup guarantees that the source directories parameter is valid.
    //
    assert(SourceDirectories);

    INFO("Entering Initialize9x.");

    //
    // Initialize the MigInf structure.
    //
    if (!MigInf_Initialize()) {
        rc = GetLastError();
    }
    else {
        rc = ERROR_SUCCESS;
    }
    

    return rc;
}


LONG
CALLBACK
MigrateUser9x (
    IN      HWND        ParentWnd,
    IN      LPCSTR      UnattendFile,
    IN      HKEY        UserRegKey,
    IN      LPCSTR      UserName,
            LPVOID      Reserved
    )
{
    //
    // Setup guarantees that UnattendFile,UserRegKey will be non-NULL
    //
    assert(UnattendFile);
    assert(UserRegKey);
    INFO("Entering MigrateUser9x.");
    

    //
    // Nothing to do per user, so, return ERROR_NO_MORE_FILES
    //
    return ERROR_NOT_INSTALLED;
}


LONG
CALLBACK
MigrateSystem9x (
    IN      HWND        ParentWnd,
    IN      LPCSTR      UnattendFile,
            LPVOID      Reserved
    )
{
    LONG                rc                  = EXIT_SUCCESS;
    PSTR                visualCppDirectory  = NULL;
    MIGINFSECTIONENUM   sectionEnum;
    BOOL                firstMessage        = TRUE;
    PCSTR               messageSection      = NULL;

    //
    // Setup guarantees that UnattendFile will be non-NULL.
    //
    assert(UnattendFile);

    INFO("Entering MigrateSystem9x");

    //
    // Since we are in this function, Initialize9x MUST have returned ERROR_SUCCESS.
    // Microsoft Visual C++ is installed on this machine. 
    //

    //
    // Initialize the miginf module to handle interfacing with Migrate.Inf and retrieve
    // the installation directory for Visual C++.
    //
    visualCppDirectory = GetPviewDirectory9x();
    if (!visualCppDirectory) {
        rc = GetLastError();
    }
    else {

        //
        // The migration INF was successfully initialized. See if there is anything for 
        // us to do. There is work to be done if (1) the [Migration Paths] section of 
        // Migrate.inf contains some paths (Indicating that setup found some of the files
        // we asked it to look for in ExeNamesBuf) and (2) The Visual CPP Install directory
        // is not in the Excluded Paths Section.
        //

        

        if (MigInf_FirstInSection(SECTION_MIGRATIONPATHS,&sectionEnum) 
            && !MigInf_PathIsExcluded(visualCppDirectory)) {

            //
            // All checks are good. We have work to do.
            // we need to sift through the files that
            // Setup returned in the Migration paths section. If the files
            // returned are in the installation directory, we will write them
            // to both the [Handled Files] sections and the [Moved Files] 
            // sections. If not, we will write the file to the [Handled Files]
            // section and then write a message to the [Incompatible Messages]
            // section. This will allow us to override the message that 
            // Setup is providing for these files with a more meaningful one.
            //
            do {

                if (PathIsInPath(sectionEnum.Key,visualCppDirectory)) {

                    //
                    // This file is in our installation path. We'll be handling it.
                    //
                    if (!MigInf_AddObject(
                            MIG_FILE,
                            SECTION_HANDLED,
                            sectionEnum.Key,
                            NULL
                            )) {

                        rc = ERROR_CANTWRITE;
                        break;
                    }

                    //
                    // We also need to note the amount of space that we will use.
                    //
                    if (!MigInf_UseSpace(sectionEnum.Key,SIZENEEDED)) {
                        rc = ERROR_CANTWRITE;
                        break;
                    }

                }
                else {

                    //
                    // This file is not in our installation path.
                    //
                    if (firstMessage) {

                        //
                        // We'll only add one message to the incompatible messages 
                        // section, no matter how many PVIEW's we find outside of 
                        // the installation directory.  However, we'll add all of 
                        // those files to the section that controls that message.
                        // That way, the message will always appear unless _every_ 
                        // file in that section has been handled by something 
                        // (i.e. another migration DLL.)
                        //

                        firstMessage    = FALSE;

                        if (!MigInf_AddObject(
                                MIG_MESSAGE,
                                SECTION_INCOMPATIBLE,
                                MESSAGE_SECTION,
                                MESSAGE
                                )) {

                            rc = ERROR_CANTWRITE;
                            break;
                        }
                    }
                    

                    if (!MigInf_AddObject(
                            MIG_FILE,
                            MESSAGE_SECTION,
                            sectionEnum.Key,
                            NULL
                            )) {
                        rc = ERROR_CANTWRITE;
                        break;
                    }
                }
                
            } while (MigInf_NextInSection(&sectionEnum));
        } 
        else {

            //
            // There is nothing for us to do.
            //
            rc = ERROR_NOT_INSTALLED;
        }

        MigInf_WriteInfToDisk();
    }


    //
    // Free the memory allocated in GetVisualCppDirectory.
    //
    
    if (visualCppDirectory) {
        LocalFree(visualCppDirectory);
    }
    
    return rc;
}

LONG
CALLBACK
InitializeNT (
    IN      LPCWSTR     WorkingDirectory,
    IN      LPCWSTR     SourceDirectory,
            LPVOID      Reserved
    )
{

    //
    // Setup ensures that WorkingDirectory and SourceDirectory will be non-NULL.
    //
    assert(WorkingDirectory != NULL && SourceDirectory != NULL);


    //
    // We do not need to do anything in this call. Simply return ERROR_SUCCES
    //
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUserNT (
    IN HINF         UnattendInfHandle,
    IN HKEY         UserRegHandle,
    IN LPCWSTR      UserName,
       LPVOID       Reserved
    )
{

    //
    // Setup guarantees that UnattendInfHandle and UserRegHandle are non-NULL and valid.
    // UserName can be NULL, however, for the default user.
    //
    assert(UnattendInfHandle);


    //
    // Nothing to do per user. Simply return ERROR_SUCCESS.
    // (Note the difference in return codes between MigrateUser9x and MigrateUserNT.)
    //
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT (
    IN HINF         UnattendInfHandle,
       LPVOID       Reserved
    )
{
    LONG    rc;
    PSTR    pviewDir;
    CHAR    fromPath[MAX_PATH];
    CHAR    toPath[MAX_PATH];

    //
    // Setup guarantees that UnattendInfHandle is non-NULL and is valid.
    //
    assert(UnattendInfHandle && UnattendInfHandle != INVALID_HANDLE_VALUE);

    //
    // If we have gotten to this point, we know that we are installed. All we need to do is copy 
    // the NT version of PVIEW into the installation directory of Visual C++ 5.0 Note that we do
    // not replace the 9x version as a normal Visual C++ install on NT would have the 9x of PVIEW
    // as well.
    //
    pviewDir = GetPviewDirectoryNt();

    if (pviewDir) {

        sprintf(fromPath,".\\%s",FILE_PVIEW);
        sprintf(toPath,"%s\\%s",pviewDir,FILE_PVIEW);

        if (!CopyFileA(fromPath,toPath,FALSE)) {
            rc = GetLastError();
        }
        else {
            rc = ERROR_SUCCESS;
        }

    }
    else {
        rc = GetLastError();
    }
        
    return rc = ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\pview\miginf.c ===
#include "poolmem.h"
#include "miginf.h"
#include <setupapi.h>

#define MIGRATEINF              ".\\migrate.inf"
#define INITIALBUFFERSIZE       1024
#define MIGINF_NOCREATE         FALSE
#define MIGINF_CREATE           TRUE


typedef struct tagMIGOBJECT MIGOBJECT, *PMIGOBJECT;
struct tagMIGOBJECT {

    PSTR        Key;
    PSTR        Value;
    
    PMIGOBJECT  Next;
};

typedef struct tagMIGSECTION MIGSECTION, * PMIGSECTION;
struct tagMIGSECTION {

    PSTR        Name;
    PMIGOBJECT  Items;

    PMIGSECTION Next;
};

PMIGSECTION g_MigrationInf;
POOLHANDLE  g_Pool = NULL;


static
PCSTR
pGetTypeAsString (
    IN MIGTYPE Type
    )
{
    //
    // Note: Strings must be in the same order as the 
    // corresponding types in the MIGTYPE enumeration above.
    //
    static PCHAR typeStrings[] = {
            "FIRST - Invalid",
            "File",
            "Path",
            "Registry",
            "Message - Invalid",
            "LAST - Invalid"
        };

    assert(Type > MIG_FIRSTTYPE && Type < MIG_LASTTYPE);

    return typeStrings[Type];
}

static
PMIGSECTION 
pFindSection (
    IN PCSTR SectionString,
    IN BOOL  CreateIfNotExist
    )
{
    PMIGSECTION rSection;

    //
    // We assume that SectionString is not null.
    //
    assert(SectionString);

    rSection = g_MigrationInf;

    while (rSection && (_mbsicmp(rSection -> Name,SectionString) != 0)) {

        //
        // Continue looking.
        //
        rSection = rSection -> Next;
    }
        
    if (!rSection && CreateIfNotExist) {
        //
        // No section was found matching this name. Make a new section and add it 
        // to the list.
        //
        rSection = PoolMemGetMemory(g_Pool,sizeof(MIGSECTION));
        if (rSection) {

            ZeroMemory(rSection,sizeof(MIGSECTION));
            rSection -> Name  = PoolMemDuplicateStringA(g_Pool,SectionString);
            rSection -> Next  = g_MigrationInf;
            g_MigrationInf    = rSection;

            if (!rSection -> Name) {
                //
                // Something went wrong when we tried to duplicate the SectionString.
                // NULL out the rSection so that the caller doesn't get back a 
                // malformed section object.
                //
                rSection = NULL;
            }
        }
    }

    return rSection;
}

static
BOOL
pPathIsInPath(
    IN PCSTR    SubPath,
    IN PCSTR    ParentPath
    )
{
    DWORD parentLength;
    BOOL  rInPath;

    //
    // This function assumes both parameters are non-NULL.
    //
    assert(SubPath);
    assert(ParentPath);
    
    parentLength = _mbslen(ParentPath);

    //
    // A path is considered "in" another path if the path is in the ParentPath
    // or a subdirectory of it.
    //
    rInPath = !_mbsnicmp(SubPath,ParentPath,parentLength);

    if (rInPath) {
        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\';
    }

    return rInPath;

}

static
DWORD
pGetMbsSize (
    IN  LPCSTR  String
    )
{
    DWORD rLength;
    
    rLength = (DWORD) _mbschr(String,0) - (DWORD) String + 1;

    return rLength;

}


static
LPSTR 
pEscapeString (
    IN  MIGTYPE Type,
    OUT LPSTR   EscapedString, 
    IN  LPCSTR  String
    )

{
    LPSTR   stringStart;
    static  CHAR exclusions[] = "[]~,;%\"";
    INT     currentChar;

    //
    // We assume that all parameters are valid.
    //
    assert(EscapedString && String);

    stringStart = EscapedString;

    while (*String)  {
        currentChar = _mbsnextc (String);
        
        if (Type == MIG_REGKEY) {
            
            //
            // Registry keys require more complex escaping than do normal INF strings.
            //
            if (!_ismbcprint (currentChar) || _mbschr (exclusions, currentChar)) {
                
                //
                // Escape unprintable or excluded character
                //
                wsprintfA (EscapedString, "~%X~", currentChar);
                EscapedString = _mbschr (EscapedString, 0);
                String = _mbsinc (String);
            }
            else {
                //
                // Copy multibyte character
                //
                if (isleadbyte (*String)) {
                    *EscapedString = *String;
                    EscapedString++;
                    String++;
                }
                
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
        }
        else {

            //
            // Escaping is pretty simple for non-registry keys. All we do is double up
            // quotes and percents.
            //
            if (*String == '\"' || *String == '%') {

                *EscapedString = *String;
                EscapedString++;
            }
            
            //
            // Copy multibyte character
            //
            if (isleadbyte (*String)) {
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
            
            *EscapedString = *String;
            EscapedString++;
            String++;
        }
    }

    //
    // Ensure that returned string is NULL terminated.
    //
    *EscapedString = 0;

    return stringStart;
}


static
PSTR
pGetValueString (
    IN MIGTYPE    ObjectType,
    IN LPCSTR     StringOne,
    IN LPCSTR     StringTwo
    )
{
    static PSTR     buffer;
    static DWORD    bufferSize;
    DWORD           maxLength;
    PSTR            bufferEnd;
    
    //
    // This function assumes that StringOne exists.
    //
    assert(StringOne);

    if (ObjectType == MIG_REGKEY) {
        //
        // Size: size of both strings, plus the size of the quotes, plus the size of the brackets 
        // for the value, * 6. This is the maximum size one of these could grow to, if every 
        // character had to be escaped out.
        //
        maxLength = (pGetMbsSize(StringOne) + (StringTwo ? pGetMbsSize(StringTwo) + 2 : 0)) * 6 + 2;
    }
    else {
        //
        // Size: size of the string * 2 (The max size if every char was a '%' or '"' plus the quotes.
        //
        maxLength = pGetMbsSize(StringOne) * 2 + 2;
    }

    if (maxLength > bufferSize) {

        //
        // Initialize our buffer, or create a larger one.
        //
        bufferSize = (maxLength > INITIALBUFFERSIZE) ? maxLength : INITIALBUFFERSIZE;
        buffer = PoolMemCreateStringA(g_Pool,bufferSize);
    }

    if (buffer != NULL) {
        
        //
        // Insert initial quote.
        //
        *buffer = '"';
 
        //
        // Massage the string to ensure it is a valid INF file string.
        //
        pEscapeString(ObjectType,_mbsinc(buffer),StringOne);

        //
        // If this is a REGISTRY entry, then we also need to add the value part of the string, 
        // if one was specified (In StringTwo)
        //

        if (ObjectType == MIG_REGKEY && StringTwo) {

            //
            // Add the opening bracket.
            //
            bufferEnd = _mbschr(buffer,0);
            *bufferEnd = '[';
            
            //
            // Add the value string in, again making sure the string is valid for an INF file.
            //
            pEscapeString(ObjectType,_mbsinc(bufferEnd),StringTwo);

            //
            // Now, add the closing braket.
            //
            bufferEnd = _mbschr(buffer,0);
            *bufferEnd = ']';

            //
            // Terminate the string.
            //
            bufferEnd = _mbsinc(bufferEnd);
            *bufferEnd = 0;
        }

        //
        // Add the final quote.
        //
        bufferEnd = _mbschr(buffer,0);
        *bufferEnd = '"';
        bufferEnd = _mbsinc(bufferEnd);
        *bufferEnd = 0;
    }
    
    return buffer;
}

static
BOOL
pCreateMigObject (
    IN MIGTYPE          ObjectType,
    IN PCSTR            ParamOne,
    IN PCSTR            ParamTwo,
    IN PMIGSECTION      Section
    )
{
    BOOL            rSuccess;
    PMIGOBJECT      newObject = NULL;

    //
    // pCreateMigObject uses a set of hueristics to correctly assemble an object. 
    // These hueristics are based on the ObjectType and the contents of ParamTwo.
    // 
    // ObjectType       ParamTwo      Key                   Value
    // -------------------------------------------------------------------------
    // MIG_REGKEY       <any>         ParamOne[ParamTwo]    Registry
    // <other>          NULL          ParamOne              <ObjectType As String>
    // <other>          non-NULL      ParamOne              ParamTwo
    //
    //


    if (Section) {

        //
        // First, create an object...
        //
        newObject = PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));

        if (newObject) {

            if (ObjectType == MIG_REGKEY) {

                newObject -> Key = 
                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,ParamTwo));

                newObject -> Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
            }
            else {
                
                newObject -> Key = 
                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,NULL));

                if (ParamTwo) {
                    newObject -> Value =
                        PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamTwo,NULL));
                }
                else {

                    newObject -> Value = 
                        PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
                }
            }
        }
    }


    if (newObject && newObject -> Key && newObject -> Value) {

        //
        // The object has been successfully created. Link it into the section.
        //
        newObject -> Next = Section -> Items;
        Section -> Items = newObject;
        rSuccess = TRUE;
    }
    else {
        rSuccess = FALSE;
    }

    return newObject && newObject -> Key && newObject -> Value;
}


static
BOOL
pWriteInfSectionToDisk (
    IN PMIGSECTION Section
    )
{
    PMIGOBJECT curObject;
    BOOL       rSuccess = TRUE;

    if (Section) {

        curObject = Section -> Items;

        while (curObject && rSuccess) {

            if (Section -> Name && curObject -> Key && curObject -> Value) {
            
                rSuccess = WritePrivateProfileString(
                    Section   -> Name,
                    curObject -> Key, 
                    curObject -> Value,
                    MIGRATEINF
                    );
            }

            curObject = curObject -> Next;
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


static
BOOL
pBuildListFromSection (
    IN PCSTR    SectionString
    )
{
    HINF            infHandle;
    PMIGSECTION     section;
    PMIGOBJECT      currentObject;
    INFCONTEXT      ic;
    DWORD           size;
    BOOL            rSuccess = TRUE;

    //
    // This function assumes that Section is non-NULL.
    //
    assert(SectionString);

    currentObject = NULL;
    
    //
    // First find the section specified.
    //
    section = pFindSection(SectionString,MIGINF_CREATE);

    if (section) {
        
        infHandle = SetupOpenInfFileA(MIGRATEINF,NULL,INF_STYLE_WIN4,NULL);
        
        if (infHandle != INVALID_HANDLE_VALUE) {
            
            if (SetupFindFirstLine(infHandle,SectionString,NULL,&ic)) {
                
                do {

                    //
                    // Create the object.
                    //
                    currentObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));
                    
                    if (!currentObject) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the size of the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,NULL,0,&size)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Create a string large enough.
                    //
                    currentObject -> Key = PoolMemCreateStringA(g_Pool,size);
                    
                    if (!currentObject -> Key) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,currentObject -> Key,size,NULL)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Successfully retrieved the line.
                    //
                    currentObject -> Value  = (PSTR) pGetTypeAsString(MIG_FILE);
                    currentObject -> Next   = section -> Items;
                    section -> Items        = currentObject;
                    
                } while(SetupFindNextLine(&ic,&ic));
                
            }
            
            SetupCloseInfFile(infHandle);
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


BOOL
MigInf_Initialize(
    VOID
    )
{

    //
    // First, initialize our pool and Zero out the structure.
    //
    g_Pool = PoolMemInitPool();


    if (g_Pool) {
        
        //
        // Now, read in the migration paths and excluded paths sections.
        //
        if (!pBuildListFromSection(SECTION_MIGRATIONPATHS) ||
            !pBuildListFromSection(SECTION_EXCLUDEDPATHS)) {
            //
            // Something went wrong (i.e. out of memory. Destroy and NULL our pool.
            //
            PoolMemDestroyPool(g_Pool);
            g_Pool = NULL;
        }
    }

    //
    // If our memory pool initialized successfully, return TRUE.
    //
    return (g_Pool != NULL);

}


VOID
MigInf_CleanUp (
    VOID
    )
{
    //
    // Only thing we need to do is clean out pool mem. We'll NULL out the list header to make
    // sure it isn't usable.
    //
    if (g_Pool) {
        PoolMemDestroyPool(g_Pool);
        g_Pool = NULL;
    }
    
    g_MigrationInf = NULL;

}


BOOL
MigInf_AddObject (
    IN MIGTYPE  ObjectType,
    IN PCSTR    SectionString,
    IN PCSTR    ParamOne,
    IN PCSTR    ParamTwo
    )
{

    return pCreateMigObject(
        ObjectType,
        ParamOne,
        ParamTwo,
        pFindSection(SectionString,MIGINF_CREATE)
        );
}

BOOL 

MigInf_FirstInSection(
    IN PCSTR SectionName, 
    OUT PMIGINFSECTIONENUM Enum
    )
{
    PMIGSECTION section;

    //
    // We assume that Enum is valid.
    //
    assert(Enum);

    section = pFindSection(SectionName,MIGINF_NOCREATE);

    if (section) {
        Enum -> EnumKey = (PVOID) section -> Items;
    }

    return MigInf_NextInSection(Enum);
}

BOOL 
MigInf_NextInSection(
    IN OUT PMIGINFSECTIONENUM Enum
    )
{


    BOOL            rSuccess = FALSE;

    //
    // We assume that the Enum is valid.
    //
    assert(Enum);

    if (Enum -> EnumKey) {

        Enum -> Key     = ((PMIGOBJECT) (Enum -> EnumKey)) -> Key;
        Enum -> Value   = ((PMIGOBJECT) (Enum -> EnumKey)) -> Value;
        Enum -> EnumKey = ((PVOID) ((PMIGOBJECT) (Enum -> EnumKey)) -> Next);
        rSuccess = TRUE;
    }

    return rSuccess;
}


BOOL
MigInf_WriteInfToDisk (
    VOID
    )
{

    BOOL        rSuccess = TRUE;
    PMIGSECTION curSection;
    
    //
    // Simply loop through all of the sections, writing each of them to disk.
    // As long as WriteSectionToDisk works, we work.
    //
    curSection = g_MigrationInf;

    while (curSection && rSuccess) {

        //
        // We skip the [Excluded Paths] and [Migration Paths] sections.
        //
        if (_mbsicmp(curSection -> Name,SECTION_EXCLUDEDPATHS) &&
            _mbsicmp(curSection -> Name,SECTION_MIGRATIONPATHS)) {
            
            rSuccess = pWriteInfSectionToDisk(curSection);
        } 

        curSection = curSection -> Next;
        
    }

    return rSuccess;
}

BOOL
MigInf_PathIsExcluded (
    IN PCSTR    Path
    )
{
    PMIGOBJECT  curExcluded;
    PMIGSECTION section;
    BOOL        rIsExcluded = FALSE;

    //
    // We assume Path is valid.
    //
    assert(Path);
    
    section = pFindSection(SECTION_EXCLUDEDPATHS,MIGINF_NOCREATE);

    if (section) {

        curExcluded = section -> Items;
        
        while (curExcluded && !rIsExcluded) {
            
            rIsExcluded = pPathIsInPath(Path,curExcluded -> Key);
            curExcluded = curExcluded -> Next;
        }
    }
    
    return rIsExcluded;
}




BOOL 
MigInf_UseSpace (
    IN PCSTR DriveRoot,
    IN LONGLONG Space
    ) 
{

    BOOL rSuccess;
    PMIGSECTION section;
    static CHAR spaceString[MAX_PATH];

    section = pFindSection(SECTION_DISKSPACEUSED,MIGINF_CREATE);

    if (section) {

        sprintf(spaceString,"%I64u",Space);
        rSuccess = pCreateMigObject (MIG_FILE,DriveRoot,spaceString,section);
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\pview\nt5\setupapi.h ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    setupapi.h

Abstract:

    Public header file for Windows NT Setup services Dll.

Revision History:

--*/

#ifndef _INC_SETUPAPI
#define _INC_SETUPAPI

//
// Define API decoration for direct importing of DLL references.
//
#if !defined(_SETUPAPI_)
#define WINSETUPAPI DECLSPEC_IMPORT
#else
#define WINSETUPAPI
#endif

#include <pshpack1.h>   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif

//
// Include commctrl.h for our use of HIMAGELIST and wizard support.
//
#include <commctrl.h>


//
// Define maximum string length constants as specified by
// Windows 95.
//
#define LINE_LEN                    256 // Win95-compatible maximum for displayable
                                        // strings coming from a device INF.
#define MAX_INF_STRING_LENGTH      4096 // Actual maximum size of an INF string (including
                                        // string substitutions).
#define MAX_TITLE_LEN                60
#define MAX_INSTRUCTION_LEN         256
#define MAX_LABEL_LEN                30
#define MAX_SERVICE_NAME_LEN        256

//
// Define maximum length of a machine name in the format expected by ConfigMgr32
// CM_Connect_Machine (i.e., "\\\\MachineName\0").
//
#define SP_MAX_MACHINENAME_LENGTH   (MAX_COMPUTERNAME_LENGTH + 3)

//
// Define type for reference to loaded inf file
//
typedef PVOID HINF;

//
// Inf context structure. Applications must not interpret or
// overwrite values in these structures.
//
typedef struct _INFCONTEXT {
    PVOID Inf;
    PVOID CurrentInf;
    UINT Section;
    UINT Line;
} INFCONTEXT, *PINFCONTEXT;

//
// Inf file information structure.
//
typedef struct _SP_INF_INFORMATION {
    DWORD InfStyle;
    DWORD InfCount;
    BYTE VersionData[ANYSIZE_ARRAY];
} SP_INF_INFORMATION, *PSP_INF_INFORMATION;

//
// SP_INF_INFORMATION.InfStyle values
//
#define INF_STYLE_NONE  0       // unrecognized or non-existent
#define INF_STYLE_OLDNT 1       // winnt 3.x
#define INF_STYLE_WIN4  2       // Win95

//
// Target directory specs.
//
#define DIRID_ABSOLUTE          -1              // real 32-bit -1
#define DIRID_ABSOLUTE_16BIT     0xffff         // 16-bit -1 for compat w/setupx
#define DIRID_NULL               0
#define DIRID_SRCPATH            1
#define DIRID_WINDOWS           10
#define DIRID_SYSTEM            11              // system32
#define DIRID_DRIVERS           12
#define DIRID_IOSUBSYS          DIRID_DRIVERS
#define DIRID_INF               17
#define DIRID_HELP              18
#define DIRID_FONTS             20
#define DIRID_VIEWERS           21
#define DIRID_COLOR             23
#define DIRID_APPS              24
#define DIRID_SHARED            25
#define DIRID_BOOT              30

#define DIRID_SYSTEM16          50
#define DIRID_SPOOL             51
#define DIRID_SPOOLDRIVERS      52
#define DIRID_USERPROFILE       53
#define DIRID_LOADER            54
#define DIRID_PRINTPROCESSOR    55

#define DIRID_DEFAULT           DIRID_SYSTEM

//
// First user-definable dirid. See SetupSetDirectoryId().
//
#define DIRID_USER              0x8000


//
// Setup callback notification routine type
//
typedef UINT (CALLBACK* PSP_FILE_CALLBACK_A)(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT Param1,
    IN UINT Param2
    );

typedef UINT (CALLBACK* PSP_FILE_CALLBACK_W)(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT Param1,
    IN UINT Param2
    );

#ifdef UNICODE
#define PSP_FILE_CALLBACK PSP_FILE_CALLBACK_W
#else
#define PSP_FILE_CALLBACK PSP_FILE_CALLBACK_A
#endif


//
// Operation/queue start/end notification. These are ordinal values.
//
#define SPFILENOTIFY_STARTQUEUE         0x00000001
#define SPFILENOTIFY_ENDQUEUE           0x00000002
#define SPFILENOTIFY_STARTSUBQUEUE      0x00000003
#define SPFILENOTIFY_ENDSUBQUEUE        0x00000004
#define SPFILENOTIFY_STARTDELETE        0x00000005
#define SPFILENOTIFY_ENDDELETE          0x00000006
#define SPFILENOTIFY_DELETEERROR        0x00000007
#define SPFILENOTIFY_STARTRENAME        0x00000008
#define SPFILENOTIFY_ENDRENAME          0x00000009
#define SPFILENOTIFY_RENAMEERROR        0x0000000a
#define SPFILENOTIFY_STARTCOPY          0x0000000b
#define SPFILENOTIFY_ENDCOPY            0x0000000c
#define SPFILENOTIFY_COPYERROR          0x0000000d
#define SPFILENOTIFY_NEEDMEDIA          0x0000000e
#define SPFILENOTIFY_QUEUESCAN          0x0000000f
//
// These are used with SetupIterateCabinet().
//
#define SPFILENOTIFY_CABINETINFO        0x00000010
#define SPFILENOTIFY_FILEINCABINET      0x00000011
#define SPFILENOTIFY_NEEDNEWCABINET     0x00000012
#define SPFILENOTIFY_FILEEXTRACTED      0x00000013

#define SPFILENOTIFY_FILEOPDELAYED      0x00000014

//
// Copy notification. These are bit flags that may be combined.
//
#define SPFILENOTIFY_LANGMISMATCH       0x00010000
#define SPFILENOTIFY_TARGETEXISTS       0x00020000
#define SPFILENOTIFY_TARGETNEWER        0x00040000

//
// File operation codes and callback outcomes.
//
#define FILEOP_COPY                     0
#define FILEOP_RENAME                   1
#define FILEOP_DELETE                   2

#define FILEOP_ABORT                    0
#define FILEOP_DOIT                     1
#define FILEOP_SKIP                     2
#define FILEOP_RETRY                    FILEOP_DOIT
#define FILEOP_NEWPATH                  4

//
// Flags in inf copy sections
//
#define COPYFLG_WARN_IF_SKIP            0x00000001      // warn if user tries to skip file
#define COPYFLG_NOSKIP                  0x00000002      // disallow skipping this file
#define COPYFLG_NOVERSIONCHECK          0x00000004      // ignore versions and overwrite target
#define COPYFLG_FORCE_FILE_IN_USE       0x00000008      // force file-in-use behavior
#define COPYFLG_NO_OVERWRITE            0x00000010      // do not copy if file exists on target
#define COPYFLG_NO_VERSION_DIALOG       0x00000020      // do not copy if target is newer
#define COPYFLG_OVERWRITE_OLDER_ONLY    0x00000040      // leave target alone if version same as source
#define COPYFLG_REPLACEONLY             0x00000400      // copy only if file exists on target

//
// Flags in inf delete sections
// New flags go in high word
//
#define DELFLG_IN_USE                   0x00000001      // queue in-use file for delete
#define DELFLG_IN_USE1                  0x00010000      // high-word version of DELFLG_IN_USE

//
// Source and file paths. Used when notifying queue callback
// of SPFILENOTIFY_STARTxxx, SPFILENOTIFY_ENDxxx, and SPFILENOTIFY_xxxERROR.
//
typedef struct _FILEPATHS_A {
    PCSTR  Target;
    PCSTR  Source;  // not used for delete operations
    UINT   Win32Error;
    DWORD  Flags;   // such as SP_COPY_NOSKIP for copy errors
} FILEPATHS_A, *PFILEPATHS_A;

typedef struct _FILEPATHS_W {
    PCWSTR Target;
    PCWSTR Source;  // not used for delete operations
    UINT   Win32Error;
    DWORD  Flags;   // such as SP_COPY_NOSKIP for copy errors
} FILEPATHS_W, *PFILEPATHS_W;

#ifdef UNICODE
typedef FILEPATHS_W FILEPATHS;
typedef PFILEPATHS_W PFILEPATHS;
#else
typedef FILEPATHS_A FILEPATHS;
typedef PFILEPATHS_A PFILEPATHS;
#endif


//
// Structure used with SPFILENOTIFY_NEEDMEDIA
//
typedef struct _SOURCE_MEDIA_A {
    PCSTR Reserved;
    PCSTR Tagfile;          // may be NULL
    PCSTR Description;
    //
    // Pathname part and filename part of source file
    // that caused us to need the media.
    //
    PCSTR SourcePath;
    PCSTR SourceFile;
    DWORD Flags;            // subset of SP_COPY_xxx
} SOURCE_MEDIA_A, *PSOURCE_MEDIA_A;

typedef struct _SOURCE_MEDIA_W {
    PCWSTR Reserved;
    PCWSTR Tagfile;         // may be NULL
    PCWSTR Description;
    //
    // Pathname part and filename part of source file
    // that caused us to need the media.
    //
    PCWSTR SourcePath;
    PCWSTR SourceFile;
    DWORD  Flags;           // subset of SP_COPY_xxx
} SOURCE_MEDIA_W, *PSOURCE_MEDIA_W;

#ifdef UNICODE
typedef SOURCE_MEDIA_W SOURCE_MEDIA;
typedef PSOURCE_MEDIA_W PSOURCE_MEDIA;
#else
typedef SOURCE_MEDIA_A SOURCE_MEDIA;
typedef PSOURCE_MEDIA_A PSOURCE_MEDIA;
#endif

//
// Structure used with SPFILENOTIFY_CABINETINFO and
// SPFILENOTIFY_NEEDNEWCABINET
//
typedef struct _CABINET_INFO_A {
    PCSTR CabinetPath;
    PCSTR CabinetFile;
    PCSTR DiskName;
    USHORT SetId;
    USHORT CabinetNumber;
} CABINET_INFO_A, *PCABINET_INFO_A;

typedef struct _CABINET_INFO_W {
    PCWSTR CabinetPath;
    PCWSTR CabinetFile;
    PCWSTR DiskName;
    USHORT SetId;
    USHORT CabinetNumber;
} CABINET_INFO_W, *PCABINET_INFO_W;

#ifdef UNICODE
typedef CABINET_INFO_W CABINET_INFO;
typedef PCABINET_INFO_W PCABINET_INFO;
#else
typedef CABINET_INFO_A CABINET_INFO;
typedef PCABINET_INFO_A PCABINET_INFO;
#endif

//
// Structure used with SPFILENOTIFY_FILEINCABINET
//
typedef struct _FILE_IN_CABINET_INFO_A {
    PCSTR NameInCabinet;
    DWORD FileSize;
    DWORD Win32Error;
    WORD  DosDate;
    WORD  DosTime;
    WORD  DosAttribs;
    CHAR  FullTargetName[MAX_PATH];
} FILE_IN_CABINET_INFO_A, *PFILE_IN_CABINET_INFO_A;

typedef struct _FILE_IN_CABINET_INFO_W {
    PCWSTR NameInCabinet;
    DWORD  FileSize;
    DWORD  Win32Error;
    WORD   DosDate;
    WORD   DosTime;
    WORD   DosAttribs;
    WCHAR  FullTargetName[MAX_PATH];
} FILE_IN_CABINET_INFO_W, *PFILE_IN_CABINET_INFO_W;

#ifdef UNICODE
typedef FILE_IN_CABINET_INFO_W FILE_IN_CABINET_INFO;
typedef PFILE_IN_CABINET_INFO_W PFILE_IN_CABINET_INFO;
#else
typedef FILE_IN_CABINET_INFO_A FILE_IN_CABINET_INFO;
typedef PFILE_IN_CABINET_INFO_A PFILE_IN_CABINET_INFO;
#endif


//
// Define type for setup file queue
//
typedef PVOID HSPFILEQ;

//
// Define type for setup disk space list
//
typedef PVOID HDSKSPC;

//
// Define type for reference to device information set
//
typedef PVOID HDEVINFO;

//
// Device information structure (references a device instance
// that is a member of a device information set)
//
typedef struct _SP_DEVINFO_DATA {
    DWORD cbSize;
    GUID  ClassGuid;
    DWORD DevInst;    // DEVINST handle
    DWORD Reserved;
} SP_DEVINFO_DATA, *PSP_DEVINFO_DATA;

//
// Device interface information structure (references a device
// interface that is associated with the device information
// element that owns it).
//
typedef struct _SP_DEVICE_INTERFACE_DATA {
    DWORD cbSize;
    GUID  InterfaceClassGuid;
    DWORD Flags;
    DWORD Reserved;
} SP_DEVICE_INTERFACE_DATA, *PSP_DEVICE_INTERFACE_DATA;

//
// Flags for SP_DEVICE_INTERFACE_DATA.Flags field.
//
#define SPINT_ACTIVE  0x00000001
#define SPINT_DEFAULT 0x00000002
#define SPINT_REMOVED 0x00000004

//
// Backward compatibility--do not use.
//
typedef SP_DEVICE_INTERFACE_DATA  SP_INTERFACE_DEVICE_DATA;
typedef PSP_DEVICE_INTERFACE_DATA PSP_INTERFACE_DEVICE_DATA;
#define SPID_ACTIVE               SPINT_ACTIVE
#define SPID_DEFAULT              SPINT_DEFAULT
#define SPID_REMOVED              SPINT_REMOVED


typedef struct _SP_DEVICE_INTERFACE_DETAIL_DATA_A {
    DWORD  cbSize;
    CHAR   DevicePath[ANYSIZE_ARRAY];
} SP_DEVICE_INTERFACE_DETAIL_DATA_A, *PSP_DEVICE_INTERFACE_DETAIL_DATA_A;

typedef struct _SP_DEVICE_INTERFACE_DETAIL_DATA_W {
    DWORD  cbSize;
    WCHAR  DevicePath[ANYSIZE_ARRAY];
} SP_DEVICE_INTERFACE_DETAIL_DATA_W, *PSP_DEVICE_INTERFACE_DETAIL_DATA_W;

#ifdef UNICODE
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_W SP_DEVICE_INTERFACE_DETAIL_DATA;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_W PSP_DEVICE_INTERFACE_DETAIL_DATA;
#else
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_A SP_DEVICE_INTERFACE_DETAIL_DATA;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_A PSP_DEVICE_INTERFACE_DETAIL_DATA;
#endif

//
// Backward compatibility--do not use.
//
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_W SP_INTERFACE_DEVICE_DETAIL_DATA_W;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_W PSP_INTERFACE_DEVICE_DETAIL_DATA_W;
typedef SP_DEVICE_INTERFACE_DETAIL_DATA_A SP_INTERFACE_DEVICE_DETAIL_DATA_A;
typedef PSP_DEVICE_INTERFACE_DETAIL_DATA_A PSP_INTERFACE_DEVICE_DETAIL_DATA_A;
#ifdef UNICODE
typedef SP_INTERFACE_DEVICE_DETAIL_DATA_W SP_INTERFACE_DEVICE_DETAIL_DATA;
typedef PSP_INTERFACE_DEVICE_DETAIL_DATA_W PSP_INTERFACE_DEVICE_DETAIL_DATA;
#else
typedef SP_INTERFACE_DEVICE_DETAIL_DATA_A SP_INTERFACE_DEVICE_DETAIL_DATA;
typedef PSP_INTERFACE_DEVICE_DETAIL_DATA_A PSP_INTERFACE_DEVICE_DETAIL_DATA;
#endif


//
// Structure for detailed information on a device information set (used for
// SetupDiGetDeviceInfoListDetail which supercedes the functionality of
// SetupDiGetDeviceInfoListClass).
//
typedef struct _SP_DEVINFO_LIST_DETAIL_DATA_A {
    DWORD  cbSize;
    GUID   ClassGuid;
    HANDLE RemoteMachineHandle;
    CHAR   RemoteMachineName[SP_MAX_MACHINENAME_LENGTH];
} SP_DEVINFO_LIST_DETAIL_DATA_A, *PSP_DEVINFO_LIST_DETAIL_DATA_A;

typedef struct _SP_DEVINFO_LIST_DETAIL_DATA_W {
    DWORD  cbSize;
    GUID   ClassGuid;
    HANDLE RemoteMachineHandle;
    WCHAR  RemoteMachineName[SP_MAX_MACHINENAME_LENGTH];
} SP_DEVINFO_LIST_DETAIL_DATA_W, *PSP_DEVINFO_LIST_DETAIL_DATA_W;

#ifdef UNICODE
typedef SP_DEVINFO_LIST_DETAIL_DATA_W SP_DEVINFO_LIST_DETAIL_DATA;
typedef PSP_DEVINFO_LIST_DETAIL_DATA_W PSP_DEVINFO_LIST_DETAIL_DATA;
#else
typedef SP_DEVINFO_LIST_DETAIL_DATA_A SP_DEVINFO_LIST_DETAIL_DATA;
typedef PSP_DEVINFO_LIST_DETAIL_DATA_A PSP_DEVINFO_LIST_DETAIL_DATA;
#endif


//
// Class installer function codes
//
#define DIF_SELECTDEVICE            0x00000001
#define DIF_INSTALLDEVICE           0x00000002
#define DIF_ASSIGNRESOURCES         0x00000003
#define DIF_PROPERTIES              0x00000004
#define DIF_REMOVE                  0x00000005
#define DIF_FIRSTTIMESETUP          0x00000006
#define DIF_FOUNDDEVICE             0x00000007
#define DIF_SELECTCLASSDRIVERS      0x00000008
#define DIF_VALIDATECLASSDRIVERS    0x00000009
#define DIF_INSTALLCLASSDRIVERS     0x0000000A
#define DIF_CALCDISKSPACE           0x0000000B
#define DIF_DESTROYPRIVATEDATA      0x0000000C
#define DIF_VALIDATEDRIVER          0x0000000D
#define DIF_MOVEDEVICE              0x0000000E
#define DIF_DETECT                  0x0000000F
#define DIF_INSTALLWIZARD           0x00000010
#define DIF_DESTROYWIZARDDATA       0x00000011
#define DIF_PROPERTYCHANGE          0x00000012
#define DIF_ENABLECLASS             0x00000013
#define DIF_DETECTVERIFY            0x00000014
#define DIF_INSTALLDEVICEFILES      0x00000015
#define DIF_UNREMOVE                0x00000016
#define DIF_SELECTBESTCOMPATDRV     0x00000017
#define DIF_ALLOW_INSTALL           0x00000018
#define DIF_REGISTERDEVICE          0x00000019
#define DIF_INSTALLINTERFACES       0x00000020
#define DIF_DETECTCANCEL            0x00000021
#define DIF_REGISTER_COINSTALLERS   0x00000022

typedef UINT        DI_FUNCTION;    // Function type for device installer


//
// Device installation parameters structure (associated with a
// particular device information element, or globally with a device
// information set)
//
typedef struct _SP_DEVINSTALL_PARAMS_A {
    DWORD             cbSize;
    DWORD             Flags;
    DWORD             FlagsEx;
    HWND              hwndParent;
    PSP_FILE_CALLBACK InstallMsgHandler;
    PVOID             InstallMsgHandlerContext;
    HSPFILEQ          FileQueue;
    DWORD             ClassInstallReserved;
    DWORD             Reserved;
    CHAR              DriverPath[MAX_PATH];
} SP_DEVINSTALL_PARAMS_A, *PSP_DEVINSTALL_PARAMS_A;

typedef struct _SP_DEVINSTALL_PARAMS_W {
    DWORD             cbSize;
    DWORD             Flags;
    DWORD             FlagsEx;
    HWND              hwndParent;
    PSP_FILE_CALLBACK InstallMsgHandler;
    PVOID             InstallMsgHandlerContext;
    HSPFILEQ          FileQueue;
    DWORD             ClassInstallReserved;
    DWORD             Reserved;
    WCHAR             DriverPath[MAX_PATH];
} SP_DEVINSTALL_PARAMS_W, *PSP_DEVINSTALL_PARAMS_W;

#ifdef UNICODE
typedef SP_DEVINSTALL_PARAMS_W SP_DEVINSTALL_PARAMS;
typedef PSP_DEVINSTALL_PARAMS_W PSP_DEVINSTALL_PARAMS;
#else
typedef SP_DEVINSTALL_PARAMS_A SP_DEVINSTALL_PARAMS;
typedef PSP_DEVINSTALL_PARAMS_A PSP_DEVINSTALL_PARAMS;
#endif


//
// SP_DEVINSTALL_PARAMS.Flags values
//
// Flags for choosing a device
//
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L     // both class & compat list shown
#define DI_NOVCP                    0x00000008L     // don't create a new copy queue--use
                                                    // caller-supplied FileQueue
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L     // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Reboot required to take effect
#define DI_NEEDREBOOT               0x00000100L     // ""

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildDriverInfoList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list

// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

// Flag to indicate that only the the INF specified by SP_DEVINSTALL_PARAMS.DriverPath
// should be searched.
#define DI_ENUMSINGLEINF            0x00010000L

// Flag that prevents ConfigMgr from removing/re-enumerating devices during device
// registration, installation, and deletion.
#define DI_DONOTCALLCONFIGMG        0x00020000L

// The following flag can be used to install a device disabled
#define DI_INSTALLDISABLED          0x00040000L

// Flag that causes SetupDiBuildDriverInfoList to build a device's compatible driver
// list from its existing class driver list, instead of the normal INF search.
#define DI_COMPAT_FROM_CLASS        0x00080000L

// This flag is set if the Class Install params should be used.
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// returns ERROR_DI_DO_DEFAULT.
#define DI_NODI_DEFAULTACTION       0x00200000L

// The setupx flag, DI_NOSYNCPROCESSING (0x00400000L) is not support in the Setup APIs.

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop provider added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS            0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS              0x80000000L     // Don't write HW & Compat IDs on install


//
// SP_DEVINSTALL_PARAMS.FlagsEx values
//
#define DI_FLAGSEX_USEOLDINFSEARCH      0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0      0x00000002L  // SetupDiSelectDevice doesn't prompt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED            0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST          0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO        0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES        0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL     0x00000080L
#define DI_FLAGSEX_DEVICECHANGE         0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS       0x00000200L
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS    0x00000800L
#define DI_FLAGSEX_NOUIONQUERYREMOVE    0x00001000L
#define DI_FLAGSEX_USECLASSFORCOMPAT    0x00002000L  // Use the device's class when building compat drv list.
                                                     // (Ignored if DI_COMPAT_FROM_CLASS flag is specified.)

#define DI_FLAGSEX_OLDINF_IN_CLASSLIST  0x00004000L  // Search legacy INFs when building class driver list.

#define DI_FLAGSEX_NO_DRVREG_MODIFY     0x00008000L  // Don't run AddReg and DelReg for device's software (driver) key.

#define DI_FLAGSEX_OSUPGRADE            0x00010000L  // Installation is occurring in an upgrade during GUI-mode setup.


//
// Class installation parameters header.  This must be the first field of any class install
// parameter structure.  The InstallFunction field must be set to the function code
// corresponding to the structure, and the cbSize field must be set to the size of the
// header structure.  E.g.,
//
// SP_ENABLECLASS_PARAMS EnableClassParams;
//
// EnableClassParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
// EnableClassParams.ClassInstallHeader.InstallFunction = DIF_ENABLECLASS;
//
typedef struct _SP_CLASSINSTALL_HEADER {
    DWORD       cbSize;
    DI_FUNCTION InstallFunction;
} SP_CLASSINSTALL_HEADER, *PSP_CLASSINSTALL_HEADER;


//
// Structure corresponding to a DIF_ENABLECLASS install function.
//
typedef struct _SP_ENABLECLASS_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    GUID                   ClassGuid;
    DWORD                  EnableMessage;
} SP_ENABLECLASS_PARAMS, *PSP_ENABLECLASS_PARAMS;

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2


//
// Structure corresponding to a DIF_MOVEDEVICE install function.
//
typedef struct _SP_MOVEDEV_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    SP_DEVINFO_DATA        SourceDeviceInfoData;
} SP_MOVEDEV_PARAMS, *PSP_MOVEDEV_PARAMS;


//
// Values indicating a change in a device's state
//
#define DICS_ENABLE      0x00000001
#define DICS_DISABLE     0x00000002
#define DICS_PROPCHANGE  0x00000003
#define DICS_START       0x00000004
#define DICS_STOP        0x00000005
//
// Values specifying the scope of a device property change
//
#define DICS_FLAG_GLOBAL         0x00000001  // make change in all hardware profiles
#define DICS_FLAG_CONFIGSPECIFIC 0x00000002  // make change in specified profile only
#define DICS_FLAG_CONFIGGENERAL  0x00000004  // 1 or more hardware profile-specific
                                             // changes to follow.
//
// Structure corresponding to a DIF_PROPERTYCHANGE install function.
//
typedef struct _SP_PROPCHANGE_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD                  StateChange;
    DWORD                  Scope;
    DWORD                  HwProfile;
} SP_PROPCHANGE_PARAMS, *PSP_PROPCHANGE_PARAMS;


//
// Structure corresponding to a DIF_REMOVE install function.
//
typedef struct _SP_REMOVEDEVICE_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD Scope;
    DWORD HwProfile;
} SP_REMOVEDEVICE_PARAMS, *PSP_REMOVEDEVICE_PARAMS;

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002


//
// Structure corresponding to a DIF_UNREMOVE install function.
//
typedef struct _SP_UNREMOVEDEVICE_PARAMS {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD Scope;
    DWORD HwProfile;
} SP_UNREMOVEDEVICE_PARAMS, *PSP_UNREMOVEDEVICE_PARAMS;

#define DI_UNREMOVEDEVICE_CONFIGSPECIFIC        0x00000002


//
// Structure corresponding to a DIF_SELECTDEVICE install function.
//
typedef struct _SP_SELECTDEVICE_PARAMS_A {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    CHAR                   Title[MAX_TITLE_LEN];
    CHAR                   Instructions[MAX_INSTRUCTION_LEN];
    CHAR                   ListLabel[MAX_LABEL_LEN];
    BYTE                   Reserved[2];                  // DWORD size alignment
} SP_SELECTDEVICE_PARAMS_A, *PSP_SELECTDEVICE_PARAMS_A;

typedef struct _SP_SELECTDEVICE_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    WCHAR                  Title[MAX_TITLE_LEN];
    WCHAR                  Instructions[MAX_INSTRUCTION_LEN];
    WCHAR                  ListLabel[MAX_LABEL_LEN];
} SP_SELECTDEVICE_PARAMS_W, *PSP_SELECTDEVICE_PARAMS_W;

#ifdef UNICODE
typedef SP_SELECTDEVICE_PARAMS_W SP_SELECTDEVICE_PARAMS;
typedef PSP_SELECTDEVICE_PARAMS_W PSP_SELECTDEVICE_PARAMS;
#else
typedef SP_SELECTDEVICE_PARAMS_A SP_SELECTDEVICE_PARAMS;
typedef PSP_SELECTDEVICE_PARAMS_A PSP_SELECTDEVICE_PARAMS;
#endif


//
// Structure corresponding to a DIF_DETECT install function.
//

typedef BOOL (CALLBACK* PDETECT_PROGRESS_NOTIFY)(
     IN PVOID ProgressNotifyParam,
     IN DWORD DetectComplete
     );

// where:
//     ProgressNotifyParam - value supplied by caller requesting detection.
//     DetectComplete - Percent completion, to be incremented by class
//                      installer, as it steps thru its detection.
//
// Return Value - If TRUE, then detection is cancelled.  Allows caller
//                requesting detection to stop detection asap.
//

typedef struct _SP_DETECTDEVICE_PARAMS {
    SP_CLASSINSTALL_HEADER  ClassInstallHeader;
    PDETECT_PROGRESS_NOTIFY DetectProgressNotify;
    PVOID                   ProgressNotifyParam;
} SP_DETECTDEVICE_PARAMS, *PSP_DETECTDEVICE_PARAMS;


//
// 'Add New Device' installation wizard structure
//
// Structure corresponding to a DIF_INSTALLWIZARD install function.
// (NOTE: This structure is also applicable for DIF_DESTROYWIZARDDATA,
// but DIF_INSTALLWIZARD is the associated function code in the class
// installation parameter structure in both cases.)
//
// Define maximum number of dynamic wizard pages that can be added to
// hardware install wizard.
//
#define MAX_INSTALLWIZARD_DYNAPAGES             20

typedef struct _SP_INSTALLWIZARD_DATA {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD                  Flags;
    HPROPSHEETPAGE         DynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    DWORD                  NumDynamicPages;
    DWORD                  DynamicPageFlags;
    DWORD                  PrivateFlags;
    LPARAM                 PrivateData;
    HWND                   hwndWizardDlg;
} SP_INSTALLWIZARD_DATA, *PSP_INSTALLWIZARD_DATA;

//
// SP_INSTALLWIZARD_DATA.Flags values
//
#define NDW_INSTALLFLAG_DIDFACTDEFS         0x00000001
#define NDW_INSTALLFLAG_HARDWAREALLREADYIN  0x00000002
#define NDW_INSTALLFLAG_NEEDRESTART         DI_NEEDRESTART
#define NDW_INSTALLFLAG_NEEDREBOOT          DI_NEEDREBOOT
#define NDW_INSTALLFLAG_NEEDSHUTDOWN        0x00000200
#define NDW_INSTALLFLAG_EXPRESSINTRO        0x00000400
#define NDW_INSTALLFLAG_SKIPISDEVINSTALLED  0x00000800
#define NDW_INSTALLFLAG_NODETECTEDDEVS      0x00001000
#define NDW_INSTALLFLAG_INSTALLSPECIFIC     0x00002000
#define NDW_INSTALLFLAG_SKIPCLASSLIST       0x00004000
#define NDW_INSTALLFLAG_CI_PICKED_OEM       0x00008000
#define NDW_INSTALLFLAG_PCMCIAMODE          0x00010000
#define NDW_INSTALLFLAG_PCMCIADEVICE        0x00020000
#define NDW_INSTALLFLAG_USERCANCEL          0x00040000
#define NDW_INSTALLFLAG_KNOWNCLASS          0x00080000


//
// SP_INSTALLWIZARD_DATA.DynamicPageFlags values
//
// This flag is set if a Class installer has added pages to the
// install wizard.
//
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

//
// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.
//
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back
// in the event of a conflict if you set this flag.
//
// WARNING (lonnym): Not currently implemented!
//
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

//
// Define wizard page resource IDs to be used when adding custom pages
// to the hardware install wizard.
//
// Resource ID for the first page that the install wizard will go to after
// adding the class installer pages.
//
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

//
// Resource ID for the page that the Select Device page will go back to.
//
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

//
// Resource ID for the page that the Select Device page will go forward to.
//
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002

//
// Resource ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
//
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

//
// Resource ID for the page that the Analyze dialog should go to if it
// continue from the analyze proc.  the wAnalyzeResult in the INSTALLDATA
// struct will contain the anaysis results.
//
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

//
// Resource ID for that page that the Install detected devices page will go
// back to.
//
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006

//
// Resource ID for the page that the Install detected devices page will go
// forward to.
//
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007

//
// Resource ID for the page that the Install detected devices page will go
// to in the event that no devices are detected.
//
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008

//
// Resource ID of the hardware install wizard's select device page.
// This ID can be used to go directly to the hardware install wizard's select
// device page.
//
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

//
// Resource ID of the hardware install wizard's device analysis page.
// This ID can be use to go directly to the hardware install wizard's analysis
// page.
//
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

//
// Resource ID of the hardware install wizard's install detected devices page.
// This ID can be use to go directly to the hardware install wizard's install
// detected devices page.
//
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

//
// Resource ID of the hardware install wizard's select class page.
// This ID can be use to go directly to the hardware install wizard's select
// class page.
//
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012


//
// Driver information structure (member of a driver info list that may be associated
// with a particular device instance, or (globally) with a device information set)
//
typedef struct _SP_DRVINFO_DATA_A {
    DWORD cbSize;
    DWORD DriverType;
    DWORD Reserved;
    CHAR  Description[LINE_LEN];
    CHAR  MfgName[LINE_LEN];
    CHAR  ProviderName[LINE_LEN];
} SP_DRVINFO_DATA_A, *PSP_DRVINFO_DATA_A;

typedef struct _SP_DRVINFO_DATA_W {
    DWORD cbSize;
    DWORD DriverType;
    DWORD Reserved;
    WCHAR Description[LINE_LEN];
    WCHAR MfgName[LINE_LEN];
    WCHAR ProviderName[LINE_LEN];
} SP_DRVINFO_DATA_W, *PSP_DRVINFO_DATA_W;

#ifdef UNICODE
typedef SP_DRVINFO_DATA_W SP_DRVINFO_DATA;
typedef PSP_DRVINFO_DATA_W PSP_DRVINFO_DATA;
#else
typedef SP_DRVINFO_DATA_A SP_DRVINFO_DATA;
typedef PSP_DRVINFO_DATA_A PSP_DRVINFO_DATA;
#endif


//
// Driver information details structure (provides detailed information about a
// particular driver information structure)
//
typedef struct _SP_DRVINFO_DETAIL_DATA_A {
    DWORD    cbSize;
    FILETIME InfDate;
    DWORD    CompatIDsOffset;
    DWORD    CompatIDsLength;
    DWORD    Reserved;
    CHAR     SectionName[LINE_LEN];
    CHAR     InfFileName[MAX_PATH];
    CHAR     DrvDescription[LINE_LEN];
    CHAR     HardwareID[ANYSIZE_ARRAY];
} SP_DRVINFO_DETAIL_DATA_A, *PSP_DRVINFO_DETAIL_DATA_A;

typedef struct _SP_DRVINFO_DETAIL_DATA_W {
    DWORD    cbSize;
    FILETIME InfDate;
    DWORD    CompatIDsOffset;
    DWORD    CompatIDsLength;
    DWORD    Reserved;
    WCHAR    SectionName[LINE_LEN];
    WCHAR    InfFileName[MAX_PATH];
    WCHAR    DrvDescription[LINE_LEN];
    WCHAR    HardwareID[ANYSIZE_ARRAY];
} SP_DRVINFO_DETAIL_DATA_W, *PSP_DRVINFO_DETAIL_DATA_W;

#ifdef UNICODE
typedef SP_DRVINFO_DETAIL_DATA_W SP_DRVINFO_DETAIL_DATA;
typedef PSP_DRVINFO_DETAIL_DATA_W PSP_DRVINFO_DETAIL_DATA;
#else
typedef SP_DRVINFO_DETAIL_DATA_A SP_DRVINFO_DETAIL_DATA;
typedef PSP_DRVINFO_DETAIL_DATA_A PSP_DRVINFO_DETAIL_DATA;
#endif


//
// Driver installation parameters (associated with a particular driver
// information element)
//
typedef struct _SP_DRVINSTALL_PARAMS {
    DWORD cbSize;
    DWORD Rank;
    DWORD Flags;
    DWORD PrivateData;
    DWORD Reserved;
} SP_DRVINSTALL_PARAMS, *PSP_DRVINSTALL_PARAMS;

//
// SP_DRVINSTALL_PARAMS.Flags values
//
#define DNF_DUPDESC         0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER       0x00000002   // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST 0x00000004   // If set, this driver node will not be
                                         // displayed in any driver select dialogs.
#define DNF_NODRIVER        0x00000008   // if we want to install no driver
                                         // (e.g no mouse drv)
#define DNF_LEGACYINF       0x00000010   // this driver node comes from an old-style INF


//
// Setup callback routine for comparing detection signatures
//
typedef DWORD (CALLBACK* PSP_DETSIG_CMPPROC)(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA NewDeviceData,
    IN PSP_DEVINFO_DATA ExistingDeviceData,
    IN PVOID            CompareContext      OPTIONAL
    );


//
// Define context structure handed to co-installers
//
typedef struct _COINSTALLER_CONTEXT_DATA {
    BOOL  PostProcessing;
    DWORD InstallResult;
    PVOID PrivateData;
} COINSTALLER_CONTEXT_DATA, *PCOINSTALLER_CONTEXT_DATA;


//
// Structure containing class image list information.
//
typedef struct _SP_CLASSIMAGELIST_DATA {
    DWORD      cbSize;
    HIMAGELIST ImageList;
    DWORD      Reserved;
} SP_CLASSIMAGELIST_DATA, *PSP_CLASSIMAGELIST_DATA;


//
// Structure to be passed as first parameter (LPVOID lpv) to ExtensionPropSheetPageProc
// entry point in setupapi.dll or to "EnumPropPages32" or "BasicProperties32" entry
// points provided by class/device property page providers.  Used to retrieve a handle
// (or, potentially, multiple handles) to property pages for a specified property page type.
//
typedef struct _SP_PROPSHEETPAGE_REQUEST {
    DWORD            cbSize;
    DWORD            PageRequested;
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
} SP_PROPSHEETPAGE_REQUEST, *PSP_PROPSHEETPAGE_REQUEST;

//
// Property sheet codes used in SP_PROPSHEETPAGE_REQUEST.PageRequested
//
#define SPPSR_SELECT_DEVICE_RESOURCES      1    // supplied by setupapi.dll
#define SPPSR_ENUM_BASIC_DEVICE_PROPERTIES 2    // supplied by device's BasicProperties32 provider
#define SPPSR_ENUM_ADV_DEVICE_PROPERTIES   3    // supplied by class and/or device's EnumPropPages32 provider


//
// Setupapi-specific error codes
//
// Inf parse outcomes
//
#define ERROR_EXPECTED_SECTION_NAME  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0)
#define ERROR_BAD_SECTION_NAME_LINE  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|1)
#define ERROR_SECTION_NAME_TOO_LONG  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|2)
#define ERROR_GENERAL_SYNTAX         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|3)
//
// Inf runtime errors
//
#define ERROR_WRONG_INF_STYLE        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x100)
#define ERROR_SECTION_NOT_FOUND      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x101)
#define ERROR_LINE_NOT_FOUND         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x102)
//
// Device Installer errors
//
#define ERROR_NO_ASSOCIATED_CLASS         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x200)
#define ERROR_CLASS_MISMATCH              (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x201)
#define ERROR_DUPLICATE_FOUND             (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x202)
#define ERROR_NO_DRIVER_SELECTED          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x203)
#define ERROR_KEY_DOES_NOT_EXIST          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x204)
#define ERROR_INVALID_DEVINST_NAME        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x205)
#define ERROR_INVALID_CLASS               (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x206)
#define ERROR_DEVINST_ALREADY_EXISTS      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x207)
#define ERROR_DEVINFO_NOT_REGISTERED      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x208)
#define ERROR_INVALID_REG_PROPERTY        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x209)
#define ERROR_NO_INF                      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20A)
#define ERROR_NO_SUCH_DEVINST             (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20B)
#define ERROR_CANT_LOAD_CLASS_ICON        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20C)
#define ERROR_INVALID_CLASS_INSTALLER     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20D)
#define ERROR_DI_DO_DEFAULT               (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20E)
#define ERROR_DI_NOFILECOPY               (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x20F)
#define ERROR_INVALID_HWPROFILE           (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x210)
#define ERROR_NO_DEVICE_SELECTED          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x211)
#define ERROR_DEVINFO_LIST_LOCKED         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x212)
#define ERROR_DEVINFO_DATA_LOCKED         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x213)
#define ERROR_DI_BAD_PATH                 (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x214)
#define ERROR_NO_CLASSINSTALL_PARAMS      (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x215)
#define ERROR_FILEQUEUE_LOCKED            (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x216)
#define ERROR_BAD_SERVICE_INSTALLSECT     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x217)
#define ERROR_NO_CLASS_DRIVER_LIST        (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x218)
#define ERROR_NO_ASSOCIATED_SERVICE       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x219)
#define ERROR_NO_DEFAULT_DEVICE_INTERFACE (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21A)
#define ERROR_DEVICE_INTERFACE_ACTIVE     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21B)
#define ERROR_DEVICE_INTERFACE_REMOVED    (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21C)
#define ERROR_BAD_INTERFACE_INSTALLSECT   (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21D)
#define ERROR_NO_SUCH_INTERFACE_CLASS     (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21E)
#define ERROR_INVALID_REFERENCE_STRING    (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x21F)
#define ERROR_INVALID_MACHINENAME         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x220)
#define ERROR_REMOTE_COMM_FAILURE         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x221)
#define ERROR_MACHINE_UNAVAILABLE         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x222)
#define ERROR_NO_CONFIGMGR_SERVICES       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x223)
#define ERROR_INVALID_PROPPAGE_PROVIDER   (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x224)
#define ERROR_NO_SUCH_DEVICE_INTERFACE    (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x225)
#define ERROR_DI_POSTPROCESSING_REQUIRED  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x226)
#define ERROR_INVALID_COINSTALLER         (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x227)
#define ERROR_NO_COMPAT_DRIVERS           (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x228)
#define ERROR_NO_DEVICE_ICON              (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x229)
#define ERROR_INVALID_INF_LOGCONFIG       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22A)
#define ERROR_DI_DONT_INSTALL             (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22B)
#define ERROR_INVALID_FILTER_DRIVER       (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x22C)

//
// Backward compatibility--do not use.
//
#define ERROR_NO_DEFAULT_INTERFACE_DEVICE ERROR_NO_DEFAULT_DEVICE_INTERFACE
#define ERROR_INTERFACE_DEVICE_ACTIVE     ERROR_DEVICE_INTERFACE_ACTIVE
#define ERROR_INTERFACE_DEVICE_REMOVED    ERROR_DEVICE_INTERFACE_REMOVED
#define ERROR_NO_SUCH_INTERFACE_DEVICE    ERROR_NO_SUCH_DEVICE_INTERFACE


//
// Win9x migration DLL error code
//
#define ERROR_NOT_INSTALLED               (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x1000)


WINSETUPAPI
BOOL
WINAPI
SetupGetInfInformationA(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetInfInformationW(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

//
// SearchControl flags for SetupGetInfInformation
//
#define INFINFO_INF_SPEC_IS_HINF        1
#define INFINFO_INF_NAME_IS_ABSOLUTE    2
#define INFINFO_DEFAULT_SEARCH          3
#define INFINFO_REVERSE_DEFAULT_SEARCH  4
#define INFINFO_INF_PATH_LIST_SEARCH    5

#ifdef UNICODE
#define SetupGetInfInformation SetupGetInfInformationW
#else
#define SetupGetInfInformation SetupGetInfInformationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueryInfFileInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryInfFileInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryInfFileInformation SetupQueryInfFileInformationW
#else
#define SetupQueryInfFileInformation SetupQueryInfFileInformationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueryInfVersionInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCSTR               Key,              OPTIONAL
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryInfVersionInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCWSTR              Key,              OPTIONAL
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryInfVersionInformation SetupQueryInfVersionInformationW
#else
#define SetupQueryInfVersionInformation SetupQueryInfVersionInformationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetInfFileListA(
    IN  PCSTR  DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetInfFileListW(
    IN  PCWSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetInfFileList SetupGetInfFileListW
#else
#define SetupGetInfFileList SetupGetInfFileListA
#endif


WINSETUPAPI
HINF
WINAPI
SetupOpenInfFileW(
    IN  PCWSTR FileName,
    IN  PCWSTR InfClass,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine    OPTIONAL
    );

WINSETUPAPI
HINF
WINAPI
SetupOpenInfFileA(
    IN  PCSTR FileName,
    IN  PCSTR InfClass,     OPTIONAL
    IN  DWORD InfStyle,
    OUT PUINT ErrorLine     OPTIONAL
    );

#ifdef UNICODE
#define SetupOpenInfFile SetupOpenInfFileW
#else
#define SetupOpenInfFile SetupOpenInfFileA
#endif


WINSETUPAPI
HINF
WINAPI
SetupOpenMasterInf(
    VOID
    );


WINSETUPAPI
BOOL
WINAPI
SetupOpenAppendInfFileW(
    IN  PCWSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupOpenAppendInfFileA(
    IN  PCSTR FileName,     OPTIONAL
    IN  HINF  InfHandle,
    OUT PUINT ErrorLine     OPTIONAL
    );

#ifdef UNICODE
#define SetupOpenAppendInfFile SetupOpenAppendInfFileW
#else
#define SetupOpenAppendInfFile SetupOpenAppendInfFileA
#endif


WINSETUPAPI
VOID
WINAPI
SetupCloseInfFile(
    IN HINF InfHandle
    );


WINSETUPAPI
BOOL
WINAPI
SetupFindFirstLineA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  PCSTR       Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupFindFirstLineW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  PCWSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

#ifdef UNICODE
#define SetupFindFirstLine SetupFindFirstLineW
#else
#define SetupFindFirstLine SetupFindFirstLineA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupFindNextLine(
    IN  PINFCONTEXT ContextIn,
    OUT PINFCONTEXT ContextOut
    );


WINSETUPAPI
BOOL
WINAPI
SetupFindNextMatchLineA(
    IN  PINFCONTEXT ContextIn,
    IN  PCSTR       Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    );

WINSETUPAPI
BOOL
WINAPI
SetupFindNextMatchLineW(
    IN  PINFCONTEXT ContextIn,
    IN  PCWSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    );

#ifdef UNICODE
#define SetupFindNextMatchLine SetupFindNextMatchLineW
#else
#define SetupFindNextMatchLine SetupFindNextMatchLineA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetLineByIndexA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetLineByIndexW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

#ifdef UNICODE
#define SetupGetLineByIndex SetupGetLineByIndexW
#else
#define SetupGetLineByIndex SetupGetLineByIndexA
#endif


WINSETUPAPI
LONG
WINAPI
SetupGetLineCountA(
    IN HINF  InfHandle,
    IN PCSTR Section
    );

WINSETUPAPI
LONG
WINAPI
SetupGetLineCountW(
    IN HINF   InfHandle,
    IN PCWSTR Section
    );

#ifdef UNICODE
#define SetupGetLineCount SetupGetLineCountW
#else
#define SetupGetLineCount SetupGetLineCountA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetLineTextA(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    IN  PCSTR       Key,              OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetLineTextW(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    IN  PCWSTR      Key,              OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetLineText SetupGetLineTextW
#else
#define SetupGetLineText SetupGetLineTextA
#endif


WINSETUPAPI
DWORD
WINAPI
SetupGetFieldCount(
    IN PINFCONTEXT Context
    );


WINSETUPAPI
BOOL
WINAPI
SetupGetStringFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetStringFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetStringField SetupGetStringFieldW
#else
#define SetupGetStringField SetupGetStringFieldA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue
    );


WINSETUPAPI
BOOL
WINAPI
SetupGetMultiSzFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetMultiSzFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetMultiSzField SetupGetMultiSzFieldW
#else
#define SetupGetMultiSzField SetupGetMultiSzFieldA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetBinaryField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PBYTE       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    );


WINSETUPAPI
DWORD
WINAPI
SetupGetFileCompressionInfoA(
    IN  PCSTR   SourceFileName,
    OUT PSTR   *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    );

WINSETUPAPI
DWORD
WINAPI
SetupGetFileCompressionInfoW(
    IN  PCWSTR  SourceFileName,
    OUT PWSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    );

#ifdef UNICODE
#define SetupGetFileCompressionInfo SetupGetFileCompressionInfoW
#else
#define SetupGetFileCompressionInfo SetupGetFileCompressionInfoA
#endif


//
// Compression types
//
#define FILE_COMPRESSION_NONE       0
#define FILE_COMPRESSION_WINLZA     1
#define FILE_COMPRESSION_MSZIP      2


WINSETUPAPI
DWORD
WINAPI
SetupDecompressOrCopyFileA(
    IN PCSTR SourceFileName,
    IN PCSTR TargetFileName,
    IN PUINT CompressionType OPTIONAL
    );

WINSETUPAPI
DWORD
WINAPI
SetupDecompressOrCopyFileW(
    IN PCWSTR SourceFileName,
    IN PCWSTR TargetFileName,
    IN PUINT  CompressionType OPTIONAL
    );

#ifdef UNICODE
#define SetupDecompressOrCopyFile SetupDecompressOrCopyFileW
#else
#define SetupDecompressOrCopyFile SetupDecompressOrCopyFileA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileLocationA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileLocationW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetSourceFileLocation SetupGetSourceFileLocationW
#else
#define SetupGetSourceFileLocation SetupGetSourceFileLocationA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileSizeA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCSTR       FileName,       OPTIONAL
    IN  PCSTR       Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetSourceFileSizeW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCWSTR      FileName,       OPTIONAL
    IN  PCWSTR      Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    );

#ifdef UNICODE
#define SetupGetSourceFileSize SetupGetSourceFileSizeW
#else
#define SetupGetSourceFileSize SetupGetSourceFileSizeA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupGetTargetPathA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetTargetPathW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetTargetPath SetupGetTargetPathW
#else
#define SetupGetTargetPath SetupGetTargetPathA
#endif


//
// Define flags for SourceList APIs.
//
#define SRCLIST_TEMPORARY       0x00000001
#define SRCLIST_NOBROWSE        0x00000002
#define SRCLIST_SYSTEM          0x00000010
#define SRCLIST_USER            0x00000020
#define SRCLIST_SYSIFADMIN      0x00000040
#define SRCLIST_SUBDIRS         0x00000100
#define SRCLIST_APPEND          0x00000200
#define SRCLIST_NOSTRIPPLATFORM 0x00000400


WINSETUPAPI
BOOL
WINAPI
SetupSetSourceListA(
    IN DWORD  Flags,
    IN PCSTR *SourceList,
    IN UINT   SourceCount
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetSourceListW(
    IN DWORD   Flags,
    IN PCWSTR *SourceList,
    IN UINT    SourceCount
    );

#ifdef UNICODE
#define SetupSetSourceList SetupSetSourceListW
#else
#define SetupSetSourceList SetupSetSourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupCancelTemporarySourceList(
    VOID
    );


WINSETUPAPI
BOOL
WINAPI
SetupAddToSourceListA(
    IN DWORD Flags,
    IN PCSTR Source
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddToSourceListW(
    IN DWORD  Flags,
    IN PCWSTR Source
    );

#ifdef UNICODE
#define SetupAddToSourceList SetupAddToSourceListW
#else
#define SetupAddToSourceList SetupAddToSourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromSourceListA(
    IN DWORD Flags,
    IN PCSTR Source
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromSourceListW(
    IN DWORD  Flags,
    IN PCWSTR Source
    );

#ifdef UNICODE
#define SetupRemoveFromSourceList SetupRemoveFromSourceListW
#else
#define SetupRemoveFromSourceList SetupRemoveFromSourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQuerySourceListA(
    IN  DWORD   Flags,
    OUT PCSTR **List,
    OUT PUINT   Count
    );

WINSETUPAPI
BOOL
WINAPI
SetupQuerySourceListW(
    IN  DWORD    Flags,
    OUT PCWSTR **List,
    OUT PUINT    Count
    );

#ifdef UNICODE
#define SetupQuerySourceList SetupQuerySourceListW
#else
#define SetupQuerySourceList SetupQuerySourceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupFreeSourceListA(
    IN OUT PCSTR **List,
    IN     UINT    Count
    );

WINSETUPAPI
BOOL
WINAPI
SetupFreeSourceListW(
    IN OUT PCWSTR **List,
    IN     UINT     Count
    );

#ifdef UNICODE
#define SetupFreeSourceList SetupFreeSourceListW
#else
#define SetupFreeSourceList SetupFreeSourceListA
#endif


WINSETUPAPI
UINT
WINAPI
SetupPromptForDiskA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  DiskName,         OPTIONAL
    IN  PCSTR  PathToSource,     OPTIONAL
    IN  PCSTR  FileSought,
    IN  PCSTR  TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PSTR   PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize
    );

WINSETUPAPI
UINT
WINAPI
SetupPromptForDiskW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR DiskName,         OPTIONAL
    IN  PCWSTR PathToSource,     OPTIONAL
    IN  PCWSTR FileSought,
    IN  PCWSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PWSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize
    );

#ifdef UNICODE
#define SetupPromptForDisk SetupPromptForDiskW
#else
#define SetupPromptForDisk SetupPromptForDiskA
#endif


WINSETUPAPI
UINT
WINAPI
SetupCopyErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  DiskName,        OPTIONAL
    IN  PCSTR  PathToSource,
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PSTR   PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    );

WINSETUPAPI
UINT
WINAPI
SetupCopyErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR DiskName,        OPTIONAL
    IN  PCWSTR PathToSource,
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PWSTR  PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    );

#ifdef UNICODE
#define SetupCopyError SetupCopyErrorW
#else
#define SetupCopyError SetupCopyErrorA
#endif


WINSETUPAPI
UINT
WINAPI
SetupRenameErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

WINSETUPAPI
UINT
WINAPI
SetupRenameErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

#ifdef UNICODE
#define SetupRenameError SetupRenameErrorW
#else
#define SetupRenameError SetupRenameErrorA
#endif


WINSETUPAPI
UINT
WINAPI
SetupDeleteErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

WINSETUPAPI
UINT
WINAPI
SetupDeleteErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    );

#ifdef UNICODE
#define SetupDeleteError SetupDeleteErrorW
#else
#define SetupDeleteError SetupDeleteErrorA
#endif


//
// Styles for SetupPromptForDisk, SetupCopyError,
// SetupRenameError, SetupDeleteError
//
#define IDF_NOBROWSE        0x00000001
#define IDF_NOSKIP          0x00000002
#define IDF_NODETAILS       0x00000004
#define IDF_NOCOMPRESSED    0x00000008
#define IDF_CHECKFIRST      0x00000100
#define IDF_NOBEEP          0x00000200
#define IDF_NOFOREGROUND    0x00000400
#define IDF_WARNIFSKIP      0x00000800
#define IDF_OEMDISK         0x80000000

//
// Return values for SetupPromptForDisk, SetupCopyError,
// SetupRenameError, SetupDeleteError
//
#define DPROMPT_SUCCESS         0
#define DPROMPT_CANCEL          1
#define DPROMPT_SKIPFILE        2
#define DPROMPT_BUFFERTOOSMALL  3
#define DPROMPT_OUTOFMEMORY     4


WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdA(
    IN HINF  InfHandle,
    IN DWORD Id,            OPTIONAL
    IN PCSTR Directory      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory     OPTIONAL
    );

#ifdef UNICODE
#define SetupSetDirectoryId SetupSetDirectoryIdW
#else
#define SetupSetDirectoryId SetupSetDirectoryIdA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdExA(
    IN HINF  InfHandle,
    IN DWORD Id,            OPTIONAL
    IN PCSTR Directory,     OPTIONAL
    IN DWORD Flags,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetDirectoryIdExW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    );

#ifdef UNICODE
#define SetupSetDirectoryIdEx SetupSetDirectoryIdExW
#else
#define SetupSetDirectoryIdEx SetupSetDirectoryIdExA
#endif

//
// Flags for SetupSetDirectoryIdEx
//
#define SETDIRID_NOT_FULL_PATH      0x00000001


WINSETUPAPI
BOOL
WINAPI
SetupGetSourceInfoA(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupGetSourceInfoW(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupGetSourceInfo SetupGetSourceInfoW
#else
#define SetupGetSourceInfo SetupGetSourceInfoA
#endif

//
// InfoDesired values for SetupGetSourceInfo
//
#define SRCINFO_PATH            1
#define SRCINFO_TAGFILE         2
#define SRCINFO_DESCRIPTION     3


WINSETUPAPI
BOOL
WINAPI
SetupInstallFileA(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCSTR               SourceFile,        OPTIONAL
    IN PCSTR               SourcePathRoot,    OPTIONAL
    IN PCSTR               DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFileW(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCWSTR              SourceFile,        OPTIONAL
    IN PCWSTR              SourcePathRoot,    OPTIONAL
    IN PCWSTR              DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    );

#ifdef UNICODE
#define SetupInstallFile SetupInstallFileW
#else
#define SetupInstallFile SetupInstallFileA
#endif

WINSETUPAPI
BOOL
WINAPI
SetupInstallFileExA(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCSTR               SourceFile,        OPTIONAL
    IN  PCSTR               SourcePathRoot,    OPTIONAL
    IN  PCSTR               DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFileExW(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCWSTR              SourceFile,        OPTIONAL
    IN  PCWSTR              SourcePathRoot,    OPTIONAL
    IN  PCWSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    );

#ifdef UNICODE
#define SetupInstallFileEx SetupInstallFileExW
#else
#define SetupInstallFileEx SetupInstallFileExA
#endif

//
// CopyStyle values for copy and queue-related APIs
//
#define SP_COPY_DELETESOURCE        0x0000001   // delete source file on successful copy
#define SP_COPY_REPLACEONLY         0x0000002   // copy only if target file already present
#define SP_COPY_NEWER               0x0000004   // copy only if source newer than or same as target
#define SP_COPY_NEWER_OR_SAME       SP_COPY_NEWER
#define SP_COPY_NOOVERWRITE         0x0000008   // copy only if target doesn't exist
#define SP_COPY_NODECOMP            0x0000010   // don't decompress source file while copying
#define SP_COPY_LANGUAGEAWARE       0x0000020   // don't overwrite file of different language
#define SP_COPY_SOURCE_ABSOLUTE     0x0000040   // SourceFile is a full source path
#define SP_COPY_SOURCEPATH_ABSOLUTE 0x0000080   // SourcePathRoot is the full path
#define SP_COPY_IN_USE_NEEDS_REBOOT 0x0000100   // System needs reboot if file in use
#define SP_COPY_FORCE_IN_USE        0x0000200   // Force target-in-use behavior
#define SP_COPY_NOSKIP              0x0000400   // Skip is disallowed for this file or section
#define SP_FLAG_CABINETCONTINUATION 0x0000800   // Used with need media notification
#define SP_COPY_FORCE_NOOVERWRITE   0x0001000   // like NOOVERWRITE but no callback nofitication
#define SP_COPY_FORCE_NEWER         0x0002000   // like NEWER but no callback nofitication
#define SP_COPY_WARNIFSKIP          0x0004000   // system critical file: warn if user tries to skip
#define SP_COPY_NOBROWSE            0x0008000   // Browsing is disallowed for this file or section
#define SP_COPY_NEWER_ONLY          0x0010000   // copy only if source file newer than target


WINSETUPAPI
HSPFILEQ
WINAPI
SetupOpenFileQueue(
    VOID
    );

WINSETUPAPI
BOOL
WINAPI
SetupCloseFileQueue(
    IN HSPFILEQ QueueHandle
    );


WINSETUPAPI
BOOL
WINAPI
SetupSetPlatformPathOverrideA(
    IN PCSTR Override   OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupSetPlatformPathOverrideW(
    IN PCWSTR Override  OPTIONAL
    );

#ifdef UNICODE
#define SetupSetPlatformPathOverride SetupSetPlatformPathOverrideW
#else
#define SetupSetPlatformPathOverride SetupSetPlatformPathOverrideA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueCopyA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,
    IN PCSTR    SourcePath,         OPTIONAL
    IN PCSTR    SourceFilename,
    IN PCSTR    SourceDescription,  OPTIONAL
    IN PCSTR    SourceTagfile,      OPTIONAL
    IN PCSTR    TargetDirectory,
    IN PCSTR    TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueCopyW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,
    IN PCWSTR   SourcePath,         OPTIONAL
    IN PCWSTR   SourceFilename,
    IN PCWSTR   SourceDescription,  OPTIONAL
    IN PCWSTR   SourceTagfile,      OPTIONAL
    IN PCWSTR   TargetDirectory,
    IN PCWSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

#ifdef UNICODE
#define SetupQueueCopy SetupQueueCopyW
#else
#define SetupQueueCopy SetupQueueCopyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueDefaultCopyA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCSTR    SourceRootPath,
    IN PCSTR    SourceFilename,
    IN PCSTR    TargetFilename,
    IN DWORD    CopyStyle
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueDefaultCopyW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCWSTR   SourceRootPath,
    IN PCWSTR   SourceFilename,
    IN PCWSTR   TargetFilename,
    IN DWORD    CopyStyle
    );

#ifdef UNICODE
#define SetupQueueDefaultCopy SetupQueueDefaultCopyW
#else
#define SetupQueueDefaultCopy SetupQueueDefaultCopyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueCopySectionA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCSTR    Section,
    IN DWORD    CopyStyle
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueCopySectionW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCWSTR   Section,
    IN DWORD    CopyStyle
    );

#ifdef UNICODE
#define SetupQueueCopySection SetupQueueCopySectionW
#else
#define SetupQueueCopySection SetupQueueCopySectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    PathPart1,
    IN PCSTR    PathPart2       OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   PathPart1,
    IN PCWSTR   PathPart2       OPTIONAL
    );

#ifdef UNICODE
#define SetupQueueDelete SetupQueueDeleteW
#else
#define SetupQueueDelete SetupQueueDeleteA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCSTR    Section
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueDeleteSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCWSTR   Section
    );

#ifdef UNICODE
#define SetupQueueDeleteSection SetupQueueDeleteSectionW
#else
#define SetupQueueDeleteSection SetupQueueDeleteSectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourcePath,
    IN PCSTR    SourceFilename, OPTIONAL
    IN PCSTR    TargetPath,     OPTIONAL
    IN PCSTR    TargetFilename
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourcePath,
    IN PCWSTR   SourceFilename, OPTIONAL
    IN PCWSTR   TargetPath,     OPTIONAL
    IN PCWSTR   TargetFilename
    );

#ifdef UNICODE
#define SetupQueueRename SetupQueueRenameW
#else
#define SetupQueueRename SetupQueueRenameA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCSTR    Section
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueueRenameSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCWSTR   Section
    );

#ifdef UNICODE
#define SetupQueueRenameSection SetupQueueRenameSectionW
#else
#define SetupQueueRenameSection SetupQueueRenameSectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupCommitFileQueueA(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupCommitFileQueueW(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    );

#ifdef UNICODE
#define SetupCommitFileQueue SetupCommitFileQueueW
#else
#define SetupCommitFileQueue SetupCommitFileQueueA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupScanFileQueueA(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_A CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    );

WINSETUPAPI
BOOL
WINAPI
SetupScanFileQueueW(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_W CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    );

#ifdef UNICODE
#define SetupScanFileQueue SetupScanFileQueueW
#else
#define SetupScanFileQueue SetupScanFileQueueA
#endif

//
// Define flags for SetupScanFileQueue.
//
#define SPQ_SCAN_FILE_PRESENCE  0x00000001
#define SPQ_SCAN_FILE_VALIDITY  0x00000002
#define SPQ_SCAN_USE_CALLBACK   0x00000004
#define SPQ_SCAN_INFORM_USER    0x00000010

//
// Define flags used with Param2 for SPFILENOTIFY_QUEUESCAN
//
#define SPQ_DELAYED_COPY        0x00000001  // file was in use; registered for delayed copy


//
// Define OEM Source Type values for use in SetupCopyOEMInf.
//
#define SPOST_NONE  0
#define SPOST_PATH  1
#define SPOST_URL   2
#define SPOST_MAX   3

WINSETUPAPI
BOOL
WINAPI
SetupCopyOEMInfA(
    IN  PCSTR   SourceInfFileName,
    IN  PCSTR   OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PSTR    DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PSTR   *DestinationInfFileNameComponent OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupCopyOEMInfW(
    IN  PCWSTR  SourceInfFileName,
    IN  PCWSTR  OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PWSTR   DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PWSTR  *DestinationInfFileNameComponent OPTIONAL
    );

#ifdef UNICODE
#define SetupCopyOEMInf SetupCopyOEMInfW
#else
#define SetupCopyOEMInf SetupCopyOEMInfA
#endif


//
// Disk space list APIs
//
WINSETUPAPI
HDSKSPC
WINAPI
SetupCreateDiskSpaceListA(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    );

WINSETUPAPI
HDSKSPC
WINAPI
SetupCreateDiskSpaceListW(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    );

#ifdef UNICODE
#define SetupCreateDiskSpaceList SetupCreateDiskSpaceListW
#else
#define SetupCreateDiskSpaceList SetupCreateDiskSpaceListA
#endif

//
// Flags for SetupCreateDiskSpaceList
//
#define SPDSL_IGNORE_DISK              0x00000001  // ignore deletes and on-disk files in copies
#define SPDSL_DISALLOW_NEGATIVE_ADJUST 0x00000002


WINSETUPAPI
HDSKSPC
WINAPI
SetupDuplicateDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    );

WINSETUPAPI
HDSKSPC
WINAPI
SetupDuplicateDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    );

#ifdef UNICODE
#define SetupDuplicateDiskSpaceList SetupDuplicateDiskSpaceListW
#else
#define SetupDuplicateDiskSpaceList SetupDuplicateDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDestroyDiskSpaceList(
    IN OUT HDSKSPC DiskSpace
    );


WINSETUPAPI
BOOL
WINAPI
SetupQueryDrivesInDiskSpaceListA(
    IN  HDSKSPC DiskSpace,
    OUT PSTR    ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryDrivesInDiskSpaceListW(
    IN  HDSKSPC DiskSpace,
    OUT PWSTR   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryDrivesInDiskSpaceList SetupQueryDrivesInDiskSpaceListW
#else
#define SetupQueryDrivesInDiskSpaceList SetupQueryDrivesInDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupQuerySpaceRequiredOnDriveA(
    IN  HDSKSPC   DiskSpace,
    IN  PCSTR     DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupQuerySpaceRequiredOnDriveW(
    IN  HDSKSPC   DiskSpace,
    IN  PCWSTR    DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    );

#ifdef UNICODE
#define SetupQuerySpaceRequiredOnDrive SetupQuerySpaceRequiredOnDriveW
#else
#define SetupQuerySpaceRequiredOnDrive SetupQuerySpaceRequiredOnDriveA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAdjustDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN LPCSTR   DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAdjustDiskSpaceListW(
    IN HDSKSPC  DiskSpace,
    IN LPCWSTR  DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

#ifdef UNICODE
#define SetupAdjustDiskSpaceList SetupAdjustDiskSpaceListW
#else
#define SetupAdjustDiskSpaceList SetupAdjustDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAddToDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN PCSTR    TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddToDiskSpaceListW(
    IN HDSKSPC  DiskSpace,
    IN PCWSTR   TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    );

#ifdef UNICODE
#define SetupAddToDiskSpaceList SetupAddToDiskSpaceListW
#else
#define SetupAddToDiskSpaceList SetupAddToDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAddSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddSectionToDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCWSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupAddSectionToDiskSpaceList SetupAddSectionToDiskSpaceListW
#else
#define SetupAddSectionToDiskSpaceList SetupAddSectionToDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupAddInstallSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupAddInstallSectionToDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCWSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupAddInstallSectionToDiskSpaceList SetupAddInstallSectionToDiskSpaceListW
#else
#define SetupAddInstallSectionToDiskSpaceList SetupAddInstallSectionToDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PCSTR   TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN PCWSTR  TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupRemoveFromDiskSpaceList SetupRemoveFromDiskSpaceListW
#else
#define SetupRemoveFromDiskSpaceList SetupRemoveFromDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveSectionFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCWSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupRemoveSectionFromDiskSpaceList SetupRemoveSectionFromDiskSpaceListW
#else
#define SetupRemoveSectionFromDiskSpaceList SetupRemoveSectionFromDiskSpaceListA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupRemoveInstallSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveInstallSectionFromDiskSpaceListW(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCWSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    );

#ifdef UNICODE
#define SetupRemoveInstallSectionFromDiskSpaceList SetupRemoveInstallSectionFromDiskSpaceListW
#else
#define SetupRemoveInstallSectionFromDiskSpaceList SetupRemoveInstallSectionFromDiskSpaceListA
#endif


//
// Cabinet APIs
//

WINSETUPAPI
BOOL
WINAPI
SetupIterateCabinetA(
    IN  PCSTR               CabinetFile,
    IN  DWORD               Reserved,
    IN  PSP_FILE_CALLBACK_A MsgHandler,
    IN  PVOID               Context
    );

WINSETUPAPI
BOOL
WINAPI
SetupIterateCabinetW(
    IN  PCWSTR              CabinetFile,
    IN  DWORD               Reserved,
    IN  PSP_FILE_CALLBACK_W MsgHandler,
    IN  PVOID               Context
    );

#ifdef UNICODE
#define SetupIterateCabinet SetupIterateCabinetW
#else
#define SetupIterateCabinet SetupIterateCabinetA
#endif


WINSETUPAPI
INT
WINAPI
SetupPromptReboot(
    IN HSPFILEQ FileQueue,  OPTIONAL
    IN HWND     Owner,
    IN BOOL     ScanOnly
    );

//
// Define flags that are returned by SetupPromptReboot
//
#define SPFILEQ_FILE_IN_USE         0x00000001
#define SPFILEQ_REBOOT_RECOMMENDED  0x00000002
#define SPFILEQ_REBOOT_IN_PROGRESS  0x00000004


WINSETUPAPI
PVOID
WINAPI
SetupInitDefaultQueueCallback(
    IN HWND OwnerWindow
    );

WINSETUPAPI
PVOID
WINAPI
SetupInitDefaultQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    );

WINSETUPAPI
VOID
WINAPI
SetupTermDefaultQueueCallback(
    IN PVOID Context
    );

WINSETUPAPI
UINT
WINAPI
SetupDefaultQueueCallbackA(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT  Param1,
    IN UINT  Param2
    );

WINSETUPAPI
UINT
WINAPI
SetupDefaultQueueCallbackW(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT  Param1,
    IN UINT  Param2
    );

#ifdef UNICODE
#define SetupDefaultQueueCallback SetupDefaultQueueCallbackW
#else
#define SetupDefaultQueueCallback SetupDefaultQueueCallbackA
#endif


//
// Flags for AddReg section lines in INF.  The corresponding value
// is <ValueType> in the AddReg line format given below:
//
// <RegRootString>,<SubKey>,<ValueName>,<ValueType>,<Value>...
//
// The low word contains basic flags concerning the general data type
// and AddReg action. The high word contains values that more specifically
// identify the data type of the registry value.  The high word is ignored
// by the 16-bit Windows 95 SETUPX APIs.
//
#define FLG_ADDREG_BINVALUETYPE     ( 0x00000001 )
#define FLG_ADDREG_NOCLOBBER        ( 0x00000002 )
#define FLG_ADDREG_DELVAL           ( 0x00000004 )
#define FLG_ADDREG_APPEND           ( 0x00000008 ) // Currently supported only
                                                   // for REG_MULTI_SZ values.
#define FLG_ADDREG_KEYONLY          ( 0x00000010 ) // Just create the key, ignore value
#define FLG_ADDREG_OVERWRITEONLY    ( 0x00000020 ) // Set only if value already exists

#define FLG_ADDREG_TYPE_MASK        ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_SZ          ( 0x00000000                           )
#define FLG_ADDREG_TYPE_MULTI_SZ    ( 0x00010000                           )
#define FLG_ADDREG_TYPE_EXPAND_SZ   ( 0x00020000                           )
#define FLG_ADDREG_TYPE_BINARY      ( 0x00000000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_DWORD       ( 0x00010000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_NONE        ( 0x00020000 | FLG_ADDREG_BINVALUETYPE )

//
// The INF may supply any arbitrary data type ordinal in the highword except
// for the following: REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ.  If this
// technique is used, then the data is given in binary format, one byte per
// field.
//


WINSETUPAPI
BOOL
WINAPI
SetupInstallFromInfSectionA(
    IN HWND                Owner,
    IN HINF                InfHandle,
    IN PCSTR               SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCSTR               SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context,
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFromInfSectionW(
    IN HWND                Owner,
    IN HINF                InfHandle,
    IN PCWSTR              SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCWSTR              SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context,
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    );

#ifdef UNICODE
#define SetupInstallFromInfSection SetupInstallFromInfSectionW
#else
#define SetupInstallFromInfSection SetupInstallFromInfSectionA
#endif

//
// Flags for SetupInstallFromInfSection
//
#define SPINST_LOGCONFIG                0x00000001
#define SPINST_INIFILES                 0x00000002
#define SPINST_REGISTRY                 0x00000004
#define SPINST_INI2REG                  0x00000008
#define SPINST_FILES                    0x00000010
#define SPINST_ALL                      0x0000001f
#define SPINST_SINGLESECTION            0x00010000
#define SPINST_LOGCONFIG_IS_FORCED      0x00020000
#define SPINST_LOGCONFIGS_ARE_OVERRIDES 0x00040000


WINSETUPAPI
BOOL
WINAPI
SetupInstallFilesFromInfSectionA(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCSTR    SectionName,
    IN PCSTR    SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallFilesFromInfSectionW(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCWSTR   SectionName,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    );

#ifdef UNICODE
#define SetupInstallFilesFromInfSection SetupInstallFilesFromInfSectionW
#else
#define SetupInstallFilesFromInfSection SetupInstallFilesFromInfSectionA
#endif


//
// Flags for SetupInstallServicesFromInfSection(Ex).  These flags are also used in
// the flags field of AddService or DelService lines in a device INF.  Some of these
// flags are not permitted in the non-Ex API.  These flags are marked as such below.
//
#define SPSVCINST_TAGTOFRONT          (0x00000001)  // (AddService) move service's tag to front of its group order list
#define SPSVCINST_ASSOCSERVICE        (0x00000002)  // (AddService) **Ex API only** mark this service as the function
                                                    // driver for the device being installed.
#define SPSVCINST_DELETEEVENTLOGENTRY (0x00000004)  // (DelService) delete the associated event log entry for a service
                                                    // specified in a DelService entry

WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionA(
    IN HINF   InfHandle,
    IN PCSTR  SectionName,
    IN DWORD  Flags
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionW(
    IN HINF   InfHandle,
    IN PCWSTR SectionName,
    IN DWORD  Flags
    );

#ifdef UNICODE
#define SetupInstallServicesFromInfSection SetupInstallServicesFromInfSectionW
#else
#define SetupInstallServicesFromInfSection SetupInstallServicesFromInfSectionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionExA(
    IN HINF             InfHandle,
    IN PCSTR            SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionExW(
    IN HINF             InfHandle,
    IN PCWSTR           SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    );

#ifdef UNICODE
#define SetupInstallServicesFromInfSectionEx SetupInstallServicesFromInfSectionExW
#else
#define SetupInstallServicesFromInfSectionEx SetupInstallServicesFromInfSectionExA
#endif


//
// Define handle type for Setup file log.
//
typedef PVOID HSPFILELOG;

WINSETUPAPI
HSPFILELOG
WINAPI
SetupInitializeFileLogA(
    IN PCSTR LogFileName,   OPTIONAL
    IN DWORD Flags
    );

WINSETUPAPI
HSPFILELOG
WINAPI
SetupInitializeFileLogW(
    IN PCWSTR LogFileName,  OPTIONAL
    IN DWORD  Flags
    );

#ifdef UNICODE
#define SetupInitializeFileLog SetupInitializeFileLogW
#else
#define SetupInitializeFileLog SetupInitializeFileLogA
#endif

//
// Flags for SetupInitializeFileLog
//
#define SPFILELOG_SYSTEMLOG     0x00000001  // use system log -- must be Administrator
#define SPFILELOG_FORCENEW      0x00000002  // not valid with SPFILELOG_SYSTEMLOG
#define SPFILELOG_QUERYONLY     0x00000004  // allows non-administrators to read system log


WINSETUPAPI
BOOL
WINAPI
SetupTerminateFileLog(
    IN HSPFILELOG FileLogHandle
    );


WINSETUPAPI
BOOL
WINAPI
SetupLogFileA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      SourceFilename,
    IN PCSTR      TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCSTR      DiskTagfile,      OPTIONAL
    IN PCSTR      DiskDescription,  OPTIONAL
    IN PCSTR      OtherInfo,        OPTIONAL
    IN DWORD      Flags
    );

WINSETUPAPI
BOOL
WINAPI
SetupLogFileW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     SourceFilename,
    IN PCWSTR     TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCWSTR     DiskTagfile,      OPTIONAL
    IN PCWSTR     DiskDescription,  OPTIONAL
    IN PCWSTR     OtherInfo,        OPTIONAL
    IN DWORD      Flags
    );

#ifdef UNICODE
#define SetupLogFile SetupLogFileW
#else
#define SetupLogFile SetupLogFileA
#endif

//
// Flags for SetupLogFile
//
#define SPFILELOG_OEMFILE   0x00000001


WINSETUPAPI
BOOL
WINAPI
SetupRemoveFileLogEntryA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      TargetFilename    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupRemoveFileLogEntryW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     TargetFilename    OPTIONAL
    );

#ifdef UNICODE
#define SetupRemoveFileLogEntry SetupRemoveFileLogEntryW
#else
#define SetupRemoveFileLogEntry SetupRemoveFileLogEntryA
#endif


//
// Items retrievable from SetupQueryFileLog()
//
typedef enum {
    SetupFileLogSourceFilename,
    SetupFileLogChecksum,
    SetupFileLogDiskTagfile,
    SetupFileLogDiskDescription,
    SetupFileLogOtherInfo,
    SetupFileLogMax
} SetupFileLogInfo;

WINSETUPAPI
BOOL
WINAPI
SetupQueryFileLogA(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCSTR            LogSectionName,   OPTIONAL
    IN  PCSTR            TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PSTR             DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupQueryFileLogW(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCWSTR           LogSectionName,   OPTIONAL
    IN  PCWSTR           TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PWSTR            DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupQueryFileLog SetupQueryFileLogW
#else
#define SetupQueryFileLog SetupQueryFileLogA
#endif

//
// Text logging APIs
//

typedef enum {
    LogSevInformation,
    LogSevWarning,
    LogSevError,
    LogSevFatalError,
    LogSevMaximum
} LogSeverity;

WINSETUPAPI
BOOL
WINAPI
SetupOpenLog (
    BOOL Erase
    );

WINSETUPAPI
BOOL
WINAPI
SetupLogErrorA (
    IN  LPCSTR              MessageString,
    IN  LogSeverity         Severity
    );

WINSETUPAPI
BOOL
WINAPI
SetupLogErrorW (
    IN  LPCWSTR             MessageString,
    IN  LogSeverity         Severity
    );

#ifdef UNICODE
#define SetupLogError SetupLogErrorW
#else
#define SetupLogError SetupLogErrorA
#endif

WINSETUPAPI
VOID
WINAPI
SetupCloseLog (
    VOID
    );





//
// Device Installer APIs
//

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoList(
    IN LPGUID ClassGuid, OPTIONAL
    IN HWND   hwndParent OPTIONAL
    );


WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListExA(
    IN LPGUID ClassGuid,   OPTIONAL
    IN HWND   hwndParent,  OPTIONAL
    IN PCSTR  MachineName, OPTIONAL
    IN PVOID  Reserved
    );

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListExW(
    IN LPGUID ClassGuid,   OPTIONAL
    IN HWND   hwndParent,  OPTIONAL
    IN PCWSTR MachineName, OPTIONAL
    IN PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInfoListEx SetupDiCreateDeviceInfoListExW
#else
#define SetupDiCreateDeviceInfoListEx SetupDiCreateDeviceInfoListExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListClass(
    IN  HDEVINFO DeviceInfoSet,
    OUT LPGUID   ClassGuid
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListDetailA(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A DeviceInfoSetDetailData
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListDetailW(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_W DeviceInfoSetDetailData
    );

#ifdef UNICODE
#define SetupDiGetDeviceInfoListDetail SetupDiGetDeviceInfoListDetailW
#else
#define SetupDiGetDeviceInfoListDetail SetupDiGetDeviceInfoListDetailA
#endif


//
// Flags for SetupDiCreateDeviceInfo
//
#define DICD_GENERATE_ID        0x00000001
#define DICD_INHERIT_CLASSDRVS  0x00000002

WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInfoA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCSTR            DeviceName,
    IN  LPGUID           ClassGuid,
    IN  PCSTR            DeviceDescription, OPTIONAL
    IN  HWND             hwndParent,        OPTIONAL
    IN  DWORD            CreationFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData     OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInfoW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceName,
    IN  LPGUID           ClassGuid,
    IN  PCWSTR           DeviceDescription, OPTIONAL
    IN  HWND             hwndParent,        OPTIONAL
    IN  DWORD            CreationFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData     OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInfo SetupDiCreateDeviceInfoW
#else
#define SetupDiCreateDeviceInfo SetupDiCreateDeviceInfoA
#endif


//
// Flags for SetupDiOpenDeviceInfo
//
#define DIOD_INHERIT_CLASSDRVS  0x00000002
#define DIOD_CANCEL_REMOVE      0x00000004

WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInfoA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCSTR            DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInfoW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    );

#ifdef UNICODE
#define SetupDiOpenDeviceInfo SetupDiOpenDeviceInfoW
#else
#define SetupDiOpenDeviceInfo SetupDiOpenDeviceInfoA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstanceIdA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstanceIdW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PWSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDeviceInstanceId SetupDiGetDeviceInstanceIdW
#else
#define SetupDiGetDeviceInstanceId SetupDiGetDeviceInstanceIdA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyDeviceInfoList(
    IN HDEVINFO DeviceInfoSet
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInterfaces(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
    IN  LPGUID                    InterfaceClassGuid,
    IN  DWORD                     MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );

//
// Backward compatibility--do not use
//
#define SetupDiEnumInterfaceDevice SetupDiEnumDeviceInterfaces


WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInterfaceA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,
    IN  LPGUID                    InterfaceClassGuid,
    IN  PCSTR                     ReferenceString,    OPTIONAL
    IN  DWORD                     CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInterfaceW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,
    IN  LPGUID                    InterfaceClassGuid,
    IN  PCWSTR                    ReferenceString,    OPTIONAL
    IN  DWORD                     CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInterface SetupDiCreateDeviceInterfaceW
#else
#define SetupDiCreateDeviceInterface SetupDiCreateDeviceInterfaceA
#endif

//
// Backward compatibility--do not use.
//
#define SetupDiCreateInterfaceDeviceW SetupDiCreateDeviceInterfaceW
#define SetupDiCreateInterfaceDeviceA SetupDiCreateDeviceInterfaceA
#ifdef UNICODE
#define SetupDiCreateInterfaceDevice SetupDiCreateDeviceInterfaceW
#else
#define SetupDiCreateInterfaceDevice SetupDiCreateDeviceInterfaceA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInterfaceA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInterfaceW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCWSTR                    DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );

#ifdef UNICODE
#define SetupDiOpenDeviceInterface SetupDiOpenDeviceInterfaceW
#else
#define SetupDiOpenDeviceInterface SetupDiOpenDeviceInterfaceA
#endif

//
// Backward compatibility--do not use
//
#define SetupDiOpenInterfaceDeviceW SetupDiOpenDeviceInterfaceW
#define SetupDiOpenInterfaceDeviceA SetupDiOpenDeviceInterfaceA
#ifdef UNICODE
#define SetupDiOpenInterfaceDevice SetupDiOpenDeviceInterfaceW
#else
#define SetupDiOpenInterfaceDevice SetupDiOpenDeviceInterfaceA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceAlias(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN  LPGUID                    AliasInterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiGetInterfaceDeviceAlias SetupDiGetDeviceInterfaceAlias


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInterfaceData(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiDeleteInterfaceDeviceData SetupDiDeleteDeviceInterfaceData


WINSETUPAPI
BOOL
WINAPI
SetupDiRemoveDeviceInterface(
    IN     HDEVINFO                  DeviceInfoSet,
    IN OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiRemoveInterfaceDevice SetupDiRemoveDeviceInterface


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailA(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailW(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDeviceInterfaceDetail SetupDiGetDeviceInterfaceDetailW
#else
#define SetupDiGetDeviceInterfaceDetail SetupDiGetDeviceInterfaceDetailA
#endif

//
// Backward compatibility--do not use.
//
#define SetupDiGetInterfaceDeviceDetailW SetupDiGetDeviceInterfaceDetailW
#define SetupDiGetInterfaceDeviceDetailA SetupDiGetDeviceInterfaceDetailA
#ifdef UNICODE
#define SetupDiGetInterfaceDeviceDetail SetupDiGetDeviceInterfaceDetailW
#else
#define SetupDiGetInterfaceDeviceDetail SetupDiGetDeviceInterfaceDetailA
#endif


//
// Default install handler for DIF_INSTALLINTERFACES.
//
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDeviceInterfaces(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

//
// Backward compatibility--do not use.
//
#define SetupDiInstallInterfaceDevices SetupDiInstallDeviceInterfaces


//
// Default install handler for DIF_REGISTERDEVICE
//

//
// Flags for SetupDiRegisterDeviceInfo
//
#define SPRDI_FIND_DUPS        0x00000001

WINSETUPAPI
BOOL
WINAPI
SetupDiRegisterDeviceInfo(
    IN     HDEVINFO           DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA   DeviceInfoData,
    IN     DWORD              Flags,
    IN     PSP_DETSIG_CMPPROC CompareProc,      OPTIONAL
    IN     PVOID              CompareContext,   OPTIONAL
    OUT    PSP_DEVINFO_DATA   DupDeviceInfoData OPTIONAL
    );


//
// Ordinal values distinguishing between class drivers and
// device drivers.
// (Passed in 'DriverType' parameter of driver information list APIs)
//
#define SPDIT_NODRIVER           0x00000000
#define SPDIT_CLASSDRIVER        0x00000001
#define SPDIT_COMPATDRIVER       0x00000002

WINSETUPAPI
BOOL
WINAPI
SetupDiBuildDriverInfoList(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     DWORD            DriverType
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiCancelDriverInfoSearch(
    IN HDEVINFO DeviceInfoSet
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDriverInfoA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDriverInfoW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    );

#ifdef UNICODE
#define SetupDiEnumDriverInfo SetupDiEnumDriverInfoW
#else
#define SetupDiEnumDriverInfo SetupDiEnumDriverInfoA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDriverA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDriverW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    );

#ifdef UNICODE
#define SetupDiGetSelectedDriver SetupDiGetSelectedDriverW
#else
#define SetupDiGetSelectedDriver SetupDiGetSelectedDriverA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDriverA(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_A DriverInfoData  OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDriverW(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_W DriverInfoData  OPTIONAL
    );

#ifdef UNICODE
#define SetupDiSetSelectedDriver SetupDiSetSelectedDriverW
#else
#define SetupDiSetSelectedDriver SetupDiSetSelectedDriverA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInfoDetailA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_A        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_A DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInfoDetailW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_W        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_W DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDriverInfoDetail SetupDiGetDriverInfoDetailW
#else
#define SetupDiGetDriverInfoDetail SetupDiGetDriverInfoDetailA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyDriverInfoList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            DriverType
    );


//
// Flags controlling what is included in the device information set built
// by SetupDiGetClassDevs
//
#define DIGCF_DEFAULT           0x00000001  // only valid with DIGCF_DEVICEINTERFACE
#define DIGCF_PRESENT           0x00000002
#define DIGCF_ALLCLASSES        0x00000004
#define DIGCF_PROFILE           0x00000008
#define DIGCF_DEVICEINTERFACE   0x00000010

//
// Backward compatibility--do not use.
//
#define DIGCF_INTERFACEDEVICE DIGCF_DEVICEINTERFACE


WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsA(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCSTR  Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
    );

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsW(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCWSTR Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
    );

#ifdef UNICODE
#define SetupDiGetClassDevs SetupDiGetClassDevsW
#else
#define SetupDiGetClassDevs SetupDiGetClassDevsA
#endif


WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsExA(
    IN LPGUID ClassGuid,   OPTIONAL
    IN PCSTR  Enumerator,  OPTIONAL
    IN HWND   hwndParent,  OPTIONAL
    IN DWORD  Flags,
    IN PCSTR  MachineName, OPTIONAL
    IN PVOID  Reserved
    );

WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsExW(
    IN LPGUID ClassGuid,   OPTIONAL
    IN PCWSTR Enumerator,  OPTIONAL
    IN HWND   hwndParent,  OPTIONAL
    IN DWORD  Flags,
    IN PCWSTR MachineName, OPTIONAL
    IN PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiGetClassDevsEx SetupDiGetClassDevsExW
#else
#define SetupDiGetClassDevsEx SetupDiGetClassDevsExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetINFClassA(
    IN  PCSTR  InfName,
    OUT LPGUID ClassGuid,
    OUT PSTR   ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetINFClassW(
    IN  PCWSTR InfName,
    OUT LPGUID ClassGuid,
    OUT PWSTR  ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetINFClass SetupDiGetINFClassW
#else
#define SetupDiGetINFClass SetupDiGetINFClassA
#endif


//
// Flags controlling exclusion from the class information list built
// by SetupDiBuildClassInfoList(Ex)
//
#define DIBCI_NOINSTALLCLASS   0x00000001
#define DIBCI_NODISPLAYCLASS   0x00000002

WINSETUPAPI
BOOL
WINAPI
SetupDiBuildClassInfoList(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiBuildClassInfoListExA(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiBuildClassInfoListExW(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCWSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiBuildClassInfoListEx SetupDiBuildClassInfoListExW
#else
#define SetupDiBuildClassInfoListEx SetupDiBuildClassInfoListExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionA(
    IN  LPGUID ClassGuid,
    OUT PSTR   ClassDescription,
    IN  DWORD  ClassDescriptionSize,
    OUT PDWORD RequiredSize          OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionW(
    IN  LPGUID ClassGuid,
    OUT PWSTR  ClassDescription,
    IN  DWORD  ClassDescriptionSize,
    OUT PDWORD RequiredSize          OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetClassDescription SetupDiGetClassDescriptionW
#else
#define SetupDiGetClassDescription SetupDiGetClassDescriptionA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionExA(
    IN  LPGUID ClassGuid,
    OUT PSTR   ClassDescription,
    IN  DWORD  ClassDescriptionSize,
    OUT PDWORD RequiredSize,         OPTIONAL
    IN  PCSTR  MachineName,          OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDescriptionExW(
    IN  LPGUID ClassGuid,
    OUT PWSTR  ClassDescription,
    IN  DWORD  ClassDescriptionSize,
    OUT PDWORD RequiredSize,         OPTIONAL
    IN  PCWSTR MachineName,          OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiGetClassDescriptionEx SetupDiGetClassDescriptionExW
#else
#define SetupDiGetClassDescriptionEx SetupDiGetClassDescriptionExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


//
// Default install handler for DIF_SELECTDEVICE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiSelectDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


//
// Default install handler for DIF_SELECTBESTCOMPATDRV
//
WINSETUPAPI
BOOL
WINAPI
SetupDiSelectBestCompatDrv(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


//
// Default install handler for DIF_INSTALLDEVICE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_INSTALLDEVICEFILES
//
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDriverFiles(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_REGISTER_COINSTALLERS
//
WINSETUPAPI
BOOL
WINAPI
SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_REMOVE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiRemoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_UNREMOVE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiUnremoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Default install handler for DIF_MOVEDEVICE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiMoveDuplicateDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DestinationDeviceInfoData
    );


//
// Default install handler for DIF_PROPERTYCHANGE
//
WINSETUPAPI
BOOL
WINAPI
SetupDiChangeState(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassA(
    IN HWND     hwndParent,  OPTIONAL
    IN PCSTR    InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassW(
    IN HWND     hwndParent,  OPTIONAL
    IN PCWSTR   InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    );

#ifdef UNICODE
#define SetupDiInstallClass SetupDiInstallClassW
#else
#define SetupDiInstallClass SetupDiInstallClassA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassExA(
    IN HWND     hwndParent,         OPTIONAL
    IN PCSTR    InfFileName,        OPTIONAL
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue,          OPTIONAL
    IN LPGUID   InterfaceClassGuid, OPTIONAL
    IN PVOID    Reserved1,
    IN PVOID    Reserved2
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiInstallClassExW(
    IN HWND     hwndParent,         OPTIONAL
    IN PCWSTR   InfFileName,        OPTIONAL
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue,          OPTIONAL
    IN LPGUID   InterfaceClassGuid, OPTIONAL
    IN PVOID    Reserved1,
    IN PVOID    Reserved2
    );

#ifdef UNICODE
#define SetupDiInstallClassEx SetupDiInstallClassExW
#else
#define SetupDiInstallClassEx SetupDiInstallClassExA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiOpenClassRegKey(
    IN LPGUID ClassGuid, OPTIONAL
    IN REGSAM samDesired
    );


//
// Flags for SetupDiOpenClassRegKeyEx
//
#define DIOCR_INSTALLER   0x00000001    // class installer registry branch
#define DIOCR_INTERFACE   0x00000002    // interface class registry branch

WINSETUPAPI
HKEY
WINAPI
SetupDiOpenClassRegKeyExA(
    IN LPGUID ClassGuid,   OPTIONAL
    IN REGSAM samDesired,
    IN DWORD  Flags,
    IN PCSTR  MachineName, OPTIONAL
    IN PVOID  Reserved
    );

WINSETUPAPI
HKEY
WINAPI
SetupDiOpenClassRegKeyExW(
    IN LPGUID ClassGuid,   OPTIONAL
    IN REGSAM samDesired,
    IN DWORD  Flags,
    IN PCWSTR MachineName, OPTIONAL
    IN PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiOpenClassRegKeyEx SetupDiOpenClassRegKeyExW
#else
#define SetupDiOpenClassRegKeyEx SetupDiOpenClassRegKeyExA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyA(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCSTR                     InfSectionName       OPTIONAL
    );

WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyW(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCWSTR                    InfSectionName       OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDeviceInterfaceRegKey SetupDiCreateDeviceInterfaceRegKeyW
#else
#define SetupDiCreateDeviceInterfaceRegKey SetupDiCreateDeviceInterfaceRegKeyA
#endif

//
// Backward compatibility--do not use.
//
#define SetupDiCreateInterfaceDeviceRegKeyW SetupDiCreateDeviceInterfaceRegKeyW
#define SetupDiCreateInterfaceDeviceRegKeyA SetupDiCreateDeviceInterfaceRegKeyA
#ifdef UNICODE
#define SetupDiCreateInterfaceDeviceRegKey SetupDiCreateDeviceInterfaceRegKeyW
#else
#define SetupDiCreateInterfaceDeviceRegKey SetupDiCreateDeviceInterfaceRegKeyA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiOpenDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired
    );

//
// Backward compatibility--do not use.
//
#define SetupDiOpenInterfaceDeviceRegKey SetupDiOpenDeviceInterfaceRegKey


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved
    );

//
// Backward compatibility--do not use.
//
#define SetupDiDeleteInterfaceDeviceRegKey SetupDiDeleteDeviceInterfaceRegKey


//
// KeyType values for SetupDiCreateDevRegKey, SetupDiOpenDevRegKey, and
// SetupDiDeleteDevRegKey.
//
#define DIREG_DEV       0x00000001          // Open/Create/Delete device key
#define DIREG_DRV       0x00000002          // Open/Create/Delete driver key
#define DIREG_BOTH      0x00000004          // Delete both driver and Device key

WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDevRegKeyA(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCSTR            InfSectionName  OPTIONAL
    );

WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDevRegKeyW(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCWSTR           InfSectionName  OPTIONAL
    );

#ifdef UNICODE
#define SetupDiCreateDevRegKey SetupDiCreateDevRegKeyW
#else
#define SetupDiCreateDevRegKey SetupDiCreateDevRegKeyA
#endif


WINSETUPAPI
HKEY
WINAPI
SetupDiOpenDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN REGSAM           samDesired
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileList(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex OPTIONAL
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileListExA(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCSTR  MachineName,          OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileListExW(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCWSTR MachineName,          OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiGetHwProfileListEx SetupDiGetHwProfileListExW
#else
#define SetupDiGetHwProfileListEx SetupDiGetHwProfileListExA
#endif


//
// Device registry property codes
// (Codes marked as read-only (R) may only be used for
// SetupDiGetDeviceRegistryProperty)
//
// These values should cover the same set of registry properties
// as defined by the CM_DRP codes in cfgmgr32.h.
//
#define SPDRP_DEVICEDESC                  (0x00000000)  // DeviceDesc (R/W)
#define SPDRP_HARDWAREID                  (0x00000001)  // HardwareID (R/W)
#define SPDRP_COMPATIBLEIDS               (0x00000002)  // CompatibleIDs (R/W)
#define SPDRP_NTDEVICEPATHS               (0x00000003)  // Unsupported, DO NOT USE
#define SPDRP_SERVICE                     (0x00000004)  // Service (R/W)
#define SPDRP_CONFIGURATION               (0x00000005)  // Configuration (R)
#define SPDRP_CONFIGURATIONVECTOR         (0x00000006)  // ConfigurationVector (R)
#define SPDRP_CLASS                       (0x00000007)  // Class (R--tied to ClassGUID)
#define SPDRP_CLASSGUID                   (0x00000008)  // ClassGUID (R/W)
#define SPDRP_DRIVER                      (0x00000009)  // Driver (R/W)
#define SPDRP_CONFIGFLAGS                 (0x0000000A)  // ConfigFlags (R/W)
#define SPDRP_MFG                         (0x0000000B)  // Mfg (R/W)
#define SPDRP_FRIENDLYNAME                (0x0000000C)  // FriendlyName (R/W)
#define SPDRP_LOCATION_INFORMATION        (0x0000000D)  // LocationInformation (R/W)
#define SPDRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000E)  // PhysicalDeviceObjectName (R)
#define SPDRP_CAPABILITIES                (0x0000000F)  // Capabilities (R)
#define SPDRP_UI_NUMBER                   (0x00000010)  // UiNumber (R)
#define SPDRP_UPPERFILTERS                (0x00000011)  // UpperFilters (R/W)
#define SPDRP_LOWERFILTERS                (0x00000012)  // LowerFilters (R/W)
#define SPDRP_MAXIMUM_PROPERTY            (0x00000013)  // Upper bound on ordinals

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetDeviceRegistryProperty SetupDiGetDeviceRegistryPropertyW
#else
#define SetupDiGetDeviceRegistryProperty SetupDiGetDeviceRegistryPropertyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyA(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,
    IN     DWORD            PropertyBufferSize
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyW(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,
    IN     DWORD            PropertyBufferSize
    );

#ifdef UNICODE
#define SetupDiSetDeviceRegistryProperty SetupDiSetDeviceRegistryPropertyW
#else
#define SetupDiSetDeviceRegistryProperty SetupDiSetDeviceRegistryPropertyA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    );

#ifdef UNICODE
#define SetupDiGetDeviceInstallParams SetupDiGetDeviceInstallParamsW
#else
#define SetupDiGetDeviceInstallParams SetupDiGetDeviceInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetClassInstallParams SetupDiGetClassInstallParamsW
#else
#define SetupDiGetClassInstallParams SetupDiGetClassInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    );

#ifdef UNICODE
#define SetupDiSetDeviceInstallParams SetupDiSetDeviceInstallParamsW
#else
#define SetupDiSetDeviceInstallParams SetupDiSetDeviceInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    );

#ifdef UNICODE
#define SetupDiSetClassInstallParams SetupDiSetClassInstallParamsW
#else
#define SetupDiSetClassInstallParams SetupDiSetClassInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInstallParamsA(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_A    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInstallParamsW(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_W    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

#ifdef UNICODE
#define SetupDiGetDriverInstallParams SetupDiGetDriverInstallParamsW
#else
#define SetupDiGetDriverInstallParams SetupDiGetDriverInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiSetDriverInstallParamsA(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA_A    DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiSetDriverInstallParamsW(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA_W    DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

#ifdef UNICODE
#define SetupDiSetDriverInstallParams SetupDiSetDriverInstallParamsW
#else
#define SetupDiSetDriverInstallParams SetupDiSetDriverInstallParamsA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiLoadClassIcon(
    IN  LPGUID  ClassGuid,
    OUT HICON  *LargeIcon,    OPTIONAL
    OUT PINT    MiniIconIndex OPTIONAL
    );


//
// Flags controlling the drawing of mini-icons
//
#define DMI_MASK      0x00000001
#define DMI_BKCOLOR   0x00000002
#define DMI_USERECT   0x00000004

WINSETUPAPI
INT
WINAPI
SetupDiDrawMiniIcon(
    IN HDC   hdc,
    IN RECT  rc,
    IN INT   MiniIconIndex,
    IN DWORD Flags
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassBitmapIndex(
    IN  LPGUID ClassGuid,    OPTIONAL
    OUT PINT   MiniIconIndex
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageList(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageListExA(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCSTR                   MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageListExW(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCWSTR                  MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    );

#ifdef UNICODE
#define SetupDiGetClassImageListEx SetupDiGetClassImageListExW
#else
#define SetupDiGetClassImageListEx SetupDiGetClassImageListExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageIndex(
    IN  PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  LPGUID                  ClassGuid,
    OUT PINT                    ImageIndex
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyClassImageList(
    IN PSP_CLASSIMAGELIST_DATA ClassImageListData
    );


//
// PropertySheetType values for the SetupDiGetClassDevPropertySheets API
//
#define DIGCDP_FLAG_BASIC           0x00000001
#define DIGCDP_FLAG_ADVANCED        0x00000002

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDevPropertySheetsA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADERA PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassDevPropertySheetsW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADERW PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    );

#ifdef UNICODE
#define SetupDiGetClassDevPropertySheets SetupDiGetClassDevPropertySheetsW
#else
#define SetupDiGetClassDevPropertySheets SetupDiGetClassDevPropertySheetsA
#endif


//
// Define ICON IDs publicly exposed from setupapi.
//
#define IDI_RESOURCEFIRST           159
#define IDI_RESOURCE                159
#define IDI_NOCFGDATA               160
#define IDI_RESOURCELAST            161
#define IDI_RESOURCEOVERLAYFIRST    161
#define IDI_RESOURCEOVERLAYLAST     161
#define IDI_CONFLICT                161

#define IDI_CLASSICON_OVERLAYFIRST  500
#define IDI_CLASSICON_OVERLAYLAST   502
#define IDI_PROBLEM_OVL             500
#define IDI_DISABLED_OVL            501
#define IDI_FORCED_OVL              502


WINSETUPAPI
BOOL
WINAPI
SetupDiAskForOEMDisk(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiSelectOEMDrv(
    IN     HWND             hwndParent,    OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidA(
    IN  LPGUID ClassGuid,
    OUT PSTR   ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidW(
    IN  LPGUID ClassGuid,
    OUT PWSTR  ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    );

#ifdef UNICODE
#define SetupDiClassNameFromGuid SetupDiClassNameFromGuidW
#else
#define SetupDiClassNameFromGuid SetupDiClassNameFromGuidA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidExA(
    IN  LPGUID ClassGuid,
    OUT PSTR   ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize,  OPTIONAL
    IN  PCSTR  MachineName,   OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassNameFromGuidExW(
    IN  LPGUID ClassGuid,
    OUT PWSTR  ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize,  OPTIONAL
    IN  PCWSTR MachineName,   OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiClassNameFromGuidEx SetupDiClassNameFromGuidExW
#else
#define SetupDiClassNameFromGuidEx SetupDiClassNameFromGuidExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    );

#ifdef UNICODE
#define SetupDiClassGuidsFromName SetupDiClassGuidsFromNameW
#else
#define SetupDiClassGuidsFromName SetupDiClassGuidsFromNameA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameExA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameExW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCWSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiClassGuidsFromNameEx SetupDiClassGuidsFromNameExW
#else
#define SetupDiClassGuidsFromNameEx SetupDiClassGuidsFromNameExA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameW(
    IN  DWORD  HwProfile,
    OUT PWSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetHwProfileFriendlyName SetupDiGetHwProfileFriendlyNameW
#else
#define SetupDiGetHwProfileFriendlyName SetupDiGetHwProfileFriendlyNameA
#endif


WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameExA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCSTR  MachineName,      OPTIONAL
    IN  PVOID  Reserved
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameExW(
    IN  DWORD  HwProfile,
    OUT PWSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCWSTR MachineName,      OPTIONAL
    IN  PVOID  Reserved
    );

#ifdef UNICODE
#define SetupDiGetHwProfileFriendlyNameEx SetupDiGetHwProfileFriendlyNameExW
#else
#define SetupDiGetHwProfileFriendlyNameEx SetupDiGetHwProfileFriendlyNameExA
#endif


//
// PageType values for SetupDiGetWizardPage API
//
#define SPWPT_SELECTDEVICE      0x00000001

//
// Flags for SetupDiGetWizardPage API
//
#define SPWP_USE_DEVINFO_DATA   0x00000001

WINSETUPAPI
HPROPSHEETPAGE
WINAPI
SetupDiGetWizardPage(
    IN HDEVINFO               DeviceInfoSet,
    IN PSP_DEVINFO_DATA       DeviceInfoData,    OPTIONAL
    IN PSP_INSTALLWIZARD_DATA InstallWizardData,
    IN DWORD                  PageType,
    IN DWORD                  Flags
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDevice(
    IN  HDEVINFO         DeviceInfoSet,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );


WINSETUPAPI
BOOL
WINAPI
SetupDiGetActualSectionToInstallA(
    IN  HINF    InfHandle,
    IN  PCSTR   InfSectionName,
    OUT PSTR    InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PSTR   *Extension              OPTIONAL
    );

WINSETUPAPI
BOOL
WINAPI
SetupDiGetActualSectionToInstallW(
    IN  HINF    InfHandle,
    IN  PCWSTR  InfSectionName,
    OUT PWSTR   InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PWSTR  *Extension              OPTIONAL
    );

#ifdef UNICODE
#define SetupDiGetActualSectionToInstall SetupDiGetActualSectionToInstallW
#else
#define SetupDiGetActualSectionToInstall SetupDiGetActualSectionToInstallA
#endif


#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _INC_SETUPAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\pch.h ===
#define _MBCS
#include <windows.h>
#include "nt5\setupapi.h"
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <mbstring.h>
#include <tchar.h>

#include "poolmem.h"
#include "miginf.h"
#include "scrnsave.h"
#include "msg.h"

#pragma warning(4:4100)     // Lower serverity of "unreferenced formal parameter"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\miginf.h ===
#ifndef MIGINF_H
#define MIGINF_H


#define SECTION_MIGRATIONPATHS  "Migration Paths"
#define SECTION_EXCLUDEDPATHS   "Excluded Paths"
#define SECTION_HANDLED         "Handled"
#define SECTION_MOVED           "Moved"
#define SECTION_INCOMPATIBLE    "Incompatible Messages"


typedef enum {

    MIG_FIRSTTYPE,
    MIG_FILE,
    MIG_PATH,
    MIG_REGKEY,
    MIG_MESSAGE,
    MIG_LASTTYPE

} MIGTYPE, *PMIGTYPE;

typedef struct tagMIGINFSECTIONENUM {

    PCSTR        Key;
    PCSTR        Value;
    PVOID        EnumKey;            // Internal.

} MIGINFSECTIONENUM, * PMIGINFSECTIONENUM;



BOOL WINAPI MigInf_Initialize (VOID);
VOID WINAPI MigInf_CleanUp (VOID);
BOOL WINAPI MigInf_PathIsExcluded (IN PCSTR Path);
BOOL WINAPI MigInf_FirstInSection(IN PCSTR SectionName, OUT PMIGINFSECTIONENUM Enum);
BOOL WINAPI MigInf_NextInSection(IN OUT PMIGINFSECTIONENUM Enum);
BOOL WINAPI MigInf_AddObject (IN MIGTYPE ObjectType,IN PCSTR SectionString,IN PCSTR ParamOne,IN PCSTR ParamTwo);
BOOL WINAPI MigInf_WriteInfToDisk (VOID);
PCSTR WINAPI MigInf_GetNewSectionName (VOID);



//
// Macros for common miginf actions.
//

//
// Adding Objects.
//
#define MigInf_AddHandledFile(file)                      MigInf_AddObject(MIG_FILE,SECTION_HANDLED,(file),NULL)
#define MigInf_AddHandledDirectory(directory)            MigInf_AddObject(MIG_PATH,SECTION_HANDLED,(directory),NULL)
#define MigInf_AddHandledRegistry(key,value)             MigInf_AddObject(MIG_REGKEY,SECTION_HANDLED,(key),(value))

#define MigInf_AddMovedFile(from,to)                     MigInf_AddObject(MIG_FILE,SECTION_MOVED,(from),(to))
#define MigInf_AddMovedDirectory(from,to)                MigInf_AddObject(MIG_PATH,SECTION_MOVED,(from),(to))

#define MigInf_AddMessage(msgSection,msg)                MigInf_AddObject(MIG_MESSAGE,SECTION_INCOMPATIBLE,(msgSection),(msg))

#define MigInf_AddMessageFile(msgSection,file)           MigInf_AddObject(MIG_FILE,(msgSection),(file),NULL)
#define MigInf_AddMessageDirectory(msgSection,directory) MigInf_AddObject(MIG_PATH,(msgSection,(directory),NULL)
#define MigInf_AddMessageRegistry(msgSection,key,value)  MigInf_AddObject(MIG_REGKEY,(msgSection),(key),(value))

//
// Enumerating Sections
//
#define MigInf_GetFirstMigrationPath(Enum)               MigInf_FirstInSection(SECTION_MIGRATIONPATHS,(Enum))
#define MigInf_GetFirstExcludedPath(Enum)                MigInf_FirstInSection(SECTION_EXCLUDEDPATHS,(Enum))



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\dataconv.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dataconv.c

Abstract:

    This source file implements data conversion routines that know
    the format of Windows 95 screen saver settings and can convert
    them to the Windows NT format.

Author:

    Jim Schmidt (jimschm) 14-Apr-1997

Revision History:


--*/

#include "pch.h"

static CHAR g_Data[MAX_PATH];

BOOL
pHasSpecialProcessing (
    IN      LPCSTR ScreenSaverName
    );

BOOL
pTranslateBezier (
    IN      HKEY RegRoot
    );

BOOL
pTranslateMarquee (
    IN      HKEY RegRoot
    );



HKEY
pCreateControlPanelKey (
    IN      HKEY RootKey,
    IN      LPCSTR SubKeyName,
    IN      BOOL CreateEmptyKey
    )
{
    CHAR FullRegKey[MAX_PATH];

    wsprintf (FullRegKey, S_CONTROL_PANEL_MASK, SubKeyName);

    if (CreateEmptyKey) {
        RegDeleteKey (RootKey, FullRegKey);
    }

    return CreateRegKey (RootKey, FullRegKey);
}


HKEY
pCreateScreenSaverKey (
    IN      HKEY RegRoot, 
    IN      LPCSTR ScreenSaverName
    )
{
    CHAR FullScreenSaverName[MAX_PATH];

    wsprintf (FullScreenSaverName, S_SCRNSAVE_MASK, ScreenSaverName);
    return pCreateControlPanelKey (RegRoot, FullScreenSaverName, FALSE);
}


BOOL
pCopyValuesFromSettingsFileToRegistry (
    IN      HKEY RegKeyRoot,
    IN      LPCSTR RegKeyName,
    IN      LPCSTR ScreenSaverName,
    IN      LPCSTR ValueArray[]
    )
{
    INT i;
    CHAR IniKeyName[MAX_PATH];
    HKEY RegKey;
    BOOL b = TRUE;

    //
    // This function takes the values stored in our settings file and
    // copies them to a brand new key in the NT registry.
    //
    // In the settings file, we store screen saver parameters in the
    // format of <screen saver name len>/<screen saver name>/<parameter>=<value>.
    //

    //
    // Create new registry key
    //

    RegKey = pCreateControlPanelKey (RegKeyRoot, RegKeyName, TRUE);
    if (!RegKey) {
        return FALSE;
    }

    //
    // Copy values to reg key
    //

    for (i = 0 ; ValueArray[i] ; i++) {
        if (!CreateScreenSaverParamKey (ScreenSaverName, ValueArray[i], IniKeyName)) {
            // fail if screen saver name is huge for some unknown reason
            LOG ((LOG_WARNING, MSG_HUGEDATA_ERROR));
            b = FALSE;
            break;
        }

        GetSettingsFileVal (IniKeyName);
        if (!SetRegValueString (RegKey, ValueArray[i], g_Data)) {
            b = FALSE;
            break;
        }
    }

    CloseRegKey (RegKey);
    return b;
}


BOOL
TranslateGeneralSetting (
    IN      HKEY RegKey,
    IN      LPCSTR Win9xSetting,
    IN      LPCSTR WinNTSetting
    )
{
    BOOL b = TRUE;

    if (!WinNTSetting) {
        WinNTSetting = Win9xSetting;
    } else {
        //
        // Delete the Win9x setting that was copied to NT, ignore
        // any failures.
        //
        RegDeleteValue (RegKey, Win9xSetting);
    }

    //
    // Obtain setting from data file
    //

    if (GetSettingsFileVal (Win9xSetting)) {
        //
        // Save settings to registry
        //

        b = SetRegValueString (RegKey, WinNTSetting, g_Data);
    }

    return b;
}


typedef struct {
    LPCSTR Win9xName;
    LPCSTR WinNtName;
} FILE_TRANS, *PFILE_TRANS;

FILE_TRANS g_FileNameTranslation[] = {
    // Win9x name                   // WinNT name (NULL=no change)
    "black16.scr",                  NULL,
    "Blank Screen.scr",             "black16.scr",

    "ssbezier.scr",                 NULL,
    "Curves and Colors.scr",        "ssbezier.scr",

    "ssstars.scr",                  NULL,
    "Flying Through Space.scr",     "ssstars.scr",

    "ssmarque.scr",                 NULL,
    "Scrolling Marquee.scr",        "ssmarque.scr",

    "ssmyst.scr",                   NULL,
    "Mystify Your Mind.scr",        "ssmyst.scr",

    NULL, NULL
};


LPCSTR
GetSettingsFileVal (
    IN      LPCSTR Key
    )
{
    GetPrivateProfileString (
        g_User, 
        Key, 
        S_EMPTY, 
        g_Data, 
        MAX_PATH, 
        g_SettingsFile
        );

    return g_Data[0] ? g_Data : NULL;
}


BOOL
pTranslateScrName (
    IN OUT  LPSTR KeyName,
    OUT     LPSTR FullPath      OPTIONAL
    )
{
    int i;

    //
    // Compare against translation list
    //

    for (i = 0 ; g_FileNameTranslation[i].Win9xName ; i++) {
        if (!_mbsicmp (KeyName, g_FileNameTranslation[i].Win9xName)) {
            break;
        }
    }

    //
    // Translate filename only if a match was found in our list
    //

    if (g_FileNameTranslation[i].Win9xName) {

        //
        // If WinNtName is NULL, there is no renaming necessary.  Otherwise,
        // use the NT name, which is always a file in system32.
        //

        if (g_FileNameTranslation[i].WinNtName && FullPath) {
            // Rebuild path
            GetSystemDirectory (FullPath, MAX_PATH);
            _mbscat (FullPath, "\\");
            _mbscat (FullPath, g_FileNameTranslation[i].WinNtName);
        }

        _mbscpy (KeyName, g_FileNameTranslation[i].WinNtName);
    }
    else if (FullPath) {
        FullPath[0] = 0;
    }

    return TRUE;
}


BOOL
SaveScrName (
    IN      HKEY RegKey, 
    IN      LPCSTR KeyName
    )
{
    LPSTR p;
    CHAR FullPath[MAX_PATH];
    CHAR ShortName[MAX_PATH];

    //
    // The Windows 95 screen saver names are different than
    // Windows NT.
    //

    if (!GetSettingsFileVal (KeyName)) {
        // Unexpected: .SCR name does not exist in our file
        return TRUE;
    }

    //
    // Locate the screen saver name within the full path
    //

    p = _mbsrchr (g_Data, '\\');
    if (!p) {
        p = g_Data;
    } else {
        p = _mbsinc (p);
    }

    //
    // Translate it if necessary
    //

    if (!pTranslateScrName (p, FullPath)) {
        return FALSE;
    }

    if (!FullPath[0]) {
        //
        // No change was made, so copy original path to FullPath
        //
        
        _mbscpy (FullPath, g_Data);
    }

    //
    // Screen savers are always stored in short filename format
    //

    GetShortPathName (FullPath, ShortName, MAX_PATH);

    return SetRegValueString (RegKey, KeyName, ShortName);
}

INT
GetHexDigit (
    IN      CHAR c
    )
{
    if (c >= '0' && c <= '9') {
        return c - '0';
    }

    c = tolower (c);
    if (c >= 'a' && c <= 'f') {
        return c - 'a' + 10;
    }

    return -1;
}

BYTE
GetNextHexByte (
    IN      LPCSTR HexString,
    OUT     LPCSTR *HexStringReturn
    )
{
    INT a, b;

    a = GetHexDigit (HexString[0]);
    b = GetHexDigit (HexString[1]);

    if (a == -1 || b == -1) {
        *HexStringReturn = NULL;
        return 0;
    }

    *HexStringReturn = &(HexString[2]);

    return a * 16 + b;
}

BOOL
GetNextDword (
    IN      LPCSTR HexString,
    OUT     LPCSTR *HexStringReturn,
    OUT     PDWORD ValuePtr
    )
{
    INT i;
    BYTE NextByte;

    *ValuePtr = 0;

    for (i = 0 ; i < 4 ; i++) {
        NextByte = GetNextHexByte (HexString, &HexString);
        if (!HexString) {
            return FALSE;
        }

        *ValuePtr = ((*ValuePtr) << 8) | NextByte;
    }

    return TRUE;
}

BOOL
VerifyBezierChecksum (
    IN      LPCSTR HexString
    )
{
    BYTE Checksum = 0;
    INT Len;

    Len = _mbslen (HexString);
    Len -= 2;

    if (Len < 1) {
        return FALSE;
    }

    while (Len > 0) {
        Checksum += GetNextHexByte (HexString, &HexString);
        if (!HexString) {
            return FALSE;
        }
    }

    if (Checksum != GetNextHexByte (HexString, &HexString)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
CopyUntranslatedSettings (
    IN      HKEY RegRoot
    )
{
    LPSTR KeyBuffer;
    DWORD KeyBufferSize;
    LPSTR p;
    CHAR ScreenSaverName[MAX_PATH];
    CHAR ValueName[MAX_PATH];
    HKEY Key;

    //
    // Enumerate each entry in our private settings file for the user
    //

    KeyBufferSize = 32768;
    KeyBuffer = (LPSTR) HeapAlloc (g_hHeap, 0, KeyBufferSize);
    if (!KeyBuffer) {
        return FALSE;
    }

    //
    // Get all keys in the user's section
    //

    GetPrivateProfileString (
        g_User,
        NULL,
        S_DOUBLE_EMPTY,
        KeyBuffer,
        KeyBufferSize,
        g_SettingsFile
        );

    for (p = KeyBuffer ; *p ; p = _mbschr (p, 0) + 1) {
        //
        // Process only if key is encoded
        //

        if (!DecodeScreenSaverParamKey (p, ScreenSaverName, ValueName)) {
            continue;
        }

        //
        // Key is encoded, so perform migration!
        //

        pTranslateScrName (ScreenSaverName, NULL);

        //
        // Skip screen savers that have special processing
        //

        if (pHasSpecialProcessing (ScreenSaverName)) {
            continue;
        }

        //
        // Save the value to the registry
        //

        GetSettingsFileVal (p);

        Key = pCreateScreenSaverKey (RegRoot, ScreenSaverName);
        if (Key) {
            if (SetRegValueString (Key, ValueName, g_Data))
            {
                CHAR DebugMsg[MAX_PATH*2];
                wsprintf (DebugMsg, "Saved %s=%s\r\n", ValueName, g_Data);
                SetupLogError (DebugMsg, LogSevInformation);
            } else {
                CHAR DebugMsg[MAX_PATH*2];
                wsprintf (DebugMsg, "Could not save %s=%s\r\n", ValueName, g_Data);
                SetupLogError (DebugMsg, LogSevError);
            }

            CloseRegKey (Key);
        }
    }

    HeapFree (g_hHeap, 0, KeyBuffer);

    return TRUE;
}


BOOL
pHasSpecialProcessing (
    IN      LPCSTR ScreenSaverName
    )
{
    //
    // Return TRUE if we are doing something special for the
    // named screen saver.
    //

    if (!_mbsicmp (ScreenSaverName, S_BEZIER) ||
        !_mbsicmp (ScreenSaverName, S_MARQUEE)
        ) {
        return TRUE;
    }

    return FALSE;
}


BOOL
TranslateScreenSavers (
    IN      HKEY RegRoot
    )
{
    BOOL b = TRUE;

    b &= pTranslateBezier (RegRoot);
    b &= pTranslateMarquee (RegRoot);

    return b;
}


BOOL
pTranslateBezier (
    IN      HKEY RegRoot
    )
{
    DWORD Value;
    CHAR StrValue[32];
    LPCSTR p;
    HKEY RegKey;
    BOOL b;

    //
    // NT's Bezier has three settings:
    //
    // Length (REG_SZ)      = Curve Count on Win9x
    // LineSpeed (REG_SZ)   = Speed on Win9x
    // Width (REG_SZ)       = Density on Win9x
    //
    // Win9x's Bezier has a big string of hex in the following format:
    // 
    // Clear Screen Flag (DWORD)
    // Random Colors Flag (DWORD)
    // Curve Count (DWORD)
    // Line Count (DWORD)
    // Density (DWORD)
    // Speed (DWORD)
    // Current Color (DWORD RGB)
    // Checksum (BYTE)
    //

    //
    // Verify structure
    //

    GetSettingsFileVal (S_BEZIER_SETTINGS);

    if (!VerifyBezierChecksum (g_Data)) {
        return TRUE;
    }

    //
    // Open reg key
    //

    RegKey = pCreateControlPanelKey (RegRoot, S_BEZIER_SETTINGS, TRUE);
    if (!RegKey) {
        return FALSE;
    }

    p = g_Data;

    // Get clear screen flag (but ignore it)
    b = GetNextDword (p, &p, &Value);

    // Get random colors flag (but ignore it)
    if (b) {
        b = GetNextDword (p, &p, &Value);
    }

    //
    // Get curve count
    //

    if (b) {
        b = GetNextDword (p, &p, &Value);
    }

    if (b) {
        wsprintf (StrValue, "%u", Value);
        b = SetRegValueString (RegKey, S_LENGTH, StrValue);
    }

    // Get line count (but ignore it)
    if (b) {
        b = GetNextDword (p, &p, &Value);
    }

    //
    // Get density
    //

    if (b) {
        b = GetNextDword (p, &p, &Value);
    }

    if (b) {
        wsprintf (StrValue, "%u", Value);
        b = SetRegValueString (RegKey, S_WIDTH, StrValue);
    }

    //
    // Get speed
    //

    if (b) {
        b = GetNextDword (p, &p, &Value);
    }

    if (b) {
        wsprintf (StrValue, "%u", Value);
        b = SetRegValueString (RegKey, S_LINESPEED, StrValue);
    }

    CloseRegKey (RegKey);

    if (!b) {
        LOG ((LOG_ERROR, MSG_BEZIER_DATA_ERROR));
    }

    return TRUE;
}


LPCSTR g_MarqueeValues[] = {
    S_BACKGROUND_COLOR,
    S_CHARSET,
    S_FONT,
    S_MODE,
    S_SIZE,
    S_SPEED,
    S_TEXT,
    S_TEXTCOLOR,
    NULL
};


BOOL
pTranslateMarquee (
    IN      HKEY RegRoot
    )
{
    BOOL b;

    //
    // Marquee has the same settings on Win9x and NT.  They just need
    // to be copied from the control.ini file to the NT registry.
    //

    b = pCopyValuesFromSettingsFileToRegistry (
                RegRoot,
                S_MARQUEE_SETTINGS, 
                S_MARQUEE,
                g_MarqueeValues
                );

    //
    // We need to divide the speed by two to be compatible
    //

    if (b) {
        HKEY MarqueeKey;
        LPCSTR Value;
        CHAR NewValue[32];

        // Read the setting we just wrote in the registry
        MarqueeKey = pCreateControlPanelKey (RegRoot, S_MARQUEE_SETTINGS, FALSE);

        if (MarqueeKey) {
            Value = GetRegValueString (MarqueeKey, S_SPEED);
            if (Value) {
                // Write speed divided by two
                wsprintf (NewValue, "%i", atoi (Value) / 2);
                SetRegValueString (MarqueeKey, S_SPEED, NewValue);
            }

            CloseRegKey (MarqueeKey);
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\miginf.c ===
#include "pch.h"

#define MIGRATEINF              ".\\migrate.inf"
#define INITIALBUFFERSIZE       1024
#define MIGINF_NOCREATE         FALSE
#define MIGINF_CREATE           TRUE


typedef struct tagMIGOBJECT MIGOBJECT, *PMIGOBJECT;
struct tagMIGOBJECT {

    PSTR        Key;
    PSTR        Value;
    
    PMIGOBJECT  Next;
};

typedef struct tagMIGSECTION MIGSECTION, * PMIGSECTION;
struct tagMIGSECTION {

    PSTR        Name;
    PMIGOBJECT  Items;

    PMIGSECTION Next;
};

PMIGSECTION g_MigrationInf;
POOLHANDLE  g_Pool = NULL;


static
PCSTR
pGetTypeAsString (
    IN MIGTYPE Type
    )
{
    //
    // Note: Strings must be in the same order as the 
    // corresponding types in the MIGTYPE enumeration above.
    //
    static PCHAR typeStrings[] = {
            "FIRST - Invalid",
            "File",
            "Path",
            "Registry",
            "Message - Invalid",
            "LAST - Invalid"
        };

    assert(Type > MIG_FIRSTTYPE && Type < MIG_LASTTYPE);

    return typeStrings[Type];
}

static
PMIGSECTION 
pFindSection (
    IN PCSTR SectionString,
    IN BOOL  CreateIfNotExist
    )
{
    PMIGSECTION rSection;

    //
    // We assume that SectionString is not null.
    //
    assert(SectionString);

    rSection = g_MigrationInf;

    while (rSection && (_mbsicmp(rSection -> Name,SectionString) != 0)) {

        //
        // Continue looking.
        //
        rSection = rSection -> Next;
    }
        
    if (!rSection && CreateIfNotExist) {
        //
        // No section was found matching this name. Make a new section and add it 
        // to the list.
        //
        rSection = PoolMemGetMemory(g_Pool,sizeof(MIGSECTION));
        if (rSection) {

            ZeroMemory(rSection,sizeof(MIGSECTION));
            rSection -> Name  = PoolMemDuplicateStringA(g_Pool,SectionString);
            rSection -> Next  = g_MigrationInf;
            g_MigrationInf    = rSection;

            if (!rSection -> Name) {
                //
                // Something went wrong when we tried to duplicate the SectionString.
                // NULL out the rSection so that the caller doesn't get back a 
                // malformed section object.
                //
                rSection = NULL;
            }
        }
    }

    return rSection;
}

static
BOOL
pPathIsInPath(
    IN PCSTR    SubPath,
    IN PCSTR    ParentPath
    )
{
    DWORD parentLength;
    BOOL  rInPath;

    //
    // This function assumes both parameters are non-NULL.
    //
    assert(SubPath);
    assert(ParentPath);
    
    parentLength = _mbslen(ParentPath);

    //
    // A path is considered "in" another path if the path is in the ParentPath
    // or a subdirectory of it.
    //
    rInPath = !_mbsnicmp(SubPath,ParentPath,parentLength);

    if (rInPath) {
        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\';
    }

    return rInPath;

}

static
DWORD
pGetMbsSize (
    IN  LPCSTR  String
    )
{
    DWORD rLength;
    
    rLength = (DWORD) _mbschr(String,0) - (DWORD) String + 1;

    return rLength;

}


static
LPSTR 
pEscapeString (
    IN  MIGTYPE Type,
    OUT LPSTR   EscapedString, 
    IN  LPCSTR  String
    )

{
    LPSTR   stringStart;
    static  CHAR exclusions[] = "[]~,;%\"";
    INT     currentChar;

    //
    // We assume that all parameters are valid.
    //
    assert(EscapedString && String);

    stringStart = EscapedString;

    while (*String)  {
        currentChar = _mbsnextc (String);
        
        if (Type == MIG_REGKEY) {
            
            //
            // Registry keys require more complex escaping than do normal INF strings.
            //
            if (!_ismbcprint (currentChar) || _mbschr (exclusions, currentChar)) {
                
                //
                // Escape unprintable or excluded character
                //
                wsprintfA (EscapedString, "~%X~", currentChar);
                EscapedString = _mbschr (EscapedString, 0);
                String = _mbsinc (String);
            }
            else {
                //
                // Copy multibyte character
                //
                if (isleadbyte (*String)) {
                    *EscapedString = *String;
                    EscapedString++;
                    String++;
                }
                
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
        }
        else {

            //
            // Escaping is pretty simple for non-registry keys. All we do is double up
            // quotes and percents.
            //
            if (*String == '\"' || *String == '%') {

                *EscapedString = *String;
                EscapedString++;
            }
            
            //
            // Copy multibyte character
            //
            if (isleadbyte (*String)) {
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
            
            *EscapedString = *String;
            EscapedString++;
            String++;
        }
    }

    //
    // Ensure that returned string is NULL terminated.
    //
    *EscapedString = 0;

    return stringStart;
}


static
PSTR
pGetValueString (
    IN MIGTYPE    ObjectType,
    IN LPCSTR     StringOne,
    IN LPCSTR     StringTwo
    )
{
    static PSTR     buffer;
    static DWORD    bufferSize;
    DWORD           maxLength;
    PSTR            bufferEnd;
    
    //
    // This function assumes that StringOne exists.
    //
    assert(StringOne);

    if (ObjectType == MIG_REGKEY) {
        //
        // Size: size of both strings, plus the size of the quotes, plus the size of the brackets 
        // for the value, * 6. This is the maximum size one of these could grow to, if every 
        // character had to be escaped out.
        //
        maxLength = (pGetMbsSize(StringOne) + (StringTwo ? pGetMbsSize(StringTwo) + 2 : 0)) * 6 + 2;
    }
    else {
        //
        // Size: size of the string * 2 (The max size if every char was a '%' or '"' plus the quotes.
        //
        maxLength = pGetMbsSize(StringOne) * 2 + 2;
    }

    if (maxLength > bufferSize) {

        //
        // Initialize our buffer, or create a larger one.
        //
        bufferSize = (maxLength > INITIALBUFFERSIZE) ? maxLength : INITIALBUFFERSIZE;
        buffer = PoolMemCreateStringA(g_Pool,bufferSize);
    }

    if (buffer != NULL) {
        
        //
        // Insert initial quote.
        //
        *buffer = '"';
 
        //
        // Massage the string to ensure it is a valid INF file string.
        //
        pEscapeString(ObjectType,_mbsinc(buffer),StringOne);

        //
        // If this is a REGISTRY entry, then we also need to add the value part of the string, 
        // if one was specified (In StringTwo)
        //

        if (ObjectType == MIG_REGKEY && StringTwo) {

            //
            // Add the opening bracket.
            //
            bufferEnd = _mbschr(buffer,0);
            *bufferEnd = '[';
            
            //
            // Add the value string in, again making sure the string is valid for an INF file.
            //
            pEscapeString(ObjectType,_mbsinc(bufferEnd),StringTwo);

            //
            // Now, add the closing braket.
            //
            bufferEnd = _mbschr(buffer,0);
            *bufferEnd = ']';

            //
            // Terminate the string.
            //
            bufferEnd = _mbsinc(bufferEnd);
            *bufferEnd = 0;
        }

        //
        // Add the final quote.
        //
        bufferEnd = _mbschr(buffer,0);
        *bufferEnd = '"';
        bufferEnd = _mbsinc(bufferEnd);
        *bufferEnd = 0;
    }
    
    return buffer;
}

static
BOOL
pCreateMigObject (
    IN MIGTYPE          ObjectType,
    IN PCSTR            ParamOne,
    IN PCSTR            ParamTwo,
    IN PMIGSECTION      Section
    )
{
    BOOL            rSuccess;
    PMIGOBJECT      newObject = NULL;

    //
    // pCreateMigObject uses a set of hueristics to correctly assemble an object. 
    // These hueristics are based on the ObjectType and the contents of ParamTwo.
    // 
    // ObjectType       ParamTwo      Key                   Value
    // -------------------------------------------------------------------------
    // MIG_REGKEY       <any>         ParamOne[ParamTwo]    Registry
    // <other>          NULL          ParamOne              <ObjectType As String>
    // <other>          non-NULL      ParamOne              ParamTwo
    //
    //


    if (Section) {

        //
        // First, create an object...
        //
        newObject = PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));

        if (newObject) {

            if (ObjectType == MIG_REGKEY) {

                newObject -> Key = 
                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,ParamTwo));

                newObject -> Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
            }
            else {
                
                newObject -> Key = 
                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,NULL));

                if (ParamTwo) {
                    newObject -> Value =
                        PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamTwo,NULL));
                }
                else {

                    newObject -> Value = 
                        PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
                }
            }
        }
    }


    if (newObject && newObject -> Key && newObject -> Value) {

        //
        // The object has been successfully created. Link it into the section.
        //
        newObject -> Next = Section -> Items;
        Section -> Items = newObject;
        rSuccess = TRUE;
    }
    else {
        rSuccess = FALSE;
    }

    return newObject && newObject -> Key && newObject -> Value;
}


static
BOOL
pWriteInfSectionToDisk (
    IN PMIGSECTION Section
    )
{
    PMIGOBJECT curObject;
    BOOL       rSuccess = TRUE;

    if (Section) {

        curObject = Section -> Items;

        while (curObject && rSuccess) {

            if (Section -> Name && curObject -> Key && curObject -> Value) {
            
                rSuccess = WritePrivateProfileString(
                    Section   -> Name,
                    curObject -> Key, 
                    curObject -> Value,
                    MIGRATEINF
                    );
            }

            curObject = curObject -> Next;
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


static
BOOL
pBuildListFromSection (
    IN PCSTR    SectionString
    )
{
    HINF            infHandle;
    PMIGSECTION     section;
    PMIGOBJECT      currentObject;
    INFCONTEXT      ic;
    DWORD           size;
    BOOL            rSuccess = TRUE;

    //
    // This function assumes that Section is non-NULL.
    //
    assert(SectionString);

    currentObject = NULL;
    
    //
    // First find the section specified.
    //
    section = pFindSection(SectionString,MIGINF_CREATE);

    if (section) {
        
        infHandle = SetupOpenInfFileA(MIGRATEINF,NULL,INF_STYLE_WIN4,NULL);
        
        if (infHandle != INVALID_HANDLE_VALUE) {
            
            if (SetupFindFirstLine(infHandle,SectionString,NULL,&ic)) {
                
                do {

                    //
                    // Create the object.
                    //
                    currentObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));
                    
                    if (!currentObject) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the size of the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,NULL,0,&size)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Create a string large enough.
                    //
                    currentObject -> Key = PoolMemCreateStringA(g_Pool,size);
                    
                    if (!currentObject -> Key) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,currentObject -> Key,size,NULL)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Successfully retrieved the line.
                    //
                    currentObject -> Value  = (PSTR) pGetTypeAsString(MIG_FILE);
                    currentObject -> Next   = section -> Items;
                    section -> Items        = currentObject;
                    
                } while(SetupFindNextLine(&ic,&ic));
                
            }
            
            SetupCloseInfFile(infHandle);
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_Initialize(
    VOID
    )
{

    //
    // First, initialize our pool and Zero out the structure.
    //
    g_Pool = PoolMemInitPool();


    if (g_Pool) {
        
        //
        // Now, read in the migration paths and excluded paths sections.
        //
        if (!pBuildListFromSection(SECTION_MIGRATIONPATHS) ||
            !pBuildListFromSection(SECTION_EXCLUDEDPATHS)) {
            //
            // Something went wrong (i.e. out of memory. Destroy and NULL our pool.
            //
            PoolMemDestroyPool(g_Pool);
            g_Pool = NULL;
        }
    }

    //
    // If our memory pool initialized successfully, return TRUE.
    //
    return (g_Pool != NULL);

}


VOID
WINAPI
MigInf_CleanUp (
    VOID
    )
{
    //
    // Only thing we need to do is clean out pool mem. We'll NULL out the list header to make
    // sure it isn't usable.
    //
    if (g_Pool) {
        PoolMemDestroyPool(g_Pool);
        g_Pool = NULL;
    }
    
    g_MigrationInf = NULL;

}


BOOL
WINAPI
MigInf_AddObject (
    IN MIGTYPE  ObjectType,
    IN PCSTR    SectionString,
    IN PCSTR    ParamOne,
    IN PCSTR    ParamTwo
    )
{

    return pCreateMigObject(
        ObjectType,
        ParamOne,
        ParamTwo,
        pFindSection(SectionString,MIGINF_CREATE)
        );
}

BOOL 
WINAPI 
MigInf_FirstInSection(
    IN PCSTR SectionName, 
    OUT PMIGINFSECTIONENUM Enum
    )
{
    PMIGSECTION section;

    //
    // We assume that Enum is valid.
    //
    assert(Enum);

    section = pFindSection(SectionName,MIGINF_NOCREATE);

    if (section) {
        Enum -> EnumKey = (PVOID) section -> Items;
    }

    return MigInf_NextInSection(Enum);
}

BOOL 
WINAPI 
MigInf_NextInSection(
    IN OUT PMIGINFSECTIONENUM Enum
    )
{


    BOOL            rSuccess = FALSE;

    //
    // We assume that the Enum is valid.
    //
    assert(Enum);

    if (Enum -> EnumKey) {

        Enum -> Key     = ((PMIGOBJECT) (Enum -> EnumKey)) -> Key;
        Enum -> Value   = ((PMIGOBJECT) (Enum -> EnumKey)) -> Value;
        Enum -> EnumKey = ((PVOID) ((PMIGOBJECT) (Enum -> EnumKey)) -> Next);
        rSuccess = TRUE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_WriteInfToDisk (
    VOID
    )
{

    BOOL        rSuccess = TRUE;
    PMIGSECTION curSection;
    
    //
    // Simply loop through all of the sections, writing each of them to disk.
    // As long as WriteSectionToDisk works, we work.
    //
    curSection = g_MigrationInf;

    while (curSection && rSuccess) {

        //
        // We skip the [Excluded Paths] and [Migration Paths] sections.
        //
        if (_mbsicmp(curSection -> Name,SECTION_EXCLUDEDPATHS) &&
            _mbsicmp(curSection -> Name,SECTION_MIGRATIONPATHS)) {
            
            rSuccess = pWriteInfSectionToDisk(curSection);
        } 

        curSection = curSection -> Next;
        
    }

    return rSuccess;
}

BOOL
WINAPI
MigInf_PathIsExcluded (
    IN PCSTR    Path
    )
{
    PMIGOBJECT  curExcluded;
    PMIGSECTION section;
    BOOL        rIsExcluded = FALSE;

    //
    // We assume Path is valid.
    //
    assert(Path);
    
    section = pFindSection(SECTION_EXCLUDEDPATHS,MIGINF_NOCREATE);

    if (section) {

        curExcluded = section -> Items;
        
        while (curExcluded && !rIsExcluded) {
            
            rIsExcluded = pPathIsInPath(Path,curExcluded -> Key);
            curExcluded = curExcluded -> Next;
        }
    }
    
    return rIsExcluded;
}



PCSTR
WINAPI
MigInf_GetNewSectionName (
    VOID
    )
{

    static CHAR     sectionName[20];
    static DWORD    seedNum=0;


    sprintf(sectionName,"msg%0.7u",seedNum++);

    return sectionName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\poolmem.c ===
#include "pch.h"
 
// Tree Memory Allocation structure.


typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    DWORD                 Index;
    DWORD                 Size;
    PPOOLMEMORYBLOCK      NextBlock;
    PPOOLMEMORYBLOCK      PrevBlock;
    PBYTE                 RawMemory;  
};

typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;
    HANDLE           Heap;
} POOLHEADER, *PPOOLHEADER;


BOOL
PoolMemAddMemory (
    IN  POOLHANDLE  Handle,
    IN  DWORD       Size
    )
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    DWORD               sizeNeeded;

    assert(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > POOLMEMORYBLOCKSIZE) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = POOLMEMORYBLOCKSIZE;
    }

    allocedMemory = HeapAlloc(poolHeader -> Heap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
    
        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;


    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;
}


POOLHANDLE
WINAPI
PoolMemInitPool (
    )
{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;
    HANDLE      procHeap;


    procHeap = GetProcessHeap();
    //
    // Allocate the header of this pool.
    //
    header = HeapAlloc(procHeap,0,sizeof(POOLHEADER));

    if (header) {

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> PoolHead = NULL;
        header -> Heap = procHeap;

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = PoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            HeapFree(header -> Heap,0,header);
            header = NULL;
        }

    }
    return (POOLHANDLE) header;
}


VOID
WINAPI
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree; 
    PPOOLHEADER      poolHeader;

    assert(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {
    
        nextBlock = blockToFree->NextBlock;
        HeapFree(poolHeader -> Heap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    HeapFree(poolHeader -> Heap,0,poolHeader);

}

PVOID
WINAPI
PoolMemGetAlignedMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size,
    IN DWORD      AlignSize
    )

{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    DWORD               sizeNeeded;
    DWORD               padLength;

    assert(poolHeader != NULL);

    currentBlock = poolHeader -> PoolHead;

    // Determine if more memory is needed, attempt to add if needed.
    sizeNeeded = Size;

    if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

        haveEnoughMemory = PoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);
        currentBlock = poolHeader -> PoolHead;
    }

    // If there is enough memory available, return it.
    if (haveEnoughMemory) {
        if (AlignSize) {

            padLength = (DWORD) currentBlock + sizeof(POOLMEMORYBLOCK) 
                + currentBlock -> Index;
            currentBlock -> Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

        }
      
         
        //Now, get the address of the memory to return.
        rMemory = (PVOID) 
            &(currentBlock->RawMemory[currentBlock -> Index]);
 
        currentBlock->Index += sizeNeeded;
    }

    return rMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\savecfg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    savecfg.c

Abstract:

    This source file implements code to save the Win9x environment to
    a settings file.  It writes a copy of all screen saver settings on
    a per-user basis.

Author:

    Jim Schmidt (jimschm) 11-Apr-1997

Revision History:


--*/

#include "pch.h"

BOOL
SaveDatFileKeyAndVal (
    IN      LPCSTR Key,
    IN      LPCSTR Val
    )
{
    //
    // This function is a wrapper to simplify writing to our settings file
    //

    return WritePrivateProfileString (g_User, Key, Val, g_SettingsFile);
}


BOOL
CopyRegValueToDatFile (
    IN      HKEY RegKey,
    IN      LPCSTR ValueName
    )
{
    LPCSTR DataPtr;
    DWORD rc;

    //
    // Obtain registry value data and copy it to our settings file
    //

    DataPtr = GetRegValueString (RegKey, ValueName);
    if (DataPtr) {
        return SaveDatFileKeyAndVal (ValueName, DataPtr);
    }

    // If not found or wrong data type, don't sweat it
    rc = GetLastError();
    return rc == ERROR_FILE_NOT_FOUND || rc == ERROR_SUCCESS;
}


#define WIN9X_MAX_SECTION  32768

BOOL
SaveControlIniSection (
    IN      LPCSTR ControlIniSection,
    IN      LPCSTR ScreenSaverName
    )
{
    LPSTR Buffer;
    LPSTR p;
    CHAR NewKey[MAX_PATH];
    BOOL b = TRUE;
    CHAR DataBuf[MAX_PATH];

    //
    // This function copies an entire section in control.ini to our
    // settings file.  It may not be necessary because control.ini will
    // still be around, but this guarantees if someone modifies
    // control.ini later, our migration will not break.
    //

    //
    // Allocate a generous buffer to hold all key names
    //

    Buffer = HeapAlloc (g_hHeap, 0, WIN9X_MAX_SECTION);
    if (!Buffer) {
        return FALSE;
    }

    //
    // Retrieve the key names
    //

    GetPrivateProfileString (
        ControlIniSection, 
        NULL, 
        S_EMPTY,
        Buffer,
        WIN9X_MAX_SECTION, 
        S_CONTROL_INI
        );

    //
    // For each key name, copy it to our settings file
    //

    p = Buffer;

    while (*p) {
        if (CreateScreenSaverParamKey (ScreenSaverName, p, NewKey)) {
            GetPrivateProfileString (
                    ControlIniSection, 
                    p, 
                    S_EMPTY, 
                    DataBuf, 
                    MAX_PATH, 
                    S_CONTROL_INI
                    );

            if (!SaveDatFileKeyAndVal (NewKey, DataBuf)) {
                b = FALSE;
                break;
            }
        }

        p = _mbschr (p, 0);
        p++;
    }

    //
    // Cleanup
    //

    HeapFree (g_hHeap, 0, Buffer);
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\makefile.inc ===
$(O)\migrate.res: migrate.rc

$(O)\msg.mc: $(PRIVATE_INC_PATH)\vendinfo.mc migrate.mc
        copy /b migrate.mc+$(PRIVATE_INC_PATH)\vendinfo.mc $(O)\msg.mc

$(O)\msg.h $(O)\msg00001.bin $(O)\msg.rc: $(O)\msg.mc
        mc -A -v -h .\$(O) -r .\$(O) $(O)\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\poolmem.h ===
#ifndef POOLMEM_H
#define POOLMEM_H

typedef LPVOID POOLHANDLE;


#define POOLMEMORYBLOCKSIZE 8192



POOLHANDLE WINAPI PoolMemInitPool ();
VOID       WINAPI PoolMemDestroyPool (IN POOLHANDLE Handle);
LPVOID     WINAPI PoolMemGetAlignedMemory(IN POOLHANDLE Handle, IN DWORD Size, IN DWORD AlignSize);


#define PoolMemCreateString(h,x)        ((LPTSTR) PoolMemGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PoolMemCreateDword(h)           ((PDWORD) PoolMemGetMemory((h),sizeof(DWORD)))


__inline
LPVOID 
PoolMemGetMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{

    return PoolMemGetAlignedMemory(Handle,Size,0);

}

__inline
LPTSTR 
PoolMemCreateStringA ( 
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(CHAR),sizeof(CHAR));
}

__inline
LPWSTR 
PoolMemCreateStringW (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPWSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(WCHAR),sizeof(WCHAR));
}


__inline
PTSTR 
PoolMemDuplicateStringA (
    IN POOLHANDLE    Handle,
    IN LPCSTR       StringToCopy
    )

{

    
    DWORD   stringLength;
    PSTR    rString;

    assert(StringToCopy);

    stringLength = (DWORD) _mbschr(StringToCopy,0) - (DWORD) StringToCopy + 1;
    rString      = PoolMemGetAlignedMemory(Handle,stringLength,sizeof(CHAR));

    if (rString) {

        _mbscpy(rString,StringToCopy);
    }

    return rString;
}


__inline
PWSTR 
PoolMemDuplicateStringW (
    IN POOLHANDLE    Handle,
    IN LPCWSTR       StringToCopy
    )

{

    
    DWORD    stringLength;
    PWSTR    rString;

    assert(StringToCopy);

    stringLength = ((wcslen(StringToCopy)+1)*sizeof(WCHAR));
    rString      = PoolMemGetAlignedMemory(Handle,stringLength,sizeof(WCHAR));

    if (rString) {

        wcscpy(rString,StringToCopy);
    }

    return rString;
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\migrate.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.h

Abstract:

    Includes the headers needed throughout the Setup migration DLL

Author:

    Calin Negreanu (calinn) 22-Dec-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "chartype.h"

//
// Windows
//

#include <windows.h>
#include <winnt.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <shlobj.h>
#include <objidl.h>

//
// Setup
//

#include <setupbat.h>

//
// Common includes
//

#include "common.h"
#include "migutil.h"
#include "fileenum.h"
#include "memdb.h"
#include "unattend.h"
#include "progbar.h"
#include "regops.h"
#include "fileops.h"
#include "win95reg.h"
#include "snapshot.h"
#include "linkpif.h"
#include "migdb.h"
#include "..\w95upg\migapp\migdbp.h"



//
// includes for code that runs only on Win9x
//

#include <ras.h>
#include <pif.h>        /* windows\inc */
#include <tlhelp32.h>

#include <winnt32p.h>

#include "init9x.h"
#include "w95upg.h"
#include "buildinf.h"
#include "msg.h"
#include "config.h"
#include "migdlls.h"
#include "hwcomp.h"
#include "sysmig.h"
#include "msgmgr.h"
#include "migapp.h"
#include "rasmig.h"
#include "dosmig.h"
#include "drives.h"
#include "timezone.h"
#include "migdb.h"


//
// DLL globals
//

extern PCSTR g_MigrateInfPath;
extern HINF g_MigrateInf;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\utils.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This source file implements utility functions used by scrnsave.c.

Author:

    Jim Schmidt (jimschm) 11-Apr-1997

Revision History:


--*/

#include "pch.h"

#ifdef UNICODE
#error UNICODE cannot be defined
#endif

//
// Declare strings
//

#define DEFMAC(var,str) CHAR var[] = str;
DEFINE_STRINGS
#undef DEFMAC

//
// Temporary buffer
//

static CHAR g_Data[MAX_PATH];

//
// Buffer for string representation of registry keys (for error logging)
//

typedef struct _tagKEYTOSTR {
    struct _tagKEYTOSTR *Prev, *Next;
    HKEY Key;
    CHAR RegKey[];
} KEYTOSTR, *PKEYTOSTR;

static PKEYTOSTR g_Head = NULL;

VOID
pAddKeyToStrMapping (
    IN      HKEY Key,
    IN      LPCSTR RootStr,
    IN      LPCSTR KeyStr
    )
{
    PKEYTOSTR Node;
    DWORD Size;
    CHAR FullKeyStr[MAX_PATH];

    // We control RootStr and KeyStr, so we know it is less than MAX_PATH in length
    wsprintf (FullKeyStr, "%s\\%s", RootStr, KeyStr);

    Size = sizeof (KEYTOSTR) + CountStringBytes (FullKeyStr);

    Node = (PKEYTOSTR) HeapAlloc (g_hHeap, 0, Size);
    if (Node) {
        Node->Prev = NULL;
        Node->Next = g_Head;
        Node->Key = Key;
        _mbscpy (Node->RegKey, FullKeyStr);

        if (g_Head) {
            g_Head->Prev = Node;
        }
        g_Head = Node;
    }
}

PKEYTOSTR
pFindKeyToStrMapping (
    IN      HKEY Key
    )
{
    PKEYTOSTR Node;

    Node = g_Head;
    while (Node) {
        if (Node->Key == Key) {
            return Node;
        }
        Node = Node->Next;
    }

    return NULL;
}

VOID
pRemoveKeyToStrMapping (
    IN      HKEY Key
    )
{
    PKEYTOSTR Node;

    Node = pFindKeyToStrMapping (Key);
    if (!Node) {
        return;
    }

    if (Node->Prev) {
        Node->Prev->Next = Node->Next;
    } else {
        g_Head = Node->Next;
    }

    if (Node->Next) {
        Node->Next->Prev = Node->Prev;
    }

    HeapFree (g_hHeap, 0, Node);
}
    

VOID
LogRegistryError (
    IN      HKEY Key,
    IN      LPCSTR ValueName
    )
{
    DWORD rc = GetLastError();
    LPCSTR FullKeyStr;
    PKEYTOSTR Node;

    Node = pFindKeyToStrMapping (Key);
    if (Node) {
        FullKeyStr = Node->RegKey;
    } else {
        FullKeyStr = S_DEFAULT_KEYSTR;
    }

    LOG ((LOG_ERROR, MSG_REGISTRY_ERROR, g_User, rc, FullKeyStr, ValueName));
}


VOID
GenerateFilePaths (
    VOID
    )
{
    INT Len;

    // Safety (unexpected condition)
    if (!g_WorkingDirectory) {
        return;
    }

    Len = CountStringBytes (g_WorkingDirectory) + sizeof(S_SETTINGS_MASK);
    g_SettingsFile = (LPSTR) HeapAlloc (g_hHeap, 0, Len);
    if (!g_SettingsFile) {
        return;
    }
    wsprintf (g_SettingsFile, S_SETTINGS_MASK, g_WorkingDirectory);

    Len = CountStringBytes (g_WorkingDirectory) + sizeof(S_MIGINF_MASK);
    g_MigrateDotInf = (LPSTR) HeapAlloc (g_hHeap, 0, Len);
    if (!g_MigrateDotInf) {
        return;
    }
    wsprintf (g_MigrateDotInf, S_MIGINF_MASK, g_WorkingDirectory);
}


HKEY
OpenRegKey (
    IN      HKEY RootKey,
    IN      LPCSTR KeyStr
    )
{
    HKEY Key;
    LONG rc;

    rc = RegOpenKeyEx (RootKey, KeyStr, 0, KEY_ALL_ACCESS, &Key);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    pAddKeyToStrMapping (Key, S_HKR, KeyStr);

    return Key;
}


HKEY
CreateRegKey (
    IN      HKEY RootKey,
    IN      LPCSTR KeyStr
    )
{
    HKEY Key;
    LONG rc;
    DWORD DontCare;

    pAddKeyToStrMapping (NULL, S_HKR, KeyStr);

    rc = RegCreateKeyEx (RootKey, KeyStr, 0, S_EMPTY, 0, 
                         KEY_ALL_ACCESS, NULL, &Key, &DontCare);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LogRegistryError (NULL, S_EMPTY);
        pRemoveKeyToStrMapping (NULL);
        return NULL;
    }

    pRemoveKeyToStrMapping (NULL);
    pAddKeyToStrMapping (Key, S_HKR, KeyStr);

    return Key;
}

VOID
CloseRegKey (
    IN      HKEY Key
    )
{
    pRemoveKeyToStrMapping (Key);
    RegCloseKey (Key);
}


LPCSTR
GetRegValueString (
    IN      HKEY Key,
    IN      LPCSTR ValueName
    )
{
    static CHAR DataBuf[MAX_PATH];
    DWORD Size;
    LONG rc;
    DWORD Type;
    DWORD d;

    Size = MAX_PATH;
    rc = RegQueryValueEx (Key, ValueName, NULL, &Type, DataBuf, &Size);
    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {
        return NULL;
    }

    if (Type == REG_DWORD) {
        d = *((PDWORD) DataBuf);
        wsprintf (DataBuf, "%u", d);
    }
    else if (Type != REG_SZ) {
        return NULL;
    }

    return DataBuf;
}

BOOL
SetRegValueString (
    HKEY Key,
    LPCSTR ValueName,
    LPCSTR ValueStr
    )
{
    LONG rc;
    LPCSTR p;

    p = _mbschr (ValueStr, 0);
    p++;

    rc = RegSetValueEx (Key, ValueName, 0, REG_SZ, ValueStr, p - ValueStr);
    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {
        LogRegistryError (Key, ValueName);
    }

    return rc == ERROR_SUCCESS;
}


LPCSTR
GetScrnSaveExe (
    VOID
    )
{
    CHAR IniFileSetting[MAX_PATH];

    GetPrivateProfileString (
            S_BOOT, 
            S_SCRNSAVE_EXE, 
            S_EMPTY, 
            IniFileSetting, 
            MAX_PATH, 
            S_SYSTEM_INI
            );

    if (!IniFileSetting[0]) {
        return NULL;
    }

    if (!OurGetLongPathName (IniFileSetting, g_Data)) {
        // File does not exist
        return NULL;
    }

    return g_Data[0] ? g_Data : NULL;
}

INT
_mbsbytes (
    IN      LPCSTR str
    )
{
    LPCSTR p;

    // Find the nul terminator and return the number of bytes
    // occupied by the characters in the string, but don't
    // include the nul.

    p = _mbschr (str, 0);
    return (p - str);
}


DWORD
CountStringBytes (
    IN      LPCSTR str
    )
{
    // Return bytes in string, plus 1 for the nul
    return _mbsbytes (str) + 1;
}

DWORD
CountMultiStringBytes (
    IN      LPCSTR str
    )
{
    LPCSTR p;
    INT Total = 0;
    INT Bytes;

    p = str;

    do {
        Bytes = CountStringBytes (p);
        p += Bytes;
        Total += Bytes;
    } while (Bytes > 1);

    return Total;
}


LPSTR
CopyStringAtoB (
    OUT     LPSTR mbstrDest, 
    IN      LPCSTR mbstrStart, 
    IN      LPCSTR mbstrEnd     // first char NOT to copy
    )
{
    LPSTR mbstrOrg;

    mbstrOrg = mbstrDest;

    // Assume mbstrEnd is on a lead byte

    while (mbstrStart < mbstrEnd) {
        if (isleadbyte (*mbstrStart)) {
            *mbstrDest = *mbstrStart;
            mbstrDest++;
            mbstrStart++;
        }

        *mbstrDest = *mbstrStart;
        mbstrDest++;
        mbstrStart++;
    }

    *mbstrDest = 0;

    return mbstrOrg;
}

LPSTR 
AppendStr (
    OUT     LPSTR mbstrDest, 
    IN      LPCSTR mbstrSrc
    )

{
    // Advance mbstrDest to end of string
    mbstrDest = _mbschr (mbstrDest, 0);

    // Copy string
    while (*mbstrSrc) {
        *mbstrDest = *mbstrSrc++;
        if (isleadbyte (*mbstrDest)) {
            mbstrDest++;
            *mbstrDest = *mbstrSrc++;
        }
        mbstrDest++;
    }

    *mbstrDest = 0;

    return mbstrDest;
}


BOOL
pFindShortName (
    IN      LPCTSTR WhatToFind,
    OUT     LPTSTR Buffer
    )
{
    WIN32_FIND_DATA fd;
    HANDLE hFind;

    hFind = FindFirstFile (WhatToFind, &fd);
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FindClose (hFind);
    _mbscpy (Buffer, fd.cFileName);

    return TRUE;
}


BOOL
OurGetLongPathName (
    IN      LPCSTR ShortPath,
    OUT     LPSTR Buffer
    )
{
    CHAR FullPath[MAX_PATH];
    LPSTR FilePart;
    LPSTR BufferEnd;
    LPSTR p, p2;
    CHAR c;

    //
    // Convert ShortPath into complete path name
    //

    if (!_mbschr (ShortPath, TEXT('\\'))) {
        if (!SearchPath (NULL, ShortPath, NULL, MAX_PATH, FullPath, &FilePart)) {
            return FALSE;
        }
    } else {
        GetFullPathName (ShortPath, MAX_PATH, FullPath, &FilePart);
    }

    //
    // Convert short path to long path
    //

    p = FullPath;

    // Don't process non-local paths
    if (!(*p) || _mbsnextc (_mbsinc (p)) != TEXT(':')) {
        _mbscpy (Buffer, FullPath);
        return TRUE;
    }

    p = _mbsinc (p);
    p = _mbsinc (p);
    if (_mbsnextc (p) != TEXT('\\')) {
        _mbscpy (Buffer, FullPath);
        return TRUE;
    }
    
    // Copy drive letter to buffer
    p = _mbsinc (p);
    CopyStringAtoB (Buffer, FullPath, p);
    BufferEnd = _mbschr (Buffer, 0);

    // Convert each portion of the path
    do {
        // Locate end of this file or dir
        p2 = _mbschr (p, TEXT('\\'));
        if (!p2) {
            p = _mbschr (p, 0);
        } else {
            p = p2;
        }

        // Look up file
        c = *p;
        *p = 0;
        if (!pFindShortName (FullPath, BufferEnd)) {
            return FALSE;
        }
        *p = c;

        // Move on to next part of path
        BufferEnd = _mbschr (BufferEnd, 0);
        if (*p) {
            p = _mbsinc (p);
            BufferEnd = AppendStr (BufferEnd, TEXT("\\"));
        }
    } while (*p);

    return TRUE;
}


BOOL
CreateScreenSaverParamKey (
    IN      LPCSTR ScreenSaverName,
    IN      LPCSTR ValueName,
    OUT     LPSTR Buffer
    )
{
    //
    // Make sure we cannot create a string bigger than MAX_PATH
    //

    if (_mbslen (ScreenSaverName) + 4 + _mbslen (ValueName) > MAX_PATH) {
        return FALSE;
    }

    //
    // Format the string with length of screen saver name, screen saver name,
    // and value name.
    //

    wsprintf (Buffer, "%03u/%s/%s", _mbslen (ScreenSaverName), ScreenSaverName, ValueName);

    return TRUE;
}

BOOL
DecodeScreenSaverParamKey (
    IN      LPCSTR EncodedString,
    OUT     LPSTR ScreenSaverName,
    OUT     LPSTR ValueName
    )
{
    INT Len;

    //
    // Validate encoded string.  It is in the form of ###/screen saver name/value name.
    //

    Len = atoi (EncodedString);
    if (Len < 0 || Len >= MAX_PATH || (Len - 5) > (INT) _mbslen (EncodedString)) {
        return FALSE;
    }

    if (EncodedString[3] != '/' || EncodedString[4 + Len] != '/') {
        return FALSE;
    }

    if (_mbslen (EncodedString + 5 + Len) >= MAX_PATH) {
        return FALSE;
    }

    //
    // Extract screen saver name and value name
    //

    _mbsncpy (ScreenSaverName, EncodedString + 4, Len);
    ScreenSaverName[Len] = 0;

    _mbscpy (ValueName, EncodedString + 5 + Len);
    return TRUE;
}

LPSTR
_mbsistr (
    IN      LPCSTR mbstrStr, 
    IN      LPCSTR mbstrSubStr
    )
{
    LPCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos;
    LPCSTR mbstrEnd;

    mbstrEnd = (LPSTR) ((LPBYTE) mbstrStr + _mbsbytes (mbstrStr) - _mbsbytes (mbstrSubStr));

    for (mbstrStart = mbstrStr ; mbstrStart <= mbstrEnd ; mbstrStart = _mbsinc (mbstrStart)) {
        mbstrStrPos = mbstrStart;
        mbstrSubStrPos = mbstrSubStr;

        while (*mbstrSubStrPos && 
               _mbctolower ((INT) _mbsnextc (mbstrSubStrPos)) == _mbctolower ((INT) _mbsnextc (mbstrStrPos))) 
        {
            mbstrStrPos = _mbsinc (mbstrStrPos);
            mbstrSubStrPos = _mbsinc (mbstrSubStrPos);
        }

        if (!(*mbstrSubStrPos))
            return (LPSTR) mbstrStart;
    }

    return NULL;    
}

VOID
DeletePartOfString (
    IN      LPSTR Buffer,
    IN      DWORD CharsToDelete
    )
{
    LPSTR p;
    DWORD d;

    p = Buffer;
    for (d = 0 ; *p && d < CharsToDelete ; d++) {
        p = _mbsinc (p);
    }

    if (!(*p)) {
        *Buffer = 0;
    } else {
        MoveMemory (Buffer, p, CountStringBytes(p));
    }
}

VOID
InsertStringInString (
    IN      LPSTR Buffer,
    IN      LPCSTR StringToInsert
    )
{
    DWORD BytesToMove;
    DWORD BytesOfInsertedString;

    BytesToMove = CountStringBytes (Buffer);
    BytesOfInsertedString = _mbsbytes(StringToInsert);
    MoveMemory (Buffer + BytesOfInsertedString, 
                Buffer,
                BytesToMove
                );
    _mbsncpy (Buffer, StringToInsert, _mbslen (StringToInsert));
}



PCSTR
ParseMessage (
    UINT MessageId,
    ...
    )
{
    va_list list;
    PSTR RetStr = NULL;
    UINT RetStrSize;

    va_start (list, MessageId);

    RetStrSize = FormatMessageA (
                    FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
                    (PSTR) g_hInst,
                    MessageId,
                    0,
                    (PSTR) (&RetStr),
                    1,
                    &list
                    );

    if (!RetStrSize && RetStr) {
        *RetStr = 0;
    }

    va_end (list);

    return RetStr;
}

VOID
FreeMessage (
    PCSTR Message
    )
{
    if (Message) {
        LocalFree ((PSTR) Message);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\scrnsave.h ===
#include "miginf.h"

//
// utils.c -- reusable utilities (unrelated to screen saver code)
//

VOID
LogRegistryError (
    IN      HKEY Key,
    IN      LPCSTR ValueName
    );

HKEY
OpenRegKey (
    IN      HKEY RootKey,
    IN      LPCSTR Key
    );

HKEY
CreateRegKey (
    IN      HKEY RootKey,
    IN      LPCSTR Key
    );

VOID
CloseRegKey (
    IN      HKEY Key
    );

LPCSTR
GetRegValueString (
    IN      HKEY Key,
    IN      LPCSTR ValueName
    );

BOOL
SetRegValueString (
    HKEY Key,
    LPCSTR ValueName,
    LPCSTR ValueStr
    );

DWORD
CountStringBytes (
    IN      LPCSTR str
    );

DWORD
CountMultiStringBytes (
    IN      LPCSTR str
    );

LPSTR
CopyStringAtoB (
    OUT     LPSTR mbstrDest, 
    IN      LPCSTR mbstrStart, 
    IN      LPCSTR mbstrEnd     // ptr to the first char NOT to copy
    );

BOOL
OurGetLongPathName (
    LPCSTR ShortPath,
    LPSTR Buffer
    );

VOID
ConvertSystemToSystem32 (
    IN OUT  LPSTR Filename
    );

//
// utils.c -- helper functions specific to screen saver settings
//

VOID
GenerateFilePaths (
    VOID
    );

LPCSTR
GetScrnSaveExe (
    VOID
    );

BOOL
CreateScreenSaverParamKey (
    IN      LPCSTR ScreenSaverName,
    IN      LPCSTR Value,
    OUT     LPSTR Buffer
    );

BOOL
DecodeScreenSaverParamKey (
    IN      LPCSTR EncodedString,
    OUT     LPSTR ScreenSaverName,
    OUT     LPSTR ValueName
    );


//
// savecfg.c -- functions that save things to our working directory
//

BOOL
SaveDatFileKeyAndVal (
    IN      LPCSTR Key,
    IN      LPCSTR Val
    );

BOOL
CopyRegValueToDatFile (
    IN      HKEY RegKey,
    IN      LPCSTR ValueName
    );

BOOL
SaveControlIniSection (
    LPCSTR ControlIniSection,
    LPCSTR ScreenSaverName
    );


//
// dataconv.c -- functions that convert Win9x settings & save them on NT
//

BOOL
CopyValuesFromDatFileToRegistry (
    IN      HKEY RegKey,
    IN      LPCSTR RegKeyName,
    IN      LPCSTR ScreenSaverName,
    IN      LPCSTR ValueArray[]
    );

LPCSTR
GetSettingsFileVal (
    IN      LPCSTR Key
    );

BOOL
TranslateGeneralSetting (
    IN      HKEY RegKey,
    IN      LPCSTR Win9xSetting,
    IN      LPCSTR WinNTSetting
    );

BOOL
SaveScrName (
    IN      HKEY RegKey, 
    IN      LPCSTR KeyName
    );

BOOL
TranslateScreenSavers (
    IN      HKEY RegRoot
    );

BOOL
CopyUntranslatedSettings (
    IN      HKEY RegRoot
    );

PCSTR
ParseMessage (
    UINT MessageId,
    ...
    );

VOID
FreeMessage (
    PCSTR Message
    );


//
// DLL globals
//

extern LPCSTR g_User;
extern LPSTR g_SettingsFile;
extern LPSTR g_MigrateDotInf;
extern LPSTR g_WorkingDirectory;
extern LPSTR g_SourceDirectories;
extern HANDLE g_hHeap;
extern HINSTANCE g_hInst;

//
// Define strings
//

#define DEFINE_NONLOCALIZED_STRINGS                                         \
    DEFMAC (S_BOOT,             "boot")                                     \
    DEFMAC (S_SCRNSAVE_EXE,     "SCRNSAVE.EXE")                             \
    DEFMAC (S_SCRNSAVE_DOT,     "Screen Saver.")                            \
    DEFMAC (S_SCRNSAVE_MASK,    "Screen Saver.%s")                          \
    DEFMAC (S_EMPTY,            "")                                         \
    DEFMAC (S_DOUBLE_EMPTY,     "\0")                                       \
    DEFMAC (S_SETTINGS_MASK,    "%s\\settings.dat")                         \
    DEFMAC (S_MIGINF_MASK,      "%s\\migrate.inf")                          \
    DEFMAC (S_SYSTEM_INI,       "system.ini")                               \
    DEFMAC (S_CONTROL_INI,      "control.ini")                              \
    DEFMAC (S_BEZIER,           "Bezier")                                   \
    DEFMAC (S_MARQUEE,          "Marquee")                                  \
    DEFMAC (S_BEZIER_SETTINGS,  "Screen Saver.Bezier")                      \
    DEFMAC (S_MARQUEE_SETTINGS, "Screen Saver.Marquee")                     \
    DEFMAC (S_MIGRATION_PATHS,  "Migration Paths")                          \
    DEFMAC (S_CONTROL_PANEL_MASK, "Control Panel\\%s")                      \
    DEFMAC (S_LENGTH,           "Length")                                   \
    DEFMAC (S_WIDTH,            "Width")                                    \
    DEFMAC (S_LINESPEED,        "LineSpeed")                                \
    DEFMAC (S_BACKGROUND_COLOR, "BackgroundColor")                          \
    DEFMAC (S_CHARSET,          "CharSet")                                  \
    DEFMAC (S_FONT,             "Font")                                     \
    DEFMAC (S_MODE,             "Mode")                                     \
    DEFMAC (S_SIZE,             "Size")                                     \
    DEFMAC (S_SPEED,            "Speed")                                    \
    DEFMAC (S_TEXT,             "Text")                                     \
    DEFMAC (S_TEXTCOLOR,        "TextColor")                                \
    DEFMAC (S_ACTIVE1,          "Active1")                                  \
    DEFMAC (S_ACTIVE2,          "Active2")                                  \
    DEFMAC (S_CLEAN_SCREEN,     "Clean Screen")                             \
    DEFMAC (S_ENDCOLOR1,        "EndColor1")                                \
    DEFMAC (S_ENDCOLOR2,        "EndColor2")                                \
    DEFMAC (S_LINES1,           "Lines1")                                   \
    DEFMAC (S_LINES2,           "Lines2")                                   \
    DEFMAC (S_STARTCOLOR1,      "StartColor1")                              \
    DEFMAC (S_STARTCOLOR2,      "StartColor2")                              \
    DEFMAC (S_WALKRANDOM1,      "WalkRandom1")                              \
    DEFMAC (S_WALKRANDOM2,      "WalkRandom2")                              \
    DEFMAC (S_DENSITY,          "Denisty")                                  \
    DEFMAC (S_WARPSPEED,        "WarpSpeed")                                \
    DEFMAC (S_HKR,              "HKR")                                      \
    DEFMAC (S_DEFAULT_KEYSTR,   "(unknown regkey)")                         \
    DEFMAC (S_SYSTEM_DIR,       "\\system\\")                               \
    DEFMAC (S_SYSTEM32_DIR,     "\\system32\\")                             \

#define DEFINE_STRINGS DEFINE_NONLOCALIZED_STRINGS

//
// Declare externs for all string variables
//

#define DEFMAC(var,str) extern CHAR var[];
DEFINE_STRINGS
#undef DEFMAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\scrnsamp\scrnsave.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    scrnsave.c

Abstract:

    This source file implements the seven required functions for a
    Windows NT 5.0 migration DLL.  The DLL demonstrates how the
    interface works by performing the Windows 9x screen saver 
    upgrade.

    The source here is a subset of the actual screen saver DLL
    that ships with Windows NT Setup.

    This sample demonstrates:

      - How to detect installation of your application

      - A typical implementation of QueryVersion, Initialize9x, 
        MigrateUser9x, MigrateSystem9x, InitializeNT, 
        MigrateUserNT and MigraetSystemNT

      - How to provide language-dependent incompatibility
        messages to the user

      - How to remove Setup's incompatibility messages via
        [Handled] section

      - Saving settings to a temporarly file in the working 
        directory

      - Mix use of ANSI and UNICODE

      - Use of the SetupLogError API

      - Deleting files

      - Handling the move from system to system32

Author:

    Jim Schmidt 11-Apr-1997

Revision History:


--*/

#include "pch.h"

BOOL
pLoadFileNames (
    VOID
    );


//
// Constants
//

#define CP_USASCII          1252
#define CP_JAPANESE         932
#define CP_CHT              950
#define CP_CHS              936
#define CP_KOREAN           949
#define END_OF_CODEPAGES    -1

//
// Code page array
//

INT   g_CodePageArray[] = {
            CP_USASCII,
            CP_JAPANESE,
            CP_CHT,
            CP_CHS,
            CP_KOREAN,
            END_OF_CODEPAGES
            };

//
// Multi-sz (i.e., double-nul terminated) list of files to find
//

CHAR    g_ExeNamesBuf[1024];
CHAR    g_MyProductId[MAX_PATH];
CHAR    g_DefaultUser[MAX_PATH];


//
// Copies of the working directory and source directory
//

LPSTR   g_WorkingDirectory = NULL;
LPSTR   g_SourceDirectories = NULL;         // multi-sz
LPSTR   g_SettingsFile = NULL;
LPSTR   g_MigrateDotInf = NULL;

//
// Registry locations and INI file sections
//

#define REGKEY_DESKTOP "Control Panel\\Desktop"
#define FULL_REGKEY_DESKTOP "HKR\\Control Panel\\Desktop"
#define FULL_REGKEY_PWD_PROVIDER "HKLM\\System\\CurrentControlSet\\Control\\PwdProvider\\SCRSAVE"

#define REGVAL_SCREENSAVEACTIVE "ScreenSaveActive"
#define REGVAL_SCREENSAVELOWPOWERACTIVE "ScreenSaveLowPowerActive"
#define REGVAL_SCREENSAVELOWPOWERTIMEOUT "ScreenSaveLowPowerTimeout"
#define REGVAL_SCREENSAVEPOWEROFFACTIVE "ScreenSavePowerOffActive"
#define REGVAL_SCREENSAVEPOWEROFFTIMEOUT "ScreenSavePowerOffTimeout"
#define REGVAL_SCREENSAVETIMEOUT "ScreenSaveTimeOut"
#define REGVAL_SCREENSAVEUSEPASSWORD "ScreenSaveUsePassword"

#define REGVAL_LOWPOWERACTIVE "LowPowerActive"
#define REGVAL_LOWPOWERTIMEOUT "LowPowerTimeout"
#define REGVAL_POWEROFFACTIVE "PowerOffActive"
#define REGVAL_POWEROFFTIMEOUT "PowerOffTimeout"
#define REGVAL_SCREENSAVERISSECURE "ScreenSaverIsSecure"

//
// State variables
//

BOOL g_FoundPassword = FALSE;
LPCSTR g_User;
CHAR g_UserNameBuf[MAX_PATH];
HANDLE g_hHeap;
HINSTANCE g_hInst;



BOOL
WINAPI
DllMain (
    IN      HANDLE DllInstance,
    IN      ULONG  ReasonForCall,
    IN      LPVOID Reserved
    )
{
    PCSTR Message;

    switch (ReasonForCall)  {

    case DLL_PROCESS_ATTACH:
        //
        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
        //
        DisableThreadLibraryCalls (DllInstance);

        //
        // Global init
        //
        g_hInst = DllInstance;
        g_hHeap = GetProcessHeap();

        if (!MigInf_Initialize()) {
            return FALSE;
        }

        Message = ParseMessage (MSG_PRODUCT_ID);
        if (Message) {
            _mbscpy (g_MyProductId, Message);
            FreeMessage (Message);
        }

        Message = ParseMessage (MSG_DEFAULT_USER);
        if (Message) {
            _mbscpy (g_DefaultUser, Message);
            FreeMessage (Message);
        }

        // Open log; FALSE means do not delete existing log
        SetupOpenLog (FALSE);
        break;

    case DLL_PROCESS_DETACH:
        MigInf_CleanUp();

        // Clean up strings
        if (g_WorkingDirectory) {
            HeapFree (g_hHeap, 0, g_WorkingDirectory);
        }
        if (g_SourceDirectories) {
            HeapFree (g_hHeap, 0, g_SourceDirectories);
        }
        if (g_SettingsFile) {
            HeapFree (g_hHeap, 0, g_SettingsFile);
        }
        if (g_MigrateDotInf) {
            HeapFree (g_hHeap, 0, g_MigrateDotInf);
        }

        SetupCloseLog();

        break;
    }

    return TRUE;
}


LONG
CALLBACK
QueryVersion (
    OUT     LPCSTR *ProductID,
	OUT     LPUINT DllVersion,
	OUT     LPINT *CodePageArray,	    OPTIONAL
	OUT     LPCSTR *ExeNamesBuf,	    OPTIONAL
	        LPVOID Reserved
    )
{
    //
    // Complete load of string resources, act like not installed
    // on resource error (unexpected condition).
    //

    if (!g_MyProductId[0] || !g_DefaultUser[0]) {
        return ERROR_NOT_INSTALLED;
    }

    if (!pLoadFileNames()) {
        return ERROR_NOT_INSTALLED;
    }

    //
    // We do some preliminary investigation to see if 
    // our components are installed.  
    //

    if (!GetScrnSaveExe()) {
        //
        // We didn't detect any components, so we return 
        // ERROR_NOT_INSTALLED and the DLL will stop being called.
        // Use this method as much as possible, because user enumeration
        // for MigrateUser9x is relatively slow.  However, don't spend too
        // much time here because QueryVersion is expected to run quickly.
        //
        return ERROR_NOT_INSTALLED;
    }

    //
    // Screen saver is enabled, so tell Setup who we are.  ProductID is used
    // for display, so it must be localized.  The ProductID string is 
    // converted to UNICODE for use on Windows NT via the MultiByteToWideChar
    // Win32 API.  It uses the same code page as FormatMessage to do
    // its conversion.
    //

    *ProductID  = g_MyProductId;

    //
    // Report our version.  Zero is reserved for use by DLLs that
    // ship with Windows NT.
    //

    *DllVersion = 1;

    // 
    // We return an array that has all ANSI code pages that we have
    // text for.
    //
    // Tip: If it makes more sense for your DLL to use locales,
    // return ERROR_NOT_INSTALLED if the DLL detects that an appropriate 
    // locale is not installed on the machine.
    //

    *CodePageArray = g_CodePageArray;

    //
    // ExeNamesBuf - we pass a list of file names (the long versions)
    // and let Setup find them for us.  Keep this list short because
    // every instance of the file on every hard drive will be reported
    // in migrate.inf.
    //
    // Most applications don't need this behavior, because the registry
    // usually contains full paths to installed components.  We need it,
    // though, because there are no registry settings that give us the
    // paths of the screen saver DLLs.
    //

    *ExeNamesBuf = g_ExeNamesBuf;

    return ERROR_SUCCESS;
}


LONG
CALLBACK
Initialize9x (
	IN      LPCSTR WorkingDirectory,
	IN      LPCSTR SourceDirectories,
	        LPVOID Reserved
    )
{
    INT Len;
    
    //
    // Because we returned ERROR_SUCCESS in QueryVersion, we are being
    // called for initialization.  Therefore, we know screen savers are
    // enabled on the machine at this point.
    // 

    //
    // Make global copies of WorkingDirectory and SourceDirectories --
    // we will not get this information again, and we shouldn't
    // count on Setup keeping the pointer valid for the life of our
    // DLL.
    //

    Len = CountStringBytes (WorkingDirectory);
    g_WorkingDirectory = HeapAlloc (g_hHeap, 0, Len);

    if (!g_WorkingDirectory) {
        return GetLastError();
    }

    CopyMemory (g_WorkingDirectory, WorkingDirectory, Len);

    Len = CountMultiStringBytes (SourceDirectories);
    g_SourceDirectories = HeapAlloc (g_hHeap, 0, Len);

    if (!g_SourceDirectories) {
        return GetLastError();
    }

    CopyMemory (g_SourceDirectories, SourceDirectories, Len);

    //
    // Now create our private 'settings file' path
    //

    GenerateFilePaths();

    //
    // Return success to have MigrateUser9x called
    //
    // Tip: A DLL can save system settings during Initialize9x as
    //      well as MigrateSystem9x.
    //
    //

    return ERROR_SUCCESS;
}


LONG
CALLBACK 
MigrateUser9x (
	IN      HWND ParentWnd, 
	IN      LPCSTR UnattendFile,
	IN      HKEY UserRegKey, 
	IN      LPCSTR UserName, 
	        LPVOID Reserved
	)
{
    HKEY RegKey;
    LPCSTR ScrnSaveExe;
    DWORD rc = ERROR_SUCCESS;
    LPSTR SectionNameBuf, p;
    DWORD SectionNameSize;
    DWORD Len;

    //
    // This DLL does not require input from the user to upgrade
    // their settings, so ParentWnd is not used.  Avoid displaying
    // any user interface when possible.
    //
    // We don't need to use UnattendFile settings because we are not
    // a service (such as a network redirector).  Therefore, we do not 
    // use the  UnattendFile parameter.
    //
    // We don't have any files that need to be generated or expanded on
    // the NT side of Setup, so we do not write to the 
    // [NT Disk Space Requirements] section of migrate.inf.
    //

    //
    // We must collect a few registry keys:
    //
    //   HKCU\Control Panel\Desktop
    //        ScreenSaveActive
    //        ScreenSaveLowPowerActive
    //        ScreenSaveLowPowerTimeout
    //        ScreenSavePowerOffActive
    //        ScreenSavePowerOffTimeout
    //        ScreenSaveTimeOut
    //        ScreenSaveUsePassword
    //
    // If ScreenSave_Data exists, we tell the user that their
    // password is not supported by writing an incompatiility
    // message.
    //

    //
    // Save the user name in a global so our utils write to the
    // correct section.
    //

    if (UserName) {
        g_User = UserName;
    } else {
        g_User = g_DefaultUser;
    }

    // OpenRegKey is our utility (in utils.c)
    RegKey = OpenRegKey (UserRegKey, REGKEY_DESKTOP);
    if (!RegKey) {
        //
        // User's registry is invalid, so skip the user
        //
        return ERROR_NOT_INSTALLED;
    }

    //
    // Note: NO changes allowed on Win9x side, we can only read our
    //       settings and save them in a file.
    //

    if (!CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEACTIVE) ||
        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVELOWPOWERACTIVE) ||
        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVELOWPOWERTIMEOUT) ||
        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEPOWEROFFACTIVE) ||
        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEPOWEROFFTIMEOUT) ||
        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVETIMEOUT) ||
        !CopyRegValueToDatFile (RegKey, REGVAL_SCREENSAVEUSEPASSWORD)
        ) {
        rc = GetLastError();
    }

    if (atoi (GetRegValueString (RegKey, REGVAL_SCREENSAVEUSEPASSWORD))) {
        // Queue change so there is only one message
        g_FoundPassword = TRUE;
    }

    //
    // Save EXE location in our dat file
    //

    ScrnSaveExe = GetScrnSaveExe();

    if (ScrnSaveExe) {
        if (!SaveDatFileKeyAndVal (S_SCRNSAVE_EXE, ScrnSaveExe)) {
            rc = GetLastError();
        }
    }

    //
    // Copy control.ini sections to our dat file
    //

    SectionNameSize = 32768;
    SectionNameBuf = (LPSTR) HeapAlloc (g_hHeap, 0, SectionNameSize);
    if (!SectionNameBuf) {
        return GetLastError();
    }

    GetPrivateProfileString (
        NULL,
        NULL,
        S_DOUBLE_EMPTY,
        SectionNameBuf,
        SectionNameSize,
        S_CONTROL_INI
        );

    Len = _mbslen (S_SCRNSAVE_DOT);
    for (p = SectionNameBuf ; *p ; p = _mbschr (p, 0) + 1) {
        //
        // Determine if section name has "Screen Saver." at the beginning
        //

        if (!_mbsnicmp (p, S_SCRNSAVE_DOT, Len)) {
            //
            // It does, so save it to our private file
            //
            SaveControlIniSection (p, p + Len);
        }
    }

    CloseRegKey (RegKey);

    if (rc != ERROR_SUCCESS) {
        LOG ((LOG_ERROR, MSG_PROCESSING_ERROR, g_User, rc));
    } else {
        //
        // Write handled for every setting we are processing.  Because this
        // DLL supports only some of the values in the Desktop key, we must
        // be very specific as to which values are actually handled.  If
        // your DLL handles all registry values AND subkeys of a registry
        // key, you can specify NULL in the second parameter of 
        // MigInf_AddHandledRegistry.
        //

        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEACTIVE);
        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVELOWPOWERACTIVE);
        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVELOWPOWERTIMEOUT);
        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEPOWEROFFACTIVE);
        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEPOWEROFFTIMEOUT);
        MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVETIMEOUT);
        
        //
        // We do not say that we handle REGVAL_SCREENSAVEUSEPASSWORD when we write
        // an incompatibility message for it.  If we did, we would be suppressing
        // our own message!
        //

        if (!g_FoundPassword) {
            MigInf_AddHandledRegistry (FULL_REGKEY_DESKTOP, REGVAL_SCREENSAVEUSEPASSWORD);
        }
    }

    return rc;
}


LONG 
CALLBACK 
MigrateSystem9x (
	IN      HWND ParentWnd, 
	IN      LPCSTR UnattendFile,
	        LPVOID Reserved
	)
{
    HINF MigrateInf;
    INFCONTEXT ic;
    CHAR FileName[MAX_PATH*2];
    PCSTR Message;

    //
    // We handle the password provider incompatibility
    //

    MigInf_AddHandledRegistry (FULL_REGKEY_PWD_PROVIDER, NULL);

    //
    // Write incompatibility message if necessary (detected in MigrateUser9x)
    //

    if (g_FoundPassword) {
        Message = ParseMessage (MSG_PASSWORD_ALERT);
        MigInf_AddMessage (g_MyProductId, Message);
        FreeMessage (Message);

        MigInf_AddMessageRegistry (
                g_MyProductId, 
                FULL_REGKEY_DESKTOP, 
                REGVAL_SCREENSAVEUSEPASSWORD
                );
    }

    //
    // Use Setup APIs to scan migration paths section
    //

    MigrateInf = SetupOpenInfFile (
                        g_MigrateDotInf,
                        NULL,
                        INF_STYLE_WIN4,
                        NULL
                        );

    if (MigrateInf != INVALID_HANDLE_VALUE) {
        if (SetupFindFirstLine (MigrateInf, S_MIGRATION_PATHS, NULL, &ic)) {
            do {
                if (SetupGetStringField (&ic, 0, FileName, MAX_PATH, NULL)) {
                    //
                    // We will be deleting the file, so we must notify Setup
                    // by writing an entry to [Moved] that has an empty right
                    // side.
                    //

                    MigInf_AddMovedFile (FileName, "");
                }
            } while (SetupFindNextLine (&ic, &ic));
        }
        
        SetupCloseInfFile (MigrateInf);
    } else {
        return GetLastError();
    }

    //
    // Write memory version of migrate.inf to disk
    //

    if (!MigInf_WriteInfToDisk()) {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK 
InitializeNT (
	IN      LPCWSTR WorkingDirectory,
	IN      LPCWSTR SourceDirectories,
	        LPVOID Reserved
	)
{
    INT Length;
    LPCWSTR p;

    //
    // Save our working directory and source directory.  We
    // convert UNICODE to ANSI, and we use the system code page.
    //

    //GetSystemCodePage
    
    //
    // Compute length of source directories
    //

    p = SourceDirectories;
    while (*p) {
        p = wcschr (p, 0) + 1;
    }
    p++;
    Length = (p - SourceDirectories) / sizeof (WCHAR);

    //
    // Convert the directories from UNICODE to DBCS.  This DLL is
    // compiled in ANSI.
    //

    g_WorkingDirectory = (LPSTR) HeapAlloc (g_hHeap, 0, MAX_PATH);
    if (!g_WorkingDirectory) {
        return GetLastError();
    }

    WideCharToMultiByte (
        CP_ACP, 
        0, 
        WorkingDirectory, 
        -1,
        g_WorkingDirectory,
        MAX_PATH,
        NULL,
        NULL
        );

    g_SourceDirectories = (LPSTR) HeapAlloc (g_hHeap, 0, Length * sizeof(WCHAR));
    if (!g_SourceDirectories) {
        return GetLastError();
    }

    WideCharToMultiByte (
        CP_ACP, 
        0, 
        SourceDirectories, 
        Length,
        g_SourceDirectories,
        Length * sizeof (WCHAR),
        NULL,
        NULL
        );

    //
    // Now generate the derived file names
    //

    GenerateFilePaths();

    //
    // Note: We have no use for g_SourceDirectories for the screen saver
    //       upgrade.  The g_SourceDirectories string points to the Windows
    //       NT media (i.e. e:\i386) and optional directories specified on
    //       the WINNT32 command line.
    //

    return ERROR_SUCCESS;
}



LONG
CALLBACK 
MigrateUserNT (
	IN      HINF UnattendInfHandle,
	IN      HKEY UserRegKey,
	IN      LPCWSTR UserName,
            LPVOID Reserved
	)
{
    HKEY DesktopRegKey;
    DWORD rc = ERROR_SUCCESS;
    BOOL b = TRUE;

    //
    // Setup gives us the UnattendInfHandle instead of the file name,
    // so we don't have to open the inf file repeatitively.  Since
    // Setup opened the handle, let Setup close it.
    //

    //
    // Convert UserName to ANSI
    //

    if (UserName) {
        WideCharToMultiByte (
            CP_ACP, 
            0, 
            UserName, 
            -1,
            g_UserNameBuf,
            MAX_PATH,
            NULL,
            NULL
            );

        g_User = g_UserNameBuf;
    } else {
        g_User = g_DefaultUser;
    }

    //
    // Setup copies all of the Win9x registry, EXCEPT for the registry
    // keys that are suppressed in usermig.inf or wkstamig.inf.
    //
    // We need the HKCU\Control Panel\Desktop key, and because this is
    // an OS key, the settings have been altered. Most applications
    // store their settings in HKCU\Software, HKLM\Software or 
    // HKCC\Software, and all three of these keys are copied in their
    // entirety (except the operating system settings in 
    // Software\Microsoft\Windows).
    //
    // When the non-OS software settings are copied from Win9x to NT, Setup
    // sometimes alters their value.  For example, all registry values
    // that point to a file that was moved from SYSTEM to SYSTEM32
    // are modified to point to the right place.
    //

    //
    // Note: we use CreateRegKey here, but actually the key always exists
    // because the NT defaults have been copied into the user's registry
    // already.  This approach reduces the possibility of failure.
    //

    DesktopRegKey = CreateRegKey (UserRegKey, REGKEY_DESKTOP);
    if (!DesktopRegKey) {
        rc = GetLastError();
        LOG ((LOG_ERROR, MSG_REGISTRY_ERROR, g_User, rc));

        return rc;
    }

    // The variable b is used to fall through when we fail unexpectedly

    b = TranslateGeneralSetting (
            DesktopRegKey, 
            REGVAL_SCREENSAVEACTIVE, 
            NULL
            );

    if (b) {
        b = TranslateGeneralSetting (
                DesktopRegKey, 
                REGVAL_SCREENSAVELOWPOWERACTIVE, 
                REGVAL_LOWPOWERACTIVE
                );
    }
    if (b) {
        b = TranslateGeneralSetting (
                DesktopRegKey, 
                REGVAL_SCREENSAVELOWPOWERTIMEOUT, 
                REGVAL_LOWPOWERTIMEOUT
                );
    }
    if (b) {
        b = TranslateGeneralSetting (
                DesktopRegKey, 
                REGVAL_SCREENSAVEPOWEROFFACTIVE, 
                REGVAL_POWEROFFACTIVE
                );
    }
    if (b) {
        b = TranslateGeneralSetting (
                DesktopRegKey, 
                REGVAL_SCREENSAVEPOWEROFFTIMEOUT, 
                REGVAL_POWEROFFTIMEOUT
                );
    }
    if (b) {
        b = TranslateGeneralSetting (
                DesktopRegKey, 
                REGVAL_SCREENSAVETIMEOUT, 
                NULL
                );
    }
    if (b) {
        b = TranslateGeneralSetting (
                DesktopRegKey, 
                REGVAL_SCREENSAVEUSEPASSWORD, 
                REGVAL_SCREENSAVERISSECURE
                );
    }

    if (b) {
        b = SaveScrName (DesktopRegKey, S_SCRNSAVE_EXE);
    }

    if (b) {
        //
        // For screen savers work differently on Win9x and NT, perform
        // translation.
        //

        TranslateScreenSavers (UserRegKey);
        
        //
        // The other settings just need to be copied from control.ini
        // to the registry.
        //

        CopyUntranslatedSettings (UserRegKey);
    }


    CloseRegKey (DesktopRegKey);

    //
    // Always return success, because if an error occurred for one user,
    // we don't have a reason not to process the next user.  If your DLL
    // runs into a fatal problem, such as a disk space shortage, you
    // should return the error.
    //

    return ERROR_SUCCESS;
}


LONG
CALLBACK 
MigrateSystemNT (
	IN      HINF UnattendInfHandle,
            LPVOID Reserved
	)
{
    CHAR FileName[MAX_PATH];
    HINF MigrateInf;
    INFCONTEXT ic;

    //
    // We now delete the Win9x screen savers that were replaced
    // by Windows NT.
    //

    MigrateInf = SetupOpenInfFile (
                        g_MigrateDotInf,
                        NULL,
                        INF_STYLE_WIN4,
                        NULL
                        );

    if (MigrateInf != INVALID_HANDLE_VALUE) {

        //
        // Use Setup APIs to scan migration paths section
        //

        if (SetupFindFirstLine (MigrateInf, S_MIGRATION_PATHS, NULL, &ic)) {
            do {
                if (SetupGetStringField (&ic, 0, FileName, MAX_PATH, NULL)) {
                    //
                    // All 32-bit binaries located in the Win9x system directory
                    // were moved to system32.  However, since we listed the
                    // screen savers in [Migration Paths], the screen savers were
                    // not moved.
                    //
                    // Now delete the file. Ignore errors because user may have 
                    // lost power, and we may be going through this a second time.
                    //

                    if (!DeleteFile (FileName)) {
                        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                            LOG ((LOG_ERROR, MSG_DELETEFILE_ERROR));
                        }
                    } else {
                        LOG ((LOG_INFORMATION, MSG_DELETEFILE_SUCCESS, FileName));
                    }
                }
            } while (SetupFindNextLine (&ic, &ic));
        }
    
        SetupCloseInfFile (MigrateInf);
    }

    return ERROR_SUCCESS;
}


BOOL
pLoadFileNames (
    VOID
    )
{
    PSTR p;
    PCSTR Message;

    Message = ParseMessage (MSG_FILENAMES);
    _mbscpy (g_ExeNamesBuf, Message);
    FreeMessage (Message);

    if (!g_ExeNamesBuf[0]) {
        return FALSE;
    }

    p = g_ExeNamesBuf;

    while (*p) {
        if (_mbsnextc (p) == '|') {
            *p = 0;
        }

        p = _mbsinc (p);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\pch.h ===
#include "migrate.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\kkimgpro.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    kkimgpro.c

Abstract:

    This source file implements the operations needed to properly migrate Kodak Imaging Pro from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    15-Mar-1999

Revision History:


--*/


#include "pch.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_KODAKIMG_FILE1        "KODAKIMG.EXE"
#define S_KODAKIMG_FILE2        "KODAKPRV.EXE"
#define MEMDB_CATEGORY_KKIMGPRO "KodakImagingPro"
#define S_COMPANYNAME           "CompanyName"
#define S_PRODUCTVER            "ProductVersion"
#define S_KKIMG_COMPANYNAME1    "Eastman Software*"
#define S_KKIMG_PRODUCTVER1     "2.*"
#define S_KKIMG_COMPANYNAME2    "Eastman Software*"
#define S_KKIMG_PRODUCTVER2     "2.*"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

PSTR
QueryVersionEntry (
    IN      PCSTR FileName,
    IN      PCSTR VersionEntry
    )
/*++

Routine Description:

  QueryVersionEntry queries the file's version structure returning the
  value for a specific entry

Arguments:

  FileName     - File to query for version struct.

  VersionEntry - Name to query in version structure.

Return value:

  Value of specified entry or NULL if unsuccessful

--*/
{
    VERSION_STRUCT Version;
    PCSTR CurrentStr;
    PSTR result = NULL;

    MYASSERT (VersionEntry);

    if (CreateVersionStruct (&Version, FileName)) {
        __try {
            CurrentStr = EnumFirstVersionValue (&Version, VersionEntry);
            if (CurrentStr) {
                CurrentStr = SkipSpace (CurrentStr);
                result = DuplicatePathString (CurrentStr, 0);
            }
            else {
                __leave;
            }
        }
        __finally {
            DestroyVersionStruct (&Version);
        }
    }
    return result;
}


BOOL
KodakImagingPro_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
KodakImagingPro_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
KodakImagingPro_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    MultiSzAppendA (&g_FilesBuff, S_KODAKIMG_FILE1);
    MultiSzAppendA (&g_FilesBuff, S_KODAKIMG_FILE2);

    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}

LONG
KodakImagingPro_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName = NULL;
    PCSTR fileName = NULL;
    PCSTR companyName = NULL;
    PCSTR productVer = NULL;
    LONG result = ERROR_NOT_INSTALLED;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    __try {
                        fileName = GetFileNameFromPathA (fullFileName);
                        if (StringIMatchA (fileName, S_KODAKIMG_FILE1)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_KKIMG_COMPANYNAME1, companyName))
                                ) {
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_KKIMG_PRODUCTVER1, productVer))
                                ) {
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_KKIMGPRO, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                        if (StringIMatchA (fileName, S_KODAKIMG_FILE2)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_KKIMG_COMPANYNAME2, companyName))
                                ) {
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_KKIMG_PRODUCTVER2, productVer))
                                ) {
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_KKIMGPRO, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                    __finally {
                        if (productVer) {
                            FreePathStringA (productVer);
                            productVer = NULL;
                        }
                        if (companyName) {
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (result == ERROR_NOT_INSTALLED) {
            DEBUGMSGA ((DBG_VERBOSE, "Kodak Imaging Pro migration DLL: Could not find needed files."));
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "Kodak Imaging Pro migration DLL: Could not open MIGRATE.INF."));
    }

    return result;
}

LONG
KodakImagingPro_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_NOT_INSTALLED;
}

LONG
KodakImagingPro_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    MEMDB_ENUMA e;
    CHAR pattern[MEMDB_MAX];

    // Handle all files from MEMDB_CATEGORY_KKIMGPRO

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_KKIMGPRO, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            // write this file to Handled
            if (!WritePrivateProfileStringA (S_HANDLED, e.szName, "FILE", g_MigrateInfPath)) {
                DEBUGMSGA ((DBG_ERROR, "Kodak Imaging Pro migration DLL: Could not write one or more handled files."));
            }
        } while (MemDbEnumNextValueA (&e));
    }

    return ERROR_NOT_INSTALLED;
}

LONG
KodakImagingPro_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    MYASSERT (FALSE);
    return ERROR_SUCCESS;
}

LONG
KodakImagingPro_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    MYASSERT (FALSE);
    return ERROR_SUCCESS;
}

LONG
KodakImagingPro_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    MYASSERT (FALSE);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\creatwr2.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    creatwr2.c

Abstract:

    This source file implements the operations needed to properly migrate Creative Writer 2.0 from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    07-Nov-1998

Revision History:


--*/


#include "pch.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_MS_WORDART_30         "HKCR\\CLSID\\{000212F0-0000-0000-C000-000000000046}\\AlternateLocalServer32"
#define S_WRDART_FILE1          "KIDART32.EXE"
#define S_WRDART_FILE2          "WRDART32.EXE"
#define S_WRDART_FILE3          "WORDART.EXE"
#define MEMDB_CATEGORY_FILE1    "CreativeWriter2\\File1"
#define MEMDB_CATEGORY_FILE2    "CreativeWriter2\\File2"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

BOOL
CreativeWriter2_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
CreativeWriter2_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
CreativeWriter2_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    __try {
        key = OpenRegKeyStrA (S_MS_WORDART_30);
        if (!key) {
            DEBUGMSGA ((DBG_VERBOSE, "Creative Writer 2 migration DLL will not run."));
            result = ERROR_NOT_INSTALLED;
            __leave;
        }
        fullFileName = GetRegValueStringA (key, "");
        if (!fullFileName) {
            DEBUGMSGA ((DBG_VERBOSE, "Creative Writer 2 migration DLL will not run."));
            result = ERROR_NOT_INSTALLED;
            __leave;
        }
        fileName = GetFileNameFromPathA (fullFileName);
        if (!StringIMatchA (fileName, S_WRDART_FILE1)) {
            DEBUGMSGA ((DBG_VERBOSE, "Creative Writer 2 migration DLL will not run."));
            result = ERROR_NOT_INSTALLED;
            __leave;
        }
        MultiSzAppendA (&g_FilesBuff, S_WRDART_FILE1);
        MultiSzAppendA (&g_FilesBuff, S_WRDART_FILE2);

        *ExeNamesBuf = g_FilesBuff.Buf;
    }
    __finally {
        if (fullFileName) {
            MemFree (g_hHeap, 0, fullFileName);
            fullFileName = NULL;
        }
        if (key) {
            CloseRegKey (key);
            key = NULL;
        }
    }

    return result;
}

LONG
CreativeWriter2_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName;
    PCSTR fileName;
    LONG result = ERROR_SUCCESS;
    BOOL set1 = FALSE;
    BOOL set2 = FALSE;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    fileName = GetFileNameFromPathA (fullFileName);
                    if (!set1 && StringIMatchA (fileName, S_WRDART_FILE1)) {
                        set1 = TRUE;
                        //
                        // this copy is safe. S_WRDART_FILE1 is longer than S_WRDART_FILE3
                        //
                        MYASSERT (ByteCount (S_WRDART_FILE1) >= ByteCount (S_WRDART_FILE3));

                        StringCopy ((PSTR)fileName, S_WRDART_FILE3);
                        MemDbSetValueExA (MEMDB_CATEGORY_FILE1, fullFileName, NULL, NULL, 0, NULL);
                    }
                    if (!set2 && StringIMatchA (fileName, S_WRDART_FILE2)) {
                        set2 = TRUE;
                        MemDbSetValueExA (MEMDB_CATEGORY_FILE2, fullFileName, NULL, NULL, 0, NULL);
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (!set1 || !set2) {
            DEBUGMSGA ((DBG_WARNING, "Creative Writer 2 migration DLL: Could not find needed files."));
            result = ERROR_NOT_INSTALLED;
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "Could not open MIGRATE.INF."));
        result = ERROR_NOT_INSTALLED;
    }

    return result;
}

LONG
CreativeWriter2_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
CreativeWriter2_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    return ERROR_SUCCESS;
}

LONG
CreativeWriter2_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    PCSTR file1 = NULL;
    PCSTR file2 = NULL;
    CHAR pattern[MEMDB_MAX];
    MEMDB_ENUMA e;
    LONG result = ERROR_SUCCESS;

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_FILE1, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!file1) {
                file1 = DuplicatePathStringA (e.szName, 0);
            }
        } while (MemDbEnumNextValueA (&e));
    }

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_FILE2, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!file2) {
                file2 = DuplicatePathStringA (e.szName, 0);
            }
        } while (MemDbEnumNextValueA (&e));
    }
    if (!file1 ||
        !file2 ||
        !DoesFileExist (file1) ||
        !DoesFileExist (file2)
        ) {
        DEBUGMSGA ((DBG_WARNING, "Creative Writer 2 migration DLL: Could not find needed files."));
        result = ERROR_NOT_INSTALLED;
    } else {
        CopyFileA (file2, file1, FALSE);
    }

    if (file1) {
        FreePathStringA (file1);
    }
    if (file2) {
        FreePathStringA (file2);
    }
    return result;
}

LONG
CreativeWriter2_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
CreativeWriter2_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\coreldr8.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    coreldr8.c

Abstract:

    This source file implements the operations needed to properly migrate
    CorelDRAW8 settings from Windows 9x to Windows NT. This is part of the
    Setup Migration DLL.

Author:

    Ovidiu Temereanca  (ovidiut)    02-Jun-1999

Revision History:


--*/


#include "pch.h"

#define S_GUID_COREL_MEDIA_FOLDERS_8    "{854AF161-1AE1-11D1-AB9B-00C0F00683EB}"

BOOL
CorelDRAW8_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
CorelDRAW8_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

LONG
CorelDRAW8_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY Key;
    LONG rc;

    rc = TrackedRegOpenKeyA (
            HKEY_CLASSES_ROOT,
            "CLSID\\" S_GUID_COREL_MEDIA_FOLDERS_8,
            &Key
            );

    if (rc != ERROR_SUCCESS) {
        return ERROR_NOT_INSTALLED;
    }

    CloseRegKey (Key);

    return ERROR_SUCCESS;
}


LONG
CorelDRAW8_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
CorelDRAW8_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}


LONG
CorelDRAW8_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    PCSTR Msg;
    PCSTR Group;

    //
    // Write a message to the report
    //
    Group = GetStringResourceA (MSG_PROGRAM_NOTES_CORELMEDIAFOLDERS8);
    Msg = GetStringResourceA (MSG_CORELMEDIAFOLDERS8_MESSAGE);

    if (!WritePrivateProfileStringA (
            S_INCOMPATIBLE_MSGS,
            Group,
            Msg,
            g_MigrateInfPath
            )) {
        DEBUGMSGA ((DBG_ERROR, "CorelDRAW8 migration DLL: Could not write incompatibility message."));
    }

    //
    // Mark the GUID as bad - once for Object section
    //
    if (!WritePrivateProfileStringA (
            Group,
            S_GUID_COREL_MEDIA_FOLDERS_8,
            "BADGUID",
            g_MigrateInfPath
            )) {
        DEBUGMSGA ((DBG_ERROR, "CorelDRAW8 migration DLL: Could not write bad GUIDS."));
    }

    //
    // Mark the GUID as bad - and second as Handled, even if it's not really handled
    //
    if (!WritePrivateProfileStringA (
            S_HANDLED,
            S_GUID_COREL_MEDIA_FOLDERS_8,
            "BADGUID",
            g_MigrateInfPath
            )) {
        DEBUGMSGA ((DBG_ERROR, "CorelDRAW8 migration DLL: Could not write bad GUIDS."));
    }

    FreeStringResourceA (Msg);
    FreeStringResourceA (Group);

    return ERROR_SUCCESS;
}

LONG
CorelDRAW8_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
CorelDRAW8_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
CorelDRAW8_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\migrate.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.c

Abstract:

    This source file implements the seven required functions for a
    Windows NT 5.0 migration DLL.  This main file calls each registered
    source file.

Author:

    Jim Schmidt     (jimschm) 02-Apr-1998

Revision History:


--*/


#include "pch.h"

VENDORINFO g_VendorInfo = {"", "", "", ""};
CHAR g_ProductId [MAX_PATH];
PCSTR g_MigrateInfPath = NULL;
HINF g_MigrateInf = INVALID_HANDLE_VALUE;
HANDLE g_hHeap;
HINSTANCE g_hInst;
POOLHANDLE g_GlobalPool;
HWND g_ParentWnd;
TCHAR g_DllDir[MAX_TCHAR_PATH];

#define D_DLLVERSION    1



/*++

Macro Expansion Lists Description:

  The following list represents all the entries that the migrations DLL calls within setup.
  We recommend that each separate item that is fixed using this migration DLL to be implemented
  in a separate source file. Each entry having the name XXX needs to implement this functions:
  XXX_QueryVersion
  XXX_Initialize9x
  XXX_MigrateUser9x
  XXX_MigrateSystem9x
  XXX_InitializeNT
  XXX_MigrateUserNT
  XXX_MigrateSystemNT

Line Syntax:

   DEFMAC(EntryName)

Arguments:

   EntryName  - This is the name that you give to a separate item implemented in this migration DLL.
                Each entry is very much like a complete migration DLL except for initializing routines.

Variables Generated From List:

   g_MigrationEntries

--*/

#define MIGRATION_DLL_ENTRIES       \
        DEFMAC(KodakImagingPro)     \
        DEFMAC(Office)              \
        DEFMAC(PhotoSuiteII)        \
        DEFMAC(CorelDRAW8)          \
        DEFMAC(WinMine)             \
        DEFMAC(SymantecWinFax)      \
        DEFMAC(ProgramAccess)       \

/*
        // It looks like this is not needed any more.
        // However, I will let this here just in case.

        DEFMAC(CreativeWriter2)     \

        // This is no longer needed either, desk.cpl supports themes
        DEFMAC(Plus95)              \
*/

//
// Implementation
//

typedef BOOL (ATTACH_PROTOTYPE) (HINSTANCE DllInstance);
typedef ATTACH_PROTOTYPE *PATTACH_PROTOTYPE;

typedef BOOL (DETACH_PROTOTYPE) (HINSTANCE DllInstance);
typedef DETACH_PROTOTYPE *PDETACH_PROTOTYPE;

typedef LONG (QUERYVERSION_PROTOTYPE) (PCSTR *ExeNamesBuf);
typedef QUERYVERSION_PROTOTYPE *PQUERYVERSION_PROTOTYPE;

typedef LONG (INITIALIZE9X_PROTOTYPE) (PCSTR WorkingDirectory, PCSTR SourceDirectories);
typedef INITIALIZE9X_PROTOTYPE *PINITIALIZE9X_PROTOTYPE;

typedef LONG (MIGRATEUSER9X_PROTOTYPE) (HWND ParentWnd, PCSTR UnattendFile, HKEY UserRegKey, PCSTR UserName);
typedef MIGRATEUSER9X_PROTOTYPE *PMIGRATEUSER9X_PROTOTYPE;

typedef LONG (MIGRATESYSTEM9X_PROTOTYPE) (HWND ParentWnd, PCSTR UnattendFile);
typedef MIGRATESYSTEM9X_PROTOTYPE *PMIGRATESYSTEM9X_PROTOTYPE;

typedef LONG (INITIALIZENT_PROTOTYPE) (PCWSTR WorkingDirectory, PCWSTR SourceDirectories);
typedef INITIALIZENT_PROTOTYPE *PINITIALIZENT_PROTOTYPE;

typedef LONG (MIGRATEUSERNT_PROTOTYPE) (HINF UnattendInfHandle, HKEY UserRegKey, PCWSTR UserName);
typedef MIGRATEUSERNT_PROTOTYPE *PMIGRATEUSERNT_PROTOTYPE;

typedef LONG (MIGRATESYSTEMNT_PROTOTYPE) (HINF UnattendInfHandle);
typedef MIGRATESYSTEMNT_PROTOTYPE *PMIGRATESYSTEMNT_PROTOTYPE;

typedef struct {
    PSTR Name;
    PATTACH_PROTOTYPE pAttach;
    PDETACH_PROTOTYPE pDetach;
    PQUERYVERSION_PROTOTYPE pQueryVersion;
    PINITIALIZE9X_PROTOTYPE pInitialize9x;
    PMIGRATEUSER9X_PROTOTYPE pMigrateUser9x;
    PMIGRATESYSTEM9X_PROTOTYPE pMigrateSystem9x;
    PINITIALIZENT_PROTOTYPE pInitializeNT;
    PMIGRATEUSERNT_PROTOTYPE pMigrateUserNT;
    PMIGRATESYSTEMNT_PROTOTYPE pMigrateSystemNT;
    DWORD Active;
    DWORD WantToRunOnNt;
} MIGRATION_ENTRY, *PMIGRATION_ENTRY;

#define DEFMAC(fn)  ATTACH_PROTOTYPE fn##_Attach;                   \
                    DETACH_PROTOTYPE fn##_Detach;                   \
                    QUERYVERSION_PROTOTYPE fn##_QueryVersion;       \
                    INITIALIZE9X_PROTOTYPE fn##_Initialize9x;       \
                    MIGRATEUSER9X_PROTOTYPE fn##_MigrateUser9x;     \
                    MIGRATESYSTEM9X_PROTOTYPE fn##_MigrateSystem9x; \
                    INITIALIZENT_PROTOTYPE fn##_InitializeNT;       \
                    MIGRATEUSERNT_PROTOTYPE fn##_MigrateUserNT;     \
                    MIGRATESYSTEMNT_PROTOTYPE fn##_MigrateSystemNT;
MIGRATION_DLL_ENTRIES
#undef DEFMAC

#define DEFMAC(fn) {#fn,                    \
                    fn##_Attach,            \
                    fn##_Detach,            \
                    fn##_QueryVersion,      \
                    fn##_Initialize9x,      \
                    fn##_MigrateUser9x,     \
                    fn##_MigrateSystem9x,   \
                    fn##_InitializeNT,      \
                    fn##_MigrateUserNT,     \
                    fn##_MigrateSystemNT,   \
                    1,                      \
                    0                       \
                    },

static MIGRATION_ENTRY g_MigrationEntries[] = {
                            MIGRATION_DLL_ENTRIES
                            {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0}
                            };
#undef DEFMAC

#define MEMDB_CATEGORY_DLLENTRIES       "MigDllEntries"
#define S_ACTIVE                        "Active"
#define DBG_MIGDLL                      "SMIGDLL"

GROWBUFFER g_FilesBuff = GROWBUF_INIT;
PCSTR g_WorkingDir = NULL;

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
INITROUTINE_PROTOTYPE MemDb_Entry;

BOOL
WINAPI
DllMain (
    IN      HINSTANCE DllInstance,
    IN      ULONG  ReasonForCall,
    IN      LPVOID Reserved
    )
{
    PSTR p;
    PMIGRATION_ENTRY m;
    BOOL entryResult;
    BOOL result = TRUE;

    switch (ReasonForCall)  {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
        //
        DisableThreadLibraryCalls (DllInstance);

        //
        // Global init
        //
        g_hHeap = GetProcessHeap();
        g_hInst = DllInstance;

        //
        // Init common controls
        //
        InitCommonControls();

        //
        // Get DLL path and strip directory
        //
        GetModuleFileNameA (DllInstance, g_DllDir, MAX_TCHAR_PATH);
        p = _mbsrchr (g_DllDir, '\\');
        MYASSERT (p);
        if (p) {
            *p = 0;
        }

        if (!MigUtil_Entry (DllInstance, DLL_PROCESS_ATTACH, NULL)) {
            return FALSE;
        }

        LogReInit (NULL, NULL);

        if (!MemDb_Entry (DllInstance, DLL_PROCESS_ATTACH, NULL)) {
            return FALSE;
        }

        //
        // Allocate a global pool
        //
        g_GlobalPool = PoolMemInitNamedPool ("Global Pool");

        m = g_MigrationEntries;
        while (m->pAttach) {

            DEBUGMSGA ((DBG_MIGDLL, "Attach calling: %s", m->Name));

            entryResult = m->pAttach (DllInstance);

            if (!entryResult) {
                DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Attach: Migration entry %s returned FALSE", m->Name));
                result = entryResult;
                break;
            }

            m++;
        }

        break;

    case DLL_PROCESS_DETACH:

        if (g_MigrateInfPath) {
            FreePathStringA (g_MigrateInfPath);
            g_MigrateInfPath = NULL;
        }

        if (g_MigrateInf != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (g_MigrateInf);
            g_MigrateInf = INVALID_HANDLE_VALUE;
        }

        //
        // Free standard pools
        //
        if (g_GlobalPool) {
            PoolMemDestroyPool (g_GlobalPool);
            g_GlobalPool = NULL;
        }

        FreeGrowBuffer (&g_FilesBuff);

        m = g_MigrationEntries;

        while (m->pDetach) {

            DEBUGMSGA ((DBG_MIGDLL, "Detach calling: %s", m->Name));

            entryResult = m->pDetach (DllInstance);

            if (!entryResult) {
                DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Detach: Migration entry %s returned FALSE", m->Name));
                result = entryResult;
                break;
            }

            m++;
        }

        MemDb_Entry (DllInstance, DLL_PROCESS_DETACH, NULL);

        MigUtil_Entry (DllInstance, DLL_PROCESS_DETACH, NULL);

        break;
    }

    return result;
}

LONG
CALLBACK
QueryVersion (
    OUT     PCSTR *ProductID,
    OUT     PUINT DllVersion,
    OUT     PINT *CodePageArray,       OPTIONAL
    OUT     PCSTR *ExeNamesBuf,        OPTIONAL
    OUT     PVENDORINFO *VendorInfo
    )
{
    PMIGRATION_ENTRY m;
    PCSTR entryExeNamesBuf;
    MULTISZ_ENUM entryEnum;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;
    PCSTR tempStr;

    //
    // Fill the data.
    //
    tempStr = GetStringResourceA (MSG_PRODUCT_ID);
    if (tempStr) {
        StringCopyByteCountA (g_ProductId, tempStr, MAX_PATH);
        FreeStringResourceA (tempStr);
    }

    *ProductID  = g_ProductId;
    *DllVersion = D_DLLVERSION;
    *CodePageArray = NULL;
    *VendorInfo = &g_VendorInfo;

    // now get the VendorInfo data from resources
    tempStr = GetStringResourceA (MSG_VI_COMPANY_NAME);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.CompanyName, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_NUMBER);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportNumber, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_URL);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportUrl, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_INSTRUCTIONS);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.InstructionsToUser, tempStr, 1024);
        FreeStringResourceA (tempStr);
    }

    //
    // Query each entry.
    //
    m = g_MigrationEntries;
    while (m->pQueryVersion) {

        DEBUGMSGA ((DBG_MIGDLL, "QueryVersion calling: %s", m->Name));

        entryExeNamesBuf = NULL;
        entryResult = m->pQueryVersion (&entryExeNamesBuf);

        if (entryResult == ERROR_SUCCESS) {

            //
            // Put the files that this entry needs in grow buffer.
            //
            if (EnumFirstMultiSzA (&entryEnum, entryExeNamesBuf)) {
                do {

                    MultiSzAppendA (&g_FilesBuff, entryEnum.CurrentString);

                } while (EnumNextMultiSzA (&entryEnum));
            }

            //
            // result is now ERROR_SUCCESS so QueryVersion will return this.
            //
            result = ERROR_SUCCESS;

        } else if (entryResult != ERROR_NOT_INSTALLED) {

            DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-QueryVersion: Migration entry %s reported error: %d", m->Name, entryResult));
        }
        m++;
    }
    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}


LONG
CALLBACK
Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    PCSTR entryExeNamesBuf;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    g_WorkingDir = DuplicatePathString (WorkingDirectory, 0);

    g_MigrateInfPath = JoinPathsA (WorkingDirectory, S_MIGRATE_INF);
    g_MigrateInf = InfOpenInfFileA (g_MigrateInfPath);

    //
    // We were unloaded so all the data about if an entry is active or not would have gone away. We need
    // to query each entry again.
    //
    m = g_MigrationEntries;
    while (m->pQueryVersion) {

        DEBUGMSGA ((DBG_MIGDLL, "QueryVersion calling: %s", m->Name));

        entryExeNamesBuf = NULL;
        entryResult = m->pQueryVersion (&entryExeNamesBuf);

        if (entryResult != ERROR_SUCCESS) {

            if (entryResult != ERROR_NOT_INSTALLED) {
                DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-QueryVersion: Migration entry %s reported error: %d", m->Name, entryResult));
            }
            m->Active = FALSE;
        }
        m++;
    }

    //
    // Now is the time to call Initialize9x for each active entry
    //
    m = g_MigrationEntries;
    while (m->pInitialize9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "Initialize9x calling: %s", m->Name));

            entryResult = m->pInitialize9x (WorkingDirectory, SourceDirectories);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Initialize9x: Migration entry %s reported error: %d", m->Name, entryResult));
                }
                m->Active = FALSE;
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}


LONG
CALLBACK
MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    g_ParentWnd = ParentWnd;
    LogReInit (&g_ParentWnd, NULL);

    //
    // Call MigrateUser9x for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateUser9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateUser9x calling: %s", m->Name));

            entryResult = m->pMigrateUser9x (ParentWnd, UnattendFile, UserRegKey, UserName);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateUser9x: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
                m->WantToRunOnNt = 1;
            }
        }
        m++;
    }

    return result;
}


LONG
CALLBACK
MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;
    PCSTR savePath;
    CHAR key[MEMDB_MAX];

    g_ParentWnd = ParentWnd;
    LogReInit (&g_ParentWnd, NULL);

    //
    // Call MigrateSystem9x for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateSystem9x calling: %s", m->Name));

            entryResult = m->pMigrateSystem9x (ParentWnd, UnattendFile);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateSystem9x: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
                m->WantToRunOnNt = 1;
            }
        }
        m++;
    }

    //
    // This was the last function on 9x side. Let's put all the data in MemDb
    // and save it for NT side.
    //
    m = g_MigrationEntries;
    while (m->Name) {
        MemDbBuildKeyA (key, MEMDB_CATEGORY_DLLENTRIES, m->Name, S_ACTIVE, NULL);
        MemDbSetValueA (key, m->WantToRunOnNt);
        m++;
    }

    //
    // Now save MemDb content.
    //
    MYASSERT (g_WorkingDir);
    savePath = JoinPathsA (g_WorkingDir, "SETUPDLL.DAT");
    if (!MemDbSaveA (savePath)) {
        DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Could not save MemDb content to %s.", savePath));
    }
    FreePathStringA (savePath);

    FreePathString (g_WorkingDir);
    g_WorkingDir = NULL;

    return result;
}


LONG
CALLBACK
InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;
    PCWSTR loadPath;
    CHAR key[MEMDB_MAX];

    //
    // This is the first function on NT side. Let's load MemDb content.
    //
    loadPath = JoinPathsW (WorkingDirectory, L"SETUPDLL.DAT");
    if (!MemDbLoadW (loadPath)) {
        DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Could not load MemDb content."));
    }
    FreePathStringW (loadPath);

    //
    // Let's get the data that we stored in MemDb
    //
    m = g_MigrationEntries;
    while (m->Name) {
        MemDbBuildKeyA (key, MEMDB_CATEGORY_DLLENTRIES, m->Name, S_ACTIVE, NULL);
        MemDbGetValueA (key, &m->Active);
        m++;
    }

    //
    // Now call InitializeNT for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "InitializeNT calling: %s", m->Name));

            entryResult = m->pInitializeNT (WorkingDirectory, SourceDirectories);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-InitializeNT: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}



LONG
CALLBACK
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    //
    // Call MigrateUserNT for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateUserNT calling: %s", m->Name));

            entryResult = m->pMigrateUserNT (UnattendInfHandle, UserRegKey, UserName);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateUserNT: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}


LONG
CALLBACK
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    //
    // Call MigrateSystemNT for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateSystemNT calling: %s", m->Name));

            entryResult = m->pMigrateSystemNT (UnattendInfHandle);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateSystemNT: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}


BOOL
IsExcludedPath (
    PCSTR Path
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR ExcludedPath;
    BOOL b = FALSE;

    if (InfFindFirstLineA (g_MigrateInf, "Excluded Paths", NULL, &context)) {
        do {
            ExcludedPath = InfGetStringField (&context, 1);

            if (ExcludedPath) {
                if (StringIMatchByteCount (ExcludedPath, Path, ByteCount (ExcludedPath))) {
                    b = TRUE;
                    break;
                }
            }
        } while (InfFindNextLine (&context));
    }

    InfCleanUpInfStruct (&context);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\photosii.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    photosII.c

Abstract:

    This source file implements the operations needed to properly migrate MGI PhotoSuite II 1.0 from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    15-Jul-1999

Revision History:


--*/


#include "pch.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_PHOTOSII_FILE1        "PhotoSuite.EXE"
#define S_PHOTOSII_FILE2        "W_Welcome.html"
#define S_PHOTOSII_RELPATH1     "\\TempPSII\\Common\\"
#define S_PHOTOSII_RELPATH2     "\\TempPSII\\Photos\\"
#define MEMDB_CATEGORY_PHOTOSII "PhotoSuiteII"
#define S_COMPANYNAME           "CompanyName"
#define S_PRODUCTVER            "ProductVersion"
#define S_PHOTOSII_COMPANYNAME  "MGI Software*"
#define S_PHOTOSII_PRODUCTVER   "1.0*"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

BOOL
PhotoSuiteII_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
PhotoSuiteII_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
PhotoSuiteII_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    MultiSzAppendA (&g_FilesBuff, S_PHOTOSII_FILE1);

    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}

LONG
PhotoSuiteII_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName = NULL;
    PCSTR fileName = NULL;
    PCSTR companyName = NULL;
    PCSTR productVer = NULL;
    LONG result = ERROR_NOT_INSTALLED;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    __try {
                        fileName = GetFileNameFromPathA (fullFileName);
                        if (StringIMatchA (fileName, S_PHOTOSII_FILE1)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_PHOTOSII_COMPANYNAME, companyName))
                                ) {
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_PHOTOSII_PRODUCTVER, productVer))
                                ) {
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_PHOTOSII, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                    __finally {
                        if (productVer) {
                            FreePathStringA (productVer);
                            productVer = NULL;
                        }
                        if (companyName) {
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (result == ERROR_NOT_INSTALLED) {
            DEBUGMSGA ((DBG_VERBOSE, "MGI PhotoSuite II migration DLL: Could not find needed files."));
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "MGI PhotoSuite II migration DLL: Could not open MIGRATE.INF."));
    }

    return result;
}

LONG
PhotoSuiteII_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    MEMDB_ENUMA e;
    CHAR pattern[MEMDB_MAX];
    CHAR file1[MEMDB_MAX];
    CHAR file2[MEMDB_MAX];
    PSTR filePtr;

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_PHOTOSII, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            //
            // we want to copy a file that is relative to this one
            //
            filePtr = _mbsrchr (e.szName, '\\');
            if (filePtr) {
                StringCopyABA (file1, e.szName, filePtr);
            } else {
                StringCopyA (file1, e.szName);
            }
            StringCopyA (file2, file1);
            StringCatA (file1, S_PHOTOSII_RELPATH1);
            StringCatA (file2, S_PHOTOSII_RELPATH2);
            StringCatA (file1, S_PHOTOSII_FILE2);
            StringCatA (file2, S_PHOTOSII_FILE2);

            if (!CopyFile (file1, file2, TRUE)) {
                DEBUGMSGA ((
                    DBG_ERROR,
                    "MGI PhotoSuite II migration DLL: Could not copy %s to %s. Error:%d",
                    file1,
                    file2,
                    GetLastError ()
                    ));
            }

        } while (MemDbEnumNextValueA (&e));
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\office.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    office.c

Abstract:

    This source file implements the operations needed to properly migrate
    Office settings from Windows 9x to Windows NT. This is part of the
    Setup Migration DLL.

Author:

    Jim Schmidt  (jimschm)    07-Apr-1999

Revision History:


--*/


#include "pch.h"

#define S_WINWORD6_INI          "WINWORD6.INI"
#define S_WORD6_INI             "WORD6.INI"
#define S_EXCEL5_INI            "EXCEL5.INI"
#define S_WINWORD6_SECTION      "Microsoft Word"
#define S_EXCEL5_SECTION        "Microsoft Excel"
#define S_WINWORD6_KEY          "CBT-PATH"
#define S_EXCEL5_KEY            "CBTLOCATION"
#define S_NO_CBT                "<<NOCBT>>"

BOOL
Office_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
Office_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

LONG
Office_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (GetWindowsDirectoryA (Path, MAX_PATH)) {

        p = AppendWackA (Path);

        StringCopyA (p, S_WINWORD6_INI);
        if (DoesFileExistA (Path)) {
            return ERROR_SUCCESS;
        }

        StringCopyA (p, S_WORD6_INI);
        if (DoesFileExistA (Path)) {
            return ERROR_SUCCESS;
        }

        StringCopyA (p, S_EXCEL5_INI);
        if (DoesFileExistA (Path)) {
            return ERROR_SUCCESS;
        }
    }

    return ERROR_NOT_INSTALLED;
}


LONG
Office_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    PCSTR Msg;
    PCSTR Group;
    CHAR Path[MAX_PATH];
    PSTR p;

    //
    // Write a message to the report
    //

    Group = GetStringResource (MSG_PROGRAM_NOTES);
    Msg = GetStringResource (MSG_OFFICE_MESSAGE);

    WritePrivateProfileStringA (
        S_INCOMPATIBLE_MSGS,
        Group,
        Msg,
        g_MigrateInfPath
        );

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINWORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (
            Group,
            Path,
            "FILE",
            g_MigrateInfPath
            );
    }

    StringCopyA (p, S_WORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (
            Group,
            Path,
            "FILE",
            g_MigrateInfPath
            );
    }

    StringCopyA (p, S_EXCEL5_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (
            Group,
            Path,
            "FILE",
            g_MigrateInfPath
            );
    }

    FreeStringResource (Msg);
    FreeStringResource (Group);

    return ERROR_SUCCESS;
}

LONG
Office_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (S_WINWORD6_SECTION, S_WINWORD6_KEY, S_NO_CBT, Path);
    }

    StringCopyA (p, S_WINWORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (S_WINWORD6_SECTION, S_WINWORD6_KEY, S_NO_CBT, Path);
    }

    StringCopyA (p, S_EXCEL5_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (S_EXCEL5_SECTION, S_EXCEL5_KEY, S_NO_CBT, Path);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\winfax.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    winfax.c

Abstract:

    This source file implements the operations needed to properly migrate
    Symantec WinFax Starter Edition (shipped as a value-add component to
    Outlook 2000). In particular, this migration dll is designed to get rid of the
    incompatiblity message reported by the printer migration dll and clean up
    some registry settings.

Author:

    Marc R. Whitten (marcw) 14-Jul-1999

Revision History:


--*/


#include "pch.h"


#define S_WINFAX_STARTER_REGKEYA "HKLM\\System\\CurrentControlSet\\Control\\Print\\Printers\\Symantec WinFax Starter Edition"


PSTR g_HandleArray[] = {

    "HKLM\\Software\\Microsoft\\Office\\8.0\\Outlook\\OLFax",
    "HKLM\\Software\\Microsoft\\Office\\9.0\\Outlook\\OLFax",
    "HKLM\\Software\\Microsoft\\Active Setup\\Outlook Uninstall\\OMF95",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\OLFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\OLFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\Setup\\[WinFaxWizard]",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\Setup\\[WinFaxWizard]",
    ""

    };




BOOL
SymantecWinFax_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
SymantecWinFax_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

LONG
SymantecWinFax_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY h;

    h = OpenRegKeyStrA ("HKLM\\Software\\Microsoft\\Active Setup\\Outlook Uninstall\\OMF95");

    if (!h) {
        return ERROR_NOT_INSTALLED;
    }

    CloseRegKey (h);





    return ERROR_SUCCESS;
}


LONG
SymantecWinFax_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
SymantecWinFax_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}


LONG
SymantecWinFax_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{

    HKEY h;
    PSTR *p;


    //
    // Handle the registry key so that the printer migration dll doesn't report it as incompatible.
    //
    WritePrivateProfileStringA (
        S_HANDLED,
        S_WINFAX_STARTER_REGKEYA,
        "Registry",
        g_MigrateInfPath
        );

    //
    // Handle other registry keys so that the reinstall will actually work.
    //

    for (p = g_HandleArray; **p; p++) {

        h = OpenRegKeyStrA (*p);
        if (h) {

            WritePrivateProfileStringA (
                S_HANDLED,
                *p,
                "Registry",
                g_MigrateInfPath
                );

            CloseRegKey (h);
        }
    }


    return ERROR_SUCCESS;
}


//
// Nothing to do during GUI mode.
//
LONG
SymantecWinFax_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
SymantecWinFax_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
SymantecWinFax_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\plus95.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    plus95.c

Abstract:

    This source file implements the operations needed to properly migrate Plus!95 from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    15-Mar-1999

Revision History:


--*/


#include "pch.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_PLUS95_FILE           "JPEGIM32.FLT"
#define MEMDB_CATEGORY_PLUS95A  "Plus95"
#define MEMDB_CATEGORY_PLUS95W  L"Plus95"
#define S_COMPANYNAME           "CompanyName"
#define S_PRODUCTVER            "ProductVersion"
#define S_PLUS95_COMPANYNAME1   "Microsoft*"
#define S_PLUS95_PRODUCTVER1    "6.*"
#define S_PLUS95_FILEW          L"JPEGIM32.FLT"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

BOOL
Plus95_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
Plus95_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
Plus95_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    MultiSzAppendA (&g_FilesBuff, S_PLUS95_FILE);

    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}

LONG
Plus95_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName = NULL;
    PCSTR fileName = NULL;
    PCSTR companyName = NULL;
    PCSTR productVer = NULL;
    LONG result = ERROR_NOT_INSTALLED;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    __try {
                        fileName = GetFileNameFromPathA (fullFileName);
                        if (StringIMatchA (fileName, S_PLUS95_FILE)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_PLUS95_COMPANYNAME1, companyName))
                                ) {
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_PLUS95_PRODUCTVER1, productVer))
                                ) {
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_PLUS95A, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                    __finally {
                        if (productVer) {
                            FreePathStringA (productVer);
                            productVer = NULL;
                        }
                        if (companyName) {
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (result == ERROR_NOT_INSTALLED) {
            DEBUGMSGA ((DBG_VERBOSE, "Plus!95 migration DLL: Could not find needed files."));
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "Plus!95 migration DLL: Could not open MIGRATE.INF."));
    }

    return result;
}

LONG
Plus95_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_NOT_INSTALLED;
}

LONG
Plus95_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    MEMDB_ENUMA e;
    CHAR pattern[MEMDB_MAX];

    // Handle all files from MEMDB_CATEGORY_PLUS95

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_PLUS95A, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            // write this file to Handled
            if (!WritePrivateProfileStringA (S_HANDLED, e.szName, "FILE", g_MigrateInfPath)) {
                DEBUGMSGA ((DBG_ERROR, "Plus!95 migration DLL: Could not write one or more handled files."));
            }
        } while (MemDbEnumNextValueA (&e));
    }

    return ERROR_SUCCESS;
}

LONG
Plus95_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    PWSTR DllLocation;
    MEMDB_ENUMW e;
    WCHAR pattern[MEMDB_MAX];

    DllLocation = JoinPathsW (WorkingDirectory, S_PLUS95_FILEW);
    if (!DoesFileExistW (DllLocation)) {
        FreePathStringW (DllLocation);
        DEBUGMSG ((DBG_ERROR, "Plus!95 migration DLL: Could not find required file."));
        return ERROR_SUCCESS;
    }

    // replace all files from MEMDB_CATEGORY_PLUS95

    MemDbBuildKeyW (pattern, MEMDB_CATEGORY_PLUS95W, L"*", NULL, NULL);
    if (MemDbEnumFirstValueW (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!CopyFileW (DllLocation, e.szName, FALSE)) {
                DEBUGMSGW ((DBG_ERROR, "Plus!95 migration DLL: Could not replace one or more handled files."));
            }
        } while (MemDbEnumNextValueW (&e));
    }
    return ERROR_SUCCESS;
}

LONG
Plus95_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
Plus95_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\progacc.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    progacc.c

Abstract:

    This source file implements the operations needed to properly migrate
    program access settings for OE access.

Author:

    Tim Noonan  (tnoonan)    17-Jul-2002

Revision History:


--*/


#include "pch.h"

#define S_OE_FILE           "MSIMN.EXE"
#define S_MAIL_KEY          "HKLM\\Software\\Clients\\Mail"
#define S_OUTLOOK_EXPRESS   "Outlook Express"
#define S_IMN               "Internet Mail and News"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

BOOL
ProgramAccess_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
ProgramAccess_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer(&g_FilesBuff);
    return TRUE;
}

LONG
ProgramAccess_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    MultiSzAppendA (&g_FilesBuff, S_OE_FILE);

    *ExeNamesBuf = g_FilesBuff.Buf;
    return ERROR_SUCCESS;
}


LONG
ProgramAccess_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
ProgramAccess_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
ProgramAccess_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    CHAR OEAccess[MAX_PATH];

    DWORD cch = GetPrivateProfileStringA("Components",
                                         "OEAccess",
                                         "",
                                         OEAccess,
                                         ARRAYSIZE(OEAccess), 
                                         UnattendFile);

    if ((cch > 0) && StringIMatchA(OEAccess, "off"))
    {       
        HKEY key;

        DEBUGMSGA((DBG_VERBOSE, "ProgramAccess: OEAccess is off."));

        key = OpenRegKeyStrA(S_MAIL_KEY);

        if (NULL != key)
        {
            PCTSTR currentClient = GetRegValueStringA(key, "");

            if (NULL != currentClient)
            {
                if (StringIMatchA(currentClient, S_OUTLOOK_EXPRESS) ||
                    StringIMatchA(currentClient, S_IMN))
                {
                    DEBUGMSGA((DBG_VERBOSE, "ProgramAccess: OE was the default client and we are marking the key as handled."));

                    WritePrivateProfileStringA(S_HANDLED,
                                               S_MAIL_KEY,
                                               "Registry",
                                               g_MigrateInfPath);
                }
                else
                {
                    DEBUGMSGA ((DBG_VERBOSE, "ProgramAccess: OE was not the default client."));
                }

                MemFree(g_hHeap, 0, currentClient);
            }
            else
            {
                DEBUGMSGA ((DBG_VERBOSE, "ProgramAccess: Error getting current client or no default client."));
            }

            CloseRegKey(key);

        }
        else
        {
            DEBUGMSGA ((DBG_VERBOSE, "ProgramAccess: Error opening " S_MAIL_KEY "."));
        }
    }
    else
    {
        DEBUGMSGA ((DBG_VERBOSE, "ProgramAccess: OEAccess is on -- not messing with default client."));
    }
    
    return ERROR_SUCCESS;
}

LONG
ProgramAccess_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
ProgramAccess_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
ProgramAccess_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\test\pch.h ===
//#define STRICT
//#define WIN32_LEAN_AND_MEAN
#define _MBCS
#include <windows.h>
#include <setupapi.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <mbstring.h>
#include <tchar.h>

#pragma warning(4:4100)     // Lower serverity of "unreferenced formal parameter"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\setup\winmine.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    winmine.c

Abstract:

    This source file implements the operations needed to properly migrate
    Minesweeper settings from Windows 9x to Windows NT. This is part of the
    Setup Migration DLL.

Author:

    Ovidiu Temereanca  (ovidiut)    07-Jul-1999

Revision History:


--*/


#include "pch.h"

#define S_WINMINE_INI          "WINMINE.INI"
#define S_ALREADYPLAYED        "AlreadyPlayed"
#define S_WINMINE              "Software\\Microsoft\\winmine"


BOOL
WinMine_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}


BOOL
WinMine_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}


LONG
WinMine_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINMINE_INI);
    if (DoesFileExistA (Path)) {
        return ERROR_SUCCESS;
    }

    return ERROR_NOT_INSTALLED;
}


LONG
WinMine_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
WinMine_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}


LONG
WinMine_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINMINE_INI);
    //
    // write this file to Handled
    //
    if (!WritePrivateProfileStringA (S_HANDLED, Path, "FILE", g_MigrateInfPath)) {
        DEBUGMSGA ((DBG_ERROR, "WinMine migration DLL: Could not write winmine.ini as handled."));
    }
    return ERROR_SUCCESS;
}


BOOL
pGetUINT (
    IN      PCSTR Value,
    OUT     PUINT ui
    )
{
    INT i = 0;
    CHAR ch;

    if (!Value || !*Value) {
        return FALSE;
    }

    while((ch = (CHAR)_mbsnextc (Value)) != 0) {
        if (ch < '0' || ch > '9') {
            return FALSE;
        }
        i = i * 10 + ch - '0';
        if (i < 0) {
            return FALSE;
        }
        Value = _mbsinc (Value);
    }

    *ui = i;

    return TRUE;
}


LONG
WinMine_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
WinMine_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    HKEY Key;
    LONG rc = ERROR_SUCCESS;
    DWORD Value = 1;
    CHAR Path[MAX_PATH];
    CHAR SectBuffer[MAX_PATH];
    CHAR KeyBuffer[MAX_PATH];
    CHAR String[MAX_PATH];
    PSTR p;
    UINT ui;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINMINE_INI);
    if (!DoesFileExistA (Path)) {
        DEBUGMSGA ((DBG_ERROR, "Could not find %s", Path));
        return ERROR_FILE_NOT_FOUND;
    }

    rc = TrackedRegCreateKeyA (
            UserRegKey,
            S_WINMINE,
            &Key
            );

    if (rc != ERROR_SUCCESS) {
        DEBUGMSGA ((DBG_ERROR, "Could not create user key %s", S_WINMINE));
        return rc;
    }

    rc = RegSetValueExA (
            Key,
            S_ALREADYPLAYED,
            0,
            REG_DWORD,
            (PCBYTE)&Value,
            sizeof (Value)
            );

    if (rc == ERROR_SUCCESS) {

        Value = GetPrivateProfileStringA (NULL, NULL, "", SectBuffer, sizeof (SectBuffer), Path);
        if (Value > 0 && Value < sizeof (SectBuffer) - 2) {
            //
            // there should be only one section
            //
            if (*(SectBuffer + SizeOfStringA (SectBuffer)) == 0) {
                //
                // get all keys with numeric values and put them in the registry
                // as REG_DWORD; the rest of them migrate as text
                //
                Value = GetPrivateProfileStringA (
                            SectBuffer,
                            NULL,
                            "",
                            KeyBuffer,
                            sizeof (KeyBuffer),
                            Path
                            );
                if (Value > 0 && Value < sizeof (KeyBuffer) - 1) {
                    p = KeyBuffer;
                    while (rc == ERROR_SUCCESS && *p) {
                        Value = GetPrivateProfileStringA (
                                    SectBuffer,
                                    p,
                                    "",
                                    String,
                                    sizeof (String),
                                    Path
                                    );
                        if (Value > 0) {
                            if (pGetUINT (String, &ui)) {
                                MYASSERT (sizeof (ui) == sizeof (DWORD));
                                rc = RegSetValueExA (
                                        Key,
                                        p,
                                        0,
                                        REG_DWORD,
                                        (PCBYTE)&ui,
                                        sizeof (ui)
                                        );
                                if (rc == ERROR_SUCCESS) {
                                    DEBUGMSGA ((DBG_VERBOSE, "Migrated value %s=%lu", p, ui));
                                } else {
                                    DEBUGMSGA ((DBG_ERROR, "Couldn't migrate value %s", p));
                                }
                            } else {
                                rc = RegSetValueExA (
                                        Key,
                                        p,
                                        0,
                                        REG_SZ,
                                        (PCBYTE)String,
                                        Value + 1
                                        );
                                if (rc == ERROR_SUCCESS) {
                                    DEBUGMSGA ((DBG_VERBOSE, "Migrated value %s=%s", p, String));
                                } else {
                                    DEBUGMSGA ((DBG_ERROR, "Couldn't migrate value %s", p));
                                }
                            }
                        }
                        p += SizeOfStringA (p);
                    }
                }
            }
            ELSE_DEBUGMSGA ((DBG_WARNING, "Found multiple sections in winmine.ini"));
        }
    }
    ELSE_DEBUGMSGA ((DBG_ERROR, "Could not create Value %s", S_ALREADYPLAYED));

    CloseRegKey (Key);

    return rc;
}


LONG
WinMine_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDD_ARGS_DLG                    101
#define IDC_EDIT1                       1001
#define IDC_PRODUCT_ID                  1001
#define IDC_EDIT2                       1002
#define IDC_VERSION                     1002
#define IDC_EDIT3                       1003
#define IDC_CODE_PAGES                  1003
#define IDC_EDIT4                       1004
#define IDC_FILES                       1004
#define IDC_BARF_QV                     1005
#define IDC_BARF_INIT9X                 1006
#define IDC_BARF_USER9X                 1007
#define IDC_BARF_SYSTEM9X               1008
#define IDC_BARF_INITNT                 1009
#define IDC_BARF_USERNT                 1010
#define IDC_BARF_SYSTEMNT               1011
#define IDC_COMPANY                     1012
#define IDC_PHONE                       1013
#define IDC_URL                         1014
#define IDC_INSTRUCTIONS                1015
#define IDC_MIGRATE_INF                 1016
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migpwd\pch.h ===
#define MIGISOL_INCLUDES
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migdlls\test\test.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    test.c

Abstract:

    This source file implements the seven required functions for a
    Windows NT 5.0 migration DLL.  It is used to perform various tests.

Author:

    Jim Schmidt     (jimschm) 02-Apr-1998

Revision History:


--*/


#include "pch.h"
#include "resource.h"


HANDLE g_hHeap;
HINSTANCE g_hInst;

typedef struct {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

#define SIGNATURE       0x01010102


BOOL
WINAPI
DllMain (
    IN      HINSTANCE DllInstance,
    IN      ULONG  ReasonForCall,
    IN      LPVOID Reserved
    )
{
    switch (ReasonForCall)  {

    case DLL_PROCESS_ATTACH:
        //
        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
        //
        DisableThreadLibraryCalls (DllInstance);

        //
        // Global init
        //
        g_hHeap = GetProcessHeap();
        g_hInst = DllInstance;

        // Open log; FALSE means do not delete existing log
        SetupOpenLog (FALSE);
        break;

    case DLL_PROCESS_DETACH:

        SetupCloseLog();

        break;
    }

    return TRUE;
}


VOID
Barf (
    VOID
    )
{
    PBYTE p;

    p = (PBYTE) 2;
    *p = 0;
    MessageBox (NULL, "Feeling too well to barf", NULL, MB_OK);
}


typedef struct {
    DWORD Signature;
    CHAR ProductId[256];
    UINT DllVersion;
    INT CodePageArray[256];
    CHAR FileNameMultiSz[4096];
    BOOL BarfInQueryVersion;
    BOOL BarfInInit9x;
    BOOL BarfInUser9x;
    BOOL BarfInSystem9x;
    BOOL BarfInInitNt;
    BOOL BarfInUserNt;
    BOOL BarfInSystemNt;
    CHAR MigrateInf[16384];
    VENDORINFO vi;
} SETTINGS, *PSETTINGS;

SETTINGS g_Settings;


VOID
pSaveSettings (
    BOOL Defaults
    )
{
    HANDLE File;
    DWORD DontCare;

    if (Defaults) {
        File = CreateFile ("c:\\settings.dat", GENERIC_WRITE, 0, NULL,
                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    } else {
        File = CreateFile ("settings.dat", GENERIC_WRITE, 0, NULL,
                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (File != INVALID_HANDLE_VALUE) {
        WriteFile (File, &g_Settings, sizeof (g_Settings), &DontCare, NULL);
        CloseHandle (File);
    } else {
        MessageBox (NULL, "Unable to save settings to media dir", NULL, MB_OK|MB_TOPMOST);
    }
}

VOID
pLoadSettings (
    BOOL Defaults
    )
{
    HANDLE File;
    DWORD DontCare;

    if (Defaults) {
        File = CreateFile ("c:\\settings.dat", GENERIC_READ, 0, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    } else {
        File = CreateFile ("settings.dat", GENERIC_READ, 0, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (File != INVALID_HANDLE_VALUE) {
        ReadFile (File, &g_Settings, sizeof (g_Settings), &DontCare, NULL);
        CloseHandle (File);

        if (g_Settings.Signature != SIGNATURE) {
            MessageBox (NULL, "settings.dat is not valid", NULL, MB_OK|MB_TOPMOST);
            ZeroMemory (&g_Settings, sizeof (g_Settings));
            g_Settings.CodePageArray[0] = -1;
            g_Settings.Signature = SIGNATURE;
        }
    }
}


BOOL
CALLBACK
GetArgsProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CHAR Version[32];
    CHAR List[4096];
    PSTR p, q;
    INT i;

    switch (uMsg) {
    case WM_INITDIALOG:
        SetWindowText (GetDlgItem (hdlg, IDC_PRODUCT_ID), g_Settings.ProductId);

        wsprintf (Version, "%u", max (1, g_Settings.DllVersion));
        SetWindowText (GetDlgItem (hdlg, IDC_VERSION), Version);
        SetWindowText (GetDlgItem (hdlg, IDC_COMPANY), g_Settings.vi.CompanyName);
        SetWindowText (GetDlgItem (hdlg, IDC_PHONE), g_Settings.vi.SupportNumber);
        SetWindowText (GetDlgItem (hdlg, IDC_URL), g_Settings.vi.SupportUrl);
        SetWindowText (GetDlgItem (hdlg, IDC_INSTRUCTIONS), g_Settings.vi.InstructionsToUser);

        SetWindowText (GetDlgItem (hdlg, IDC_MIGRATE_INF), g_Settings.MigrateInf);

        p = g_Settings.FileNameMultiSz;
        q = List;
        while (*p) {
            if (q != List) {
                _mbscpy (q, ",");
                q = _mbschr (q, 0);
            }
            _mbscpy (q, p);
            q = _mbschr (q, 0);

            p = _mbschr (p, 0) + 1;
        }
        *q = 0;

        SetWindowText (GetDlgItem (hdlg, IDC_FILES), List);

        q = List;
        if (g_Settings.CodePageArray[0] != -1) {
            for (i = 0 ; g_Settings.CodePageArray[i] != -1 ; i++) {
                if (i > 0) {
                    _mbscpy (q, ",");
                    q = _mbschr (q, 0);
                }

                wsprintf (q, "%i", g_Settings.CodePageArray[i]);
                q = _mbschr (q, 0);
            }

            _mbscpy (q, ",-1");
            q = _mbschr (q, 0);
        }
        *q = 0;

        SetWindowText (GetDlgItem (hdlg, IDC_CODE_PAGES), List);


        CheckDlgButton (hdlg, IDC_BARF_QV, g_Settings.BarfInQueryVersion ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_INIT9X, g_Settings.BarfInInit9x ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_USER9X, g_Settings.BarfInUser9x ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_SYSTEM9X, g_Settings.BarfInSystem9x ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_INITNT, g_Settings.BarfInInitNt ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_USERNT, g_Settings.BarfInUserNt ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_SYSTEMNT, g_Settings.BarfInSystemNt ? BST_CHECKED : BST_UNCHECKED);

        return FALSE;

    case WM_COMMAND:
        if (HIWORD (wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDOK:

                GetDlgItemText (hdlg, IDC_PRODUCT_ID, g_Settings.ProductId, 256);
                GetDlgItemText (hdlg, IDC_MIGRATE_INF, g_Settings.MigrateInf, 16384);

                GetDlgItemText (hdlg, IDC_VERSION, Version, 32);
                g_Settings.DllVersion = strtoul (Version, NULL, 10);

                GetDlgItemText (hdlg, IDC_CODE_PAGES, List, 4096);

                i = 0;

                if (*List) {
                    q = List;
                    do {
                        p = _mbschr (List, TEXT(','));
                        if (p) {
                            *p = 0;
                            p++;
                        }

                        g_Settings.CodePageArray[i] = atoi (q);
                        i++;

                        q = p;
                    } while (p);
                }

                g_Settings.CodePageArray[i] = -1;


                GetDlgItemText (hdlg, IDC_FILES, List, 4096);

                if (*List) {
                    _mbscpy (g_Settings.FileNameMultiSz, List);
                    p = _mbschr (g_Settings.FileNameMultiSz, ',');
                    while (p) {
                        *p = 0;
                        p = _mbschr (p + 1, ',');
                    }

                    p++;
                    *p = 0;
                } else {
                    *g_Settings.FileNameMultiSz = 0;
                }

                GetDlgItemText (hdlg, IDC_COMPANY, g_Settings.vi.CompanyName, 256);
                GetDlgItemText (hdlg, IDC_PHONE, g_Settings.vi.SupportNumber, 256);
                GetDlgItemText (hdlg, IDC_URL, g_Settings.vi.SupportUrl, 256);
                GetDlgItemText (hdlg, IDC_INSTRUCTIONS, g_Settings.vi.InstructionsToUser, 256);

                g_Settings.BarfInQueryVersion = (IsDlgButtonChecked (hdlg, IDC_BARF_QV) == BST_CHECKED);
                g_Settings.BarfInInit9x = (IsDlgButtonChecked (hdlg, IDC_BARF_INIT9X) == BST_CHECKED);
                g_Settings.BarfInUser9x = (IsDlgButtonChecked (hdlg, IDC_BARF_USER9X) == BST_CHECKED);
                g_Settings.BarfInSystem9x = (IsDlgButtonChecked (hdlg, IDC_BARF_SYSTEM9X) == BST_CHECKED);
                g_Settings.BarfInInitNt = (IsDlgButtonChecked (hdlg, IDC_BARF_INITNT) == BST_CHECKED);
                g_Settings.BarfInUserNt = (IsDlgButtonChecked (hdlg, IDC_BARF_USERNT) == BST_CHECKED);
                g_Settings.BarfInSystemNt = (IsDlgButtonChecked (hdlg, IDC_BARF_SYSTEMNT) == BST_CHECKED);

                EndDialog (hdlg, IDOK);
                break;

            case IDCANCEL:
                EndDialog (hdlg, IDCANCEL);
                break;
            }
        }

        break;
    }

    return FALSE;
}



LONG
CALLBACK
QueryVersion (
    OUT     PCSTR *ProductID,
    OUT     PUINT DllVersion,
    OUT     PINT *CodePageArray,       OPTIONAL
    OUT     PCSTR *ExeNamesBuf,        OPTIONAL
    OUT     PVENDORINFO *VendorInfo
    )
{
    ZeroMemory (&g_Settings, sizeof (g_Settings));
    g_Settings.CodePageArray[0] = -1;
    g_Settings.Signature = SIGNATURE;

    pLoadSettings(TRUE);

    if (DialogBox (
            g_hInst,
            MAKEINTRESOURCE(IDD_ARGS_DLG),
            NULL,
            GetArgsProc
            ) != IDOK) {

        return ERROR_NOT_INSTALLED;
    }

    *ProductID  = g_Settings.ProductId;
    *DllVersion = g_Settings.DllVersion;
    if (g_Settings.CodePageArray[0] != -1) {
        *CodePageArray = g_Settings.CodePageArray;
    }
    *ExeNamesBuf = g_Settings.FileNameMultiSz;
    *VendorInfo = &g_Settings.vi;

    if (g_Settings.BarfInQueryVersion) {
        Barf();
    }

    pSaveSettings(TRUE);
    pSaveSettings(FALSE);

    return ERROR_SUCCESS;
}


LONG
CALLBACK
Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories,
            PVOID Reserved
    )
{
    HANDLE File;
    DWORD DontCare;

    pLoadSettings(FALSE);

    if (g_Settings.MigrateInf[0]) {
        File = CreateFile ("migrate.inf", GENERIC_READ|GENERIC_WRITE, 0, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (File != INVALID_HANDLE_VALUE) {
            SetFilePointer (File, 0, NULL, FILE_END);
            WriteFile (File, "\r\n", 2, &DontCare, NULL);
            WriteFile (File, g_Settings.MigrateInf, lstrlen (g_Settings.MigrateInf), &DontCare, NULL);
            WriteFile (File, "\r\n", 2, &DontCare, NULL);
            CloseHandle (File);
        } else {
            return GetLastError();
        }
    }

    if (g_Settings.BarfInInit9x) {
        Barf();
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName,
            PVOID Reserved
    )
{
    if (g_Settings.BarfInUser9x) {
        Barf();
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
            PVOID Reserved
    )
{
    if (g_Settings.BarfInSystem9x) {
        Barf();
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories,
            PVOID Reserved
    )
{
    pLoadSettings(FALSE);

    if (g_Settings.BarfInInitNt) {
        Barf();
    }

    return ERROR_SUCCESS;
}



LONG
CALLBACK
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName,
            PVOID Reserved
    )
{
    TCHAR Path[MAX_PATH];
    TCHAR Msg[2048];
    HKEY RegKey;
    TCHAR ExpandedPath[MAX_PATH];
    DWORD Size;
    DWORD rc;

    if (g_Settings.BarfInUserNt) {
        Barf();
    }

    wsprintf (Msg, TEXT("User: %ls\r\n"), UserName);
    OutputDebugString (Msg);

    GetEnvironmentVariable (TEXT("USERPROFILE"), Path, MAX_PATH);

    wsprintf (Msg, TEXT("User Profile: %s\r\n"), Path);
    OutputDebugString (Msg);

    rc = RegOpenKeyEx (
            UserRegKey,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"),
            0,
            KEY_READ,
            &RegKey
            );

    if (rc != ERROR_SUCCESS) {
        wsprintf (Msg, TEXT("Can't open reg key.  Error: %u\r\n"), rc);
        OutputDebugString (Msg);
    } else {

        Size = sizeof (ExpandedPath);
        rc = RegQueryValueEx (RegKey, TEXT("Programs"), NULL, NULL, (PBYTE) ExpandedPath, &Size);

        if (rc == ERROR_SUCCESS) {
            wsprintf (Msg, TEXT("Programs: %ls\r\n"), ExpandedPath);
            OutputDebugString (Msg);
        } else {
            wsprintf (Msg, TEXT("Can't open reg key.  Error: %u\r\n"), rc);
            OutputDebugString (Msg);
        }

        RegCloseKey (RegKey);
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            PVOID Reserved
    )
{
    if (g_Settings.BarfInSystemNt) {
        Barf();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migisol\pch.h ===
#define MIGISOL_INCLUDES
#include "master.h"


WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    );

#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\miglib\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Calls all initialization routines that are used by miglib.lib.

Author:

    Jim Schmidt (jimschm) 08-Feb-1999

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>

HANDLE g_hHeap;
HANDLE g_hInst;

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );


VOID
InitializeMigLib (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL);
}


VOID
TerminateMigLib (
    VOID
    )
{
    MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\msg\makefile.inc ===
$(O)\msg.mc: w95upg.mc w95upgnt.mc common.mc report.mc last.mc
        copy /b w95upg.mc+w95upgnt.mc+common.mc+report.mc+last.mc $(O)\msg.mc

$(O)\msg.h $(O)\msg00001.bin $(O)\msg.rc: $(O)\msg.mc
        mc -A -v -h .\$(O) -r .\$(O) $(O)\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migisol\migisol.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migisol.c

Abstract:

    Implements an EXE that is used to run migration DLLs in a
    separate address space (sandboxing).

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    jimschm     19-Mar-2001 Removed DVD check because it is now
                            in a migration dll
    jimschm     02-Jun-1999 Added DVD checking support to avoid
                            setup crash on a Win9x blue screen
    jimschm     18-Mar-1999 Added cleanup for cases where text mode
                            fails and the user returns to Win9x.

    jimschm     23-Sep-1998 Converted to new IPC mechanism

--*/

#include "pch.h"
#include "plugin.h"
#include "migui.h"
#include "ntui.h"
#include "unattend.h"

BOOL g_ReportPhase = FALSE;
BOOL g_MigrationPhase = FALSE;
TCHAR g_DllName[MAX_TCHAR_PATH] = "";

P_INITIALIZE_NT InitializeNT;
P_MIGRATE_USER_NT MigrateUserNT;
P_MIGRATE_SYSTEM_NT MigrateSystemNT;
P_QUERY_VERSION QueryVersion;
P_INITIALIZE_9X Initialize9x;
P_MIGRATE_USER_9X MigrateUser9x;
P_MIGRATE_SYSTEM_9X MigrateSystem9x;


BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    PVOID lpvReserved
    );

BOOL
IsNEC98(
    VOID
    );


#define NO_GUI_ERROR 0

//
// Local functions
//

BOOL
PackExeNames(
    PGROWBUFFER GrowBuf,
    PCSTR p
    );

BOOL
PackDword(
    PGROWBUFFER GrowBuf,
    DWORD dw
    );

BOOL
PackQuadWord(
    PGROWBUFFER GrowBuf,
    LONGLONG qw
    );

BOOL
PackIntArray(
    PGROWBUFFER GrowBuf,
    PINT Array
    );

BOOL
PackString (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

BOOL
PackBinary (
    PGROWBUFFER GrowBuf,
    PBYTE Data,
    DWORD DataSize
    );

HINF
pGetInfHandleFromFileNameW (
    PCWSTR UnattendFile
    );

VOID
ProcessCommands (
    VOID
    );

BOOL
pParseCommandLine (
    VOID
    );

VOID
DoInitializeNT (
    PCWSTR Args
    );

VOID
DoInitialize9x (
    PCSTR Args
    );

VOID
DoMigrateUserNT (
    PCWSTR Args
    );

VOID
DoQueryVersion (
    PCSTR Args
    );

VOID
DoMigrateUser9x (
    PCSTR Args
    );

VOID
DoMigrateSystemNT (
    PCWSTR Args
    );

VOID
DoMigrateSystem9x (
    PCSTR Args
    );

HWND
pFindParentWindow (
    IN      PCTSTR WindowTitle,
    IN      DWORD ProcessId
    );

static HINSTANCE g_hLibrary;
HANDLE g_hHeap;
HINSTANCE g_hInst;


#ifdef DEBUG
#define DBG_MIGISOL "MigIsol"
#endif


INT
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    PSTR AnsiCmdLine,
    INT CmdShow
    )

/*++

Routine Description:

  The entry point to migisol.exe.  The entire body of code is wrapped
  in a try/except block to catch all problems with any migration DLLs.

Arguments:

  hInstance     - The instance handle of this EXE
  hPrevInstance - The previous instance handle of this EXE if it is
                  running, or NULL if no other instances exist.
  AnsiCmdLine   - The command line (ANSI version)
  CmdShow       - The ShowWindow command passed by the shell

Return Value:

  Returns -1 if an error occurred, or 0 if the exe completed. The exe
  will automatically terminate with 0 if the migration DLL throws an
  exception.

--*/

{
    TCHAR OurDir[MAX_TCHAR_PATH];
    PTSTR p;

    __try {
        g_hInst = hInstance;
        g_hHeap = GetProcessHeap();

        *OurDir = 0;

        GetModuleFileName (NULL, OurDir, ARRAYSIZE(OurDir));

        p = _tcsrchr (OurDir, TEXT('\\'));
        if (p) {
            *p = 0;
            if (!_tcschr (OurDir, TEXT('\\'))) {
                p[0] = TEXT('\\');
                p[1] = 0;
            }

            SetCurrentDirectory (OurDir);

            //
            // Force a specific setupapi.dll to be loaded
            //

            StringCopy (AppendWack (OurDir), TEXT("setupapi.dll"));
            LoadLibraryEx (
                    OurDir,
                    NULL,
                    LOAD_WITH_ALTERED_SEARCH_PATH
                    );
        }

        // Initialize utility library
        if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
            FreeLibrary (g_hLibrary);
            return -1;
        }

        DEBUGMSG ((DBG_MIGISOL, "migisol.exe started"));

        if (!pParseCommandLine()) {
            FreeLibrary (g_hLibrary);
            return -1;
        }

        DEBUGMSG ((DBG_MIGISOL, "CmdLine parsed"));

        if (!OpenIpc (FALSE, NULL, NULL, NULL)) {
            DEBUGMSG ((DBG_MIGISOL, "OpenIpc failed"));
            FreeLibrary (g_hLibrary);
            return -1;
        }

        __try {
            DEBUGMSG ((DBG_MIGISOL, "Processing commands"));
            ProcessCommands();
        }

        __except (TRUE) {
            LOG ((LOG_ERROR, "Upgrade Pack process is terminating because of an exception in WinMain"));
        }

        CloseIpc();
        FreeLibrary (g_hLibrary);

        DEBUGMSG ((DBG_MIGISOL, "migisol.exe terminating"));

        if (!MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
            return -1;
        }
    }

    __except (TRUE) {
    }

    return 0;
}

#define WINNT32_SECTOR_SIZE             512
#define WINNT32_FAT_BOOT_SECTOR_COUNT   1
#define WINNT32_FAT_BOOT_SIZE           (WINNT32_SECTOR_SIZE * WINNT32_FAT_BOOT_SECTOR_COUNT)
#define FILE_ATTRIBUTE_RHS              (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)


BOOL
pWriteFATBootSector (
    IN      PCTSTR BootDataFile,
    IN      TCHAR BootDriveLetter
    )
{
    HANDLE BootDataHandle;
    BYTE Data[WINNT32_FAT_BOOT_SIZE];
    DWORD BytesRead;
    BOOL Success = FALSE;

    if (GetFileAttributes (BootDataFile) == INVALID_ATTRIBUTES) {
        DEBUGMSG ((DBG_ERROR, "Can't find %s", BootDataFile));
        return FALSE;
    }

    BootDataHandle = CreateFile (
                        BootDataFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL
                        );
    if (BootDataHandle == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "Can't open %s", BootDataFile));
        return FALSE;
    }

    Success = ReadFile (BootDataHandle, Data, WINNT32_FAT_BOOT_SIZE, &BytesRead, NULL) &&
              (BytesRead == WINNT32_FAT_BOOT_SIZE);

    CloseHandle (BootDataHandle);

    if (Success) {
        //
        // write the boot sector with this data; don't save NT boot sector
        //
        Success = WriteDiskSectors (
                        BootDriveLetter,
                        0,
                        WINNT32_FAT_BOOT_SECTOR_COUNT,
                        WINNT32_SECTOR_SIZE,
                        Data
                        );
        DEBUGMSG_IF ((
            !Success,
            DBG_ERROR,
            "WriteDiskSectors failed for %c!",
            BootDriveLetter
            ));
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Unexpected boot sector size %u in %s", BytesRead, BootDataFile));

    return Success;
}

VOID
pCleanUpUndoDirectory (
    CHAR BootDrive
    )
/*++

Routine Description:

  This function delete recursively all files and directories
  include and in %windir%\undo directory.

Arguments:

  none

Return Value:

  none

--*/
{
    TCHAR PathBuffer[MAX_PATH];
    TCHAR Answer[MAX_PATH];
    TCHAR NullPath[] = {0};

    DEBUGMSG((DBG_MIGISOL, "Cleanup routine of undo directory"));

    if(!BootDrive){
        if (!GetWindowsDirectory (PathBuffer, ARRAYSIZE(PathBuffer))) {
            DEBUGMSG((DBG_MIGISOL, "GetWindowsDirectory failed"));
            return;
        }
        BootDrive = PathBuffer[0];
    }

    wsprintf(PathBuffer, TEXT("%c:\\$win_nt$.~bt\\winnt.sif"), BootDrive);

    GetPrivateProfileString(
        S_WIN9XUPGUSEROPTIONS,
        S_PATH_FOR_BACKUP,
        NullPath,
        Answer,
        ARRAYSIZE(Answer),
        PathBuffer);

    if(!Answer[0]) {
        DEBUGMSG ((DBG_MIGISOL, "Failed to retrieve directory path"));
        return;
    }

    wsprintf(PathBuffer, TEXT("%c:\\$win_nt$.~bt\\dataloss"), BootDrive);
    if (DoesFileExist (PathBuffer)) {
        LOG ((
            LOG_INFORMATION,
            "Data loss was detected because of a failure to restore one or more files. "
                "The data can be recovered from backup files in %s.",
            Answer
            ));
        return;
    }

    SetFileAttributes(Answer, FILE_ATTRIBUTE_NORMAL);
    RemoveCompleteDirectory (Answer);

    DEBUGMSG ((DBG_MIGISOL, "Cleaned %s directory", Answer));
}

VOID
pCleanUpAfterTextModeFailure (
    VOID
    )
{
    TCHAR squiggleBtDir[] = TEXT("?:\\$win_nt$.~bt");
    TCHAR squiggleLsDir[] = TEXT("?:\\$win_nt$.~ls");
    TCHAR squiggleBuDir[] = TEXT("?:\\$win_nt$.~bu"); // for NEC98
    TCHAR drvLtr[] = TEXT("?:\\$DRVLTR$.~_~");
    TCHAR setupLdr[] = TEXT("?:\\$LDR$");
    TCHAR txtSetupSif[] = TEXT("?:\\TXTSETUP.SIF");
    PCTSTR bootSectDat;
    TCHAR setupTempDir[MAX_PATH];
    TCHAR bootIni[] = TEXT("?:\\boot.ini");
    TCHAR ntLdr[] = TEXT("?:\\NTLDR");
    TCHAR ntDetectCom[] = TEXT("?:\\NTDETECT.COM");
    TCHAR bootFontBin[] = TEXT("?:\\BOOTFONT.BIN");
    TCHAR bootSectDos[] = TEXT("?:\\BootSect.dos");
    TCHAR renamedFile1[] = TEXT("?:\\boot~tmp.$$1");
    TCHAR renamedFile2[] = TEXT("?:\\boot~tmp.$$2");
    TCHAR renamedFile3[] = TEXT("?:\\boot~tmp.$$3");
    BOOL noLdr = FALSE;
    BOOL noNtDetect = FALSE;
    BOOL noBootFontBin = FALSE;
    DWORD Drives;
    TCHAR DriveLetter;
    DWORD Bit;
    TCHAR Root[] = TEXT("?:\\");
    TCHAR Scratch[MAX_PATH];
    PCTSTR bootSectBak;
    PCTSTR bootIniBak;
    PCTSTR ntldrBak;
    PCTSTR bootFontBak;
    PCTSTR ntdetectBak;
    TCHAR WinDir[MAX_PATH];
    DWORD Type;
    DWORD Attribs;
    FILE_ENUM e;
    HANDLE WinInit;
    CHAR AnsiBuffer[MAX_PATH + 10];
    DWORD Dummy;
    PTSTR Write;
    BOOL prepareBootIni = FALSE;
    CHAR SystemDirPath[MAX_PATH];
    TCHAR bootDriveLetter;
    PCTSTR bootSectorFile;
    BOOL bootLoaderWritten;
    HKEY key;
    BOOL dontTouchBootCode = FALSE;

    if (ISNT()) {
        return;
    }

    DEBUGMSG ((DBG_MIGISOL, "Entering cleanup routine"));

    SuppressAllLogPopups (TRUE);

    //
    // Reinitialize system restore
    //

    key = OpenRegKeyStr (TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Services\\VxD\\VxDMon"));
    if (key) {
        RegSetValueEx (key, TEXT("FirstRun"), 0, REG_SZ, (PCBYTE) "Y", 2);
        CloseRegKey (key);
    }

    //
    // Prepare windir and temp dir paths, get the bitmask of drive letters
    //
    // We need to know the system drive to be repaired, since win98 on NEC98
    // can boot up from any partition that can be installed.
    //

    GetSystemDirectory (SystemDirPath, MAX_PATH);

    if (!GetWindowsDirectory (setupTempDir, sizeof (setupTempDir) / sizeof (setupTempDir[0]))) {
        DEBUGMSG ((DBG_ERROR, "Can't get Windows dir"));
        return;
    } else {
        StringCopy (WinDir, setupTempDir);
    }
    StringCopy (AppendWack (setupTempDir), TEXT("setup"));

    Drives = GetLogicalDrives();

    bootDriveLetter = IsNEC98() ? SystemDirPath[0] : TEXT('C');

    if (WinDir[0] != bootDriveLetter) {
        dontTouchBootCode = TRUE;
    }

    //
    // Create paths
    //

    bootIniBak = JoinPaths (setupTempDir, S_BOOTINI_BACKUP);
    ntldrBak = JoinPaths (setupTempDir, S_NTLDR_BACKUP);
    ntdetectBak = JoinPaths (setupTempDir, S_NTDETECT_BACKUP);
    bootSectBak = JoinPaths (setupTempDir, S_BOOTSECT_BACKUP);
    bootFontBak = JoinPaths (setupTempDir, S_BOOTFONT_BACKUP);

    //
    // Deltree $win_nt$.~bt and $win_nt$.~ls
    //

    for (Bit = 1, DriveLetter = TEXT('A') ; Bit ; Bit <<= 1, DriveLetter++) {

        if (!(Drives & Bit)) {
            continue;
        }

        Root[0] = DriveLetter;
        Type = GetDriveType (Root);

        if (Type == DRIVE_FIXED || Type == DRIVE_UNKNOWN) {
            //
            // Clean this drive
            //

            squiggleBtDir[0] = DriveLetter;
            squiggleLsDir[0] = DriveLetter;

            RemoveCompleteDirectory (squiggleBtDir);
            RemoveCompleteDirectory (squiggleLsDir);

            //
            // On NEC98, there may be another temp directry to be clean up.
            //
            if (IsNEC98()) {
                squiggleBuDir[0] = DriveLetter;
                RemoveCompleteDirectory (squiggleBuDir);
            }
        }
    }

    DEBUGMSG ((DBG_MIGISOL, "Cleaned squiggle dirs"));

    //
    // Repair boot.ini (do not necessarily restore it to its original form though)
    // and clean the root of the drive.
    //

    for (Bit = 1, DriveLetter = TEXT('A') ; Bit ; Bit <<= 1, DriveLetter++) {

        if (!(Drives & Bit)) {
            continue;
        }

        //
        // On NEC98, there may be multiple boot files in each partition.
        // So we will just take care the system that booted up.
        //
        if (IsNEC98() && (DriveLetter != SystemDirPath[0])) {
            continue;
        }

        Root[0] = DriveLetter;
        Type = GetDriveType (Root);

        if (Type == DRIVE_FIXED || Type == DRIVE_UNKNOWN) {
            //
            // Remove setup from boot.ini if it is on this drive,
            // and clean root of the drive.
            //

            squiggleBtDir[0] = DriveLetter;
            squiggleLsDir[0] = DriveLetter;
            bootIni[0] = DriveLetter;
            drvLtr[0] = DriveLetter;
            setupLdr[0] = DriveLetter;
            ntLdr[0] = DriveLetter;
            ntDetectCom[0] = DriveLetter;
            bootFontBin[0] = DriveLetter;
            txtSetupSif[0] = DriveLetter;
            bootSectDos[0] = DriveLetter;
            renamedFile1[0] = DriveLetter;
            renamedFile2[0] = DriveLetter;
            renamedFile3[0] = DriveLetter;

            SetFileAttributes (drvLtr, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (drvLtr);

            SetFileAttributes (setupLdr, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (setupLdr);

            SetFileAttributes (txtSetupSif, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (txtSetupSif);

            //
            // If this is the boot drive, and if we have a bootsect.bak and
            // boot.bak in the setup temp directory, then that means Win9x had
            // an initial boot.ini, and we must restore it. Otherwise there
            // was no boot.ini.
            //

            if (!dontTouchBootCode && DriveLetter == bootDriveLetter) {
                DEBUGMSG ((DBG_MIGISOL, "Processing boot drive %c", bootDriveLetter));

                //
                // test for existence of bootini.bak/bootsect.bak (we don't
                // care about the attributes).
                //


                Attribs = GetFileAttributes (bootIniBak);
                DEBUGMSG ((DBG_MIGISOL, "Attributes of %s: 0x%08X", bootIniBak, Attribs));
                if (Attribs != INVALID_ATTRIBUTES) {
                    DEBUGMSG ((DBG_MIGISOL, "Attributes of %s: 0x%08X", bootSectBak, Attribs));
                    Attribs = GetFileAttributes (bootSectBak);
                }

                //
                // if pair exists, then get attributes of real boot.ini file
                //

                if (Attribs != INVALID_ATTRIBUTES) {
                    Attribs = GetFileAttributes (bootIni);
                    if (Attribs == INVALID_ATTRIBUTES) {
                        Attribs = FILE_ATTRIBUTE_RHS;
                    }

                    //
                    // Restore ntdetect.com, ntldr, boot sector, and original
                    // boot.ini.
                    //

                    DEBUGMSG ((DBG_MIGISOL, "Restoring dual-boot environment"));

                    if (pWriteFATBootSector (bootSectBak, bootDriveLetter)) {
                        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
                        CopyFile (bootIniBak, bootIni, FALSE);  // ignore failure
                        SetFileAttributes (bootIni, Attribs);

                        //
                        // Restore ntldr and ntdetect.com [as a pair]
                        //

                        if (DoesFileExist (ntldrBak) && DoesFileExist (ntdetectBak)) {
                            //
                            // wipe away collisions with our temp file names,
                            // then move current working loader to temp files
                            //

                            if (DoesFileExist (ntLdr)) {
                                SetFileAttributes (renamedFile1, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile1);
                                MoveFile (ntLdr, renamedFile1);
                                noLdr = FALSE;
                            } else {
                                noLdr = TRUE;
                            }

                            if (DoesFileExist (ntDetectCom)) {
                                SetFileAttributes (renamedFile2, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile2);
                                MoveFile (ntDetectCom, renamedFile2);
                                noNtDetect = FALSE;
                            } else {
                                noNtDetect = TRUE;
                            }

                            if (DoesFileExist (bootFontBin)) {
                                SetFileAttributes (renamedFile3, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile3);
                                MoveFile (bootFontBin, renamedFile3);
                                noBootFontBin = FALSE;
                            } else {
                                noBootFontBin = TRUE;
                            }

                            //
                            // now attempt to copy backup files to loader location
                            //

                            bootLoaderWritten = FALSE;

                            if (CopyFile (ntldrBak, ntLdr, FALSE)) {
                                bootLoaderWritten = CopyFile (ntdetectBak, ntDetectCom, FALSE);
                                DEBUGMSG_IF ((!bootLoaderWritten, DBG_ERROR, "Can't copy %s to %s", ntdetectBak, ntDetectCom));

                                if (bootLoaderWritten && DoesFileExist (bootFontBak)) {
                                    bootLoaderWritten = CopyFile (bootFontBak, bootFontBin, FALSE);
                                    DEBUGMSG_IF ((!bootLoaderWritten, DBG_ERROR, "Can't copy %s to %s", bootFontBak, bootFontBin));
                                }
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Can't copy %s to %s", ntldrBak, ntLdr));

                            if (bootLoaderWritten) {
                                //
                                // success -- remove temp files
                                //

                                SetFileAttributes (renamedFile1, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile1);

                                SetFileAttributes (renamedFile2, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile2);

                                SetFileAttributes (renamedFile3, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile3);

                            } else {
                                //
                                // fail -- restore temp files. If restoration
                                // fails, then generate a working boot.ini.
                                //

                                SetFileAttributes (ntLdr, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (ntLdr);

                                SetFileAttributes (ntDetectCom, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (ntDetectCom);

                                SetFileAttributes (bootFontBin, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (bootFontBin);

                                if (!noLdr) {
                                    if (!MoveFile (renamedFile1, ntLdr)) {
                                        prepareBootIni = TRUE;
                                        DEBUGMSG ((DBG_ERROR, "Can't restore %s to %s", renamedFile1, ntLdr));
                                    }
                                }

                                if (!noNtDetect) {
                                    if (!MoveFile (renamedFile2, ntDetectCom)) {
                                        prepareBootIni = TRUE;
                                        DEBUGMSG ((DBG_ERROR, "Can't restore %s to %s", renamedFile2, ntDetectCom));
                                    }
                                }

                                if (!noBootFontBin) {
                                    if (!MoveFile (renamedFile3, bootFontBin)) {
                                        prepareBootIni = TRUE;
                                        DEBUGMSG ((DBG_ERROR, "Can't restore %s to %s", renamedFile3, bootFontBin));
                                    }
                                }
                            }
                        }
                    } else {
                        LOG ((LOG_WARNING, "Unable to restore dual-boot loader"));
                    }

                } else {
                    //
                    // Remove the NT boot code. Delete ntdetect.com,
                    // bootfont.bin and ntldr. If any part of this code fails,
                    // make a boot.ini that will work. (ntdetect.com won't
                    // be needed.)
                    //

                    SetFileAttributes (ntDetectCom, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile (ntDetectCom);

                    Attribs = GetFileAttributes (bootIni);

                    if (Attribs != INVALID_ATTRIBUTES) {

                        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
                        prepareBootIni = TRUE;

                        //
                        // SystemDrive is not only C: on NEC98. Also, boot.ini
                        // should be always sitting on system drive but boot
                        // drive during setup, if these are separated.
                        // So we must take care the boot files on system drive.
                        //

                        if (GetFileAttributes (bootSectBak) != INVALID_ATTRIBUTES) {
                            bootSectorFile = bootSectBak;
                        } else {
                            bootSectorFile = bootSectDos;
                        }

                        if (pWriteFATBootSector (bootSectorFile, bootDriveLetter)) {
                            DEBUGMSG ((DBG_MIGISOL, "Successfully restored FAT boot sector"));
                            //
                            // restored original boot sector, NT boot files not required any longer
                            //
                            DeleteFile (bootIni);

                            SetFileAttributes (ntLdr, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (ntLdr);

                            SetFileAttributes (bootSectDos, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (bootSectDos);

                            SetFileAttributes (ntDetectCom, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (ntDetectCom);

                            SetFileAttributes (bootFontBin, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (bootFontBin);

                            prepareBootIni = FALSE;
                        } else {
                            //
                            // make sure this boot file is not accidentally
                            // deleted by the end-user
                            //
                            SetFileAttributes (ntLdr, FILE_ATTRIBUTE_RHS);

                            DEBUGMSG ((DBG_ERROR, "Cannot restore FAT boot sector from %s", bootSectDos));
                        }
                    }
                    ELSE_DEBUGMSG ((DBG_MIGISOL, "Skipping removal of boot.ini because it is not present"));
                }

                //
                // If we have any failure, this code here will make a boot
                // sector & loader that at least boots Win9x.
                //

                if (prepareBootIni) {
                    bootSectDat = JoinPaths (squiggleBtDir, TEXT("BOOTSECT.DAT"));

                    WritePrivateProfileString (TEXT("Boot Loader"), TEXT("Default"), Root, bootIni);
                    WritePrivateProfileString (TEXT("Operating Systems"), bootSectDat, NULL, bootIni);

                    GetPrivateProfileString (TEXT("Operating Systems"), Root, TEXT(""), Scratch, MAX_PATH, bootIni);

                    if (!Scratch[0]) {
                        //
                        // This should never ever occur, but for unknown cases we have this
                        //

                        WritePrivateProfileString (TEXT("Operating Systems"), Root, TEXT("Microsoft Windows"), bootIni);
                    }

                    WritePrivateProfileString (NULL, NULL, NULL, bootIni);
                    SetFileAttributes (bootIni, Attribs);

                    prepareBootIni = FALSE;
                    FreePathString (bootSectDat);
                }
            }
        }
    }

    //
    // Remove setup's temp dir as best we can.  This leaves some junk around,
    // but we will fix that on the next reboot.
    //

    RemoveCompleteDirectory (setupTempDir);

    //
    // put all remaining files in wininit.ini\[rename] they will be
    // automatically removed at next reboot
    //

    StringCopy (Scratch, WinDir);
    StringCopy (AppendWack (Scratch), TEXT("wininit.ini"));

    //
    // append "manually" since using WritePrivateProfileString will just
    // overwrite previous setting
    //

    if (EnumFirstFile (&e, setupTempDir, NULL)) {
        WinInit = CreateFile (
                    Scratch,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
        if (WinInit != INVALID_HANDLE_VALUE) {

            StringCopyA (AnsiBuffer, "\r\n[rename]");
            if (WriteFile (WinInit, AnsiBuffer, _mbslen (AnsiBuffer), &Dummy, NULL)) {

                StringCopyA (AnsiBuffer, "\r\nNUL=");
                Write = GetEndOfString (AnsiBuffer);

                do {
#ifdef UNICODE
                    KnownSizeUnicodeToDbcs (Write, e.FullPath);
#else
                    StringCopyA (Write, e.FullPath);
#endif
                    if (!WriteFile (WinInit, AnsiBuffer, _mbslen (AnsiBuffer), &Dummy, NULL)) {
                        break;
                    }
                } while (EnumNextFile (&e));
            }

            CloseHandle (WinInit);
        }
        ELSE_DEBUGMSG ((DBG_MIGISOL, "Cannot create wininit.ini"));
    }
    ELSE_DEBUGMSG ((DBG_MIGISOL, "No files found in temp dir"));

    FreePathString (bootIniBak);
    FreePathString (ntldrBak);
    FreePathString (ntdetectBak);
    FreePathString (bootSectBak);
    FreePathString (bootFontBak);

    DEBUGMSG ((DBG_MIGISOL, "Leaving cleanup routine"));
}


BOOL
pParseCommandLine (
    VOID
    )

/*++

Routine Description:

  Prepares the global variables g_hLibrary, g_ReportPhase, g_MigrationPhase,
  g_DllName and the migration DLL entry points (Initialize9x, etc.)

Arguments:

  none

Return Value:

  TRUE if the module was successfully loaded, or FALSE if a parsing
  error or load error occurred.

--*/

{
    PCTSTR CmdLine;
    PCTSTR *argv;
    INT argc;
    INT i;
    PCTSTR p;
    TCHAR drive;

    CmdLine = GetCommandLine();
    argv = CommandLineToArgv (CmdLine, &argc);
    if (!argv) {
        DEBUGMSG ((DBG_MIGISOL, "Parse error"));
        return FALSE;
    }

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('/')) {
            p = _tcsinc (argv[i]);
            switch (_totlower (_tcsnextc (p))) {
            case 'r':
                // Report-phase
                g_ReportPhase = TRUE;
                break;

            case 'm':
                // Migration-phase
                g_MigrationPhase = TRUE;
                break;

            case 'b':
                drive = '\0';
                p = _tcsinc(p);
                if(p && ':' == _tcsnextc(p)){
                    p = _tcsinc(p);
                    if(p){
                        drive = (TCHAR)_tcsnextc(p);
                    }
                }
                pCleanUpUndoDirectory(drive);
            case 'c':
                // Restore Win9x
                pCleanUpAfterTextModeFailure();
                return FALSE;
            }
        }
        else if (!g_DllName[0]) {
            StringCopy (g_DllName, argv[i]);
        } else {
            DEBUGMSG ((DBG_MIGISOL, "Broken arg: %s", argv[i]));
            return FALSE;
        }
    }

    //
    // Verify expected options exist
    //

    // One must be FALSE while the other must be TRUE
    if (g_ReportPhase == g_MigrationPhase) {
        DEBUGMSG ((DBG_MIGISOL, "Too many args"));
        return FALSE;
    }

    if (!g_DllName[0]) {
        DEBUGMSG ((DBG_MIGISOL, "No operation"));
        return FALSE;
    }

    //
    // Load migration DLL
    //

    g_hLibrary = LoadLibraryEx (
                    g_DllName,
                    NULL,
                    LOAD_WITH_ALTERED_SEARCH_PATH
                    );

    // If it fails, assume the DLL does not want to be loaded
    if (!g_hLibrary) {
        LOG ((LOG_ERROR, "Cannot load %s, rc=%u", g_DllName, GetLastError()));
        return FALSE;
    }

    // Get proc addresses for NT-side functions
    InitializeNT    = (P_INITIALIZE_NT)     GetProcAddress (g_hLibrary, PLUGIN_INITIALIZE_NT);
    MigrateUserNT   = (P_MIGRATE_USER_NT)   GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_USER_NT);
    MigrateSystemNT = (P_MIGRATE_SYSTEM_NT) GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_SYSTEM_NT);

    // Get proc addresses for 9x-side functions
    QueryVersion    = (P_QUERY_VERSION)     GetProcAddress (g_hLibrary, PLUGIN_QUERY_VERSION);
    Initialize9x    = (P_INITIALIZE_9X)     GetProcAddress (g_hLibrary, PLUGIN_INITIALIZE_9X);
    MigrateUser9x   = (P_MIGRATE_USER_9X)   GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_USER_9X);
    MigrateSystem9x = (P_MIGRATE_SYSTEM_9X) GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_SYSTEM_9X);

    // If any function does not exist, ignore the out-of-spec DLL
    if (!QueryVersion || !Initialize9x || !MigrateUser9x || !MigrateSystem9x ||
        !InitializeNT || !MigrateUserNT || !MigrateSystemNT
        ) {

        LOG ((LOG_ERROR, "Cannot load %s, one or more functions missing", g_DllName));
        return FALSE;
    }

    return TRUE;
}


VOID
ProcessCommands (
    VOID
    )

/*++

Routine Description:

  ProcessCommands waits on the IPC pipe for a command message.  When
  a command message is received, it is dispatched to the processing
  function.  If a terminate command is received, the EXE terminates.

  If no command is received in one second, the EXE terminates.  Therefore,
  Setup must always be ready to feed the EXE commands.

Arguments:

  none

Return Value:

  none

--*/

{
    DWORD Command;
    PBYTE Data;
    DWORD DataSize;

    DEBUGMSG ((DBG_MIGISOL, "Starting to process %s", g_DllName));

    do {

        // We wait for an interval: w95upgnt.dll or w95upg.dll should be ready
        // to feed us continuously.


        //
        // Receive command, don't care about size, OK to fail.
        //

        if (!GetIpcCommand (
                IPC_GET_COMMAND_WIN9X,
                &Command,
                &Data,
                &DataSize
                )) {
            DEBUGMSG ((DBG_WARNING, "MIGISOL: No command recieved"));
            break;
        }

        DEBUGMSG ((DBG_NAUSEA, "MigIsol - Command recieved: %u", Command));

        switch (Command) {

        case IPC_QUERY:
            if (g_MigrationPhase) {
            } else {
                DoQueryVersion ((PCSTR) Data);
            }
            break;

        case IPC_INITIALIZE:
            if (g_MigrationPhase) {
                DoInitializeNT ((PCWSTR) Data);
            } else {
                DoInitialize9x ((PCSTR) Data);
            }
            break;

        case IPC_MIGRATEUSER:
            if (g_MigrationPhase) {
                DoMigrateUserNT ((PCWSTR) Data);
            } else {
                DoMigrateUser9x ((PCSTR) Data);
            }
            break;

        case IPC_MIGRATESYSTEM:
            if (g_MigrationPhase) {
                DoMigrateSystemNT ((PCWSTR) Data);
            } else {
                DoMigrateSystem9x ((PCSTR) Data);
            }
            break;

        case IPC_TERMINATE:
            DEBUGMSG ((DBG_MIGISOL, "Processing of %s is complete", g_DllName));
            return;

        default:
            DEBUGMSG ((DBG_MIGISOL, "ProcessCommands: Unrecognized command -- terminating"));
            return;
        }

        if (Data) {
            MemFree (g_hHeap, 0, Data);
            Data = NULL;
        }

    } while (Command != IPC_TERMINATE);
}


VOID
DoInitializeNT (
    PCWSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's InitializeNT function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the initialize command.

Return Value:

  none

--*/

{
    PCWSTR WorkingDir = NULL;
    PCWSTR SourceDirs = NULL;
    PCWSTR EndOfSourceDirs;
    PDWORD ReservedSize;
    PVOID Reserved;
    DWORD rc = RPC_S_CALL_FAILED;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    //
    // Set pointers of IN parameters
    //

    WorkingDir = Args;
    SourceDirs = wcschr (Args, 0) + 1;
    EndOfSourceDirs = SourceDirs;
    while (*EndOfSourceDirs) {
        EndOfSourceDirs = wcschr (EndOfSourceDirs, 0);
        EndOfSourceDirs++;
    }
    ReservedSize = (PDWORD) (EndOfSourceDirs + 1);
    if (*ReservedSize) {
        Reserved = (PVOID) (ReservedSize + 1);
    } else {
        Reserved = NULL;
    }

    //
    // Set CWD
    //
    SetCurrentDirectoryW(WorkingDir);

    //
    // Call migration DLL function
    //

    __try {
        rc = InitializeNT (WorkingDir, SourceDirs, Reserved);
    }
    __except (TRUE) {
        // Send log message
        DEBUGMSG ((DBG_MIGISOL, "%s threw an exception in InitializeNT", g_DllName));
        rc = ERROR_NOACCESS;
        TechnicalLogId = MSG_EXCEPTION_MIGRATE_INIT_NT;
    }

    //
    // No OUT parameters to send
    //

    SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);
}


HINF
pGetInfHandleFromFileNameW (
    PCWSTR UnattendFile
    )

/*++

Routine Description:

  pGetInfHandleFromFileName uses the Setup APIs to open the specified
  UnattendFile.

Arguments:

  UnattendFile  - A pointer to the UNICODE file name specifying the unattend
                  file.  This string is converted to ANSI and the ANSI version
                  of SetupOpenInfFile is called.

Return Value:

  The INF handle, or NULL (*not* INVALID_HANDLE_VALUE) if the file could not
  be opened.

--*/

{
    CHAR AnsiUnattendFile[MAX_MBCHAR_PATH];
    HINF UnattendHandle;

    KnownSizeWtoA (AnsiUnattendFile, UnattendFile);
    UnattendHandle = SetupOpenInfFileA (AnsiUnattendFile, NULL, INF_STYLE_OLDNT|INF_STYLE_WIN4, NULL);

    if (UnattendHandle == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "pGetInfHandleFromFileNameW: Could not open %s", UnattendFile));
        UnattendHandle = NULL;
    }

    return UnattendHandle;
}

VOID
DoMigrateUserNT (
    PCWSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateUserNT function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATEUSER command.

Return Value:

  none

--*/

{
    PCWSTR UnattendFile;
    PCWSTR UserRegKey;
    PCWSTR UserName;
    PCWSTR UserDomain;
    PCWSTR FixedUserName;
    PCWSTR UserProfileDir;
    WCHAR OrgProfileDir[MAX_WCHAR_PATH];
    HINF UnattendHandle = NULL;
    HKEY UserRegHandle = NULL;
    DWORD rc;
    PVOID Reserved;
    PDWORD ReservedBytesPtr;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    __try {
        //
        // Preserve USERPROFILE environment variable
        //

        GetEnvironmentVariableW (S_USERPROFILEW, OrgProfileDir, MAX_WCHAR_PATH);

        //
        // Set pointers of IN parameters
        //

        UnattendFile     = Args;
        UserRegKey       = wcschr (UnattendFile, 0) + 1;
        UserName         = wcschr (UserRegKey, 0) + 1;
        UserDomain       = wcschr (UserName, 0) + 1;
        FixedUserName    = wcschr (UserDomain, 0) + 1;
        UserProfileDir   = wcschr (FixedUserName, 0) + 1;
        ReservedBytesPtr = (PDWORD) (wcschr (UserProfileDir, 0) + 1);

        if (*ReservedBytesPtr) {
            Reserved = (PVOID) (ReservedBytesPtr + 1);
        } else {
            Reserved = NULL;
        }

        //
        // Set USERPROFILE
        //

        if (UserProfileDir[0]) {
            WCHAR DebugDir[MAX_WCHAR_PATH];

            SetEnvironmentVariableW (S_USERPROFILEW, UserProfileDir);
            DEBUGMSG ((DBG_MIGISOL, "USERPROFILE set to %ls", UserProfileDir));

            GetEnvironmentVariableW (S_USERPROFILEW, DebugDir, MAX_WCHAR_PATH);
            DEBUGMSG ((DBG_MIGISOL, "USERPROFILE set to %ls", DebugDir));
        }

        //
        // Get UnattendHandle and UserRegHandle
        //

        UnattendHandle = pGetInfHandleFromFileNameW (UnattendFile);
        UserRegHandle = OpenRegKeyStrW (UserRegKey);

        if (!UnattendHandle || !UserRegHandle) {
            // Send log message and failure code
            rc = ERROR_OPEN_FAILED;

        } else {

            //
            // Call migration DLL function
            //

            __try {
                rc = MigrateUserNT (
                        UnattendHandle,
                        UserRegHandle,
                        UserName[0] ? UserName : NULL,
                        Reserved
                        );
            }
            __except (TRUE) {
                // Send log message and failure code
                DEBUGMSG ((DBG_MIGISOL, "%s threw an exception in MigrateUserNT", g_DllName));
                rc = ERROR_NOACCESS;
                TechnicalLogId = MSG_EXCEPTION_MIGRATE_USER_NT;
            }
        }

        //
        // No OUT parameters to send
        //

        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
            UserRegHandle = NULL;
        }

        SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);

    }

    __finally {
        //
        // Clean up
        //

        SetEnvironmentVariableW (S_USERPROFILEW, OrgProfileDir);

        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
        }

        if (UnattendHandle != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (UnattendHandle);
        }
    }
}


VOID
DoMigrateSystemNT (
    PCWSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateSystemNT function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATESYSTEM command.

Return Value:

  none

--*/

{
    PCWSTR UnattendFile;
    HINF UnattendHandle = NULL;
    DWORD rc;
    PVOID Reserved;
    PDWORD ReservedBytesPtr;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    __try {
        //
        // Set pointers of IN parameters
        //

        UnattendFile    = Args;
        ReservedBytesPtr = (PDWORD) (wcschr (UnattendFile, 0) + 1);

        if (*ReservedBytesPtr) {
            Reserved = (PVOID) (ReservedBytesPtr + 1);
        } else {
            Reserved = NULL;
        }

        //
        // Get UnattendHandle and UserRegHandle
        //

        UnattendHandle = pGetInfHandleFromFileNameW (UnattendFile);

        if (!UnattendHandle) {
            rc = ERROR_OPEN_FAILED;
        } else {

            //
            // Call migration DLL function
            //

            __try {
                rc = MigrateSystemNT (UnattendHandle, Reserved);
            }
            __except (TRUE) {
                DEBUGMSG ((DBG_MIGISOL, "%s threw an exception in MigrateSystemNT", g_DllName));
                rc = ERROR_NOACCESS;
                TechnicalLogId = MSG_EXCEPTION_MIGRATE_SYSTEM_NT;
            }
        }

        //
        // No OUT parameters to send
        //

        SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);

    }

    __finally {
        if (UnattendHandle != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (UnattendHandle);
        }
    }
}



VOID
DoQueryVersion (
    PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's QueryVersion function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_QUERY command.

Return Value:

  none

--*/

{
    DWORD rc = RPC_S_CALL_FAILED;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PSTR ProductId = NULL;
    UINT DllVersion = 0;
    PDWORD CodePageArray = NULL;
    PCSTR ExeNames = NULL;
    PCSTR WorkingDir;
    PVENDORINFO VendorInfo = NULL;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoQueryVersion"));

    __try {
        //
        // Set pointers of IN parameters
        //
        WorkingDir = (PSTR)Args;                  // CWD for this process

        //
        // Change CWD
        //
        SetCurrentDirectory(WorkingDir);

        //
        // Call migration DLL function
        //
        __try {
            DEBUGMSG ((DBG_MIGISOL, "QueryVersion: WorkingDir=%s", WorkingDir));

            rc = QueryVersion (
                    &ProductId,
                    &DllVersion,
                    &CodePageArray,
                    &ExeNames,
                    &VendorInfo
                    );

            DEBUGMSG ((DBG_MIGISOL, "QueryVersion rc=%u", rc));
            DEBUGMSG ((DBG_MIGISOL, "VendorInfo=0x%X", VendorInfo));
        }
        __except (TRUE) {
            DEBUGMSG ((
                DBG_MIGISOL,
                "%s threw an exception in QueryVersion",
                g_DllName
                ));

            TechnicalLogId = MSG_MIGDLL_QUERYVERSION_EXCEPTION_LOG;
            rc = ERROR_NOACCESS;
        }

        //
        // Unless we know failure occurred, return out parameters
        //
        if (rc == ERROR_SUCCESS) {
            //
            // Pack product id string
            //
            if (!PackString (&GrowBuf, ProductId)) {
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion PackProductId failed"));
                rc = GetLastError();
                __leave;
            }

            //
            // Pack DLL version
            //
            if (!PackDword(&GrowBuf, DllVersion)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion DllVersion failed"));
                __leave;
            }

            //
            // Pack CP array
            //
            if (!PackIntArray(&GrowBuf, CodePageArray)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion PackIntArray failed"));
                __leave;
            }

            //
            // Pack Exe Names
            //
            if (!PackExeNames(&GrowBuf, ExeNames)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion PackExeNames failed"));
                __leave;
            }


            //
            // Pack PVENDORINFO
            //
            if (!PackDword(&GrowBuf, (DWORD) VendorInfo)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion VendorInfo failed"));
                __leave;
            }

            if (VendorInfo) {
                if (!PackBinary (&GrowBuf, (PBYTE) VendorInfo, sizeof (VENDORINFO))) {
                    rc = GetLastError();
                    DEBUGMSG ((DBG_MIGISOL, "QueryVersion VendorInfo failed"));
                    __leave;
                }
            }
        }

        //
        // Send the packed parameters
        //
        if (!SendIpcCommandResults (
                rc,
                TechnicalLogId,
                GuiLogId,
                GrowBuf.End ? GrowBuf.Buf : NULL,
                GrowBuf.End
                )) {

            DEBUGMSG ((
                DBG_ERROR,
                "DoQueryVersion failed to send command response"
                ));

            LOG ((LOG_ERROR, "Upgrade Pack process could not send reply data"));
        }
    }
    __finally {
        FreeGrowBuffer(&GrowBuf);
    }

    DEBUGMSG ((DBG_MIGISOL, "Leaving DoQueryVersion, rc=%u", rc));
}


VOID
DoInitialize9x (
    PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's Initialize9x function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_INITIALIZE command.

Return Value:

  none

--*/

{
    DWORD rc = RPC_S_CALL_FAILED;
    PSTR WorkingDir = NULL;
    PSTR SourceDirs = NULL;
    PVOID Reserved;
    DWORD ReservedSize;
    PCSTR p;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;
    GROWBUFFER GrowBuf = GROWBUF_INIT;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoInitialize9x"));

    __try {
        //
        // Set pointers of IN parameters
        //
        WorkingDir = (PSTR)Args;               // CWD for this process
        SourceDirs = GetEndOfStringA (WorkingDir) + 1; // arg for Initialize9x

        p = SourceDirs;
        while (*p) {
            p = GetEndOfStringA (p);
            p++;
        }

        p++;

        ReservedSize = *((PDWORD) p);
        p = (PCSTR) ((PBYTE) p + sizeof (DWORD));

        if (ReservedSize) {
            Reserved = (PVOID) p;
            p = (PCSTR) ((PBYTE) p + ReservedSize);
        } else {
            Reserved = NULL;
        }

        //
        // Change CWD
        //
        SetCurrentDirectory(WorkingDir);

        //
        // Call migration DLL function
        //
        __try {
            rc = Initialize9x (
                    WorkingDir,
                    SourceDirs,
                    Reserved
                    );
        }
        __except (TRUE) {
            //
            // Send log message
            //
            DEBUGMSG ((DBG_MIGISOL,
                "%s threw an exception in Initialize9x",
                g_DllName));

            TechnicalLogId = MSG_MIGDLL_INITIALIZE9X_EXCEPTION_LOG;
            rc = ERROR_NOACCESS;
        }

        //
        // Send reserved
        //

        if (rc == ERROR_SUCCESS) {

            //
            // Pack reserved parameter
            //

            // Set ReservedSize to zero for now because the Reserved arg is an IN only
            ReservedSize = 0;

            if (!PackBinary (&GrowBuf, (PBYTE) Reserved, ReservedSize)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "Initialize9x reserved failed"));
                __leave;
            }
        }

        //
        // Send the packed parameters
        //
        if (!SendIpcCommandResults (
                rc,
                TechnicalLogId,
                GuiLogId,
                GrowBuf.End ? GrowBuf.Buf : NULL,
                GrowBuf.End
                )) {

            DEBUGMSG ((
                DBG_ERROR,
                "DoInitializeNT failed to send command response"
                ));

            LOG ((LOG_ERROR, "Upgrade Pack process could not send reply data"));
        }
    }
    __finally {
        FreeGrowBuffer (&GrowBuf);
    }

    DEBUGMSG ((DBG_MIGISOL, "Leaving DoInitialize9x, rc=%u", rc));
}


VOID
DoMigrateUser9x (
    IN      PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateUser9x function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATEUSER command.

Return Value:

  none

--*/

{
    PCSTR ParentWndTitle = NULL;
    HWND ParentWnd;
    PCSTR UnattendFile = NULL;
    PCSTR UserRegKey = NULL;
    PCSTR UserName = NULL;
    HKEY UserRegHandle = NULL;
    DWORD rc = RPC_S_CALL_FAILED;
    DWORD ProcessId;
    DWORD GuiLogId = 0;
    DWORD TechnicalLogId = 0;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoMigrateUser9x"));

    __try {
        //
        // Set pointers of IN parameters
        //
        ParentWndTitle  = Args;
        UnattendFile    = GetEndOfStringA (ParentWndTitle) + 1;
        ProcessId       = *((PDWORD) UnattendFile);
        UnattendFile    = (PCSTR) ((PBYTE) UnattendFile + sizeof (DWORD));
        UserRegKey      = GetEndOfStringA (UnattendFile) + 1;
        UserName        = GetEndOfStringA (UserRegKey) + 1;

        //
        // Get UserRegHandle
        //

        UserRegHandle = OpenRegKeyStr(UserRegKey);

        if (!UserRegHandle) {
            rc = ERROR_OPEN_FAILED;
        } else {

            ParentWnd = pFindParentWindow (ParentWndTitle, ProcessId);

            //
            // Call migration DLL function
            //

            __try {
                rc = MigrateUser9x(
                        ParentWnd,
                        UnattendFile,
                        UserRegHandle,
                        *UserName ? UserName : NULL,
                        NULL
                        );
            }
            __except (TRUE) {
                //
                // Send log message
                //
                DEBUGMSG ((
                    DBG_MIGISOL,
                    "%s threw an exception in MigrateUser9x",
                    g_DllName
                    ));

                TechnicalLogId = MSG_MIGDLL_MIGRATEUSER9X_EXCEPTION_LOG;
                rc = ERROR_NOACCESS;
            }
        }

        //
        // No need to return out parameters
        //

        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
            UserRegHandle = NULL;
        }

        SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);
    }
    __finally {
        //
        // Free resources
        //
        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
        }
    }

    DEBUGMSG ((DBG_MIGISOL, "Leaving MigrateUser9x , rc=%u", rc));
}


VOID
DoMigrateSystem9x(
    IN      PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateSystem9x function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATESYSTEM command.

Return Value:

  none

--*/

{
    PCSTR ParentWndTitle = NULL;
    DWORD ProcessId;
    PCSTR UnattendFile = NULL;
    HWND ParentWnd = NULL;
    DWORD rc = RPC_S_CALL_FAILED;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoMigrateSystem9x"));

    //
    // Set pointers of IN parameters
    //

    ParentWndTitle    = Args;
    UnattendFile      = GetEndOfStringA (ParentWndTitle) + 1;
    ProcessId         = *((PDWORD) UnattendFile);
    UnattendFile      = (PCSTR) ((PBYTE) UnattendFile + sizeof (DWORD));

    //
    // Get ParentWnd
    //
    ParentWnd = pFindParentWindow (ParentWndTitle, ProcessId);

    //
    // Call migration DLL function
    //
    __try {
        rc = MigrateSystem9x(
                ParentWnd,
                UnattendFile,
                NULL
                );
    }
    __except (TRUE) {
        //
        // Send log message
        //
        DEBUGMSG ((
            DBG_MIGISOL,
            "%s threw an exception in MigrateSystem9x",
            g_DllName
            ));

        TechnicalLogId = MSG_MIGDLL_MIGRATESYSTEM9X_EXCEPTION_LOG;
        rc = ERROR_NOACCESS;
    }

    //
    // No need to return out parameters
    //

    SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);

    DEBUGMSG ((DBG_MIGISOL, "Leaving DoMigrateSystem9x, rc=%u", rc));
}



//
// Function packs a DWORD into a GrowBuffer.

BOOL
PackDword(
    PGROWBUFFER GrowBuf,
    DWORD dw
    )
{
    PVOID p;
    p = GrowBuffer (GrowBuf, sizeof(DWORD));
    if (!p) {
        return FALSE;
    }
    CopyMemory (p, (PVOID)(&dw), sizeof(dw));
    return TRUE;
}



//
// Function packs a LONGLONG into a GrowBuffer
BOOL
PackQuadWord(
        PGROWBUFFER GrowBuf,
        LONGLONG qw)
{
    return (
        PackDword(GrowBuf, (DWORD)qw) &&
        PackDword(GrowBuf, (DWORD)(qw >> 32)));
}


//
// Function packs 1) a NULL ptr, or 2) array of int terminated by -1, into a
// GrowBuffer.
//
BOOL
PackIntArray(
    PGROWBUFFER GrowBuf,
    PINT Array
    )
{
    DWORD Count;
    PDWORD ArrayPos;

    if (!Array) {
        if (!GrowBufAppendDword (GrowBuf, 0)) {
            return FALSE;
        }
    } else {
        __try {
            Count = 1;
            for (ArrayPos = Array ; (*ArrayPos) != -1 ; ArrayPos++) {
                Count++;
            }
        }
        __except (TRUE) {
            LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid code page array", g_DllName));
            SetLastError (ERROR_NOACCESS);
            return FALSE;
        }

        if (!GrowBufAppendDword (GrowBuf, Count)) {
            return FALSE;
        }

        for (ArrayPos = Array ; Count ; ArrayPos++, Count--) {
            if (!GrowBufAppendDword (GrowBuf, (DWORD) (UINT) (*ArrayPos))) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


//
// Function packs 1) a NULL pointer, or 2) a multi-sz, into a GrowBuffer.
//
BOOL
PackExeNames(
    PGROWBUFFER GrowBuf,
    PCSTR ExeNames
    )
{
    PCSTR p;

    if (ExeNames) {
        __try {
            for (p = ExeNames ; *p ; p = GetEndOfStringA (p) + 1) {
            }
        }
        __except (TRUE) {
            LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid file list", g_DllName));
            SetLastError (ERROR_NOACCESS);
            return FALSE;
        }

        // Append non-empty strings
        for (p = ExeNames ; *p ; p = GetEndOfStringA (p) + 1) {
            if (!MultiSzAppendA (GrowBuf, p)) {
                return FALSE;
            }
        }
    }

    // Append a final empty string
    if (!MultiSzAppendA(GrowBuf, "")) {
        return FALSE;
    }

    return TRUE;
}

BOOL
PackString (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    __try {
        if (!MultiSzAppendA (GrowBuf, String)) {
            return FALSE;
        }
    }
    __except (TRUE) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s provided an invalid ProductID string (%xh)",
            g_DllName,
            String
            ));

        LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid product ID", g_DllName));

        SetLastError (ERROR_NOACCESS);
        return FALSE;
    }

    return TRUE;
}

BOOL
PackBinary (
    PGROWBUFFER GrowBuf,
    PBYTE Data,
    DWORD DataSize
    )
{
    PBYTE Buf;

    if (!PackDword (GrowBuf, DataSize)) {
        return FALSE;
    }

    if (!DataSize) {
        return TRUE;
    }

    Buf = GrowBuffer (GrowBuf, DataSize);
    if (!Buf) {
        return FALSE;
    }

    __try {
        CopyMemory (Buf, Data, DataSize);
    }
    __except (TRUE) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s provided an invalid binary parameter (%xh)",
            g_DllName,
            Data
            ));

        LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid binary parameter", g_DllName));

        SetLastError (ERROR_NOACCESS);
        return FALSE;
    }

    return TRUE;
}



typedef struct {
    PCTSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCT, *PFINDWINDOW_STRUCT;


BOOL
CALLBACK
pEnumWndProc (
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

  A callback that is called for every top level window on the system.
  It is used with pFindParentWindow to locate a specific window.

Arguments:

  hwnd      - Specifies the handle of the current enumerated window
  lParam    - Specifies a pointer to a FINDWINDOW_STRUCT variable that
              holds WindowTitle and ProcessId, and receives the
              handle if a match is found.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    TCHAR Title[MAX_TCHAR_PATH];
    DWORD ProcessId;
    PFINDWINDOW_STRUCT p;

    p = (PFINDWINDOW_STRUCT) lParam;

    GetWindowText (hwnd, Title, MAX_TCHAR_PATH);
    GetWindowThreadProcessId (hwnd, &ProcessId);

    DEBUGMSG ((DBG_MIGISOL, "Testing window: %s, ID=%x against %s, %x",
              Title, ProcessId, p->WindowTitle, p->ProcessId));

    if (!StringCompare (Title, p->WindowTitle) &&
        ProcessId == p->ProcessId) {

        p->Match = hwnd;
        LogReInit (&hwnd, NULL);

        DEBUGMSG ((DBG_MIGISOL, "Window found: %s, ID=%u", Title, ProcessId));
        return FALSE;
    }

    return TRUE;
}


HWND
pFindParentWindow (
    IN      PCTSTR WindowTitle,
    IN      DWORD ProcessId
    )

/*++

Routine Description:

  Locates the wizard window by enumerating all top-level windows.
  The first one to match the supplied title and process ID is used.

Arguments:

  WindowTitle   - Specifies the name of the window to find.
  ProcessId     - Specifies the ID of the process who owns the window.  If
                  zero is specified, NULL is returned.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    FINDWINDOW_STRUCT FindWndStruct;

    // If no process ID, we cannot have a match
    if (!ProcessId) {
        return NULL;
    }

    ZeroMemory (&FindWndStruct, sizeof (FindWndStruct));
    FindWndStruct.WindowTitle = WindowTitle;
    FindWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProc, (LPARAM) &FindWndStruct);

    return FindWndStruct.Match;
}


//
// Check platform that I'm runnig on. Copyed from winnt32[au].dll.
//   TRUE  - NEC98
//   FALSE - others(includes x86)
//

BOOL
IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migisol\sectorio.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sectorio.c

Abstract:

    Routines to perform low-level sector I/O on either Windows NT or
    Windows 95.

Author:

    Ted Miller (tedm) 1 Nov 1996

Revision History:

--*/

#include "pch.h"
#include <tlhelp32.h>

#define ISOSR2() ISATLEASTOSR2()
#define MALLOC(u) (LocalAlloc (GMEM_FIXED, u))
#define FREE(u) (LocalFree (u))

//
// Define structures for use with Win9x VWIN32.
// Note: alignment must be on 1-byte boundaries for these structures.
//
#include <pshpack1.h>

typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS;

typedef struct _DIOC_DISKIO {
    DWORD  StartSector;
    WORD   SectorCount;
    LPBYTE Buffer;
} DIOC_DISKIO;

#include <poppack.h>



//
// Define codes we care about for use with VWIN32
//
#define VWIN32_DIOC_DOS_IOCTL           1
#define VWIN32_DIOC_DOS_INT25           2
#define VWIN32_DIOC_DOS_INT26           3
#define VWIN32_DIOC_DOS_DRIVEINFO       6       // new in OSR2


BOOL
ReadOrWriteSectorsWin9xOriginal(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    earlier than OSR2. Uses int25/26.

    This routine will fail on Windows NT.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = (DWORD)(_totupper(Drive) - TEXT('A'));
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            Write ? VWIN32_DIOC_DOS_INT26 : VWIN32_DIOC_DOS_INT25,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9xOsr2(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    OSR2 or later. Uses the new int21 function 7305 (Ext_ABSDiskReadWrite).

    This routine will fail on Windows NT and earlier versions of Windows 95.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = 0x7305;
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;
    RegistersIn.reg_EDX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_ESI = Write ? 1 : 0;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_DRIVEINFO,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
        SetLastError (ERROR_IO_DEVICE);
    }

    return(b);
}


BOOL
LockOrUnlockVolumeWin9x(
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive,
    IN UINT   Level,
    IN BOOL   Lock
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    BOOL Pass;

    Pass = 0;

retry:
    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440d;

    //
    // bl = 1-based drive number
    // bh = lock level
    //
    RegistersIn.reg_EBX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_EBX |= (Level << 8);

    //
    // cl = lock or unlock volume code
    // ch = categoey, 8 on original Win95, 0x48 on OSR2
    //
    RegistersIn.reg_ECX = Lock ? 0x4a : 0x6a;
    RegistersIn.reg_ECX |= ((ISOSR2() && !Pass) ? 0x4800 : 0x800);

    //
    // dx = permissions
    //
    // bit 0 controls write operations (0 = disallowed)
    // bit 1 controls read operations  (0 = allowed)
    //
    RegistersIn.reg_EDX = 1;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    //
    // If OSR2, try form of call with 8 in ch instead of 48.
    //
    if(!b && ISOSR2() && !Pass) {
        Pass = 1;
        goto retry;
    }

    return(b);
}


BOOL
pGetWin9xLockFlagState (
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive,
    OUT PINT LockStatus
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;

    *LockStatus = 0;

    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440D;

    //
    // bx = 1-based drive number
    //
    RegistersIn.reg_EBX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;

    //
    // cx = 0x86C (get lock flag state)
    //
    RegistersIn.reg_ECX = 0x86C;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if (b) {
        if (RegistersOut.reg_Flags & 1) {
            b = FALSE;
        } else {
            *LockStatus = RegistersOut.reg_EAX;
        }
    }

    return b;
}


BOOL
ResetWin9xDisk (
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;

    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x710d;

    //
    // cx = 0 (reset & flush disk)
    //
    RegistersIn.reg_ECX = 0;

    //
    // dx = 1-based drive number
    //
    RegistersIn.reg_EDX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return b;
}


typedef HANDLE(WINAPI *OPENTHREAD)(DWORD, BOOL, DWORD);


BOOL
pMakeThreadExclusive (
    BOOL Lock
    )
{
    HANDLE h;
    THREADENTRY32 e;
    DWORD thisThread;
    HANDLE threadHandle;
    OPENTHREAD openThreadFn;
    HMODULE lib;
    BOOL result = FALSE;

    lib = LoadLibrary (TEXT("kernel32.dll"));
    if (!lib) {
        goto c0;
    }

    openThreadFn = (OPENTHREAD) GetProcAddress (lib, "OpenThread");
    if (!openThreadFn) {
        //
        // Must be Win98 or Win98SE -- change thread priority as workaround
        //

        if (Lock) {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
            Sleep (0);
        } else {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);
        }

        goto c1;
    }

    thisThread = GetCurrentThreadId();

    h = CreateToolhelp32Snapshot (TH32CS_SNAPTHREAD, 0);
    if (h == INVALID_HANDLE_VALUE) {
        goto c1;
    }

    e.dwSize = sizeof (e);

    if (Thread32First (h, &e)) {
        do {
            if (e.th32ThreadID != thisThread) {
                threadHandle = openThreadFn (THREAD_SUSPEND_RESUME, FALSE, e.th32ThreadID);
                if (threadHandle) {
                    if (Lock) {
                        SuspendThread (threadHandle);
                    } else {
                        ResumeThread (threadHandle);
                    }

                    CloseHandle (threadHandle);
                }
            }
        } while (Thread32Next (h, &e));
    }

    CloseHandle (h);
    result = TRUE;

c1:
    FreeLibrary (lib);

c0:
    return result;

}


BOOL
ReadOrWriteSectorsWin9x(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95.
    This routine will fail on Windows NT. After opening the VWIN32
    VxD, the routine determines whether to use the original algorithm
    or the OSR2 algorithm, and calls the appropriate worker routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set to something meaningful.

--*/

{
    HANDLE hVxd;
    BOOL b;
    DWORD d;
    INT level;
    INT retry = 100;

    //
    // This thread must be the exclusive thread in our process
    //

    pMakeThreadExclusive (TRUE);

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                Write ? GENERIC_WRITE : GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    //
    // Take out locks. We'll be as unrestrictive as possible.
    // The locking stuff is really funky. You have to pass in all kinds of
    // different parameters in OSR2 for reasons unknown. Also the
    // permissions bits are strangely encoded.
    //
    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,1,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c1;
    }

    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,2,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c2;
    }

    //
    // Try to get the level 3 lock. Retry if something happened while
    // getting the lock. Fail after too many retries.
    //

    do {

        if(!LockOrUnlockVolumeWin9x(hVxd,Drive,3,TRUE)) {
            d = ERROR_SHARING_VIOLATION;
            b = FALSE;
            goto c3;
        }

        if (!pGetWin9xLockFlagState (hVxd, Drive, &level)) {
            // unexpected -- INT 21h call failed
            break;
        }

        if (!level) {
            // We successfully got a clean level 3 lock
            break;
        }

        LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
        retry--;

    } while (retry);

    if (!retry) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c3;
    }

    //
    // Go do it.
    //
    b = ISOSR2()
      ? ReadOrWriteSectorsWin9xOsr2(hVxd,Drive,StartSector,SectorCount,Buffer,Write)
      : ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);

    //
    // If it failed, and OSR2 routine is being used, fall back to Win95 API.  This is a workaround
    // for Compaq because they ship OSR2 without the new OSR2 sector API support!
    //

    if (!b && ISOSR2()) {
        b = ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);
    }

    d = GetLastError();

    LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
c3:
    LockOrUnlockVolumeWin9x(hVxd,Drive,2,FALSE);
c2:
    LockOrUnlockVolumeWin9x(hVxd,Drive,1,FALSE);
c1:
    CloseHandle(hVxd);
c0:

    //
    // Resume all threads
    //

    pMakeThreadExclusive (FALSE);

    SetLastError(d);
    return(b);
}


BOOL
ReadOrWriteSectors(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk. Allocates a properly
    aligned buffer and decides whether to call NT- or Win9x-specific
    i/o routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. There are no alignment requirements on ths buffer.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    Last error is undisturbed from the operation that caused any failure.

--*/

{
    LPBYTE AlignedBuffer;
    LPBYTE p;
    BOOL b;
    DWORD d;

    //
    // Allocate a buffer we will align on a sector boundary.
    //
    if(AlignedBuffer = MALLOC((SectorCount * SectorSize) + (SectorSize - 1))) {

        if(d = (DWORD)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }

        if(Write) {
            CopyMemory(p,Buffer,SectorCount*SectorSize);
        }

        b = ReadOrWriteSectorsWin9x(Drive,StartSector,SectorCount,p,Write);

        d = GetLastError();

        if(b && !Write) {
            CopyMemory(Buffer,p,SectorCount*SectorSize);
        }

        FREE(AlignedBuffer);

    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(d);
    return(b);
}


BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    )

/*++

Routine Description:

    Read a set of disk sectors off a disk device.

Arguments:

    Drive - supplies drive letter of device to be read from.

    StartSector - supplies logical sector number of first sector to be read.

    SectorCount - supplies number of sectors to be read.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from.

    Buffer - if successful, receives data from the disk. There are no
        alignment requirements on ths buffer.

Return Value:

    Boolean value indicating whether the disk was read successfully.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,FALSE));
}


BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    )

/*++

Routine Description:

    Write data to a set of disk sectors.

Arguments:

    Drive - supplies drive letter of device to be written to.

    StartSector - supplies logical sector number of first sector to be written.

    SectorCount - supplies number of sectors to be written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be written to.

    Buffer - supplies data to be written. There are no alignment requirements
        on ths buffer.

Return Value:

    Boolean value indicating whether the disk was successfully written.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migpwd\migpwd.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migpwd.c

Abstract:

    Implements a simple password application that sets a default password
    for each local account created.  This application is placed in the
    RunOnce registry key when the Administrator account is set to auto-logon,
    and at least one other local account was created.

    The list of migrated local accounts is kept in

    HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\Win9xUpg\Users

    This app prompts the user for a password, explaining what exactly is going
    on, and then deletes the RunOnce and Users value on exit.


Author:

    Jim Schmidt (jimschm) 18-Mar-1998

Revision History:

    jimschm     06-Jul-1998     Added private stress option

--*/

#include "pch.h"
#include "resource.h"
#include "msg.h"

#include <lm.h>

//
// Constants
//

#define MAX_PASSWORD                64

//
// Globals
//

HINSTANCE g_hInst;
HANDLE g_hHeap;
UINT g_TotalUsers;
BOOL g_AutoPassword = FALSE;
TCHAR g_AutoLogonUser[256];
TCHAR g_AutoLogonPassword[MAX_PASSWORD + 1];

//
// !!! This is for internal use only !!!  It is used for auto stress.
//

#ifdef PRERELEASE

BOOL g_AutoStress = FALSE;
TCHAR g_AutoStressUser[MAX_USER_NAME];
TCHAR g_AutoStressPwd[MAX_PASSWORD];
TCHAR g_AutoStressOffice[32];
TCHAR g_AutoStressDbg[MAX_COMPUTER_NAME];
DWORD g_AutoStressFlags;

#endif


//
// Library prototypes
//

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    );


//
// Local prototypes
//

VOID
pCleanup (
    VOID
    );

BOOL
pIsAdministratorOnly (
    VOID
    );

BOOL
CALLBACK
PasswordProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
pIsBlankPasswordAllowed (
    VOID
    );

BOOL
pIsPersonal (
    VOID
    )
{
    static BOOL g_Determined = FALSE;
    static BOOL g_Personal = FALSE;
    OSVERSIONINFOEX osviex;

    //
    // Determine if Personal SKU
    //
    if (!g_Determined) {
        g_Determined = TRUE;
        osviex.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);
        if (GetVersionEx ((LPOSVERSIONINFO)&osviex)) {
            if (osviex.wProductType == VER_NT_WORKSTATION &&
                (osviex.wSuiteMask & VER_SUITE_PERSONAL)
                ) {
                g_Personal = TRUE;
            }
        }
    }
    return g_Personal;
}


//
// Implementation
//

INT
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    PSTR AnsiCmdLine,
    INT CmdShow
    )

/*++

Routine Description:

  The entry point to migpwd.exe.  All the work is done in a dialog box,
  so no message loop is necessary.

Arguments:

  hInstance     - The instance handle of this EXE
  hPrevInstance - The previous instance handle of this EXE if it is
                  running, or NULL if no other instances exist.
  AnsiCmdLine   - The command line (ANSI version)
  CmdShow       - The ShowWindow command passed by the shell

Return Value:

  Returns -1 if an error occurred, or 0 if the exe completed. The exe
  will automatically terminate with 0 if the migration DLL throws an
  exception.

--*/

{
    UINT Result;
    PCTSTR ArgArray[1];
    TCHAR UserName[MAX_USER_NAME];
    DWORD Size;
    HCURSOR OldCursor;
    INITCOMMONCONTROLSEX init = {sizeof (INITCOMMONCONTROLSEX), 0};
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR winDir[MAX_PATH];
    PTSTR oobeBalnPath;
    PTSTR cmdLine;
    BOOL ProcessResult;

#ifdef PRERELEASE
    HKEY Key;
    PCTSTR Data;
#endif

    InitCommonControlsEx (&init);

    g_hInst = hInstance;
    g_hHeap = GetProcessHeap();

    OldCursor = SetCursor (LoadCursor (NULL, IDC_ARROW));

    MigUtil_Entry (hInstance, DLL_PROCESS_ATTACH, NULL);

#ifdef PRERELEASE

    Key = OpenRegKeyStr (S_AUTOSTRESS_KEY);
    if (Key) {
        g_AutoStress = TRUE;

        Data = GetRegValueString (Key, S_AUTOSTRESS_USER);
        if (Data) {
            StringCopy (g_AutoStressUser, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_PASSWORD);
        if (Data) {
            StringCopy (g_AutoStressPwd, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_OFFICE);
        if (Data) {
            StringCopy (g_AutoStressOffice, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_DBG);
        if (Data) {
            StringCopy (g_AutoStressDbg, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_FLAGS);
        if (Data) {
            g_AutoStressFlags = _tcstoul (Data, NULL, 10);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        CloseRegKey (Key);
    }

#endif

    //
    // Launch oobebaln.exe /init
    //

    ZeroMemory (&si, sizeof (si));
    si.cb = sizeof (si);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;

    if (!GetWindowsDirectory (winDir, ARRAYSIZE(winDir))) {
        StringCopy (winDir, TEXT("c:\\windows"));
    }

    oobeBalnPath = JoinPaths (winDir, TEXT("system32\\oobe\\oobebaln.exe"));
    cmdLine = JoinText (oobeBalnPath, TEXT(" /init"));

    ProcessResult = CreateProcess (
                        oobeBalnPath,
                        cmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_DEFAULT_ERROR_MODE,
                        NULL,
                        NULL,
                        &si,
                        &pi
                        );

    if (ProcessResult) {
        CloseHandle (pi.hThread);
        CloseHandle (pi.hProcess);
    } else {
        LOG ((LOG_ERROR, "Cannot start %s", cmdLine));
    }

    FreePathString (oobeBalnPath);
    FreeText (cmdLine);


    //
    // Set passwords
    //

    if (pIsAdministratorOnly()) {
        DEBUGMSG ((DBG_VERBOSE, "Calling Adminitrator password dialog"));
        Result = DialogBox (
                     hInstance,
                     MAKEINTRESOURCE(IDD_ADMIN_PASSWORD_DLG),
                     NULL,
                     PasswordProc
                     );
    } else {
        DEBUGMSG ((DBG_VERBOSE, "Calling multi user password dialog"));
        Result = DialogBox (
                     hInstance,
                     MAKEINTRESOURCE(IDD_PASSWORD_DLG),
                     NULL,
                     PasswordProc
                     );
    }

    if (Result == IDOK) {
        Size = MAX_USER_NAME;
        GetUserName (UserName, &Size);
        ArgArray[0] = UserName;

        pCleanup();

#ifdef PRERELEASE
        if (!g_AutoStress) {
#endif

        //if (g_TotalUsers) {
        //    ResourceMessageBox (NULL, MSG_YOU_ARE_ADMIN, MB_ICONINFORMATION|MB_OK, ArgArray);
        //}

#ifdef PRERELEASE
        } else {
            NETRESOURCE nr;
            LONG rc;
            TCHAR CmdLine[MAX_TCHAR_PATH];
            STARTUPINFO si;
            PROCESS_INFORMATION pi;
            PTSTR UserName;
            TCHAR StressCmdLine[MAX_TCHAR_PATH];
            TCHAR NtDevDomain[MAX_COMPUTER_NAME];
            TCHAR Msg[1024];

            //
            // Autostress: Create connection to \\ntstress or \\ntstress2
            //             Turn on autologon
            //             Create Run key for stress
            //             Run munge /p
            //

            nr.dwType = RESOURCETYPE_ANY;
            nr.lpLocalName = TEXT("s:");
            nr.lpRemoteName = TEXT("\\\\ntstress\\stress");
            nr.lpProvider = NULL;

            rc = WNetAddConnection2 (&nr, g_AutoStressPwd, g_AutoStressUser, 0);

            if (rc != ERROR_SUCCESS) {
                nr.lpRemoteName = TEXT("\\\\ntstress2\\stress");
                rc = WNetAddConnection2 (&nr, g_AutoStressPwd, g_AutoStressUser, 0);
            }

            if (rc == ERROR_SUCCESS) {
                // Prepare command line
                StringCopy (NtDevDomain, g_AutoStressUser);
                UserName = _tcschr (NtDevDomain, TEXT('\\'));
                if (UserName) {
                    *UserName = 0;
                    UserName++;
                } else {
                    UserName = g_AutoStressUser;
                    StringCopy (NtDevDomain, TEXT("ntdev"));
                }

                wsprintf (
                    StressCmdLine,
                    TEXT("%s\\stress.cmd /o %s /n %s /d c:\\stress /k %s /g"),
                    nr.lpRemoteName,
                    g_AutoStressOffice,
                    UserName,
                    g_AutoStressDbg
                    );

                if (g_AutoStressFlags & AUTOSTRESS_PRIVATE) {
                    StringCat (StressCmdLine, TEXT(" /P"));
                }

                if (g_AutoStressFlags & AUTOSTRESS_MANUAL_TESTS) {
                    StringCat (StressCmdLine, TEXT(" /M"));
                }

                // Turn on autologon
                Key = OpenRegKeyStr (S_WINLOGON_REGKEY);
                MYASSERT (Key);

                RegSetValueEx (
                    Key,
                    S_AUTOADMIN_LOGON_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) TEXT("1"),
                    sizeof (TCHAR) * 2
                    );

                RegSetValueEx (
                    Key,
                    S_DEFAULT_USER_NAME_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) UserName,
                    SizeOfString (UserName)
                    );

                RegSetValueEx (
                    Key,
                    S_DEFAULT_PASSWORD_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) g_AutoStressPwd,
                    SizeOfString (g_AutoStressPwd)
                    );

                RegSetValueEx (
                    Key,
                    S_DEFAULT_DOMAIN_NAME_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) NtDevDomain,
                    SizeOfString (NtDevDomain)
                    );

                CloseRegKey (Key);

                // Prepare the launch of stress
                Key = OpenRegKeyStr (S_RUN_KEY);
                MYASSERT (Key);

                RegSetValueEx (
                    Key,
                    TEXT("Stress"),
                    0,
                    REG_SZ,
                    (PBYTE) StressCmdLine,
                    SizeOfString (StressCmdLine)
                    );

                CloseRegKey (Key);

                // Run munge /p /q /y (to set preferred stress settings and reboot)
                wsprintf (CmdLine, TEXT("%s\\munge.bat /p /q /y"), nr.lpRemoteName);
                ZeroMemory (&si, sizeof (si));
                si.cb = sizeof (si);

                if (!CreateProcess (
                        NULL,
                        CmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        0,
                        NULL,
                        NULL,
                        &si,
                        &pi
                        )) {
                    wsprintf (Msg, TEXT("Can't start %s.  rc=%u"), CmdLine, GetLastError());
                    MessageBox (NULL, Msg, NULL, MB_OK);

                }

            } else {
                wsprintf (Msg, TEXT("Can't connect to ntstress or ntstress2.  rc=%u"), GetLastError());
                MessageBox (NULL, Msg, NULL, MB_OK);
            }
        }
#endif
    }

    MigUtil_Entry (hInstance, DLL_PROCESS_DETACH, NULL);
    SetCursor (OldCursor);

    return 0;
}


VOID
pCopyRegString (
    IN      HKEY DestKey,
    IN      HKEY SrcKey,
    IN      PCTSTR SrcValue
    )

/*++

Routine Description:

  pCopyRegString copies a REG_SZ value from one key to another.  If the value
  does not exist or is not a REG_SZ, nothing is copied.

Arguments:

  DestKey  - Specifies the destination key handle
  SrcKey   - Specifies the source key handle
  SrcValue - Specifies the value in SrcKey to copy

Return Value:

  None.

--*/

{
    PCTSTR Data;

    Data = GetRegValueString (SrcKey, SrcValue);
    if (Data) {
        RegSetValueEx (
            DestKey,
            SrcValue,
            0,
            REG_SZ,
            (PBYTE) Data,
            SizeOfString (Data)
            );

        MemFree (g_hHeap, 0, Data);
    }
}


VOID
pCleanup (
    VOID
    )

/*++

Routine Description:

  pCleanup performs all cleanup necessary to remove auto-logon and migpwd.exe.

Arguments:

  None.

Return Value:

  None.

--*/

{
    HKEY Key;
    HKEY DestKey;
    TCHAR ExeName[MAX_PATH];

    //
    // This is the place where we will delete the Run or RunOnce entry,
    // remove the Setup\Win9xUpg\Users key, remove the auto logon,
    // and delete this EXE.
    //

    Key = OpenRegKeyStr (S_RUNONCE_KEY);
    if (Key) {
        RegDeleteValue (Key, S_MIGPWD);
        CloseRegKey (Key);
    }

    Key = OpenRegKeyStr (S_RUN_KEY);
    if (Key) {
        RegDeleteValue (Key, S_MIGPWD);
        CloseRegKey (Key);
    }

    Key = OpenRegKeyStr (S_WINLOGON_REGKEY);
    if (Key) {
        RegDeleteValue (Key, S_AUTOADMIN_LOGON_VALUE);
        RegDeleteValue (Key, S_DEFAULT_PASSWORD_VALUE);
        CloseRegKey (Key);
    }

    Key = OpenRegKeyStr (S_WIN9XUPG_KEY);
    if (Key) {
        RegDeleteKey (Key, S_USERS_SUBKEY);
        CloseRegKey (Key);
    }

    GetModuleFileName (NULL, ExeName, MAX_PATH);
    MoveFileEx (ExeName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);

    //
    // Transfer auto logon from Win9xUpg
    //

    Key = OpenRegKeyStr (S_WIN9XUPG_KEY);

    if (Key) {
        DestKey = OpenRegKeyStr (S_WINLOGON_REGKEY);

        if (DestKey) {
            pCopyRegString (DestKey, Key, S_AUTOADMIN_LOGON_VALUE);

            if (g_AutoLogonUser[0]) {
                //
                // We changed the password for this user
                //

                RegSetValueEx (
                    DestKey,
                    S_DEFAULT_PASSWORD_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) g_AutoLogonPassword,
                    SizeOfString (g_AutoLogonPassword)
                    );
            } else {
                pCopyRegString (DestKey, Key, S_DEFAULT_PASSWORD_VALUE);
            }

            pCopyRegString (DestKey, Key, S_DEFAULT_USER_NAME_VALUE);
            pCopyRegString (DestKey, Key, S_DEFAULT_DOMAIN_NAME_VALUE);

            CloseRegKey (DestKey);
        }

        CloseRegKey (Key);
    }
}


BOOL
pSetUserPassword (
    IN      PCTSTR User,
    IN      PCTSTR Password
    )

/*++

Routine Description:

  pSetUserPassword changes the password on the specified user account.

Arguments:

  User     - Specifies the user name to change
  Password - Specifies the new password

Return Value:

  TRUE if the password was changed, or FALSE if an error occurred.

--*/

{
    LONG rc;
    PCWSTR UnicodeUser;
    PCWSTR UnicodePassword;
    PUSER_INFO_1 ui1;

    UnicodeUser     = CreateUnicode (User);
    UnicodePassword = CreateUnicode (Password);

    rc = NetUserGetInfo (NULL, (PWSTR) UnicodeUser, 1, (PBYTE *) (&ui1));

    if (rc != NO_ERROR) {
        SetLastError (rc);
        DEBUGMSG ((DBG_ERROR, "User %s does not exist", User));
        rc = NO_ERROR;
    } else {

        ui1->usri1_password = (PWSTR) UnicodePassword;

        rc = NetUserSetInfo (NULL, (PWSTR) UnicodeUser, 1, (PBYTE) ui1, NULL);

        NetApiBufferFree ((PVOID) ui1);

    }

    DestroyUnicode (UnicodeUser);
    DestroyUnicode (UnicodePassword);

    DEBUGMSG_IF ((rc != NO_ERROR, DBG_ERROR, "Password could not be set, rc=%u", rc));

    SetLastError (rc);
    return rc == NO_ERROR;
}


BOOL
CALLBACK
PasswordProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  PasswordProc is the dialog procedure for the password dialog.  It
  initializes the list box with the names of all new accounts.  When the user
  choses Change, the password is tested and changed if possible.  A popup is
  presented if the user tries to enter a blank password.

Arguments:

  hdlg   - Dialog window handle
  uMsg   - Message to process
  wParam - Message-specific
  lParam - Message-specific

Return Value:

  TRUE if the message was processed, or FALSE if the message should be
  processed by the OS.

--*/

{
    HKEY Key;
    HKEY win9xUpgKey;
    static HWND List;
    REGVALUE_ENUM e;
    PCTSTR Data;
    //LONG Index;
    //LONG Count;
    TCHAR Pwd[MAX_PASSWORD + 1];
    TCHAR ConfirmPwd[MAX_PASSWORD + 1];
    static HWND Edit1, Edit2;
    GROWBUFFER Line = GROWBUF_INIT;
    BOOL b;
    SIZE Size;
    INT MaxWidth;
    INT IntegralWidth;
    TEXTMETRIC tm;
    HDC dc;
    RECT rect;
    DWORD bufSize;
    TCHAR computerName[MAX_PATH];
    PCTSTR domainName;
    BOOL changingAutoLogonPwd;

    *Pwd = 0;
    *ConfirmPwd = 0;

    switch (uMsg) {

    case WM_INITDIALOG:

        //
        // Enable a timer so the dialog never goes to sleep
        // and we ensure it's always the foreground window
        //

        SetTimer (hdlg, 1, 30000, NULL);
        SetTimer (hdlg, 2, 1000, NULL);

        //
        // Fill list box with user names from registry
        //

        List = GetDlgItem (hdlg, IDC_USER_LIST);
        Edit1 = GetDlgItem (hdlg, IDC_PASSWORD);
        Edit2 = GetDlgItem (hdlg, IDC_CONFIRM);

        SendMessage (Edit1, EM_LIMITTEXT, MAX_PASSWORD, 0);
        SendMessage (Edit2, EM_LIMITTEXT, MAX_PASSWORD, 0);

        g_TotalUsers = 0;

        if (List) {
            //
            // Compute text metrics for list
            //

            dc = CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL);

            SelectObject (dc, (HFONT) SendMessage (List, WM_GETFONT, 0, 0));
            GetTextMetrics (dc, &tm);

            Key = OpenRegKeyStr (S_USER_LIST_KEY);
            if (Key) {
                //
                // Enumerate the users in this key.  Data is saved with
                // each list entry, though it is not currently used.
                //

                MaxWidth = 0;

                if (EnumFirstRegValue (&e, Key)) {
                    do {
                        Data = GetRegValueString (e.KeyHandle, e.ValueName);
                        if (Data) {

                            GetTextExtentPoint (
                                dc,
                                e.ValueName,
                                TcharCount (e.ValueName),
                                &Size
                                );

                            MaxWidth = max (MaxWidth, Size.cx);

                            if (g_TotalUsers) {
                                GrowBufAppendString (&Line, TEXT("\t"));
                            }

                            GrowBufAppendString (&Line, e.ValueName);
                            g_TotalUsers++;

                            MemFree (g_hHeap, 0, Data); // edit ctrl version

                            //
                            // List box code:
                            //
                            //
                            //Index = SendMessage (
                            //            List,
                            //            LB_ADDSTRING,
                            //            0,
                            //            (LPARAM) e.ValueName
                            //            );
                            //
                            //MYASSERT (Index != LB_ERR);
                            //SendMessage (
                            //    List,
                            //    LB_SETITEMDATA,
                            //    Index,
                            //    (LPARAM) Data
                            //    );
                            //
                            // free Data later
                        }

                    } while (EnumNextRegValue (&e));
                }

                GrowBufAppendString (&Line, TEXT("\r\n"));
                SetWindowText (List, (PCTSTR) Line.Buf);

                MaxWidth += tm.tmAveCharWidth * 2;

                GetWindowRect (List, &rect);

                IntegralWidth = (rect.right - rect.left) / MaxWidth;
                IntegralWidth = max (IntegralWidth, 1);

                MaxWidth = IntegralWidth * (rect.right - rect.left);

                rect.left = 0;
                rect.right = 100;
                rect.top = 0;
                rect.bottom = 100;

                MapDialogRect (hdlg, &rect);

                MaxWidth = (MaxWidth * 100) / (rect.right - rect.left);

                SendMessage (List, EM_SETTABSTOPS, 1, (LPARAM) (&MaxWidth));

                CloseRegKey (Key);
                DeleteDC (dc);
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "%s not found", S_USER_LIST_KEY));

            FreeGrowBuffer (&Line);

            if (!g_TotalUsers) {
                EndDialog (hdlg, IDOK);
            } else {
                SetForegroundWindow (hdlg);
            }
        }

        if (pIsPersonal ()) {
            g_AutoPassword = TRUE;
            PostMessage (hdlg, WM_COMMAND, IDOK, 0);
        }
#ifdef PRERELEASE
        //
        // !!! This is for internal use only !!!  It is used for auto stress.
        //

        else if (g_AutoStress) {
            PostMessage (hdlg, WM_COMMAND, IDOK, 0);
        }
#endif

        return FALSE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (pIsPersonal () && g_AutoPassword) {
                StringCopy (Pwd, TEXT(""));
                StringCopy (ConfirmPwd, Pwd);
            } else {
                GetWindowText (Edit1, Pwd, MAX_PASSWORD + 1);
                GetWindowText (Edit2, ConfirmPwd, MAX_PASSWORD + 1);
                if (lstrcmp (Pwd, ConfirmPwd)) {
                    OkBox (hdlg, MSG_PASSWORDS_DO_NOT_MATCH);
                    SetWindowText (Edit1, S_EMPTY);
                    SetWindowText (Edit2, S_EMPTY);
                    SetFocus (Edit1);
                    break;
                }
#ifdef PRERELEASE
                //
                // !!! This is for internal use only !!!  It is used for auto stress.
                //

                if (g_AutoStress) {
                    StringCopy (Pwd, TEXT("Password1"));
                    StringCopy (ConfirmPwd, Pwd);
                }
#endif

                if (*Pwd == 0) {
                    if (pIsBlankPasswordAllowed()) {
                        //
                        // Don't warn about blank passwords, since on Whistler they
                        // are safe.
                        //
                        //if (IDYES != YesNoBox (hdlg, MSG_EMPTY_PASSWORD_WARNING)) {
                        //    break;
                        //}
                    } else {
                        OkBox (hdlg, MSG_MUST_SPECIFY_PASSWORD);
                        break;
                    }
                }
            }

            //
            // Enumerate all the users and set the password on each
            //

            b = TRUE;
            Key = OpenRegKeyStr (S_USER_LIST_KEY);
            if (Key) {
                //
                // Get the user name & pwd of the autologon (if any)
                //

                g_AutoLogonUser[0] = 0;
                g_AutoLogonPassword[0] = 0;

                bufSize = ARRAYSIZE (computerName);
                if (GetComputerName (computerName, &bufSize)) {
                    win9xUpgKey = OpenRegKeyStr (S_WIN9XUPG_KEY);

                    if (win9xUpgKey) {

                        domainName = GetRegValueString (win9xUpgKey, S_DEFAULT_DOMAIN_NAME_VALUE);
                        if (domainName) {
                            if (StringIMatch (computerName, domainName)) {

                                //
                                // Process local accounts only
                                //

                                Data = GetRegValueString (win9xUpgKey, S_DEFAULT_USER_NAME_VALUE);
                                if (Data) {
                                    StringCopyByteCount (g_AutoLogonUser, Data, sizeof(g_AutoLogonUser));
                                    MemFree (g_hHeap, 0, Data);
                                }
                            }
                            ELSE_DEBUGMSG ((DBG_VERBOSE, "Autologon set for non-local user (domain is %s)", domainName));

                            MemFree (g_hHeap, 0, domainName);
                        }

                        CloseRegKey (win9xUpgKey);
                    }
                }

                //
                // Enumerate the users in this key
                //

                changingAutoLogonPwd = FALSE;

                if (EnumFirstRegValue (&e, Key)) {
                    do {

                        if (g_AutoLogonUser[0]) {
                            if (!changingAutoLogonPwd && StringIMatch (e.ValueName, g_AutoLogonUser)) {
                                changingAutoLogonPwd = TRUE;
                                StringCopy (g_AutoLogonPassword, Pwd);
                            }
                        }

                        if (!pSetUserPassword (e.ValueName, Pwd)) {
                            if (!g_AutoPassword) {
                                if (GetLastError() == NERR_PasswordTooShort) {
                                    OkBox (hdlg, MSG_PASSWORD_TOO_SHORT);
                                } else {
                                    OkBox (hdlg, MSG_PASSWORD_INVALID);
                                }
                            }

                            b = FALSE;
                            g_AutoPassword = FALSE;
                            break;
                        }

                    } while (EnumNextRegValue (&e));
                }

                //
                // NOTE: b might be FALSE; changingAutoLogonPwd only matters
                // when b is TRUE, because we just stay in the dialog until
                // then.
                //

                if (b && !changingAutoLogonPwd) {
                    g_AutoLogonUser[0] = 0;
                }

                CloseRegKey (Key);
            }

            if (b) {
                EndDialog (hdlg, LOWORD (wParam));
            }

            break;
        }
        break;

    case WM_TIMER:
        if (wParam == 2) {
            //
            //  This timer ensures we have the keyboard focus
            //  even if another process tries to take it while
            //  the dialog is being shown.
            //
            if (GetForegroundWindow () != hdlg) {
                SetForegroundWindow (hdlg);
            }
        } else {
            //
            // Make this thread a no-sleep thread
            //
            SetThreadExecutionState (ES_SYSTEM_REQUIRED|ES_DISPLAY_REQUIRED|ES_CONTINUOUS);
        }
        break;

    case WM_DESTROY:

        KillTimer (hdlg, 1);
        KillTimer (hdlg, 2);

        //List = GetDlgItem (hdlg, IDC_LIST);
        //if (List) {
        //
        //    Count = SendMessage (List, LB_GETCOUNT, 0, 0);
        //    for (Index = 0 ; Index < Count ; Index++) {
        //        Data = (PCTSTR) SendMessage (List, LB_GETITEMDATA, Index, 0);
        //        if (Data) {
        //            MemFree (g_hHeap, 0, Data);
        //        }
        //    }
        //}

        break;

    }


    return FALSE;
}


BOOL
pIsAdministratorOnly (
    VOID
    )
{
    BOOL NonAdminExists = FALSE;
    PCTSTR AdministratorName;
    HKEY Key;
    REGVALUE_ENUM e;
    PCTSTR Data;
    BOOL AdministratorExists = FALSE;

    AdministratorName = GetStringResource (MSG_ADMINISTRATOR);
    MYASSERT (AdministratorName);

    Key = OpenRegKeyStr (S_USER_LIST_KEY);
    if (Key) {
        //
        // Enumerate the users in this key.  Data is saved with
        // each list entry, though it is not currently used.
        //

        if (EnumFirstRegValue (&e, Key)) {
            do {
                Data = GetRegValueString (e.KeyHandle, e.ValueName);
                if (Data) {
                    if (!StringIMatch (e.ValueName, AdministratorName)) {
                        NonAdminExists = TRUE;
                    } else {
                        AdministratorExists = TRUE;
                    }

                    MemFree (g_hHeap, 0, Data);
                }

            } while (EnumNextRegValue (&e));
        }

        CloseRegKey (Key);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "%s not found", S_USER_LIST_KEY));

    FreeStringResource (AdministratorName);

    return !NonAdminExists && AdministratorExists;
}



BOOL
pIsBlankPasswordAllowed (
    VOID
    )
{
    PUSER_MODALS_INFO_0 umi;
    NET_API_STATUS rc;
    BOOL b;

    rc = NetUserModalsGet (
            NULL,
            0,
            (PBYTE *) &umi
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);
        DEBUGMSG ((DBG_ERROR, "Can't get password policy info"));
        return TRUE;
    }

    b = (umi->usrmod0_min_passwd_len == 0);

    NetApiBufferFree ((PVOID) umi);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\migpwd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDC_OPTIONS                     2
#define IDD_PASSWORD_DLG                102
#define IDI_KEYS                        103
#define IDD_ADMIN_PASSWORD_DLG          103
#define IDC_LIST                        1000
#define IDC_EDIT1                       1001
#define IDC_PASSWORD                    1001
#define IDC_EDIT2                       1002
#define IDC_CONFIRM                     1002
#define IDC_USER_LIST                   1004
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appc_cnv\appc_cnv.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    appc_cnv.c

Abstract:

Author:

    Calin Negreanu (calinn) 25-Mar-1999

Revision History:

    <alias> <date> <comments>

--*/

#ifndef UNICODE
#error UNICODE needs to be defined
#else
#define _UNICODE
#endif

#include <windows.h>
#include <tchar.h>
#include <winnt.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <badapps.h>

BOOL CancelFlag = FALSE;
BOOL *g_CancelFlagPtr = &CancelFlag;

#ifdef DEBUG
extern BOOL g_DoLog;
#endif

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL     g_UseInf = FALSE;
PCTSTR   g_DestInf = NULL;
DWORD    g_ValueSeq = 0;

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "tstbadap [-i:<inffile>]\n\n"
            "Optional Arguments:\n"
            "  -i:<inffile>    - Specifies INF file that will contain CheckBadApps data.\n"
            );

    exit(255);
}

BOOL
DoesFileExistW(
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData
    );


BOOL
pWorkerFn (
    VOID
    );

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    INT i;
    WCHAR destInf[MAX_PATH];

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'i':
                g_UseInf = TRUE;
                if (argv[i][2] == ':') {
                    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, &argv[i][3], -1, destInf, MAX_PATH);
                    g_DestInf = destInf;
                } else if (i + 1 < argc) {
                    i++;
                    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, argv[i], -1, destInf, MAX_PATH);
                    g_DestInf = destInf;
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            HelpAndExit();
        }
    }

    if ((g_UseInf) && (g_DestInf == NULL)) {
        HelpAndExit();
    }

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    pWorkerFn ();

    return 0;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    );

#define S_CHECK_BAD_APPS        TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps")
#define S_CHECK_BAD_APPS_400    TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps400")

#define S_APP_COMPATIBILITY     TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\~AppCompatibility")

BOOL
OutputStrValue (
    IN      PCTSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PTSTR result;

    *Size = (_tcslen (VersionValue) + 1) * sizeof (TCHAR);
    result = HeapAlloc (g_hHeap, 0, *Size);
    if (!result) {
        return FALSE;
    }
    _tcscpy (result, VersionValue);
    *Data = (PBYTE)result;
    return TRUE;
}

typedef struct {
    ULONGLONG Value;
    ULONGLONG Mask;
} BINVER_DATA, *PBINVER_DATA;

BOOL
OutputBinVerValue (
    IN      PCTSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PBINVER_DATA result;
    PWORD maskIdx;
    PWORD valueIdx;
    UINT index;

    result = HeapAlloc (g_hHeap, 0, sizeof (BINVER_DATA));
    if (!result) {
        return FALSE;
    }
    result->Value = 0;
    result->Mask = 0;
    *Size = sizeof (BINVER_DATA);

    maskIdx = (PWORD)&(result->Mask) + 3;
    valueIdx = (PWORD)&(result->Value) + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) _tcstoul ((PTSTR)VersionValue, &((PTSTR)VersionValue), 10);
        if (*VersionValue && (_tcsnextc (VersionValue) != TEXT('.'))) {
            return 0;
        }
        VersionValue = _tcsinc (VersionValue);
        *maskIdx = 0xFFFF;
        valueIdx --;
        maskIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

BOOL
OutputUpToBinVerValue (
    IN      PCTSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PULONGLONG result;
    PWORD valueIdx;
    UINT index;

    result = HeapAlloc (g_hHeap, 0, sizeof (ULONGLONG));
    if (!result) {
        return FALSE;
    }
    *result = 0;
    *Size = sizeof (ULONGLONG);

    valueIdx = (PWORD)result + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) _tcstoul ((PTSTR)VersionValue, &((PTSTR)VersionValue), 10);
        if (*VersionValue && (_tcsnextc (VersionValue) != TEXT('.'))) {
            return 0;
        }
        VersionValue = _tcsinc (VersionValue);
        valueIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

VOID
pPrintBadAppsData (
    PCTSTR BadAppsName,
    PCTSTR AddnlBadAppsName,
    PCTSTR KeyName,
    PCTSTR ValueName,
    DWORD MsgId,
    DWORD AppType,
    BOOL AppBinVer,
    PCTSTR AppBinVerData
    )
{
    BYTE blob [8192];
    PBYTE blobPtr;
    BADAPP_PROP appProp;
    DWORD verId;
    PBYTE Data;
    DWORD DataSize;

    LONG status;
    HKEY addnlKey;
    HKEY exeKey;
    TCHAR valueName [MAX_PATH];

    blobPtr = blob;
    appProp.Size = sizeof (BADAPP_PROP);
    appProp.MsgId = MsgId;
    appProp.AppType = AppType;
    CopyMemory (blobPtr, &appProp, sizeof (BADAPP_PROP));
    blobPtr += sizeof (BADAPP_PROP);
    if (AppBinVer) {
        verId = VTID_UPTOBINPRODUCTVER;
        CopyMemory (blobPtr, &verId, sizeof (DWORD));
        blobPtr += sizeof (DWORD);
        OutputUpToBinVerValue (AppBinVerData, &DataSize, &Data);
        CopyMemory (blobPtr, &DataSize, sizeof (DWORD));
        blobPtr += sizeof (DWORD);
        CopyMemory (blobPtr, Data, DataSize);
        blobPtr += DataSize;
        HeapFree (g_hHeap, 0, Data);
    }
    verId = VTID_REQFILE;
    CopyMemory (blobPtr, &verId, sizeof (DWORD));
    blobPtr += sizeof (DWORD);
    OutputStrValue (ValueName, &DataSize, &Data);
    CopyMemory (blobPtr, &DataSize, sizeof (DWORD));
    blobPtr += sizeof (DWORD);
    CopyMemory (blobPtr, Data, DataSize);
    blobPtr += DataSize;
    HeapFree (g_hHeap, 0, Data);
    DataSize = 0;
    CopyMemory (blobPtr, &DataSize, sizeof (DWORD));
    blobPtr += sizeof (DWORD);

    if (g_UseInf) {

    } else {
        status = RegCreateKey (HKEY_LOCAL_MACHINE, AddnlBadAppsName, &addnlKey);
        if (status == ERROR_SUCCESS) {
            status = RegCreateKey (addnlKey, KeyName, &exeKey);
            if (status == ERROR_SUCCESS) {
                _itot (g_ValueSeq, valueName, 10);
                RegSetValueEx (exeKey, valueName, 0, REG_BINARY, blob, blobPtr - blob);
            }
        }
    }
}

BOOL
pWorkerFn (
    VOID
    )
{
    HKEY badAppKey = NULL;
    TCHAR exeKeyStr [MAX_PATH + 1];
    DWORD idxKey = 0;
    LONG statKey;
    HKEY exeKey = NULL;
    LONG status;
    DWORD index;
    TCHAR valueName [MAX_PATH];
    DWORD valueSize;
    DWORD valueType;
    DWORD blobSize;
    BYTE blobData[4096];
    DWORD msgId;
    DWORD appType;
    BOOL appBinVer;
    TCHAR appBinVerStr[MAX_PATH];
    TCHAR flagsValue [MAX_PATH];
    TCHAR binVerValue [MAX_PATH];
    BYTE addnlData[4096];
    PCTSTR flagsPtr;
    DWORD addnlSize;

    if (RegOpenKey (HKEY_LOCAL_MACHINE, S_CHECK_BAD_APPS, &badAppKey) == ERROR_SUCCESS) {
        idxKey = 0;
        statKey = ERROR_SUCCESS;
        while (statKey == ERROR_SUCCESS) {
            statKey = RegEnumKey (badAppKey, idxKey, exeKeyStr, MAX_PATH + 1);
            if (statKey == ERROR_SUCCESS) {
                if (RegOpenKey (badAppKey, exeKeyStr, &exeKey) == ERROR_SUCCESS) {
                    index = 0;
                    status = ERROR_SUCCESS;
                    while (status == ERROR_SUCCESS) {
                        blobSize = 4096;
                        valueSize = MAX_PATH;
                        status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, blobData, &blobSize);
                        if ((status == ERROR_SUCCESS) ||
                            (status == ERROR_MORE_DATA)
                            ) {
                            if (valueType == REG_SZ) {
                                msgId = 0;
                                appType = 0;
                                appBinVer = FALSE;
                                msgId = _ttoi ((PCTSTR) blobData);
                                if (msgId) {
                                    g_ValueSeq ++;
                                    _tcscpy (flagsValue, TEXT("Flags"));
                                    _tcscat (flagsValue, valueName);
                                    _tcscpy (binVerValue, TEXT("Version"));
                                    _tcscat (binVerValue, valueName);

                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, flagsValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))  && (valueType == REG_SZ)) {
                                        flagsPtr = (PCTSTR) addnlData;
                                        while (*flagsPtr) {
                                            if (_tcsnextc (flagsPtr) == TEXT('Y')) {
                                                appType = appType | APPTYPE_INC_HARDBLOCK;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('L')) {
                                                appType = appType | APPTYPE_MINORPROBLEM;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('N')) {
                                                appType = appType | APPTYPE_FLAG_NONET;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('F')) {
                                                appType = appType | APPTYPE_FLAG_FAT32;
                                            }
                                            flagsPtr = _tcsinc (flagsPtr);
                                        }
                                    }
                                    if ((appType & APPTYPE_TYPE_MASK) == 0) {
                                        appType |= APPTYPE_INC_NOBLOCK;
                                    }
                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, binVerValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) && (valueType == REG_BINARY)) {
                                        PWORD valueIdx;
                                        appBinVer = TRUE;
                                        valueIdx = (PWORD) (addnlData);
                                        _stprintf (appBinVerStr, TEXT("%d.%d.%d.%d"), *(valueIdx + 1), *valueIdx, *(valueIdx + 3), *(valueIdx + 2));
                                    }

                                    pPrintBadAppsData (
                                        S_CHECK_BAD_APPS,
                                        S_APP_COMPATIBILITY,
                                        exeKeyStr,
                                        valueName,
                                        msgId,
                                        appType,
                                        appBinVer,
                                        appBinVerStr
                                        );

                                    status = ERROR_SUCCESS;
                                }
                            }
                        }
                        index ++;
                    }
                }
            }
            idxKey ++;
        }
    }
    if (RegOpenKey (HKEY_LOCAL_MACHINE, S_CHECK_BAD_APPS_400, &badAppKey) == ERROR_SUCCESS) {
        idxKey = 0;
        statKey = ERROR_SUCCESS;
        while (statKey == ERROR_SUCCESS) {
            statKey = RegEnumKey (badAppKey, idxKey, exeKeyStr, MAX_PATH + 1);
            if (statKey == ERROR_SUCCESS) {
                if (RegOpenKey (badAppKey, exeKeyStr, &exeKey) == ERROR_SUCCESS) {
                    index = 0;
                    status = ERROR_SUCCESS;
                    while (status == ERROR_SUCCESS) {
                        blobSize = 4096;
                        valueSize = MAX_PATH;
                        status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, blobData, &blobSize);
                        if ((status == ERROR_SUCCESS) ||
                            (status == ERROR_MORE_DATA)
                            ) {
                            if (valueType == REG_SZ) {
                                msgId = 0;
                                appType = 0;
                                appBinVer = FALSE;
                                msgId = _ttoi ((PCTSTR) blobData);
                                if (msgId) {
                                    g_ValueSeq ++;
                                    _tcscpy (flagsValue, TEXT("Flags"));
                                    _tcscat (flagsValue, valueName);
                                    _tcscpy (binVerValue, TEXT("Version"));
                                    _tcscat (binVerValue, valueName);

                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, flagsValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))  && (valueType == REG_SZ)) {
                                        flagsPtr = (PCTSTR) addnlData;
                                        while (*flagsPtr) {
                                            if (_tcsnextc (flagsPtr) == TEXT('Y')) {
                                                appType = appType | APPTYPE_INC_HARDBLOCK;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('L')) {
                                                appType = appType | APPTYPE_MINORPROBLEM;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('N')) {
                                                appType = appType | APPTYPE_FLAG_NONET;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('F')) {
                                                appType = appType | APPTYPE_FLAG_FAT32;
                                            }
                                            flagsPtr = _tcsinc (flagsPtr);
                                        }
                                    }
                                    if ((appType & APPTYPE_TYPE_MASK) == 0) {
                                        appType |= APPTYPE_INC_NOBLOCK;
                                    }
                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, binVerValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) && (valueType == REG_BINARY)) {
                                        PWORD valueIdx;
                                        appBinVer = TRUE;
                                        valueIdx = (PWORD) (addnlData);
                                        _stprintf (appBinVerStr, TEXT("%d.%d.%d.%d"), *(valueIdx + 1), *valueIdx, *(valueIdx + 3), *(valueIdx + 2));
                                    }

                                    pPrintBadAppsData (
                                        S_CHECK_BAD_APPS_400,
                                        S_APP_COMPATIBILITY,
                                        exeKeyStr,
                                        valueName,
                                        msgId,
                                        appType,
                                        appBinVer,
                                        appBinVerStr
                                        );

                                    status = ERROR_SUCCESS;
                                }
                            }
                        }
                        index ++;
                    }
                }
            }
            idxKey ++;
        }
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appc_ta\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appc_ta.res: appc_ta.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appc_tu\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appc_tu.res: appc_tu.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appc_cnv\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appc_cnv.res: appc_cnv.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appc_tu\appc_tu.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    appc_tu.c

Abstract:

Author:

    Calin Negreanu (calinn) 01-Mar-1999

Revision History:

    <alias> <date> <comments>

--*/

#ifndef UNICODE
#error UNICODE needs to be defined
#endif

#include <windows.h>
#include <winnt.h>
#include <tchar.h>
#include <stdio.h>
#include <shlobj.h>
#include <setupapi.h>
#include <badapps.h>

BOOL CancelFlag = FALSE;
BOOL *g_CancelFlagPtr = &CancelFlag;

#ifdef DEBUG
extern BOOL g_DoLog;
#endif

HANDLE g_hHeap;
HINSTANCE g_hInst;

PCTSTR   g_SourceExe = NULL;

BOOL     g_UseInf = FALSE;
PCTSTR   g_SourceInf = NULL;

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "appc_tu [-i:<inffile>] <EXE file>\n\n"
            "Optional Arguments:\n"
            "  -i:<inffile>    - Specifies INF file containing AppCompatibility data.\n"
            "     <EXE file>   - Specifies EXE file that needs to be validated.\n"
            );

    exit(255);
}

BOOL
DoesPathExist (
    IN      PCTSTR Path
    );


BOOL
pWorkerFn (
    VOID
    );

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    INT i;
    WCHAR sourceExe[MAX_PATH];
    WCHAR sourceInf[MAX_PATH];

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'i':
                g_UseInf = TRUE;
                if (argv[i][2] == ':') {
                    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, &argv[i][3], -1, sourceInf, MAX_PATH);
                    g_SourceInf = sourceInf;
                } else if (i + 1 < argc) {
                    i++;
                    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, argv[i], -1, sourceInf, MAX_PATH);
                    g_SourceInf = sourceInf;
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, &argv[i][0], -1, sourceExe, MAX_PATH);
            g_SourceExe = sourceExe;
        }
    }

    if (((g_UseInf) && (g_SourceInf == NULL)) || (g_SourceExe == NULL)) {
        HelpAndExit();
    }

    if (g_UseInf && (!DoesPathExist (g_SourceInf))) {
        printf ("Source INF file does not exist: %S", g_SourceInf);
        return 254;
    }

    if (!DoesPathExist (g_SourceExe)) {
        printf ("Source EXE file does not exist: %S", g_SourceExe);
        return 254;
    }

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    pWorkerFn ();

    return 0;
}

PCTSTR
ShGetFileNameFromPath (
    IN      PCTSTR PathSpec
    );

#define S_APP_COMPATIBILITY     TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility")

BOOL
pWorkerFn (
    VOID
    )
{
    HKEY badAppKey = NULL;
    HKEY exeKey = NULL;
    LONG status;
    DWORD index;
    TCHAR valueName [MAX_PATH];
    DWORD valueSize;
    DWORD valueType;
    DWORD blobSize;
    PBYTE blobData;
    BADAPP_DATA appData;
    BADAPP_PROP appProp;
    BOOL result = FALSE;
    HINF  infHandle;
    INFCONTEXT context;
    TCHAR fieldStr [MAX_PATH];
    INT   fieldVal;

    if (g_UseInf) {
        infHandle = SetupOpenInfFile (g_SourceInf, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (infHandle != INVALID_HANDLE_VALUE) {
            blobData = (PBYTE)HeapAlloc(g_hHeap, 0, 8192);
            if (blobData) {
                if (SetupFindFirstLine (infHandle, TEXT("DATA"), NULL, &context)) {
                    do {
                        // now let's read the line and create the BLOB
                        index = 5;
                        blobSize = 0;
                        while (SetupGetStringField (&context, index, fieldStr, MAX_PATH, NULL)) {
                            swscanf (fieldStr, TEXT("%x"), &fieldVal);
                            blobData [blobSize] = (BYTE) fieldVal;
                            blobSize ++;
                            if (blobSize == 4096) {
                                break;
                            }
                            index ++;
                        }
                        appProp.Size = sizeof (BADAPP_PROP);
                        appData.Size = sizeof (BADAPP_DATA);
                        appData.FilePath = g_SourceExe;
                        appData.Blob = blobData;
                        result = SHIsBadApp (&appData, &appProp);
                    } while ((!result) && (SetupFindNextLine (&context, &context)));
                }
                HeapFree (g_hHeap, 0, blobData);
            }
            SetupCloseInfFile (infHandle);
        }
    } else {
        if (RegOpenKey (HKEY_LOCAL_MACHINE, S_APP_COMPATIBILITY, &badAppKey) == ERROR_SUCCESS) {
            if (RegOpenKey (badAppKey, ShGetFileNameFromPath (g_SourceExe), &exeKey) == ERROR_SUCCESS) {
                index = 0;
                status = ERROR_SUCCESS;
                while ((!result) && (status == ERROR_SUCCESS)) {
                    valueSize = MAX_PATH;
                    status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, NULL, &blobSize);
                    if (status == ERROR_SUCCESS) {
                        blobData = (PBYTE)HeapAlloc(g_hHeap, 0, blobSize);
                        if (blobData) {
                            valueSize = MAX_PATH;
                            status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, blobData, &blobSize);
                            if ((status == ERROR_SUCCESS) ||
                                (status == ERROR_MORE_DATA)
                                ) {
                                appProp.Size = sizeof (BADAPP_PROP);
                                appData.Size = sizeof (BADAPP_DATA);
                                appData.FilePath = g_SourceExe;
                                appData.Blob = blobData;
                                result = SHIsBadApp (&appData, &appProp);
                            }
                            HeapFree (g_hHeap, 0, (PVOID)blobData);
                        }
                    }
                    index ++;
                }
                RegCloseKey (exeKey);
            }
            RegCloseKey (badAppKey);
        }
    }

    if (result) {
        printf ("\nApplication known bad: %S\n\n", g_SourceExe);
        printf ("    Application state: ");
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_INC_NOBLOCK) {
            printf ("Incompatible - no hard block\n");
        }
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_INC_HARDBLOCK) {
            printf ("Incompatible - hard block\n");
        }
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_MINORPROBLEM) {
            printf ("Minor problems\n");
        }
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_REINSTALL) {
            printf ("Reinstall\n");
        }
        printf ("    Application flags: ");
        if (appProp.AppType & APPTYPE_FLAG_NONET) {
            printf ("Can't run over the net\n                       ");
        }
        if (appProp.AppType & APPTYPE_FLAG_FAT32) {
            printf ("Can't run on FAT32\n                       ");
        }
        if (appProp.AppType & APPTYPE_FLAG_NTFS) {
            printf ("Can't run on NTFS\n                       ");
        }
        printf ("\n");
        printf ("           Message ID: %d\n\n", appProp.MsgId);
    } else {
        printf ("\nApplication not known bad.\n\n");
    }

    return result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appdiff\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appdiff\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appc_ta\appc_ta.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    appc_ta.c

Abstract:

Author:

    Calin Negreanu (calinn) 01-Mar-1999

Revision History:

    <alias> <date> <comments>

--*/

#ifdef UNICODE
#error UNICODE must not be defined
#endif

#include <windows.h>
#include <winnt.h>
#include <tchar.h>
#include <stdio.h>
#include <shlobj.h>
#include <setupapi.h>
#include <badapps.h>

BOOL CancelFlag = FALSE;
BOOL *g_CancelFlagPtr = &CancelFlag;

#ifdef DEBUG
extern BOOL g_DoLog;
#endif

HANDLE g_hHeap;
HINSTANCE g_hInst;

PCTSTR   g_SourceExe = NULL;

BOOL     g_UseInf = FALSE;
PCTSTR   g_SourceInf = NULL;

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "appc_ta [-i:<inffile>] <EXE file>\n\n"
            "Optional Arguments:\n"
            "  -i:<inffile>    - Specifies INF file containing AppCompatibility data.\n"
            "     <EXE file>   - Specifies EXE file that needs to be validated.\n"
            );

    exit(255);
}

BOOL
DoesPathExist (
    IN      PCTSTR Path
    );


BOOL
pWorkerFn (
    VOID
    );

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    INT i;

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'i':
                g_UseInf = TRUE;
                if (argv[i][2] == ':') {
                    g_SourceInf = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    g_SourceInf = argv[i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            g_SourceExe = &argv[i][0];
        }
    }

    if (((g_UseInf) && (g_SourceInf == NULL)) || (g_SourceExe == NULL)) {
        HelpAndExit();
    }

    if (g_UseInf && (!DoesPathExist (g_SourceInf))) {
        printf ("Source INF file does not exist: %s", g_SourceInf);
        return 254;
    }

    if (!DoesPathExist (g_SourceExe)) {
        printf ("Source EXE file does not exist: %s", g_SourceExe);
        return 254;
    }

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    pWorkerFn ();

    return 0;
}

PCTSTR
ShGetFileNameFromPath (
    IN      PCTSTR PathSpec
    );

#define S_APP_COMPATIBILITY     TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility")

BOOL
pWorkerFn (
    VOID
    )
{
    HKEY badAppKey = NULL;
    HKEY exeKey = NULL;
    LONG status;
    DWORD index;
    TCHAR valueName [MAX_PATH];
    DWORD valueSize;
    DWORD valueType;
    DWORD blobSize;
    PBYTE blobData;
    BADAPP_DATA appData;
    BADAPP_PROP appProp;
    BOOL result = FALSE;
    HINF  infHandle;
    INFCONTEXT context;
    TCHAR fieldStr [MAX_PATH];
    INT   fieldVal;

    if (g_UseInf) {
        infHandle = SetupOpenInfFile (g_SourceInf, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (infHandle != INVALID_HANDLE_VALUE) {
            blobData = (PBYTE)HeapAlloc(g_hHeap, 0, 8192);
            if (blobData) {
                if (SetupFindFirstLine (infHandle, TEXT("DATA"), NULL, &context)) {
                    do {
                        // now let's read the line and create the BLOB
                        index = 5;
                        blobSize = 0;
                        while (SetupGetStringField (&context, index, fieldStr, MAX_PATH, NULL)) {
                            sscanf (fieldStr, TEXT("%x"), &fieldVal);
                            blobData [blobSize] = (BYTE) fieldVal;
                            blobSize ++;
                            if (blobSize == 4096) {
                                break;
                            }
                            index ++;
                        }
                        appProp.Size = sizeof (BADAPP_PROP);
                        appData.Size = sizeof (BADAPP_DATA);
                        appData.FilePath = g_SourceExe;
                        appData.Blob = blobData;
                        result = SHIsBadApp (&appData, &appProp);
                    } while ((!result) && (SetupFindNextLine (&context, &context)));
                }
                HeapFree (g_hHeap, 0, blobData);
            }
            SetupCloseInfFile (infHandle);
        }
    } else {
        if (RegOpenKey (HKEY_LOCAL_MACHINE, S_APP_COMPATIBILITY, &badAppKey) == ERROR_SUCCESS) {
            if (RegOpenKey (badAppKey, ShGetFileNameFromPath (g_SourceExe), &exeKey) == ERROR_SUCCESS) {
                index = 0;
                status = ERROR_SUCCESS;
                while ((!result) && (status == ERROR_SUCCESS)) {
                    valueSize = MAX_PATH;
                    status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, NULL, &blobSize);
                    if (status == ERROR_SUCCESS) {
                        blobData = (PBYTE)HeapAlloc(g_hHeap, 0, blobSize);
                        if (blobData) {
                            valueSize = MAX_PATH;
                            status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, blobData, &blobSize);
                            if ((status == ERROR_SUCCESS) ||
                                (status == ERROR_MORE_DATA)
                                ) {
                                appProp.Size = sizeof (BADAPP_PROP);
                                appData.Size = sizeof (BADAPP_DATA);
                                appData.FilePath = g_SourceExe;
                                appData.Blob = blobData;
                                result = SHIsBadApp (&appData, &appProp);
                            }
                            HeapFree (g_hHeap, 0, (PVOID)blobData);
                        }
                    }
                    index ++;
                }
                RegCloseKey (exeKey);
            }
            RegCloseKey (badAppKey);
        }
    }

    if (result) {
        printf ("\nApplication known bad: %s\n\n", g_SourceExe);
        printf ("    Application state: ");
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_INC_NOBLOCK) {
            printf ("Incompatible - no hard block\n");
        }
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_INC_HARDBLOCK) {
            printf ("Incompatible - hard block\n");
        }
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_MINORPROBLEM) {
            printf ("Minor problems\n");
        }
        if ((appProp.AppType & APPTYPE_TYPE_MASK) == APPTYPE_REINSTALL) {
            printf ("Reinstall\n");
        }
        printf ("    Application flags: ");
        if (appProp.AppType & APPTYPE_FLAG_NONET) {
            printf ("Can't run over the net\n                       ");
        }
        if (appProp.AppType & APPTYPE_FLAG_FAT32) {
            printf ("Can't run on FAT32\n                       ");
        }
        if (appProp.AppType & APPTYPE_FLAG_NTFS) {
            printf ("Can't run on NTFS\n                       ");
        }
        printf ("\n");
        printf ("           Message ID: %d\n\n", appProp.MsgId);
    } else {
        printf ("\nApplication not known bad.\n\n");
    }

    return result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appdiff\appdiff.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    appdiff.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    Jim Schmidt (jimschm) 26-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


#define S_FILES         TEXT("Files")
#define S_REG           TEXT("Reg")
#define S_INIFILES      TEXT("IniFiles")
#define S_EXCLUDE       TEXT("Exclude")
#define S_PATHS         TEXT("Paths")
#define S_REGISTRY      TEXT("Registry")
#define S_SUBSTITUTIONS TEXT("Substitutions")
#define S_SRC           TEXT("Src")
#define S_DEST          TEXT("Dest")
#define S_ADDED         TEXT("Added")
#define S_CHANGED       TEXT("Changed")
#define S_ZERO          TEXT("0")

typedef struct {
    BOOL SnapMode;
    BOOL DiffMode;
    BOOL CheckBits;
    PCTSTR SnapFile;
    PCTSTR AppFile;
    PCTSTR Name;
    PCTSTR OutputFile;
    PCTSTR RegRoot;
    PCTSTR FileSysRoot;
    BOOL UseAppDiffInf;
    BOOL NoRoots;
    BOOL QuietMode;
} OPTIONS, *POPTIONS;

BOOL g_Quiet;
BOOL g_Thorough;


typedef struct {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    DWORD    nFileSizeHigh;
    DWORD    nFileSizeLow;
} FILEINFO, *PFILEINFO;

BOOL
DoSnapMode (
    POPTIONS Options
    );

BOOL
DoDiffMode (
    POPTIONS Options
    );

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
WINAPI
MemDb_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );



BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    g_hInst = hInstance;
    g_hHeap = GetProcessHeap();

    MigUtil_Entry (
        hInstance,
        dwReason,
        lpReserved
        );

    MemDb_Entry (
        hInstance,
        dwReason,
        lpReserved
        );

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    MemDb_Entry (
        hInstance,
        dwReason,
        lpReserved
        );

    MigUtil_Entry (
        hInstance,
        dwReason,
        lpReserved
        );
}


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "appdiff -s[:snapfile] [-r:<regroot>] [-f:<fileroot>]\n"
            "appdiff -d[:snapfile] [-a:appfilelist] [-n:name] [-o:outfile]\n"
            "appdiff -s[:snapfile] -d [-n:name] [-o:outfile] [-r:<regroot>]\n"
            "        [-f:<fileroot>]\n"
            "\n"
            "-s         Specifies snapshot mode, where snapfile is the name of\n"
            "           the memdb output file, and is snap.dat by default.\n"
            "\n"
            "-d         Specifies diff mode, where snapfile is the name of a\n"
            "           previously generated snapshot file, and is snap.dat by\n"
            "           default.\n"
            "\n"
            "-a         Specifies the application file list, as generated by\n"
            "           migfiles.exe.\n"
            "\n"
            "-n         Specifies the application section name, and the default\n"
            "           is Application.\n"
            "\n"
            "-o         Specifies the name of the output INF fragment, and the\n"
            "           default is output.inf\n"
            "\n"
            "-r         Specifies a registry root to compare.  If specified,\n"
            "           only the registry is scanned, unless -f is also specified.\n"
            "\n"
            "-f         Specifies a file system root to compare.  If specified,\n"
            "           only the file system is scanned, unless -r is also\n"
            "           specified.\n"
            "\n"
            "Additional Options:"
            "\n"
            "-q         Quiet mode -- disables stderr output.\n"
            "-u         Use appdiff.inf and output.inf (for generation of uninstall\n"
            "           sections)\n"
            "-t         Thorough checks (computes checksums for all data)\n"
            "\n"
            "APPDIFF.INF specifies the registry and file system roots to scan on\n"
            "a per-app basis, and is used to generate uninstall sections for\n"
            "migdb.inf.  See \\\\jimschm-dev\\team\\tools\\appdiff.inf for info.\n"
            "\n"
            "OUTPUT.INF is generated by this tool, and is designed to be cut &\n"
            "pasted into migdb.inf.\n"
            );

    exit(0);
}



BOOL
pParseCommandLine (
    IN      INT ArgCount,
    IN      PTSTR ArgArray[],
    OUT     POPTIONS Options
    )
{
    INT i;

    ZeroMemory (Options, sizeof (OPTIONS));

    Options->NoRoots = TRUE;

    for (i = 0 ; i < ArgCount ; i++) {

        if (ArgArray[i][0] == TEXT('-') || ArgArray[i][0] == TEXT('/')) {

            switch (_totlower (ArgArray[i][1])) {

            case TEXT('s'):
                Options->SnapMode = TRUE;

                if (ArgArray[i][2] == TEXT(':')) {
                    if (Options->SnapFile) {
                        return FALSE;
                    }

                    Options->SnapFile = &ArgArray[i][3];

                    if (Options->SnapFile[0] == 0) {
                        return FALSE;
                    }
                }

                break;

            case TEXT('t'):
                if (g_Thorough) {
                    return FALSE;
                }

                Options->CheckBits = TRUE;
                g_Thorough = TRUE;

                break;

            case TEXT('d'):
                Options->DiffMode = TRUE;

                if (ArgArray[i][2] == TEXT(':')) {
                    if (Options->SnapFile) {
                        return FALSE;
                    }

                    Options->SnapFile = &ArgArray[i][3];

                    if (Options->SnapFile[0] == 0) {
                        return FALSE;
                    }
                }

                break;

            case TEXT('r'):
                Options->NoRoots = FALSE;

                if (Options->RegRoot) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->RegRoot = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->RegRoot = ArgArray[i];
                } else {
                    Options->RegRoot = &ArgArray[i][2];
                }

                if (Options->RegRoot[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('f'):
                Options->NoRoots = FALSE;

                if (Options->FileSysRoot) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->FileSysRoot = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->FileSysRoot = ArgArray[i];
                } else {
                    Options->FileSysRoot = &ArgArray[i][2];
                }

                if (Options->FileSysRoot[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('q'):
                if (g_Quiet) {
                    return FALSE;
                }

                Options->QuietMode = TRUE;
                g_Quiet = TRUE;
                break;

            case TEXT('u'):
                if (Options->UseAppDiffInf) {
                    return FALSE;
                }

                Options->UseAppDiffInf = TRUE;
                break;

            case TEXT('a'):
                if (Options->AppFile) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->AppFile = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->AppFile = ArgArray[i];
                } else {
                    Options->AppFile = &ArgArray[i][2];
                }

                if (Options->AppFile[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('n'):
                if (Options->Name) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->Name = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->Name = ArgArray[i];
                } else {
                    Options->Name = &ArgArray[i][2];
                }

                if (Options->Name[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('o'):
                if (Options->OutputFile) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->OutputFile = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->OutputFile = ArgArray[i];
                } else {
                    Options->OutputFile = &ArgArray[i][2];
                }

                if (Options->OutputFile[0] == 0) {
                    return FALSE;
                }

                break;

            default:
                return FALSE;
            }
        }

        else {
            return FALSE;
        }
    }

    if (!Options->SnapMode && !Options->DiffMode) {
        return FALSE;
    }

    if (!Options->SnapFile) {
        Options->SnapFile = TEXT("snap.dat");
    }

    if (!Options->OutputFile && Options->UseAppDiffInf) {
        Options->OutputFile = TEXT("output.inf");
    }

    if (!Options->Name) {
        Options->Name = TEXT("Application");
    }

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Snap file:        %s\n"), Options->SnapFile);

        if (Options->OutputFile) {
            _ftprintf (stderr, TEXT("Output file:      %s\n"), Options->OutputFile);
        }

        _ftprintf (stderr, TEXT("Thorough checks:  %s\n"), Options->CheckBits ? "ENABLED" : "DISABLED");

        _ftprintf (stderr, TEXT("Application Name: %s\n\n"), Options->Name);
    }

    return TRUE;
}



INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    OPTIONS Options;

    if (!pParseCommandLine (argc - 1, &argv[1], &Options)) {
        HelpAndExit();
    }

    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    //
    // Snap Mode: Gather the directory, registry and INI files
    //

    if (Options.SnapMode) {
        DoSnapMode (&Options);
    }

    //
    // Diff Mode: Gather another snapshot, then compare against
    //            original
    //

    if (Options.DiffMode) {
        if (Options.SnapMode) {
            _ftprintf (stderr, TEXT("Do your thing, then hit Enter.\n"));
            getchar();
            _ftprintf (stderr, TEXT("\n"));
        }

        DoDiffMode (&Options);
    }

    Terminate();

    return 0;
}


BOOL
pCompareData (
    IN      PCBYTE Src,
    IN      PCBYTE Dest,
    IN      UINT Size
    )
{
    PCWSTR p, q;

    if (Size >= sizeof (WCHAR)) {

        p = (PCWSTR) (Src + Size - sizeof (WCHAR));
        q = (PCWSTR) (Dest + Size - sizeof (WCHAR));

        if (*p == 0 && *q == 0) {
            if (StringIMatchW ((PCWSTR) Src, (PCWSTR) Dest)) {
                return TRUE;
            }

            return FALSE;
        }
    }

    return memcmp (Src, Dest, Size) == 0;
}


VOID
pSetMemDbKey (
    IN      BOOL DiffMode,
    IN      PCTSTR Group,
    IN      PCTSTR Key,
    IN      PBYTE Data,
    IN      DWORD DataSize
    )
{
    PCBYTE OrgData;
    DWORD OrgSize;
    TCHAR Node[MEMDB_MAX];

    wsprintf (Node, TEXT("%s\\%s"), S_EXCLUDE, Key);

    if (MemDbGetValue (Node, NULL)) {
        return;
    }

    if (!DiffMode) {

        MemDbSetBinaryValueEx (
            S_ZERO,
            Group,
            Key,
            Data,
            DataSize,
            NULL
            );
    }

    else {
        //
        // Compare against original data
        //

        wsprintf (Node, TEXT("0\\%s\\%s"), Group, Key);
        OrgData = MemDbGetBinaryValue (Node, &OrgSize);

        if (!OrgData) {
            //
            // Data has been added
            //

            wsprintf (Node, TEXT("%s\\%s\\%s"), S_ADDED, Group, Key);
            MemDbSetValue (Node, 0);
        }

        else {

            //
            // Delete memdb key, so remaining items will provide list of data
            // that was deleted.
            //

            if (OrgSize != DataSize || !pCompareData (OrgData, Data, DataSize)) {
                //
                // Data has changed
                //

                MemDbDeleteValue (Node);

                wsprintf (Node, TEXT("%s\\%s\\%s"), S_CHANGED, Group, Key);
                MemDbSetValue (Node, 0);
            } else {
                //
                // Data has not changed
                //

                MemDbDeleteValue (Node);
            }
        }
    }
}



VOID
pConvertWin32FindData (
    IN      PWIN32_FIND_DATA Data,
    OUT     PFILEINFO Info
    )
{
    Info->dwFileAttributes = Data->dwFileAttributes;
    Info->ftCreationTime = Data->ftCreationTime;
    Info->ftLastWriteTime = Data->ftLastWriteTime;
    Info->nFileSizeHigh = Data->nFileSizeHigh;
    Info->nFileSizeLow = Data->nFileSizeLow;

}



VOID
pSetRegDataAndFreePtrs (
    BOOL DiffMode,
    PBYTE Data,         OPTIONAL
    PBYTE Data2,        OPTIONAL
    DWORD Size,
    PCTSTR Key,
    PCTSTR Value        OPTIONAL
    )
{
    PCTSTR Node;

    if (Data2) {
        Node = CreateEncodedRegistryString (Key, Value);

        pSetMemDbKey (
            DiffMode,
            S_REG,
            Node,
            Data2,
            Size
            );

        FreeEncodedRegistryString (Node);

        if (Data) {
            MemFree (g_hHeap, 0, Data);
        }

        MemFree (g_hHeap, 0, Data2);
    }
}


BOOL
pRegSnap (
    BOOL DiffMode,
    PCTSTR Root
    )

{
    REGTREE_ENUM Reg;
    REGVALUE_ENUM RegVal;
    PBYTE Data;
    PBYTE Data2;
    DWORD Size = 0;
    TCHAR SkipTree[MEMDB_MAX];
    TCHAR TempNode[MEMDB_MAX];
    UINT SkipTreeBytes = 0;

    SkipTree[0] = 0;

    wsprintf (TempNode, TEXT("%s\\%s"), S_EXCLUDE, Root);
    if (MemDbGetValue (TempNode, NULL)) {
        return TRUE;
    }

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Taking snapshot of %s\n"), Root);
    }

    if (EnumFirstRegKeyInTree (&Reg, Root)) {
        do {
            //
            // Key/key tree exclude processing
            //

            if (SkipTree[0]) {
                if (StringIMatchByteCount (SkipTree, Reg.FullKeyName, SkipTreeBytes)) {
                    continue;
                }

                SkipTree[0] = 0;
            }

            wsprintf (TempNode, TEXT("%s\\%s"), S_EXCLUDE, Reg.FullKeyName);
            if (MemDbGetValue (TempNode, NULL)) {
                StringCopy (SkipTree, Reg.FullKeyName);
                SkipTreeBytes = ByteCount (SkipTree);
                continue;
            }

            //
            // Non-excluded key
            //

            Data = NULL;

            if (EnumFirstRegValue (&RegVal, Reg.CurrentKey->KeyHandle)) {
                do {
                    Data = GetRegValueData (RegVal.KeyHandle, RegVal.ValueName);
                    Data2 = NULL;

                    if (Data) {
                        Size = RegVal.DataSize + sizeof (DWORD);
                        Data2 = MemAlloc (g_hHeap, 0, Size);
                        MYASSERT (Data2);

                        CopyMemory ((PDWORD) Data2 + 1, Data, RegVal.DataSize);
                        *((PDWORD) Data2) = RegVal.Type;
                    }

                    pSetRegDataAndFreePtrs (DiffMode, Data, Data2, Size, Reg.FullKeyName, RegVal.ValueName);

                } while (EnumNextRegValue (&RegVal));

            } else {
                Size = sizeof (DWORD);
                Data2 = MemAlloc (g_hHeap, 0, Size);
                MYASSERT (Data2);
                *((PDWORD) Data2) = 0xffffffff;

                pSetRegDataAndFreePtrs (DiffMode, Data, Data2, Size, Reg.FullKeyName, RegVal.ValueName);
            }

        } while (EnumNextRegKeyInTree (&Reg));
    }

    return TRUE;
}


DWORD
pComputeChecksum (
    PCTSTR FullPath
    )
{
    HANDLE File;
    HANDLE Map;
    PBYTE Data;
    UINT Size;
    UINT u;
    DWORD Checksum = 0;

    Data = MapFileIntoMemory (FullPath, &File, &Map);
    if (!Data) {
        return 0xFFFFFFFF;
    }

    Size = GetFileSize (File, NULL);

    for (u = 0 ; u < Size ; u++) {
        Checksum = _rotl (Checksum, 3);
        Checksum ^= Data[u];
    }

    UnmapFile (Data, Map, File);

    return Checksum;
}


BOOL
pDirAndIniSnap (
    BOOL DiffMode,
    PCTSTR Root
    )
{
    TREE_ENUM Dir;
    PCTSTR p, q, r;
    TCHAR SectionNames[32768];
    TCHAR KeyNames[32768];
    TCHAR KeyValue[4096];
    TCHAR Node[MEMDB_MAX];
    TCHAR ExcludeNode[MEMDB_MAX];
    UINT Count;
    FILEINFO fi;
    TCHAR SkipTree[MEMDB_MAX];
    UINT SkipTreeBytes = 0;
    DWORD Checksum;

    SkipTree[0] = 0;

    wsprintf (ExcludeNode, TEXT("%s\\%s"), S_EXCLUDE, Root);
    if (MemDbGetValue (ExcludeNode, NULL)) {
        return TRUE;
    }

    //
    // Take a snapshot of all dirs in drive specified by Root
    //

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Taking snapshot of %s\n"), Root);
    }

    if (EnumFirstFileInTree (&Dir, Root, NULL, TRUE)) {
        do {
            //
            // Exclude processing
            //

            if (SkipTree[0]) {
                if (StringIMatchByteCount (SkipTree, Dir.FullPath, SkipTreeBytes)) {
                    continue;
                }

                SkipTree[0] = 0;
            }

            if (Dir.Directory) {
                wsprintf (ExcludeNode, TEXT("%s\\%s"), S_EXCLUDE, Dir.FullPath);
                if (MemDbGetValue (ExcludeNode, NULL)) {
                    StringCopy (SkipTree, Dir.FullPath);
                    AppendWack (SkipTree);
                    SkipTreeBytes = ByteCount (SkipTree);
                    continue;
                }
            }

            //
            // Non-excluded file
            //

            if (g_Thorough) {
                Checksum = pComputeChecksum (Dir.FullPath);

                pSetMemDbKey (
                    DiffMode,
                    S_FILES,
                    Dir.FullPath,
                    (PBYTE) &Checksum,
                    sizeof (Checksum)
                    );

            } else {
                pConvertWin32FindData (Dir.FindData, &fi);

                pSetMemDbKey (
                    DiffMode,
                    S_FILES,
                    Dir.FullPath,
                    (PBYTE) &fi,
                    sizeof (FILEINFO)
                    );
            }

            p = _tcsrchr (Dir.Name, TEXT('.'));
            if (p) {
                p = _tcsinc (p);
                if (StringIMatch (p, TEXT("INI"))) {
                    //
                    // Found INI file, take a snapshot of it
                    //

                    if (!g_Quiet) {
                        _ftprintf (stderr, TEXT("    Taking snapshot of %s\n"), Dir.FullPath);
                    }

                    Count = GetPrivateProfileString (NULL, NULL, TEXT("\0"), SectionNames, 32768, Dir.FullPath);
                    SectionNames[Count] = 0;
                    SectionNames[Count + 1] = 0;

                    p = SectionNames;
                    while (*p) {
                        //
                        // Filter out dup sections
                        //

                        r = SectionNames;
                        while (r < p) {
                            if (StringIMatch (p, r)) {
                                break;
                            }

                            r = GetEndOfString (r) + 1;
                        }

                        if (r < p) {
                            if (!g_Quiet) {
                                _ftprintf (stderr, TEXT("        ***Duplicate section ignored: [%s]\n"), p);
                            }

                            p = GetEndOfString (p) + 1;
                            continue;
                        }

                        //
                        // Process each key in the section
                        //

                        Count = GetPrivateProfileString (
                                    p,
                                    NULL,
                                    TEXT("\0"),
                                    KeyNames,
                                    32768,
                                    Dir.FullPath
                                    );
                        KeyNames[Count] = 0;
                        KeyNames[Count + 1] = 0;

                        q = KeyNames;

                        while (*q) {
                            //
                            // Ignore duplicate value names
                            //

                            r = KeyNames;
                            while (r < q) {
                                if (StringIMatch (q, r)) {
                                    break;
                                }

                                r = GetEndOfString (r) + 1;
                            }

                            if (r < q) {
                                if (!g_Quiet) {
                                    _ftprintf (stderr, TEXT("        ***Duplicate key ignored: [%s] %s\n"), p, q);
                                }

                                q = GetEndOfString (q) + 1;
                                continue;
                            }

                            GetPrivateProfileString (
                                p,
                                q,
                                TEXT(""),
                                KeyValue,
                                4096,
                                Dir.FullPath
                                );

                            wsprintf (Node, TEXT("%s\\[%s]\\%s"), Dir.FullPath, p, q);
                            pSetMemDbKey (
                                DiffMode,
                                S_INIFILES,
                                Node,
                                (PBYTE) KeyValue,
                                ByteCount (KeyValue) + sizeof (TCHAR)
                                );

                            q = GetEndOfString (q) + 1;
                        }

                        p = GetEndOfString (p) + 1;
                    }
                }
            }

        } while (EnumNextFileInTree (&Dir));
    }

    return TRUE;
}


VOID
pCreateSubst (
    IN      PCTSTR Src,
    IN      PCTSTR Dest
    )
{
    DWORD Offset;

    MemDbSetValueEx (S_SUBSTITUTIONS, S_DEST, Dest, NULL, 0, &Offset);
    MemDbSetValueEx (S_SUBSTITUTIONS, S_SRC, Src, NULL, Offset, NULL);
}

BOOL
pTakeSnapshot (
    POPTIONS Options,
    BOOL DiffMode
    )
{
    HINF Inf;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    TCHAR Path[MAX_TCHAR_PATH];
    PTSTR p, q;
    TCHAR Section[256];
    UINT Dirs = 0;
    UINT RegRoots = 0;
    TCHAR WinDir[MAX_TCHAR_PATH];
    TCHAR SystemDir[MAX_TCHAR_PATH];
    TCHAR System32Dir[MAX_TCHAR_PATH];
    TCHAR SystemDrive[8];
    TCHAR ProgramFilesDir[MAX_TCHAR_PATH];

    GetWindowsDirectory (WinDir, MAX_TCHAR_PATH);
    StringCopy (SystemDir, WinDir);
    StringCopy (AppendWack (SystemDir), TEXT("system"));
    StringCopy (System32Dir, SystemDir);
    StringCat (System32Dir, TEXT("32"));
    SystemDrive[0] = SystemDir[0];
    SystemDrive[1] = TEXT(':');
    SystemDrive[2] = 0;
    StringCopy (ProgramFilesDir, SystemDrive);
    StringCopy (AppendWack (ProgramFilesDir), TEXT("Program Files"));

    pCreateSubst (WinDir, TEXT("%%WINDIR%%"));
    pCreateSubst (SystemDir, TEXT("%%SYSTEMDIR%%"));
    pCreateSubst (System32Dir, TEXT("%%SYSTEM32DIR%%"));
    pCreateSubst (SystemDrive, TEXT("%%SYSTEMDRIVE%%"));
    pCreateSubst (ProgramFilesDir, TEXT("%%PROGRAMFILES%%"));


    if (Options->UseAppDiffInf) {
        GetModuleFileName (NULL, Path, MAX_TCHAR_PATH);
        p = _tcsrchr (Path, TEXT('\\'));
        MYASSERT (p);
        StringCopy (p + 1, TEXT("appdiff.inf"));

        Inf = InfOpenInfFile (Path);
    } else {
        Inf = INVALID_HANDLE_VALUE;
    }

    if (Inf == INVALID_HANDLE_VALUE) {
        //
        // Take snapshot of file system and INI files
        //

        if (Options->FileSysRoot) {
            pDirAndIniSnap (DiffMode, Options->FileSysRoot);
        } else if (Options->NoRoots) {
            pDirAndIniSnap (DiffMode, TEXT("C:\\"));
        }

        //
        // Take snapshot of registry
        //

        if (Options->RegRoot) {
            pRegSnap (DiffMode, Options->RegRoot);
        } else if (Options->NoRoots) {
            pRegSnap (DiffMode, TEXT("HKLM"));
            pRegSnap (DiffMode, TEXT("HKU"));
        }
    }

    else {
        //
        // Fill in the [Exclude] section
        //

        if (InfFindFirstLine (Inf, S_EXCLUDE, NULL, &is)) {
            do {
                p = InfGetLineText (&is);
                MemDbSetValueEx (S_EXCLUDE, p, NULL, NULL, 0, NULL);
            } while (InfFindNextLine (&is));
        }

        InfResetInfStruct (&is);

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_EXCLUDE);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    MemDbSetValueEx (S_EXCLUDE, p, NULL, NULL, 0, NULL);
                } while (InfFindNextLine (&is));
            }

            InfResetInfStruct (&is);
        }

        //
        // Fill in the [Substitutions] section
        //

        if (InfFindFirstLine (Inf, S_SUBSTITUTIONS, NULL, &is)) {
            do {
                p = InfGetStringField (&is, 0);
                q = InfGetStringField (&is, 1);

                pCreateSubst (p, q);

            } while (InfFindNextLine (&is));
        }

        InfResetInfStruct (&is);

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_EXCLUDE);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    MemDbSetValueEx (S_EXCLUDE, p, NULL, NULL, 0, NULL);
                } while (InfFindNextLine (&is));
            }

            InfResetInfStruct (&is);
        }

        //
        // Enumerate the [Paths] section, use c:\ by default
        //

        if (InfFindFirstLine (Inf, S_PATHS, NULL, &is)) {
            do {
                p = InfGetLineText (&is);
                pDirAndIniSnap (DiffMode, p);
                Dirs++;
            } while (InfFindNextLine (&is));

            InfResetInfStruct (&is);
        }

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_PATHS);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    pDirAndIniSnap (DiffMode, p);
                    Dirs++;
                } while (InfFindNextLine (&is));
            }

            InfResetInfStruct (&is);
        }

        if (!Dirs) {
            pDirAndIniSnap (DiffMode, TEXT("C:\\"));
        }

        //
        // Enumerate the [Registry] section, use HKLM and HKU by default
        //

        if (InfFindFirstLine (Inf, S_REGISTRY, NULL, &is)) {
            do {
                p = InfGetLineText (&is);
                pRegSnap (DiffMode, p);
                RegRoots++;
            } while (InfFindNextLine (&is));

            InfResetInfStruct (&is);
        }

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_REGISTRY);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    pRegSnap (DiffMode, p);
                    RegRoots++;
                } while (InfFindNextLine (&is));

                InfResetInfStruct (&is);
            }
        }

        if (!RegRoots) {
            pRegSnap (DiffMode, TEXT("HKLM"));
            pRegSnap (DiffMode, TEXT("HKU"));
        }

        InfCloseInfFile (Inf);
    }

    InfCleanUpInfStruct (&is);
    return TRUE;
}


PCTSTR
pPerformSubstitution (
    PGROWLIST EnvVars,
    PCTSTR OrgStr
    )
{
    PCTSTR PathStr;
    PCTSTR NewPathString;
    UINT Count;
    UINT u;
    PCTSTR Src;
    PCTSTR Dest;

    Count = GrowListGetSize (EnvVars);

    PathStr = DuplicatePathString (OrgStr, 0);
    MYASSERT (PathStr);

    for (u = 0 ; u < Count ; u += 2) {
        Src = GrowListGetString (EnvVars, u);
        Dest = GrowListGetString (EnvVars, u + 1);

        NewPathString = StringSearchAndReplace (PathStr, Src, Dest);
        if (NewPathString) {
            FreePathString (PathStr);
            PathStr = NewPathString;
        }
    }

    return PathStr;
}


VOID
pCreateEnvVars (
    PGROWLIST EnvVars
    )
{
    MEMDB_ENUM e;
    TCHAR Dest[MEMDB_MAX];
    UINT Count;
    UINT u;
    UINT Len;

    //
    // Enumerate source strings
    //

    Count = 0;

    if (MemDbGetValueEx (&e, S_SUBSTITUTIONS, S_SRC, NULL)) {
        do {
            MemDbBuildKeyFromOffset (e.dwValue, Dest, 2, NULL);

            Len = ByteCount (e.szName);

            for (u = 0 ; u < Count ; u += 2) {
                if (ByteCount (GrowListGetString (EnvVars, u)) < Len) {
                    break;
                }
            }

            if (u < Count) {
                GrowListInsertString (EnvVars, u, e.szName);
                GrowListInsertString (EnvVars, u + 1, Dest);
            } else {
                GrowListAppendString (EnvVars, e.szName);
                GrowListAppendString (EnvVars, Dest);
            }

            Count += 2;

        } while (MemDbEnumNextValue (&e));
    }
}


VOID
pDecodeRegStr (
    IN      PCTSTR RegStr,
    OUT     PTSTR Key,
    OUT     PCTSTR *ValuePtr
    )
{
    PTSTR p;
    PCTSTR Val = NULL;

    StringCopy (Key, RegStr);

    p = _tcschr (Key, TEXT('['));
    if (p) {
        Val = _tcsinc (p);
        p = _tcsdec2 (Key, p);
        while (p) {
            if (_tcsnextc (p) != TEXT(' ')) {
                break;
            }

            p = _tcsdec2 (Key, p);
        }

        *p = 0;
    }

    *ValuePtr = Val;
}

BOOL
pAreAllValuesInMemDb (
    IN      PCTSTR RegStr,
    IN      BOOL Encoded,
    IN      HKEY KeyHandle      OPTIONAL
    )
{
    BOOL WeOpen = FALSE;
    REGVALUE_ENUM e;
    TCHAR Key[MAX_REGISTRY_KEY];
    PCTSTR Value;
    BOOL b = TRUE;

    //
    // If encoded, decode first.
    //

    if (Encoded) {
        pDecodeRegStr (RegStr, Key, &Value);
    } else {
        StringCopy (Key, RegStr);
        Value = NULL;
    }

    //
    // If key not open, open now
    //

    if (!KeyHandle) {
        KeyHandle = OpenRegKeyStr (Key);
        WeOpen = TRUE;

        if (!KeyHandle) {
           return TRUE;
        }
    }

    //
    // if there is at least one value remaining, fail
    //

    b = !EnumFirstRegValue (&e, KeyHandle);

    if (WeOpen) {
        CloseRegKey (KeyHandle);
    }

    return b;
}


BOOL
pIsEntireSubKeyGone (
    IN      PCTSTR RegStr,
    IN      BOOL Encoded
    )
{
    TCHAR Key[MAX_REGISTRY_KEY];
    PCTSTR Value;
    HKEY KeyHandle;

    //
    // If encoded, decode now
    //

    if (Encoded) {
        pDecodeRegStr (RegStr, Key, &Value);
    } else {
        StringCopy (Key, RegStr);
        Value = NULL;
    }

    //
    // Open key
    //

    KeyHandle = OpenRegKeyStr (Key);
    if (!KeyHandle) {
       return TRUE;
    }

    CloseRegKey (KeyHandle);
    return FALSE;
}

VOID
pAppendThingsToDelete (
    POPTIONS Options,
    HANDLE File
    )
{
    MEMDB_ENUM e;
    PCTSTR p;
    GROWLIST EnvVars = GROWLIST_INIT;
    TCHAR SkipKey[MEMDB_MAX];
    UINT SkipKeyBytes = 0;
    BOOL RegFlag;
    BOOL AppendStar;
    BOOL RemoveVal;
    PCTSTR OutLine;
    TCHAR KeyBuf[MAX_REGISTRY_KEY];
    PCTSTR DontCare;

    SkipKey[0] = 0;

    //
    // Generate substitution mapping
    //

    pCreateEnvVars (&EnvVars);

    //
    // Write section name
    //

    if (!Options->Name) {
        return;
    }

    WriteFileString (File, TEXT("["));
    WriteFileString (File, Options->Name);
    WriteFileString (File, TEXT("]\r\n"));

    //
    // Write all the things in the deleted key
    //

    if (MemDbGetValueEx (&e, S_ZERO, NULL, NULL)) {
        do {
            p = _tcschr (e.szName, TEXT('\\'));
            MYASSERT (p);

            if (StringIMatchAB (S_REG, e.szName, p)) {
                RegFlag = TRUE;
            } else {
                RegFlag = FALSE;
            }

            //
            // Skip if this node is a subkey of a deleted key
            //

            p = _tcsinc (p);

            if (SkipKey[0]) {
                if (StringIMatchByteCount (SkipKey, p, SkipKeyBytes)) {
                    continue;
                }

                SkipKey[0] = 0;
            }

            RemoveVal = FALSE;
            AppendStar = FALSE;

            OutLine = p;

            if (RegFlag) {
                //
                // If this is a registry key, and everything in
                // the registry key has been deleted, then
                // just write the one key with a star after it.
                //

                if (pIsEntireSubKeyGone (p, TRUE)) {
                    RemoveVal = TRUE;
                    AppendStar = TRUE;
                }

                //
                // If it's a registry key, and all the subvalues
                // are deleted, then just write the one key, but
                // without a star.
                //

                else if (pAreAllValuesInMemDb (p, TRUE, NULL)) {
                    RemoveVal = TRUE;
                }
            }

            //
            // The value spec needs to be removed from the reg key
            //

            if (RemoveVal) {
                pDecodeRegStr (p, KeyBuf, &DontCare);
                OutLine = CreateEncodedRegistryString (KeyBuf, NULL);

                //
                // Workaround: CreateEncodedRegistryString always appends
                // an asterisk, and we want to control when the asterisk
                // appears.
                //

                p = _tcsrchr (OutLine, TEXT('*'));
                if (p && p[1] == 0) {
                    p = _tcsdec2 (OutLine, p);
                    if (p) {
                        *((PTSTR) p) = 0;
                    }
                }

                //
                // If this entire key is going to be deleted, then
                // turn on SkipKey so the memdb nodes will be skipped.
                //

                if (AppendStar && SkipKey[0] == 0) {
                    StringCopy (SkipKey, OutLine);
                    AppendWack (SkipKey);
                    SkipKeyBytes = ByteCount (SkipKey);
                }
            }

            //
            // Perform substitution on the string
            //

            p = pPerformSubstitution (&EnvVars, OutLine);
            MYASSERT (p);

            if (RemoveVal) {
                FreeEncodedRegistryString (OutLine);
            }

            //
            // Write the file/reg key to the file
            //

            WriteFileString (File, p);

            if (AppendStar) {
                WriteFileString (File, TEXT("\\*"));
            }

            WriteFileString (File, TEXT("\r\n"));

            FreePathString (p);

        } while (MemDbEnumNextValue (&e));
    }

    //
    // Write blank line at the end
    //

    WriteFileString (File, TEXT("\r\n"));

    FreeGrowList (&EnvVars);
}


BOOL
pDumpDiffs (
    VOID
    )
{
    MEMDB_ENUM e;
    BOOL Changes = FALSE;

    if (MemDbGetValueEx (&e, S_ZERO, NULL, NULL)) {
        _tprintf (TEXT("Deleted Items:\n"));
        Changes = TRUE;

        do {
            _tprintf (TEXT("  %s\n"), e.szName);
        } while (MemDbEnumNextValue (&e));
    }

    if (MemDbGetValueEx (&e, S_ADDED, NULL, NULL)) {
        _tprintf (TEXT("Added Items:\n"));

        do {
            _tprintf (TEXT("  %s\n"), e.szName);
        } while (MemDbEnumNextValue (&e));
    }

    if (MemDbGetValueEx (&e, S_CHANGED, NULL, NULL)) {
        _tprintf (TEXT("Changed Items:\n"));

        do {
            _tprintf (TEXT("  %s\n"), e.szName);
        } while (MemDbEnumNextValue (&e));
    }

    return Changes;
}


BOOL
pGenerateInf (
    POPTIONS Options
    )
{
    HANDLE File;
    BOOL DelChanges;

    //
    // Dump changes to stdout
    //

    DelChanges = pDumpDiffs();

    if (Options->OutputFile) {
        //
        // Write a section to our output file
        //

        File = CreateFile (
                    Options->OutputFile,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (File == INVALID_HANDLE_VALUE) {
            _ftprintf (stderr, TEXT("Cannot generate %s, error %u\n"), Options->OutputFile, GetLastError());
            return FALSE;
        }

        if (DelChanges) {
            pAppendThingsToDelete (Options, File);
        }

        CloseHandle (File);
    }

    return TRUE;
}

BOOL
DoSnapMode (
    POPTIONS Options
    )
{
    DWORD Start;

    Start = GetTickCount();

    if (!pTakeSnapshot (Options, FALSE)) {
        return FALSE;
    }

    MemDbSave (Options->SnapFile);

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Run time: %u seconds\n"), (GetTickCount() - Start) / 1000);
    }

    return TRUE;
}



BOOL
DoDiffMode (
    POPTIONS Options
    )
{
    DWORD Start;

    Start = GetTickCount();

    if (GetFileAttributes (Options->SnapFile) == 0xffffffff) {
        _ftprintf (stderr, TEXT("Bogus file arg: %s\n"), Options->SnapFile);
    }

    if (!Options->SnapMode) {
        MemDbLoad (Options->SnapFile);
    }

    if (!pTakeSnapshot (Options, TRUE)) {
        return FALSE;
    }

    pGenerateInf (Options);

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Run time: %u seconds\n"), (GetTickCount() - Start) / 1000);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appwiz\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appwiz.res: appwiz.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\appwiz\appwiz.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwwiz.c

Abstract:

    Implements a upgwiz wizard for obtaining various application information.

Author:

    Calin Negreanu (calinn)  10-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"
#include <cpl.h>


DATATYPE g_DataTypes[] = {
    {UPGWIZ_VERSION,
        "Incompatible - requires app installation",
        "You must install the application that has incompatible modules, CPLs or SCRs).",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_NO_DATA_OBJECT,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Compatible Application - requires app installation",
        "You specify the application that migrates fine on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_NO_DATA_OBJECT,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Incompatible Application",
        "You specify the application that is incompatible with Windows NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Incompatible DOS Application",
        "You specify the DOS application that is incompatible with Windows NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Application that needs to be reinstalled",
        "You specify an application that needs to be reinstalled after migration.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Application with minor problems",
        "You specify an application that has minor problems running on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_REQUIRE_TEXT,
        1024,
        "&Application name:",
        "&Problem Description:"
    },

    {UPGWIZ_VERSION,
        "DOS Application with minor problems",
        "You specify an DOS application that has minor problems running on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_REQUIRE_TEXT,
        1024,
        "&Application name:",
        "&Problem Description:"
    },

    {UPGWIZ_VERSION,
        "Incompatible CPLs",
        "You specify Control Panel Applets that are incompatible with NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_ONE_SELECTION,
        1024,
        "&CPL name:"
    },

    {UPGWIZ_VERSION,
        "CPLs with minor problems",
        "You specify Control Panel Applets that have minor problems running on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_REQUIRE_TEXT|DTF_ONE_SELECTION,
        1024,
        "&CPL name:"
    },

    {UPGWIZ_VERSION,
        "Incompatible screen savers",
        "You specify screen savers that are incompatible with NT5.",
        0,
    },

    {UPGWIZ_VERSION,
        "Screen savers with minor problems",
        "You specify screen savers that have minor problems while running on NT5.",
        0,
        DTF_REQUIRE_TEXT|DTF_ONE_SELECTION,
        1024,
        NULL,
        "&Problem description:"
    },

    {UPGWIZ_VERSION,
        "Compatible RunKey entries",
        "You specify RunKey entries that can be left after migration.",
        0,
    },

};


GROWBUFFER g_DataObjects = GROWBUF_INIT;
POOLHANDLE g_DataObjectPool;

HINSTANCE g_OurInst;

BOOL
Init (
    VOID
    )
{
#ifndef UPGWIZ4FLOPPY
    return InitToolMode (g_OurInst);
#else
    return TRUE;
#endif
}

VOID
Terminate (
    VOID
    )
{
    //
    // Local cleanup
    //

    FreeGrowBuffer (&g_DataObjects);

    if (g_DataObjectPool) {
        PoolMemDestroyPool (g_DataObjectPool);
    }

#ifndef UPGWIZ4FLOPPY
    TerminateToolMode (g_OurInst);
#endif
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_DETACH) {
        MYASSERT (g_OurInst == hInstance);
        Terminate();
    }

    g_OurInst = hInstance;

    return TRUE;
}


UINT
GiveVersion (
    VOID
    )
{
    Init();

    return UPGWIZ_VERSION;
}


PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    )
{
    UINT u;

    *Count = sizeof (g_DataTypes) / sizeof (g_DataTypes[0]);

    for (u = 0 ; u < *Count ; u++) {
        g_DataTypes[u].DataTypeId = u;
    }

    return g_DataTypes;
}

VOID
pGatherScreenSavers (
    VOID
    )
{
    CHAR winDir [MAX_PATH];
    PCSTR scrDir = NULL;
    TREE_ENUM e;
    PDATAOBJECT Data;

    if (GetWindowsDirectory (winDir, MAX_PATH) == 0) {
        return;
    }

    if (ISNT()) {
        scrDir = JoinPaths (winDir, "SYSTEM32");
    }
    else {
        scrDir = JoinPaths (winDir, "SYSTEM");
    }
    if (EnumFirstFileInTreeEx (&e, scrDir, "*.scr", FALSE, FALSE, FILE_ENUM_THIS_LEVEL)) {
        do {
            if (!e.Directory) {
                Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, e.Name);
                Data->Version = UPGWIZ_VERSION;
                Data->Flags = 0;
                Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, e.FullPath);
            }
        }
        while (EnumNextFileInTree (&e));
    }
    FreePathString (scrDir);
}


typedef struct _CPL_STRUCT {
    PSTR FriendlyName;
    PSTR FullPathName;
} CPL_STRUCT, *PCPL_STRUCT;

PCPL_STRUCT
pAllocCPLStruct (
    IN      PCSTR FriendlyName,
    IN      PCSTR FullPathName
    )
{
    PCPL_STRUCT cplStruct;

    cplStruct = (PCPL_STRUCT) PoolMemGetMemory (g_DataObjectPool, sizeof (CPL_STRUCT));
    ZeroMemory (cplStruct, sizeof (CPL_STRUCT));
    if (FriendlyName) {
        cplStruct->FriendlyName = PoolMemDuplicateString (g_DataObjectPool, FriendlyName);
    }
    if (FullPathName) {
        cplStruct->FullPathName = PoolMemDuplicateString (g_DataObjectPool, FullPathName);
    }
    return cplStruct;
}


typedef LONG (CPL_PROTOTYPE) (HWND hwndCPl, UINT uMsg, LONG lParam1, LONG lParam2);
typedef CPL_PROTOTYPE * PCPL_PROTOTYPE;

VOID
pGetCPLFriendlyName (
    IN      PCSTR FileName
    )
{
    HANDLE cplInstance;
    PCPL_PROTOTYPE cplMain;
    TCHAR localName[MEMDB_MAX];
    UINT oldErrorMode;
    BOOL gathered;
    PDATAOBJECT Data;
    LONG numEntries,i;
    PCSTR uName;
    PCSTR displayName;

    LPCPLINFO info;
    LPNEWCPLINFO newInfo;

    oldErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);

    cplInstance = LoadLibrary (FileName);
    if (!cplInstance) {
        LOG ((LOG_ERROR, "Cannot load %s. Error:%ld", FileName, GetLastError()));

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        SetErrorMode (oldErrorMode);
        return;
    }

    cplMain = (PCPL_PROTOTYPE)GetProcAddress (cplInstance, TEXT("CPlApplet"));
    if (!cplMain) {
        LOG ((LOG_ERROR, "Cannot get main entry point for %s. Error:%ld", FileName, GetLastError()));

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        SetErrorMode (oldErrorMode);
        return;
    }
    if ((*cplMain) (NULL, CPL_INIT, 0, 0) == 0) {
        (*cplMain) (NULL, CPL_EXIT, 0, 0);
        LOG ((LOG_ERROR, "%s failed unexpectedly. Error:%ld", FileName, GetLastError()));

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        FreeLibrary (cplInstance);
        SetErrorMode (oldErrorMode);
        return;
    }

    numEntries = (*cplMain) (NULL, CPL_GETCOUNT, 0, 0);
    if (numEntries == 0) {
        (*cplMain) (NULL, CPL_EXIT, 0, 0);

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        FreeLibrary (cplInstance);
        SetErrorMode (oldErrorMode);
        DEBUGMSG ((DBG_WARNING, "CPL: No display info available for %s.", FileName));
        return;
    }

    info = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (CPLINFO) * numEntries);
    newInfo = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NEWCPLINFO) * numEntries);

    gathered = FALSE;
    for (i=0;i<numEntries;i++) {
        (*cplMain) (NULL, CPL_INQUIRE, i, (LONG)&info[i]);
        (*cplMain) (NULL, CPL_NEWINQUIRE, i, (LONG)&newInfo[i]);

        if (newInfo[i].szName[0]) {
            uName = NULL;
            if (newInfo[i].szName[1]==0) {
                // let's try the unicode name
                uName = ConvertWtoA ((PWSTR)newInfo[i].szName);
            }
            displayName = JoinTextEx (NULL, uName?uName:newInfo[i].szName, GetFileNameFromPath (FileName), " - ", 0, NULL);
            Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
            Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
            Data->Version = UPGWIZ_VERSION;
            Data->Flags = 0;
            Data->DllParam = pAllocCPLStruct (uName?uName:newInfo[i].szName, FileName);
            FreeText (displayName);
            if (uName) {
                FreeConvertedStr (uName);
            }
            gathered = TRUE;

        } else if (LoadString (cplInstance, info[i].idName, localName, MEMDB_MAX)) {

            displayName = JoinTextEx (NULL, localName, GetFileNameFromPath (FileName), " - ", 0, NULL);
            Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
            Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
            Data->Version = UPGWIZ_VERSION;
            Data->Flags = 0;
            Data->DllParam = pAllocCPLStruct (localName, FileName);
            FreeText (displayName);
            gathered = TRUE;

        }
        ELSE_DEBUGMSG ((DBG_ERROR, "CPL: Can't get string id %u", info[i].idName));
    }

    for (i=0;i<numEntries;i++) {
        (*cplMain) (NULL, CPL_STOP, i, info[i].lData?info[i].lData:newInfo[i].lData);
    }

    if (!gathered) {
        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, FileName);
    }

    (*cplMain) (NULL, CPL_EXIT, 0, 0);

    FreeLibrary (cplInstance);

    MemFree (g_hHeap, 0, newInfo);
    MemFree (g_hHeap, 0, info);

    SetErrorMode (oldErrorMode);

    return;
}

VOID
pGatherCPLs (
    VOID
    )
{
    CHAR winDir [MAX_PATH];
    PCSTR scrDir = NULL;
    TREE_ENUM e;

    if (GetWindowsDirectory (winDir, MAX_PATH) == 0) {
        return;
    }

    if (ISNT()) {
        scrDir = JoinPaths (winDir, "SYSTEM32");
    }
    else {
        scrDir = JoinPaths (winDir, "SYSTEM");
    }
    if (EnumFirstFileInTreeEx (&e, scrDir, "*.cpl", FALSE, FALSE, FILE_ENUM_THIS_LEVEL)) {
        do {
            if (!e.Directory) {
                pGetCPLFriendlyName (e.FullPath);
            }
        }
        while (EnumNextFileInTree (&e));
    }
    FreePathString (scrDir);
}

typedef struct _RUNKEY_STRUCT {
    PSTR ValueName;
    PSTR Value;
} RUNKEY_STRUCT, *PRUNKEY_STRUCT;


PRUNKEY_STRUCT
pAllocRunKeyStruct (
    IN      PCSTR ValueName,
    IN      PCSTR Value
    )
{
    PRUNKEY_STRUCT runKeyStruct;

    runKeyStruct = (PRUNKEY_STRUCT) PoolMemGetMemory (g_DataObjectPool, sizeof (RUNKEY_STRUCT));
    ZeroMemory (runKeyStruct, sizeof (RUNKEY_STRUCT));
    runKeyStruct->ValueName = PoolMemDuplicateString (g_DataObjectPool, ValueName);
    runKeyStruct->Value = PoolMemDuplicateString (g_DataObjectPool, Value);
    return runKeyStruct;
}

VOID
pGatherRunKeys (
    VOID
    )
{
    HKEY          runKey;
    PCTSTR        entryStr;
    REGVALUE_ENUM runKeyEnum;
    PDATAOBJECT Data;
    PCSTR displayName;

    runKey = OpenRegKeyStr (S_RUNKEY);
    if (runKey != NULL) {
        if (EnumFirstRegValue (&runKeyEnum, runKey)) {
            do {
                entryStr = GetRegValueString (runKey, runKeyEnum.ValueName);
                if (entryStr != NULL) {

                    displayName = JoinTextEx (NULL, runKeyEnum.ValueName, entryStr, " - ", 0, NULL);
                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = DOF_NO_SPLIT_ON_WACK;
                    FreeText (displayName);
                    Data->DllParam = pAllocRunKeyStruct (runKeyEnum.ValueName, entryStr);

                    MemFree (g_hHeap, 0, entryStr);
                }
            }
            while (EnumNextRegValue (&runKeyEnum));
        }
        CloseRegKey (runKey);
    }
    runKey = OpenRegKeyStr (S_RUNKEY_USER);
    if (runKey != NULL) {
        if (EnumFirstRegValue (&runKeyEnum, runKey)) {
            do {
                entryStr = GetRegValueString (runKey, runKeyEnum.ValueName);
                if (entryStr != NULL) {

                    displayName = JoinTextEx (NULL, runKeyEnum.ValueName, entryStr, " - ", 0, NULL);
                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = 0;
                    FreeText (displayName);
                    Data->DllParam = pAllocRunKeyStruct (runKeyEnum.ValueName, entryStr);

                    MemFree (g_hHeap, 0, entryStr);
                }
            }
            while (EnumNextRegValue (&runKeyEnum));
        }
        CloseRegKey (runKey);
    }
}


VOID
pGatherStartMenuItems (
    HKEY Key,
    PCSTR ValueName,
    BOOL DosApps
    )
{
    PCSTR entryStr;
    PCSTR expandedEntry;
    TREE_ENUM e;
    PDATAOBJECT Data;

    entryStr = GetRegValueString (Key, ValueName);
    if (entryStr) {
        expandedEntry = ExpandEnvironmentText (entryStr);

        if (EnumFirstFileInTreeEx (&e, expandedEntry, DosApps?"*.pif":"*.lnk", FALSE, FALSE, FILE_ENUM_ALL_LEVELS)) {
            do {
                if (!e.Directory) {
                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, e.SubPath);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = 0;
                    Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, e.FullPath);
                }
            }
            while (EnumNextFileInTree (&e));
        }

        if (expandedEntry != entryStr) {
            FreeText (expandedEntry);
        }
        MemFree (g_hHeap, 0, entryStr);
    }
}

VOID
pGatherStartMenu (
    BOOL DosApps
    )
{
    HKEY startMenuKey;

    startMenuKey = OpenRegKeyStr ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Common Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Common Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

    startMenuKey = OpenRegKeyStr ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

    startMenuKey = OpenRegKeyStr ("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Common Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Common Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

    startMenuKey = OpenRegKeyStr ("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

}

PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    )
{
    g_DataObjectPool = PoolMemInitNamedPool ("Data Objects");

    switch (DataTypeId) {

    case 0:
        // compatible Apps
        MessageBox (NULL, "Internal App DLL error:00004. Please contact calinn.", "Error", MB_OK);
        break;

    case 1:
        // compatible Apps
        MessageBox (NULL, "Internal App DLL error:00002. Please contact calinn.", "Error", MB_OK);
        break;

    case 2:
        // incompatible Apps
        pGatherStartMenu (FALSE);
        break;

    case 3:
        // incompatible DOS Apps
        pGatherStartMenu (TRUE);
        break;

    case 4:
        // Apps to be reinstalled
        pGatherStartMenu (FALSE);
        break;

    case 5:
        // Apps with minor problems
        pGatherStartMenu (FALSE);
        break;

    case 6:
        // DOS Apps with minor problems
        pGatherStartMenu (TRUE);
        break;

    case 7:
        // incompatible CPLs
        pGatherCPLs ();
        break;

    case 8:
        // CPLs with minor problems
        pGatherCPLs ();
        break;

    case 9:
        // incompatible SCRs
        pGatherScreenSavers ();
        break;

    case 10:
        // SCRs with minor problems
        pGatherScreenSavers ();
        break;

    case 11:
        // compatible RunKey entries
        pGatherRunKeys ();
        break;

    default:
        MessageBox (NULL, "Internal App DLL error:00001. Please contact calinn.", "Error", MB_OK);
        break;
    }

    *Count = g_DataObjects.End / sizeof (DATAOBJECT);

    return (PDATAOBJECT) g_DataObjects.Buf;
}

BOOL
pIncompatibleSCROutput (
    IN      HANDLE File
    )
{
    BOOL b = FALSE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;

    if (!WizardWriteRealString (File, "[Screen Savers - Incompatible]\r\n")) {
        return FALSE;
    }

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            if (GetFileAttributesLine ((PSTR)Data->DllParam, dataStr, MAX_PATH)) {
                b = WizardWriteString (File, dataStr);
                b = b && WizardWriteRealString (File, "\r\n");
                if (!b) break;
            }
        }
        Data++;
    }
    b = b && WizardWriteRealString (File, "\r\n");
    return b;
}

BOOL
pMinorProblemsSCROutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    BOOL b = FALSE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;

    if (!WizardWriteRealString (File, "[MinorProblems]\r\n")) {
        return FALSE;
    }

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            MYASSERT (GetFileExtensionFromPath ((PSTR)Data->DllParam));

            StringCopyAB (dataStr, GetFileNameFromPath ((PSTR)Data->DllParam), _mbsdec(GetFileNameFromPath ((PSTR)Data->DllParam), GetFileExtensionFromPath ((PSTR)Data->DllParam)));
            b = WizardWriteColumn (File, dataStr, 30);
            b = b && WizardWriteRealString (File, ", %");
            b = b && WizardWriteInfString (File, dataStr, FALSE, FALSE, TRUE, '_', 0);
            b = b && WizardWriteRealString (File, "%, ");
            b = b && GetFileAttributesLine ((PSTR)Data->DllParam, dataStr, MAX_PATH);
            b = b && WizardWriteString (File, dataStr);
            b = b && WizardWriteString (File, "\r\n");
            b = b && WizardWriteString (File, "[Strings]\r\n");
            StringCopyAB (dataStr, GetFileNameFromPath ((PSTR)Data->DllParam), _mbsdec(GetFileNameFromPath ((PSTR)Data->DllParam), GetFileExtensionFromPath ((PSTR)Data->DllParam)));
            b = b && WizardWriteInfString (File, dataStr, FALSE, FALSE, TRUE, '_', 0);
            b = b && WizardWriteColumn (File, "=", 1);
            b = b && WizardWriteInfString (File, Args->OptionalText, TRUE, TRUE, FALSE, 0, 0);
            b = b && WizardWriteRealString (File, "\r\n");
            if (!b) break;
        }
        Data++;
    }
    b = b && WizardWriteRealString (File, "\r\n");
    return b;
}

BOOL
pIncompatibleCPLOutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    BOOL b = FALSE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    PCPL_STRUCT cplStruct;

    if (!WizardWriteRealString (File, "[ControlPanelApplets]\r\n")) {
        return FALSE;
    }

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            cplStruct = (PCPL_STRUCT)Data->DllParam;

            if (GetFileAttributesLine ((PSTR)cplStruct->FullPathName, dataStr, MAX_PATH)) {
                b = WizardWriteQuotedColumn (File, cplStruct->FriendlyName?cplStruct->FriendlyName:Args->OptionalDescription, 30);
                b = b && WizardWriteRealString (File, ",, ");
                b = b && WizardWriteString (File, dataStr);
                b = b && WizardWriteRealString (File, "\r\n");
                if (!b) break;
            }
        }
        Data++;
    }
    b = b && WizardWriteRealString (File, "\r\n");
    return b;
}

BOOL
pMinorCPLOutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    BOOL b = FALSE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    PCPL_STRUCT cplStruct = NULL;

    if (!WizardWriteRealString (File, "[ControlPanelApplets]\r\n")) {
        return FALSE;
    }

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            cplStruct = (PCPL_STRUCT)Data->DllParam;

            if (GetFileAttributesLine ((PSTR)cplStruct->FullPathName, dataStr, MAX_PATH)) {
                b = WizardWriteQuotedColumn (File, cplStruct->FriendlyName?cplStruct->FriendlyName:Args->OptionalDescription, 30);
                b = b && WizardWriteRealString (File, ", %");
                b = b && WizardWriteInfString (File, cplStruct->FriendlyName?cplStruct->FriendlyName:Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
                b = b && WizardWriteRealString (File, "%, ");
                b = b && WizardWriteString (File, dataStr);
                b = b && WizardWriteRealString (File, "\r\n");
                if (!b) break;
            }
        }
        Data++;
    }
    b = b && WizardWriteRealString (File, "\r\n");
    b = b && WizardWriteRealString (File, "[Strings]\r\n");
    b = b && WizardWriteInfString (File, cplStruct->FriendlyName?cplStruct->FriendlyName:Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
    b = b && WizardWriteRealString (File, "=");
    b = b && WizardWriteInfString (File, Args->OptionalText, TRUE, TRUE, FALSE, 0, 0);
    b = b && WizardWriteRealString (File, "\r\n");
    return b;
}

PCTSTR
pSearchModule (
    IN      PCTSTR CommandLine
    )
{
    PTSTR nextChar;
    TCHAR module     [MAX_TCHAR_PATH] = TEXT("");
    TCHAR moduleLong [MAX_TCHAR_PATH] = TEXT("");
    PATH_ENUM pathEnum;
    PTSTR candidate;

    ExtractArgZero (CommandLine, module);
    nextChar = _tcsinc (module);
    if ((nextChar != NULL) &&
        (_tcsnextc (nextChar) == ':')
       ){
        if (!OurGetLongPathName (module, moduleLong, MAX_TCHAR_PATH)) {
            _tcsncpy (moduleLong, module, MAX_TCHAR_PATH);
        }
        return DuplicatePathString (moduleLong, 0);
    }
    else {
        if (EnumFirstPath (&pathEnum, NULL, g_WinDir, g_SystemDir)) {
            do {
                candidate = JoinPaths (pathEnum.PtrCurrPath, module);
                if (DoesFileExist (candidate)) {
                    return candidate;
                }
                FreePathString (candidate);
            }
            while (EnumNextPath (&pathEnum));
        }
        EnumPathAbort (&pathEnum);
    }
    return NULL;
}

BOOL
pCompatibleRunKeyOutput (
    IN      HANDLE File
    )
{
    BOOL b = FALSE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    PRUNKEY_STRUCT runKeyStruct;
    PCSTR fullFileName;

    if (!WizardWriteRealString (File, "[CompatibleRunKeyModules]\r\n")) {
        return FALSE;
    }

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            runKeyStruct = (PRUNKEY_STRUCT)Data->DllParam;

            fullFileName = pSearchModule (runKeyStruct->Value);

            if (fullFileName) {


                if (GetFileAttributesLine ((PSTR)fullFileName, dataStr, MAX_PATH)) {
                    b = WizardWriteQuotedColumn (File, runKeyStruct->ValueName, 30);
                    b = b && WizardWriteRealString (File, ",, ");
                    b = b && WizardWriteString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
                    if (!b) break;
                }
            }
        }
        Data++;
    }
    b = b && WizardWriteRealString (File, "\r\n");
    return b;
}

BOOL
pIncompatibleAppOutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args,
    IN      BOOL DosApp
    )
{
    BOOL b = TRUE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    IShellLink *ShellLink;
    IPersistFile *PersistFile;

    CHAR sTarget [MAX_PATH];
    CHAR sParams [MAX_PATH];
    CHAR sWorkDir [MAX_PATH];
    CHAR sIconPath [MAX_PATH];
    INT sIconNr;
    WORD sHotKey;
    BOOL sDosApp;
    BOOL sMsDosMode;

    DWORD fileCount = 0;
    PCSTR fileName=NULL;

    if (!InitCOMLink (&ShellLink, &PersistFile)) {
        return FALSE;
    }

    fileCount = 0;
    fileName = NULL;

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            b = b && ExtractShortcutInfo (
                        sTarget,
                        sParams,
                        sWorkDir,
                        sIconPath,
                        &sIconNr,
                        &sHotKey,
                        &sDosApp,
                        &sMsDosMode,
                        NULL,
                        NULL,
                        (PSTR)Data->DllParam,
                        ShellLink,
                        PersistFile);
            if (!b) {
                break;
            }

            fileCount ++;
            switch (fileCount) {

            case 1: fileName = DuplicatePathString (sTarget, 0);
                    b = b && WizardWriteRealString (File, DosApp?"[DosApps]\r\n":"[Incompatible]\r\n");
                    break;

            case 2: b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "\r\n\r\n");
                    b = b && WizardWriteRealString (File, "[");
                    b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "]\r\n");
                    b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");

            default:b = b && GetFileAttributesLine (sTarget, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
            }

        }
        Data++;
    }

    if (fileCount == 1) {
        b = b && WizardWriteRealString (File, Args->OptionalDescription);
        b = b && WizardWriteRealString (File, ",, ");
        b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
        b = b && WizardWriteRealString (File, dataStr);
        b = b && WizardWriteRealString (File, "\r\n");
    }

    if (fileCount) {
        b = b && WizardWriteRealString (File, "\r\n");
    }

    FreeCOMLink (&ShellLink, &PersistFile);

    return b;
}

BOOL
pReinstallAppOutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    BOOL b = TRUE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    IShellLink *ShellLink;
    IPersistFile *PersistFile;

    CHAR sTarget [MAX_PATH];
    CHAR sParams [MAX_PATH];
    CHAR sWorkDir [MAX_PATH];
    CHAR sIconPath [MAX_PATH];
    INT sIconNr;
    WORD sHotKey;
    BOOL sDosApp;
    BOOL sMsDosMode;

    DWORD fileCount = 0;
    PCSTR fileName=NULL;

    if (!InitCOMLink (&ShellLink, &PersistFile)) {
        return FALSE;
    }

    fileCount = 0;
    fileName = NULL;

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            b = b && ExtractShortcutInfo (
                        sTarget,
                        sParams,
                        sWorkDir,
                        sIconPath,
                        &sIconNr,
                        &sHotKey,
                        &sDosApp,
                        &sMsDosMode,
                        NULL,
                        NULL,
                        (PSTR)Data->DllParam,
                        ShellLink,
                        PersistFile);

            if (!b) {
                break;
            }

            fileCount ++;
            switch (fileCount) {

            case 1: fileName = DuplicatePathString (sTarget, 0);
                    b = b && WizardWriteRealString (File, "[Reinstall]\r\n");
                    break;

            case 2: b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "\r\n\r\n");
                    b = b && WizardWriteRealString (File, "[");
                    b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "]\r\n");
                    b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");

            default:b = b && GetFileAttributesLine (sTarget, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
            }
        }
        Data++;
    }

    if (fileCount == 1) {
        b = b && WizardWriteRealString (File, Args->OptionalDescription);
        b = b && WizardWriteRealString (File, ",, ");
        b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
        b = b && WizardWriteRealString (File, dataStr);
        b = b && WizardWriteRealString (File, "\r\n");
    }

    if (fileCount) {
        b = b && WizardWriteRealString (File, "\r\n");
    }

    FreeCOMLink (&ShellLink, &PersistFile);

    return b;
}

BOOL
pMinorProblemsAppOutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args,
    IN      BOOL DosApp
    )
{
    BOOL b = TRUE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    IShellLink *ShellLink;
    IPersistFile *PersistFile;

    CHAR sTarget [MAX_PATH];
    CHAR sParams [MAX_PATH];
    CHAR sWorkDir [MAX_PATH];
    CHAR sIconPath [MAX_PATH];
    INT sIconNr;
    WORD sHotKey;
    BOOL sDosApp;
    BOOL sMsDosMode;

    DWORD fileCount = 0;
    PCSTR fileName=NULL;

    if (!InitCOMLink (&ShellLink, &PersistFile)) {
        return FALSE;
    }

    fileCount = 0;
    fileName = NULL;

    while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
        if (Data->Flags & DOF_SELECTED) {

            b = b && ExtractShortcutInfo (
                        sTarget,
                        sParams,
                        sWorkDir,
                        sIconPath,
                        &sIconNr,
                        &sHotKey,
                        &sDosApp,
                        &sMsDosMode,
                        NULL,
                        NULL,
                        (PSTR)Data->DllParam,
                        ShellLink,
                        PersistFile);

            if (!b) {
                break;
            }

            fileCount ++;
            switch (fileCount) {

            case 1: fileName = DuplicatePathString (sTarget, 0);
                    b = b && WizardWriteRealString (File, DosApp?"[DosApps]\r\n":"[MinorProblems]\r\n");
                    break;

            case 2: b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, ", %");
                    b = b && WizardWriteInfString (File, Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
                    b = b && WizardWriteRealString (File, "%");
                    b = b && WizardWriteRealString (File, "\r\n\r\n");
                    b = b && WizardWriteRealString (File, "[");
                    b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "]\r\n");
                    b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");

            default:b = b && GetFileAttributesLine (sTarget, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
            }
        }
        Data++;
    }

    if (fileCount == 1) {
        b = b && WizardWriteRealString (File, Args->OptionalDescription);
        b = b && WizardWriteRealString (File, ", %");
        b = b && WizardWriteInfString (File, Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
        b = b && WizardWriteRealString (File, "%, ");
        b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
        b = b && WizardWriteRealString (File, dataStr);
        b = b && WizardWriteRealString (File, "\r\n");
    }

    if (fileCount) {
        b = b && WizardWriteRealString (File, "\r\n");
        b = b && WizardWriteRealString (File, "[Strings]\r\n");
        b = b && WizardWriteInfString (File, Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
        b = b && WizardWriteRealString (File, "=");
        b = b && WizardWriteInfString (File, Args->OptionalText, TRUE, TRUE, FALSE, 0, 0);
        b = b && WizardWriteRealString (File, "\r\n");
    }

    FreeCOMLink (&ShellLink, &PersistFile);

    return b;
}

BOOL
pCompatibleAppOutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    BOOL b = TRUE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    SNAP_FILE_ENUMA e;
    DWORD fileCount = 0;
    PCSTR fileName=NULL;

    fileCount = 0;
    fileName = NULL;

    if (EnumFirstSnapFile (&e, "*.EXE", SNAP_RESULT_CHANGED|SNAP_RESULT_ADDED)) {
        do {
            fileCount ++;
            switch (fileCount) {

            case 1: fileName = DuplicatePathString (e.FileName, 0);
                    b = b && WizardWriteRealString (File, "[CompatibleFiles]\r\n");
                    break;

            case 2: b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "\r\n\r\n");
                    b = b && WizardWriteRealString (File, "[");
                    b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "]\r\n");
                    b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");

            default:b = b && GetFileAttributesLine (e.FileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
            }
        } while (EnumNextSnapFile (&e));
    }

    if (fileCount == 1) {
        b = b && WizardWriteRealString (File, Args->OptionalDescription);
        b = b && WizardWriteRealString (File, ",, ");
        b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
        b = b && WizardWriteRealString (File, dataStr);
        b = b && WizardWriteRealString (File, "\r\n");
    }

    if (fileCount) {
        b = b && WizardWriteRealString (File, "\r\n");
    }

    return b;
}

BOOL
pIncompatibleAllOutput (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    BOOL b = TRUE;
    CHAR dataStr[MAX_PATH];
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    SNAP_FILE_ENUMA e;
    DWORD fileCount = 0;
    PCSTR fileName=NULL;

    fileCount = 0;
    fileName = NULL;

    if (EnumFirstSnapFile (&e, "*.EXE", SNAP_RESULT_CHANGED|SNAP_RESULT_ADDED)) {
        do {
            fileCount ++;
            switch (fileCount) {

            case 1: fileName = DuplicatePathString (e.FileName, 0);
                    b = b && WizardWriteRealString (File, "[Incompatible]\r\n");
                    break;

            case 2: b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "\r\n\r\n");
                    b = b && WizardWriteRealString (File, "[");
                    b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "]\r\n");
                    b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");

            default:b = b && GetFileAttributesLine (e.FileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
            }
        } while (EnumNextSnapFile (&e));
    }

    if (EnumFirstSnapFile (&e, "*.SCR", SNAP_RESULT_CHANGED|SNAP_RESULT_ADDED)) {
        do {
            fileCount ++;
            switch (fileCount) {

            case 1: fileName = DuplicatePathString (e.FileName, 0);
                    b = b && WizardWriteRealString (File, "[Incompatible]\r\n");
                    break;

            case 2: b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "\r\n\r\n");
                    b = b && WizardWriteRealString (File, "[");
                    b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "]\r\n");
                    b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");

            default:b = b && GetFileAttributesLine (e.FileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
            }
        } while (EnumNextSnapFile (&e));
    }

    if (fileCount == 1) {
        b = b && WizardWriteRealString (File, Args->OptionalDescription);
        b = b && WizardWriteRealString (File, ",, ");
        b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
        b = b && WizardWriteRealString (File, dataStr);
        b = b && WizardWriteRealString (File, "\r\n");
    }

    if (fileCount) {
        b = b && WizardWriteRealString (File, "\r\n");
    }

    fileCount = 0;
    fileName = NULL;

    if (EnumFirstSnapFile (&e, "*.CPL", SNAP_RESULT_CHANGED|SNAP_RESULT_ADDED)) {
        do {
            fileCount ++;
            switch (fileCount) {

            case 1: fileName = DuplicatePathString (e.FileName, 0);
                    b = b && WizardWriteRealString (File, "[ControlPanelApplets]\r\n");
                    break;

            case 2: b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "\r\n\r\n");
                    b = b && WizardWriteRealString (File, "[");
                    b = b && WizardWriteRealString (File, Args->OptionalDescription);
                    b = b && WizardWriteRealString (File, "-CPLs]\r\n");
                    b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");

            default:b = b && GetFileAttributesLine (e.FileName, dataStr, MAX_PATH);
                    b = b && WizardWriteRealString (File, dataStr);
                    b = b && WizardWriteRealString (File, "\r\n");
            }
        } while (EnumNextSnapFile (&e));
    }

    if (fileCount == 1) {
        b = b && WizardWriteRealString (File, Args->OptionalDescription);
        b = b && WizardWriteRealString (File, "-CPLs,, ");
        b = b && GetFileAttributesLine (fileName, dataStr, MAX_PATH);
        b = b && WizardWriteRealString (File, dataStr);
        b = b && WizardWriteRealString (File, "\r\n");
    }

    if (fileCount) {
        b = b && WizardWriteRealString (File, "\r\n");
    }
    return b;
}

BOOL
GenerateOutput (
    IN      POUTPUTARGS Args
    )
{
    BOOL b = FALSE;
    HANDLE File;
    CHAR Path[MAX_MBCHAR_PATH];

    switch (Args->DataTypeId) {

    case 0:
        // incompatible - snapshot
        wsprintf (Path, "%s\\IncAll.txt", Args->OutboundDir);
        break;

    case 1:
        // compatible Apps
        wsprintf (Path, "%s\\CompatA.txt", Args->OutboundDir);
        break;

    case 2:
        // incompatible Apps
        wsprintf (Path, "%s\\IncompA.txt", Args->OutboundDir);
        break;

    case 3:
        // incompatible DOS Apps
        wsprintf (Path, "%s\\IncompDA.txt", Args->OutboundDir);
        break;

    case 4:
        // Apps to be reinstalled
        wsprintf (Path, "%s\\ReinstA.txt", Args->OutboundDir);
        break;

    case 5:
        // Apps with minor problems
        wsprintf (Path, "%s\\MinorA.txt", Args->OutboundDir);
        break;

    case 6:
        // DOS Apps with minor problems
        wsprintf (Path, "%s\\MinorDA.txt", Args->OutboundDir);
        break;

    case 7:
        // incompatible CPLs
        wsprintf (Path, "%s\\IncCPL.txt", Args->OutboundDir);
        break;

    case 8:
        // incompatible CPLs
        wsprintf (Path, "%s\\MinorCPL.txt", Args->OutboundDir);
        break;

    case 9:
        // incompatible SCRs
        wsprintf (Path, "%s\\IncSCR.txt", Args->OutboundDir);
        break;

    case 10:
        // SCRs with minor problems
        wsprintf (Path, "%s\\MinorSCR.txt", Args->OutboundDir);
        break;

    case 11:
        // compatible RunKey entries
        wsprintf (Path, "%s\\CompatRK.txt", Args->OutboundDir);
        break;

    default:
        break;
    }

    printf ("Saving data to %s\n\n", Path);

    File = CreateFile (
                Path,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (File == INVALID_HANDLE_VALUE) {
        printf ("Can't open file for output.\n");
        return FALSE;
    }

    __try {
        SetFilePointer (File, 0, NULL, FILE_END);

        //
        // Write [Identification] for all .inx files
        //

        if (!WizardWriteRealString (File, "[Identification]\r\n")) {
            __leave;
        }

        //
        // Write user name and date/time
        //

        if (!WriteHeader (File)) {
            __leave;
        }

        switch (Args->DataTypeId) {

        case 0:
            // incompatible - snapshot
            b = pIncompatibleAllOutput (File, Args);
            break;

        case 1:
            // compatible Apps
            b = pCompatibleAppOutput (File, Args);
            break;

        case 2:
            // incompatible Apps
            b = pIncompatibleAppOutput (File, Args, FALSE);
            break;

        case 3:
            // incompatible DOS Apps
            b = pIncompatibleAppOutput (File, Args, TRUE);
            break;

        case 4:
            // Apps to be reinstalled
            b = pReinstallAppOutput (File, Args);
            break;

        case 5:
            // Apps with minor problems
            b = pMinorProblemsAppOutput (File, Args, FALSE);
            break;

        case 6:
            // DOS Apps with minor problems
            b = pMinorProblemsAppOutput (File, Args, TRUE);
            break;

        case 7:
            // incompatible CPLs
            b = pIncompatibleCPLOutput (File, Args);
            break;

        case 8:
            // CPLs with minor problems
            b = pMinorCPLOutput (File, Args);
            break;

        case 9:
            // incompatible SCRs
            b = pIncompatibleSCROutput (File);
            break;

        case 10:
            // SCRs with minor problems
            b = pMinorProblemsSCROutput (File, Args);
            break;

        case 11:
            // compatible RunKey entries
            b = pCompatibleRunKeyOutput (File);
            break;

        default:
            MessageBox (NULL, "Internal App DLL error:00003. Please contact calinn.", "Error", MB_OK);
        }

        //
        // Write a final blank line
        //

        b = b && WizardWriteRealString (File, "\r\n");
    }
    __finally {
        CloseHandle (File);
    }

    return b;
}

BOOL
DisplayOptionalUI (
    IN      POUTPUTARGS Args
    )
{
    PDATAOBJECT Data = (PDATAOBJECT) g_DataObjects.Buf;
    PCPL_STRUCT cplStruct;

    switch (Args->DataTypeId) {

    case 0:
    case 1:
        printf ("Taking a snapshot of your system. Please wait...");
        TakeSnapShotEx (SNAP_FILES);
        printf ("Done\n");
        MessageBox (NULL, "Please install your application and then press the OK button", "Install APP", MB_OK);
        printf ("Generating a diff. Please wait...");
        GenerateDiffOutputEx (NULL, NULL, FALSE, SNAP_FILES);
        printf ("Done\n");
        break;

    case 7:
    case 8:
        // incompatible CPLs
        while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {
            if (Data->Flags & DOF_SELECTED) {

                cplStruct = (PCPL_STRUCT)Data->DllParam;

                if (cplStruct->FriendlyName) {
                    g_DataTypes[Args->DataTypeId].Flags &= (~DTF_REQUIRE_DESCRIPTION);
                }
            }
            Data ++;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\cmntool\cmntool.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    TODO: cmntool.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    //
    // TODO: Add others here if needed (don't forget to prototype above)
    //

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        TEXT("  cmntool [/F:file]\n")

        TEXT("\nDescription:\n\n")

        //
        // TODO: Describe tool, indent 2 spaces
        //

        TEXT("  cmntool is a stub!\n")

        TEXT("\nArguments:\n\n")

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        TEXT("  /F  Specifies optional file name\n")

        );

    exit (1);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('f'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    FileArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    FileArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // TODO: Do work here
    //

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\badappid\makefile.inc ===
obj\$(TARGET_DIRECTORY)\badappid.res: badappid.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\cmntool\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\cue\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\badappid\dialogs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialogs.rc
//
#define IDD_GETFILES                    101
#define IDD_EDITITEM                    102
#define ID_CONTINUE                     1000
#define ID_QUIT                         1001
#define IDC_MAINFILE                    1002
#define IDC_BROWSE                      1003
#define IDC_REQFILES                    1004
#define IDC_ADDFILE                     1005
#define IDC_REMOVEFILE                  1006
#define IDC_NONET                       1007
#define IDC_FLAG1                       1007
#define IDC_FLAG2                       1008
#define IDC_STATIC2                     1009
#define IDC_FLAG3                       1010
#define IDC_APPTYPE1                    1011
#define IDC_APPTYPE3                    1012
#define IDC_APPTYPE4                    1013
#define IDC_STATIC4                     1014
#define IDC_STATIC1                     1015
#define IDC_APPTYPE2                    1016
#define IDC_APPTYPE5                    1017
#define IDC_APPTYPE6                    1018
#define IDC_MAINEDIT                    1020
#define IDC_MSGID                       1022
#define IDC_VERSION                     1023
#define IDC_SAVEMIGDB                   1100
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\collapse\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\badappid\badappid.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    badappid.c

Abstract:

    Implements a upgwiz wizard for obtaining various application information.

Author:

    Calin Negreanu (calinn)  10-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"
#include "..\..\w95upg\migapp\migdbp.h"
#include "dialogs.h"
#include <commdlg.h>
#include <badapps.h>
#include <newexe.h>

DATATYPE g_DataTypes[] = {
    {UPGWIZ_VERSION,
        "Generate AppsHelp entry",
        "You must specify the main EXE and a variable number of additional files.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },
};

typedef struct _ITEM_INFO {
    PSTR FilePath;
    PSTR VersionValue;
    UINT VersionIndex;
} ITEM_INFO, *PITEM_INFO;

PSTR g_MainFile = NULL;
GROWBUFFER g_AddnlFiles = GROWBUF_INIT;
UINT g_AppProblem = APPTYPE_INC_NOBLOCK;
BOOL g_AppFlags = 0;
BOOL g_SaveMigDb = TRUE;
DWORD g_MsgId = 0;

GROWBUFFER g_DataObjects = GROWBUF_INIT;
POOLHANDLE g_DataObjectPool;

HINSTANCE g_OurInst;

BOOL
Init (
    VOID
    )
{
#ifndef UPGWIZ4FLOPPY
    return InitToolMode (g_OurInst);
#else
    return TRUE;
#endif
}

VOID
Terminate (
    VOID
    )
{
    //
    // Local cleanup
    //

    FreeGrowBuffer (&g_DataObjects);

    if (g_DataObjectPool) {
        PoolMemDestroyPool (g_DataObjectPool);
    }

#ifndef UPGWIZ4FLOPPY
    TerminateToolMode (g_OurInst);
#endif
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_DETACH) {
        MYASSERT (g_OurInst == hInstance);
        Terminate();
    }

    g_OurInst = hInstance;

    return TRUE;
}


UINT
GiveVersion (
    VOID
    )
{
    Init();

    g_DataObjectPool = PoolMemInitNamedPool ("Data Objects");

    return UPGWIZ_VERSION;
}


PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    )
{
    UINT u;

    *Count = sizeof (g_DataTypes) / sizeof (g_DataTypes[0]);

    for (u = 0 ; u < *Count ; u++) {
        g_DataTypes[u].DataTypeId = u;
    }

    return g_DataTypes;
}

BOOL CALLBACK
pSetDefGuiFontProc(
    IN      HWND hwnd,
    IN      LPARAM lParam)
{
    SendMessage(hwnd, WM_SETFONT, lParam, 0L);
    return TRUE;
}


void
pSetDefGUIFont(
    IN      HWND hdlg
    )
{
    EnumChildWindows(hdlg, pSetDefGuiFontProc, (LPARAM)GetStockObject(DEFAULT_GUI_FONT));
}

BOOL
CALLBACK
pGetFilesUIProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CHAR tempStr [MEMDB_MAX];
    static CHAR lastDir [MEMDB_MAX] = "";
    OPENFILENAME ofn;
    UINT Index;

    switch (uMsg) {
    case WM_INITDIALOG:
        pSetDefGUIFont(hdlg);

        CheckDlgButton (hdlg, IDC_SAVEMIGDB, BST_CHECKED);
        CheckDlgButton (hdlg, IDC_NONET, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE1, BST_CHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE2, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE3, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE4, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE5, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE6, BST_UNCHECKED);

        sprintf (tempStr, "%d", g_MsgId);
        SendDlgItemMessage (hdlg, IDC_MSGID, WM_SETTEXT, 0, (LPARAM)tempStr);

        EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), FALSE);
        EnableWindow (GetDlgItem (hdlg, IDC_VERSION), FALSE);
        PostMessage (hdlg, WM_COMMAND, IDC_BROWSE, 0);
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_MAINFILE:

            if (HIWORD (wParam) == EN_CHANGE) {

                if (g_MainFile) {
                    FreePathString (g_MainFile);
                    g_MainFile = NULL;
                }
                SendDlgItemMessage (hdlg, IDC_MAINFILE, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
                g_MainFile = DuplicatePathString (tempStr, 0);
                if (DoesFileExist (g_MainFile)) {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), TRUE);
                } else {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), FALSE);
                }
            }

            break;

        case IDC_BROWSE:
            if (g_MainFile) {
                StringCopy (tempStr, g_MainFile);
            } else {
                *tempStr = 0;
            }
            ZeroMemory (&ofn, sizeof (OPENFILENAME));
            ofn.lStructSize = sizeof (OPENFILENAME);
            ofn.hwndOwner = hdlg;
            ofn.lpstrFile = tempStr;
            ofn.nMaxFile = MEMDB_MAX;
            ofn.lpstrInitialDir = lastDir;
            ofn.lpstrTitle = "Select Main File";
            ofn.Flags = OFN_NOCHANGEDIR | OFN_NODEREFERENCELINKS | OFN_HIDEREADONLY;
            if (GetOpenFileName (&ofn)) {
                //let's copy the last directory
                StringCopyAB (lastDir, tempStr, _mbsdec (tempStr, tempStr + ofn.nFileOffset));
                if (g_MainFile) {
                    FreePathString (g_MainFile);
                }
                g_MainFile = DuplicatePathString (tempStr, 0);
                if (DoesFileExist (g_MainFile)) {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), TRUE);
                } else {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), FALSE);
                }
                SendDlgItemMessage (hdlg, IDC_MAINFILE, WM_SETTEXT, 0, (LPARAM)g_MainFile);
            }
            break;

        case IDC_ADDFILE:
            *tempStr = 0;
            ZeroMemory (&ofn, sizeof (OPENFILENAME));
            ofn.lStructSize = sizeof (OPENFILENAME);
            ofn.hwndOwner = hdlg;
            ofn.lpstrFile = tempStr;
            ofn.nMaxFile = MEMDB_MAX;
            ofn.lpstrInitialDir = lastDir;
            ofn.lpstrTitle = "Add Required File";
            ofn.Flags = OFN_NOCHANGEDIR | OFN_NODEREFERENCELINKS | OFN_HIDEREADONLY;
            if (GetOpenFileName (&ofn)) {
                //let's copy the last directory
                StringCopyAB (lastDir, tempStr, _mbsdec (tempStr, tempStr + ofn.nFileOffset));
                Index = SendDlgItemMessage (hdlg, IDC_REQFILES, LB_ADDSTRING, 0, (LPARAM)tempStr);
                SendDlgItemMessage (hdlg, IDC_REQFILES, LB_SETCURSEL, Index, 0);
            }
            break;

        case IDC_REMOVEFILE:
            Index = SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCURSEL, 0, 0);
            if (Index != LB_ERR) {
                SendDlgItemMessage (hdlg, IDC_REQFILES, LB_DELETESTRING, Index, 0);
                if (Index >= (UINT)SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCOUNT, 0, 0)) {
                    SendDlgItemMessage (
                        hdlg,
                        IDC_REQFILES,
                        LB_SETCURSEL,
                        SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCOUNT, 0, 0) - 1,
                        0
                        );
                } else {
                    SendDlgItemMessage (hdlg, IDC_REQFILES, LB_SETCURSEL, Index, 0);
                }
            }
            break;

        case IDC_APPTYPE1:
        case IDC_APPTYPE2:
        case IDC_APPTYPE3:
        case IDC_APPTYPE4:
        case IDC_APPTYPE5:
        case IDC_APPTYPE6:
            if (IsDlgButtonChecked (hdlg, IDC_APPTYPE5)) {
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG1), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG2), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG3), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_SAVEMIGDB), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_MSGID), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_VERSION), TRUE);
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE6)) {
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG1), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG2), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG3), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_SAVEMIGDB), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_MSGID), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_VERSION), FALSE);
            } else {
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG1), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG2), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG3), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_SAVEMIGDB), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_MSGID), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_VERSION), FALSE);
            }
            break;
        case ID_CONTINUE:
            g_SaveMigDb = IsDlgButtonChecked (hdlg, IDC_SAVEMIGDB);
            if (IsDlgButtonChecked (hdlg, IDC_FLAG1)) {
                g_AppFlags |= APPTYPE_FLAG_NONET;
            }
            if (IsDlgButtonChecked (hdlg, IDC_FLAG2)) {
                g_AppFlags |= APPTYPE_FLAG_FAT32;
            }
            if (IsDlgButtonChecked (hdlg, IDC_FLAG3)) {
                g_AppFlags |= APPTYPE_FLAG_NTFS;
            }
            g_AppProblem = APPTYPE_INC_NOBLOCK;
            if (IsDlgButtonChecked (hdlg, IDC_APPTYPE1)) {
                g_AppProblem = APPTYPE_INC_NOBLOCK;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE2)) {
                g_AppProblem = APPTYPE_INC_HARDBLOCK;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE3)) {
                g_AppProblem = APPTYPE_MINORPROBLEM;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE4)) {
                g_AppProblem = APPTYPE_REINSTALL;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE5)) {
                g_AppProblem = APPTYPE_VERSIONSUB;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE6)) {
                g_AppProblem = APPTYPE_SHIM;
            }
            if (g_AppProblem == APPTYPE_VERSIONSUB) {
                SendDlgItemMessage (hdlg, IDC_VERSION, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
                g_SaveMigDb = FALSE;
                g_AppFlags = 0;
            } else if (g_AppProblem == APPTYPE_SHIM) {
                tempStr[0] = 0;
                g_SaveMigDb = FALSE;
                g_AppFlags = 0;
            } else {
                SendDlgItemMessage (hdlg, IDC_MSGID, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
            }
            g_MsgId = strtoul (tempStr, NULL, 10);

            Index = (UINT)SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCOUNT, 0, 0);
            while (Index) {
                if (SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETTEXT, Index - 1, (LPARAM) tempStr) != LB_ERR) {
                    MultiSzAppend (&g_AddnlFiles, tempStr);
                }
                Index --;
            }
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
        case ID_QUIT:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }

        break;
    }

    return FALSE;
}

BOOL
GatherInfoUI (
    HINSTANCE LocalDllInstance,
    IN      UINT DataTypeId
    )
{
    BOOL result = TRUE;

    switch (DataTypeId) {

    case 0:
        if (g_MainFile) {
            FreePathString (g_MainFile);
            g_MainFile = NULL;
        }
        if (g_AddnlFiles.Buf) {
            FreeGrowBuffer (&g_AddnlFiles);
        }
        g_AppFlags = 0;
        g_SaveMigDb = TRUE;
        g_MsgId = 0;
        result = (ID_CONTINUE == DialogBox (LocalDllInstance, MAKEINTRESOURCE(IDD_GETFILES), NULL, pGetFilesUIProc));
        break;
    default:
        MessageBox (NULL, "Internal BadApps DLL error:00004. Please contact calinn.", "Error", MB_OK);
        result = FALSE;
    }

    return result;
}


PSTR g_ExeTypesStr[] = {
    "NONE",
    "DOS",
    "WIN16",
    "WIN32"
};

PCTSTR
QueryCompanyName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "COMPANYNAME");
}

PCTSTR
QueryProductVersion (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "PRODUCTVERSION");
}

PCTSTR
QueryProductName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "PRODUCTNAME");
}

PCTSTR
QueryFileDescription (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "FILEDESCRIPTION");
}

PCTSTR
QueryFileVersion (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "FILEVERSION");
}

PCTSTR
QueryOriginalFileName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "ORIGINALFILENAME");
}

PCTSTR
QueryInternalName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "INTERNALNAME");
}

PCTSTR
QueryLegalCopyright (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "LEGALCOPYRIGHT");
}

PCTSTR
Query16BitDescription (
    IN      PCTSTR FilePath
    )
{
    return Get16ModuleDescription (FilePath);
}

PCTSTR
QueryModuleType (
    IN      PCTSTR FilePath
    )
{
    return g_ExeTypesStr [GetModuleType (FilePath)];
}

PCTSTR
QueryFileSize (
    IN      PCSTR FilePath
    )
{
    HANDLE findHandle;
    WIN32_FIND_DATA findData;
    CHAR result[10];

    findHandle = FindFirstFile (FilePath, &findData);
    if (findHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    sprintf (result, "0x%08lX", findData.nFileSizeLow);
    FindClose (findHandle);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileCheckSum (
    IN      PCTSTR FilePath
    )
{
    UINT checkSum;
    FILE_HELPER_PARAMS Params;
    WIN32_FIND_DATA findData;
    TCHAR result[10];
    HANDLE findHandle;

    Params.Handled = 0;
    Params.FullFileSpec = FilePath;
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (FilePath);
    Params.CurrentDirData = NULL;
    findHandle = FindFirstFile (FilePath, &findData);
    if (findHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    Params.FindData = &findData;
    Params.VirtualFile = FALSE;
    checkSum = ComputeCheckSum (&Params);
    sprintf (result, "0x%08lX", checkSum);
    FindClose (findHandle);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFilePECheckSum (
    IN      PCSTR FilePath
    )
{
    ULONG checkSum;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    checkSum = GetPECheckSum (FilePath);
    if (checkSum == 0) {
        return NULL;
    }
    sprintf (result, "0x%0lX", checkSum);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryBinFileVer (
    IN      PCSTR FilePath
    )
{
    ULONGLONG value;
    PWORD valueIdx;
    TCHAR result[24];

    valueIdx = (PWORD) (&value);
    value = GetBinFileVer (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "%d.%d.%d.%d", *(valueIdx + 3), *(valueIdx + 2), *(valueIdx + 1), *valueIdx);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryBinProductVer (
    IN      PCSTR FilePath
    )
{
    ULONGLONG value;
    PWORD valueIdx;
    TCHAR result[24];

    valueIdx = (PWORD) (&value);
    value = GetBinProductVer (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "%d.%d.%d.%d", *(valueIdx + 3), *(valueIdx + 2), *(valueIdx + 1), *valueIdx);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileDateHi (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileDateHi (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileDateLo (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileDateLo (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileVerOs (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileVerOs (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileVerType (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileVerType (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsMajorVersion (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwMajorVersion);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsMinorVersion (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwMinorVersion);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsPlatformId (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwPlatformId);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsBuildNo (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwBuildNumber);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

BOOL
OutputDecValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PDWORD result;

    result = MemAlloc (g_hHeap, 0, sizeof (DWORD));
    if (!result) {
        return FALSE;
    }
    sscanf (VersionValue, "%ld", result);
    *Data = (PBYTE)result;
    *Size = sizeof (DWORD);
    return TRUE;
}

BOOL
OutputHexValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PDWORD result;

    result = MemAlloc (g_hHeap, 0, sizeof (DWORD));
    if (!result) {
        return FALSE;
    }
    sscanf (VersionValue, "%lx", result);
    *Data = (PBYTE)result;
    *Size = sizeof (DWORD);
    return TRUE;
}

BOOL
OutputModuleTypeValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PDWORD result;

    result = MemAlloc (g_hHeap, 0, sizeof (DWORD));
    if (!result) {
        return FALSE;
    }
    *result = 0;
    if (StringIMatch (VersionValue, "NONE")) {
        *result = 0;
    }
    if (StringIMatch (VersionValue, "DOS")) {
        *result = 1;
    }
    if (StringIMatch (VersionValue, "WIN16")) {
        *result = 2;
    }
    if (StringIMatch (VersionValue, "WIN32")) {
        *result = 3;
    }
    *Data = (PBYTE)result;
    *Size = sizeof (DWORD);
    return TRUE;
}

BOOL
OutputStrValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PWSTR result;
    PCWSTR convStr;

    convStr = ConvertAtoW (VersionValue);
    *Size = (wcslen (convStr) + 1) * sizeof (WCHAR);
    result = MemAlloc (g_hHeap, 0, *Size);
    if (!result) {
        return FALSE;
    }
    StringCopyW (result, convStr);
    FreeConvertedStr (convStr);
    *Data = (PBYTE)result;
    return TRUE;
}

typedef struct {
    ULONGLONG Value;
    ULONGLONG Mask;
} BINVER_DATA, *PBINVER_DATA;

BOOL
OutputBinVerValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PBINVER_DATA result;
    PWORD maskIdx;
    PWORD valueIdx;
    UINT index;

    result = MemAlloc (g_hHeap, 0, sizeof (BINVER_DATA));
    if (!result) {
        return FALSE;
    }
    result->Value = 0;
    result->Mask = 0;
    *Size = sizeof (BINVER_DATA);

    maskIdx = (PWORD)&(result->Mask) + 3;
    valueIdx = (PWORD)&(result->Value) + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) strtoul ((PSTR)VersionValue, &((PSTR)VersionValue), 10);
        if (*VersionValue && (_mbsnextc (VersionValue) != '.')) {
            *Data = (PBYTE)result;
            return TRUE;
        }
        VersionValue = _mbsinc (VersionValue);
        *maskIdx = 0xFFFF;
        valueIdx --;
        maskIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

BOOL
OutputUpToBinVerValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PULONGLONG result;
    PWORD valueIdx;
    UINT index;

    result = MemAlloc (g_hHeap, 0, sizeof (ULONGLONG));
    if (!result) {
        return FALSE;
    }
    *result = 0;
    *Size = sizeof (ULONGLONG);

    valueIdx = (PWORD)result + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) strtoul ((PSTR)VersionValue, &((PSTR)VersionValue), 10);
        if (*VersionValue && (_mbsnextc (VersionValue) != '.')) {
            *Data = (PBYTE)result;
            return TRUE;
        }
        VersionValue = _mbsinc (VersionValue);
        valueIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

typedef PCTSTR (VERSION_QUERY_PROTOTYPE) (PCTSTR FilePath);
typedef VERSION_QUERY_PROTOTYPE * PVERSION_QUERY_PROTOTYPE;

typedef BOOL (VERSION_OUTPUT_PROTOTYPE) (PCTSTR VersionValue, DWORD *Size, PBYTE *Data);
typedef VERSION_OUTPUT_PROTOTYPE * PVERSION_OUTPUT_PROTOTYPE;

typedef struct _VERSION_DATA {
    DWORD   VersionId;
    PCSTR   VersionName;
    PCSTR   DisplayName;
    PCSTR   VersionValue;
    DWORD   Allowance;
    BOOL    Modifiable;
    PVERSION_QUERY_PROTOTYPE VersionQuery;
    PVERSION_OUTPUT_PROTOTYPE VersionOutput;
} VERSION_DATA, *PVERSION_DATA;

#define LIBARGS(id, fn) {id,
#define TOOLARGS(name, dispName, allowance, edit, query, output) name,dispName,NULL,allowance,edit,query,output},
VERSION_DATA g_ToolVersionData [] = {
                              VERSION_STAMPS
                              {0, NULL, NULL, NULL, 0, FALSE, NULL, NULL}
                              };
#undef TOOLARGS
#undef LIBARGS


VOID
pGatherFilesAttributes (
    VOID
    )
{
    PDATAOBJECT Data;
    MULTISZ_ENUM multiSzEnum;
    PSTR filePath;
    PVERSION_DATA p;
    PITEM_INFO info;
    UINT versionIdx;
    TCHAR buffer [MEMDB_MAX];

    p = g_ToolVersionData;
    versionIdx = 0;
    while (p->VersionName) {
        p->VersionValue = p->VersionQuery(g_MainFile);
        if ((p->VersionValue) && (p->Allowance & VA_ALLOWMAINFILE)) {

            Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
            filePath = PoolMemDuplicateString (g_DataObjectPool, g_MainFile);
            ReplaceWacks (filePath);
            sprintf (buffer, "%s - %s", p->DisplayName, p->VersionValue);
            Data->NameOrPath = JoinPaths (filePath, buffer);
            Data->Version = UPGWIZ_VERSION;
            Data->Flags = DOF_NO_SORT;
            info = (PITEM_INFO) PoolMemGetMemory (g_DataObjectPool, sizeof (ITEM_INFO));
            info->FilePath = PoolMemDuplicateString (g_DataObjectPool, g_MainFile);
            info->VersionValue = PoolMemDuplicateString (g_DataObjectPool, p->VersionValue);
            info->VersionIndex = versionIdx;
            Data->DllParam = info;
        }
        p++;
        versionIdx++;
    }

    if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {
        do {
            p = g_ToolVersionData;
            versionIdx = 0;
            while (p->VersionName) {
                p->VersionValue = p->VersionQuery(multiSzEnum.CurrentString);
                if ((p->VersionValue) && (p->Allowance & VA_ALLOWADDNLFILES)) {

                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    filePath = PoolMemDuplicateString (g_DataObjectPool, multiSzEnum.CurrentString);
                    ReplaceWacks (filePath);
                    sprintf (buffer, "%s - %s", p->DisplayName, p->VersionValue);
                    Data->NameOrPath = JoinPaths (filePath, buffer);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = DOF_NO_SORT;
                    info = (PITEM_INFO) PoolMemGetMemory (g_DataObjectPool, sizeof (ITEM_INFO));
                    info->FilePath = PoolMemDuplicateString (g_DataObjectPool, multiSzEnum.CurrentString);
                    info->VersionValue = PoolMemDuplicateString (g_DataObjectPool, p->VersionValue);
                    info->VersionIndex = versionIdx;
                    Data->DllParam = info;
                }
                p++;
                versionIdx++;
            }

        } while (EnumNextMultiSz (&multiSzEnum));
    }
}

PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    )
{
    switch (DataTypeId) {

    case 0:
        // Bad apps
        pGatherFilesAttributes ();
        break;

    default:
        MessageBox (NULL, "Internal BadApps DLL error:00001. Please contact calinn.", "Error", MB_OK);
        break;
    }

    *Count = g_DataObjects.End / sizeof (DATAOBJECT);

    return (PDATAOBJECT) g_DataObjects.Buf;
}

#define ID_EDITMENUITEM 200

BOOL
CALLBACK
pEditItemUIProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSTR * editStr;
    CHAR tempStr [MEMDB_MAX];

    switch (uMsg) {
    case WM_INITDIALOG:
        editStr = ((PSTR *) lParam);
        pSetDefGUIFont(hdlg);
        SendDlgItemMessage (hdlg, IDC_MAINEDIT, WM_SETTEXT, 0, (LPARAM)(*editStr));
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_MAINEDIT:

            if (HIWORD (wParam) == EN_CHANGE) {

                if (*editStr) {
                    FreePathString (*editStr);
                    *editStr = NULL;
                }
                SendDlgItemMessage (hdlg, IDC_MAINEDIT, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
                *editStr = DuplicatePathString (tempStr, 0);
            }
            break;

        case IDOK:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
        case ID_QUIT:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }
        break;
    }

    return FALSE;
}

BOOL
Handle_RMouse (
    IN      HINSTANCE LocalDllInstance,
    IN      HWND Owner,
    IN      PDATAOBJECT DataObject,
    IN      PPOINT pt
    )
{
    PITEM_INFO info;
    TCHAR buffer [MEMDB_MAX];
    PVERSION_DATA p;
    UINT versionIdx;
    HMENU menu;
    PSTR newVersion;

    info = (PITEM_INFO) DataObject->DllParam;
    p = g_ToolVersionData;
    versionIdx = 0;
    while (p->VersionName) {
        if (versionIdx == info->VersionIndex) {
            break;
        }
        versionIdx ++;
        p ++;
    }
    if (!p->VersionName) {
        return FALSE;
    }
    if (!p->Modifiable) {
        return FALSE;
    }

    menu = CreatePopupMenu ();
    AppendMenu (menu, MF_STRING, ID_EDITMENUITEM, "Edit");
    if (TrackPopupMenu (menu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_TOPALIGN, pt->x, pt->y, 0, Owner, NULL) == ID_EDITMENUITEM) {

        newVersion = DuplicatePathString (info->VersionValue, 0);
        if (DialogBoxParam (LocalDllInstance, MAKEINTRESOURCE(IDD_EDITITEM), NULL, pEditItemUIProc, (LPARAM)(&newVersion)) == IDOK) {

            FreePathString (DataObject->NameOrPath);
            PoolMemReleaseMemory (g_DataObjectPool, (PVOID)info->VersionValue);
            info->VersionValue = PoolMemDuplicateString (g_DataObjectPool, newVersion);
            sprintf (buffer, "%s - %s", p->DisplayName, newVersion);
            DataObject->NameOrPath = DuplicatePathString (buffer, 0);
            return TRUE;
        }
        FreePathString (newVersion);
    }
    return FALSE;
}

PSTR
pGetRelativePath (
    IN      PCSTR MainFile,
    IN      PCSTR AddnlFile
    )
{
    UINT Index = 0;
    PCSTR p,q;
    CHAR result [MEMDB_MAX] = "";
    PSTR resultIdx = result;

    p = _mbschr (MainFile, '\\');
    q = _mbschr (AddnlFile, '\\');

    while (p && q) {
        if ((p - MainFile) != (q - AddnlFile)) {
            break;
        }
        if (!StringIMatchByteCount (MainFile, AddnlFile, p - MainFile)) {
            break;
        }
        if (!StringIMatchByteCount (MainFile, AddnlFile, q - AddnlFile)) {
            break;
        }
        Index += (p - MainFile);
        MainFile = _mbsinc (p);
        AddnlFile = _mbsinc (q);
        p = _mbschr (MainFile, '\\');
        q = _mbschr (AddnlFile, '\\');
    }

    if (Index > 0) {
        while (p) {
            StringCopy (resultIdx, "..\\");
            resultIdx = GetEndOfString (resultIdx);
            MainFile = _mbsinc (p);
            p = _mbschr (MainFile, '\\');
        }
        StringCopy (resultIdx, AddnlFile);
        return (DuplicatePathString (result, 0));
    }
    return NULL;
}

BOOL
pFilesAttribOutput_MigDb (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    PITEM_INFO info;
    UINT sectCount;
    CHAR sectName [MEMDB_MAX];
    PSTR relPath;
    MULTISZ_ENUM multiSzEnum;
    PDATAOBJECT Data = NULL;

    switch (g_AppProblem) {
    case APPTYPE_INC_NOBLOCK:
    case APPTYPE_INC_HARDBLOCK:
        WizardWriteRealString (File, "[Incompatible]\r\n");
        break;
    case APPTYPE_MINORPROBLEM:
        WizardWriteRealString (File, "[MinorProblems]\r\n");
        break;
    case APPTYPE_REINSTALL:
        WizardWriteRealString (File, "[Reinstall]\r\n");
        break;
    default:
        MessageBox (NULL, "Internal BadApps DLL error:00006. Please contact calinn.", "Error", MB_OK);
    }

    WizardWriteQuotedColumn (File, Args->OptionalDescription, 30);

    if (g_AppProblem == APPTYPE_MINORPROBLEM) {
        WizardWriteRealString (File, ", %");
        WizardWriteInfString (File, Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
        WizardWriteRealString (File, "%");
    }

    if (g_AddnlFiles.Buf) {
        // we have additional files. We will create as many sections as needed.

        Data = (PDATAOBJECT) g_DataObjects.Buf;

        WizardWriteRealString (File, ", ");
        WizardWriteRealString (File, GetFileNameFromPath (g_MainFile));

        while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

            if (Data->Flags & DOF_SELECTED) {

                info = (PITEM_INFO)Data->DllParam;

                if (StringIMatch (g_MainFile, info->FilePath)) {

                    WizardWriteRealString (File, ", ");
                    WizardWriteRealString (File, g_ToolVersionData[info->VersionIndex].VersionName);
                    WizardWriteRealString (File, "(");
                    WizardWriteInfString (File, info->VersionValue, TRUE, FALSE, FALSE, 0, 0);
                    WizardWriteRealString (File, ")");
                }
            }
            Data++;
        }
        sectCount = 1;

        if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {
            do {

                sprintf (sectName, "REQFILE(%s.Req%d)", Args->OptionalDescription, sectCount);
                WizardWriteRealString (File, ", ");
                WizardWriteInfString (File, sectName, FALSE, FALSE, TRUE, '_', 0);
                sectCount ++;

            } while (EnumNextMultiSz (&multiSzEnum));
        }

        WizardWriteRealString (File, "\r\n");
        WizardWriteRealString (File, "\r\n");

        sectCount = 1;

        if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {

            do {

                sprintf (sectName, "[%s.Req%d]\r\n", Args->OptionalDescription, sectCount);
                WizardWriteInfString (File, sectName, FALSE, FALSE, TRUE, '_', 0);
                relPath = pGetRelativePath (g_MainFile, multiSzEnum.CurrentString);
                if (!relPath) {
                    sprintf (sectName, "Could not get relative path for:%s)", multiSzEnum.CurrentString);
                    MessageBox (NULL, sectName, "Error", MB_OK);
                    relPath = DuplicatePathString (multiSzEnum.CurrentString, 0);
                }
                WizardWriteRealString (File, relPath);
                FreePathString (relPath);

                Data = (PDATAOBJECT) g_DataObjects.Buf;

                while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

                    if (Data->Flags & DOF_SELECTED) {

                        info = (PITEM_INFO)Data->DllParam;

                        if (StringIMatch (multiSzEnum.CurrentString, info->FilePath)) {

                            WizardWriteRealString (File, ", ");
                            WizardWriteRealString (File, g_ToolVersionData[info->VersionIndex].VersionName);
                            WizardWriteRealString (File, "(");
                            WizardWriteInfString (File, info->VersionValue, TRUE, FALSE, FALSE, 0, 0);
                            WizardWriteRealString (File, ")");
                        }
                    }
                    Data++;
                }

                WizardWriteRealString (File, "\r\n");
                WizardWriteRealString (File, "\r\n");
                sectCount ++;

            } while (EnumNextMultiSz (&multiSzEnum));
        }
    } else {
        // we have only one file. We will write it in the same line.

        Data = (PDATAOBJECT) g_DataObjects.Buf;

        WizardWriteRealString (File, ", ");
        WizardWriteRealString (File, GetFileNameFromPath (g_MainFile));

        while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

            if (Data->Flags & DOF_SELECTED) {

                info = (PITEM_INFO)Data->DllParam;
                WizardWriteRealString (File, ", ");
                WizardWriteRealString (File, g_ToolVersionData[info->VersionIndex].VersionName);
                WizardWriteRealString (File, "(");
                WizardWriteInfString (File, info->VersionValue, TRUE, FALSE, FALSE, 0, 0);
                WizardWriteRealString (File, ")");
            }
            Data++;
        }
        WizardWriteRealString (File, "\r\n");
        WizardWriteRealString (File, "\r\n");
    }

    if (g_AppProblem == APPTYPE_MINORPROBLEM) {
        WizardWriteRealString (File, "[Strings]\r\n");
        WizardWriteInfString (File, Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
        WizardWriteRealString (File, "=");
        WizardWriteInfString (File, Args->OptionalText, TRUE, TRUE, FALSE, 0, 0);
        WizardWriteRealString (File, "\r\n");
        WizardWriteRealString (File, "\r\n");
    }

    return TRUE;
}

BOOL
pWriteBlob (
    IN      HANDLE File,
    IN      PBYTE Data,
    IN      DWORD Size,
    IN      DWORD LineLen
    )
{
    CHAR result[4];
    DWORD lineLen = 0;

    while (Size>1) {
        sprintf (result, "%02X,", *Data);
        WizardWriteRealString (File, result);
        lineLen += 3;
        if (lineLen >= LineLen) {
            WizardWriteRealString (File, "\\\r\n");
            lineLen = 0;
        }
        Size --;
        Data ++;
    }
    if (Size) {
        sprintf (result, "%02X", *Data);
        WizardWriteRealString (File, result);
    }
    return TRUE;
}

BOOL
pFilesAttribOutput_BadApps (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    PSTR fullKey;
    GROWBUFFER Buffer = GROWBUF_INIT;
    BADAPP_PROP appProp;
    PDATAOBJECT DataObject = NULL;
    PITEM_INFO info;
    PVERSION_DATA p;
    UINT versionIdx;
    PBYTE Data;
    DWORD DataSize;
    DWORD TotalSize = 0;
    MULTISZ_ENUM multiSzEnum;
    PSTR relPath;
    CHAR tmpStr[MEMDB_MAX];

    WizardWriteRealString (File, "HKLM,");

    fullKey = JoinPaths ("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility", GetFileNameFromPath (g_MainFile));

    WizardWriteQuotedColumn (File, fullKey, 0);
    FreePathString (fullKey);
    WizardWriteRealString (File, ",");
    WizardWriteQuotedColumn (File, "Sequencer", 0);
    WizardWriteRealString (File, ",0x00030003,\\\r\n");

    //now it's a good time to generate the BLOB

    //first thing - add data about MsgId and the app problem
    appProp.Size = sizeof (BADAPP_PROP);
    appProp.MsgId = g_MsgId;
    appProp.AppType = 0;
    appProp.AppType = g_AppProblem | g_AppFlags;
    CopyMemory (GrowBuffer (&Buffer, sizeof (BADAPP_PROP)), &appProp, sizeof (BADAPP_PROP));
    TotalSize += sizeof (BADAPP_PROP);

    //next - add data about main file attributes
    DataObject = (PDATAOBJECT) g_DataObjects.Buf;

    while ((DWORD)DataObject < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

        if (DataObject->Flags & DOF_SELECTED) {

            info = (PITEM_INFO)DataObject->DllParam;

            if (StringIMatch (g_MainFile, info->FilePath)) {

                p = g_ToolVersionData;
                versionIdx = 0;
                while (p->VersionName) {
                    if (versionIdx == info->VersionIndex) {
                        break;
                    }
                    versionIdx ++;
                    p ++;
                }
                if (p->VersionName) {
                    if (p->VersionOutput (info->VersionValue, &DataSize, &Data)) {
                        CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &(p->VersionId), sizeof (DWORD));
                        TotalSize += sizeof (DWORD);
                        CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                        TotalSize += sizeof (DWORD);
                        CopyMemory (GrowBuffer (&Buffer, DataSize), Data, DataSize);
                        TotalSize += DataSize;
                        MemFree (g_hHeap, 0, Data);
                    }
                }
            }
        }
        DataObject++;
    }

    if (g_AddnlFiles.Buf) {
        // we have additional files. We will create as many sections as needed.
        if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {

            do {
                relPath = pGetRelativePath (g_MainFile, multiSzEnum.CurrentString);
                if (!relPath) {
                    sprintf (tmpStr, "Could not get relative path for:%s)", multiSzEnum.CurrentString);
                    MessageBox (NULL, tmpStr, "Error", MB_OK);
                    relPath = DuplicatePathString (multiSzEnum.CurrentString, 0);
                }
                // now let's write the addnl file in UNICODE

                DataSize = VTID_REQFILE;
                CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                TotalSize += sizeof (DWORD);
                OutputStrValue (relPath, &DataSize, &Data);
                CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                TotalSize += sizeof (DWORD);
                CopyMemory (GrowBuffer (&Buffer, DataSize), Data, DataSize);
                TotalSize += DataSize;
                MemFree (g_hHeap, 0, Data);

                DataObject = (PDATAOBJECT) g_DataObjects.Buf;

                while ((DWORD)DataObject < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

                    if (DataObject->Flags & DOF_SELECTED) {

                        info = (PITEM_INFO)DataObject->DllParam;

                        if (StringIMatch (multiSzEnum.CurrentString, info->FilePath)) {

                            p = g_ToolVersionData;
                            versionIdx = 0;
                            while (p->VersionName) {
                                if (versionIdx == info->VersionIndex) {
                                    break;
                                }
                                versionIdx ++;
                                p ++;
                            }
                            if (p->VersionName) {
                                if (p->VersionOutput (info->VersionValue, &DataSize, &Data)) {
                                    CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &(p->VersionId), sizeof (DWORD));
                                    TotalSize += sizeof (DWORD);
                                    CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                                    TotalSize += sizeof (DWORD);
                                    CopyMemory (GrowBuffer (&Buffer, DataSize), Data, DataSize);
                                    TotalSize += DataSize;
                                    MemFree (g_hHeap, 0, Data);
                                }
                            }
                        }
                    }
                    DataObject++;
                }
            } while (EnumNextMultiSz (&multiSzEnum));
        }
    }
    DataSize = 0;
    CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
    TotalSize += sizeof (DWORD);

    //now it's a good time to write the BLOB
    pWriteBlob (File, Buffer.Buf, TotalSize, 80);

    return TRUE;
}

BOOL
GenerateOutput (
    IN      POUTPUTARGS Args
    )
{
    BOOL b = FALSE;
    HANDLE File;
    CHAR Path[MAX_MBCHAR_PATH];

    switch (Args->DataTypeId) {

    case 0:
        // bad apps
        wsprintf (Path, "%s\\badapps.txt", Args->OutboundDir);
        break;

    default:
        MessageBox (NULL, "Internal BadApps DLL error:00002. Please contact calinn.", "Error", MB_OK);
    }

    printf ("Saving data to %s\n\n", Path);

    File = CreateFile (
                Path,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (File == INVALID_HANDLE_VALUE) {
        printf ("Can't open file for output.\n");
        return FALSE;
    }

    __try {
        SetFilePointer (File, 0, NULL, FILE_END);

        //
        // Write user name and date/time
        //

        if (!WriteHeader (File)) {
            __leave;
        }

        switch (Args->DataTypeId) {

        case 0:
            // bad apps
            if (g_SaveMigDb) {
                b = pFilesAttribOutput_MigDb (File, Args);
            } else {
                b = TRUE;
            }
            b = b && pFilesAttribOutput_BadApps (File, Args);
            break;

        default:
            MessageBox (NULL, "Internal BadApps DLL error:00003. Please contact calinn.", "Error", MB_OK);
        }

        //
        // Write a final blank line
        //

        b = b && WizardWriteRealString (File, "\r\n");
    }
    __finally {
        CloseHandle (File);
    }

    return b;
}

BOOL
DisplayOptionalUI (
    IN      POUTPUTARGS Args
    )
{
    switch (Args->DataTypeId) {

    case 0:
        if (g_AppProblem == APPTYPE_MINORPROBLEM) {
            g_DataTypes[Args->DataTypeId].Flags |= (DTF_REQUIRE_TEXT);
        }
        break;
    default:
        MessageBox (NULL, "Internal BadApps DLL error:00005. Please contact calinn.", "Error", MB_OK);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\datafilt\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\domain\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\datafilt\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\collapse\collapse.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    collapse.c

Abstract:

    Takes the formatting spaces out of an INF

Author:

    Jim Schmidt (jimschm) 08-Jun-1999

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        TEXT("  collapse <file> [output]\n")

        TEXT("\nDescription:\n\n")

        TEXT("  collapse takes the spaces out of an INF\n")

        TEXT("\nArguments:\n\n")

        TEXT("  file    Specifies the input file name.\n")
        TEXT("  output  Specifies the output file name.  If not specified,\n")
        TEXT("          the original file is updated in place.\n")

        );

    exit (1);
}


#define MAX_BLOCK_SIZE      65536


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR OutputArg = NULL;
    PCTSTR FileArg = NULL;
    HANDLE Src, Dest;
    BOOL QuoteMode;
    BYTE InBuffer[MAX_BLOCK_SIZE];
    BYTE OutBuffer[MAX_BLOCK_SIZE];
    BOOL Unicode;
    TCHAR TempPath[MAX_TCHAR_PATH];
    TCHAR TempFile[MAX_TCHAR_PATH];
    DWORD Attribs;
    BOOL b;
    DWORD BytesRead;
    DWORD BytesWritten;
    PCSTR AnsiPtr, AnsiEnd;
    PCWSTR UnicodePtr, UnicodeEnd;
    PSTR AnsiOutPtr;
    PWSTR UnicodeOutPtr;
    PBYTE End;
    WORD LastChar;
    UINT Line;
    BOOL Comments;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            HelpAndExit();
        } else {
            if (OutputArg) {
                HelpAndExit();
            } else if (FileArg) {
                OutputArg = argv[i];
            } else {
                FileArg = argv[i];
            }
        }
    }

    //
    // Validate args
    //

    if (!FileArg) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    if (!OutputArg) {
        OutputArg = FileArg;
    }

    GetTempPath (ARRAYSIZE(TempPath), TempPath);
    GetTempFileName (TempPath, TEXT("u2a"), 0, TempFile);

    Src = CreateFile (
            FileArg,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if (Src != INVALID_HANDLE_VALUE) {

        b = TRUE;

        Attribs = GetFileAttributes (FileArg);

        Dest = CreateFile (
                TempFile,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

        if (Dest == INVALID_HANDLE_VALUE) {
            b = FALSE;
        }

    } else {
        _tprintf (TEXT("Can't open %s for read permission.\n"), FileArg);
        b = FALSE;
    }

    if (b) {
        //
        // Src and Dest are valid now.  Determine if Src is unicode.
        //

        b = ReadFile (Src, InBuffer, 2, &BytesRead, NULL);

        if (b && BytesRead == 2) {

            if (InBuffer[0] != 0xFF || InBuffer[1] != 0xFE) {
                SetFilePointer (Src, 0, NULL, FILE_BEGIN);
                Unicode = FALSE;
            } else {
                Unicode = TRUE;
            }
        }
    }

    if (b) {
        //
        // Do the conversion
        //

        LastChar = 0;
        QuoteMode = FALSE;
        Line = 1;
        Comments = FALSE;

        do {
            b = ReadFile (Src, InBuffer, ARRAYSIZE(InBuffer), &BytesRead, NULL);

            if (!b) {
                _tprintf (TEXT("Can't read from %s, error=%u\n"), Src, GetLastError());
                break;
            }

            if (!BytesRead) {
                //
                // Done
                //

                break;
            }

            if (!Unicode) {

                AnsiPtr = (PCSTR) InBuffer;
                AnsiEnd = (PCSTR) (InBuffer + BytesRead);
                AnsiOutPtr = (PSTR) OutBuffer;

                while (AnsiPtr < AnsiEnd) {

                    if (*AnsiPtr == ';') {
                        Comments = TRUE;
                    }

                    if (*AnsiPtr == '\r' || *AnsiPtr == '\n') {

                        if (LastChar != '\r' && QuoteMode) {
                            _tprintf (TEXT("Unmatched quotes found at line %u\n"), Line);
                        }

                        QuoteMode = FALSE;
                        Comments = FALSE;

                        if (LastChar != '\r' || *AnsiPtr != '\n') {
                            Line++;
                        }

                        LastChar = (WORD) (*AnsiPtr);
                        *AnsiOutPtr++ = *AnsiPtr;

                    } else if (!Comments) {

                        if (LastChar == '\r' || LastChar == '\n') {
                            if (*AnsiPtr == '@') {
                                LastChar = (WORD) (*AnsiPtr);
                            } else {
                                LastChar = 0;
                            }
                        } else if (LastChar == '@') {
                            if (*AnsiPtr == '*') {
                                LastChar = (WORD) (*AnsiPtr);
                            } else {
                                LastChar = 0;
                            }
                        } else if (LastChar == '*') {
                            if (*AnsiPtr == ':') {
                                Comments = TRUE;
                            }

                            LastChar = 0;

                        } else {

                            LastChar = 0;

                        }

                        if (Comments) {

                            *AnsiOutPtr++ = *AnsiPtr;

                        } else {

                            if (*AnsiPtr == '\"') {

                                QuoteMode = !QuoteMode;
                                *AnsiOutPtr++ = *AnsiPtr;

                            }

                            else if (QuoteMode || *AnsiPtr != ' ') {

                                *AnsiOutPtr++ = *AnsiPtr;

                            }

                        }

                    } else {

                        *AnsiOutPtr++ = *AnsiPtr;

                    }

                    AnsiPtr++;
                }

                End = (PBYTE) AnsiOutPtr;

            } else {
                UnicodePtr = (PCWSTR) InBuffer;
                UnicodeEnd = (PCWSTR) (InBuffer + BytesRead);
                UnicodeOutPtr = (PWSTR) OutBuffer;

                while (UnicodePtr < UnicodeEnd) {

                    if (*UnicodePtr == L';') {
                        Comments = TRUE;
                    }

                    if (*UnicodePtr == L'\r' || *UnicodePtr == L'\n') {

                        if (LastChar != L'\r' && QuoteMode) {
                            _tprintf (TEXT("Unmatched quotes found at line %u\n"), Line);
                        }

                        QuoteMode = FALSE;
                        Comments = FALSE;

                        if (LastChar != L'\r' || *UnicodePtr != L'\n') {
                            Line++;
                        }

                        LastChar = (WORD) (*UnicodePtr);
                        *UnicodeOutPtr++ = *UnicodePtr;

                    } else if (!Comments) {

                        if (LastChar == L'\r' || LastChar == L'\n') {
                            if (*UnicodePtr == L'@') {
                                LastChar = (WORD) (*UnicodePtr);
                            } else {
                                LastChar = 0;
                            }
                        } else if (LastChar == L'@') {
                            if (*UnicodePtr == L'*') {
                                LastChar = (WORD) (*UnicodePtr);
                            } else {
                                LastChar = 0;
                            }
                        } else if (LastChar == L'*') {
                            if (*UnicodePtr == L':') {
                                Comments = TRUE;
                            }

                            LastChar = 0;

                        } else {

                            LastChar = 0;

                        }

                        if (Comments) {

                            *UnicodeOutPtr++ = *UnicodePtr;

                        } else {

                            if (*UnicodePtr == L'\"') {

                                QuoteMode = !QuoteMode;
                                *UnicodeOutPtr++ = *UnicodePtr;

                            }

                            else if (QuoteMode || *UnicodePtr != L' ') {

                                *UnicodeOutPtr++ = *UnicodePtr;

                            }

                        }

                    } else {

                        *UnicodeOutPtr++ = *UnicodePtr;

                    }

                    UnicodePtr++;
                }

                End = (PBYTE) UnicodeOutPtr;
            }

            //
            // Now write the output
            //

            if (End > OutBuffer) {
                b = WriteFile (
                        Dest,
                        OutBuffer,
                        End - OutBuffer,
                        &BytesWritten,
                        NULL
                        );

                if (!b) {
                    _tprintf (TEXT("Can't write to %s, error=%u\n"), TempFile, GetLastError());
                }
            }

        } while (b);
    }

    //
    // If success, rename the temp file to the output file
    //

    if (b) {
        CloseHandle (Src);
        CloseHandle (Dest);

        Src = INVALID_HANDLE_VALUE;
        Dest = INVALID_HANDLE_VALUE;

        SetFileAttributes (OutputArg, FILE_ATTRIBUTE_NORMAL);

        b = MoveFileEx (
                TempFile,
                OutputArg,
                MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING
                );

        if (!b) {
            _tprintf (TEXT("Can't move %s to %s, error=%u\n"), TempFile, OutputArg, GetLastError());
        } else {
            SetFileAttributes (OutputArg, Attribs);
        }
    }

    //
    // Cleanup
    //

    if (Src != INVALID_HANDLE_VALUE) {
        CloseHandle (Src);
    }

    if (Dest != INVALID_HANDLE_VALUE) {
        CloseHandle (Dest);
    }

    if (!b) {
        DeleteFile (Dest);
    } else {
        if (!StringIMatch (FileArg, OutputArg)) {
            _tprintf (TEXT("Collapse of %s to %s was successful\n"), FileArg, OutputArg);
        } else {
            _tprintf (TEXT("Collapse of %s was successful\n"), FileArg);
        }
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\doswiz\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\cue\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\dynupdt\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\cue\cue.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cue.c

Abstract:

    Generates command prompt aliases

Author:

    Jim Schmidt (jimschm)   13-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


HANDLE g_hHeap;
HINSTANCE g_hInst;

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "cue [-c:cmd] [-a:alias] [root]\n"
            "\n"
            "-c         Specifies command, default is cd /d %%d\\$1\n"
            "-a         Specifies alias format string, default is %%n\n"
            "[root]     Specifies root directory to scan\n"
            "\n"
            "The -c and -a options can have the following symbols:\n"
            "\n"
            "   %%d      Specifies full directory path\n"
            "   %%n      Specifies directory name\n"
            "\n"
            "The output can be copied to cue.pri in the razzle environment.\n"
            );

    exit(0);
}

GROWLIST g_VarNames = GROWLIST_INIT;
GROWBUFFER g_VarVals = GROWBUF_INIT;

VOID
pInitEnvVars (
    VOID
    )
{
    PCSTR Env;
    PCSTR p;
    CHAR VarName[512];
    PSTR VarVal;

    Env = GetEnvironmentStrings();
    Env = GetEndOfStringA (Env) + 1;
    Env = GetEndOfStringA (Env) + 1;

    p = Env;
    while (*p) {
        _mbscpy (VarName, p);
        p = GetEndOfStringA (p) + 1;

        if (*VarName != '_') {
            continue;
        }

        VarVal = _mbschr (VarName, '=');
        if (VarVal) {

            *VarVal = 0;
            VarVal++;

            GrowListAppendString (&g_VarNames, VarName);
            MultiSzAppend (&g_VarVals, VarVal);
        }
    }
}

VOID
pFreeEnvVars (
    VOID
    )
{
    FreeGrowList (&g_VarNames);
    FreeGrowBuffer (&g_VarVals);
}

VOID
pUseEnvVars (
    IN OUT  PSTR String
    )
{
    PSTR p;
    UINT u;
    UINT Best;
    UINT Length;
    UINT BestLength;
    PCSTR q;
    CHAR NewString[1024];
    PSTR d;

    p = String;
    d = NewString;

    do {
        q = (PCSTR) g_VarVals.Buf;
        BestLength = 0;
        u = 0;
        Best = 0xffffffff;

        while (*q) {

            Length = _mbslen (q);
            if (Length > 3) {

                if (!_mbsnicmp (p, q, Length)) {
                    if (Length > BestLength) {
                        Best = u;
                        BestLength = Length;
                    }
                }

            }

            q = GetEndOfStringA (q) + 1;
            u++;
        }

        if (Best != 0xffffffff) {
            q = GrowListGetString (&g_VarNames, Best);

            *d++ = '%';
            StringCopyA (d, q);
            d = GetEndOfStringA (d);
            *d++ = '%';

            p += BestLength;
        } else {
            *d++ = *p++;
        }
    } while (*p);

    *d = 0;

    StringCopyA (String, NewString);
}


VOID
pGenerateString (
    IN      PCSTR Format,
    OUT     PSTR String,
    IN      PCSTR Directory,
    IN      PCSTR FullPath
    )
{
    PSTR p;
    PCSTR q;

    q = Format;
    p = String;

    while (*q) {
        if (*q == '%') {
            q++;
            switch (tolower (*q)) {

            case 'n':
                StringCopyA (p, Directory);
                p = GetEndOfStringA (p);
                break;

            case 'd':
                StringCopyA (p, FullPath);
                p = GetEndOfStringA (p);
                break;

            default:
                if (*q != 0) {
                    *p++ = *q;
                } else {
                    q--;
                }

                break;
            }

            q++;

        } else {
            *p++ = *q++;
        }
    }

    *p = 0;
}


VOID
AddString (
    PCSTR String
    )
{
    MemDbSetValue (String, 0);
}

BOOL
FindString (
    PCSTR String
    )
{
    return MemDbGetValue (String, NULL);
}


BOOL
pIsAliasInUse (
    IN      PCSTR Alias,
    IN OUT  PGROWLIST NewAliases
    )
{
    LONG rc;
    CHAR CmdLine[512];
    UINT Size;
    UINT u;
    PCSTR p;
    UINT Len;
    PSTR DontCare;

    //
    // Scan new aliases first.  Two or more identical aliases are ambiguous,
    // so we find them and delete them.
    //

    Size = GrowListGetSize (NewAliases);
    wsprintf (CmdLine, "%s ", Alias);
    Len = _mbslen (CmdLine);

    for (u = 0 ; u < Size ; u++) {
        p = GrowListGetString (NewAliases, u);
        if (!_mbsnicmp (p, CmdLine, Len)) {
            GrowListDeleteItem (NewAliases, u);
            return TRUE;
        }

    }

    //
    // Now see if the alias was already defined
    //

    if (FindString (Alias)) {
        return TRUE;
    }

    //
    // Finally verify the alias is not an EXE in the path
    //

    wsprintf (CmdLine, "%s.exe", Alias);
    if (SearchPath (NULL, CmdLine, NULL, 512, CmdLine, &DontCare)) {
        return TRUE;
    }

    wsprintf (CmdLine, "%s.bat", Alias);
    if (SearchPath (NULL, CmdLine, NULL, 512, CmdLine, &DontCare)) {
        return TRUE;
    }

    wsprintf (CmdLine, "%s.cmd", Alias);
    if (SearchPath (NULL, CmdLine, NULL, 512, CmdLine, &DontCare)) {
        return TRUE;
    }

    return FALSE;
}


VOID
pAddAlias (
    IN OUT  PGROWLIST NewAliases,
    IN      PCSTR AliasStr,
    IN      PCSTR CommandStr
    )
{
    CHAR CmdLine[512];

    AddString (AliasStr);
    wsprintf (CmdLine, "%s %s", AliasStr, CommandStr);
    GrowListAppendString (NewAliases, CmdLine);
}

VOID
pProcessCueFile (
    IN      PCSTR Path,
    IN      PCSTR FileName
    )
{
    HANDLE File;
    CHAR CmdLine[512];
    PSTR p;
    PCSTR q;
    DWORD Read;
    DWORD Size;
    DWORD Pos;
    CHAR FullPath[MAX_PATH];

    wsprintf (FullPath, "%s\\%s", Path, FileName);

    File = CreateFile (
               FullPath,
               GENERIC_READ,
               0,
               NULL,
               OPEN_EXISTING,
               FILE_ATTRIBUTE_NORMAL,
               NULL
               );

    if (File != INVALID_HANDLE_VALUE) {
        Size = GetFileSize (File, NULL);
        for (Pos = 0 ; Pos < Size ; Pos += Read) {
            SetFilePointer (File, Pos, NULL, FILE_BEGIN);
            if (!ReadFile (File, CmdLine, 256, &Read, NULL)) {
                break;
            }

            //
            // Find end of line
            //

            CmdLine[Read] = 0;
            p = _mbschr (CmdLine, '\n');
            if (p) {
                *p = 0;
                Read = p - CmdLine + 1;
            } else {
                p = _mbschr (CmdLine, '\r');
                if (p) {
                    *p = 0;
                    Read = p - CmdLine + 1;
                } else {
                    p = GetEndOfStringA (CmdLine);
                    Read = p - CmdLine;
                }
            }

            //
            // Add alias
            //

            q = CmdLine;
            while (isspace (*q)) {
                q++;
            }

            p = (PSTR) q;
            while (*p && !isspace (*p)) {
                p++;
            }

            if (*p) {
                *p = 0;

                AddString (q);
            }
        }

        CloseHandle (File);
    }
}


BOOL
MemDb_Entry (
    HINSTANCE hInst,
    DWORD Reason,
    PVOID DontCare
    );

BOOL
MigUtil_Entry (
    HINSTANCE hInst,
    DWORD Reason,
    PVOID DontCare
    );

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    TREE_ENUM e;
    GROWLIST NewAliases = GROWLIST_INIT;
    PCSTR RootPath;
    INT i;
    UINT u;
    UINT Size;
    PCSTR Alias = "%n";
    PCSTR Command = "cd /d %d\\$1";
    CHAR AliasStr[256];
    CHAR CommandStr[256];
    CHAR PubPath[MAX_PATH];
    CHAR PriPath[MAX_PATH];
    PSTR p;
    CHAR CurDir[MAX_PATH];

    GetCurrentDirectory (MAX_PATH, CurDir);
    RootPath = NULL;

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL);
    MemDb_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL);

    for (i = 1 ; i < argc ; i++) {

        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {

            case 'c':
                if (argv[i][2] != ':') {
                    i++;
                    if (i == argc) {
                        HelpAndExit();
                    }

                    Command = argv[i];
                } else {
                    Command = &argv[i][3];
                }

                break;

            case 'a':
                if (argv[i][2] != ':') {
                    i++;
                    if (i == argc) {
                        HelpAndExit();
                    }

                    Alias = argv[i];
                } else {
                    Alias = &argv[i][3];
                }

                break;

            default:
                HelpAndExit();
            }
        }

        else if (RootPath) {
            HelpAndExit();
        }

        else {
            RootPath = argv[i];
        }
    }

    if (!RootPath) {
        RootPath = CurDir;
    }

    //
    // Parse the ntcue.pub, cue.pub and cue.pri files
    //

    if (!GetEnvironmentVariable ("INIT", PriPath, MAX_PATH)) {
        printf ("Must be in razzle environment to run this tool\n");
        return -1;
    }

    StringCopyA (PubPath, PriPath);
    p = _mbsrchr (PubPath, '\\');
    if (!p) {
        printf ("Must be in razzle environment to run this tool\n");
        return -1;
    }

    *p = 0;

    pProcessCueFile (PubPath, "ntcue.pub");
    pProcessCueFile (PubPath, "cue.pub");
    pProcessCueFile (PriPath, "cue.pri");

    //
    // Add commands
    //

    AddString ("cd");
    AddString ("dir");
    AddString ("copy");
    AddString ("type");
    AddString ("del");
    AddString ("erase");
    AddString ("color");
    AddString ("md");
    AddString ("chdir");
    AddString ("mkdir");
    AddString ("prompt");
    AddString ("pushd");
    AddString ("popd");
    AddString ("set");
    AddString ("setlocal");
    AddString ("endlocal");
    AddString ("if");
    AddString ("for");
    AddString ("call");
    AddString ("shift");
    AddString ("goto");
    AddString ("start");
    AddString ("assoc");
    AddString ("ftype");
    AddString ("exit");
    AddString ("ren");
    AddString ("rename");
    AddString ("move");

    pInitEnvVars();

    //
    // Scan the specified directory
    //

    if (EnumFirstFileInTree (&e, RootPath, NULL, TRUE)) {
        do {
            if (!e.Directory) {
                continue;
            }

            pGenerateString (Alias, AliasStr, e.Name, e.FullPath);

            if (pIsAliasInUse (AliasStr, &NewAliases)) {
                continue;
            }

            pGenerateString (Command, CommandStr, e.Name, e.FullPath);
            pUseEnvVars (CommandStr);

            pAddAlias (&NewAliases, AliasStr, CommandStr);

        } while (EnumNextFileInTree (&e));
    }


    Size = GrowListGetSize (&NewAliases);

    for (u = 0 ; u < Size ; u++) {
        p = (PSTR) GrowListGetString (&NewAliases, u);
        printf ("%s\n", p);
    }

    FreeGrowList (&NewAliases);

    pFreeEnvVars();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\domain\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\domain\domain.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    w9xtool.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    if (argc != 3) {
        printf ("Usage:\n\ndomain <domain_to_query> <computer_name>\n\n");
        return 1;
    }

    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    if (DoesComputerAccountExistOnDomain (argv[1], argv[2], TRUE)) {
        printf ("%s on %s exists\n", argv[2], argv[1]);
    } else {
        printf ("%s on %s does not exist\n", argv[2], argv[1]);
    }

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\doswiz\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\dynupdt\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\enumtree\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\enumtree\pch.h ===
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\datafilt\datafilt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    nttool.c

Abstract:

    Implements a stub tool that is designed to run with NT-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

PBYTE
FilterRegValue (
    IN      PBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD DataType,
    IN      PCTSTR KeyForDbgMsg,        OPTIONAL
    OUT     PDWORD NewDataSize
    );

VOID
pFixUpMemDb2 (
    VOID
    );

BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


VOID
Test (
    IN      PCTSTR CmdLine
    )
{
    static PTSTR ValueData = NULL;
    DWORD NewSize;

    ValueData = ReuseAlloc (g_hHeap, ValueData, SizeOfString (CmdLine));
    StringCopy (ValueData, CmdLine);

    ValueData = (PTSTR) FilterRegValue (
                            (PBYTE) ValueData,
                            SizeOfString (ValueData),
                            REG_SZ,
                            TEXT("foo"),
                            &NewSize
                            );

    _tprintf (TEXT("[%s]\n"), ValueData);
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    MemDbLoad (TEXT("c:\\public\\ntsetup.dat"));
    pFixUpMemDb2();

    Test (TEXT("C:\\WINDOWS\\PBRUSH.EXE"));
    Test (TEXT("C:\\WINDOWS\\SendTo\\Fax Recipient.lnk"));
    Test (TEXT("notepad C:\\WINDOWS\\ShellNew\\WORDPFCT.WPG"));
    Test (TEXT("c:\\command.com"));
    Test (TEXT("C:\\PROGRA~1\\NETMEE~1\\WB32.EXE"));
    Test (TEXT("C:\\WINDOWS\\Start Menu\\Programs\\Internet Explorer.lnk"));
    Test (TEXT("SCRNSAVE.EXE c:\\WINDOWS\\SYSTEM\\3D Text.scr"));
    Test (TEXT("SCRNSAVE.EXE \"c:\\WINDOWS\\SYSTEM\\3D Text.scr\""));
    Test (TEXT("c:\\WINDOWS\\MPLAYER.EXE FOO.WAV"));
    Test (TEXT("C:\\PROGRA~1\\ACCESS~1\\WORDPAD.EXE"));
    Test (TEXT("notepad,C:\\WINDOWS\\Start Menu\\Programs\\Internet Explorer.lnk"));
    Test (TEXT("TEST C:\\WINDOWS\\SYSTEM\\ICWSCRPT.EXE"));
    Test (TEXT("C:\\WINDOWS\\PBRUSH.EXE C:\\PROGRA~1\\ACCESS~1\\WORDPAD.EXE"));
    Test (TEXT("C:\\WINDOWS\\PBRUSH.EXE,C:\\PROGRA~1\\ACCESS~1\\WORDPAD.EXE"));


    Terminate();

    return 0;
}


PCTSTR
pGetProfilePathForUser (
    IN      PCTSTR User
    )
{
    static TCHAR Path[MAX_TCHAR_PATH];

    wsprintf (Path, TEXT("c:\\windows\\profiles\\%s"), User);
    return Path;
}



VOID
pFixUpDynamicPaths2 (
    PCTSTR Category
    )
{
    MEMDB_ENUM e;
    TCHAR Pattern[MEMDB_MAX];
    PTSTR p;
    GROWBUFFER Roots = GROWBUF_INIT;
    MULTISZ_ENUM e2;
    TCHAR NewRoot[MEMDB_MAX];
    PCTSTR ProfilePath;

    //
    // Collect all the roots that need to be renamed
    //

    StringCopy (Pattern, Category);
    p = AppendWack (Pattern);
    StringCopy (p, TEXT("*"));

    if (MemDbEnumFirstValue (&e, Pattern, MEMDB_THIS_LEVEL_ONLY, MEMDB_ALL_BUT_PROXY)) {
        do {
            if (_tcsnextc (e.szName) == TEXT('>')) {
                StringCopy (p, e.szName);
                MultiSzAppend (&Roots, Pattern);
            }
        } while (MemDbEnumNextValue (&e));
    }

    //
    // Now change each root
    //

    if (EnumFirstMultiSz (&e2, (PCTSTR) Roots.Buf)) {
        do {
            //
            // Compute NewRoot
            //

            StringCopy (NewRoot, e2.CurrentString);

            p = _tcschr (NewRoot, TEXT('>'));
            MYASSERT (p);

            ProfilePath = pGetProfilePathForUser (_tcsinc (p));
            if (!ProfilePath) {
                DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
            } else {
                StringCopy (p, ProfilePath);
                MemDbMoveTree (e2.CurrentString, NewRoot);
            }

        } while (EnumNextMultiSz (&e2));
    }

    FreeGrowBuffer (&Roots);
}


VOID
pFixUpMemDb2 (
    VOID
    )
{
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_DATA);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_USERFILEMOVE_DEST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\extract\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\dynupdt\dynupdt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    nttool.c

Abstract:

    Implements a stub tool that is designed to run with NT-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "setupapi.h"
#include "sputils.h"
#include "setupapi.h"
#include "regstr.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}

#define MyMalloc(s) HeapAlloc(g_hHeap,0,s)
#define MyRealloc(p,s) HeapReAlloc(g_hHeap,0,p,s)
#define MyFree(p) HeapFree(g_hHeap,0,p)

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

DWORD
TreeCopy(
    IN PCWSTR SourceDir,
    IN PCWSTR TargetDir
    )
{
    DWORD d;
    WCHAR Pattern[MAX_PATH];
    WCHAR NewTarget[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // First create the target directory if it doesn't already exist.
    //
    if(!CreateDirectory(TargetDir,NULL)) {
        d = GetLastError();
        if(d != ERROR_ALREADY_EXISTS) {
            return(d);
        }
    }

    //
    // Copy each file in the source directory to the target directory.
    // If any directories are encountered along the way recurse to copy them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <sourcedir>\*.
    //
    lstrcpyn(Pattern,SourceDir,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {

        d = NO_ERROR;

    } else {

        do {

            //
            // Form the full name of the file or directory we just found
            // as well as its name in the target.
            //
            lstrcpyn(Pattern,SourceDir,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            lstrcpyn(NewTarget,TargetDir,MAX_PATH);
            pSetupConcatenatePaths(NewTarget,FindData.cFileName,MAX_PATH,NULL);

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                    d = TreeCopy(Pattern,NewTarget);
                } else {
                    d = NO_ERROR;
                }

            } else {

                //
                // The current match is not a directory -- so copy it.
                //
                SetFileAttributes(NewTarget,FILE_ATTRIBUTE_NORMAL);
                d = CopyFile(Pattern,NewTarget,FALSE) ? NO_ERROR : GetLastError();
            }
        } while((d==NO_ERROR) && FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    return(d);
}

VOID
Delnode(
    IN PCWSTR Directory
    )
{
    WCHAR Pattern[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // Delete each file in the given directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <currentdir>\*.
    //
    lstrcpyn(Pattern,Directory,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file or directory we just found.
            //
            lstrcpyn(Pattern,Directory,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            //
            // Remove read-only atttribute if it's there.
            //
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(Pattern,FILE_ATTRIBUTE_NORMAL);
            }

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                    Delnode(Pattern);
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                if(!DeleteFile(Pattern)) {
                }
            }
        } while(FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out. Ignore errors.
    //
    SetFileAttributes(Directory,FILE_ATTRIBUTE_NORMAL);
    RemoveDirectory(Directory);
}


BOOL
CallDuFunction (
    IN      PCTSTR SyssetupPath
    )
{
    BOOL b = FALSE;
    HMODULE hSyssetup;
    BOOL (*pfn) (
        VOID
        );

    hSyssetup = LoadLibrary (SyssetupPath);

    if (hSyssetup) {
        (FARPROC)pfn = GetProcAddress (hSyssetup, "DynamicUpdateInstallDuAsms");
        if (pfn) {
            b = pfn ();
        }

        FreeLibrary (hSyssetup);
    }

    return b;
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    LONG rc;

    if (argc < 2) {
        return -1;
    }

    if (!Init()) {

        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    CallDuFunction (argv[1]);

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\doswiz\doswiz.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwwiz.c

Abstract:

    Implements a upgwiz wizard for obtaining dos configuration information.

Author:

    Jim Schmidt (jimschm)  12-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"

DATATYPE g_DataTypes[] = {
    {UPGWIZ_VERSION,
        "DOS Device or TSR should be compatible",
        "You specify the DOS configuration line that was incorrectly marked as incompatible.",
        0,
        DTF_REQUIRE_TEXT|DTF_REQUIRE_DESCRIPTION|DTF_ONE_SELECTION,
        1024,
        "&Name of Device or TSR Program:"
    },

    {UPGWIZ_VERSION,
        "DOS Device or TSR should be incompatible",
        "You specify the DOS configuration lines that need to be reported as incompatible.",
        0,
        DTF_REQUIRE_TEXT|DTF_REQUIRE_DESCRIPTION|DTF_ONE_SELECTION,
        1024,
        "&Name of Device or TSR Program:",
        "&Describe the Problem:"
    }
};


GROWBUFFER g_DataObjects = GROWBUF_INIT;
POOLHANDLE g_DataObjectPool;
HINSTANCE g_OurInst;

BOOL
Init (
    VOID
    )
{
#ifndef UPGWIZ4FLOPPY
    return InitToolMode (g_OurInst);
#else
    return TRUE;
#endif
}

VOID
Terminate (
    VOID
    )
{
    //
    // Local cleanup
    //

    FreeGrowBuffer (&g_DataObjects);

    if (g_DataObjectPool) {
        PoolMemDestroyPool (g_DataObjectPool);
    }

#ifndef UPGWIZ4FLOPPY
    TerminateToolMode (g_OurInst);
#endif
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_DETACH) {
        MYASSERT (g_OurInst == hInstance);
        Terminate();
    }

    g_OurInst = hInstance;

    return TRUE;
}


UINT
GiveVersion (
    VOID
    )
{
    Init();

    return UPGWIZ_VERSION;
}


PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    )
{
    UINT u;

    *Count = sizeof (g_DataTypes) / sizeof (g_DataTypes[0]);

    for (u = 0 ; u < *Count ; u++) {
        g_DataTypes[u].DataTypeId = u;
    }

    return g_DataTypes;
}




PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    )
{
    PDATAOBJECT data;
    MEMDB_ENUM e;
    TCHAR line[MEMDB_MAX];
    TCHAR key[MEMDB_MAX];
    TCHAR file[MEMDB_MAX];
    DWORD offset;
    DWORD value;
    DWORD curOffset;
    PTSTR name;



    g_DataObjectPool = PoolMemInitNamedPool ("Data Objects");

    //
    // Parse the dos files.
    //
    ParseDosFiles ();


    curOffset = 0;
    //
    // Send the list back.
    //
    if (MemDbEnumItems (&e, MEMDB_CATEGORY_DM_LINES)) {

        do {

            //
            // Get the actual line contents.
            //
            if (MemDbGetEndpointValueEx (MEMDB_CATEGORY_DM_LINES, e.szName, NULL, line)) {

                //
                // Get the value and flags from this endpoint.
                //
                MemDbBuildKey (key, MEMDB_CATEGORY_DM_LINES, e.szName, NULL, line);
                MemDbGetValueAndFlags( key, &offset, &value);

                if (curOffset != offset) {
                    MemDbBuildKeyFromOffset (offset, file, 1, NULL);
                    curOffset = offset;
                    ReplaceWacks (file);
                }

                ReplaceWacks (line);

                name = JoinPaths(file,line);



                //
                // create dataobject with this data.
                //
                data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                data -> Version = UPGWIZ_VERSION;
                data -> NameOrPath = PoolMemDuplicateString (g_DataObjectPool, name);
                data -> Flags = DOF_NO_SORT;
                data -> DllParam = PoolMemDuplicateString (g_DataObjectPool, key);

                FreePathString (name);

            }

        } while (MemDbEnumNextValue (&e));
    }

    *Count = g_DataObjects.End / sizeof (DATAOBJECT);

    return (PDATAOBJECT) g_DataObjects.Buf;
}



BOOL
GenerateOutput (
    IN      POUTPUTARGS Args
    )
{
    BOOL rSuccess = FALSE;
    TCHAR path[MAX_TCHAR_PATH];
    HANDLE file;
    PDATAOBJECT data  = (PDATAOBJECT) g_DataObjects.Buf;
    UINT count = g_DataObjects.End / sizeof (DATAOBJECT);
    UINT i;
    LINESTRUCT ls;
    PTSTR p;

    //
    // Create path to outbond file
    //
    wsprintf (
        path,
        TEXT("%s\\%s"),
        Args -> OutboundDir,
        Args -> DataTypeId ? "incmpdos.txt" : "cmpdos.txt"
        );


    printf ("Saving data to %s\n\n", path);

    file = CreateFile (
                path,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        printf ("Can't open file for output.\n");
        return FALSE;
    }

    __try {

        SetFilePointer (file, 0, NULL, FILE_END);

        //
        // log user name and date/time
        //
        if (!WriteHeader (file)) {
            __leave;
        }

        //
        // write data.
        //
        rSuccess = TRUE;
        for (i = 0; i < count; i++) {

            if (data -> Flags & DOF_SELECTED) {

                //
                // Write the full line.
                //
                p = _mbschr (data -> NameOrPath, '\\');
                MYASSERT (p);

                *p = 0;
                RestoreWacks ((PTSTR) data -> NameOrPath);

                rSuccess &= WizardWriteString (file, "file: ");
                rSuccess &= WizardWriteString (file, data -> NameOrPath);
                rSuccess &= WizardWriteString (file, "\r\n");

                p = _mbsinc (p);
                RestoreWacks (p);

                rSuccess &= WizardWriteString (file, "line: ");
                rSuccess &= WizardWriteString (file, p);
                rSuccess &= WizardWriteString (file, "\r\n");

                StringCopy (path, p);

                do {

                    InitLineStruct (&ls, path);

                    if (DoesFileExist (ls.FullPath)) {
                        //
                        // Write File Attributes
                        //
                        rSuccess &= WriteFileAttributes (Args, NULL, file, ls.FullPath, NULL);
                    }

                    p = ls.Arguments;
                    if (*p == '=') {
                        p = _mbsinc (p);
                    }

                    p = (PTSTR) SkipSpace (p);
                    if (p) {

                        if (*p == '=') {
                            p = (PTSTR) SkipSpace(_mbsinc (p));
                        }

                        if (p) {
                            StringCopy (path, p);
                        }
                    }

                    if (!p) {
                        *path = 0;
                    }


                } while (*ls.Arguments && StringCompare (ls.FullLine,ls.Arguments));
            }

            data++;
        }

        //
        // write a final blank line.
        //
        WizardWriteRealString (file, "\r\n\r\n");
    }
    __finally {

        CloseHandle (file);
    }

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\exports\makefile.inc ===
obj\$(TARGET_DIRECTORY)\exports.res: exports.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\enumtree\enumtree.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enumtree.c

Abstract:

    Performs a test of the file enumeration code.

Author:

    Jim Schmidt (jimschm)   14-Jan-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "enumtree [-d|-f] [-i] [-p:pattern] [-s] [-x:ext] [-x:ext] [-x:...] <root>\n\n"
            "<root>   Specifies the root path to enumerate (required)\n"
            "-d       Specifies dirs should be recursed before files are listed\n"
            "-f       Specifies files should be listed before dirs are recursed\n"
            "-i       Specifies that the scan will be in depth first\n"
            "-p       Specifies a pattern of files to find\n"
            "-s       SLM mode (outputs files not read-only)\n"
            "-e       Specifies file to exclused from the -s option\n"
            "-x       Specifies extension to exclude from the -s option\n"
            );

    exit(0);
}


BOOL
pScanGrowListForStr (
    IN      PGROWLIST Exclusions,
    IN      PCTSTR SearchStr
    )
{
    UINT i;
    UINT Size;
    PCTSTR Str;

    Size = GrowListGetSize (Exclusions);
    for (i = 0 ; i < Size ; i++) {
        Str = GrowListGetString (Exclusions, i);
        if (StringIMatch (SearchStr, Str)) {
            return TRUE;
        }
    }

    return FALSE;
}

HANDLE g_hHeap;
HINSTANCE g_hInst;

INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    TREE_ENUM e;
    PCTSTR RootPath;
    PCTSTR FilePattern;
    INT i;
    UINT u;
    BOOL DirsFirst = TRUE;
    BOOL DepthFirst = FALSE;
    UINT Files, Dirs;
    BOOL SlmMode = FALSE;
    PCTSTR Ext = NULL;
    GROWLIST FileExclusions = GROWLIST_INIT;
    GROWLIST ExtExclusions = GROWLIST_INIT;

    RootPath = NULL;
    FilePattern = NULL;

    g_hHeap = GetProcessHeap();

    for (i = 1 ; i < argc ; i++) {

        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('/')) {
            switch (_totlower (argv[i][1])) {

            case TEXT('d'):
                DirsFirst = TRUE;
                break;

            case TEXT('f'):
                DirsFirst = FALSE;
                break;

            case TEXT('i'):
                DepthFirst = TRUE;
                break;

            case TEXT('p'):
                if (argv[i][2] == ':') {
                    FilePattern = &argv[i][3];
                } else if (i + 1 < argc) {
                    FilePattern = argv[i + 1];
                } else {
                    HelpAndExit();
                }

                break;

            case TEXT('x'):
                if (argv[i][2] == ':') {
                    Ext = &argv[i][3];
                } else if (i + 1 < argc) {
                    Ext = argv[i + 1];
                } else {
                    HelpAndExit();
                }

                GrowListAppendString (&ExtExclusions, Ext);
                break;

            case TEXT('e'):
                if (argv[i][2] == ':') {
                    Ext = &argv[i][3];
                } else if (i + 1 < argc) {
                    Ext = argv[i + 1];
                } else {
                    HelpAndExit();
                }

                GrowListAppendString (&FileExclusions, Ext);
                break;

            case TEXT('s'):
                SlmMode = TRUE;
                break;

            default:
                HelpAndExit();
            }
        }

        else if (RootPath) {
            HelpAndExit();
        }

        else {
            RootPath = argv[i];
        }
    }

    if (!RootPath) {
        HelpAndExit();
    }

    Files = 0;
    Dirs = 0;

    if (EnumFirstFileInTreeEx (&e, RootPath, FilePattern, DirsFirst, DepthFirst, FILE_ENUM_ALL_LEVELS)) {
        do {
            if (e.Directory) {
                Dirs++;
            } else {
                Files++;
            }

            if (!SlmMode) {
                for (u = 0 ; u < e.Level ; u++) {
                    _tprintf (TEXT(" "));
                }

                _tprintf (TEXT("%s\n"), e.Name);
            } else {
                if (!e.Directory && !(e.FindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)) {
                    Ext = GetFileExtensionFromPath (e.Name);
                    if (!Ext) {
                        Ext = S_EMPTY;
                    }

                    if (!pScanGrowListForStr (&ExtExclusions, Ext) &&
                        !pScanGrowListForStr (&FileExclusions, e.Name)
                        ) {
                        _tprintf (TEXT("%s\n"), e.SubPath);
                    }
                }
            }
        } while (EnumNextFileInTree (&e));
    }

    if (!SlmMode) {
        _tprintf (TEXT("\nFiles: %u\nDirs: %u\n"), Files, Dirs);
    }

    FreeGrowList (&ExtExclusions);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\extract\pch.h ===
#include "master.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\extract\extract.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    icontool.c

Abstract:

    Extracts icons in a variety of ways to test the icon extraction code.

Author:

    Jim Schmidt (jimschm)   22-Apr-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


INT g_ErrorLevel;

VOID
pLaunchCompareDlg (
    IN      PCTSTR FileName1,
    IN      PCTSTR FileName2
    );

UINT
pRemoveIcons (
    IN      PICON_EXTRACT_CONTEXT Context,
    IN      UINT Start,
    IN      UINT End
    );

UINT
pCopyIconRange (
    IN      PICON_EXTRACT_CONTEXT Context,
    IN      PCTSTR IconFile,
    IN      UINT Start,
    IN      UINT End
    );

//
// This routine is in migutil\icons.c
//

BOOL
pOpenIconImageA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileToOpen,
    OUT     PBOOL IsIco,                        OPTIONAL
    OUT     PBOOL Is16Bit                       OPTIONAL
    );

BOOL
pOpenIconImageW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileToOpen,
    OUT     PBOOL IsIco,                        OPTIONAL
    OUT     PBOOL Is16Bit                       OPTIONAL
    );

#ifdef UNICODE

#define pOpenIconImage pOpenIconImageW

#else

#define pOpenIconImage pOpenIconImageA

#endif

typedef enum {
    NONE,
    CREATE_ICO,
    EXTRACT,
    EXTRACT_ALL,
    IMPLANT,
    EXTRACT_ONE,
    LIST,
    COMPARE,
    MAKE_UNIQUE,
    KILL
} MODE;



VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "icontool -a [-r] <pe-file>\n"
            "icontool -c <pe-file-1> <pe-file-2>\n"
            "icontool -d [i:<index>] <in-file> <migicons.dat>\n"
            "icontool -e[:range] <in-file> <migicons.dat>\n"
            "icontool [-i:<index>] <in-file> <ico-file>\n"
            "icontool -k <pe-file> <index range>\n"
            "icontool -l[i] [-q] [-n] [-p:<path>] <in-file> [<in-file>] [...]\n"
            "icontool -u <pe-file>\n"
            "icontool -x <migicons.dat> <pe-file>\n"
            "\n"
            "<in-file>      Specifies the file to extract an icon from (.ICO, NE or PE)\n"
            "<ico-file>     Specifies the file to save the icon to (.ICO only)\n"
            "<pe-file>      Specifies the file to save the icon(s) to (PE only)\n"
            "<migicons.dat> Specifies the path to migicons.dat (note: same as what\n"
            "               is generated by WINNT32)\n"
            "-a             Scans all files for icons\n"
            "-c             Compare pe-file-1 to pe-file-2 visually\n"
            "-d             Extracts icon from a file into dat file\n"
            "-e             Extracts all icons from <in-file>, or a range of icons. The\n"
            "               range must be simple (as in these three examples: 152 or 1-4\n"
            "               or 10-)\n"
            "-i             Specifies the index or string ID of the icon to extract, default\n"
            "               is 0\n"
            "-k             Kill icon where <index range> is in the form of 1,4-5,10\n"
            "-l             Lists icon resource names\n"
            "-li            Produces output for [Compatible Icon Indexes]\n"
            "-n             No header (used with -li only)\n"
            "-p             Specifies a path to compare the same-named <in-file>, used to\n"
            "               produce [Compatible Icon Index] that have binaries with icons\n"
            "               in common.\n"
            "-q             Quiet (no error output)\n"
            "-r             Enables recursion\n"
            "-u             Makes all icons unique, removes duplicates\n"
            "-x             Extracts icons from a dat file into a pe file\n"
            );

    exit(0);
}

BOOL
pRemoveDuplicateIcons (
    IN      PCTSTR SourcePeFile,
    IN      PCTSTR DestPeFile
    );

BOOL
pGetMinAndMax (
    IN      PICON_EXTRACT_CONTEXT Context,
    OUT     PUINT Min,
    OUT     PUINT Max
    );

HANDLE g_hHeap;
HINSTANCE g_hInst;


BOOL
pIsErrorOk (
    DWORD Error
    )
{
    if (Error != ERROR_SUCCESS &&
        Error != ERROR_FILE_INVALID &&
        Error != ERROR_ACCESS_DENIED &&
        Error != ERROR_BAD_FORMAT &&
        Error != ERROR_RESOURCE_TYPE_NOT_FOUND &&
        Error != ERROR_SHARING_VIOLATION &&
        Error != ERROR_NO_MORE_FILES &&
        Error != ERROR_RESOURCE_DATA_NOT_FOUND &&
        Error != ERROR_NOACCESS &&
        Error != ERROR_INVALID_EXE_SIGNATURE &&
        Error != ERROR_CANT_ACCESS_FILE
        ) {
        return TRUE;
    }

    return FALSE;
}


BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    );

VOID
Init (
    VOID
    )
{
    MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL);
}

VOID
Terminate (
    VOID
    )
{
    MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);
}


INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    PCTSTR IconFile = NULL;
    PCTSTR DestFile = NULL;
    PCTSTR IconId = NULL;
    INT IconIndex = 0;
    INT i;
    GROWBUFFER Buf = GROWBUF_INIT;
    GROWBUFFER Buf2 = GROWBUF_INIT;
    MODE Mode = NONE;
    BOOL RecurseMode = FALSE;
    INT Id = 1;
    ICON_EXTRACT_CONTEXT Context;
    WORD Icon;
    DWORD Error;
    UINT Count;
    BOOL UseIconIndex = TRUE;
    TCHAR IconIndexStr[128];
    MULTISZ_ENUM MultiSz;
    PCTSTR IconList;
    PCTSTR IconList2;
    BOOL InfOutput = FALSE;
    INT ResourceId;
    UINT Column;
    UINT Indent;
    TCHAR Buffer[2048];
    MULTISZ_ENUM LookAhead;
    INT Range;
    PCTSTR LastValidString;
    BOOL NeedsHeader = TRUE;
    GROWBUFFER FileList = GROWBUF_INIT;
    MULTISZ_ENUM FileListEnum;
    FILE_ENUM FileEnum;
    UINT Files = 0;
    TCHAR RootPath[MAX_TCHAR_PATH];
    PCTSTR comparePath = NULL;
    PCTSTR FileName;
    PCTSTR RootPathPtr;
    BOOL Quiet = FALSE;
    PCTSTR NextNum;
    UINT Start = 0;
    UINT End = 0xFFFF;
    UINT Min;
    UINT Max;
    TCHAR workPath[MAX_TCHAR_PATH];
    PCTSTR fileSpec;
    MULTISZ_ENUM compareEnum;
    BOOL match;
    BOOL noHeader = FALSE;

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    Init();

    for (i = 1 ; i < argc ; i++) {

        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('/')) {
            switch (_totlower (argv[i][1])) {

            case TEXT('x'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                Mode = IMPLANT;
                break;

            case TEXT('d'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                Mode = EXTRACT_ONE;
                break;

            case TEXT('l'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                if (_totlower (argv[i][2]) == TEXT('i')) {
                    InfOutput = TRUE;
                } else if (argv[i][2]) {
                    HelpAndExit();
                }

                Mode = LIST;
                break;

            case TEXT('n'):
                if (noHeader) {
                    HelpAndExit();
                }

                noHeader = TRUE;
                break;

            case TEXT('c'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                Mode = COMPARE;
                break;

            case TEXT('u'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                Mode = MAKE_UNIQUE;
                break;

            case TEXT('p'):
                if (comparePath) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {
                    comparePath = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    comparePath = argv[i];
                } else {
                    HelpAndExit();
                }
                break;

            case TEXT('i'):
                if (argv[i][2] == ':') {
                    IconId = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    IconId= argv[i];
                } else {
                    HelpAndExit();
                }

                IconIndex = _ttoi (IconId);
                while (_istspace ((TCHAR)_tcsnextc (IconId))) {
                    IconId = _tcsinc (IconId);
                }

                if (*IconId) {
                    if (!IconIndex && iscsymf(_tcsnextc (IconId))) {
                        UseIconIndex = FALSE;
                    }
                }

                break;

            case TEXT('k'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                Mode = KILL;
                break;

            case TEXT('a'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                Mode = EXTRACT_ALL;
                break;

            case TEXT('q'):
                if (Quiet) {
                    HelpAndExit();
                }

                Quiet = TRUE;
                break;

            case TEXT('e'):
                if (Mode != NONE) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {
                    NextNum = &argv[i][3];

                    if (_tcsnextc (NextNum) != TEXT('-')) {
                        Start = _tcstoul (NextNum, (PTSTR *) (&NextNum), 10);
                    }

                    if (_tcsnextc (NextNum) == TEXT('-')) {
                        NextNum = _tcsinc (NextNum);

                        if (*NextNum) {
                            End = _tcstoul (NextNum, (PTSTR *) (&NextNum), 10);
                        }
                    } else {
                        End = Start;
                    }

                    if (*NextNum) {
                        HelpAndExit();
                    }
                }

                Mode = EXTRACT;
                break;

            case TEXT('r'):
                if (RecurseMode) {
                    HelpAndExit();
                }

                RecurseMode = TRUE;
                break;

            default:
                HelpAndExit();
            }
        }

        else {

            Files++;
            MultiSzAppend (&FileList, argv[i]);

            if (IconFile) {
                DestFile = argv[i];
            }

            else {
                IconFile = argv[i];
            }

        }
    }

    MultiSzAppend (&FileList, S_EMPTY);

    //
    // Enforce syntax
    //

    if (Quiet && Mode != LIST) {
        HelpAndExit();
    }

    if (Mode == EXTRACT_ALL && DestFile) {
        HelpAndExit();
    }

    if (Mode == EXTRACT_ALL || Mode == LIST) {
        DestFile = IconFile;
    }

    if (Mode == MAKE_UNIQUE) {
        if (!DestFile) {
            DestFile = IconFile;
        }
    }

    if (!DestFile) {
        HelpAndExit();
    }

    if (RecurseMode && Mode != EXTRACT_ALL) {
        HelpAndExit();
    }

    if (Files > 2 && Mode != LIST) {
        HelpAndExit();
    }

    if ((comparePath || noHeader) && Mode != LIST) {
        HelpAndExit();
    }

    if (UseIconIndex) {
        IconId = (PCTSTR) (WORD) IconIndex;
        wsprintf (IconIndexStr, TEXT("%i"), IconIndex);
    } else {
        StringCopy (IconIndexStr, IconId);
    }

    if (Mode == KILL) {

        fprintf (stderr, "Beginning icon processing\n");

        if (!BeginIconExtraction (&Context, IconFile)) {
            fprintf (stderr, "Can't begin icon extraction\n");
            return 0;
        }

        //
        // Get the min and max IDs
        //

        if (!pGetMinAndMax (&Context, &Min, &Max)) {
            fprintf (stderr, "Can't kill icons without min/max info\n");
            return 0;
        }

        //
        // Evaluate the range and remove the icons
        //

        NextNum = DestFile;
        Count = 0;

        fprintf (stderr, "Removing icons\n");

        for (;;) {
            NextNum = SkipSpace (NextNum);

            if (!(*NextNum)) {
                break;
            }

            if (_tcsnextc (NextNum) == TEXT('-')) {
                Start = Min;
            } else {
                Start = _tcstoul (NextNum, (PTSTR *) (&NextNum), 10);
                NextNum = SkipSpace (NextNum);
            }

            if (_tcsnextc (NextNum) == TEXT('-')) {
                NextNum = SkipSpace (_tcsinc (NextNum));

                if (_tcsnextc (NextNum) == TEXT(',') || !(*NextNum)) {
                    End = Max;
                } else {
                    End = _tcstoul (NextNum, (PTSTR *) (&NextNum), 10);
                    NextNum = SkipSpace (NextNum);
                }
            } else {
                End = Start;
            }

            Count += pRemoveIcons (&Context, Start, End);

            if (_tcsnextc (NextNum) == TEXT(',')) {
                NextNum = _tcsinc (NextNum);
            } else {
                break;
            }
        }

        fprintf (stderr, "Saving\n");

        if (EndIconExtraction (&Context)) {
            printf ("Icons removed: %u\n", Count);
        }

        return 0;
    }

    else if (Mode == IMPLANT) {
        //
        // Use IconFile as a source to generate a PE file of icons
        //

        if (!BeginIconExtraction (&Context, DestFile)) {
            fprintf (stderr, "Can't begin icon extraction\n");
            return 0;
        }

        if (!OpenIconImageFile (&Context, IconFile, FALSE)) {
            _ftprintf (stderr, TEXT("Can't open %s\n"), IconFile);
            EndIconExtraction (&Context);
            return 0;
        }

        Count = 0;
        while (CopyIcon (&Context, NULL, NULL, 0)) {
            Count++;
        }

        if (EndIconExtraction (&Context)) {
            printf ("Icons extracted: %u\n", Count);
        }
    }

    else if (Mode == EXTRACT || Mode == EXTRACT_ONE) {
        //
        // Use IconFile as a source to generate a PE file of icons
        //

        if (!BeginIconExtraction (&Context, NULL)) {
            fprintf (stderr, "Can't begin icon extraction\n");
            return 0;
        }

        if (!OpenIconImageFile (&Context, DestFile, TRUE)) {
            _ftprintf (stderr, TEXT("Can't create %s\n"), DestFile);
            EndIconExtraction (&Context);
            return 0;
        }

        if (Mode == EXTRACT) {

            //
            // If no range is specified, use the CopyAllIcons api
            //

            if (Start == 0 && End == 0xFFFF) {
                if (!CopyAllIcons (&Context, IconFile)) {
                    _ftprintf (stderr, TEXT("Can't copy all icons from %s, error %u\n"), IconFile, GetLastError());
                } else {
                    _tprintf (TEXT("Extracted all icons from %s\n"), IconFile);
                }
            }

            //
            // If a range is specified, get the names and copy them
            // if they are in the range.
            //

            else {
                Count = pCopyIconRange (&Context, IconFile, Start, End);
                _tprintf (TEXT("Icons extracted: %u\n"), Count);
            }


        } else {
            if (!CopyIcon (&Context, IconFile, NULL, IconIndex)) {
                _ftprintf (stderr, TEXT("Can't copy %s [%i], error %u\n"), IconFile, IconIndex, GetLastError());
            } else {
                _tprintf (TEXT("Extracted %s [%i]\n"), IconFile, IconIndex);
            }
        }

        EndIconExtraction (&Context);
    }

    else if (Mode == MAKE_UNIQUE) {

        pRemoveDuplicateIcons (IconFile, DestFile);

    }

    else if (Mode == LIST) {

        EnumFirstMultiSz (&FileListEnum, (PCTSTR) FileList.Buf);

        do {
            //
            // Separate the path and file pattern
            //

            FileName = GetFileNameFromPath (FileListEnum.CurrentString);

            if (FileName == FileListEnum.CurrentString) {
                RootPathPtr = TEXT(".");
            } else {
                _tcssafecpyab (
                    RootPath,
                    FileListEnum.CurrentString,
                    FileName,
                    sizeof (RootPath) / sizeof (RootPath[0])
                    );
                RootPathPtr = RootPath;

                if (CharCount (RootPath) > 3) {
                    RemoveWackAtEnd (RootPath);
                }
            }

            //
            // Process all files specified
            //

            if (EnumFirstFile (&FileEnum, RootPathPtr, FileName)) {
                do {

                    if (FileEnum.Directory) {
                        continue;
                    }

                    //
                    // Process IconFile
                    //

                    IconFile = FileEnum.FullPath;
                    IconList = ExtractIconNamesFromFile (IconFile, &Buf);

                    Count = 0;

                    if (comparePath) {
                        //
                        // Prepare a list of resources in a binary located
                        // in an alternate path
                        //

                        fileSpec = GetFileNameFromPath (IconFile);
                        StringCopy (workPath, comparePath);
                        StringCopy (AppendWack (workPath), fileSpec);

                        IconList2 = ExtractIconNamesFromFile (workPath, &Buf2);
                    } else {
                        IconList2 = IconList;
                    }

                    if (IconList && IconList2) {

                        if (!InfOutput) {

                            //
                            // Simple output
                            //

                            if (EnumFirstMultiSz (&MultiSz, IconList)) {

                                do {
                                    if (IconList != IconList2) {
                                        match = FALSE;
                                        if (EnumFirstMultiSz (&compareEnum, IconList2)) {
                                            do {

                                                if (StringMatch (MultiSz.CurrentString, compareEnum.CurrentString)) {
                                                    match = TRUE;
                                                    break;
                                                }

                                            } while (EnumNextMultiSz (&compareEnum));
                                        }

                                        if (!match) {
                                            continue;
                                        }
                                    }

                                    if (!Count) {
                                        if (IconList != IconList2) {
                                            _tprintf (TEXT("Icon resources in both %s and %s:\n\n"), IconFile, workPath);
                                        } else {
                                            _tprintf (TEXT("Icon resources in %s:\n\n"), IconFile);
                                        }
                                    }

                                    _tprintf (TEXT("  %s\n"), MultiSz.CurrentString);
                                    Count++;
                                } while (EnumNextMultiSz (&MultiSz));

                                if (Count) {
                                    _tprintf (TEXT("\n"));
                                }
                            }

                            if (IconList != IconList2) {
                                if (EnumFirstMultiSz (&MultiSz, IconList)) {

                                    Count = 0;

                                    do {
                                        match = FALSE;
                                        if (EnumFirstMultiSz (&compareEnum, IconList2)) {
                                            do {

                                                if (StringMatch (MultiSz.CurrentString, compareEnum.CurrentString)) {
                                                    match = TRUE;
                                                    break;
                                                }

                                            } while (EnumNextMultiSz (&compareEnum));
                                        }

                                        if (match) {
                                            continue;
                                        }

                                        if (!Count) {
                                            _tprintf (TEXT("Icon resources in only in %s:\n\n"), IconFile);
                                        }

                                        _tprintf (TEXT("  %s\n"), MultiSz.CurrentString);
                                        Count++;
                                    } while (EnumNextMultiSz (&MultiSz));

                                    if (Count) {
                                        _tprintf (TEXT("\n"));
                                    }
                                }

                                if (EnumFirstMultiSz (&MultiSz, IconList2)) {

                                    Count = 0;

                                    do {
                                        match = FALSE;
                                        if (EnumFirstMultiSz (&compareEnum, IconList)) {
                                            do {

                                                if (StringMatch (MultiSz.CurrentString, compareEnum.CurrentString)) {
                                                    match = TRUE;
                                                    break;
                                                }

                                            } while (EnumNextMultiSz (&compareEnum));
                                        }

                                        if (match) {
                                            continue;
                                        }

                                        if (!Count) {
                                            _tprintf (TEXT("Icon resources in only in %s:\n\n"), workPath);
                                        }

                                        _tprintf (TEXT("  %s\n"), MultiSz.CurrentString);
                                        Count++;
                                    } while (EnumNextMultiSz (&MultiSz));

                                    if (Count) {
                                        _tprintf (TEXT("\n"));
                                    }
                                }

                                Count = 1;
                            }

                        } else {

                            //
                            // INF output
                            //

                            //
                            // Count the numeric resources
                            //

                            if (EnumFirstMultiSz (&MultiSz, IconList)) {
                                do {
                                    if (IconList != IconList2) {
                                        match = FALSE;
                                        if (EnumFirstMultiSz (&compareEnum, IconList2)) {
                                            do {

                                                if (StringMatch (MultiSz.CurrentString, compareEnum.CurrentString)) {
                                                    match = TRUE;
                                                    break;
                                                }

                                            } while (EnumNextMultiSz (&compareEnum));
                                        }

                                        if (!match) {
                                            continue;
                                        }
                                    }

                                    if (_tcsnextc (MultiSz.CurrentString) == TEXT('#')) {
                                        Count++;
                                    }
                                } while (EnumNextMultiSz (&MultiSz));
                            }

                            //
                            // If at least one numeric resource, print it
                            //

                            if (Count) {

                                if (NeedsHeader) {
                                    if (!noHeader) {
                                        _tprintf (TEXT("[%s]\n"), S_KNOWN_GOOD_ICON_MODULES);
                                    }

                                    NeedsHeader = FALSE;
                                }

                                wsprintf (Buffer, TEXT("%s="), GetFileNameFromPath (IconFile));
                                Indent = TcharCount (Buffer);

                                wsprintf (GetEndOfString (Buffer), TEXT("%u"), Count);
                                Column = TcharCount (Buffer);

                                _tprintf (TEXT("%s"), Buffer);

                                if (EnumFirstMultiSz (&MultiSz, IconList)) {
                                    do {
                                        if (IconList != IconList2) {
                                            match = FALSE;
                                            if (EnumFirstMultiSz (&compareEnum, IconList2)) {
                                                do {

                                                    if (StringMatch (MultiSz.CurrentString, compareEnum.CurrentString)) {
                                                        match = TRUE;
                                                        break;
                                                    }

                                                } while (EnumNextMultiSz (&compareEnum));
                                            }

                                            if (!match) {
                                                continue;
                                            }
                                        }

                                        if (_tcsnextc (MultiSz.CurrentString) == TEXT('#')) {

                                            ResourceId = _ttoi (_tcsinc (MultiSz.CurrentString));

                                            //
                                            // Determine if this is a range
                                            //

                                            Range = ResourceId;

                                            EnumFirstMultiSz (&LookAhead, MultiSz.CurrentString);
                                            LastValidString = MultiSz.CurrentString;

                                            while (EnumNextMultiSz (&LookAhead)) {

                                                if (_tcsnextc (LookAhead.CurrentString) != TEXT('#')) {
                                                    continue;
                                                }

                                                i = _ttoi (_tcsinc (LookAhead.CurrentString));
                                                if (Range + 1 == i) {
                                                    Range = i;
                                                    LastValidString = LookAhead.CurrentString;
                                                } else {
                                                    break;
                                                }
                                            }

                                            //
                                            // Add separator
                                            //

                                            _tprintf (TEXT(","));
                                            Column++;

                                            if (Range > ResourceId + 1) {
                                                wsprintf (Buffer, TEXT("%u-%u"), ResourceId, Range);
                                                MultiSz.CurrentString = LastValidString;
                                            } else {
                                                wsprintf (Buffer, TEXT("%u"), ResourceId);
                                            }

                                            if (TcharCount (Buffer) + Column > 78) {
                                                _tprintf (TEXT("\\\n"));

                                                for (Column = 0 ; Column < Indent ; Column++) {
                                                    _tprintf (TEXT(" "));
                                                }
                                            }

                                            Column += TcharCount (Buffer);
                                            _tprintf (TEXT("%s"), Buffer);
                                        }

                                    } while (EnumNextMultiSz (&MultiSz));
                                }

                                _tprintf (TEXT("\n"));
                            }
                        }
                    }

                    if (!Count && !Quiet) {
                        _ftprintf (stderr, TEXT("No icons in %s\n"), IconFile);
                    }

                    if (Count) {
                        g_ErrorLevel = 1;
                    }

                } while (EnumNextFile (&FileEnum));
            }

        } while (EnumNextMultiSz (&FileListEnum));
    }

    else if (Mode == EXTRACT_ONE) {
        //
        // Extract one icon
        //

        if (ExtractIconImageFromFile (IconFile, IconId, &Buf)) {
            if (WriteIconImageArrayToIcoFile (DestFile, &Buf)) {
                _ftprintf (stderr, TEXT("Icon %s from %s written successfully to %s.\n"), IconIndexStr, IconFile, DestFile);
            } else {
                _ftprintf (stderr, TEXT("Can't write icon to %s (error %u)\n"), DestFile, GetLastError());
            }
        } else {
            _ftprintf (stderr, TEXT("Can't extract icon %s from %s (error %u)\n"), IconIndexStr, IconFile, GetLastError());
        }
    }

    else if (Mode == EXTRACT_ALL) {
        //
        // Extract default icon of every file
        //

        if (!BeginIconExtraction (&Context, DestFile)) {
            fprintf (stderr, "Can't begin icon extraction\n");
            return 0;
        }

        if (RecurseMode) {
            TREE_ENUM e;

            if (EnumFirstFileInTree (&e, TEXT("."), NULL, FALSE)) {
                do {
                    if (StringIMatch (e.FullPath, DestFile)) {
                        continue;
                    }

                    Icon = Context.IconId;

                    if (!CopyAllIcons (&Context, e.FullPath)) {
                        Error = GetLastError();

                        if (pIsErrorOk (Error)) {
                            _ftprintf (stderr, TEXT("Can't copy icons from %s, error %u\n"), e.FullPath, Error);
                            break;
                        }
                    } else {
                        _tprintf (TEXT("%u: %s\n"), Icon, e.FullPath);
                    }
                } while (EnumNextFileInTree (&e));
            }

        } else {
            WIN32_FIND_DATA fd;
            HANDLE FindHandle;
            TCHAR FullPath[MAX_TCHAR_PATH];
            PTSTR p;

            GetCurrentDirectory (MAX_TCHAR_PATH, FullPath);
            p = AppendWack (FullPath);
            StringCopy (p, TEXT("*.*"));

            FindHandle = FindFirstFile (FullPath, &fd);
            if (FindHandle != INVALID_HANDLE_VALUE) {
                do {
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        continue;
                    }

                    StringCopy (p, fd.cFileName);
                    if (StringIMatch (FullPath, DestFile)) {
                        continue;
                    }

                    Icon = Context.IconId;

                    if (!CopyAllIcons (&Context, fd.cFileName)) {
                        Error = GetLastError();

                        if (pIsErrorOk (Error)) {
                            _ftprintf (stderr, TEXT("Can't copy icons from %s, error %u\n"), fd.cFileName, Error);
                            break;
                        }
                    } else {
                        _tprintf (TEXT("%u: %s\n"), Icon, fd.cFileName);
                    }

                } while (FindNextFile (FindHandle, &fd));

                FindClose (FindHandle);
            }
        }

        if (EndIconExtraction (&Context)) {
            printf ("Icons extracted.\n");
        }
    }

    else if (Mode == COMPARE) {
        pLaunchCompareDlg (IconFile, DestFile);
    }

    FreeGrowBuffer (&Buf);
    FreeGrowBuffer (&Buf2);
    FreeGrowBuffer (&FileList);

    Terminate();

    return g_ErrorLevel;
}


BOOL
pSetIconInWindow (
    IN      HWND IconWnd1,
    IN      HWND IconWnd2,
    IN      PCTSTR FileName1,
    IN      PCTSTR FileName2,
    IN      INT ResourceId
    )
{
    HANDLE Instance1;
    HANDLE Instance2;
    BOOL b = FALSE;
    HICON Icon1 = NULL;
    HICON Icon2 = NULL;

    Instance1 = LoadLibraryEx (FileName1, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (Instance1) {
        //
        // Get the icon
        //

        Icon1 = LoadIcon (Instance1, MAKEINTRESOURCE (ResourceId));
    }

    Instance2 = LoadLibraryEx (FileName2, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (Instance2) {
        //
        // Get the icon
        //

        Icon2 = LoadIcon (Instance2, MAKEINTRESOURCE (ResourceId));
    }

    if (Icon1 && Icon2) {
        SendMessage (IconWnd1, STM_SETICON, (WPARAM) Icon1, 0);
        SendMessage (IconWnd2, STM_SETICON, (WPARAM) Icon2, 0);

        b = TRUE;
    }

    if (Instance1) {
        FreeLibrary (Instance1);
    }

    if (Instance2) {
        FreeLibrary (Instance2);
    }

    return b;
}


typedef struct {
    GROWBUFFER IdArray;
    UINT CurrentId;
    UINT IdCount;
    PCTSTR FileName1;
    PCTSTR FileName2;
} DLGARGS, *PDLGARGS;


#define WMX_UPDATE_ICONS        (WM_APP+1)

BOOL
CALLBACK
IconCompareDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PDLGARGS Args;
    TCHAR Number[32];
    INT ResourceId;

    switch (uMsg) {

    case WM_INITDIALOG:
        Args = (PDLGARGS) lParam;

        SetDlgItemText (hdlg, IDC_FILE_NAME1, Args->FileName1);
        SetDlgItemText (hdlg, IDC_FILE_NAME2, Args->FileName2);
        SendMessage (hdlg, WMX_UPDATE_ICONS, 0, 0);

        switch (g_ErrorLevel) {

        case 0:
            ResourceId = IDC_NO_MATCH;
            break;

        case 1:
            ResourceId = IDC_PARTIAL;
            break;

        case 2:
            ResourceId = IDC_MATCH;
            break;
        }

        CheckDlgButton (hdlg, ResourceId, BST_CHECKED);

        break;

    case WMX_UPDATE_ICONS:

        ResourceId = (INT) (*((PDWORD) Args->IdArray.Buf + Args->CurrentId));

        pSetIconInWindow (
            GetDlgItem (hdlg, IDC_ICON1),
            GetDlgItem (hdlg, IDC_ICON2),
            Args->FileName1,
            Args->FileName2,
            ResourceId
            );

        wsprintf (Number, TEXT("%i"), ResourceId);
        SetDlgItemText (hdlg, IDC_RESOURCE_ID, Number);

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            if (IsDlgButtonChecked (hdlg, IDC_NO_MATCH) == BST_CHECKED) {
                g_ErrorLevel = 0;
            } else if (IsDlgButtonChecked (hdlg, IDC_PARTIAL) == BST_CHECKED) {
                g_ErrorLevel = 1;
            } else if (IsDlgButtonChecked (hdlg, IDC_MATCH) == BST_CHECKED) {
                g_ErrorLevel = 2;
            }

            EndDialog (hdlg, 0);
            break;

        case IDC_NEXT:
            if (Args->CurrentId < (Args->IdCount - 1)) {
                Args->CurrentId++;
                SendMessage (hdlg, WMX_UPDATE_ICONS, 0, 0);
            }
            break;

        case IDC_PREV:
            if (Args->CurrentId > 0) {
                Args->CurrentId--;
                SendMessage (hdlg, WMX_UPDATE_ICONS, 0, 0);
            }
            break;
        }
        break;
    }

    return FALSE;
}


VOID
pLaunchCompareDlg (
    IN      PCTSTR FileName1,
    IN      PCTSTR FileName2
    )
{
    DLGARGS Args;
    PCTSTR IconList1;
    PCTSTR IconList2;
    GROWBUFFER Buf1 = GROWBUF_INIT;
    GROWBUFFER Buf2 = GROWBUF_INIT;
    MULTISZ_ENUM Enum1, Enum2;
    BOOL Match;

    //
    // Obtain the resource ID list from both FileName1 and FileName2.
    // Put the union in a grow buffer.
    //

    ZeroMemory (&Args, sizeof (Args));
    Args.FileName1 = FileName1;
    Args.FileName2 = FileName2;

    IconList1 = ExtractIconNamesFromFile (FileName1, &Buf1);
    IconList2 = ExtractIconNamesFromFile (FileName2, &Buf2);

    if (IconList1 && IconList2) {
        //
        // Enumerate list one, then scan list two for a match
        //

        if (EnumFirstMultiSz (&Enum1, IconList1)) {
            do {
                if (_tcsnextc (Enum1.CurrentString) != TEXT('#')) {
                    continue;
                }

                Match = FALSE;

                if (EnumFirstMultiSz (&Enum2, IconList2)) {
                    do {

                        if (StringMatch (Enum1.CurrentString, Enum2.CurrentString)) {
                            Match = TRUE;
                            break;
                        }

                    } while (EnumNextMultiSz (&Enum2));
                }

                if (Match) {
                    GrowBufAppendDword (
                        &Args.IdArray,
                        (DWORD) _ttoi (_tcsinc (Enum1.CurrentString))
                        );

                    Args.IdCount++;
                } else {
                    _ftprintf (
                        stderr,
                        TEXT("Resource ID %s is not in %s\n"),
                        Enum1.CurrentString,
                        FileName2
                        );
                }

            } while (EnumNextMultiSz (&Enum1));
        }

        //
        // Enumerate list two, then scan list one for a match
        //

        if (EnumFirstMultiSz (&Enum2, IconList2)) {
            do {
                if (_tcsnextc (Enum2.CurrentString) != TEXT('#')) {
                    continue;
                }

                Match = FALSE;

                if (EnumFirstMultiSz (&Enum1, IconList1)) {
                    do {

                        if (StringMatch (Enum1.CurrentString, Enum2.CurrentString)) {
                            Match = TRUE;
                            break;
                        }

                    } while (EnumNextMultiSz (&Enum1));
                }

                if (!Match) {
                    _ftprintf (
                        stderr,
                        TEXT("Resource ID %s is not in %s\n"),
                        Enum2.CurrentString,
                        FileName1
                        );
                }
            } while (EnumNextMultiSz (&Enum2));
        }

        //
        // Now present the dialog
        //

        if (Args.IdCount) {

            DialogBoxParam (
                g_hInst,
                MAKEINTRESOURCE(IDD_COMPARE),
                NULL,
                IconCompareDlgProc,
                (LPARAM) &Args
                );

        } else {
            _ftprintf (stderr, TEXT("No common icon resources found.\n"));
        }

    } else {
        if (!IconList1) {
            _ftprintf (stderr, TEXT("Can't get icon list from %s\n"), FileName1);
        }

        if (!IconList2) {
            _ftprintf (stderr, TEXT("Can't get icon list from %s\n"), FileName2);
        }
    }

    FreeGrowBuffer (&Buf1);
    FreeGrowBuffer (&Buf2);

}



BOOL
pCompareIconImages (
    IN      PCTSTR SourceFile,
    IN      PCTSTR Name1,
    IN      PCTSTR Name2
    )
{
    GROWBUFFER SrcBuf = GROWBUF_INIT;
    GROWBUFFER DestBuf = GROWBUF_INIT;
    BOOL b;

    b = ExtractIconImageFromFile (SourceFile, Name1, &SrcBuf);

    if (b) {
        b = ExtractIconImageFromFile (SourceFile, Name2, &DestBuf);
    }

    if (b) {
        if (SrcBuf.End != DestBuf.End) {
            b = FALSE;
        } else {
            b = (memcmp (SrcBuf.Buf, DestBuf.Buf, SrcBuf.End) == 0);
        }
    }

    FreeGrowBuffer (&SrcBuf);
    FreeGrowBuffer (&DestBuf);

    return b;
}


BOOL
pMakeNameIndex (
    IN      PCTSTR SourceFile,
    OUT     PGROWBUFFER IndexBuf,
    OUT     PGROWBUFFER IndexArray
    )
{
    PCTSTR IconList;
    MULTISZ_ENUM e;

    IndexBuf->End = 0;
    IndexArray->End = 0;

    IconList = ExtractIconNamesFromFile (SourceFile, IndexBuf);

    if (IconList) {
        //
        // Build an index array
        //

        if (EnumFirstMultiSz (&e, IconList)) {
            do {
                if (_tcsnextc (e.CurrentString) != TEXT('#')) {
                    //
                    // This is a named string
                    //

                    GrowBufAppendDword (IndexArray, (DWORD) e.CurrentString);

                } else {

                    //
                    // This is a 16-bit ID
                    //

                    GrowBufAppendDword (IndexArray, (DWORD) _ttoi (_tcsinc (e.CurrentString)));
                }
            } while (EnumNextMultiSz (&e));
        }

    } else {
        _ftprintf (stderr, TEXT("No icons found in %s\n"), SourceFile);
    }


    return IndexArray->End != 0;
}

#define BLANK_ID        0xFFFFFFFF

BOOL
pFindUniqueIcons (
    IN      PCTSTR SourceFile,
    OUT     PGROWBUFFER WorkBuffer,
    OUT     PGROWBUFFER UniqueIndexArray,
    OUT     PUINT OriginalMax
    )
{
    GROWBUFFER IndexArray = GROWBUF_INIT;
    BOOL b;
    UINT i, j;
    UINT Count;
    PDWORD IdPtr;

    UniqueIndexArray->End = 0;

    b = pMakeNameIndex (SourceFile, WorkBuffer, &IndexArray);

    if (b) {

        *OriginalMax = 0;

        Count = IndexArray.End / sizeof (DWORD);
        IdPtr = (PDWORD) IndexArray.Buf;

        for (i = 0 ; i < Count ; i++) {

            if (IdPtr[i] == BLANK_ID) {
                continue;
            }

            if (IdPtr[i] < 0x10000) {
                _ftprintf (stderr, TEXT("Processing ID %u\n"), IdPtr[i]);

                if (IdPtr[i] > *OriginalMax) {
                    *OriginalMax = IdPtr[i];
                }
            } else {
                _ftprintf (stderr, TEXT("Processing ID %s\n"), IdPtr[i]);
            }

            for (j = i + 1 ; j < Count ; j++) {

                if (IdPtr[j] == BLANK_ID) {
                    continue;
                }

                if (pCompareIconImages (SourceFile, (PCTSTR) (IdPtr[i]), (PCTSTR) (IdPtr[j]))) {
                    IdPtr[j] = BLANK_ID;
                }
            }
        }

        for (i = 0 ; i < Count ; i++) {
            if (IdPtr[i] != BLANK_ID) {
                GrowBufAppendDword (UniqueIndexArray, IdPtr[i]);
            }
        }
    }

    FreeGrowBuffer (&IndexArray);
    return b;
}


UINT
pRemoveIcons (
    IN      PICON_EXTRACT_CONTEXT Context,
    IN      UINT Start,
    IN      UINT End
    )
{
    UINT Count = 0;
    GROWBUFFER Names = GROWBUF_INIT;
    PCTSTR IconList;
    MULTISZ_ENUM e;
    UINT id;

    if (Start > End) {
        return 0;
    }

    if (Start == End) {
        _ftprintf (stderr, TEXT("Removing icon %u\n"), Start);
    } else {
        _ftprintf (stderr, TEXT("Removing icon range %u through %u\n"), Start, End);
    }

    pOpenIconImage (Context, Context->DestFile, NULL, NULL);

    IconList = ExtractIconNamesFromFileEx (
                    Context->ModuleName,
                    &Names,
                    Context->Module,
                    Context->Module16
                    );

    if (IconList) {
        if (EnumFirstMultiSz (&e, IconList)) {
            do {
                if (_tcsnextc (e.CurrentString) == TEXT('#')) {

                    id = (DWORD) _ttoi (_tcsinc (e.CurrentString));

                    if (id >= Start && id <= End) {
                        if (UpdateResource (
                                Context->Update,
                                RT_ICON,
                                MAKEINTRESOURCE(id),
                                MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                                NULL,
                                0
                                )) {
                            Count++;
                        } else {
                            _ftprintf (stderr, TEXT("Can't remove icon ID %u; rc=%u\n"), id, GetLastError());
                        }
                    }
                }
            } while (EnumNextMultiSz (&e));
        }
    } else {
        _ftprintf (stderr, TEXT("Can't get icon names; rc=%u\n"), GetLastError());
    }

    FreeGrowBuffer (&Names);

    return Count;
}


BOOL
pRemoveDuplicateIcons (
    IN      PCTSTR SourcePeFile,
    IN      PCTSTR DestPeFile
    )
{
    GROWBUFFER WorkBuffer = GROWBUF_INIT;
    GROWBUFFER UniqueIndexArray = GROWBUF_INIT;
    ICON_EXTRACT_CONTEXT Context;
    UINT Count = 0;
    UINT u;
    PDWORD IconId;
    BOOL b;
    UINT OriginalMax;

    _ftprintf (stderr, TEXT("Finding unique icons\n"));
    b = pFindUniqueIcons (SourcePeFile, &WorkBuffer, &UniqueIndexArray, &OriginalMax);

    if (b) {
        b = BeginIconExtraction (&Context, DestPeFile);

        if (!b) {
            _ftprintf (stderr, TEXT("Can't save icons to %s\n"), DestPeFile);
        }
    }

    if (b) {

        _ftprintf (stderr, TEXT("Updating icon resources\n"));

        Count = UniqueIndexArray.End / sizeof (DWORD);
        IconId = (PDWORD) UniqueIndexArray.Buf;

        for (u = 0 ; u < Count ; u++) {
            b = CopyIcon (&Context, SourcePeFile, (PCTSTR) (IconId[u]), 0);
            if (!b) {
                if (IconId[u] < 0x10000) {
                    _ftprintf (stderr, TEXT("Can't copy icon %u\n"), IconId[u]);
                } else {
                    _ftprintf (stderr, TEXT("Can't copy icon %s\n"), IconId[u]);
                }

                break;
            }
        }
    }

    if (b) {

        pRemoveIcons (&Context, Count + 1, OriginalMax);

        b = EndIconExtraction (&Context);

        if (!b) {
            _ftprintf (stderr, TEXT("Can't safe icons\n"));
        }
    }

    if (b) {
        _ftprintf (stderr, TEXT("Final icon count: %u\n"), Count);
    }

    FreeGrowBuffer (&WorkBuffer);
    FreeGrowBuffer (&UniqueIndexArray);

    return b;
}


BOOL
pGetMinAndMax (
    IN      PICON_EXTRACT_CONTEXT Context,
    OUT     PUINT Min,
    OUT     PUINT Max
    )
{
    BOOL b = FALSE;
    GROWBUFFER Names = GROWBUF_INIT;
    PCTSTR IconList;
    UINT id;
    MULTISZ_ENUM e;

    *Min = (UINT) -1;
    *Max = 0;

    pOpenIconImage (Context, Context->DestFile, NULL, NULL);

    _ftprintf (stderr, TEXT("Getting min/max icon indexes from %s\n"), Context->ModuleName);

    IconList = ExtractIconNamesFromFileEx (
                    Context->ModuleName,
                    &Names,
                    Context->Module,
                    Context->Module16
                    );

    if (IconList) {
        if (EnumFirstMultiSz (&e, IconList)) {
            do {
                if (_tcsnextc (e.CurrentString) == TEXT('#')) {

                    id = (DWORD) _ttoi (_tcsinc (e.CurrentString));

                    if (id < *Min) {
                        *Min = id;
                    }

                    if (id > *Max) {
                        *Max = id;
                    }
                }
            } while (EnumNextMultiSz (&e));
        }

        b = TRUE;
    }

    FreeGrowBuffer (&Names);

    if (b) {
        _ftprintf (stderr, TEXT("Min: %u  Max: %u\n"), *Min, *Max);
    } else {
        _ftprintf (stderr, TEXT("Can't get min/max info, rc=%u\n"), GetLastError());
    }


    return b;
}


UINT
pCopyIconRange (
    IN      PICON_EXTRACT_CONTEXT Context,
    IN      PCTSTR IconFile,
    IN      UINT Start,
    IN      UINT End
    )
{
    UINT Count = 0;
    GROWBUFFER Names = GROWBUF_INIT;
    PCTSTR IconList;
    UINT id;
    MULTISZ_ENUM e;

    pOpenIconImage (Context, IconFile, NULL, NULL);

    if (Start == End) {
        _ftprintf (
            stderr,
            TEXT("Copying icon %u from %s to %s\n"),
            Start,
            Context->ModuleName,
            Context->IconImageFileName
            );
    } else {
        _ftprintf (
            stderr,
            TEXT("Copying icon range %u to %u from %s to %s\n"),
            Start,
            End,
            Context->ModuleName,
            Context->IconImageFileName
            );
    }

    IconList = ExtractIconNamesFromFileEx (
                    Context->ModuleName,
                    &Names,
                    Context->Module,
                    Context->Module16
                    );

    if (IconList) {
        if (EnumFirstMultiSz (&e, IconList)) {
            do {
                if (_tcsnextc (e.CurrentString) == TEXT('#')) {

                    id = (DWORD) _ttoi (_tcsinc (e.CurrentString));

                    if (id >= Start && id <= End) {
                        if (!CopyIcon (Context, IconFile, e.CurrentString, 0)) {
                            _ftprintf (stderr, TEXT("Can't copy %s [%i], error %u\n"), IconFile, id, GetLastError());
                        } else {
                            Count++;
                        }
                    }
                }
            } while (EnumNextMultiSz (&e));
        }
    } else {
        _ftprintf (stderr, TEXT("Can't get icon names from %s\n"), Context->ModuleName);
    }

    FreeGrowBuffer (&Names);

    return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\filegen\makefile.inc ===
obj\$(TARGET_DIRECTORY)\filegen.res: filegen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\exports\exports.c ===
#include "pch.h"


typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
INITROUTINE_PROTOTYPE MemDb_Entry;
INITROUTINE_PROTOTYPE FileEnum_Entry;

#define DBG_MODULES   "MODULES"
#define FLAG_BAD_FUNCTION 1
#define FLAG_BAD_INDEX    2


HINSTANCE g_hInst;
HANDLE g_hHeap;

BOOL g_CancelFlag = FALSE;

DWORD g_DirSequencer = 0;
DWORD g_FileSequencer = 0;

#ifdef DEBUG
extern BOOL            g_DoLog;
#endif
extern BOOL           *g_CancelFlagPtr = &g_CancelFlag;
extern POOLHANDLE      g_PathsPool;

BOOL
WriteE95Only (
    VOID
    );

BOOL
pHandleFile (
    IN      PCTSTR FileName,
    IN      BOOL Win95Side
    );

BOOL
pHandleAllFiles (
    IN      PCTSTR SrcPath,
    IN      BOOL Win95Side
    );

BOOL
pDeleteAllFiles (
    IN      PCTSTR DirPath
    );

BOOL
pProcessExportModule (
    IN      PCTSTR ModuleName,
    IN      BOOL Win95Side
    );

BOOL
pLoadKnownGoodExports (
    IN      HINF ConfigHandle
    );

BOOL
pLoadIgnoredFiles (
    IN      HINF ConfigHandle
    );

BOOL
pLocalLoadNTFilesData (
    IN      PCTSTR FilePath,
    IN      HINF ConfigHandle
    );

BOOL
pCompressedFile (
    IN      PTREE_ENUM e
    );

BOOL
pWorkerFn (
    IN      HINF ConfigHandle
    );

BOOL
pHandleSection (
    IN      PCTSTR SectionName,
    IN      HINF ConfigHandle
    );

VOID
pInitProgBarVars (
    VOID
    );

VOID
pUsage (
    VOID
    )
{
    _tprintf (TEXT ("\nCommand line syntax:\n\n"
                    "exports [/B:BaseDir] [/T:TempDir] [/F[:SectionName]]\n\n"
                    "/B    Specifies the base directory where all exports files are\n"
                    "      located. (e95only.dat, exports.cfg)\n"
                    "/T    Specifies the temporary directory used for unpacking\n"
                    "      cabinet files\n"
                    "/F    Forces rescanning a particular section or all sections\n"
                    "/I    Specifies path to NTFILES (default %NTTREE%)\n"));
}

PTSTR g_ConfigFile = NULL;
PTSTR g_TempDir    = NULL;
PTSTR g_BaseDir    = NULL;
PTSTR g_ExportDest = NULL;
PTSTR g_TxtSetupPath = NULL;
PTSTR g_RescanSect = NULL;
BOOL  g_RescanFlag = FALSE;

extern HINF  g_MigDbInf;
GROWBUFFER g_SectFiles = GROWBUF_INIT;

#define MEMDB_CATEGORY_WNT_EXPORTS     TEXT("WNtExports")
#define MEMDB_CATEGORY_W95_SECTIONS    TEXT("W95Sections")

void
__cdecl
main (
    int argc,
    CHAR *argv[]
    )
{

    INT argidx, index;
    INT nextArg = 0;
    HINF configHandle = INVALID_HANDLE_VALUE;
    TCHAR fileName [MAX_TCHAR_PATH] = "";
    PTSTR dontCare;

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    g_hInst = GetModuleHandle (NULL);
    g_hHeap = GetProcessHeap();

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MigUtil failed initializing\n"));
        exit (1);
    }

    if (!MemDb_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MemDb failed initializing\n"));
        exit(1);
    }

    for (argidx = 1; argidx < argc; argidx++) {
        if ((argv[argidx][0] != '-') &&
            (argv[argidx][0] != '/')
            ) {
            if (nextArg == 0) {
                pUsage ();
                exit (1);
            }
            switch (nextArg) {
            case 1:
                index = 0;
                goto label1;
            case 2:
                index = 0;
                goto label2;
            case 3:
                index = 0;
                goto label3;
            case 4:
                index = 0;
                goto label4;
            }
        }
        switch (toupper(argv[argidx][1])) {
        case 'B':
            if (argv[argidx][2] == 0) {
                nextArg = 1;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label1:
                nextArg = 0;
                g_BaseDir = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_BaseDir, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_BaseDir, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        case 'T':
            if (argv[argidx][2] == 0) {
                nextArg = 2;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label2:
                nextArg = 0;
                g_TempDir = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_TempDir, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_TempDir, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        case 'I':
            if (argv[argidx][2] == 0) {
                nextArg = 3;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label3:
                nextArg = 0;
                g_TxtSetupPath = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_TxtSetupPath, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_TxtSetupPath, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        case 'F':
            g_RescanFlag = TRUE;
            if (argv[argidx][2] == 0) {
                nextArg = 4;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label4:
                nextArg = 0;
                g_RescanSect = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_RescanSect, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_RescanSect, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        default:
            pUsage ();
            exit (1);
        }
    }
    if (g_BaseDir == NULL) {
        g_BaseDir = AllocPathString (MAX_TCHAR_PATH);
        _tcsncpy (g_BaseDir, TEXT(".\\"), MAX_TCHAR_PATH);
    }
    if (g_TempDir == NULL) {
        g_TempDir = AllocPathString (MAX_TCHAR_PATH);
        if (GetEnvironmentVariable (TEXT("TEMP"), g_TempDir, MAX_TCHAR_PATH) == 0) {
            _tcsncpy (g_TempDir, TEXT("C:\\TEMP"), MAX_TCHAR_PATH);
        }
    }
    if (g_TxtSetupPath == NULL) {
        g_TxtSetupPath = AllocPathString (MAX_TCHAR_PATH);
        if ((GetEnvironmentVariable (TEXT("_NTTREE"   ), g_TxtSetupPath, MAX_TCHAR_PATH) == 0) &&
            (GetEnvironmentVariable (TEXT("_NT386TREE"), g_TxtSetupPath, MAX_TCHAR_PATH) == 0)
            ) {
            _tcsncpy (g_TxtSetupPath, TEXT("."), MAX_TCHAR_PATH);
        }
    }
    g_ConfigFile  = JoinPaths (g_BaseDir, TEXT("exports.cfg"));
    g_ExportDest  = JoinPaths (g_BaseDir, TEXT("e95only.dat"));

    if (!pSetupFileExists (g_ConfigFile, NULL)) {
        _tprintf (TEXT("\nConfiguration file not found. Exiting.\n"));
        exit (1);
    }

    if (SearchPath (NULL, TEXT("extract.exe"), NULL, 0, NULL, NULL) == 0) {
        _tprintf (TEXT("\nCannot find extract.exe. Exiting.\n"));
        exit (1);
    }

    configHandle = SetupOpenInfFile (g_ConfigFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (configHandle == INVALID_HANDLE_VALUE) {
        SearchPath (NULL, g_ConfigFile, NULL, MAX_TCHAR_PATH, fileName, &dontCare);
        configHandle = SetupOpenInfFile (fileName, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (configHandle == INVALID_HANDLE_VALUE) {
            _tprintf (TEXT("\nCannot open configuration file %s. Exiting.\n"), g_ConfigFile);
            exit (1);
        }
    }

    if (!pLoadKnownGoodExports (configHandle)) {
        _tprintf (TEXT("\nCannot load known good exports. Exiting.\n"));
        exit (1);
    }

    if (!pLocalLoadNTFilesData (g_TxtSetupPath, configHandle)) {
        _tprintf (TEXT("\nCannot load NT file list. Exiting.\n"));
        exit (1);
    }

    if (!pLoadIgnoredFiles (configHandle)) {
        _tprintf (TEXT("\nCannot load ignored files. Exiting.\n"));
        exit (1);
    }

    pWorkerFn (configHandle);

    WriteE95Only ();

    FreePathString (g_ConfigFile);
    FreePathString (g_TempDir);
    FreePathString (g_BaseDir);
    FreePathString (g_ExportDest);

    if (!MemDb_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        _tprintf (TEXT("MemDb failed initializing\n"));
        exit(1);
    }

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        _tprintf (TEXT("MigUtil failed initializing\n"));
        exit (1);
    }

}

BOOL
WriteE95Only (
    VOID
    )
{
    return MemDbExportA (MEMDB_CATEGORY_WIN9X_APIS, g_ExportDest, TRUE);
}

BOOL
pLoadKnownGoodExports (
    IN      HINF ConfigHandle
    )
{
    INFCONTEXT context;
    TCHAR goodExport [MAX_TCHAR_PATH];
    INT goodExportIdx;

    if (SetupFindFirstLine (ConfigHandle, TEXT("KnownGood"), NULL, &context)) {
        do {
            if (!SetupGetStringField (&context, 0, goodExport, MAX_TCHAR_PATH, NULL)) {
                _tprintf (TEXT("\nBad section [KnownGood] in %s. Exiting.\n"), g_ConfigFile);
                return FALSE;
            }
            if (!SetupGetIntField (&context, 1, &goodExportIdx)) {
                _tprintf (TEXT("\nBad section [KnownGood] in %s. Exiting.\n"), g_ConfigFile);
                return FALSE;
            }
            MemDbSetValueEx (MEMDB_CATEGORY_WNT_EXPORTS, goodExport, NULL, NULL, goodExportIdx, NULL);
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pLoadIgnoredFiles (
    IN      HINF ConfigHandle
    )
{
    INFCONTEXT context;
    TCHAR ignoredFile [MAX_TCHAR_PATH];
    TCHAR key [MEMDB_MAX];

    if (SetupFindFirstLine (ConfigHandle, TEXT("IgnoredFiles"), NULL, &context)) {
        do {
            if (!SetupGetStringField (&context, 0, ignoredFile, MAX_TCHAR_PATH, NULL)) {
                _tprintf (TEXT("\nBad section [IgnoredFiles] in %s. Exiting.\n"), g_ConfigFile);
                return FALSE;
            }
            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, ignoredFile, NULL, NULL);
            MemDbDeleteTree (key);
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pLocalLoadNTFilesData (
    IN      PCTSTR FilePath,
    IN      HINF ConfigHandle
    )
{
    PCSTR fileListName = NULL;
    PCSTR fileListNameTmp = NULL;

    //first let's read FILELIST.DAT
    fileListName = JoinPaths (g_TxtSetupPath, S_FILELIST_UNCOMPRESSED);
    if (!DoesFileExist (fileListName)) {
        fileListName = JoinPaths (g_TxtSetupPath, S_FILELIST_COMPRESSED);
        if (!DoesFileExist (fileListName)) {
            _tprintf (TEXT("Could not find FILELIST.DAT."));
            FreePathString (fileListName);
            return FALSE;
        }
        fileListNameTmp = JoinPaths (g_TempDir, S_FILELIST_UNCOMPRESSED);

        if (SetupDecompressOrCopyFile (fileListName, fileListNameTmp, 0) != NO_ERROR) {
            _tprintf (TEXT("Could not decompress FILELIST.DAT."));
            FreePathString (fileListName);
            FreePathString (fileListNameTmp);
            return FALSE;
        }

        FreePathString (fileListNameTmp);
    }

    if (!ReadNtFilesEx (fileListNameTmp?fileListNameTmp:fileListName, FALSE)) {
        _tprintf (TEXT("Could not read FILELIST.DAT."));
        if (fileListName) {
            FreePathString (fileListName);
        }
        if (fileListNameTmp) {
            DeleteFile (fileListNameTmp);
            FreePathString (fileListNameTmp);
        }
        return FALSE;
    }

    if (fileListName) {
        FreePathString (fileListName);
    }
    if (fileListNameTmp) {
        DeleteFile (fileListNameTmp);
        FreePathString (fileListNameTmp);
    }

    _tprintf (TEXT("Processing NT files ... \n"));

    if (!pHandleAllFiles (FilePath, FALSE)) {
        return FALSE;
    }

    return TRUE;
}

UINT
pCabinetCallback (
    IN      PVOID Context,          //context used by the callback routine
    IN      UINT Notification,      //notification sent to callback routine
    IN      UINT Param1,            //additional notification information
    IN      UINT Param2             //additional notification information );
    )
{
    PCTSTR tempDir  = Context;
    PCTSTR fileName = (PCTSTR)Param2 ;
    PFILE_IN_CABINET_INFO fileInfo = (PFILE_IN_CABINET_INFO)Param1;

    switch (Notification) {
    case SPFILENOTIFY_FILEEXTRACTED :
    case SPFILENOTIFY_NEEDNEWCABINET :
        return NO_ERROR;
    case SPFILENOTIFY_FILEINCABINET :
        _stprintf (fileInfo->FullTargetName, TEXT("%s\\%s"), tempDir, fileInfo->NameInCabinet);
        return FILEOP_DOIT;
    }
    return NO_ERROR;
}

BOOL
pWorkerFn (
    HINF ConfigHandle
    )
{
    INFCONTEXT context;
    TCHAR sectName [MAX_TCHAR_PATH];

    if (SetupFindFirstLine (ConfigHandle, TEXT("sections"), NULL, &context)) {
        do {
            if (!SetupGetStringField (&context, 1, sectName, MAX_TCHAR_PATH, NULL)) {
                _tprintf (TEXT("\nBad section [SECTIONS] in %s. Exiting.\n"), g_ConfigFile);
                return FALSE;
            }
            if (!pHandleSection (sectName, ConfigHandle)) {
                return FALSE;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pDeleteAllFiles (
    IN      PCTSTR DirPath
    )
{
    TREE_ENUM e;
    TCHAR tempFile [MAX_TCHAR_PATH] = "";
    BOOL dirsFirst = FALSE;

    if (EnumFirstFileInTree (&e, DirPath, TEXT("*"), dirsFirst)) {
        do {
            if (e.Directory) {
                DEBUGMSG((DBG_ERROR, "Unexpected directory in temporary area."));
                return FALSE;
            }
            _stprintf (tempFile, TEXT("%s\\%s"), DirPath, e.Name);
            if (!DeleteFile (tempFile)) {
                return FALSE;
            }
        } while (EnumNextFileInTree (&e));
    }
    return TRUE;
}

BOOL
pSelected (
    IN      PCTSTR FileName
    )
{
    TCHAR key[MEMDB_MAX];
    DWORD dontCare;

    MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, FileName, NULL, NULL);
    return MemDbGetValue (key, &dontCare);
}


BOOL
pCabinetFile (
    IN      PCTSTR FileName
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (FileName);
    if ((extPtr != NULL) &&
        (_tcsicmp (extPtr, TEXT("CAB")) == 0)
        ) {
        return TRUE;
    }
    return FALSE;
}

BOOL
pHandleFile (
    IN      PCTSTR FileName,
    IN      BOOL Win95Side
    )
{
    pProcessExportModule (FileName, Win95Side);

    return TRUE;
}

BOOL
pCompressedFile (
    IN      PTREE_ENUM e
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (e->FullPath);
    if (extPtr == NULL) {
        return FALSE;
    }
    if (_tcslen (extPtr) != 3) {
        return FALSE;
    }
    return (extPtr [2] == TEXT('_'));
}

BOOL
pExeFile (
    IN      PTREE_ENUM e
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (e->FullPath);
    if ((extPtr != NULL) &&
        (StringIMatch (extPtr, TEXT("EXE")))
        ) {
        return TRUE;
    }
    return FALSE;
}

BOOL
pCopyAndHandleCabResource (
    IN      PVOID Source,
    IN      DWORD Size,
    IN      PCTSTR DirName
    )
{
    TCHAR cabDir   [MAX_TCHAR_PATH] = "";
    HANDLE hFile;
    DWORD dontCare;

    if (Size < 4) {
        return TRUE;
    }
    if (*((PDWORD)Source) != 0x4643534D) {
        return TRUE;
    }

    g_FileSequencer ++;
    _stprintf (cabDir, TEXT("%s\\MIGDB%03u.CAB"), DirName, g_FileSequencer);

    hFile = CreateFile (cabDir, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "Cannot create file %s", cabDir));
        return FALSE;
    }
    if (!WriteFile (hFile, Source, Size, &dontCare, NULL)) {
        DEBUGMSG ((DBG_ERROR, "Cannot write to file %s", cabDir));
        return FALSE;
    }
    CloseHandle (hFile);

    return TRUE;
}

BOOL CALLBACK
EnumResNameProc (
    IN      HANDLE hModule,   // module handle
    IN      LPCTSTR lpszType, // pointer to resource type
    IN      LPTSTR lpszName,  // pointer to resource name
    IN      LONG lParam       // application-defined parameter
    )
{
    HRSRC hResource;
    DWORD size;
    HGLOBAL hGlobal;
    PVOID srcBytes;

    hResource = FindResource (hModule, lpszName, lpszType);
    if (hResource) {
        size = SizeofResource (hModule, hResource);
        if (size) {
            hGlobal = LoadResource (hModule, hResource);
            if (hGlobal) {
                srcBytes = LockResource (hGlobal);
                if (srcBytes) {
                    pCopyAndHandleCabResource (srcBytes, size, (PCTSTR)lParam);
                }
            }
        }
    }
    return TRUE;
}


BOOL CALLBACK
EnumResTypeProc (
    IN      HANDLE hModule,  // resource-module handle
    IN      LPTSTR lpszType, // pointer to resource type
    IN      LONG lParam      // application-defined parameter
    )
{
    if ((lpszType != RT_ACCELERATOR  ) &&
        (lpszType != RT_ANICURSOR    ) &&
        (lpszType != RT_ANIICON      ) &&
        (lpszType != RT_BITMAP       ) &&
        (lpszType != RT_CURSOR       ) &&
        (lpszType != RT_DIALOG       ) &&
        (lpszType != RT_FONT         ) &&
        (lpszType != RT_FONTDIR      ) &&
        (lpszType != RT_GROUP_CURSOR ) &&
        (lpszType != RT_GROUP_ICON   ) &&
        (lpszType != RT_HTML         ) &&
        (lpszType != RT_ICON         ) &&
        (lpszType != RT_MENU         ) &&
        (lpszType != RT_MESSAGETABLE ) &&
        (lpszType != RT_PLUGPLAY     ) &&
        (lpszType != RT_STRING       ) &&
        (lpszType != RT_VERSION      ) &&
        (lpszType != RT_VXD          ) &&
        (lpszType != RT_HTML         )
        ) {
        // we found an unknown type. Let's enumerate all resources of this type
        if (EnumResourceNames (hModule, lpszType, EnumResNameProc, lParam) == 0) {
            DEBUGMSG ((DBG_ERROR, "Error enumerating names:%ld", GetLastError ()));
        }
    }
    return TRUE;
}

BOOL
pHandleAllFiles (
    IN      PCTSTR SrcPath,
    IN      BOOL Win95Side
    )
{
    TCHAR tempDir [MAX_TCHAR_PATH] = "";
    TCHAR cmdLine [MAX_TCHAR_PATH] = "";
    TREE_ENUM e;
    DWORD error;
    HMODULE exeModule;

    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo;

    if (EnumFirstFileInTree (&e, SrcPath, TEXT("*"), FALSE)) {
        do {
            if (!e.Directory) {
                if (pCabinetFile (e.Name)) {
                    // cabinet file
                    g_DirSequencer++;
                    _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                    if (CreateDirectory (tempDir, NULL) == 0) {
                        error = GetLastError ();
                        if (error == ERROR_ALREADY_EXISTS) {
                            pDeleteAllFiles (tempDir);
                        }
                        ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                    }

                    _tprintf (TEXT("    Extracting cabinet file ... %s"), e.Name);

                    // we need to expand the cabinet file
                    SetLastError (0);
                    if (!SetupIterateCabinet (e.FullPath, 0, pCabinetCallback, tempDir)) {
                        _tprintf (TEXT("...error %ld\n"), GetLastError());
                        DEBUGMSG((DBG_ERROR, "Could not iterate cabinet file:%s\nError:%ld", e.FullPath, GetLastError ()));
                    }
                    else {
                        _tprintf (TEXT("...done\n"));
                    }

                    if (!pHandleAllFiles (tempDir, Win95Side)) {
                        return FALSE;
                    }

                    pDeleteAllFiles (tempDir);
                    RemoveDirectory (tempDir);
                    g_DirSequencer--;
                }
                else if (pCompressedFile (&e)) {

                    // compressed file
                    g_DirSequencer++;
                    _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                    if (CreateDirectory (tempDir, NULL) == 0) {
                        error = GetLastError ();
                        if (error == ERROR_ALREADY_EXISTS) {
                            pDeleteAllFiles (tempDir);
                        }
                        ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                    }

                    _stprintf (cmdLine, TEXT("expand /r %s %s"), e.FullPath, tempDir);
                    ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
                    startupInfo.cb = sizeof (STARTUPINFO);
                    if (CreateProcess (NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo)) {
                        WaitForSingleObject (processInfo.hProcess, INFINITE);
                        CloseHandle (processInfo.hProcess);
                        CloseHandle (processInfo.hThread);
                        if (!pHandleAllFiles (tempDir, Win95Side)) {
                            return FALSE;
                        }
                        pDeleteAllFiles (tempDir);
                    }
                    else {
                        DEBUGMSG ((DBG_ERROR, "Could not decompress:%s, Error:%ld", e.Name, GetLastError()));
                    }

                    RemoveDirectory (tempDir);
                    g_DirSequencer--;
                }
                else {
                    if (pExeFile (&e)) {

                        g_FileSequencer = 0;
                        g_DirSequencer++;
                        _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                        if (CreateDirectory (tempDir, NULL) == 0) {
                            error = GetLastError ();
                            if (error == ERROR_ALREADY_EXISTS) {
                                pDeleteAllFiles (tempDir);
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                        }

                        exeModule = LoadLibraryEx (e.FullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
                        EnumResourceTypes (exeModule, EnumResTypeProc, (LONG)tempDir);
                        FreeLibrary (exeModule);

                        if (!pHandleAllFiles (tempDir, Win95Side)) {
                            return FALSE;
                        }

                        pDeleteAllFiles (tempDir);
                        RemoveDirectory (tempDir);
                        g_DirSequencer--;
                    }

                    if (pSelected (e.Name)) {
                        if (!pHandleFile (e.FullPath, Win95Side)) {
                            return FALSE;
                        }
                    }
                }
            } else {
                if (!Win95Side) {
                    if ((StringIMatch (e.SubPath, TEXT("Win9xMig"))) ||
                        (StringIMatch (e.SubPath, TEXT("\\Win9xMig"))) ||
                        (StringIMatch (e.SubPath, TEXT("Winnt32"))) ||
                        (StringIMatch (e.SubPath, TEXT("\\Winnt32"))) ||
                        (StringIMatch (e.SubPath, TEXT("System32"))) ||
                        (StringIMatch (e.SubPath, TEXT("\\System32")))
                        ) {
                        AbortEnumFileInTree (&e);
                    }
                }
            }
        } while (EnumNextFileInTree (&e));
    }
    return TRUE;
}

BOOL
pHandleSection (
    IN      PCTSTR SectionName,
    IN      HINF ConfigHandle
    )
{
    INFCONTEXT context;
    TCHAR srcPath [MAX_TCHAR_PATH] = "";
    TCHAR key [MEMDB_MAX] = "";
    BOOL forced = FALSE;
    INT field;
    TCHAR includePattern [MAX_TCHAR_PATH] = "";
    DWORD dontCare;

    _tprintf (TEXT("Processing section : %s ... "), SectionName);

    if (!SetupFindFirstLine (ConfigHandle, SectionName, TEXT("sourcepath"), &context)) {
        _tprintf (TEXT("\nCannot find SourcePath= line in %s.\n"), SectionName);
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, srcPath, MAX_TCHAR_PATH, NULL)) {
        _tprintf (TEXT("\nCannot read source path name in %s.\n"), SectionName);
        return FALSE;
    }

    g_SectFiles.Buf       = NULL;
    g_SectFiles.Size      = 0;
    g_SectFiles.End       = 0;
    g_SectFiles.GrowSize  = 0;
    g_SectFiles.UserIndex = 0;

    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("IncludeFiles"), &context)) {
        field = 1;
        while (SetupGetStringField (&context, field, includePattern, MAX_TCHAR_PATH, NULL)) {
            MultiSzAppend (&g_SectFiles, includePattern);
            field ++;
        }
    }

    // let's try to find if this section was already processed in migdb.inx
    MemDbBuildKey (key, MEMDB_CATEGORY_W95_SECTIONS, SectionName, NULL, NULL);
    if (MemDbGetValue (key, &dontCare)) {
        FreeGrowBuffer (&g_SectFiles);
        _tprintf (TEXT("skipped\n"));
        return TRUE;
    }

    _tprintf (TEXT("\n"));

    MemDbSetValue (key, 0);

    if (!pHandleAllFiles (srcPath, TRUE)) {
        FreeGrowBuffer (&g_SectFiles);
        return FALSE;
    }

    FreeGrowBuffer (&g_SectFiles);

    return TRUE;
}


//from here we are dealing with 16 bit and 32 bit modules decompiling code


//since we are reading from a file we need that sizeof to give us the accurate result
#pragma pack(push,1)

typedef struct _NE_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    WORD  EntryTableOff;
    WORD  EntryTableLen;
    ULONG Reserved;
    WORD  Flags;
    WORD  NumberOfDataSeg;
    WORD  SizeOfHeap;
    WORD  SizeOfStack;
    ULONG CS_IP;
    ULONG SS_SP;
    WORD  NumEntriesSegTable;
    WORD  NumEntriesModuleTable;
    WORD  NonResNameTableSize;
    WORD  SegTableOffset;
    WORD  ResTableOffset;
    WORD  ResNameTableOffset;
    WORD  ModuleTableOffset;
    WORD  ImportedTableOffset;
    ULONG NonResNameTableOffset;
    WORD  NumberOfMovableEntryPoints;
    WORD  ShiftCount;
    WORD  NumberOfResourceSegments;
    BYTE  TargetOS;
    BYTE  AdditionalInfo;
    WORD  FastLoadOffset;
    WORD  FastLoadSize;
    WORD  Reserved1;
    WORD  WinVersionExpected;
} NE_HEADER, *PNE_HEADER;

typedef struct _NE_SEGMENT_ENTRY {
    WORD  SegmentOffset;
    WORD  SegmentLen;
    WORD  SegmentFlags;
    WORD  SegMinAlloc;
} NE_SEGMENT_ENTRY, *PNE_SEGMENT_ENTRY;

typedef struct _NE_RELOC_ITEM {
    BYTE  AddressType;
    BYTE  RelocType;
    WORD  RelocOffset;
    WORD  ModuleOffset;
    WORD  FunctionOffset;
} NE_RELOC_ITEM, *PNE_RELOC_ITEM;

#define SEG_CODE_MASK                   0x0001
#define SEG_CODE                        0x0000
#define SEG_PRELOAD_MASK                0x0040
#define SEG_PRELOAD                     0x0040
#define SEG_RELOC_MASK                  0x0100
#define SEG_RELOC                       0x0100

#define RELOC_IMPORTED_ORDINAL          0x01
#define RELOC_IMPORTED_NAME             0x02

#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ
#define IMAGE_NE_SIGNATURE              0x454E      // NE
#define IMAGE_PE_SIGNATURE              0x00004550l // PE00

#pragma pack(pop)

typedef struct _EXPORT_ENUM32 {
    /*user area - BEGIN*/
    PCSTR    ExportFunction;
    DWORD    ExportFunctionOrd;
    /*user area - END*/

    PLOADED_IMAGE Image;
    PIMAGE_EXPORT_DIRECTORY ImageDescriptor;
    PDWORD ExportNamesAddr;
    PUSHORT ExportOrdAddr;
    DWORD CurrExportNr;
} EXPORT_ENUM32, *PEXPORT_ENUM32;

typedef struct _EXPORT_ENUM16 {
    /*user area - BEGIN*/
    CHAR ExportFunction[MAX_MBCHAR_PATH];
    PUSHORT ExportFunctionOrd;
    /*user area - END*/

    BOOL ResTable;
    PCSTR Image;
    PDOS_HEADER DosHeader;
    PNE_HEADER NeHeader;
    PCSTR NamesEntry;
} EXPORT_ENUM16, *PEXPORT_ENUM16;

#define UNKNOWN_MODULE  0
#define DOS_MODULE      1
#define W16_MODULE      2
#define W32_MODULE      3

typedef struct _MODULE_IMAGE {
    UINT ModuleType;
    union {
        struct {
            LOADED_IMAGE Image;
        } W32Data;
        struct {
            PCSTR Image;
            HANDLE FileHandle;
            HANDLE MapHandle;
        } W16Data;
    } ModuleData;
} MODULE_IMAGE, *PMODULE_IMAGE;

BOOL
pLoadModuleData (
    IN      PCSTR ModuleName,
    IN OUT  PMODULE_IMAGE ModuleImage
    )
{
    HANDLE fileHandle;
    DWORD bytesRead;
    DOS_HEADER dh;
    DWORD sign;
    PWORD signNE = (PWORD)&sign;
    BOOL result = FALSE;

    ZeroMemory (ModuleImage, sizeof (MODULE_IMAGE));

    fileHandle = CreateFile (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        ModuleImage->ModuleType = UNKNOWN_MODULE;
        return FALSE;
    }
    __try {
        __try {
            if ((!ReadFile (fileHandle, &dh, sizeof (DOS_HEADER), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DOS_HEADER))
                ) {
                __leave;
            }
            result = TRUE;
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ModuleImage->ModuleType = UNKNOWN_MODULE;
                __leave;
            }
            ModuleImage->ModuleType = DOS_MODULE;

            if (SetFilePointer (fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            if ((!ReadFile (fileHandle, &sign, sizeof (DWORD), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DWORD))
                ) {
                __leave;
            }
            CloseHandle (fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;

            if (sign == IMAGE_PE_SIGNATURE) {
                ModuleImage->ModuleType = W32_MODULE;
                result = MapAndLoad ((PSTR)ModuleName, NULL, &ModuleImage->ModuleData.W32Data.Image, FALSE, TRUE);
            }
            if (*signNE == IMAGE_NE_SIGNATURE) {
                ModuleImage->ModuleType = W16_MODULE;
                ModuleImage->ModuleData.W16Data.Image = MapFileIntoMemory (
                                                            ModuleName,
                                                            &ModuleImage->ModuleData.W16Data.FileHandle,
                                                            &ModuleImage->ModuleData.W16Data.MapHandle
                                                            );
                result = (ModuleImage->ModuleData.W16Data.Image != NULL);
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle (fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
pUnloadModuleData (
    IN OUT  PMODULE_IMAGE ModuleImage
    )
{
    switch (ModuleImage->ModuleType) {
    case W32_MODULE:
        UnMapAndLoad (&ModuleImage->ModuleData.W32Data.Image);
        break;
    case W16_MODULE:
        UnmapFile (
            (PVOID) ModuleImage->ModuleData.W16Data.Image,
            ModuleImage->ModuleData.W16Data.FileHandle,
            ModuleImage->ModuleData.W16Data.MapHandle
            );
        break;
    default:;
    }
    return TRUE;
}

BOOL
EnumNextExportFunction16 (
    IN OUT  PEXPORT_ENUM16 ModuleExports
    )
{
    ModuleExports->NamesEntry += ModuleExports->NamesEntry [0] + 3;
    if (ModuleExports->NamesEntry [0] == 0) {
        if (!ModuleExports->ResTable) {
            return FALSE;
        }
        else {
            ModuleExports->ResTable = FALSE;
            ModuleExports->NamesEntry = ModuleExports->Image +
                                        ModuleExports->NeHeader->NonResNameTableOffset;
            return EnumNextExportFunction16 (ModuleExports);
        }
    }
    strncpy (ModuleExports->ExportFunction, ModuleExports->NamesEntry + 1, ModuleExports->NamesEntry [0]);
    ModuleExports->ExportFunction [ModuleExports->NamesEntry [0]] = 0;
    ModuleExports->ExportFunctionOrd = (PUSHORT) (ModuleExports->NamesEntry + ModuleExports->NamesEntry [0] + 1);

    return TRUE;
}

BOOL
EnumFirstExportFunction16 (
    IN      PCSTR ModuleImage,
    IN OUT  PEXPORT_ENUM16 ModuleExports
    )
{
    ZeroMemory (ModuleExports, sizeof (EXPORT_ENUM16));

    ModuleExports->Image = ModuleImage;

    ModuleExports->ResTable = TRUE;

    ModuleExports->DosHeader = (PDOS_HEADER) (ModuleExports->Image);
    ModuleExports->NeHeader = (PNE_HEADER) (ModuleExports->Image + ModuleExports->DosHeader->e_lfanew);

    ModuleExports->NamesEntry = ModuleExports->Image +
                                ModuleExports->DosHeader->e_lfanew +
                                ModuleExports->NeHeader->ResNameTableOffset;
    return EnumNextExportFunction16 (ModuleExports);
}

BOOL
EnumNextExportFunction32 (
    IN OUT  PEXPORT_ENUM32 ModuleExports
    )
{
    if (ModuleExports->CurrExportNr >= ModuleExports->ImageDescriptor->NumberOfNames) {
        return FALSE;
    }
    if (*ModuleExports->ExportNamesAddr == 0) {
        return FALSE;
    }
    ModuleExports->ExportFunction = ImageRvaToVa (
                                        ModuleExports->Image->FileHeader,
                                        ModuleExports->Image->MappedAddress,
                                        *ModuleExports->ExportNamesAddr,
                                        NULL
                                        );
    ModuleExports->ExportFunctionOrd = *ModuleExports->ExportOrdAddr + ModuleExports->ImageDescriptor->Base;

    ModuleExports->ExportNamesAddr ++;
    ModuleExports->ExportOrdAddr ++;
    ModuleExports->CurrExportNr ++;
    return (ModuleExports->ExportFunction != NULL);
}

BOOL
EnumFirstExportFunction32 (
    IN      PLOADED_IMAGE ModuleImage,
    IN OUT  PEXPORT_ENUM32 ModuleExports
    )
{
    ULONG imageSize;

    ZeroMemory (ModuleExports, sizeof (EXPORT_ENUM32));

    ModuleExports->Image = ModuleImage;

    ModuleExports->ImageDescriptor = (PIMAGE_EXPORT_DIRECTORY)
                                        ImageDirectoryEntryToData (
                                            ModuleImage->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_EXPORT,
                                            &imageSize
                                            );
    if (!ModuleExports->ImageDescriptor) {
        DEBUGMSG((DBG_MODULES, ":Cannot load export directory for %s", ModuleImage->ModuleName));
        return FALSE;
    }
    if (ModuleExports->ImageDescriptor->NumberOfNames == 0) {
        return FALSE;
    }

    ModuleExports->ExportNamesAddr = (PDWORD) ImageRvaToVa (
                                                ModuleExports->Image->FileHeader,
                                                ModuleExports->Image->MappedAddress,
                                                ModuleExports->ImageDescriptor->AddressOfNames,
                                                NULL
                                                );

    ModuleExports->ExportOrdAddr = (PUSHORT) ImageRvaToVa (
                                                ModuleExports->Image->FileHeader,
                                                ModuleExports->Image->MappedAddress,
                                                ModuleExports->ImageDescriptor->AddressOfNameOrdinals,
                                                NULL
                                                );

    ModuleExports->CurrExportNr = 0;

    return EnumNextExportFunction32 (ModuleExports);
}

DWORD
pProcessPEModule (
    IN      PCSTR CurrentPath,
    IN      PLOADED_IMAGE ModuleImage,
    IN      BOOL Win95Side
    )
{
    EXPORT_ENUM32 e;
    CHAR key[MEMDB_MAX];
    MEMDB_ENUM me;
    DWORD memDbValue;

    if (EnumFirstExportFunction32 (ModuleImage, &e)) {
        do {
            DEBUGMSG((DBG_MODULES, "%s 32exports %s", ModuleImage->ModuleName, e.ExportFunction));
            if (Win95Side) {
                MemDbBuildKey (key, MEMDB_CATEGORY_WNT_EXPORTS, GetFileNameFromPath (ModuleImage->ModuleName), e.ExportFunction, NULL);
                if (!MemDbGetValue (key, &memDbValue)) {
                    if (MemDbEnumFirstValue (&me, MEMDB_CATEGORY_WIN9X_APIS TEXT("\\*"), MEMDB_ALL_SUBLEVELS, MEMDB_ALL_MATCHES)) {
                        MemDbBuildKey (key, MEMDB_CATEGORY_WIN9X_APIS, GetFileNameFromPath (ModuleImage->ModuleName), e.ExportFunction, NULL);
                        MemDbSetValue (key, 0);

                        _stprintf (key, TEXT("%s\\%s\\%ld"), MEMDB_CATEGORY_WIN9X_APIS, GetFileNameFromPath (ModuleImage->ModuleName), e.ExportFunctionOrd);
                        MemDbSetValue (key, 0);
                    }
                }
                else {
                    if ((USHORT)memDbValue != e.ExportFunctionOrd) {
                        _stprintf (key, TEXT("%s\\%s\\%ld"), MEMDB_CATEGORY_WIN9X_APIS, GetFileNameFromPath (ModuleImage->ModuleName), e.ExportFunctionOrd);
                        MemDbSetValue (key, 0);
                    }
                }
            }
            else {
                MemDbBuildKey (key, MEMDB_CATEGORY_WNT_EXPORTS, GetFileNameFromPath (ModuleImage->ModuleName), e.ExportFunction, NULL);
                if (!MemDbGetValue (key, NULL)) {
                    MemDbSetValue (key, e.ExportFunctionOrd);
                }
            }
        }
        while (EnumNextExportFunction32 (&e));
    }
    return TRUE;
}

DWORD
pProcessNEModule (
    IN      PCSTR ModuleName,
    IN      PCSTR ModuleImage,
    IN      BOOL Win95Side
    )
{
    EXPORT_ENUM16 e;
    CHAR key[MEMDB_MAX];
    CHAR fileName[MEMDB_MAX];
    PSTR extPtr;
    MEMDB_ENUM me;
    DWORD memDbValue;

    //since this is a NT module whenever some other module imports something from this one we will not have the
    //extension so let's get the extension out

    StringCopy (fileName, GetFileNameFromPath (ModuleName));
    extPtr = (PSTR)GetFileExtensionFromPath (fileName);
    if (extPtr) {
        extPtr = _mbsdec (fileName, extPtr);
        if (extPtr) {
            *extPtr = 0;
        }
    }

    if (EnumFirstExportFunction16 (ModuleImage, &e)) {
        do {
            DEBUGMSG((DBG_MODULES, "%s 16exports %s", ModuleName, e.ExportFunction));
            if (Win95Side) {

                MemDbBuildKey (key, MEMDB_CATEGORY_WNT_EXPORTS, fileName, e.ExportFunction, NULL);
                if (!MemDbGetValue (key, &memDbValue)) {

                    if (MemDbEnumFirstValue (&me, MEMDB_CATEGORY_WIN9X_APIS TEXT("\\*"), MEMDB_ALL_SUBLEVELS, MEMDB_ALL_MATCHES)) {
                        MemDbBuildKey (key, MEMDB_CATEGORY_WIN9X_APIS, fileName, e.ExportFunction, NULL);
                        MemDbSetValue (key, 0);

                        _stprintf (key, TEXT("%s\\%s\\%ld"), MEMDB_CATEGORY_WIN9X_APIS, fileName, *e.ExportFunctionOrd);
                        MemDbSetValue (key, 0);
                    }
                }
                else {
                    if ((USHORT)memDbValue != (*e.ExportFunctionOrd)) {
                        _stprintf (key, TEXT("%s\\%s\\%ld"), MEMDB_CATEGORY_WIN9X_APIS, fileName, *e.ExportFunctionOrd);
                        MemDbSetValue (key, 0);
                    }
                }
            }
            else {
                MemDbBuildKey (key, MEMDB_CATEGORY_WNT_EXPORTS, fileName, e.ExportFunction, NULL);
                if (!MemDbGetValue (key, NULL)) {
                    MemDbSetValue (key, *e.ExportFunctionOrd);
                }
            }
        }
        while (EnumNextExportFunction16 (&e));
    }
    return TRUE;
}

BOOL
pProcessExportModule (
    IN      PCTSTR ModuleName,
    IN      BOOL Win95Side
    )
{
    MODULE_IMAGE moduleImage;
    DWORD result = TRUE;

    PCSTR fileName = GetFileNameFromPath (ModuleName);
    if (_stricmp (fileName, "COMCTL32.DLL") == 0) {
        result = TRUE;
    }

    __try {
        if (!pLoadModuleData (ModuleName, &moduleImage)) {
            DEBUGMSG((DBG_MODULES, ":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        __try {
            switch (moduleImage.ModuleType) {
            case DOS_MODULE:
                DEBUGMSG((DBG_MODULES, "Examining %s : DOS module.", ModuleName));
                break;
            case W16_MODULE:
                DEBUGMSG((DBG_MODULES, "Examining %s : W16 module.", ModuleName));
                result = pProcessNEModule (ModuleName, moduleImage.ModuleData.W16Data.Image, Win95Side);
                break;
            case W32_MODULE:
                DEBUGMSG((DBG_MODULES, "Examining %s : W32 module.", ModuleName));
                result = pProcessPEModule (ModuleName, &moduleImage.ModuleData.W32Data.Image, Win95Side);
                break;
            default:
                DEBUGMSG((DBG_MODULES, "Examining %s : Unknown module type.", ModuleName));
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            DEBUGMSG((DBG_WARNING, DBG_MODULES":Access violation while checking %s", ModuleName));
            result = TRUE;
        }
    }
    __finally {
        pUnloadModuleData (&moduleImage);
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\filegen\filegen.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    filegen.c

Abstract:

    This module creates a tool that generates filelist.dat and is executed for us by
    the NT build lab.  It scans the INI files to build a list for all files that are
    going to be installed by NT

Author:

    Calin Negreanu (calinn) 18-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include <conio.h>

#ifdef UNICODE
#error UNICODE not allowed
#endif

#define S_IGNORE_THIS_FILE  TEXT("*")

#define FILEGEN_VERSION     3

#define DIRS_FIELD  8
#define DISP_FIELD  9
#define DEST_FIELD  11

#define SRC_NEVER_COPY              0x01


BOOL CancelFlag = FALSE;
BOOL *g_CancelFlagPtr = &CancelFlag;
POOLHANDLE g_TempPool;

#ifdef DEBUG
extern BOOL g_DoLog;
#endif

typedef BOOL (*PSETUPGETINFSECTIONS) ( HINF,PTSTR,UINT,UINT*);

PSETUPGETINFSECTIONS MypSetupGetInfSections;

// this section is populated from the directories with either INF files or with compressed
// INF files that were uncompressed in the temp directory. Two things: The value of every
// key will have a checksum of the INF, if this is 0xFFFFFFFF it means that the INF file
// has changed and all the other information about this INF file should be discarded.
#define MEMDB_CATEGORY_INF_FILES            TEXT("InfFiles")

// this section needs no optimization. It will be created every time from the additional file
#define MEMDB_CATEGORY_NT_KNOWN_FILES       TEXT("NtKnownFiles")

// this section needs no optimization. It will be created every time from the additional file
#define MEMDB_CATEGORY_NT_HEADER_FILES      TEXT("NtHeaderFiles")

// this section needs no optimization. It will be created every time from the additional file
#define MEMDB_CATEGORY_NT_CHECK_FILES       TEXT("NtCheckFiles")

#define MEMDB_CATEGORY_NT_FILES_DOUBLED_COPY        "NtFilesDoubledCopy"
#define MEMDB_CATEGORY_NT_FILES_DOUBLED_IDX_COPY    "NtFilesDoubledIdxCopy"
#define MEMDB_CATEGORY_NT_FILES_NODIR_COPY          "NtFilesNoDirCopy"
#define MEMDB_CATEGORY_NT_FILES_NODIR_OTHER_COPY    "NtFilesNoDirOtherCopy"

#define MEMDB_CATEGORY_NT_FILES_DOUBLED_DEL         "NtFilesDoubledDel"
#define MEMDB_CATEGORY_NT_FILES_DOUBLED_IDX_DEL     "NtFilesDoubledIdxDel"
#define MEMDB_CATEGORY_NT_FILES_NODIR_DEL           "NtFilesNoDirDel"
#define MEMDB_CATEGORY_NT_FILES_NODIR_OTHER_DEL     "NtFilesNoDirOtherDel"

#define MEMDB_CATEGORY_NT_SECT_NODIR        "NtSectNoDir"
#define MEMDB_CATEGORY_NT_SECT_BADDIR       "NtSectBadDir"
#define MEMDB_CATEGORY_NT_INSTALLED_INFS    "NtInstalledInfs"
#define MEMDB_CATEGORY_NT_FILES_NO_LAYOUT   "NtFileNoLayout"

#define MEMDB_CATEGORY_DEL_FILES            "DelFiles"

#define MEMDB_CATEGORY_SRC_INF_FILES_NR     "Source INF Files\\Total Number"
#define MEMDB_CATEGORY_SRC_INF_FILES        "Source INF Files"

#define MEMDB_CATEGORY_KNOWN_FILE_NAMES     "KnownFileNames"

#define SECT_KNOWN_LOCATION                 "NtFiles_KnownLocation"

HANDLE g_hHeap;
HINSTANCE g_hInst;
extern POOLHANDLE g_TextPool;

CHAR   g_TempDirBuf[MAX_MBCHAR_PATH];
CHAR   g_TempDirWackBuf[MAX_MBCHAR_PATH];
PSTR   g_TempDir;
PSTR   g_TempDirWack;
INT    g_TempDirWackChars;
PSTR   g_WinDir;
CHAR   g_WinDirBuf[MAX_MBCHAR_PATH];
CHAR   g_SourceDirectoryBuf[MAX_SOURCE_COUNT][MAX_MBCHAR_PATH];
PCSTR  g_SourceDirectories[MAX_SOURCE_COUNT];
DWORD  g_SourceDirectoryCount = 0;

BOOL   g_DoWarnings = FALSE;
CHAR   g_WarnFileBuf[MAX_MBCHAR_PATH];
PSTR   g_WarnFile = NULL;

BOOL   g_DoHeader = FALSE;
CHAR   g_HeaderFileBuf[MAX_MBCHAR_PATH];
PSTR   g_HeaderFile = NULL;

PSTR   g_AddnlFile = NULL;
BOOL   g_AddnlFileForced = FALSE;
CHAR   g_AddnlFileBuf[MAX_MBCHAR_PATH];
CHAR   g_AddnlFileAlt[MAX_MBCHAR_PATH];
HINF   g_AddnlInf = INVALID_HANDLE_VALUE;

CHAR   g_PlatformBuf[MAX_MBCHAR_PATH];
PSTR   g_Platform = NULL;
CHAR   g_ProductBuf[MAX_MBCHAR_PATH];
PSTR   g_Product = NULL;

CHAR   g_StructNameBuf[MAX_MBCHAR_PATH] = "Tier2Files";
PSTR   g_StructName = NULL;

BOOL   g_StrictInfs = TRUE;

#define LAYOUT_CACHE_SIZE           3
CHAR   g_LastLayoutFile[LAYOUT_CACHE_SIZE][MAX_MBCHAR_PATH];
UINT   g_LayoutRef[LAYOUT_CACHE_SIZE];
HINF   g_LastLayoutHandle[LAYOUT_CACHE_SIZE];
BOOL   g_NextAvailLayoutData = 0;

BOOL   g_ForceRescan = FALSE;
PSTR   g_InfDatabase = NULL;
UINT   g_TotalInfFiles = 0;

typedef struct _EXCLUDED_FILES {
    PCSTR File;
    INT ExcludeType;
    struct _EXCLUDED_FILES *Next;
} EXCLUDED_FILES, *PEXCLUDED_FILES;

PEXCLUDED_FILES g_ExcludedFiles = NULL;

typedef struct _FORCED_FILES {
    PCSTR FilePattern;
    struct _FORCED_FILES *Next;
} FORCED_FILES, *PFORCED_FILES;

PFORCED_FILES g_ForcedFiles = NULL;

typedef struct _EXCLUDED_INF_FILES {
    PCSTR InfName;
    PCSTR CopySectName;
    struct _EXCLUDED_INF_FILES *Next;
} EXCLUDED_INF_FILES, *PEXCLUDED_INF_FILES;

HASHITEM g_ExcludedInfsTable;
HASHITEM g_ExcludedDirsTable;

typedef struct _RENAMED_DIRS {
    PCSTR SrcDir;
    PCSTR DestDir;
    struct _RENAMED_DIRS *Next;
} RENAMED_DIRS, *PRENAMED_DIRS;

PRENAMED_DIRS g_RenamedDirs = NULL;

typedef struct _HEADER_FILES {
    PCSTR FilePattern;
    UINT Priority;
    struct _HEADER_FILES *Next;
} HEADER_FILES, *PHEADER_FILES;

PHEADER_FILES g_HeaderFiles;

HASHITEM g_PrivateIdInfsTable;

typedef struct _PRIVATE_ID_INFS {
    PCSTR PrivateId;
    PCSTR EquivalentId;
    struct _PRIVATE_ID_INFS *Next;
} PRIVATE_ID_INFS, *PPRIVATE_ID_INFS;

HASHITEM g_IgnoredDirsTable;

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    );

BOOL
WINAPI
MemDb_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    );

BOOL
pCreateNtFileList (
    IN      PCSTR FileListDatPath
    );

BOOL
LocalGetFileNames (
    IN      PCTSTR *InfDirs,
    IN      UINT InfDirCount,
    IN      BOOL QueryFlag
    );

BOOL
pLocalGetFileNamesWorker (
    IN      PCTSTR InfDir,
    IN      BOOL QueryFlag
    );

VOID
LocalFreeFileNames (
    IN      BOOL QueryFlag
    );

BOOL
pLocalReadNtFiles (
    IN      PCTSTR InfPath
    );

BOOL
pFixDir (
    IN      PCSTR src,
    OUT     PSTR dest
    );

BOOL
pIsExcludedDir (
    IN      PCTSTR DirName
    );

BOOL
pShouldRescanInfs (
    IN      PCTSTR *InfDirs,
    IN      UINT InfDirCount
    );

VOID
pProcessDelFileSpec (
    IN      PCSTR DestDirectory,
    IN      PCSTR DestFile
    );


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "filegen [-i:<infdir>] [-o:<outputfile>] [-t:<tempdir>] [-w[:<warningfile>]]\n"
            "        [-h:<headerfile>] [-a:<additional_file>] [-p:<platform>]\n"
            "        [-d:<product>] [-s:<struct_name>] [-b:<INF database>] [-f] [-l]\n\n"
            "Optional Arguments:\n"
            "  [-i:<infdir>]        - Specifies directory containing INF files.\n"
            "                         Default: %%_NTTREE%%\n"
            "  [-o:<outputfile>]    - Specifies path and file name of DAT file.\n"
            "                         Default: %%_NTTREE%%\\filelist.dat\n"
            "  [-t:<tempdir>]       - Specifies path for temporary files.\n"
            "                         Default: %%TEMP%%\n"
            "  [-w[:<warningfile>]] - Specifies if warning file is generated and it's\n"
            "                         location. Default: %%_NTTREE%%\\dump\\filegen.wrn\n"
            "  [-h:<headerfile>]    - Specifies if header file is generated and it's\n"
            "                         location. Default: %%_NTTREE%%\\dump\\filegen.hdr\n"
            "  [-a:<addnl_file>]    - Specifies full path name for FILEGEN.INF file\n"
            "  [-p:<platform>]      - Specifies platform (such as x86 or ia64)\n"
            "                         Default: x86\n"
            "  [-d:<product>]       - Specifies product type (WKS, DTC, ENT, SRV)\n"
            "                         Default: WKS\n"
            "  [-s:<struct_name>]   - Specifies the structure name (for header file)\n"
            "                         Default: Tier2Files\n"
            "  [-b:<INF database>]  - Specifies INF database file from the last run\n"
            "  [-f]                 - Force rescanning all INFs\n"
            "  [-l]                 - List content of existing output file\n"
            );

    exit(255);
}

HINF
pOpenInfWithCache (
    IN      PCSTR InfFile
    )
{
    HINF infHandle;
    INT index;

    for (index = 0 ; index < LAYOUT_CACHE_SIZE ; index++) {
        if (StringIMatch (InfFile, g_LastLayoutFile[index])) {
            infHandle = g_LastLayoutHandle[index];
            g_LayoutRef[index] += 1;
            break;
        }
    }

    if (index == LAYOUT_CACHE_SIZE) {
        infHandle = InfOpenInfFile (InfFile);

        if (infHandle != INVALID_HANDLE_VALUE) {

            for (index = 0 ; index < LAYOUT_CACHE_SIZE ; index++) {
                if (g_LayoutRef[index] == 0) {
                    break;
                }
            }

            if (index < LAYOUT_CACHE_SIZE) {
                if (g_LastLayoutFile[index][0]) {
                    InfCloseInfFile (g_LastLayoutHandle[index]);
                }

                StringCopy (g_LastLayoutFile[index], InfFile);
                g_LastLayoutHandle[index] = infHandle;
                g_LayoutRef[index] = 1;
            }
        }
    }

    return infHandle;
}


VOID
pCloseInfWithCache (
    IN      HINF Inf
    )
{
    INT i;

    for (i = 0 ; i < LAYOUT_CACHE_SIZE ; i++) {
        if (g_LastLayoutFile[i][0] && g_LastLayoutHandle[i] == Inf) {
            break;
        }
    }

    if (i < LAYOUT_CACHE_SIZE) {
        if (g_LayoutRef[i] == 0) {
            MYASSERT(FALSE);
        } else {
            g_LayoutRef[i] -= 1;
        }
    } else {
        InfCloseInfFile (Inf);
    }
}


VOID
pCloseCachedHandles (
    VOID
    )
{
    INT index;

    for (index = 0 ; index < LAYOUT_CACHE_SIZE ; index++) {
        if (g_LastLayoutFile[index][0]) {

            InfCloseInfFile (g_LastLayoutHandle[index]);
            g_LastLayoutHandle[index] = INVALID_HANDLE_VALUE;
            g_LastLayoutFile[index][0] = 0;
            g_LayoutRef[index] = 0;
        }
    }
}


PTSTR
pGetNonEmptyField (
    IN OUT  PINFSTRUCT InfStruct,
    IN      UINT Field
    )
{
    PTSTR result;

    result = InfGetStringField (InfStruct, Field);
    if (result && *result == 0) {
        result = NULL;
    }

    return result;
}

BOOL
pIsForcedFile (
    IN      PCTSTR FileName
    )
{
    PFORCED_FILES forcedFile;

    forcedFile = g_ForcedFiles;
    while (forcedFile) {

        if (IsPatternMatch (forcedFile->FilePattern, FileName)) {
            return TRUE;
        }
        forcedFile = forcedFile->Next;
    }
    return FALSE;
}

INT
pIsExcludedFile (
    IN      PCTSTR FileName
    )
{
    PEXCLUDED_FILES excludedFile;

    //
    // Test if a file referenced by an INF should be excluded from the file list
    //
    // Return value -1 means not excluded
    // Return value 0 means excluded
    // Return value 1 means not excluded, but include in excluded files section of filelist.dat
    //

    excludedFile = g_ExcludedFiles;
    while (excludedFile) {

        if (IsPatternMatch (excludedFile->File, FileName)) {
            if (!pIsForcedFile (FileName)) {
                return excludedFile->ExcludeType;
            }
        }
        excludedFile = excludedFile->Next;
    }
    return -1;
}

BOOL
pIsExcludedInfSection (
    IN      PCTSTR InfFileName,
    IN      PCTSTR InfSectionName
    )
{
    BOOL excluded = FALSE;
    PEXCLUDED_INF_FILES excludedInf;

    if (HtFindStringAndData (g_ExcludedInfsTable, InfFileName, &excludedInf)) {
        if (!excludedInf) {
            //this means that the whole INF is excluded
            excluded = TRUE;
        } else {
            while (excludedInf) {
                if (StringIMatch (excludedInf->CopySectName, InfSectionName)) {
                    excluded = TRUE;
                    break;
                }
                excludedInf = excludedInf->Next;
            }
        }
    }
    return excluded;
}

BOOL
pLoadForcedFilesFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    PCSTR filePattern;
    PFORCED_FILES forcedFile;

    if (InfFindFirstLine (infHandle, SectName, NULL, &context)) {
        do {
            filePattern = pGetNonEmptyField (&context, 1);
            if (filePattern) {
                forcedFile = (PFORCED_FILES) PoolMemGetMemory (g_TextPool, sizeof (FORCED_FILES));
                if (forcedFile) {
                    forcedFile->FilePattern = PoolMemDuplicateString (g_TextPool, filePattern);
                    forcedFile->Next = g_ForcedFiles;
                    g_ForcedFiles = forcedFile;
                }
            }
        } while (InfFindNextLine (&context));
    }
    InfCleanUpInfStruct (&context);
    return TRUE;
}

BOOL
pLoadForcedFiles (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    StringCopy (sectTmp, TEXT("FILELIST.FORCEINCLUDE"));
    pLoadForcedFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadForcedFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadForcedFilesFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.FORCEINCLUDE"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadForcedFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadForcedFilesFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}

BOOL
pLoadExcludedFilesFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    PCSTR filePattern;
    PEXCLUDED_FILES excludedFile;

    if (InfFindFirstLine (infHandle, SectName, NULL, &context)) {
        do {
            filePattern = pGetNonEmptyField (&context, 1);
            if (filePattern) {
                excludedFile = (PEXCLUDED_FILES) PoolMemGetMemory (g_TextPool, sizeof (EXCLUDED_FILES));
                if (excludedFile) {
                    excludedFile->File = PoolMemDuplicateString (g_TextPool, filePattern);
                    if (!InfGetIntField (&context, 2, &(excludedFile->ExcludeType))) {
                        excludedFile->ExcludeType = 0;
                    }
                    excludedFile->Next = g_ExcludedFiles;
                    g_ExcludedFiles = excludedFile;
                }
            }
        } while (InfFindNextLine (&context));
    }
    InfCleanUpInfStruct (&context);
    return TRUE;
}

BOOL
pLoadExcludedFiles (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    StringCopy (sectTmp, TEXT("FILELIST.EXCLUDE"));
    pLoadExcludedFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadExcludedFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadExcludedFilesFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.EXCLUDE"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadExcludedFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadExcludedFilesFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}

BOOL
pLoadRenamedDirsFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    PCSTR srcDir, destDir;
    PRENAMED_DIRS renamedDir;

    if (InfFindFirstLine (infHandle, SectName, NULL, &context)) {
        do {
            srcDir = pGetNonEmptyField (&context, 1);
            destDir = pGetNonEmptyField (&context, 2);

            if (srcDir && destDir) {
                renamedDir = (PRENAMED_DIRS) PoolMemGetMemory (g_TextPool, sizeof (RENAMED_DIRS));
                if (renamedDir) {
                    renamedDir->SrcDir = PoolMemDuplicateString (g_TextPool, srcDir);
                    renamedDir->DestDir = PoolMemDuplicateString (g_TextPool, destDir);
                    renamedDir->Next = g_RenamedDirs;
                    g_RenamedDirs = renamedDir;
                }
            }
        } while (InfFindNextLine (&context));
    }
    InfCleanUpInfStruct (&context);
    return TRUE;
}

BOOL
pLoadRenamedDirs (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    StringCopy (sectTmp, TEXT("FILELIST.RENAMEDIRS"));
    pLoadRenamedDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadRenamedDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadRenamedDirsFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.RENAMEDIRS"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadRenamedDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadRenamedDirsFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}

BOOL
pLoadHeaderFilesFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    PCSTR filePattern;
    PHEADER_FILES headerFile;

    if (InfFindFirstLine (infHandle, SectName, NULL, &context)) {
        do {
            filePattern = pGetNonEmptyField (&context, 1);
            if (filePattern) {
                headerFile = (PHEADER_FILES) PoolMemGetMemory (g_TextPool, sizeof (HEADER_FILES));
                if (headerFile) {
                    headerFile->FilePattern = PoolMemDuplicateString (g_TextPool, filePattern);
                    if (!InfGetIntField (&context, 2, &(headerFile->Priority))) {
                        headerFile->Priority = 0xFFFFFFFF;
                    }
                    headerFile->Next = g_HeaderFiles;
                    g_HeaderFiles = headerFile;
                }
            }
        } while (InfFindNextLine (&context));
    }
    InfCleanUpInfStruct (&context);
    return TRUE;
}

BOOL
pLoadHeaderFiles (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    StringCopy (sectTmp, TEXT("FILELIST.HEADERFILES"));
    pLoadHeaderFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadHeaderFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadHeaderFilesFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.HEADERFILES"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadHeaderFilesFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadHeaderFilesFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}

BOOL
pLoadExcludedInfsFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR InfFile, CopySect;
    PEXCLUDED_INF_FILES excludedInfFile;
    HASHITEM findIndex;

    if (InfFindFirstLine (infHandle, SectName, NULL, &is)) {
        do {
            InfFile = pGetNonEmptyField (&is, 1);
            CopySect = pGetNonEmptyField (&is, 2);
            if (InfFile) {
                if (CopySect) {
                    excludedInfFile = (PEXCLUDED_INF_FILES) PoolMemGetMemory (g_TextPool, sizeof (EXCLUDED_INF_FILES));
                    excludedInfFile->InfName = PoolMemDuplicateString (g_TextPool, InfFile);
                    excludedInfFile->CopySectName = PoolMemDuplicateString (g_TextPool, CopySect);
                    findIndex = HtFindStringAndData (g_ExcludedInfsTable, InfFile, &(excludedInfFile->Next));
                    if (findIndex) {
                        HtSetStringData (g_ExcludedInfsTable, findIndex, &excludedInfFile);
                    } else {
                        excludedInfFile->Next = NULL;
                        HtAddStringAndData (g_ExcludedInfsTable, InfFile, &excludedInfFile);
                    }
                } else {
                    // the whole INF file is excluded
                    findIndex = HtFindStringAndData (g_ExcludedInfsTable, InfFile, &excludedInfFile);
                    if (findIndex) {
                        excludedInfFile = NULL;
                        HtSetStringData (g_ExcludedInfsTable, findIndex, &excludedInfFile);
                    } else {
                        excludedInfFile = NULL;
                        HtAddStringAndData (g_ExcludedInfsTable, InfFile, &excludedInfFile);
                    }
                }
            }
            InfResetInfStruct (&is);
        } while (InfFindNextLine (&is));
    }
    InfCleanUpInfStruct (&is);
    return TRUE;
}

BOOL
pCreateExcludedInfsTable (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    g_ExcludedInfsTable = HtAllocWithData (sizeof (PCTSTR));

    StringCopy (sectTmp, TEXT("FILELIST.EXCLUDEINF"));
    pLoadExcludedInfsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadExcludedInfsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadExcludedInfsFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.EXCLUDEINF"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadExcludedInfsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadExcludedInfsFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}

BOOL
pLoadPrivateIdInfsFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR InfFile, PrivateId, EquivalentId;
    PPRIVATE_ID_INFS privateIdInfFile;
    HASHITEM findIndex;

    if (InfFindFirstLine (infHandle, SectName, NULL, &is)) {
        do {
            InfFile = pGetNonEmptyField (&is, 1);
            PrivateId = pGetNonEmptyField (&is, 2);
            EquivalentId = pGetNonEmptyField (&is, 3);

            if (InfFile && PrivateId && EquivalentId) {
                privateIdInfFile = (PPRIVATE_ID_INFS) PoolMemGetMemory (g_TextPool, sizeof (PRIVATE_ID_INFS));
                privateIdInfFile->PrivateId = PoolMemDuplicateString (g_TextPool, PrivateId);
                privateIdInfFile->EquivalentId = PoolMemDuplicateString (g_TextPool, EquivalentId);
                findIndex = HtFindStringAndData (g_PrivateIdInfsTable, InfFile, &(privateIdInfFile->Next));
                if (findIndex) {
                    HtSetStringData (g_PrivateIdInfsTable, findIndex, &privateIdInfFile);
                } else {
                    privateIdInfFile->Next = NULL;
                    HtAddStringAndData (g_PrivateIdInfsTable, InfFile, &privateIdInfFile);
                }
            }
            InfResetInfStruct (&is);
        } while (InfFindNextLine (&is));
    }
    InfCleanUpInfStruct (&is);
    return TRUE;
}

BOOL
pCreatePrivateIdInfsTable (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    g_PrivateIdInfsTable = HtAllocWithData (sizeof (PCTSTR));

    StringCopy (sectTmp, TEXT("FILELIST.PRIVATEIDDIR"));
    pLoadPrivateIdInfsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadPrivateIdInfsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadPrivateIdInfsFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.PRIVATEIDDIR"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadPrivateIdInfsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadPrivateIdInfsFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}

BOOL
pLoadExcludedDirsFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR DirId;

    if (InfFindFirstLine (infHandle, SectName, NULL, &is)) {
        do {
            DirId = pGetNonEmptyField (&is, 1);
            if (DirId) {
                HtAddString (g_ExcludedDirsTable, DirId);
            }
            InfResetInfStruct (&is);
        } while (InfFindNextLine (&is));
    }
    InfCleanUpInfStruct (&is);
    return TRUE;
}

BOOL
pLoadExcludedDirs (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    g_ExcludedDirsTable = HtAlloc ();

    StringCopy (sectTmp, TEXT("FILELIST.EXCLUDEDIR"));
    pLoadExcludedDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadExcludedDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadExcludedDirsFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.EXCLUDEDIR"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadExcludedDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadExcludedDirsFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}

BOOL
pLoadIgnoredDirsFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR DirId;

    if (InfFindFirstLine (infHandle, SectName, NULL, &is)) {
        do {
            DirId = pGetNonEmptyField (&is, 1);
            if (DirId) {
                HtAddString (g_IgnoredDirsTable, DirId);
            }
            InfResetInfStruct (&is);
        } while (InfFindNextLine (&is));
    }
    InfCleanUpInfStruct (&is);
    return TRUE;
}

BOOL
pLoadIgnoredDirs (
    IN      HINF infHandle
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    g_IgnoredDirsTable = HtAlloc ();

    StringCopy (sectTmp, TEXT("FILELIST.IGNOREDIR"));
    pLoadIgnoredDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadIgnoredDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadIgnoredDirsFromSect (infHandle, sectTmp);

    StringCopy (sectTmp, TEXT("FILELIST.IGNOREDIR"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadIgnoredDirsFromSect (infHandle, sectTmp);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadIgnoredDirsFromSect (infHandle, sectTmp);

    FreeText (sectTmp);

    return TRUE;
}


BOOL
pLoadKnownFilesFromSect (
    IN      HINF infHandle,
    IN      PCSTR SectName,
    IN      BOOL CountPriority
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR SrcName;
    PCTSTR DestName;
    PCTSTR InfName;
    PCTSTR DirName;
    UINT Priority;
    DWORD offset;
    PTSTR key;

    key = AllocText (MEMDB_MAX);
    if (!key) {
        return FALSE;
    }

    if (InfFindFirstLine (infHandle, SectName, NULL, &is)) {
        do {
            DestName = pGetNonEmptyField (&is, 1);
            SrcName = pGetNonEmptyField (&is, 2);
            InfName = pGetNonEmptyField (&is, 3);
            DirName = pGetNonEmptyField (&is, 4);
            if (!InfGetIntField (&is, 5, &Priority)) {
                Priority = 0xFFFFFFFF;
            }
            if (DestName && DirName) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_NT_DIRS,
                    DirName,
                    NULL,
                    NULL,
                    0,
                    &offset
                    );
                if (CountPriority) {
                    _stprintf (key, TEXT("%s\\%07ud\\%s\\%s\\%s"), MEMDB_CATEGORY_NT_KNOWN_FILES, Priority, DestName, SrcName, InfName);
                } else {
                    _stprintf (key, TEXT("%s\\%s\\%s\\%s"), MEMDB_CATEGORY_NT_KNOWN_FILES, DestName, SrcName, InfName);
                }
                MemDbSetValue (key, offset);

                MemDbBuildKey (key, MEMDB_CATEGORY_KNOWN_FILE_NAMES, SrcName, NULL, NULL);
                MemDbSetValue (key, offset);
            }
            InfResetInfStruct (&is);
        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
    FreeText (key);

    return TRUE;
}


BOOL
pIsKnownFile (
    IN      PCTSTR DestDir,
    IN      PCTSTR DestFile
    )
{
    TCHAR testKey[MEMDB_MAX];
    DWORD storedOffset;
    DWORD dirOffset;

    MemDbSetValueEx (
        MEMDB_CATEGORY_NT_DIRS,
        DestDir,
        NULL,
        NULL,
        0,
        &dirOffset
        );

    MemDbBuildKey (testKey, MEMDB_CATEGORY_KNOWN_FILE_NAMES, DestFile, NULL, NULL);
    if (!MemDbGetValue (testKey, &storedOffset)) {
        return FALSE;
    }

    return storedOffset != dirOffset;
}


BOOL
pLoadKnownFiles (
    IN      HINF InfHandle,
    IN      BOOL CountPriority
    )
{
    PTSTR sectTmp;

    sectTmp = AllocText (256);
    if (!sectTmp) {
        return FALSE;
    }

    MemDbDeleteTree (MEMDB_CATEGORY_NT_KNOWN_FILES);

    StringCopy (sectTmp, TEXT("FILELIST.KNOWNFILES"));
    pLoadKnownFilesFromSect (InfHandle, sectTmp, CountPriority);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadKnownFilesFromSect (InfHandle, sectTmp, CountPriority);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadKnownFilesFromSect (InfHandle, sectTmp, CountPriority);

    StringCopy (sectTmp, TEXT("FILELIST.KNOWNFILES"));
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Product);
    pLoadKnownFilesFromSect (InfHandle, sectTmp, CountPriority);
    StringCat (sectTmp, TEXT("."));
    StringCat (sectTmp, g_Platform);
    pLoadKnownFilesFromSect (InfHandle, sectTmp, CountPriority);

    FreeText (sectTmp);

    return TRUE;
}


VOID
pPrintWarningGroupPart (
    IN      HANDLE FileHandle,
    IN      PCSTR Title,
    IN      PCSTR MemDbPattern,
    IN      INT Type,
    IN      BOOL LastPartOfGroup,
    IN OUT  PBOOL OneItem               OPTIONAL
    )
{
    MEMDB_ENUM enumFiles;
    MEMDB_ENUM enumSubFiles;
    PSTR outptr;
    PSTR output;
    BOOL dummy = FALSE;
    PTSTR outputStr;
    PTSTR key;

    __try {

        outputStr = AllocText (MEMDB_MAX);
        key = AllocText (MEMDB_MAX);

        if (!key || !outputStr) {
            __leave;
        }

        if (!OneItem) {
            OneItem = &dummy;
        }

        if (MemDbEnumFirstValue (
                &enumFiles,
                MemDbPattern,
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {

            if (*OneItem == FALSE) {
                WriteFileString (FileHandle, Title);
            }

            do {
                switch (Type) {

                case 0:
                    WriteFileString (FileHandle, enumFiles.szName);
                    WriteFileString (FileHandle, "\r\n");
                    break;

                case 1:
                    output = DuplicatePathString (enumFiles.szName, 0);
                    outptr = _mbschr (output, '\\');
                    if (outptr) {
                        *outptr = '=';
                    }
                    WriteFileString (FileHandle, output);
                    WriteFileString (FileHandle, "\r\n");
                    FreePathString (output);
                    break;

                case 2:
                    output = DuplicatePathString (enumFiles.szName, 0);
                    outptr = _mbschr (output, '\\');
                    if (outptr) {
                        *outptr = '=';
                    }
                    outptr = _mbschr (outptr, '\\');
                    if (outptr) {
                        *outptr = ',';
                    }

                    WriteFileString (FileHandle, output);
                    WriteFileString (FileHandle, "\r\n");
                    FreePathString (output);
                    break;

                case 3:
                    WriteFileString (FileHandle, enumFiles.szName);
                    WriteFileString (FileHandle, "=");

                    MemDbBuildKeyFromOffset (enumFiles.dwValue, outputStr, 1, NULL);

                    outptr = _mbschr (outputStr, '\\');
                    if (outptr) {
                        *outptr = ',';
                    }

                    if (Type == 4) {
                        outptr = _mbschr (outptr, '\\');
                        if (outptr) {
                            *outptr = ',';
                        }
                    }

                    WriteFileString (FileHandle, outputStr);
                    WriteFileString (FileHandle, "\r\n");
                    break;

                case 4:
                case 5:
                    if (Type == 4) {
                        MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_DOUBLED_COPY, enumFiles.szName, TEXT("*"), NULL);
                    } else {
                        MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_DOUBLED_DEL, enumFiles.szName, TEXT("*"), NULL);
                    }

                    if (MemDbEnumFirstValue (
                            &enumSubFiles,
                            key,
                            MEMDB_ALL_SUBLEVELS,
                            MEMDB_ENDPOINTS_ONLY
                            )) {
                        do {
                            WriteFileString (FileHandle, enumFiles.szName);
                            WriteFileString (FileHandle, "=");

                            output = DuplicatePathString (enumSubFiles.szName, 0);
                            outptr = _mbschr (output, '\\');
                            if (outptr) {
                                *outptr = ',';
                            }
                            WriteFileString (FileHandle, output);
                            WriteFileString (FileHandle, "\r\n");
                            FreePathString (output);
                        } while (MemDbEnumNextValue (&enumSubFiles));
                    }
                    break;
                }

            } while (MemDbEnumNextValue (&enumFiles));

            *OneItem = TRUE;
        }

        if (LastPartOfGroup) {
            if (*OneItem) {
                WriteFileString (FileHandle, "\r\n\r\n");
            }

            *OneItem = FALSE;
        }
    }
    __finally {
        FreeText (outputStr);
        FreeText (key);
    }
}


VOID
pPrintWarnings (
    VOID
    )
{
    HANDLE fileHandle;
    MEMDB_ENUM enumFiles,enumFiles1;
    DWORD dontCare;
    PSTR output;
    PSTR outptr;
    PSTR outputStr;
    PSTR key;
    BOOL matchFound;

    __try {
        outputStr = AllocText (MEMDB_MAX);
        key = AllocText (MEMDB_MAX);

        if (!key || !outputStr) {
            __leave;
        }

        fileHandle = CreateFile (g_WarnFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        matchFound = FALSE;
        pPrintWarningGroupPart (
            fileHandle,
            "Files with no directory information in LAYOUT.INF and INTL.INF:\r\n\r\n",
            MEMDB_CATEGORY_NT_FILES_NODIR_COPY "\\*",
            0,
            FALSE,
            &matchFound
            );
        pPrintWarningGroupPart (
            fileHandle,
            "Files with no directory information in LAYOUT.INF and INTL.INF:\r\n\r\n",
            MEMDB_CATEGORY_NT_FILES_NODIR_DEL "\\*",
            0,
            TRUE,
            &matchFound
            );

        pPrintWarningGroupPart (
            fileHandle,
            "INF files with section having no directory information:\r\n"
                "(<INF file>=<copy section>)\r\n\r\n",
            MEMDB_CATEGORY_NT_SECT_NODIR "\\*",
            1,
            TRUE,
            NULL
            );

        pPrintWarningGroupPart (
            fileHandle,
            "INF files with section having unknown directory ID:\r\n"
                "(<INF file>=<copy section>,<dir ID>)\r\n\r\n",
            MEMDB_CATEGORY_NT_SECT_BADDIR "\\*",
            2,
            TRUE,
            NULL
            );

        pPrintWarningGroupPart (
            fileHandle,
            "INF files with files having no source layout information:\r\n"
                "(<INF file>=<section>,<file>)\r\n\r\n",
            MEMDB_CATEGORY_NT_FILES_NO_LAYOUT "\\*",
            2,
            TRUE,
            NULL
            );

        pPrintWarningGroupPart (
            fileHandle,
            "Files within copy sections with bad or non-existent dir ID:\r\n"
                "(<file>=<INF file>,<section>[,<dir ID>])\r\n\r\n",
            MEMDB_CATEGORY_NT_FILES_NODIR_OTHER_COPY "\\*",
            3,
            FALSE,
            &matchFound
            );

        pPrintWarningGroupPart (
            fileHandle,
            "Files within copy sections with bad or non-existent dir ID:\r\n"
                "(<file>=<INF file>,<section>[,<dir ID>])\r\n\r\n",
            MEMDB_CATEGORY_NT_FILES_NODIR_OTHER_DEL "\\*",
            3,
            TRUE,
            &matchFound
            );

        pPrintWarningGroupPart (
            fileHandle,
            "Duplicate files:\r\n"
                "(<dest file>=<INF file>,<dir ID>)\r\n\r\n",
            MEMDB_CATEGORY_NT_FILES_DOUBLED_IDX_COPY "\\*",
            4,
            FALSE,
            &matchFound
            );

        pPrintWarningGroupPart (
            fileHandle,
            "Duplicate files:\r\n"
                "(<dest file>=<INF file>,<dir ID>)\r\n\r\n",
            MEMDB_CATEGORY_NT_FILES_DOUBLED_IDX_DEL "\\*",
            5,
            TRUE,
            &matchFound
            );

        CloseHandle (fileHandle);
    }
    __finally {
        FreeText (outputStr);
        FreeText (key);
    }
}

BOOL
pIsHeaderFile (
    IN      PCTSTR FileName,
    OUT     PUINT Priority
    )
{
    PHEADER_FILES headerFile;
    UINT priority = 0xFFFFFFFF;
    BOOL result = FALSE;

    headerFile = g_HeaderFiles;
    while (headerFile) {
        if (IsPatternMatch (headerFile->FilePattern, FileName)) {
            if (priority > headerFile->Priority) {
                priority = headerFile->Priority;
            }
            result = TRUE;
        }
        headerFile = headerFile->Next;
    }
    if (result && Priority) {
        *Priority = priority;
    }
    return result;
}

VOID
pBuildHeaderFilesCategory (
    VOID
    )
{
    MEMDB_ENUM enumFiles;
    PSTR key;
    PSTR dirName;
    PSTR priorStr;
    PSTR filePtr1 = NULL, filePtr2=NULL;
    PSTR destName;
    PSTR srcName;
    PCSTR infName = NULL;
    UINT Priority;
    INT ExcludeType;

    __try {

        key = AllocText (MEMDB_MAX);
        dirName = AllocText (MEMDB_MAX);
        priorStr = AllocText (MEMDB_MAX);
        destName = AllocText (MEMDB_MAX);
        srcName = AllocText (MEMDB_MAX);

        if (!key || !dirName || !priorStr || !destName || !srcName) {
            __leave;
        }

        MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, TEXT("*"), NULL, NULL);

        if (MemDbEnumFirstValue (
                &enumFiles,
                key,
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {
            do {
                MemDbBuildKeyFromOffset (enumFiles.dwValue, key, 1, NULL);

                filePtr1 = enumFiles.szName;

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (destName, filePtr1, filePtr2);

                filePtr1 = _mbsinc (filePtr2);

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (srcName, filePtr1, filePtr2);

                infName = _mbsinc (filePtr2);

                pFixDir (key, dirName);

                ExcludeType = pIsExcludedFile (destName);
                if ((ExcludeType == -1) || (ExcludeType == 1)) {

                    if (!pIsExcludedDir (key)) {

                        if (pIsHeaderFile (destName, &Priority)) {

                            _stprintf (
                                key,
                                TEXT("%s\\%07ud\\%s\\%s\\%s\\%s"),
                                MEMDB_CATEGORY_NT_HEADER_FILES,
                                Priority,
                                destName,
                                srcName,
                                infName,
                                dirName
                                );
                            MemDbSetValue (key, 0);
                        }
                    }
                }
                _stprintf (
                    key,
                    TEXT("%s\\%s\\%s"),
                    MEMDB_CATEGORY_NT_CHECK_FILES,
                    srcName,
                    destName
                    );
                MemDbSetValue (key, 0);
            } while (MemDbEnumNextValue (&enumFiles));
        }

        MemDbBuildKey (key, MEMDB_CATEGORY_NT_KNOWN_FILES, TEXT("*"), NULL, NULL);

        if (MemDbEnumFirstValue (
                &enumFiles,
                key,
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {
            do {
                MemDbBuildKeyFromOffset (enumFiles.dwValue, key, 1, NULL);

                filePtr1 = enumFiles.szName;

                //let's skip priority number

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (priorStr, filePtr1, filePtr2);

                filePtr1 = _mbsinc (filePtr2);

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (destName, filePtr1, filePtr2);

                filePtr1 = _mbsinc (filePtr2);

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (srcName, filePtr1, filePtr2);

                infName = _mbsinc (filePtr2);

                pFixDir (key, dirName);

                _stprintf (
                    key,
                    TEXT("%s\\%s\\%s\\%s\\%s\\%s"),
                    MEMDB_CATEGORY_NT_HEADER_FILES,
                    priorStr,
                    destName,
                    srcName,
                    infName,
                    dirName
                    );
                MemDbSetValue (key, 0);
                _stprintf (
                    key,
                    TEXT("%s\\%s