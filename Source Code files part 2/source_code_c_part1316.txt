D        hDlg,
    PGlobals    pGlobals)
{
    PWSTR   pszUsername;
    PWSTR   pszDomain;
    PWSTR   pszOld;
    PWSTR   pszNew;
    PWSTR   pszTemp;

    NET_API_STATUS  NetStatus;

    if (!NetUserChangePasswordFn)
    {
        if (!LoadNetapi(hDlg))
        {
            return(FALSE);
        }
    }

    pszUsername = AllocAndCaptureText(hDlg, IDD_USER_NAME);
    pszDomain = AllocAndCaptureText(hDlg, IDD_DOMAIN);
    pszOld = AllocAndCaptureText(hDlg, IDD_OLD_PASSWORD);
    pszNew = AllocAndCaptureText(hDlg, IDD_NEW_PASSWORD);

    if (!pszUsername || !pszDomain || !pszOld || !pszNew)
    {
        goto clean_exit;
    }

    pszTemp = AllocAndCaptureText(hDlg, IDD_CONFIRM_PASSWORD);
    if (wcscmp(pszNew, pszTemp))
    {
        LocalFree(pszTemp);
        MessageBox(hDlg, TEXT("Your passwords did not match."), TEXT("Change Password"),
                        MB_ICONSTOP | MB_OK);
        goto clean_exit;
    }

    NetStatus = NetUserChangePasswordFn(pszDomain, pszUsername, pszOld, pszNew);
    if (NetStatus != NERR_Success)
    {
        SetLastError(NetStatus);
        ErrorMessage(hDlg, TEXT("Change Password"), MB_ICONSTOP | MB_OK);
    }
    else
        MessageBox(hDlg, TEXT("Your password was changed successfully"),
                    TEXT("Change Password"), MB_ICONINFORMATION | MB_OK);

clean_exit:
    if (pszUsername)
    {
        LocalFree(pszUsername);
    }
    if (pszDomain)
    {
        LocalFree(pszDomain);
    }
    if (pszOld)
    {
        LocalFree(pszOld);
    }
    if (pszNew)
    {
        LocalFree(pszNew);
    }

    return(NetStatus == NERR_Success);
}

int
CALLBACK
ChangePasswordDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            CenterWindow(hDlg);
            SetWindowLong(hDlg, GWL_USERDATA, lParam);
            return(TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (TryToChangePassword(hDlg, pGlobals))
                {
                    SetWindowText(GetDlgItem(hDlg, IDCANCEL), TEXT("Done"));
                }
                SetDlgItemText(hDlg, IDD_OLD_PASSWORD, TEXT(""));
                SetDlgItemText(hDlg, IDD_NEW_PASSWORD, TEXT(""));
                SetDlgItemText(hDlg, IDD_CONFIRM_PASSWORD, TEXT(""));
                SetFocus(GetDlgItem(hDlg, IDD_OLD_PASSWORD));

                return(TRUE);
            }
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, 0);
                return(TRUE);
            }

    }
    return(FALSE);
}



int
CALLBACK
ConfigDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            pGlobals = (PGlobals) lParam;

            CenterWindow(hDlg);
            SetWindowLong(hDlg, GWL_USERDATA, lParam);

            CheckDlgButton(hDlg, IDD_NO_NEW_USERS, !pGlobals->fAllowNewUser);

            CheckDlgButton(hDlg, IDD_AUTO_LOGON,
                    (pGlobals->pAccount->Flags & MINI_AUTO_LOGON) ? 1 : 0 );

            return(TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    pGlobals->fAllowNewUser = !IsDlgButtonChecked(hDlg, IDD_NO_NEW_USERS);
                    if (IsDlgButtonChecked(hDlg, IDD_AUTO_LOGON))
                    {
                        pGlobals->pAccount->Flags |= MINI_AUTO_LOGON;
                    }
                    else
                    {
                        pGlobals->pAccount->Flags &= ~MINI_AUTO_LOGON;
                    }
                    EndDialog(hDlg, IDOK);
                    return(TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return(TRUE);

            }
    }

    return(FALSE);

}

int
InitOptionsDialog(
    HWND        hDlg,
    LPARAM      lParam)
{
    CenterWindow(hDlg);
    SetWindowLong(hDlg, GWL_USERDATA, lParam);

    return(1);
}



int
CALLBACK
OptionsDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;
    int         result;


    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);

    switch (Message)
    {
        case WM_INITDIALOG:
            return InitOptionsDialog(hDlg, lParam);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hDlg, WLX_SAS_ACTION_NONE);
                    return(TRUE);

                case IDD_LOCK_BUTTON:
                    EndDialog(hDlg, WLX_SAS_ACTION_LOCK_WKSTA);
                    return(TRUE);

                case IDD_TASK_BUTTON:
                    EndDialog(hDlg, WLX_SAS_ACTION_TASKLIST);
                    return(TRUE);

                case IDD_OPTIONS_EXIT:
                    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                                        hDllInstance,
                                                        (LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN),
                                                        hDlg,
                                                        ShutdownDlgProc,
                                                        (LONG) pGlobals);
                    if (result != WLX_SAS_ACTION_NONE)
                    {
                        EndDialog(hDlg, result);
                    }
                    return(TRUE);

                case IDD_PASSWORD_BUTTON:
                    pWlxFuncs->WlxDialogBoxParam(   hGlobalWlx,
                                                    hDllInstance,
                                                    (LPTSTR) MAKEINTRESOURCE(IDD_CHANGE_PASSWORD),
                                                    hDlg,
                                                    ChangePasswordDlgProc,
                                                    (LONG) pGlobals);
                    return(TRUE);

                case IDD_CONFIG_BUTTON:
                    pWlxFuncs->WlxDialogBoxParam(   hGlobalWlx,
                                                    hDllInstance,
                                                    (LPTSTR) MAKEINTRESOURCE(IDD_LOGON_CONFIG),
                                                    hDlg,
                                                    ConfigDlgProc,
                                                    (LONG) pGlobals);
                    return(TRUE);

            }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\structs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       structs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


typedef struct _MiniAccount {
    struct _MiniAccount *   pNext;
    PWSTR                   pszUsername;
    PWSTR                   pszDomain;
    PWSTR                   pszPassword;
    PWSTR                   pszComment;
    DWORD                   IconId;
    DWORD                   Flags;
} MiniAccount, * PMiniAccount;

typedef struct _SerializedMiniAccount {
    DWORD                   Version;
    DWORD                   dwDomainOffset;
    DWORD                   dwDomainLength;
    DWORD                   dwPasswordOffset;
    DWORD                   dwPasswordLength;
    DWORD                   dwCommentOffset;
    DWORD                   dwCommentLength;
    DWORD                   Flags;
    DWORD                   IconId;
} SerializedMiniAccount, * PSerializedMiniAccount;

#define MINI_VERSION            0

#define MINI_PASSWORD_REQUIRED  0x00000001
#define MINI_PASSWORD_ALWAYS    0x00000002
#define MINI_NEW_ACCOUNT        0x00000004
#define MINI_CAN_EDIT           0x00000008
#define MINI_AUTO_LOGON         0x00000010
#define MINI_SAVE               0x00000020


typedef struct _Globals {
    BOOL                    fAllowNewUser;
    BOOL                    fAutoLogonAtBoot;
    BOOL                    fAutoLogonAlways;
    HANDLE                  hUserToken;
    PMiniAccount            pAccount;
} Globals, * PGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\welcome.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       welcome.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"


int
CALLBACK
WelcomeDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (Message)
    {
        case WM_INITDIALOG:
            CenterWindow(hDlg);
            return(TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                pWlxFuncs->WlxSasNotify(hGlobalWlx, GINA_SAS_1);
            }
            return(TRUE);

        default:
            return(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\shutdown.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       shutdown.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-28-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

WCHAR   szShutdownSettingPath[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Shutdown");
int
ShutdownDialogInit(
    HWND        hDlg,
    LPARAM      lParam)
{
    PGlobals    pGlobals;
    HKEY        hKey;
    DWORD       dwValue;
    DWORD       dwSize;
    DWORD       dwType;
    DWORD       PowerOff;

    pGlobals = (PGlobals) lParam;

    SetWindowLong(hDlg, GWL_USERDATA, lParam);

    PowerOff = GetProfileInt(TEXT("Winlogon"), TEXT("PowerDownAfterShutdown"), 0);

    if (pGlobals->hUserToken)
    {
        if (ImpersonateLoggedOnUser(pGlobals->hUserToken))
        {

            dwValue = 0;

            if (!RegOpenKey(HKEY_CURRENT_USER,
                            szShutdownSettingPath,
                            &hKey))
            {
                dwSize = sizeof(DWORD);
                RegQueryValueEx(hKey, TEXT("Shutdown Setting"), 0, &dwType, (PBYTE) &dwValue, &dwSize);
                RegCloseKey(hKey);
            }

            RevertToSelf();
        }
    }

    if (!PowerOff)
    {
        ShowWindow(GetDlgItem(hDlg, IDD_CONFIRM_POWEROFF), SW_HIDE);
    }

    if (!pGlobals->hUserToken)
    {
        ShowWindow(GetDlgItem(hDlg, IDD_CONFIRM_LOGOFF), SW_HIDE);
    }

    switch (dwValue)
    {
        case 0:
            if (pGlobals->hUserToken)
            {
                CheckDlgButton(hDlg, IDD_CONFIRM_LOGOFF, 1);
                SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_LOGOFF));
                break;
            }

        case 2:
            CheckDlgButton(hDlg, IDD_CONFIRM_REBOOT, 1);
                SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_REBOOT));
            break;
        case 3:
            if (PowerOff)
            {
                CheckDlgButton(hDlg, IDD_CONFIRM_POWEROFF, 1);
                SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_POWEROFF));
                break;
            }
        default:
            CheckDlgButton(hDlg, IDD_CONFIRM_SHUTDOWN, 1);
            SetFocus(GetDlgItem(hDlg, IDD_CONFIRM_SHUTDOWN));

    }

    CenterWindow(hDlg);

    SetFocus(GetDlgItem(hDlg, IDOK));

    return(1);

}

VOID
UpdateShutdownSettings(
            PGlobals    pGlobals,
            DWORD       Setting)
{
    // int err;
    HKEY    hKey;
    DWORD   Actual;

    switch (Setting)
    {
        default:
        case IDD_CONFIRM_LOGOFF:
            Actual = 0;
            break;

        case IDD_CONFIRM_SHUTDOWN:
            Actual = 1;
            break;

        case IDD_CONFIRM_REBOOT:
            Actual = 2;
            break;

        case IDD_CONFIRM_POWEROFF:
            Actual = 3;
            break;
    }


    if (pGlobals->hUserToken)
    {
        if (ImpersonateLoggedOnUser(pGlobals->hUserToken))
        {

            if (!RegOpenKey(HKEY_CURRENT_USER,
                            szShutdownSettingPath,
                            &hKey))
            {
                RegSetValueEx(  hKey,
                                TEXT("Shutdown Setting"),
                                0,
                                REG_DWORD,
                                (PBYTE) &Actual,
                                sizeof(DWORD) );
                RegCloseKey(hKey);
            }

            RevertToSelf();
        }
    }

}

int
CALLBACK
ShutdownDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PGlobals    pGlobals;

    switch (Message)
    {
        case WM_INITDIALOG:
            return(ShutdownDialogInit(hDlg, lParam));

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, WLX_SAS_ACTION_NONE);
            }
            if (LOWORD(wParam) == IDOK)
            {
                pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);

                if (IsDlgButtonChecked(hDlg, IDD_CONFIRM_LOGOFF))
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_LOGOFF);
                    EndDialog(hDlg, WLX_SAS_ACTION_LOGOFF);
                }
                else if (IsDlgButtonChecked(hDlg, IDD_CONFIRM_REBOOT))
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_REBOOT);
                    EndDialog(hDlg, WLX_SAS_ACTION_SHUTDOWN_REBOOT);
                }
                else if (IsDlgButtonChecked(hDlg, IDD_CONFIRM_POWEROFF))
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_POWEROFF);
                    EndDialog(hDlg, WLX_SAS_ACTION_SHUTDOWN_POWER_OFF);
                }
                else
                {
                    UpdateShutdownSettings(pGlobals, IDD_CONFIRM_SHUTDOWN);
                    EndDialog(hDlg, WLX_SAS_ACTION_SHUTDOWN);
                }

            }
            return(TRUE);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\util.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       util.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

HMODULE hNetMsg = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   CenterWindow
//
//  Synopsis:   Centers a window
//
//  Arguments:  [hwnd] --
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
CenterWindow(
    HWND    hwnd
    )
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    // Get window rect
    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    // Get parent rect
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        // Return the desktop windows size (size of main screen)
        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    // Centre the child in the parent
    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;

    // Move the child into position
    SetWindowPos(hwnd, HWND_TOPMOST, rect.left, rect.top, 0, 0, SWP_NOSIZE);

    SetForegroundWindow(hwnd);
}


int
ErrorMessage(
    HWND        hWnd,
    PWSTR       pszTitleBar,
    DWORD       Buttons)
{
    WCHAR   szMessage[256];
    DWORD   GLE;

    GLE = GetLastError();

    if (GLE >= NERR_BASE)
    {
        if (!hNetMsg)
        {
            hNetMsg = LoadLibrary(TEXT("netmsg.dll"));
        }
        FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
            hNetMsg,                               // ignored
            GLE,                                  // message id
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),   // message language
            szMessage,                  // address of buffer pointer
            199,                                  // minimum buffer size
            NULL );                              // no other arguments

    }

    FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,                               // ignored
            (GetLastError()),                     // message id
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),   // message language
            szMessage,                  // address of buffer pointer
            199,                                  // minimum buffer size
            NULL );                              // no other arguments

    return(MessageBox(hWnd, szMessage, pszTitleBar, Buttons));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#if DBG

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);

#else

#define DebugMsg(x)


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gpext\gpext.c ===
#include <windows.h>
#include <userenv.h>

//
//  Some helpful tips about group policy extensions
//
//  1)  You will be called in the LocalSystem's context
//      If you need to access the net, you'll need to impersonate
//      the user via the hToken passed in.
//
//



#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{febf1208-8aff-11d2-a8a1-00c04fbbcfa2}")
#define GPEXT_NAME   TEXT("Group Policy client side extension sample")



BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
            DisableThreadLibraryCalls (hInstance);
            }
            break;
    }

    return TRUE;
}


DWORD ProcessGroupPolicy ( DWORD   dwFlags,
                           HANDLE  hToken,
                           HKEY    hKeyRoot,
                           PGROUP_POLICY_OBJECT   pDeletedGPOList,
                           PGROUP_POLICY_OBJECT   pChangedGPOList,
                           ASYNCCOMPLETIONHANDLE  pHandle,
                           BOOL*   pbAbort,
                           PFNSTATUSMESSAGECALLBACK pStatusCallback )
{
    PGROUP_POLICY_OBJECT pCurGPO;

    if (dwFlags & GPO_INFO_FLAG_MACHINE)
        OutputDebugString (TEXT("GPEXT:  Machine GPO\r\n"));

    if (dwFlags & GPO_INFO_FLAG_BACKGROUND)
        OutputDebugString (TEXT("GPEXT:  Background processing of GPO\r\n"));

    if (dwFlags & GPO_INFO_FLAG_SLOWLINK)
        OutputDebugString (TEXT("GPEXT:  Policy is being applied across a slow link.\r\n"));

    if (dwFlags & GPO_INFO_FLAG_VERBOSE)
        OutputDebugString (TEXT("GPEXT:  Verbose policy logging is requested (to the eventlog).\r\n"));

    if (dwFlags & GPO_INFO_FLAG_NOCHANGES)
        OutputDebugString (TEXT("GPEXT:  No changes where detected in this series of GPOs.  Policy should be refreshed as quickly as possible.\r\n"));

    if (dwFlags & GPO_INFO_FLAG_LINKTRANSITION)
        OutputDebugString (TEXT("GPEXT:  Link speed transition (either slow to fast or fast to slow)\r\n"));

    //
    // Process list of deleted GPOs
    //

    OutputDebugString (TEXT("GPEXT:  Processing deleted GPO list\n"));

    for (pCurGPO = pDeletedGPOList; pCurGPO; pCurGPO = pCurGPO->pNext)
    {
        if ( *pbAbort )
        {
            OutputDebugString (TEXT("GPEXT:  Aborting further processing\n"));
            break;
        }

        OutputDebugString (pCurGPO->lpDisplayName);
        OutputDebugString (TEXT(" aka "));
        OutputDebugString (pCurGPO->szGPOName);
        OutputDebugString (TEXT(".\r\n"));
    }

    //
    // Process list of changed GPOs
    //

    OutputDebugString (TEXT("GPEXT:  Processing changed GPO list\n"));

    for (pCurGPO = pChangedGPOList; pCurGPO; pCurGPO = pCurGPO->pNext)
    {
        if ( *pbAbort )
        {
            OutputDebugString (TEXT("GPEXT:  Aborting further processing\n"));
            break;
        }

        OutputDebugString (pCurGPO->lpDisplayName);
        OutputDebugString (TEXT(" aka "));
        OutputDebugString (pCurGPO->szGPOName);
        OutputDebugString (TEXT(".\r\n"));
    }

    return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, GPEXT_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)GPEXT_NAME,
                   (lstrlen(GPEXT_NAME) + 1) * sizeof(TCHAR));


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicy"),
                   (lstrlen(TEXT("ProcessGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("gpext.dll"),
                   (lstrlen(TEXT("gpext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 1;
    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gpext2\gpext.c ===
#include <windows.h>
#include <userenv.h>
#include "events.h"

//
//  This is a simple client side extension that reads its return value from the
//  registry and exits.  The registry value it reads is controlled via the gpext.adm
//  file in this directory.
//



#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{febf1209-8aff-11d2-a8a1-00c04fbbcfa2}")
#define GPEXT_NAME   TEXT("Sample CSE")



BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
            DisableThreadLibraryCalls (hInstance);
            }
            break;
    }

    return TRUE;
}


DWORD ProcessGroupPolicy ( DWORD   dwFlags,
                           HANDLE  hToken,
                           HKEY    hKeyRoot,
                           PGROUP_POLICY_OBJECT   pDeletedGPOList,
                           PGROUP_POLICY_OBJECT   pChangedGPOList,
                           ASYNCCOMPLETIONHANDLE  pHandle,
                           BOOL*   pbAbort,
                           PFNSTATUSMESSAGECALLBACK pStatusCallback )
{
    HKEY hKey;
    DWORD dwResult = ERROR_SUCCESS, dwSize, dwType;
    TCHAR szMsg[100] = {0};
    TCHAR szMsg2[100] = {0};
    HANDLE  hEventLog;
    LPTSTR szStrings[2] = {0,0};

    if (RegOpenKeyEx (hKeyRoot, TEXT("Software\\Policies\\Microsoft\\Windows\\SampleCSE"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwResult);

        RegQueryValueEx (hKey, TEXT("ReturnValue"), NULL, &dwType, (LPBYTE) &dwResult, &dwSize);

        if (dwResult != ERROR_SUCCESS)
        {
            dwSize = sizeof(szMsg);
            RegQueryValueEx (hKey, TEXT("EventMsg1"), NULL, &dwType, (LPBYTE) szMsg, &dwSize);

            dwSize = sizeof(szMsg2);
            RegQueryValueEx (hKey, TEXT("EventMsg2"), NULL, &dwType, (LPBYTE) szMsg2, &dwSize);
        }

        RegCloseKey (hKey);
    }


    if (dwResult != ERROR_SUCCESS)
    {
        //
        // Put message in event log
        //

        hEventLog = RegisterEventSource(NULL, TEXT("gpext"));

        if (hEventLog)
        {

            szStrings[0] = szMsg;
            ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, EVENT_ERROR, NULL, 1, 0,
                        szStrings, NULL);

            szStrings[0] = szMsg2;
            ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, EVENT_ERROR, NULL, 1, 0,
                        szStrings, NULL);


            DeregisterEventSource(hEventLog);
        }
    }

    wsprintf (szMsg, TEXT("SampleCSE:  returning 0x%x\r\n"), dwResult);
    OutputDebugString (szMsg);

    return dwResult;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, GPEXT_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)GPEXT_NAME,
                   (lstrlen(GPEXT_NAME) + 1) * sizeof(TCHAR));


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicy"),
                   (lstrlen(TEXT("ProcessGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("gpext.dll"),
                   (lstrlen(TEXT("gpext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 1;
    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegCloseKey (hKey);



    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\gpext"), 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    RegSetValueEx (hKey, TEXT("EventMessageFile"), 0, REG_SZ, (LPBYTE)TEXT("gpext.dll"),
                   (lstrlen(TEXT("gpext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 7;
    RegSetValueEx (hKey, TEXT("TypesSupported"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));


    RegCloseKey (hKey);


    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);
    RegDeleteKey (HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\gpext"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\compdata.cpp ===
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentData::CComponentData()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_pGPTInformation = NULL;
}

CComponentData::~CComponentData()
{
    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IUnknown)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IComponentData)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<long*>(bmp16x16),
                      reinterpret_cast<long*>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreateComponent: Failed to create CSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CComponentData::QueryDataObject(long cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject;
    LPGPTDATAOBJECT pGPTDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pGPTDataObject->SetType(type);
    pGPTDataObject->SetCookie(cookie);
    pGPTDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (!m_pGPTInformation)
                {
                    lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                }

                if (m_pGPTInformation)
                {
                    hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        if (g_NameSpace[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == NUM_NAMESPACE_ITEMS)
        pItem->displayname = NULL;
    else
    {
        pItem->displayname = g_NameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    LONG cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IPersistStreamInit)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    *pClassID = CLSID_GPTDemoSnapIn;

    return S_OK;
}

STDMETHODIMP CComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_FAIL;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot)
        m_hRoot = hParent;


    if (m_hRoot == hParent)
        dwIndex = 0;
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = item.lParam;
    }

    for (i = 0; i < NUM_NAMESPACE_ITEMS; i++)
    {
        if (g_NameSpace[i].dwParent == dwIndex)
        {
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 0;
            item.nOpenImage = 1;
            item.nState = 0;
            item.cChildren = g_NameSpace[i].cChildren;
            item.lParam = g_NameSpace[i].dwID;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentDataCF::CComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CComponentDataCF::~CComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CComponentData *pComponentData = new CComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object creation (IClassFactory)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (IsEqualCLSID (rclsid, CLSID_GPTDemoSnapIn)) {

        CComponentDataCF *pComponentDataCF = new CComponentDataCF();   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\gptdemo.cpp ===
#include "main.h"
#include <initguid.h>
#include <gptdemo.h>
#include <gpedit.h>


//
// Global variables for this DLL
//

LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitNameSpace();
#if DBG
       InitDebugSupport();
#endif
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return (CreateComponentDataClassFactory (rclsid, riid, ppv));
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

const TCHAR szSnapInLocation[] = TEXT("%SystemRoot%\\System32\\GPTDemo.dll");

STDAPI DllRegisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwIndex;
    LONG lResult;
    HKEY hKey;


    StringFromGUID2 (CLSID_GPTDemoSnapIn, szSnapInKey, 50);

    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, IDS_SNAPIN_NAME, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szSnapInLocation,
                   (lstrlen(szSnapInLocation) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                  szSnapInKey, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register in the NodeTypes key
    //

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (NODEID_User, szGUID, 50);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    DWORD dwIndex;
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;

    StringFromGUID2 (CLSID_GPTDemoSnapIn, szSnapInKey, 50);

    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);
        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }


    StringFromGUID2 (NODEID_User, szGUID, 50);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);


    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\dataobj.h ===
//
// IGPTDataobject interface id
//

// {C14C50E2-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(IID_IGPTDataObject,0xc14c50e2, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);




#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IGPTDataObject
DECLARE_INTERFACE_(IGPTDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPTDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ long cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ long *cookie) PURE;
};
typedef IGPTDataObject *LPGPTDATAOBJECT;



//
// CDataObject class
//

class CDataObject : public IDataObject,
                    public IGPTDataObject
{
    friend class CSnapIn;

protected:

    ULONG                  m_cRef;
    CComponentData        *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    LONG                   m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;



public:
    CDataObject(CComponentData *pComponent);
    ~CDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IGPTDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (LONG cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (LONG *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\compdata.h ===
//
// CComponentData class
//

class CComponentData:
    public IComponentData,
    public IPersistStreamInit
{
    friend class CDataObject;
    friend class CSnapIn;

protected:
    ULONG                m_cRef;
    HWND		 m_hwndFrame;
    LPCONSOLENAMESPACE   m_pScope;
    LPCONSOLE            m_pConsole;
    HSCOPEITEM           m_hRoot;
    LPGPEINFORMATION     m_pGPTInformation;

public:
    CComponentData();
    ~CComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);


private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
};



//
// ComponentData class factory
//


class CComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CComponentDataCF();
    ~CComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "main.h"

#if DBG

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPTDemo[] = TEXT("GPTDEMO(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPTDemoDebugLevel")

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[2*MAX_PATH+40];
    va_list marker;
    DWORD dwErrCode;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        wsprintf (szDebugTitle, c_szGPTDemo, GetCurrentProcessId());
        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;

            hFile = CreateFile(TEXT("c:\\GPTDemo.log"),
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }

        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\dataobj.cpp ===
#include "main.h"
#include <initguid.h>
#include "dataobj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CDataObject::CDataObject(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CDataObject::~CDataObject()
{
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGPTDataObject))
    {
        *ppv = (LPGPTDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDispName[50];
    WCHAR  szDisplayName[100];

    LoadStringW (g_hInstance, IDS_SNAPIN_NAME, szDisplayName, 100);

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPTDemoSnapIn, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\gptdemo.h ===
//-----------------------------------------------------------------------------
//
// gptdemo.h - Definitions and prototypes for the GPTDEMO.DLL
//
// Copyright 1997, Microsoft Corporation
//
//-----------------------------------------------------------------------------


//
// Group Policy Editor Demo SnapIn extension GUID
//

// {C14C50E0-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(CLSID_GPTDemoSnapIn, 0xc14c50e0, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);



//
// Group Policy Editor node ids
//

// {C14C50E1-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(NODEID_GPTDemoRoot, 0xc14c50e1, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);


//
// User Interface Policy
//

// {81244660-FF22-11d0-8D04-248D0B000000}
DEFINE_GUID(NODEID_Samples, 0x81244660, 0xff22, 0x11d0, 0x8d, 0x4, 0x24, 0x8d, 0xb, 0x0, 0x0, 0x0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\layout.cpp ===
#include "main.h"


//
//  This file contains the tool's namespace and result pane items
//


//
// Result pane items for the nodes with no result pane items
//

RESULTITEM g_Undefined[] =
{
    { 1, 1, 0, 0, {0} }
};


//
// Result pane items for the Samples node
//

RESULTITEM g_Samples[] =
{
    { 2, 1, IDS_README, 4, {0} },
    { 3, 1, IDS_APPEAR, 7, {0} }
};




//
// Namespace (scope) items
//
// Be sure to update NUM_NAMESPACE_ITEMS define in layout.h if you
// add / remove from this array.
//

NAMESPACEITEM g_NameSpace[] =
{
    { 0, -1, 0,          0, {0}, 0, g_Undefined, &NODEID_User },   // Root
    { 1, 0, IDS_SAMPLES, 0, {0}, 2, g_Samples,   &NODEID_Samples }
};


BOOL InitNameSpace()
{
    DWORD dwIndex;

    for (dwIndex = 1; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        LoadString (g_hInstance, g_NameSpace[dwIndex].iStringID,
                    g_NameSpace[dwIndex].szDisplayName,
                    MAX_DISPLAYNAME_SIZE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\layout.h ===
#define NUM_NAMESPACE_ITEMS       2
#define MAX_DISPLAYNAME_SIZE    100


typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;


typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iStringID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
} NAMESPACEITEM, *LPNAMESPACEITEM;


extern RESULTITEM g_Root[];
extern RESULTITEM g_Undefined[];
extern NAMESPACEITEM g_NameSpace[];

BOOL InitNameSpace();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\snapin.h ===
//
// SnapIn class
//

class CSnapIn:
    public IComponent,
    public IExtendPropertySheet
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CComponentData      *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPIMAGELIST          m_pImageResult; // Result pane's image list interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    WCHAR                m_column1[20];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode

    static unsigned int  m_cfNodeType;
    static TCHAR m_szDefaultIcon[];

public:
    CSnapIn(CComponentData *pComponent);
    ~CSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(long);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, long, long);
    STDMETHODIMP         QueryDataObject(long, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(long, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      long handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


private:
    static BOOL CALLBACK UserGroupPolDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK MachineGroupPolDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK GroupPolDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, BOOL bUser);
    static BOOL CALLBACK ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK NetHoodDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK StartMenuDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL AddEntry (HWND hLV, LPTSTR lpPlace, LPTSTR lpLocation);
    static BOOL InitializePlacesDlg (CSnapIn* pSnapIn, HWND hDlg);
    static BOOL SavePlaces (CSnapIn* pSnapIn, HWND hLV);
    static BOOL RemoveEntries (CSnapIn* pSnapIn, HWND hLV);
    static BOOL CALLBACK MyDocsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK AddPlaceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK MyDocsTargetDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK AppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\snapin.cpp ===
#include "main.h"


// {febf1208-8aff-11d2-a8a1-00c04fbbcfa2}
#define GPEXT_GUID { 0xfebf1208, 0x8aff, 0x11d2, { 0xa8, 0xa1, 0x0, 0xc0, 0x4f, 0xbb, 0xcf, 0xa2} };

GUID guidGPExt = GPEXT_GUID;
GUID guidSnapin = CLSID_GPTDemoSnapIn;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSnapIn::CSnapIn(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pImageResult = NULL;
    m_pConsoleVerb = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_ICON;

    LoadString(g_hInstance, IDS_NAME, m_column1, sizeof(m_column1));
}

CSnapIn::~CSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IComponent)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);


    return S_OK;
}

STDMETHODIMP CSnapIn::Destroy(long cookie)
{

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }
    if (m_pImageResult != NULL)
    {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
        hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

        // Set the images
        m_pImageResult->ImageListSetStrip(reinterpret_cast<long*>(hbmp16x16),
                                          reinterpret_cast<long*>(hbmp32x32),
                                          0, RGB(255, 0, 255));

        DeleteObject(hbmp16x16);
        DeleteObject(hbmp32x32);
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPGPTDATAOBJECT pGPTDataObject;
            long cookie;
            INT i;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_NameSpace[cookie].cResultItems; i++)
            {
                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_NameSpace[cookie].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM) &g_NameSpace[cookie].pResultItems[i];
                m_pResult->InsertItem(&resultItem);
            }

            //m_pResult->Sort(0, 0, -1);
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;


    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPGPTDATAOBJECT pGPTDataObject;
            DATA_OBJECT_TYPES type;
            LONG cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IGPTDataObject, (LPVOID *)&pGPTDataObject);

            if (FAILED(hr))
                break;

            pGPTDataObject->GetType(&type);
            pGPTDataObject->GetCookie(&cookie);

            pGPTDataObject->Release();


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if ((type == CCT_RESULT) || ((type == CCT_SCOPE) && (cookie == 0)))
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                //
                // If this is a result pane item, then change the default
                // verb to Properties.
                //

                if (type == CCT_RESULT)
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = g_NameSpace[pResult->lParam].szDisplayName;
                else
                    pResult->str = L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = 0;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE);
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CSnapIn::GetResultViewType(long cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPTDATAOBJECT pGPTDataObjectA, pGPTDataObjectB;
    LONG cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObjectB)))
    {
        pGPTDataObjectA->Release();
        return S_FALSE;
    }

    pGPTDataObjectA->GetCookie(&cookie1);
    pGPTDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPTDataObjectA->Release();
    pGPTDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IExtendPropertySheet)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             long handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[2];
    LPGPTDATAOBJECT pGPTDataObject;
    LPRESULTITEM pItem;
    LONG cookie;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                            (LPVOID *)&pGPTDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pGPTDataObject->GetCookie(&cookie);
    pGPTDataObject->Release();


    pItem = (LPRESULTITEM)cookie;


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) this;


    //
    // Do the page specific stuff
    //

    switch (pItem->dwID)
    {
        case 2:

            psp.pszTemplate = MAKEINTRESOURCE(IDD_README);
            psp.pfnDlgProc = ReadmeDlgProc;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 3:

            psp.pszTemplate = MAKEINTRESOURCE(IDD_APPEAR);
            psp.pfnDlgProc = AppearDlgProc;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;
    }


    return (hr);
}

STDMETHODIMP CSnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPGPTDATAOBJECT pGPTDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPTDataObject,
                                               (LPVOID *)&pGPTDataObject)))
    {
        pGPTDataObject->GetType(&type);
        pGPTDataObject->Release();

        if (type == CCT_RESULT)
            return S_OK;
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (Internal functions)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK CSnapIn::ReadmeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}


BOOL CALLBACK CSnapIn::AppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CSnapIn * pCS;
    static BOOL bAppearDirty;
    HKEY hKeyRoot, hKey;
    DWORD dwType, dwSize, dwDisp;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szPath[2 * MAX_PATH];
    HRESULT hr;


    switch (message)
    {
        case WM_INITDIALOG:
        {
            pCS = (CSnapIn *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLong (hDlg, DWL_USER, (LONG) pCS);

            if (!pCS) {
                break;
            }

            CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_DEFAULT);

            hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath (GPO_SECTION_USER, szPath, ARRAYSIZE(szPath));

            if (SUCCEEDED(hr))
            {

                lstrcat (szPath, TEXT("\\gpext.ini"));

                GetPrivateProfileString (TEXT("Colors"), TEXT("Background"), TEXT("0 128 128"),
                                         szBuffer, MAX_PATH, szPath);

                if (!lstrcmpi(szBuffer, TEXT("255 0 0")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_RED);
                else if (!lstrcmpi(szBuffer, TEXT("0 255 0")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_GREEN);
                else if (!lstrcmpi(szBuffer, TEXT("0 0 255")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_BLUE);
                else if (!lstrcmpi(szBuffer, TEXT("0 0 0")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_BLACK);
                else if (!lstrcmpi(szBuffer, TEXT("160 160 164")))
                    CheckRadioButton (hDlg, IDC_RED, IDC_DEFAULT, IDC_GRAY);


                GetPrivateProfileString (TEXT("Desktop"), TEXT("Wallpaper"), TEXT("(None)"),
                                         szBuffer, MAX_PATH, szPath);

                SetDlgItemText (hDlg, IDC_WALLPAPER, szBuffer);

                GetPrivateProfileString (TEXT("Desktop"), TEXT("TileWallpaper"), TEXT("0"),
                                         szBuffer, MAX_PATH, szPath);

                if (szBuffer[0] == TEXT('1'))
                    CheckRadioButton (hDlg, IDC_TILE, IDC_CENTER, IDC_TILE);
                else
                    CheckRadioButton (hDlg, IDC_TILE, IDC_CENTER, IDC_CENTER);
            }


            bAppearDirty = FALSE;
            break;
        }

        case WM_COMMAND:
            if ((HIWORD(wParam) == BN_CLICKED) || (HIWORD(wParam) == EN_UPDATE))
            {
                if (!bAppearDirty)
                {
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                    bAppearDirty = TRUE;
                }
            }
            break;

        case WM_NOTIFY:

            pCS = (CSnapIn *) GetWindowLong (hDlg, DWL_USER);

            if (!pCS) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    if (bAppearDirty)
                    {

                       hr = pCS->m_pcd->m_pGPTInformation->GetFileSysPath (GPO_SECTION_USER, szPath, ARRAYSIZE(szPath));

                       if (SUCCEEDED(hr))
                       {
                           lstrcat (szPath, TEXT("\\gpext.ini"));
                           lstrcpy (szBuffer, TEXT("0 128 128"));

                           if (IsDlgButtonChecked (hDlg, IDC_RED) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("255 0 0"));

                           else if (IsDlgButtonChecked (hDlg, IDC_GREEN) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("0 255 0"));

                           else if (IsDlgButtonChecked (hDlg, IDC_BLUE) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("0 0 255"));

                           else if (IsDlgButtonChecked (hDlg, IDC_BLACK) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("0 0 0"));

                           else if (IsDlgButtonChecked (hDlg, IDC_GRAY) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("160 160 164"));

                           WritePrivateProfileString (TEXT("Colors"), TEXT("Background"), szBuffer, szPath);


                           lstrcpy (szBuffer, TEXT("(None)"));

                           GetDlgItemText (hDlg, IDC_WALLPAPER, szBuffer, MAX_PATH);

                           WritePrivateProfileString (TEXT("Desktop"), TEXT("Wallpaper"), szBuffer, szPath);

                           if (IsDlgButtonChecked (hDlg, IDC_TILE) == BST_CHECKED)
                               lstrcpy (szBuffer, TEXT("1"));
                           else
                               lstrcpy (szBuffer, TEXT("0"));

                           WritePrivateProfileString (TEXT("Desktop"), TEXT("TileWallpaper"), szBuffer, szPath);

                           bAppearDirty = FALSE;
                           pCS->m_pcd->m_pGPTInformation->PolicyChanged(FALSE, TRUE, &guidGPExt, &guidSnapin);
                       }
                    }
                }
                // fall through...

                case PSN_RESET:
                    SetWindowLong (hDlg, DWL_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\util.cpp ===
#include "main.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}


//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    TCHAR szDelKey[2 * MAX_PATH];


    lstrcpy (szDelKey, lpSubKey);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    TCHAR szDelKey[2 * MAX_PATH];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;


    //
    // Make a copy of the subkey so we can write to it.
    //

    lstrcpy (szDelKey, lpSubKey);


    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\util.h ===
//
// Function proto-types for util.cpp
//

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gptdemo\main.h ===
#include <windows.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <prsht.h>
#include <mmc.h>
#include <gpedit.h>
#include <gptdemo.h>

class CSnapIn;

#include "layout.h"
#include "compdata.h"
#include "snapin.h"
#include "dataobj.h"
#include "debug.h"
#include "util.h"


//
// Resource ids
//

#define IDS_SNAPIN_NAME          1
#define IDS_NAME                 2
#define IDS_POLICY               3
#define IDS_DISPLAY              4
#define IDS_SAMPLES              5
#define IDS_README               8
#define IDS_APPEAR              19


//
// Icons
//

#define IDI_POLICY               1
#define IDI_README               2
#define IDI_APPEAR               7


//
// Bitmaps
//

#define IDB_16x16                1
#define IDB_32x32                2


//
// Dialogs
//


#define IDD_README             150

#define IDD_APPEAR             600
#define IDC_RED                601
#define IDC_GREEN              602
#define IDC_BLUE               603
#define IDC_BLACK              604
#define IDC_GRAY               605
#define IDC_DEFAULT            606
#define IDC_WALLPAPER          607
#define IDC_TILE               608
#define IDC_CENTER             609


//
// Global variables
//

extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;


//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//
// Functions to create class factories
//

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\sethc\access.h ===
DWORD WINAPI StickyKeysNotification(BOOL fNotify);
DWORD WINAPI FilterKeysNotification(BOOL fNotify);
DWORD WINAPI ToggleKeysNotification(BOOL fNotify);
DWORD WINAPI MouseKeysNotification(BOOL fNotify);
DWORD WINAPI HighContNotification(BOOL fNotify);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\notify\notify.c ===
#include <windows.h>
#include <winwlx.h>

//
//  Some helpful tips about winlogon's notify events
//
//  1)  The logoff and shutdown notifications are always done
//      synchronously regardless of the Asynchronous registry entry.
//
//  2)  If you need to spawn child processes, you have to use
//      CreateProcessAsUser() otherwise the process will start
//      on winlogon's desktop (not the user's)
//
//  3)  The logon notification comes before the user's network
//      connections are restored.  If you need the user's persisted
//      net connections, use the StartShell event.
//
//  4)  Don't put any UI up during either screen saver event.
//      These events are intended for background processing only.
//



#define NOTIFY_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\notify")


BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
            DisableThreadLibraryCalls (hInstance);
            }
            break;
    }

    return TRUE;
}


VOID WLEventLogon (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventLogon.\r\n"));
}

VOID WLEventLogoff (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventLogff.\r\n"));
}

VOID WLEventStartup (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartup.\r\n"));
}

VOID WLEventShutdown (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventShutdown.\r\n"));
}

VOID WLEventStartScreenSaver (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartScreenSaver.\r\n"));
}

VOID WLEventStopScreenSaver (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStopScreenSaver.\r\n"));
}

VOID WLEventLock (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventLock.\r\n"));
}

VOID WLEventUnlock (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventUnlock.\r\n"));
}

VOID WLEventStartShell (PWLX_NOTIFICATION_INFO pInfo)
{
    OutputDebugString (TEXT("NOTIFY:  Entering WLEventStartShell.\r\n"));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwTemp;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, NOTIFY_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    RegSetValueEx (hKey, TEXT("Logon"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLogon"),
                   (lstrlen(TEXT("WLEventLogon")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Logoff"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLogoff"),
                   (lstrlen(TEXT("WLEventLogoff")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Startup"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartup"),
                   (lstrlen(TEXT("WLEventStartup")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Shutdown"), 0, REG_SZ, (LPBYTE)TEXT("WLEventShutdown"),
                   (lstrlen(TEXT("WLEventShutdown")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StartScreenSaver"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartScreenSaver"),
                   (lstrlen(TEXT("WLEventStartScreenSaver")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StopScreenSaver"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStopScreenSaver"),
                   (lstrlen(TEXT("WLEventStopScreenSaver")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Lock"), 0, REG_SZ, (LPBYTE)TEXT("WLEventLock"),
                   (lstrlen(TEXT("WLEventLock")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("Unlock"), 0, REG_SZ, (LPBYTE)TEXT("WLEventUnlock"),
                   (lstrlen(TEXT("WLEventUnlock")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("StartShell"), 0, REG_SZ, (LPBYTE)TEXT("WLEventStartShell"),
                   (lstrlen(TEXT("WLEventStartShell")) + 1) * sizeof(TCHAR));

    dwTemp = 0;
    RegSetValueEx (hKey, TEXT("Impersonate"), 0, REG_DWORD, (LPBYTE)&dwTemp, sizeof(dwTemp));

    dwTemp = 1;
    RegSetValueEx (hKey, TEXT("Asynchronous"), 0, REG_DWORD, (LPBYTE)&dwTemp, sizeof(dwTemp));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("notify.dll"),
                   (lstrlen(TEXT("notify.dll")) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, NOTIFY_PATH);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\sethc\access.c ===
/****************************** Module Header ******************************\
* Module Name: access.c
*
* Copyright (c) 1997, Microsoft Corporation
*
* Accessibility notification dialogs
*
* History:
* 02-01-97  Fritz Sands   Created
\***************************************************************************/

#include <stdio.h>
#include <wtypes.h>
#include "dialogs.h"
#include <winuserp.h>
#include <oleacc.h>
#pragma hdrstop

/*
 * Notification Dialog Stuff
 */
 
extern HINSTANCE  g_hInstance;

#define cchBuf 1024                       // plenty of room for title
#define cchTitle 128
typedef struct tagACCESSINFO {
    UINT  Feature;
    UINT  TitleID;
    HANDLE hDesk;
    WCHAR  wcTitle[cchTitle];
} ACCESSINFO, *PACCESSINFO;

#define NOTIF_KEY                __TEXT("Control Panel\\Accessibility")
#define NOTIFY_VALUE   __TEXT("Warning Sounds")

#define HOTKEYCODE                    100

#define ID_STICKYKEYNAME    NOTIF_KEY __TEXT("\\StickyKeys")
#define ID_TOGGLEKEYS       NOTIF_KEY __TEXT("\\ToggleKeys")
#define ID_HIGHCONTROST     NOTIF_KEY __TEXT("\\HighContrast")
#define ID_MOUSEKEYS        NOTIF_KEY __TEXT("\\MouseKeys")
#define ID_SERIALKEYS       NOTIF_KEY __TEXT("\\SerialKeys")

/***************************************************************************
 *                                                                         *
 * ConfirmHandler_InitDialog                                               *
 *                                                                         *
 * Input: hWnd = dialog window handle                                      *
 *                  uiTitle = resource ID of dialog box title              *
 *                  uiTitle+1 through uiTitle+n = resource ID of dialog box text *
 * Output: Returns TRUE on success, FALSE on failure.                      *
 *                                                                         *
 ***************************************************************************/

BOOL ConfirmHandler_InitDialog(HWND hWnd, HDESK hDesk, UINT uiTitle, WCHAR *pszTitle) {
    RECT    rc;   // Current window size
    WCHAR *pszBuf;
    WCHAR *pszNext;
    int cchBufLeft;
    int cchHelpText;
    int fSuccess = 0;
    WCHAR szDesktop[MAX_PATH];
    DWORD Len1 = MAX_PATH;
    BOOL b;

    szDesktop[0] = 0;
    b = GetUserObjectInformation(hDesk, UOI_NAME, szDesktop, MAX_PATH, &Len1);
    SetWindowText(hWnd, pszTitle);                                    // Init title bar

    pszBuf = (WCHAR *)LocalAlloc(LMEM_FIXED, cchBuf * sizeof (WCHAR));
    if (!pszBuf) goto Exit;

    pszNext = pszBuf; cchBufLeft = cchBuf;
    while (cchHelpText = LoadString(g_hInstance, ++uiTitle, pszNext, cchBufLeft)) {
        pszNext += cchHelpText;
        cchBufLeft -= cchHelpText;
    }

    SetDlgItemText(hWnd, ID_HELPTEXT, pszBuf);       // Init help text

    if (b && (0 == wcscmp(szDesktop,L"Winlogon"))) {
        EnableWindow(GetDlgItem(hWnd, IDHELP), FALSE);

    }

// Make us a topmost window and center ourselves.

    GetWindowRect(hWnd, &rc);                                               // Get size of dialog

// Center dialog and make it topmost
    SetWindowPos(hWnd,
                 HWND_TOPMOST,
                 (GetSystemMetrics(SM_CXFULLSCREEN)/2) - (rc.right - rc.left)/2,
                 (GetSystemMetrics(SM_CYFULLSCREEN)/2) - (rc.bottom - rc.top)/2,
                 0,0, SWP_NOSIZE );

       // Make sure we're active!
// Lets try setting this to be the foreground window.
    // SetForegroundWindow(hWnd);


    // SetForgroundWindow will not work because we are not the forground task.  So use accSelect
	if ( hWnd )
	{
		IAccessible *pAcc = NULL;
		VARIANT varChild;

		varChild.vt = VT_I4;
		varChild.lVal = 0;
		
		if ( AccessibleObjectFromWindow( hWnd, OBJID_CLIENT, &IID_IAccessible, (void**)&pAcc ) == S_OK )
		{
			if ( pAcc )
			    pAcc->lpVtbl->accSelect( pAcc, SELFLAG_TAKEFOCUS, varChild );
		}
	}
	
	
    fSuccess = 1;

    LocalFree((HLOCAL)pszBuf);
Exit:
    return fSuccess;
}

/***************************************************************************
 *                                                                         *
 *                                                                         *
 * ConfirmHandler                                                          *
 *                                                                         *
 * Input: Std Window messages                                              *
 * Output: IDOK if success, IDCANCEL if we should abort                    *
 *                                                                         *
 *                                                                         *
 * Put up the main dialog to tell the user what is happening and to get    *
 * permission to continue.                                                 *
 ***************************************************************************/


INT_PTR CALLBACK ConfirmHandler(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR       buf[100];
    WCHAR       szRundll[] = L"rundll32.exe";
    WCHAR       szDesktop[MAX_PATH];
    DWORD       Len1, Len2;
    PACCESSINFO pAccessInfo;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO si;

    GetStartupInfo(&si);

    switch(message) {
    case WM_INITDIALOG:
       SetWindowLongPtr(hWnd, DWLP_USER, lParam);
       pAccessInfo = (PACCESSINFO)lParam;
       
       return ConfirmHandler_InitDialog(hWnd, pAccessInfo->hDesk, pAccessInfo->TitleID, pAccessInfo->wcTitle);

    case WM_COMMAND:
       pAccessInfo = (PACCESSINFO)GetWindowLongPtr(hWnd, DWLP_USER);

       switch (LOWORD(wParam)) {
       case IDOK:
       case IDCANCEL:
            EndDialog(hWnd, LOWORD(wParam));

            return TRUE;

       case IDHELP:
            // IDHELP (Settings... really) dismisses dialog with no changes
            EndDialog(hWnd, IDCANCEL);

//
// Spawn the correct help
//
            lstrcpy(buf,L" Shell32.dll,Control_RunDLL access.cpl,,");
            switch (pAccessInfo->Feature) {
            case ACCESS_STICKYKEYS:
            case ACCESS_FILTERKEYS:
            case ACCESS_TOGGLEKEYS:
            default:
                 lstrcat(buf,L"1");
                 break;

            case ACCESS_MOUSEKEYS:
                 lstrcat(buf,L"4");
                 break;

            case ACCESS_HIGHCONTRAST:
                 lstrcat(buf,L"3");
                 break;
            }

			CreateProcess( szRundll, buf, NULL, NULL, FALSE, 0, NULL, NULL, &si, &ProcessInfo );

            return TRUE;
            break;

       default:
            return FALSE;
       }
       break;
    
    default:
       // fall thru rather than return FALSE to keep compiler happy
       break;
    }
    return FALSE;
}

DWORD MakeAccessDlg(PACCESSINFO pAccessInfo) {
    DWORD iRet = 0;
    HDESK  hDeskOld;

    hDeskOld = GetThreadDesktop(GetCurrentThreadId());
    if (hDeskOld == NULL) return 0;

    pAccessInfo->hDesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (pAccessInfo->hDesk == NULL) return 0;

    if (LoadString(g_hInstance, pAccessInfo->TitleID, pAccessInfo->wcTitle, cchTitle)) {
        SetThreadDesktop(pAccessInfo->hDesk);
        if (!FindWindowEx(GetDesktopWindow(), NULL, (LPCTSTR)0x8002, pAccessInfo->wcTitle)) {
            iRet = (DWORD)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(DLG_CONFIRM), NULL, ConfirmHandler, (LPARAM)pAccessInfo);
        }
        SetThreadDesktop(hDeskOld);
    }
    CloseDesktop(pAccessInfo->hDesk);

    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI StickyKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL ;
    ACCESSINFO AccessInfo;
    STICKYKEYS sticky;
    DWORD dwS;
    BOOL b;

    AccessInfo.Feature = ACCESS_STICKYKEYS;
    AccessInfo.TitleID = ID_STICKY_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet)
    {
        sticky.cbSize = sizeof sticky;
        b = SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof sticky, &sticky, 0);
        dwS= sticky.dwFlags;

        if (iRet & HOTKEYCODE) {
            sticky.dwFlags &= ~SKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof sticky, &sticky, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }
        if (iRet == IDOK) {
            sticky.dwFlags |= SKF_STICKYKEYSON;
        }

        if (dwS != sticky.dwFlags) {
            b = SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof sticky, &sticky, 0);

           SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETSTICKYKEYS, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);
        }

        iRet = 1;
    }

    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI FilterKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL ;
    ACCESSINFO AccessInfo;
    FILTERKEYS filter;
    DWORD dwF;
    BOOL b;

    AccessInfo.Feature = ACCESS_FILTERKEYS;
    AccessInfo.TitleID = ID_FILTER_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        filter.cbSize = sizeof filter;
        b = SystemParametersInfo(SPI_GETFILTERKEYS, sizeof filter, &filter, 0);
        dwF = filter.dwFlags;

        if (iRet & HOTKEYCODE) {
            filter.dwFlags &= ~FKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETFILTERKEYS, sizeof filter, &filter, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }
        if (iRet == IDOK) {
            filter.dwFlags |= FKF_FILTERKEYSON;
        }
        if (dwF !=filter.dwFlags) {
            b = SystemParametersInfo(SPI_SETFILTERKEYS, sizeof filter, &filter, 0);
            // Broadcast a message. Being extra safe not to turn on filter keys 
            // during logon. Send message to notify all specially systray: a-anilk 
           SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETFILTERKEYS, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);

        }
        iRet = 1;
    }

    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI ToggleKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL;
    ACCESSINFO AccessInfo;
    TOGGLEKEYS toggle;
    DWORD dwT;
    BOOL b;

    toggle.cbSize = sizeof toggle;

    AccessInfo.Feature = ACCESS_TOGGLEKEYS;
    AccessInfo.TitleID = ID_TOGGLE_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        toggle.cbSize = sizeof toggle;
        b = SystemParametersInfo(SPI_GETTOGGLEKEYS, sizeof toggle, &toggle, 0);
        dwT = toggle.dwFlags;

        if (iRet & HOTKEYCODE) {
            toggle.dwFlags &= ~TKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETTOGGLEKEYS, sizeof toggle, &toggle, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }
        if (iRet == IDOK) {
            toggle.dwFlags |= TKF_TOGGLEKEYSON;
        }

        if (toggle.dwFlags != dwT) {
            b = SystemParametersInfo(SPI_SETTOGGLEKEYS, sizeof toggle, &toggle, 0);
            // Not required to send message, As it currently has no indicators...
        }
        iRet = 1;
    }
        
    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI MouseKeysNotification(BOOL fNotifReq) {
    DWORD iRet = IDCANCEL;
    ACCESSINFO AccessInfo;
    MOUSEKEYS mouse;
    DWORD dwM;
    BOOL b;

    AccessInfo.Feature = ACCESS_MOUSEKEYS;
    AccessInfo.TitleID = ID_MOUSE_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        mouse.cbSize = sizeof mouse;
        b = SystemParametersInfo(SPI_GETMOUSEKEYS, sizeof mouse, &mouse, 0);
        dwM = mouse.dwFlags;

        if (iRet & HOTKEYCODE) {
            mouse.dwFlags &= ~MKF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETMOUSEKEYS, sizeof mouse, &mouse, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }

        if (iRet == IDOK) {
            mouse.dwFlags |= MKF_MOUSEKEYSON;
        }

        if (mouse.dwFlags != dwM) {
            b = SystemParametersInfo(SPI_SETMOUSEKEYS, sizeof mouse, &mouse, 0);

            SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETMOUSEKEYS, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);
        }

        iRet = 1;
    }
        
    return iRet;
}

/***************************************************************************
 *                                                                         *
 * The thread opens the input desktopn, connects to it, and calls the      *
 * notification dialog for the accessibility feature.                      *
 *                                                                         *
 ***************************************************************************/
DWORD WINAPI HighContNotification(BOOL fNotifReq)
{
    DWORD iRet = IDCANCEL ;
    ACCESSINFO AccessInfo;
    HIGHCONTRAST  hc;
    DWORD dwH;
    BOOL b;

    AccessInfo.Feature = ACCESS_HIGHCONTRAST;
    AccessInfo.TitleID = ID_HC_TITLE;

    if ( fNotifReq )
    {
        iRet = MakeAccessDlg(&AccessInfo);
    }
    else
        iRet = IDOK;

    if (iRet) {
        hc.cbSize = sizeof hc;
        b = SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof hc, &hc, 0);
        dwH = hc.dwFlags;

        if (iRet & HOTKEYCODE) {
            hc.dwFlags &= ~HCF_HOTKEYACTIVE;
            b = SystemParametersInfo(SPI_SETHIGHCONTRAST, sizeof hc, &hc, SPIF_UPDATEINIFILE);
            iRet &= ~HOTKEYCODE;
        }

        if (iRet == IDOK) {
            hc.dwFlags |= HCF_HIGHCONTRASTON;
        }

        if (hc.dwFlags != dwH) {
            b = SystemParametersInfo(SPI_SETHIGHCONTRAST, sizeof hc, &hc, 0);

            SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETHIGHCONTRAST, FALSE, 
               SMTO_ABORTIFHUNG, 5000, NULL);
        }
        iRet = 1;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\sethc\sethc.c ===
/****************************** Module Header ******************************\
* Module Name: sethc.c
*
* Copyright (c) 1997, Microsoft Corporation
*
* SetHC -- exe to set or clear high contrast state.
*
* History:
* 02-01-97  Fritz Sands Created
* Bug fixes : a-anilk June 99
\***************************************************************************/

/***************************************************************************
 * Use the following define if for some reason we have to go back to using
 * a message loop to let shell have time to update the UI
 *
#define NEED_MSG_PUMP
 **************************************************************************/

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winuserp.h>
#include <cpl.h>
#include <stdarg.h>
#include <stdlib.h>
#include <WININET.H>
#include <shlobj.h>
#include <objbase.h>
#include <shlguid.h>
#include <uxthemep.h>
#include "access.h"
#pragma hdrstop

HINSTANCE  g_hInstance;

#ifdef DBG
  #define DBPRINTF MyOutputDebugString
  void MyOutputDebugString( LPCTSTR lpOutputString, ...);
#else
  #define DBPRINTF   1 ? (void)0 : (void)
#endif

/*
 * High Contrast Stuff
 */

#define HC_KEY                  TEXT("Control Panel\\Accessibility\\HighContrast")
#define HIGHCONTRASTSCHEME      TEXT("High Contrast Scheme")
#define REGSTR_VAL_FLAGS        TEXT("Flags")
#define REGSTR_PATH_APPEARANCE  TEXT("Control Panel\\Appearance")
#define REGSTR_PATH_LOOKSCHEMES TEXT("Control Panel\\Appearance\\Schemes")
#define APPEARANCESCHEME        REGSTR_PATH_LOOKSCHEMES
#define DEFSCHEMEKEY            REGSTR_PATH_APPEARANCE
#define DEFSCHEMENAME           TEXT("Current")
#define WHITEBLACK_HC           TEXT("High Contrast Black (large)")
#define CURHCSCHEME             TEXT("Volatile HC Scheme")
// the extension for an appearance filename
#define THEME_EXT L".msstyles"
// the following is a Windows Classic color scheme or a THEME_EXT file name
#define PRE_HC_SCHEME           TEXT("Pre-High Contrast Scheme")
// the following is the color scheme when pre-HC was a .mstheme
#define PRE_HC_THM_COLOR        TEXT("Pre-High Contrast Color")
// the following is the font size when pre-HC was a .mstheme
#define PRE_HC_THM_SIZE         TEXT("Pre-High Contrast Size")
// the following is the wallpaper for pre-HC
#define PRE_HC_WALLPAPER        TEXT("Pre-High Contrast Wallpaper")

// increase this value so we can store a theme filename
#ifdef MAX_SCHEME_NAME_SIZE
#undef MAX_SCHEME_NAME_SIZE
#endif
#define MAX_SCHEME_NAME_SIZE 512

#define ARRAYSIZE(x) sizeof(x)/sizeof(x[0])
/*
 * Note -- this must match the desktop applet
 */

#define SCHEME_VERSION 2        // Ver 2 == Unicode
typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATA;

typedef DWORD (WINAPI* PFNDIALOGRTN)(BOOL);
PFNDIALOGRTN g_aRtn[] = {
    NULL,
    StickyKeysNotification,   //ACCESS_STICKYKEYS
    FilterKeysNotification,   //ACCESS_FILTERKEYS
    ToggleKeysNotification,   //ACCESS_TOGGLEKEYS
    MouseKeysNotification,    //ACCESS_MOUSEKEYS
    HighContNotification, //ACCESS_HIGHCONTRAST
};


/***************************************************************************
 * GetRegValue
 *
 * Passed the key, and the identifier, return the string data from the
 * registry.
 ***************************************************************************/
 long GetRegValue(LPWSTR RegKey, LPWSTR RegEntry, LPWSTR RegVal, long Size)
{
    HKEY  hReg;       // Registry handle for schemes
    DWORD Type;       // Type of value
    long retval;

    retval = RegCreateKey(HKEY_CURRENT_USER, RegKey, &hReg);
    if (retval != ERROR_SUCCESS)
        return retval;

    retval = RegQueryValueEx(hReg,
        RegEntry,
        NULL,
        (LPDWORD)&Type,
        (LPBYTE)RegVal,
        &Size);

    RegCloseKey(hReg);
    return retval;
}

/***************************************************************************
 * SetRegValue
 *
 * Passed the key, and the identifier, set the string data from the
 * registry.
 ***************************************************************************/
long SetRegValue(LPTSTR RegKey, LPWSTR RegEntry, LPVOID RegVal, long Size, DWORD Type)
{
    HKEY  hReg;                                // Registry handle for schemes
    DWORD Reserved = 0;
    long retval;

    if (RegCreateKey(HKEY_CURRENT_USER,RegKey, &hReg) != ERROR_SUCCESS)
        return 0;

    // A common error is to omit the `+1', so we just smash the correct
    // value into place regardless.
    if (Type == REG_SZ)
        Size = (lstrlen(RegVal) + 1) * sizeof(WCHAR);

    retval = RegSetValueEx(hReg,
                     RegEntry,
                     0,
                     Type,
                     RegVal,
                     Size);


    RegCloseKey(hReg);
    return retval;
 }


/***************************************************************************
 * SaveAndRemoveWallpaper
 * 
 * Gets the current wallpaper setting from the system and saves it in the
 * accessibility registry entries.  No error return as there isn't anything
 * we can do.
 *
 * ISSUE we aren't getting all the active desktop properties; just wallpaper.
 * This isn't a regression in that we didn't even restore wallpaper in W2K.
 *
 ***************************************************************************/
void SaveAndRemoveWallpaper()
{
    WCHAR szWallpaper[MAX_SCHEME_NAME_SIZE] = {0};
    IActiveDesktop *p;
    HRESULT hr;

    hr = CoCreateInstance(
                  &CLSID_ActiveDesktop
                , NULL
                , CLSCTX_INPROC_SERVER
                , &IID_IActiveDesktop
                , (void **)&p);
    if (SUCCEEDED(hr))
    {
        hr = p->lpVtbl->GetWallpaper(p, szWallpaper, MAX_SCHEME_NAME_SIZE, 0);
        if (SUCCEEDED(hr))
        {
            // save the current wallpaper setting

            SetRegValue(HC_KEY, PRE_HC_WALLPAPER, szWallpaper, 0, REG_SZ);
            
            // now remove the wallpaper, if necessary

            if (szWallpaper[0])
            {
                szWallpaper[0] = 0;
                hr = p->lpVtbl->SetWallpaper(p, szWallpaper, 0);
                if (SUCCEEDED(hr))
                    hr = p->lpVtbl->ApplyChanges(p, AD_APPLY_ALL);
            }
        }
        p->lpVtbl->Release(p);
    }
}

/***************************************************************************
 * RestoreWallpaper
 *
 * Restores the pre-high contrast wallpaper setting.  Reads the setting
 * stored in the accessibility registry entries and restores the system
 * setting.  No error return as there isn't anything we can do.
 * 
 ***************************************************************************/
void RestoreWallpaper()
{
    long lRv;
    TCHAR szWallpaper[MAX_SCHEME_NAME_SIZE] = {0};

    lRv = GetRegValue(HC_KEY, PRE_HC_WALLPAPER, szWallpaper, MAX_SCHEME_NAME_SIZE);
    if (lRv == ERROR_SUCCESS && szWallpaper[0])
    {
        IActiveDesktop *p;
        HRESULT hr;

        hr = CoCreateInstance(
                      &CLSID_ActiveDesktop
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , &IID_IActiveDesktop
                    , (void **)&p);
        if (SUCCEEDED(hr))
        {
            hr = p->lpVtbl->SetWallpaper(p, szWallpaper, 0);
            if (SUCCEEDED(hr))
                hr = p->lpVtbl->ApplyChanges(p, AD_APPLY_ALL);

            p->lpVtbl->Release(p);
        }
    }
}

/***************************************************************************
 * AppearanceRestored
 *
 * lpszName  [in] the name of a theme file (mstheme).  
 * 
 * Function returns TRUE if lpszName is a theme file and it was restored
 * otherwise it returns FALSE.  May return TRUE if restoring the theme
 * fails (not much we can do if theme api's fail).
 * 
 ***************************************************************************/
BOOL AppearanceRestored(LPCWSTR lpszName)
{
    HRESULT hr;
    HTHEMEFILE hThemeFile;
    int cch = lstrlen(lpszName) - lstrlen(THEME_EXT);
    TCHAR szColor[MAX_SCHEME_NAME_SIZE] = {0};
    TCHAR szSize[MAX_SCHEME_NAME_SIZE] = {0};

    if (cch <= 0 || lstrcmpi(&lpszName[cch], THEME_EXT))
    {
        DBPRINTF(TEXT("AppearanceRestored:  %s is not a theme file\r\n"), lpszName);
        return FALSE;   // this isn't a theme file
    }

    // This is a theme file, get the color and size parts of the theme

    GetRegValue(HC_KEY, PRE_HC_THM_COLOR, szColor, ARRAYSIZE(szColor));
    GetRegValue(HC_KEY, PRE_HC_THM_SIZE, szSize, ARRAYSIZE(szSize));

    // Load the theme file, color and size then apply it
    hr = OpenThemeFile(lpszName, szColor, szSize, &hThemeFile, TRUE);
    DBPRINTF(TEXT("AppearanceRestored:  OpenThemeFile(%s, %s, %s) returned 0x%x\r\n"), lpszName, szColor, szSize, hr);
    if (SUCCEEDED(hr))
    {
        hr = ApplyTheme(hThemeFile, AT_LOAD_SYSMETRICS | AT_SYNC_LOADMETRICS, NULL);
        DBPRINTF(TEXT("AppearanceRestored:  ApplyTheme() returned 0x%x\r\n"), hr);
        CloseThemeFile(hThemeFile);
    }

    return TRUE;
}

/***************************************************************************
 * DelRegValue
 *
 * Passed the key and the subkey, delete the subkey.
 *
 ***************************************************************************/
long DelRegValue(LPTSTR RegKey, LPTSTR RegEntry)
{
    HKEY  hReg;                                // Registry handle for schemes
    DWORD Reserved = 0;
    long retval;

    retval = RegCreateKey(HKEY_CURRENT_USER,RegKey, &hReg);
    if (retval != ERROR_SUCCESS)
        return retval;

    retval = RegDeleteValue(hReg, RegEntry);

    RegCloseKey(hReg);
    return retval;
}

#define COLOR_MAX_400       (COLOR_INFOBK + 1)
void FAR SetMagicColors(HDC, DWORD, WORD);


/***************************************************************************
 *
 *
 * SetCurrentSchemeName
 *
 * Input: szName -> name of scheme or theme to become current
 * Output: Boolean success/failure
 *
 ***************************************************************************/

typedef LONG (CALLBACK *APPLETPROC)(HWND, UINT, LPARAM, LPARAM);
typedef BOOL (CALLBACK *SETSCHEME)(LPCTSTR);
typedef BOOL (CALLBACK *SETSCHEMEA)(LPCSTR);

BOOL SetCurrentSchemeName(LPCWSTR lpszName, BOOL fNoReg)
{
    BOOL fRc = FALSE;

    if (fNoReg) 
    {
        // Setting a non-persistent scheme; we come to this code path for
        // both setting or unsetting HC via hot keys

        HKEY hkSchemes;

        // For Whistler, because it may confuse users, we are always turning off
        // theming and any wallpaper.  Otherwise, sometimes they'll loose these
        // settings (when they log off and log back on) and sometimes they won't
        // (when they use the hot keys to turn HC off).

        DBPRINTF(TEXT("SetCurrentSchemeName:  To %s w/o persisting to registry\r\n"), lpszName);
        if (IsThemeActive())
        {
            DBPRINTF(TEXT("SetCurrentSchemeName:  Turning off active Themes\r\n"));
            ApplyTheme(NULL, 0, NULL);
        }

        if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_LOOKSCHEMES, &hkSchemes) == ERROR_SUCCESS) {
            SCHEMEDATA sd;
            DWORD dwType, dwSize;
            BOOL b;
            HDC  hdc;
            int iColors[COLOR_MAX];
            int i;
            COLORREF rgbColors[COLOR_MAX];

            dwType = REG_BINARY;
            dwSize = sizeof(sd);
            if (RegQueryValueEx(hkSchemes, lpszName, NULL, &dwType, (LPBYTE)&sd, &dwSize) == ERROR_SUCCESS) {
                int n;
                if (sd.version != SCHEME_VERSION) {
                    RegCloseKey(hkSchemes);
                    return FALSE;
                    }
                n = (int)(dwSize - (sizeof(sd) - sizeof(sd.rgb))) / sizeof(COLORREF);

                sd.ncm.cbSize = sizeof(NONCLIENTMETRICS);

                b = SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(sd.ncm),
                    (void far *)&sd.ncm,
                    0);

                b = SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(LOGFONT),
                    (void far *)(LPLOGFONT)&sd.lfIconTitle,
                    0);

                if (n == COLOR_MAX_400)
                {
                    sd.rgb[COLOR_HOTLIGHT] = sd.rgb[COLOR_ACTIVECAPTION];
                    sd.rgb[COLOR_GRADIENTACTIVECAPTION] = RGB(0,0,0);
                    sd.rgb[COLOR_GRADIENTINACTIVECAPTION] = RGB(0,0,0);
                }

#if(WINVER >= 0x0501)
                // new Whistler colors
                sd.rgb[COLOR_MENUBAR] = sd.rgb[COLOR_MENU];
                sd.rgb[COLOR_MENUHILIGHT] = sd.rgb[COLOR_MENUTEXT];

                // reset "flatmenu" and "dropshadows" settings 
                SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);
                SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);
#endif /* WINVER >= 0x0501 */

            //
            // restore magic colors back to Win31 defaults.
            //
                hdc = GetDC(NULL);
                SetMagicColors(hdc, 0x00c0dcc0, 8);         // money green
                SetMagicColors(hdc, 0x00f0caa6, 9);         // IBM blue
                SetMagicColors(hdc, 0x00f0fbff, 246);       // off white
                ReleaseDC(NULL, hdc);

                for (i=0; i<COLOR_MAX; i++)
                {
                    iColors[i] = i;
                    rgbColors[i] = sd.rgb[i] & 0x00FFFFFF;
                }

                SetSysColors(COLOR_MAX, iColors, rgbColors);
                SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, 0, SMTO_ABORTIFHUNG, 5000, NULL);
            }
            RegCloseKey(hkSchemes);
           fRc = TRUE;
        }
    } else 
    {
        /*
         * We need to persist this setting.  First see if lpszName is a
         * theme file and restore it if it is
         */
        fRc = AppearanceRestored(lpszName);
        if (!fRc)
        {
            /*
             * The user is in "Windows Classic" appearance so use desk CPL to restore
             */
            HINSTANCE hinst = LoadLibrary(TEXT("DESK.CPL"));
            if (NULL != hinst) 
            {
                APPLETPROC ap = (APPLETPROC)GetProcAddress((HMODULE)hinst, "CPlApplet");
                if (ap) 
                {
                    if (ap(0, CPL_INIT, 0, 0)) 
                    {
                        SETSCHEME ss = (SETSCHEME)GetProcAddress(hinst, "DeskSetCurrentSchemeW");
                        if (ss) 
                        {
                            fRc = ss(lpszName);
                            DBPRINTF(TEXT("SetCurrentSchemeName:  DeskSetCurrentSchemeW(%s) returned %d\r\n"), lpszName, fRc);
                        }

                        ap(0, CPL_EXIT, 0, 0);
                    }
                }
                FreeLibrary(hinst);
            }
        }
    }

    return fRc;
}

/***************************************************************************
 *
 * GetCurrentSchemeName
 *
 * szBuf     [out] Buffer to receive name of scheme (MAXSCHEMENAME) or theme file
 * ctchBuf   [in]  Size of szBuf
 * szColor   [out] If szBuf is a theme file, the color scheme name
 * ctchColor [in]  Size of szColor
 * szSize    [out] If szBuf is a theme file, the font size
 * ctchSize  [in]  Size of szSize
 *
 *     Returns the name of the current scheme.  This will be either the name
 *     of a theme file (if Professional visual style is on) or the name of
 *     a color scheme (if Windows Classic visual style is on).  If the 
 *     current scheme does not have a name, create one (ID_PRE_HC_SCHEME).
 *
 *     If anything goes wrong, there isn't much we can do.
 *
 ***************************************************************************/

void GetCurrentSchemeName(LPTSTR szBuf, long ctchBuf, LPTSTR szColor, long ctchColor, LPTSTR szSize, long ctchSize)
{
    HRESULT hr;

    // First try to get a theme filename

    hr = GetCurrentThemeName(szBuf, ctchBuf, szColor, ctchColor, szSize, ctchSize);
    if (FAILED(hr))
    {
        // User is in Windows Classic appearance (visual style)

        szColor[0] = 0;
        szSize[0] = 0;

        if (GetRegValue(DEFSCHEMEKEY, DEFSCHEMENAME, szBuf, MAX_SCHEME_NAME_SIZE * sizeof(WCHAR))
                       != ERROR_SUCCESS) 
        {
            SCHEMEDATA scm;
            int i;

            /* Load the current scheme into scm */
            scm.version = SCHEME_VERSION;
            scm.wDummy = 0;
            scm.ncm.cbSize = sizeof(NONCLIENTMETRICS);
            SystemParametersInfo(SPI_GETNONCLIENTMETRICS,
                sizeof(NONCLIENTMETRICS),
                &scm.ncm,
                0);

            SystemParametersInfo(SPI_GETICONTITLELOGFONT,
                sizeof(LOGFONT),
                &scm.lfIconTitle,
                0);

            for (i = 0; i < COLOR_MAX; i++) {
                scm.rgb[i] = GetSysColor(i);
            }

            /* Now give it a name */
            SetRegValue(APPEARANCESCHEME, PRE_HC_SCHEME, &scm, sizeof(scm), REG_BINARY);
            /*
             * NOTE -- PRE_HC_SCHEME in APPEARANCESCHEME is actual scheme data, NOT a scheme
             *         name,  This data has info about settings if the user did not have a
             *         desktop scheme in place before switching to high contrast mode.
             */

            wcscpy(szBuf, PRE_HC_SCHEME);
        }
    }
}

void WINAPI RegQueryStr(
   LPWSTR lpDefault,
   HKEY hkey, 
   LPWSTR lpSubKey,
   LPWSTR lpValueName,
   LPWSTR lpszValue,
   DWORD cbData) // note this is bytes, not characters.
{
   DWORD dwType;

   lstrcpy(lpszValue, lpDefault);
   if (ERROR_SUCCESS == RegOpenKeyEx(hkey, lpSubKey, 0, KEY_QUERY_VALUE, &hkey)) {
      RegQueryValueEx(hkey, lpValueName, NULL, &dwType, (PBYTE) lpszValue, &cbData);
      RegCloseKey(hkey);
   }
}

DWORD WINAPI RegQueryStrDW(
    DWORD dwDefault,
    HKEY hkey, 
    LPWSTR lpSubKey,
    LPWSTR lpValueName)
{
    DWORD dwRet = dwDefault;    
    WCHAR szTemp[40];
    WCHAR szDefault[40];

    const LPWSTR pwszd = TEXT("%d");

    wsprintf(szDefault, pwszd, dwDefault);

    RegQueryStr(
        szDefault, 
        hkey, 
        lpSubKey, 
        lpValueName,
        szTemp, 
        sizeof(szTemp));


    dwRet = _wtoi(szTemp);
    return dwRet;
}

/***************************************************************************
 *
 *
 * SetHighContrast
 *
 * Input: None
 * Output: None
 *
 * Outline:
 *
 ***************************************************************************/

int SetHighContrast(BOOL fEnabledOld, BOOL fNoReg)
{
    BOOL fOk = 0;
    TCHAR szBuf[MAX_SCHEME_NAME_SIZE];
    TCHAR szColor[MAX_SCHEME_NAME_SIZE];
    TCHAR szSize[MAX_SCHEME_NAME_SIZE];
    HIGHCONTRAST hc;

    szBuf[0] = TEXT('\0');

    if (!fEnabledOld)
    {
        /*
         * Get the current scheme information (create it if necessary)
         * Note -- we need to put this in the registry, even in "no registry"
         * cases, so we can restore the values.
         */
        GetCurrentSchemeName(szBuf, MAX_SCHEME_NAME_SIZE, szColor, MAX_SCHEME_NAME_SIZE, szSize, MAX_SCHEME_NAME_SIZE);
        DBPRINTF(TEXT("SetHighContrast:  Save to registry ThemeFile=%s Color=%s Size=%s\r\n"), szBuf, szColor, szSize);
        SetRegValue(HC_KEY, PRE_HC_SCHEME, szBuf, 0, REG_SZ); /* Save it */
        SetRegValue(HC_KEY, PRE_HC_THM_COLOR, szColor, 0, REG_SZ);
        SetRegValue(HC_KEY, PRE_HC_THM_SIZE, szSize, 0, REG_SZ);
        /*
         * NOTE -- PRE_HC_SCHEME in HC_KEY is the NAME of the scheme (which may be a made-up
         *         name) holding the settings before High Contrast was invoked.
         */
    }

    hc.cbSize = sizeof(hc);

    SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof hc, &hc, 0);
    if ((NULL != hc.lpszDefaultScheme) && (TEXT('\0') != *(hc.lpszDefaultScheme)))
    {
        lstrcpy(szBuf, hc.lpszDefaultScheme);
    }
    else
    {
       /*
        *  Get the name of the HC scheme.  By design, we have to look
        *  in about fifty places...  We get the default one first, then try
        * to get better and better ones.  That way, when we're done, we have
        *  the best one that succeeded.
        */
        lstrcpy(szBuf, WHITEBLACK_HC);
        GetRegValue(HC_KEY, HIGHCONTRASTSCHEME, szBuf, sizeof(szBuf));
        GetRegValue(DEFSCHEMEKEY, CURHCSCHEME, szBuf, sizeof(szBuf));
    }
    fOk = SetCurrentSchemeName(szBuf, fNoReg);
    if (fOk)
        SaveAndRemoveWallpaper();

    return (short)fOk;
}



/***************************************************************************
 *
 *
 * ClearHighContrast
 *
 * Input: None
 * Output: None
 *
 * Outline:
 *
 *         If high contrast is currently on:
 *
 *                 Get the PRE_HC_SCHEME.
 *
 *                 If able to get it:
 *
 *                         Make it the current scheme.
 *
 *                         If the name is IDS_PRE_HC_SCHEME, then delete the scheme
 *                         data and set the current scheme name to null.  (Clean up.)
 *
 *                 End if
 *
 *                 Set the key that says that high contrast is now off.
 *
 *         End if
 *
 ***************************************************************************/

BOOL FAR PASCAL ClearHighContrast(BOOL fNoReg)
{
    BOOL fOk = FALSE;
    WCHAR szBuf[MAX_SCHEME_NAME_SIZE];

    szBuf[0] = '\0';
    if (ERROR_SUCCESS == GetRegValue(HC_KEY, PRE_HC_SCHEME, szBuf, sizeof(szBuf)))
    {
        DBPRINTF(TEXT("ClearHighContrast:  Reset to pre-HC scheme %s\r\n"), szBuf);
        fOk = SetCurrentSchemeName(szBuf, fNoReg);    // reset the scheme

        // If persisting this setting, wallpaper may need to be restored.
        // If clearing a temporary setting then, to avoid user confusion,
        // we turned theming and wallpaper off permanently.  Otherwise, 
        // sometimes they'll loose these settings (when they log off and 
        // log back on) and sometimes they won't (when they use the hot
        // keys to turn HC off).

        if (!fNoReg)
        {
            RestoreWallpaper();
            if (lstrcmpi(szBuf, PRE_HC_SCHEME) == 0) 
            {
                DelRegValue(APPEARANCESCHEME, PRE_HC_SCHEME);
                DBPRINTF(TEXT("DelRegValue(%s, %s)\r\n"), APPEARANCESCHEME, PRE_HC_SCHEME);
                DelRegValue(DEFSCHEMEKEY, DEFSCHEMENAME);
                DBPRINTF(TEXT("DelRegValue(%s, %s)\r\n"), DEFSCHEMEKEY, DEFSCHEMENAME);
            }
        }
    }

    return fOk;
}


#if NEED_MSG_PUMP
/***************************************************************************\
*  WndProc
*
*  Processes messages for the main window.
\***************************************************************************/
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message) 
	{
        case WM_TIMER:
        if (wParam == 1)
        {
            KillTimer(hWnd, wParam);
            DBPRINTF(TEXT("WM_TIMER\r\n"));
            DestroyWindow(hWnd);
        }
        break;

		case WM_DESTROY:
		PostQuitMessage(0);
		break;

		default:
		return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
#endif

/***************************************************************************\
* WinMain
*
* History:
* 02-01-97  Fritz Sands  Created
* 12-19-00  micw added windowing code so theming calls would work
\***************************************************************************/
int WINAPI WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow)
{
#if NEED_MSG_PUMP
	MSG msg;
	WNDCLASSEX wcex;
    LPTSTR pszWindowClass = TEXT("SetHC"); // message-only window doesn't need localization
    HWND hWnd;
#endif
	UINT index;
	BOOL fSet, fWasSet, fNoReg;


    CoInitialize(NULL);
    
	// Safety checks to make sure that it is not run from command line
	// Should have 3 characters, And all of them numeric...:a-anilk
	if ( strlen(lpszCmdParam) != 3 )
		return 0;

	for ( index = 0; index < 3 ; index++ )
    {
	  if ( lpszCmdParam[index] < '0' || lpszCmdParam[index] > '9' )
      {
		  return 0;
      }
    }
    
	fSet = lpszCmdParam[0] - '0';
    fWasSet = lpszCmdParam[1] - '0';
    fNoReg = lpszCmdParam[2] - '0';
    DBPRINTF(TEXT("WinMain:  fSet=%d fWasSet=%d fNoReg=%d\r\n"), fSet, fWasSet, fNoReg);
    
    // this is to deal with HighContrast, StickyKey, ToggleKey, FilterKey and MouseKeys
    if ( fSet == 2 )
    {
        // this is which Dialog will be displayed 
        LONG lPopup = lpszCmdParam[1] - '0';

        // This indicate wheather we will actually display the dialog or just do the work without asking
        BOOL fNotify = lpszCmdParam[2] - '0';

        DBPRINTF(TEXT("WinMain:  lPopup=%d fNotify=%d\r\n"), lPopup, fNotify );

        // Make sure we don't access outside the bounds of the funtion pointer array
        if ( lPopup < 1 || lPopup > 5 )
            return 0;

        // Index into a table of functions pointers and call the 
        // funtion to bring up the right hotkey dialog.
        g_aRtn[lPopup]( fNotify );
        	
        CoUninitialize();
        return 1;
    }

#if NEED_MSG_PUMP
    // Create a message only window to process messages from theme api

	wcex.cbSize         = sizeof(WNDCLASSEX); 
	wcex.style			= 0;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= NULL;
	wcex.hCursor		= NULL;
	wcex.hbrBackground	= NULL;
	wcex.lpszMenuName	= NULL;
	wcex.lpszClassName	= pszWindowClass;
	wcex.hIconSm		= NULL;

	RegisterClassEx(&wcex);

    hWnd = CreateWindow(pszWindowClass,NULL,0,0,0,0,0,HWND_MESSAGE,NULL,hInstance,NULL);
    if (!hWnd)
    {
        return 0;
    }
#endif

    if (fSet) 
    {
        SetHighContrast(fWasSet, fNoReg);
    }
    else
    {
        ClearHighContrast(fNoReg);
    }

#if NEED_MSG_PUMP

    SetTimer(hWnd, 1, 4000, NULL);

	// The calls to set/unset visual style require that messages
    // be processed.  When the timer goes we'll exit.

	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
#endif

    CoUninitialize();
    return 1;
}

#ifdef DEBUG
void MyOutputDebugString( LPCTSTR lpOutputString, ...)
{
    TCHAR achBuffer[500];
    /* create the output buffer */
    va_list args;
    va_start(args, lpOutputString);
    wvsprintf(achBuffer, lpOutputString, args);
    va_end(args);

    OutputDebugString(achBuffer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\rsopreg\rsopreg.cpp ===
//*************************************************************
//  File name: RSOPREG.CPP
//
//  Description:  A small command line utility that shows how
//                to query for all the registry policy objects
//                in a WMI namespace
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <ole2.h>
#include <wbemcli.h>
#include <tchar.h>
#include <stdio.h>


//*************************************************************
//
//  EnumObjects()
//
//  Purpose:    Enumerates the given namespace for all registry
//              policy objects
//
//  Parameters: pIWbemServices - Interface pointer to the namespace
//
//  Return:     void
//
//*************************************************************

void EnumObjects (IWbemServices * pIWbemServices)
{
    BSTR pLanguage = NULL, pQuery = NULL, pValueName = NULL, pRegistryKey = NULL;
    IEnumWbemClassObject * pEnum;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varRegistryKey, varValueName;
    ULONG ulCount = 0;


    //
    // Print heading
    //

    _tprintf (TEXT("\n\nRegistry objects in the RSOP\\User namespace:\n\n"));


    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));
    pQuery = SysAllocString (TEXT("SELECT * FROM RSOP_RegistryPolicySetting"));


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pRegistryKey = SysAllocString (TEXT("registryKey"));
    pValueName = SysAllocString (TEXT("valueName"));


    //
    // Check if the allocations succeeded
    //

    if (pLanguage && pQuery && pRegistryKey && pValueName)
    {

        //
        // Execute the query
        //

        hr = pIWbemServices->ExecQuery (pLanguage, pQuery, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                        NULL, &pEnum);

        if (SUCCEEDED(hr))
        {

            //
            // Loop through the results retreiving the registry key and value names
            //

            while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet) == S_OK)
            {
                hr = pObjects[0]->Get (pRegistryKey, 0, &varRegistryKey, NULL, NULL);

                if (SUCCEEDED(hr))
                {
                    hr = pObjects[0]->Get (pValueName, 0, &varValueName, NULL, NULL);

                    if (SUCCEEDED(hr))
                    {

                        //
                        // Print the key / value names
                        //

                        _tprintf (TEXT("    %s\\%s\n"), varRegistryKey.bstrVal, varValueName.bstrVal);
                        VariantClear (&varValueName);
                    }

                    VariantClear (&varRegistryKey);
                }

                ulCount++;
            }

            if (ulCount == 0)
            {
                _tprintf (TEXT("\tNo registry objects found\n"));
            }

            pEnum->Release();
        }
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pRegistryKey)
    {
        SysFreeString (pRegistryKey);
    }

    if (pValueName)
    {
        SysFreeString (pValueName);
    }

}


//*************************************************************
//
//  main()
//
//  Purpose:    Entry point of this application
//
//  Parameters: argc & argv
//
//  Return:     0
//
//*************************************************************

int __cdecl main( int argc, char *argv[])
{
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    BSTR pNamespace = NULL;
    HRESULT hr;


    //
    // Initialize COM
    //

    CoInitialize(NULL);


    //
    // Create the locator interface
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                         IID_IWbemLocator, (LPVOID *) &pIWbemLocator);

    if (hr != S_OK)
    {
        _tprintf(TEXT("CoCreateInstance failed with 0x%x\n"), hr);
        goto Exit;
    }


    //
    // Using the locator, connect to the RSOP user namespace
    //

    pNamespace = SysAllocString(TEXT("root\\rsop\\user"));

    if (pNamespace)
    {
        hr = pIWbemLocator->ConnectServer(pNamespace,
                                        NULL,   //using current account for simplicity
                                        NULL,   //using current password for simplicity
                                        0L,             // locale
                                        0L,             // securityFlags
                                        NULL,   // authority (domain for NTLM)
                                        NULL,   // context
                                        &pIWbemServices);

        if (hr != S_OK)
        {
            _tprintf(TEXT("ConnectServer failed with 0x%x\n"), hr);
            goto Exit;
        }


        EnumObjects (pIWbemServices);
    }

Exit:

    if (pNamespace)
    {
        SysFreeString(pNamespace);
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    CoUninitialize ();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\shutdown\main.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <initguid.h>
#include <windowsx.h>
#include <winuserp.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <lm.h>

#include <shlobj.h>
#include <Cmnquery.h>
#include <dsclient.h>
#include <Dsquery.h>

#include <reason.h>
#include "resource.h"

//#define SNAPSHOT_TEST
#ifdef SNAPSHOT_TEST
#define TESTMSG(x) \
	WriteToConsole((x))
#else
#define TESTMSG(x)
#endif //SNAPSHOT_TEST
//
//	Default warning state for warning user check button
//
#define		DEFAULTWARNINGSTATE BST_CHECKED

#define		TITLEWARNINGLEN 32

//
//	Name of the executable
//
LPWSTR		g_lpszProgramName = NULL;

//
//	Enum for all of the actions.
//
enum 
{
	ACTION_SHUTDOWN = 0,
	ACTION_RESTART = 1,
	ACTION_LOGOFF,
	ACTION_STANDBY,
	ACTION_DISCONNECT,
	ACTION_ABORT
};

//
//	Resource IDs for actions.
//
DWORD g_dwActions[] = 
{
	IDS_ACTION_SHUTDOWN,
	IDS_ACTION_RESTART,
	IDS_ACTION_LOGOFF
	//IDS_ACTION_STANDBY,
	//IDS_ACTION_DISCONNECT,
	//IDS_ACTION_ABORT
};

//
//	Number of actions and the action strings loaded from resource.
//
const int	g_nActions = sizeof(g_dwActions) / sizeof(DWORD);
WCHAR		g_lppszActions[g_nActions][MAX_PATH];

LPWSTR		g_lpszNewComputers = NULL;
WCHAR		g_lpszDefaultDomain[MAX_PATH] = L"";
WCHAR		g_lpszLocalComputerName[MAX_PATH] = L"";
WCHAR		g_lpszTitleWarning[TITLEWARNINGLEN];
BOOL		g_bAssumeShutdown = FALSE;

struct _PROVIDER{
	LPWSTR	szName;
	DWORD	dwLen;
};

typedef struct _SHUTDOWNREASON
{
	DWORD dwCode;
	WCHAR lpName[MAX_REASON_NAME_LEN + 1];
	WCHAR lpDesc[MAX_REASON_DESC_LEN + 1];
} SHUTDOWNREASON, *PSHUTDOWNREASON;

PSHUTDOWNREASON g_lpReasons = NULL;
DWORD		g_dwReasons = 0;
DWORD		g_dwReasonSelect;
DWORD		g_dwActionSelect;

typedef struct _SHUTDOWNCACHEDHWNDS
{
	HWND hwndShutdownDialog;
	HWND hwndListSelectComputers;
	HWND hwndEditComment;
	HWND hwndStaticDesc;
	HWND hwndEditTimeout;
	HWND hwndButtonWarning;
	HWND hwndComboAction;
	HWND hwndComboOption;
	HWND hwndBtnAdd;
	HWND hwndBtnRemove;
	HWND hwndBtnBrowse;
	HWND hwndChkPlanned;
	HWND hwndButtonOK;
} SHUTDOWNCACHEDHWNDS, *PSHUTDOWNCACHEDHWNDS;

SHUTDOWNCACHEDHWNDS g_wins;

HMODULE		g_hDllInstance = NULL;
typedef		BOOL (*REASONBUILDPROC)(REASONDATA *, BOOL, BOOL);
typedef		VOID (*REASONDESTROYPROC)(REASONDATA *);

BOOL		GetNetworkComputers(HWND hwndList, HWND hwndProgress, LPCWSTR lpDomain);
BOOL		GetComputerNameFromPath(LPWSTR szPath, LPWSTR szName);
VOID		AdjustWindowState();
INT_PTR 
CALLBACK	Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR 
CALLBACK	AddNew_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR 
CALLBACK	Browse_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
BOOL		Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
BOOL		AddNew_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
BOOL		Browse_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
BOOL		Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
BOOL		Browse_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

typedef         void (*PSetThreadUILanguage)(DWORD);


//
//	Check whether a string is all white spaces.
//
BOOL 
IsEmpty(LPCWSTR lpCWSTR)
{
	if(!lpCWSTR)
		return TRUE;
	while(*lpCWSTR && (*lpCWSTR == '\n' || *lpCWSTR == '\t' || *lpCWSTR == '\r' || *lpCWSTR == ' '))
		lpCWSTR++;
	if(*lpCWSTR)
		return FALSE;
	return TRUE;
}

// Write the string to console
VOID
WriteToConsole(
    LPWSTR  pszMsg
    )
{
	HANDLE	hConsole = GetStdHandle( STD_OUTPUT_HANDLE );

    if ( !pszMsg || !*pszMsg )
        return;

    DWORD   dwStrLen        = lstrlenW( pszMsg );
    LPSTR   pszAMsg         = NULL;
    DWORD   dwBytesWritten  = 0;
    DWORD   dwMode          = 0;

    if ( (GetFileType ( hConsole ) & FILE_TYPE_CHAR ) && 
         GetConsoleMode( hConsole, &dwMode ) )
    {
         WriteConsoleW( hConsole, pszMsg, dwStrLen, &dwBytesWritten, 0 );
         return;
    } 	
    
    // console redirect to a file.
    if ( !(pszAMsg = (LPSTR)LocalAlloc(LMEM_FIXED, (dwStrLen + 1) * sizeof(WCHAR) ) ) )
    {
        return;
    }

    if (WideCharToMultiByte(GetConsoleOutputCP(),
                                    0,
                                    pszMsg,
                                    -1,
                                    pszAMsg,
                                    dwStrLen * sizeof(WCHAR),
                                    NULL,
                                    NULL) != 0 
									&& hConsole)
    {
        WriteFile(  hConsole,
                        pszAMsg,
                        lstrlenA(pszAMsg),
                        &dwBytesWritten,
                        NULL );
    
    }
    
    LocalFree( pszAMsg );
}


// Report error.
VOID
report_error(
    DWORD error_code
    )
{
    LPVOID msgBuf = 0;
    FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        error_code,
        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
        reinterpret_cast< wchar_t* >( &msgBuf ),
        0,
        NULL);

    //fwprintf( stderr, L"%s : %s\n", g_lpszProgramName, reinterpret_cast< wchar_t* >( msgBuf ));
    WriteToConsole( reinterpret_cast<wchar_t*> (msgBuf) ); 
	    
    LocalFree( msgBuf );
}


BOOL
parse_reason_code(
    LPCWSTR  arg,
    LPDWORD  lpdwReason
    )
{
    // Code consists of flags:major:minor
    int major = 0;
    int minor = 0;

    const int state_start = 0;
    const int state_flags = 0;
    const int state_major = 1;
    const int state_minor = 2;
    const int state_null = 3;
    const int state_done = 4;

    for( int i = 0, state = state_start; state != state_done; ++i )
    {
        switch( state )
        {
        case state_flags :
            // Expecting flags
            switch( arg[ i ] ) {
            case L'U' : case L'u' :
                *lpdwReason |= 0x40000000; // SHTDN_REASON_FLAG_USER_DEFINED
                break;
            case L'P' : case L'p' :
                *lpdwReason |= 0x80000000; // SHTDN_REASON_FLAG_PLANNED
                break;
            case L':' :
                state = state_major;
                break;
            case 0 : 
                // End of string (use default major and minor).
                state = state_done;
                break;
            default :
                return FALSE;
            }
            break;
        case state_major :
            // Expecting major
            if( arg[ i ] >= L'0' && arg[ i ] <= L'9' ) {
                major = major * 10 + arg[ i ] - L'0';
            }
            else {
                // Make sure we only have 8 bits
                if( major > 0xff ) return FALSE;
                *lpdwReason |= major << 16;
                if( arg[ i ] == 0 ) {
                    // use default minor reason.
                    state = state_done;
                }
                if( arg[ i ] == L':' ) {
                    state = state_minor;
                }
                else return FALSE;
            }
            break;
        case state_minor :
            // Expecting minor reason
            // Expecting major
            if( arg[ i ] >= L'0' && arg[ i ] <= L'9' ) {
                minor = minor * 10 + arg[ i ] - L'0';
            }
            else {
                // Make sure we only have 8 bits
                if( minor > 0xffff ) return FALSE;
                *lpdwReason = ( *lpdwReason & 0xffff0000 ) | minor;
                if( arg[ i ] == 0 ) {
                    return state_done;
                }
                if( arg[ i ] == L':' ) {
                    state = state_null;
                }
                else return FALSE;
            }
            break;
        case state_null :
            // Expecting end of string
            if( arg[ i ] != 0 ) return FALSE;
            state = state_done;
        default :
            return FALSE;
        }
    }
    return TRUE;
}


// Parses an integer if it is in decimal notation.
// Returns FALSE if it is malformed.
BOOL
parse_int(
    const wchar_t* arg,
    LPDWORD lpdwInt
    )
{
    *lpdwInt = 0;
    while( *arg ) {
        if( *arg >= L'0' && *arg <= L'9' ) {
            *lpdwInt = *lpdwInt * 10 + int( *arg++ - L'0' );
        }
        else {
            return FALSE;
        }
    }
    return TRUE;
}

// Parse options.
// Returns FALSE if the option strings are malformed.  This causes the usage to be printed.
BOOL
parse_options(
    int      argc,
    wchar_t  *argv[],
    LPBOOL   lpfLogoff,
    LPBOOL   lpfForce,
    LPBOOL   lpfReboot,
    LPBOOL   lpfAbort,
    LPWSTR   *ppServerName,
    LPWSTR   *ppMessage,
    LPDWORD  lpdwTimeout,
    LPDWORD  lpdwReason
    )
{
    BOOL  fShutdown = FALSE;

    *lpfLogoff    = FALSE;
    *lpfForce     = FALSE;
    *lpfReboot    = FALSE;
    *lpfAbort     = FALSE;
    *ppServerName = NULL;
    *ppMessage    = NULL;
    *lpdwTimeout  = 30;
    *lpdwReason   = 0xFF;

	//
	//	Set default reason to be planned
	//
	*lpdwReason |= 0x80000000; // SHTDN_REASON_FLAG_PLANNED

    for( int i = 1; i < argc; ++i )
    {
        wchar_t* arg = argv[ i ];

        switch( arg[ 0 ] )
        {
            case L'/' : case L'-' :

                switch( arg[ 1 ] )
                {
                    case L'L' : case L'l' :

                        *lpfLogoff = TRUE;
                        if (arg[2] != 0) return FALSE;
                        break;

                    case L'S' : case L's' :

                        //
                        // Use server name if supplied  (i.e. do nothing here)
                        //

                        fShutdown = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        break;

                    case L'F' : case L'f' :

                        *lpfForce = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        break;

                    case L'R' : case L'r' :

                        *lpfReboot = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        break;

                    case L'A' : case L'a' :

                        *lpfAbort = TRUE;
                        if( arg[ 2 ] != 0 ) return FALSE;
                        break;

                    case L'T' : case L't' :

                        //
                        // Next arg should be number of seconds
                        //

                        if (++i == argc)
                        {
                            return FALSE;
                        }

                        arg = argv[i];

                        if( arg[ 0 ] < L'0' || arg[ 0 ] > L'9' ) return FALSE;
                        if( !parse_int( arg, lpdwTimeout )) return FALSE;
                        break;

                    case L'Y' : case L'y' :

                        // Ignore this option.
                        break;

                    case L'D' : case L'd' :

                        //
                        // Next arg should be reason code
                        //

                        if (++i == argc)
                        {
                            return FALSE;
                        }

                        arg = argv[i];
						
						//
						//If reason code is given, we clear the planned bit.
						//
						*lpdwReason &= ~(0x80000000); // SHTDN_REASON_FLAG_PLANNED

                        if( !parse_reason_code( arg, lpdwReason ))
                        {
                            return FALSE;
                        }

                        break;

                    case L'C' : case L'c' :

                        //
                        // Next arg should be shutdown message.  Make
                        // sure only one is specified.
                        //

                        if (++i == argc || *ppMessage)
                        {
                            return FALSE;
                        }

                        arg = argv[i];

                        *ppMessage = arg;

                        break;

                    case L'M' : case L'm' :

                        //
                        // Next arg should be machine name.  Make
                        // sure only one is specified.
                        //

                        if (++i == argc || *ppServerName)
                        {
                            return FALSE;
                        }

                        arg = argv[i];

                        if (arg[0] == L'\\' && arg[1] == L'\\')
                        {
                            *ppServerName = arg + 2;
                        }
                        else
                        {
                            *ppServerName = arg;
                        }

                        break;

                    case L'H' : case L'h' : case L'?' : default : 

                        return FALSE;
                }

                break;

            default :

                //
                // Junk
                //

                return FALSE;
        }
    }


    //
    // Default is to logoff
    //

    if (!fShutdown && !*lpfReboot && !*lpfAbort)
    {
        *lpfLogoff = TRUE;
    }


    //
    // Check for mutually exclusive options
    //

    if (*lpfAbort && (*lpfLogoff || fShutdown || *lpfReboot || *lpfForce))
    {
        return FALSE;
    }

    if (*lpfLogoff && (*ppServerName || fShutdown || *lpfReboot))
    {
        return FALSE;
    }

    if (fShutdown && *lpfReboot)
    {
        return FALSE;
    }

    return TRUE;
}


// Print out usage help string.
VOID
usage(
    VOID
    )
{
    HMODULE  	hModule = GetModuleHandle( NULL );
    int 	buf_len = MAX_PATH;
    int 	new_len	= 0;
    LPWSTR 	buf	    = NULL;
    LPWSTR 	msg	    = NULL;

    if( hModule == NULL )
    {
        report_error( GetLastError() );
        return;
    }

    buf = (LPWSTR) LocalAlloc(LMEM_FIXED, buf_len * sizeof(WCHAR));

    if (buf == NULL)
    {
        report_error( GetLastError() );
        return;
    }

    new_len = LoadStringW( hModule, IDS_USAGE, buf, buf_len );

    //
    // Since LoadString doesn't tell you how much data you should have
    // if the buffer's too small, retry until we succeed.
    //

    while( new_len + 1 == buf_len )
    {
        LocalFree(buf);
        buf_len *= 2;
        buf = (LPWSTR) LocalAlloc(LMEM_FIXED, buf_len * sizeof(WCHAR));

        if (buf == NULL)
        {
            report_error( GetLastError() );
            return;
        }

        new_len = LoadStringW( hModule, IDS_USAGE, buf, buf_len );
    }

    if( 0 == new_len )
    {
        report_error( GetLastError() );
        LocalFree(buf);
        return;
    }
        
    //fwprintf( stderr, buf, g_lpszProgramName );
    new_len = lstrlenW( buf ) + lstrlenW( g_lpszProgramName ) + 1;	

    if ( msg = (LPWSTR)LocalAlloc(LMEM_FIXED, new_len * sizeof(WCHAR) ) )
    {
	    swprintf(msg, buf, g_lpszProgramName );
	    WriteToConsole( msg );
    }
    else
    {
	    report_error( GetLastError() );
    }

    LocalFree(buf);
    LocalFree(msg);
}


// We need shutdown privileges enabled to be able to shut down our machines.
BOOL
enable_privileges(
    LPCWSTR  lpServerName,
    BOOL     fLogoff 
    )
{
    NTSTATUS	Status = STATUS_SUCCESS;
	NTSTATUS	Status1 = STATUS_SUCCESS;
    BOOLEAN		fWasEnabled;

    if (fLogoff)
    {
        //
        // No privileges to get
        //

        return TRUE;
    }

	//
	//	We will always enable both privileges so 
	//	it can work for telnet sessions.
	//
	Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
									TRUE,
									FALSE,
									&fWasEnabled);

	Status1 = RtlAdjustPrivilege(SE_REMOTE_SHUTDOWN_PRIVILEGE,
									TRUE,
									FALSE,
									&fWasEnabled);

    if (!NT_SUCCESS(Status) || !NT_SUCCESS(Status1))
    {
		report_error(RtlNtStatusToDosError(Status));
		report_error(RtlNtStatusToDosError(Status1));
		return FALSE;
    }

    return TRUE;
}


VOID __cdecl
wmain(
    int      argc,
    wchar_t *argv[]
    )
{
    BOOL    fLogoff;
    BOOL    fForce;
    BOOL    fReboot;
    BOOL    fAbort;
    LPWSTR  lpServerName;
    LPWSTR  lpMessage;
    DWORD   dwTimeout;
    DWORD   dwReason;
	INT_PTR hResult;

	HINSTANCE hInstance = LoadLibrary( L"kernel32.dll" );
    if ( hInstance )
    {
        PSetThreadUILanguage SetThreadUILang = (PSetThreadUILanguage)GetProcAddress( hInstance, "SetThreadUILanguage" );
        
        if ( SetThreadUILang )
             (*SetThreadUILang)( 0 );

        FreeLibrary( hInstance );
    }

    // We use the program name for reporting errors.
    g_lpszProgramName = argv[ 0 ];

	//
	//	Userdomain is used as the default domain.
	//
	GetEnvironmentVariableW(L"USERDOMAIN", g_lpszDefaultDomain, MAX_PATH);
	GetEnvironmentVariableW(L"COMPUTERNAME", g_lpszLocalComputerName, MAX_PATH);

	//
	//	if there is no arguments, we will display help.
	//
	if(argc == 1)
	{
		usage();
        return;
	}

	//
	//	If the first argument is -i or /i, we pop up UI.
	//
	if(wcsncmp(argv[1], L"-i", 2) == 0 || wcsncmp(argv[1], L"/i", 2) == 0
		|| wcsncmp(argv[1], L"-I", 2) == 0 || wcsncmp(argv[1], L"/I", 2) == 0)
	{
		g_hDllInstance = GetModuleHandle(NULL);
		if(g_hDllInstance)
		{
			hResult = DialogBoxParam(g_hDllInstance, MAKEINTRESOURCE(IDD_DIALOGSHUTDOWN), NULL, Shutdown_DialogProc, NULL);
			
			if(g_lpReasons)
				LocalFree((HLOCAL)g_lpReasons);
		}
		return;
	}
    // Parse the options.
    if( !parse_options( argc,
                        argv,
                        &fLogoff,
                        &fForce,
                        &fReboot,
                        &fAbort,
                        &lpServerName,
                        &lpMessage,
                        &dwTimeout,
                        &dwReason ))
    {
        usage();
        return;
    }

    // Get all privileges so that we can shutdown the machine.
    if( !enable_privileges( lpServerName, fLogoff ))
    {
		TESTMSG(L"enable_privileges failed\n");
        return;
    }

    // Do the work.
    if( fAbort )
    {
        if( !AbortSystemShutdownW( lpServerName ))
        {
            report_error( GetLastError( ));
        }
    }
    else if (fLogoff)
    {
        if (!ExitWindowsEx(fForce ? EWX_LOGOFF : (EWX_LOGOFF | EWX_FORCE),
                           0))
        {
            report_error(GetLastError());
        }
    }
    else
    {
        // Do the normal form.
        if( !InitiateSystemShutdownExW( lpServerName,
                                        lpMessage,
                                        dwTimeout,
                                        fForce,
                                        fReboot,
                                        dwReason ))
        {
			TESTMSG(L"InitiateSystemShutdownExW failed\n");
            report_error( GetLastError( ));
        }
    }
}


//
//	Get the computers in the spesified domain and populate the list box
//
BOOL GetNetworkComputers(HWND hwndList, HWND hwndProgress, LPCWSTR lpDomain)
{
	LPSERVER_INFO_101	pBuf = NULL;
	LPSERVER_INFO_101	pTmpBuf;
	DWORD				dwLevel = 101;
	DWORD				dwPrefMaxLen = -1;
	DWORD				dwEntriesRead = 0;
	DWORD				dwTotalEntries = 0;
	DWORD				dwTotalCount = 0;
	DWORD				dwServerType = SV_TYPE_SERVER; // all servers
	DWORD				dwResumeHandle = 0;
	NET_API_STATUS		nStatus;
	LPWSTR				pszServerName = NULL;
	WCHAR				lpWSTR[MAX_PATH];
	DWORD				i;
	WCHAR				er[MAX_PATH];
	WCHAR				wsz[MAX_PATH];


	LoadStringW(g_hDllInstance, IDS_GETCOMPUTERNAMEWAIT, er, MAX_PATH);
	LoadStringW(g_hDllInstance, IDS_GETCOMPUTERNAMEPROGRESS, wsz, MAX_PATH);

	SetWindowTextW(hwndProgress, er);
	nStatus = NetServerEnum(NULL,
                           dwLevel,
                           (LPBYTE *) &pBuf,
                           dwPrefMaxLen,
                           &dwEntriesRead,
                           &dwTotalEntries,
                           dwServerType,
                           lpDomain,
                           &dwResumeHandle);
   //
   // If the call succeeds,
   //
   if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
   {
		if ((pTmpBuf = pBuf) != NULL)
		{
			//
			//	Loop through the entries and 
			//  add each computer name to list.
			//
			for (i = 0; i < dwEntriesRead; i++)
			{
				if (pTmpBuf == NULL)
				{
				   break;
				}

				wcscpy(lpWSTR, pTmpBuf->sv101_name);

				if(i+1 > 0 && (i+1) % 500 == 0){
					DWORD percentage = ((i+1)*100)/dwEntriesRead;
					swprintf(er, L"%d%% %s(%d)...", percentage, wsz, i+1);
					SetWindowTextW(hwndProgress, er);
				}

				//
				//	We don't add dups.
				//
				if(LB_ERR == ListBox_FindString(hwndList, -1, lpWSTR))
					ListBox_AddString(hwndList, lpWSTR);

				pTmpBuf++;
				dwTotalCount++;
			}

			//
			//	Display a warning if all available entries were
			//  not enumerated, print the number actually 
			//  enumerated, and the total number available.
			//

			if (nStatus == ERROR_MORE_DATA)
			{
				LoadStringW(g_hDllInstance, IDS_GETCOMPUTERNAMEMOREDATA, er, MAX_PATH);
				SetWindowTextW(hwndProgress, er);
			}

			LoadStringW(g_hDllInstance, IDS_GETCOMPUTERNAMECOMPLETE, wsz, MAX_PATH);
			swprintf(er, L"%s %d)", wsz, dwTotalCount);
			SetWindowTextW(hwndProgress, er);
		}
	}
	else 
	{
		LoadStringW(g_hDllInstance, IDS_GETCOMPUTERNAMEERROR, wsz, MAX_PATH);
		swprintf(er, L"%s: %d", wsz, nStatus);
		SetWindowTextW(hwndProgress, er);
	}
   //
   // Free the allocated buffer.
   //
   if (pBuf != NULL)
      NetApiBufferFree(pBuf);

   return TRUE;
}

//
//	Get computername from ADSI path
//	Here we only handle WinNT, LDAP, NWCOMPAT, and NDS.
//
BOOL GetComputerNameFromPath(LPWSTR szPath, LPWSTR szName)
{
	static _PROVIDER p[] =
	{
		{L"LDAP://", 7},
		{L"WinNT://", 8}, 
		{L"NWCOMPAT://", 11},
		{L"NDS://", 6}
	};

	static UINT np = sizeof(p)/sizeof(_PROVIDER);
	LPWSTR lpsz = NULL;

	if(!szPath || !szName)
		return FALSE;

	for(UINT i = 0; i < np; i++)
	{
		if(wcsncmp(szPath, p[i].szName, p[i].dwLen) == 0)
		{
			switch(i)
			{
			case 0: //	LDAP
				lpsz = wcsstr(szPath, L"CN=");
				if(!lpsz)
					return FALSE;
				lpsz += 3;
				
				while(*lpsz && *lpsz != ',')
					*szName++ = *lpsz++;
				*szName = 0;
				return TRUE;
			case 1: //	WinNT
			case 2: //	NWCOMPAT
				lpsz = szPath + p[i].dwLen;
				//
				//	skip domain or provider path
				//
				while(*lpsz && *lpsz != '/')
					lpsz++;
				lpsz++;

				while(*lpsz && *lpsz != '/')
					*szName++ = *lpsz++;
				*szName = 0;
				return TRUE;
			case 3: //	NDS
				lpsz = wcsstr(szPath, L"CN=");
				if(!lpsz)
					return FALSE;
				lpsz += 3;
				
				while(*lpsz && *lpsz != '/')
					*szName++ = *lpsz++;
				*szName = 0;
				return TRUE;
			default:
				return FALSE;
			}
		}
	}
	return FALSE;
}

//
//	A centralized place for adjusting window states.
//
VOID AdjustWindowState()
{
	if(g_dwActionSelect == ACTION_SHUTDOWN || g_dwActionSelect == ACTION_RESTART)
	{
		EnableWindow(g_wins.hwndButtonWarning, TRUE);
		if (IsDlgButtonChecked(g_wins.hwndShutdownDialog, IDC_CHECKWARNING) == BST_CHECKED)
			EnableWindow(g_wins.hwndEditTimeout, TRUE);
		else
			EnableWindow(g_wins.hwndEditTimeout, FALSE);

		EnableWindow(g_wins.hwndEditComment, TRUE);
		if(g_bAssumeShutdown)
		{
			EnableWindow(g_wins.hwndComboOption, FALSE);
			EnableWindow(g_wins.hwndChkPlanned, FALSE);
			EnableWindow(g_wins.hwndButtonOK, TRUE);
		}
		else
		{
			EnableWindow(g_wins.hwndComboOption, TRUE);
			EnableWindow(g_wins.hwndChkPlanned, TRUE);
			if(g_dwReasonSelect != -1 && (g_lpReasons[g_dwReasonSelect].dwCode & SHTDN_REASON_FLAG_COMMENT_REQUIRED))
			{
				if(Edit_GetTextLength(g_wins.hwndEditComment) > 0)
					EnableWindow(g_wins.hwndButtonOK, TRUE);
				else
					EnableWindow(g_wins.hwndButtonOK, FALSE);
			}
			else
			{
				EnableWindow(g_wins.hwndButtonOK, TRUE);
			}
		}
		EnableWindow(g_wins.hwndBtnAdd, TRUE);
		EnableWindow(g_wins.hwndBtnBrowse, TRUE);
		EnableWindow(g_wins.hwndBtnRemove, TRUE);
		EnableWindow(g_wins.hwndListSelectComputers, TRUE);
	}
	else
	{
		EnableWindow(g_wins.hwndChkPlanned, FALSE);
		EnableWindow(g_wins.hwndButtonWarning, FALSE);
		EnableWindow(g_wins.hwndBtnAdd, FALSE);
		EnableWindow(g_wins.hwndBtnBrowse, FALSE);
		EnableWindow(g_wins.hwndBtnRemove, FALSE);
		EnableWindow(g_wins.hwndComboOption, FALSE);
		EnableWindow(g_wins.hwndEditComment, FALSE);
		EnableWindow(g_wins.hwndEditTimeout, FALSE);
		EnableWindow(g_wins.hwndListSelectComputers, FALSE);
		EnableWindow(g_wins.hwndButtonOK, TRUE);
	}
}

//
//	Init dialog handler for the shutdown dialog.
//
BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
	HMODULE				hUser32;
	REASONBUILDPROC		buildProc;
	REASONDESTROYPROC	DestroyProc;
	WCHAR				lpReasonName[MAX_PATH];
	REASONDATA			Reasons;
	int					i;

	//
	//	Init all of the dialog items so we dont have to find
	//	them everytime we need them.
	//
	g_wins.hwndShutdownDialog	= hwnd;
	g_wins.hwndButtonWarning	= GetDlgItem(hwnd, IDC_CHECKWARNING);
	g_wins.hwndComboAction		= GetDlgItem(hwnd, IDC_COMBOACTION);
	g_wins.hwndComboOption		= GetDlgItem(hwnd, IDC_COMBOOPTION);
	g_wins.hwndEditComment		= GetDlgItem(hwnd, IDC_EDITCOMMENT);
	g_wins.hwndStaticDesc		= GetDlgItem(hwnd, IDC_STATICDESCRIPTION);
	g_wins.hwndEditTimeout		= GetDlgItem(hwnd, IDC_EDITTIMEOUT);
	g_wins.hwndListSelectComputers = GetDlgItem(hwnd, IDC_LISTSELECTEDCOMPUTERS);
	g_wins.hwndBtnAdd			= GetDlgItem(hwnd, IDC_BUTTONADDNEW);
	g_wins.hwndBtnBrowse		= GetDlgItem(hwnd, IDC_BUTTONBROWSE);
	g_wins.hwndBtnRemove		= GetDlgItem(hwnd, IDC_BUTTONREMOVE);
	g_wins.hwndChkPlanned		= GetDlgItem(hwnd, IDC_CHECK_PLANNED);
	g_wins.hwndButtonOK			= GetDlgItem(hwnd, IDOK);
	
	if(g_wins.hwndButtonWarning == NULL 
		|| g_wins.hwndComboAction == NULL 
		|| g_wins.hwndComboOption == NULL 
		|| g_wins.hwndEditComment == NULL
		|| g_wins.hwndStaticDesc == NULL
		|| g_wins.hwndEditTimeout == NULL
		|| g_wins.hwndListSelectComputers == NULL
		|| g_wins.hwndBtnAdd == NULL
		|| g_wins.hwndBtnBrowse == NULL
		|| g_wins.hwndBtnRemove == NULL
		|| g_wins.hwndChkPlanned == NULL)
	{
		report_error( GetLastError( ));
		EndDialog(hwnd, (int)-1);
		return FALSE;
	}
	
	LoadString(g_hDllInstance, IDS_DIALOGTITLEWARNING, g_lpszTitleWarning, TITLEWARNINGLEN);

	//
	//	Default timeout is set to 20 seconds.
	//
	Edit_SetText(g_wins.hwndEditTimeout, L"20");
	if(! CheckDlgButton(hwnd, IDC_CHECKWARNING, DEFAULTWARNINGSTATE))
	{
		report_error( GetLastError( ));
		EndDialog(hwnd, (int)-1);
		return FALSE;
	}

	//
	//	The for loop will load all of the actions into action combo.
	//	in the meantime we save them for later use.
	//
	for(i = 0; i < g_nActions; i++)
	{
		LoadString(g_hDllInstance, g_dwActions[i], g_lppszActions[i], MAX_PATH - 1);
		ComboBox_AddString(g_wins.hwndComboAction, g_lppszActions[i]);
		if(g_dwActions[i] == IDS_ACTION_SHUTDOWN)
		{
			ComboBox_SelectString(g_wins.hwndComboAction, -1, g_lppszActions[i]);
			g_dwActionSelect = ACTION_SHUTDOWN;
		}
	}

	hUser32 = LoadLibraryW(L"user32.dll");
	if(hUser32 != NULL)
	{
		//
		//	We are using the user32.dll to get and destroy the reasons.
		//	The reasons are added to the option combo and also cached for later use.
		//
		buildProc = (REASONBUILDPROC)GetProcAddress(hUser32, "BuildReasonArray");
		DestroyProc = (REASONDESTROYPROC)GetProcAddress(hUser32, "DestroyReasons");
		if(!buildProc || !DestroyProc)
		{
			FreeLibrary(hUser32);
			hUser32 = NULL;
			g_bAssumeShutdown = TRUE;
		}
		
	}
	else
	{
		g_bAssumeShutdown = TRUE;
	}

	
	//
	//	If we dont have BuildReasonArray() and DestroyReasons() is user32.dll (pre whistler)
	//	we will disable he option combo box.
	//
	if(!g_bAssumeShutdown)
	{
		if(!(*buildProc)(&Reasons, TRUE, FALSE))
		{
			report_error( GetLastError( ));
			FreeLibrary(hUser32);
			EndDialog(hwnd, (int)-1);
			return FALSE;
		}
		else 
		{
			int		iOption;
			int		iFirst = -1;
			DWORD	dwCheckState = 0x0;
		
			//
			//	Alloc space for reasons.
			//
			g_lpReasons = (PSHUTDOWNREASON)LocalAlloc(LMEM_FIXED, Reasons.cReasons * sizeof(SHUTDOWNREASON));
			if(!g_lpReasons)
			{
				report_error( GetLastError( ));
				FreeLibrary(hUser32);
				EndDialog(hwnd, (int)-1);
				return FALSE;
			}

			//
			//	Set the default to be planned.
			//
			CheckDlgButton(hwnd, IDC_CHECK_PLANNED, BST_CHECKED);
			if (IsDlgButtonChecked(hwnd, IDC_CHECK_PLANNED) == BST_CHECKED)
				dwCheckState = SHTDN_REASON_FLAG_PLANNED;

			//
			//	Init this guy number of reasons.
			//
			g_dwReasons = Reasons.cReasons;

			//
			//	Now populate the combo according the current check state.
			//
			for (iOption = 0; iOption < (int)Reasons.cReasons; iOption++)
			{
				wcscpy(g_lpReasons[iOption].lpName, Reasons.rgReasons[iOption]->szName);
				wcscpy(g_lpReasons[iOption].lpDesc, Reasons.rgReasons[iOption]->szDesc);
				g_lpReasons[iOption].dwCode = Reasons.rgReasons[iOption]->dwCode;
				if(((Reasons.rgReasons[iOption]->dwCode) & SHTDN_REASON_FLAG_PLANNED) == dwCheckState)
				{
					if(iFirst == -1)
						iFirst = iOption;
					ComboBox_AddString(g_wins.hwndComboOption, g_lpReasons[iOption].lpName);
				}
			}

			//
			//	do a default selection (the first one), and set the description.
			//
			g_dwReasonSelect = iFirst;
			if(g_dwReasons > 0 && iFirst != -1)
			{
				ComboBox_SelectString(g_wins.hwndComboOption, -1, g_lpReasons[iFirst].lpName);
				SetWindowTextW(g_wins.hwndStaticDesc,  g_lpReasons[iFirst].lpDesc);
			}
			else
			{
				return FALSE;
			}

			//
			// Setup the comment box.
			// We must fix the maximum characters.
			//
			SendMessage( g_wins.hwndEditComment, EM_LIMITTEXT, (WPARAM)MAX_REASON_COMMENT_LEN, (LPARAM)0 );
			
			(*DestroyProc)(&Reasons);
			FreeLibrary(hUser32);
		}
	}

	AdjustWindowState();

	return TRUE;
}

//
//	Init dialog handler for browse dialog
//
BOOL Browse_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
	HWND	hwndDomain = NULL;
	int		cItems = 1024;
	int		lpItems[1024];
	int		cActualItems;
	WCHAR	lpDomain[MAX_PATH];

	hwndDomain = GetDlgItem(hwnd, IDC_EDITDOMAIN);

	if(!hwndDomain)
		return FALSE;

	Edit_SetText(hwndDomain, g_lpszDefaultDomain);;

	return TRUE;
}

//
//	winproc for shutdown dialog
//
INT_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Shutdown_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Shutdown_OnCommand);
	case (WM_SYSCOMMAND): 
		return (Shutdown_OnCommand(hwnd, (int)(LOWORD(wParam)), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L);
    }

    return FALSE;
}

//
//	winproc for Browse dialog
//
INT_PTR CALLBACK Browse_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Browse_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Browse_OnCommand);
    }

    return FALSE;
}

//
//	winproc for AddNew dialog
//
INT_PTR CALLBACK AddNew_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_COMMAND, AddNew_OnCommand);
    }

    return FALSE;
}

//
//	Command handler for the shutdown dialog.
//
BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL		fHandled = FALSE;
    DWORD		dwDlgResult = 0;
	HINSTANCE	h;

    switch (id)
    {
    case IDCANCEL:
        if (codeNotify == BN_CLICKED)
        {  
			EndDialog(hwnd, (int) dwDlgResult);
        }
	fHandled = TRUE;
        break;
	case SC_CLOSE:
		EndDialog(hwnd, (int) dwDlgResult);
		fHandled = TRUE;
		break;
	case IDC_BUTTONREMOVE:
        if (codeNotify == BN_CLICKED)
        {  
			  int	cItems = 1024;
			  int	lpItems[1024];
			  int	cActualItems;
			  WCHAR	lpServerName[MAX_PATH];

			  //
			  //	Get the number of selected items. If there is any remove them one by one.
			  //
			  cActualItems = ListBox_GetSelItems(g_wins.hwndListSelectComputers, cItems, lpItems);
			  if(cActualItems > 0)
			  {
				  int i;
				  for(i = cActualItems-1; i >= 0; i--)
				  {
					  ListBox_DeleteString(g_wins.hwndListSelectComputers, lpItems[i]);
				  }
			  }
			  fHandled = TRUE;
		}
        break;
	case IDC_CHECK_PLANNED:
		if (codeNotify == BN_CLICKED)
        { 
			int		iOption;
			int		iFirst = -1;
			DWORD	dwCheckState = 0x0;

			//
			//	Get check button state.
			//
			if (IsDlgButtonChecked(hwnd, IDC_CHECK_PLANNED) == BST_CHECKED)
				dwCheckState = SHTDN_REASON_FLAG_PLANNED;

			//
			//	Remove all items from combo
			//
			while (ComboBox_GetCount(g_wins.hwndComboOption))
				ComboBox_DeleteString(g_wins.hwndComboOption, 0);

			//
			//	Now populate the combo according the current check state.
			//
			for (iOption = 0; iOption < (int)g_dwReasons; iOption++)
			{
				if(((g_lpReasons[iOption].dwCode) & SHTDN_REASON_FLAG_PLANNED) == dwCheckState)
				{
					ComboBox_AddString(g_wins.hwndComboOption, g_lpReasons[iOption].lpName);
					if(iFirst == -1)
						iFirst = iOption;
				}
			}

			//
			//	do a default selection (the first one), and set the description.
			//
			if(iFirst != -1)
			{
				ComboBox_SelectString(g_wins.hwndComboOption, -1, g_lpReasons[iFirst].lpName);
				SetWindowTextW(g_wins.hwndStaticDesc,  g_lpReasons[iFirst].lpDesc);
			}
			g_dwReasonSelect = iFirst;
			AdjustWindowState();
			fHandled = TRUE;
		}
		break;
	case IDC_EDITCOMMENT:
        if( codeNotify == EN_CHANGE) 
        {
			if(g_dwReasonSelect != -1 && (g_lpReasons[g_dwReasonSelect].dwCode & SHTDN_REASON_FLAG_COMMENT_REQUIRED))
			{
				if(Edit_GetTextLength(g_wins.hwndEditComment) > 0)
					EnableWindow(g_wins.hwndButtonOK, TRUE);
				else
					EnableWindow(g_wins.hwndButtonOK, FALSE);
			}
			else
			{
				EnableWindow(g_wins.hwndButtonOK, TRUE);
			}
            fHandled = TRUE;
        }
        break;

	case IDC_BUTTONADDNEW:
        if (codeNotify == BN_CLICKED)
        {  
			WCHAR	lpServerName[MAX_PATH];
			LPWSTR	lpBuffer;
			DWORD	dwIndex = 0;
			INT_PTR	hResult;

			//
			//	Will pop up the addnew dialog. User can type in computer names seperated
			//	by white space. After click on OK, we will parse the computer names and
			//	add them to the selected computer list. No duplicates will be added.
			//
			hResult = DialogBoxParam(g_hDllInstance, MAKEINTRESOURCE(IDD_DIALOG_ADDNEW), hwnd, AddNew_DialogProc, NULL);
			if(g_lpszNewComputers)
			{
				lpBuffer = g_lpszNewComputers;
				while(*lpBuffer)
				{
					lpServerName[dwIndex] = '\0';
					while(*lpBuffer && *lpBuffer != '\t' && *lpBuffer != '\n' && *lpBuffer != '\r' && *lpBuffer != ' ')
						lpServerName[dwIndex++] = *lpBuffer++;
					lpServerName[dwIndex] = '\0';
					if(dwIndex > 0 && LB_ERR == ListBox_FindString(g_wins.hwndListSelectComputers, -1, lpServerName))
						ListBox_AddString(g_wins.hwndListSelectComputers, lpServerName);
					dwIndex = 0;
					while(*lpBuffer && (*lpBuffer == '\t' || *lpBuffer == '\n' || *lpBuffer == '\r' || *lpBuffer == ' '))
						lpBuffer++;
				}
				
				LocalFree((HLOCAL)g_lpszNewComputers);
				g_lpszNewComputers = NULL;
			}
			fHandled = TRUE;
		}
        break;
	case IDOK:
		//
		//	Here we gather all of the information and do the action.
		//
        if (codeNotify == BN_CLICKED)
        {  
			int		cItems = 1024;
			int		lpItems[1024];
			int		cActualItems;
			BOOL	fLogoff = FALSE;
			BOOL	fAbort = FALSE;
			BOOL	fForce = FALSE;
			BOOL	fReboot = FALSE;
			BOOL	fDisconnect = FALSE;
			BOOL	fStandby = FALSE;
			DWORD	dwTimeout = 0;
			DWORD	dwReasonCode = 0;
			WCHAR	lpServerName[MAX_PATH];
			WCHAR	lpMsg[MAX_REASON_COMMENT_LEN] = L"";
			DWORD	dwCnt = 0;
			DWORD	dwActionCode = g_dwActionSelect;
			WCHAR	lpNoPrivilage[MAX_PATH];
			WCHAR	lpNotSupported[MAX_PATH];
			WCHAR	lpRes[MAX_PATH * 2];
			WCHAR	lpFailed[MAX_PATH];
			WCHAR	lpSuccess[MAX_PATH];

			//
			//	The default reason code is 0 and default comment is L"".
			//
			if(IsDlgButtonChecked(hwnd, IDC_CHECKWARNING))
			{
				fForce = FALSE;
				lpServerName[0] = '\0';
				GetWindowText(g_wins.hwndEditTimeout, lpServerName, MAX_PATH);
				if(lstrlen(lpServerName) == 0)
				  dwTimeout = 0;
				else dwTimeout = _wtoi(lpServerName);
			}
			else 
			{
				fForce = TRUE;
			}

			LoadString(g_hDllInstance, IDS_CANNOTGETPRIVILAGE, lpNoPrivilage, MAX_PATH);
			LoadString(g_hDllInstance, IDS_ACTIONNOTSUPPORTED, lpNotSupported, MAX_PATH);
			LoadString(g_hDllInstance, IDS_FAILED, lpFailed, MAX_PATH);
			LoadString(g_hDllInstance, IDS_SUCCEEDED, lpSuccess, MAX_PATH);
			GetWindowText(g_wins.hwndEditComment, lpMsg, MAX_REASON_COMMENT_LEN);

			if(dwActionCode == ACTION_LOGOFF)
			{
				fLogoff = TRUE;
			}
			else if (dwActionCode == ACTION_RESTART)
			{
				fReboot = TRUE;
			}
#if 0
			else if (dwActionCode == ACTION_ABORT)
				fAbort = TRUE;
			else if (dwActionCode == ACTION_STANDBY)
			{
				fStandby = TRUE;
				//lstrcat(lpNotSupported, lpServerName);
				//MessageBox(hwnd, lpNotSupported, NULL, 0);
				break;
			}
			else if (dwActionCode == ACTION_DISCONNECT)
			{
				fDisconnect = TRUE;
				//lstrcat(lpNotSupported, lpServerName);
				//MessageBox(hwnd, lpNotSupported, g_lpszTitleWarning, 0);
				break;
			}
#endif //0
			//
			//	Logoff is only for the local computer.
			//	Everything else will ingored.
			//
			if(fLogoff)
			{
				if (!ExitWindowsEx(fForce ? EWX_LOGOFF : (EWX_LOGOFF | EWX_FORCE),
										   0))
				{
					report_error(GetLastError());
				}
				EndDialog(hwnd, (int) dwDlgResult);
				break;
			}

			if(! g_bAssumeShutdown)
			{
				dwReasonCode = g_lpReasons[g_dwReasonSelect].dwCode;
			}

			dwCnt = ListBox_GetCount(g_wins.hwndListSelectComputers);
			if(dwCnt > 0)
			{
				DWORD i;
				for(i = 0; i < dwCnt; i++)
				{
					ListBox_GetText(g_wins.hwndListSelectComputers, i, lpServerName);


					//
					// Get all privileges so that we can shutdown the machine.
					//
					if( !enable_privileges(lpServerName, fLogoff))
					{
						report_error( GetLastError( ));
						wcscpy(lpRes, lpNoPrivilage);
						wcscat(lpRes, L": ");
						wcscat(lpRes, lpServerName);
						wcscat(lpRes, L"\n");
						WriteToConsole(lpRes);
						continue;
					}

					//
					// Do the work.
					//
					if( fAbort )
					{
						if( !AbortSystemShutdown( lpServerName ))
						{
							report_error( GetLastError( ));
						}
					}
					else
					{
						//
						// Do the normal form.
						//
						if( !InitiateSystemShutdownEx( lpServerName,
														lpMsg,
														dwTimeout,
														fForce,
														fReboot,
														dwReasonCode ))
						{
							report_error( GetLastError( ));
							wcscpy(lpRes, lpFailed);
							wcscat(lpRes, L": ");
							wcscat(lpRes, lpServerName);
							wcscat(lpRes, L"\n");
							WriteToConsole(lpRes);
						}
						else
						{
							wcscpy(lpRes, lpSuccess);
							wcscat(lpRes, L": ");
							wcscat(lpRes, lpServerName);
							wcscat(lpRes, L"\n");
							WriteToConsole(lpRes);
						}
					}

					
				}
			}
			else
			{
				//
				//	We will keep the dialog up in case user forget to add computers.
				//
				LoadStringW(g_hDllInstance, IDS_EMPTYLISTMSG, lpMsg, MAX_REASON_COMMENT_LEN);
				MessageBoxW(hwnd, lpMsg, g_lpszTitleWarning, 0);
				break;
			}
			EndDialog(hwnd, (int) dwDlgResult);
		}
        break;
	case IDC_CHECKWARNING:
		//
		//	The checkbutton state decides the state of the timeout edit box.
		//
        if (codeNotify == BN_CLICKED)
        {  
			if(BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CHECKWARNING))
			{
				EnableWindow(g_wins.hwndEditTimeout, TRUE);
			}
			else 
			{
				EnableWindow(g_wins.hwndEditTimeout, FALSE);
			}
			fHandled = TRUE;
		}
        break;
	case IDC_BUTTONBROWSE:
		//
		//	Simply pop up the browse dialog. That dialog will be responsible
		//	for adding the user selection to the selected computer list.
		//
        if (codeNotify == BN_CLICKED)
        {  
			//DialogBoxParam(g_hDllInstance, MAKEINTRESOURCE(IDD_DIALOG_BROWSE), hwnd, Browse_DialogProc, NULL);
			HRESULT hr;
			ICommonQuery* pcq;
			OPENQUERYWINDOW oqw = { 0 };
			DSQUERYINITPARAMS dqip = { 0 };
			IDataObject *pdo;

			FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES), 
							  NULL,
							  DVASPECT_CONTENT, 
							  -1, 
							  TYMED_HGLOBAL};
			FORMATETC fmte2 = {(CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSQUERYPARAMS), 
							  NULL,
							  DVASPECT_CONTENT, 
							  -1, 
							  TYMED_HGLOBAL};
			STGMEDIUM medium = { TYMED_NULL, NULL, NULL };

			DSOBJECTNAMES *pdon;
			DSQUERYPARAMS *pdqp;

			CoInitialize(NULL);

			//
			// Windows 2000: Always use IID_ICommonQueryW explicitly. IID_ICommonQueryA is not supported.
			//
			hr = CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (void**)&pcq);
			if (FAILED(hr)) {
				//
				// if failed we fall back on our browse dialog.
				//
				CoUninitialize();
				DbgPrint("Cannot create ICommonQuery, fallback on simple browse.\n");
				DialogBoxParam(g_hDllInstance, MAKEINTRESOURCE(IDD_DIALOG_BROWSE), hwnd, Browse_DialogProc, NULL);
				break;
			}

			//
			// Initialize the OPENQUERYWINDOW structure to indicate 
			// we want to do a Directory Service
			// Query, the default form is printers and the search 
			// should start once the window is initialized.
			//
			oqw.cbStruct = sizeof(oqw);
			oqw.dwFlags = OQWF_OKCANCEL|OQWF_DEFAULTFORM|OQWF_HIDEMENUS|OQWF_REMOVEFORMS;
			oqw.clsidHandler = CLSID_DsQuery;
			oqw.pHandlerParameters = &dqip;
			oqw.clsidDefaultForm = CLSID_DsFindComputer;
 
			//
			// Now initialize the handler specific parameters, 
			// in this case, the File/Save menu item is removed
			//
			dqip.cbStruct = sizeof(dqip);
			dqip.dwFlags = DSQPF_NOSAVE;
			

			//
			// Call OpenQueryWindow, it will block until 
			// the Query Window is dismissed,
			//
			hr = pcq->OpenQueryWindow(hwnd, &oqw, &pdo);
			if (FAILED(hr)) {
				//
				// if failed we fall back on our browse dialog.
				//
				pcq->Release();
				CoUninitialize();
				DialogBoxParam(g_hDllInstance, MAKEINTRESOURCE(IDD_DIALOG_BROWSE), hwnd, Browse_DialogProc, NULL);
				break;
			}

			if (!pdo) {
				//
				// if cancelled,nothing needs to be done.
				//
				pcq->Release();
				CoUninitialize();
				break;
			}

			//
			// Get the CFSTR_DSOBJECTNAMES data. For each selected, the data
			// includes the object class and an ADsPath to the selected object.
			//
			hr = pdo->GetData(&fmte, &medium);

			if(! FAILED(hr))
			{
				pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
		
				if ( pdon )
				{
					WCHAR			szName[MAX_PATH];
					LPWSTR			lpsz = NULL;
					UINT			i;

					for (i = 0; i < pdon->cItems; i++) 
					{
						if(!GetComputerNameFromPath((LPWSTR) ((PBYTE) pdon + pdon->aObjects[i].offsetName), szName))
							continue;

						//
						//	We don't add dups.
						//
						if(LB_ERR == ListBox_FindString(g_wins.hwndListSelectComputers, -1, szName))
						{
							ListBox_AddString(g_wins.hwndListSelectComputers, szName);
						}
					}
 
					GlobalUnlock(medium.hGlobal);
				}
				else
				{
					DbgPrint("GlobalLock on medium failed.\n");
				}
				ReleaseStgMedium(&medium);
			}
			else
			{
				DbgPrint("pdo->GetData failed: 0x%x\n", hr);
			}
 
			//
			//	Release resources.
			//
			pdo->Release();
			pcq->Release();

			CoUninitialize();
			fHandled = TRUE;
		}
        break;
	case IDC_COMBOOPTION:
		//
		//	Here is where you select shutdown reasons.
		//
        if (codeNotify == CBN_SELCHANGE)
        {  
			WCHAR name[MAX_REASON_NAME_LEN + 1];
			DWORD dwIndex;

			GetWindowText(g_wins.hwndComboOption, (LPWSTR)&name, MAX_REASON_NAME_LEN);
			for(dwIndex = 0; dwIndex < g_dwReasons; dwIndex++)
			{
				if(lstrcmp(name, g_lpReasons[dwIndex].lpName) == 0)
				{
					SetWindowTextW(g_wins.hwndStaticDesc, g_lpReasons[dwIndex].lpDesc);
					g_dwReasonSelect = dwIndex;
					AdjustWindowState();
					break;
				}
			}
			fHandled = TRUE;
		}
        break;
	case IDC_COMBOACTION:
		//
		//	Select user action here.
		//	according to the action. some item will be disabled or enabled.
		//
        if (codeNotify == CBN_SELCHANGE)
        {  
			WCHAR name[MAX_PATH];
			DWORD dwIndex;

			GetWindowText(g_wins.hwndComboAction, (LPWSTR)&name, MAX_PATH);
			for(dwIndex = 0; dwIndex < g_nActions; dwIndex++)
			{
				if(lstrcmp(name, g_lppszActions[dwIndex]) == 0)
				{
					g_dwActionSelect = dwIndex;
					AdjustWindowState();
					break;
				}
			}
			fHandled = TRUE;
		}
        break;
    }
    return fHandled;
}

//
//	Command handler for the addnew dialog.
//	It simply copy the text into a allocated buffer when OK is clicked.
//
BOOL AddNew_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL		fHandled = FALSE;
    DWORD		dwDlgResult = 0;
	HINSTANCE	h;

    switch (id)
    {
    case IDOK:
        if (codeNotify == BN_CLICKED)
        {  
			HWND hwndEdit;
			DWORD dwTextlen = 0;

			hwndEdit = GetDlgItem(hwnd, IDC_EDIT_ADDCOMPUTERS_COMPUTERS);
			if(hwndEdit != NULL)
			{
				dwTextlen = Edit_GetTextLength(hwndEdit);
				if(dwTextlen)
				{
					g_lpszNewComputers = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (dwTextlen + 1));
					if(g_lpszNewComputers){
						Edit_GetText(hwndEdit, g_lpszNewComputers, dwTextlen + 1);
					}
				}
			}
			EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
	case IDCANCEL:
        if (codeNotify == BN_CLICKED)
        {  
			EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
	}
    return fHandled;
}

//
//Command handler for the browse dialog.
//
BOOL Browse_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL		fHandled = FALSE;
    DWORD		dwDlgResult = 0;
	HINSTANCE	h;

    switch (id)
    {
    case IDOK:
		//
		//	Get selected computer names and add them to
		//	selected computer list. No dups.
		//
        if (codeNotify == BN_CLICKED)
        {  
			int cItems = 1024;
			int lpItems[1024];
			int cActualItems;
			HWND hwndFromList;
			WCHAR lpServerName[MAX_PATH];

			hwndFromList = GetDlgItem(hwnd, IDC_LISTNETWORKCOMPUTERS);
			assert(hwndFromList != NULL);
			cActualItems = ListBox_GetSelItems(hwndFromList, cItems, lpItems);
			if(cActualItems > 0)
			{
				int i;
				for(i = 0; i < cActualItems; i++)
				{
					ListBox_GetText(hwndFromList, lpItems[i], lpServerName);
					if(IsEmpty(lpServerName))
						continue;
					if(LB_ERR == ListBox_FindString(g_wins.hwndListSelectComputers, -1, lpServerName))
						ListBox_AddString(g_wins.hwndListSelectComputers, lpServerName);
				}
			}
			
			EndDialog(hwnd, (int) dwDlgResult);
			fHandled = TRUE;
        }
        break;
	case IDCANCEL:
		if (codeNotify == BN_CLICKED)
		{
			EndDialog(hwnd, (int)0);
			fHandled = TRUE;
		}
		break;
	case IDC_BUTTON_REFRESH:
		//
		//	List the computers in the specified domain.
		//
		if (codeNotify == BN_CLICKED)
		{
			WCHAR	domain[MAX_PATH];
			HWND	hwndDomain;
			HWND	hwndComputers;
			HWND	hwndProgress;

			hwndDomain		= GetDlgItem(hwnd, IDC_EDITDOMAIN);
			hwndComputers	= GetDlgItem(hwnd, IDC_LISTNETWORKCOMPUTERS);
			hwndProgress	= GetDlgItem(hwnd, IDC_STATIC_PROGRESS);
			assert(hwndDomain != NULL && hwndComputers != NULL && hwndProgress != NULL);

			while(ComboBox_DeleteString(hwndComputers, 0));
			lstrcpy(domain, g_lpszDefaultDomain);
			Edit_GetText(hwndDomain, domain, MAX_PATH);
			GetNetworkComputers(hwndComputers, hwndProgress, domain);
			
			fHandled = TRUE;
		}
		break;
	}
    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\sethc\dialogs.h ===
/****************************** Module Header ******************************\
* Module Name: dialogs.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define contants used by dialog edit when editting dialog.dlg
*
* NOTE - this file is maintained by dlgedit. Do not edit directly
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


// Accessibility notification dialogs
#define DLG_CONFIRM               0x1230
#define ID_HELPTEXT               0x1231
#define ID_NOHOTKEY               0x1232

#define ID_STICKY_TITLE         0x1240
#define ID_STICKY_TEXT          0x1240

#define ID_FILTER_TITLE         0x1250
#define ID_FILTER_TEXT          0x1250

#define ID_MOUSE_TITLE          0x1260
#define ID_MOUSE_TEXT           0x1260

#define ID_HC_TITLE             0x1270
#define ID_HC_TEXT              0x1270

#define ID_TOGGLE_TITLE         0x1280
#define ID_TOGGLE_TEXT          0x1280

#define ID_SERIAL_TITLE         0x1290
#define ID_SERIAL_TEXT          0x1290

#define ID_ACCESS_TITLE         0x1300
#define ID_ACCESS_TEXT          0x1300

#define ID_WHITEBLACK_HC        0x1320
#define ID_PRE_HC_SCHEME        0x1321
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\shutdown\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Strings.rc
//
#define IDS_USEAGE                      1
#define IDS_USAGE                       1

#define IDS_ACTION_SHUTDOWN             2
#define IDS_ACTION_RESTART              3
#define IDS_ACTION_ABORT                4
#define IDS_ACTION_LOGOF                5
#define IDS_ACTION_LOGOFF               5
#define IDS_ACTION_STANDBY              6
#define IDS_ACTION_DISCONNECT           7
#define IDS_CANNOTGETPRIVILAGE          8
#define IDS_ACTIONNOTSUPPORTED          9
#define IDS_GETCOMPUTERNAMEWAIT         10
#define IDS_GETCOMPUTERNAMEPROGRESS     11
#define IDS_GETCOMPUTERNAMECOMPLETE     12
#define IDS_GETCOMPUTERNAMEMOREDATA     13
#define IDS_GETCOMPUTERNAMEERROR        14
#define IDS_DIALOGTITLEWARNING		15
#define	IDS_SUCCEEDED			16
#define IDS_FAILED			17
#define IDS_EMPTYLISTMSG		18
#define IDD_DIALOGSHUTDOWN              101
#define IDD_DIALOG_ADDNEW               102
#define IDD_DIALOG_BROWSE               103
#define IDC_COMBOACTION                 1000
#define IDC_COMBOOPTION                 1001
#define IDC_LISTNETWORKCOMPUTERS        1002
#define IDC_LISTSELECTEDCOMPUTERS       1003
#define IDC_BUTTON_REFRESH              1004
#define IDC_BUTTONREMOVE                1004
#define IDC_BUTTONBROWSE                1010
#define IDC_CHECKWARNING                1011
#define IDC_EDITTIMEOUT                 1012
#define IDC_EDITCOMMENT                 1014
#define IDC_BUTTONADDNEW                1015
#define IDC_EDIT_ADDCOMPUTERS_COMPUTERS 1015
#define IDC_STATICDESCRIPTION           1017
#define IDC_EDITDOMAIN                  1018
#define IDC_STATIC_PROGRESS             1019
#define IDC_CHECK_PLANNED		1020
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\advdep.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       AdvDep.cpp
//
//  Contents:   addvanced deployment settings dialog
//
//  Classes:
//
//  Functions:
//
//  History:    01-28-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdvDep dialog


CAdvDep::CAdvDep(CWnd* pParent /*=NULL*/)
    : CDialog(CAdvDep::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAdvDep)
    m_fIgnoreLCID = FALSE;
    m_fInstallOnAlpha = FALSE;
    m_f32On64 = FALSE;
    m_szProductCode = _T("");
    m_szDeploymentCount = _T("");
    m_szScriptName = _T("");
    m_fIncludeOLEInfo = FALSE;
    //}}AFX_DATA_INIT
}


void CAdvDep::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAdvDep)
    DDX_Check(pDX, IDC_CHECK1, m_fIgnoreLCID);
    DDX_Check(pDX, IDC_CHECK3, m_fUninstallUnmanaged);
    DDX_Check(pDX, IDC_CHECK4, m_fIncludeOLEInfo);
    DDX_Check(pDX, IDC_CHECK2, m_f32On64);
    DDX_Text(pDX, IDC_STATIC1, m_szProductCode);
    DDX_Text(pDX, IDC_STATIC2, m_szDeploymentCount);
    DDX_Text(pDX, IDC_STATIC3, m_szScriptName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAdvDep, CDialog)
    //{{AFX_MSG_MAP(CAdvDep)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

int FindBreak(CString &sz)
{
    int iReturn = sz.ReverseFind(L'\\');
    int i2 = sz.ReverseFind(L' ');
    if (i2 > iReturn)
    {
        iReturn = i2;
    }
    return iReturn;
}

BOOL CAdvDep::OnInitDialog()
{
    BOOL fIntel = FALSE;
    GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    
    //
    // The include COM information flag is not supported by RSoP
    // so in RSoP mode, we will hide this control
    //
    if ( m_pDeploy->m_fRSOP )
    {
        GetDlgItem( IDC_CHECK4 )->ShowWindow( SW_HIDE );
    }

#if 0
    if (m_pDeploy->m_pData->m_pDetails->pInstallInfo->PathType != SetupNamePath)
    {
        // this is NOT a legacy app
#endif
        if (m_pDeploy->m_fPreDeploy)
        {
            // and we're in pre-deploy mode - enable the extensions only field
            GetDlgItem(IDC_CHECK4)->EnableWindow(TRUE);
        }
#if 0
    }
#endif
    // search for an Intel processor code
    int nPlatforms = m_pDeploy->m_pData->m_pDetails->pPlatformInfo->cPlatforms;
    while (nPlatforms--)
    {
        if (m_pDeploy->m_pData->m_pDetails->pPlatformInfo->
            prgPlatform[nPlatforms].dwProcessorArch
            == PROCESSOR_ARCHITECTURE_INTEL)
        {
            fIntel = TRUE;
        }
    }
//    GetDlgItem(IDC_CHECK2)->EnableWindow(fIntel);
    CString sz;
    if (m_pDeploy->m_fMachine)
    {
        sz.LoadString(IDS_ADVANCEDMACHINES);
    }
    else
    {
        sz.LoadString(IDS_ADVANCEDUSERS);
    }

    if (m_pDeploy->m_pData->Is64Bit())
    {
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK2)->ShowWindow(SW_HIDE);
    }
    else
    {
        GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
        GetDlgItem(IDC_CHECK2)->ShowWindow(SW_SHOW);
    }

    //
    // In the past, we allowed administrators to optionally specify
    // that unmanaged installs should be removed for per-user non-admin
    // installs.  Due to security issues, it is clear that the
    // behavior should not be configurable, that the client
    // should transparently make the decision.  For this reason,
    // we hide this option in the ui below, and note that
    // we leave the resource in the executable so that
    // test code will not be broken by a resource change at this
    // stage in the project -- this resource should be removed altogether
    // in the next release
    //
    GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
    GetDlgItem(IDC_CHECK3)->ShowWindow(SW_HIDE);


    if (m_pDeploy->m_fRSOP)
    {
        // disable EVERYTHING
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }

#if 0
    // Insert spaces after each directory in the script path to allow the
    // static control to split the path over multiple lines.
    // (Without whitespace the control won't split the path up and it
    // will be unreadable.)
    CString szPath = m_szScriptName;
    int ich;
    m_szScriptName = "";
    while (0 <= (ich = szPath.FindOneOf(TEXT("\\/"))))
    {
        m_szScriptName += szPath.Left(ich+1);
        if (ich > 0)
        {
            m_szScriptName += " ";
        }
        szPath = szPath.Mid(ich+1);
    }
    m_szScriptName += szPath;
#else
    // split the path so it will fit in the control

    RECT rect;
    CWnd * pwndStatic =  GetDlgItem(IDC_STATIC3);
    pwndStatic->GetClientRect(&rect);
    DWORD dwControl = rect.right-rect.left;
    CString szPath = m_szScriptName;
    m_szScriptName = "";
    CDC * pDC = pwndStatic->GetDC();
    CSize size = pDC->GetTextExtent(szPath);
    pDC->LPtoDP(&size);
    int ich;
    while (size.cx >= dwControl)
    {
        ich = FindBreak(szPath);
        if (ich <= 0)
        {
            // there's no where else to break this string
            break;
        }
        else
        {
            // break off the front of the string
            CString szFront;
            do
            {
                szFront = szPath.Left(ich);
                size = pDC->GetTextExtent(szFront);
                pDC->LPtoDP(&size);
                ich = FindBreak(szFront);
            } while (ich > 0 && size.cx >= dwControl);
            m_szScriptName += szFront;
            m_szScriptName += L'\n';
            szPath = szPath.Mid(szFront.GetLength());
        }
        size = pDC->GetTextExtent(szPath);
        pDC->LPtoDP(&size);
    }
    m_szScriptName += szPath;
    pwndStatic->ReleaseDC(pDC);

#endif

    CDialog::OnInitDialog();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAdvDep message handlers

void CAdvDep::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_ADVDEP);
}

LRESULT CAdvDep::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\addupgrd.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       addupgrd.h
//
//  Contents:   add upgrade deployment dialog
//
//  Classes:    CAddUpgrade
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
#define AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddUpgrd.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade dialog

class CAddUpgrade : public CDialog
{
// Construction
public:
        CAddUpgrade(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CAddUpgrade)
        enum { IDD = IDD_FIND_UPGRADE };
        int             m_iUpgradeType;
        int             m_iSource;
        //}}AFX_DATA

        CUpgradeData    m_UpgradeData; // out
        CString         m_szPackageName;// out

        UINT            m_cUpgrades;    // in
        map <CString, CUpgradeData> * m_pUpgradeList;
        CString     m_szMyGuid;     // in - script file for the current
                                    //      application (used to exclude the
                                    //      current script file from the
                                    //      potential upgrade set)

        CScopePane * m_pScope;      // in - used to build the list of
                                    //      deployed apps

        CString     m_szGPO;        //      LDAP path to selected GPO
        CString     m_szGPOName;    //      Name of selected GPO;

private:
        map<CString, CUpgradeData> m_NameIndex;
        BOOL        m_fPopulated;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CAddUpgrade)
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CAddUpgrade)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        afx_msg void OnCurrentContainer();
        afx_msg void OnOtherContainer();
        afx_msg void OnAllContainers();
        afx_msg void OnBrowse();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshList();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\addupgrd.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       addupgrd.cpp
//
//  Contents:   add upgrade dialog
//
//  Classes:    CAddUpgrade
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade dialog


CAddUpgrade::CAddUpgrade(CWnd* pParent /*=NULL*/)
        : CDialog(CAddUpgrade::IDD, pParent)
{
        //{{AFX_DATA_INIT(CAddUpgrade)
        m_iUpgradeType = 1; // default to rip-and-replace
        m_iSource = 0;  // default to current container
        m_szGPOName = L"";
        //}}AFX_DATA_INIT
        m_fPopulated = FALSE;
}


void CAddUpgrade::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAddUpgrade)
        DDX_Radio(pDX, IDC_RADIO4, m_iUpgradeType);
        DDX_Radio(pDX, IDC_RADIO1, m_iSource);
        DDX_Text(pDX, IDC_EDIT1, m_szGPOName);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddUpgrade, CDialog)
        //{{AFX_MSG_MAP(CAddUpgrade)
        ON_BN_CLICKED(IDC_RADIO1, OnCurrentContainer)
        ON_BN_CLICKED(IDC_RADIO2, OnOtherContainer)
        ON_BN_CLICKED(IDC_RADIO10, OnAllContainers)
        ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
        ON_LBN_DBLCLK(IDC_LIST1, OnOK)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade message handlers

BOOL CAddUpgrade::OnInitDialog()
{
    // If m_fPopulated is FALSE then populate the map with all packages in
    // this GPO container _EXCEPT_ the current app.
    if (!m_fPopulated)
    {
        OnCurrentContainer();
        m_szGPO = m_pScope->m_szGPO;
        m_fPopulated = TRUE;
    }
    else
    {
        // This will be done in OnCurrentContainer if m_fPopulated is FALSE
        RefreshList();
    }

    CDialog::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddUpgrade::RefreshList()
{
    // For every element in the map, if it isn't already in the upgrade
    // list then add it to the list.

    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    pList->ResetContent();

    BOOL fEnable = FALSE;

    // add all elements that aren't already in the upgrade list
    map<CString, CUpgradeData>::iterator i;
    for (i = m_NameIndex.begin(); i != m_NameIndex.end(); i++)
    {
        if (m_pUpgradeList->end() == m_pUpgradeList->find(GetUpgradeIndex(i->second.m_PackageGuid)))
        {
            fEnable = TRUE;
            pList->AddString(i->first);
            CDC * pDC = pList->GetDC();
            CSize size = pDC->GetTextExtent(i->first);
            pDC->LPtoDP(&size);
            pList->ReleaseDC(pDC);
            if (pList->GetHorizontalExtent() < size.cx)
            {
                pList->SetHorizontalExtent(size.cx);
            }
        }
    }
    GetDlgItem(IDOK)->EnableWindow(fEnable);
    if (NULL == GetFocus())
    {
        GetDlgItem(IDCANCEL)->SetFocus();
    }
    pList->SetCurSel(0);
}

void CAddUpgrade::OnOK()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int iSel = pList->GetCurSel();
    if (iSel != LB_ERR)
    {
        // only allow the dialog to close with IDOK if a selection has been made
        CDialog::OnOK();

        // Do this part later to make sure that all data members are
        // refreshed (this happens as part of the OnOk processing)
        pList->GetText(iSel, m_szPackageName);
        m_UpgradeData = m_NameIndex[m_szPackageName];
        m_UpgradeData.m_flags = (m_iUpgradeType == 1) ? UPGFLG_Uninstall : UPGFLG_NoUninstall;
    }
}

void CAddUpgrade::OnCurrentContainer()
{
    // Populate the map with all packages in this GPO container _EXCEPT_ the
    // current app.
    CString szClassStore;
    HRESULT hr = m_pScope->GetClassStoreName(szClassStore, FALSE);
    ASSERT(hr == S_OK);
    m_NameIndex.erase(m_NameIndex.begin(), m_NameIndex.end());
    map <MMC_COOKIE, CAppData>::iterator i;
    for (i = m_pScope->m_AppData.begin(); i != m_pScope->m_AppData.end(); i ++)
    {
        CString szIndex = GetUpgradeIndex(i->second.m_pDetails->pInstallInfo->PackageGuid);
        if (0 != _wcsicmp(szIndex, m_szMyGuid))
        {
            // make sure we exclude legacy apps
            if (i->second.m_pDetails->pInstallInfo->PathType != SetupNamePath)
            {
                CUpgradeData data;
                memcpy(&data.m_PackageGuid, &i->second.m_pDetails->pInstallInfo->PackageGuid, sizeof(GUID));
                data.m_szClassStore = szClassStore;
                // Add this element to the list
                m_NameIndex[i->second.m_pDetails->pszPackageName] = data;
            }
        }
    }

    RefreshList();
}

void CAddUpgrade::OnOtherContainer()
{
    // Populate the map with all packages in the other container.

    m_NameIndex.erase(m_NameIndex.begin(), m_NameIndex.end());
    WCHAR szBuffer[MAX_DS_PATH];
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO);
    if (SUCCEEDED(hr))
    {
        // open GPO object without opening registry data
        hr = pGPO->OpenDSGPO((LPOLESTR)((LPCOLESTR)m_szGPO), GPO_OPEN_READ_ONLY);
        if (SUCCEEDED(hr))
        {
            hr = pGPO->GetDSPath(m_pScope->m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
            if (SUCCEEDED(hr))
            {
                // OK, we should now have a DS path that we can use to locate
                // a class store.
                LPOLESTR szCSPath;
                hr = CsGetClassStorePath((LPOLESTR)((LPCOLESTR)szBuffer), &szCSPath);
                if (SUCCEEDED(hr))
                {
                    // now we should have the DS path to the class store itself
                    IClassAdmin * pIClassAdmin;
                    hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&pIClassAdmin);
                    if (SUCCEEDED(hr))
                    {
                        // and finally we should have a pointer to the IClassAdmin
                        IEnumPackage * pIPE = NULL;

                        HRESULT hr = pIClassAdmin->EnumPackages(NULL,
                                                                NULL,
                                                                APPQUERY_ADMINISTRATIVE,
                                                                NULL,
                                                                NULL,
                                                                &pIPE);
                        if (SUCCEEDED(hr))
                        {
                            hr = pIPE->Reset();
                            PACKAGEDISPINFO stPDI;
                            ULONG nceltFetched;
                            while (SUCCEEDED(hr))
                            {
                                hr = pIPE->Next(1, &stPDI, &nceltFetched);
                                if (nceltFetched)
                                {
                                    // make sure we exclude legacy apps
                                    // and deleted apps
                                    if (stPDI.PathType != SetupNamePath)
                                    {
                                        CString szIndex = GetUpgradeIndex(stPDI.PackageGuid);
                                        if (0 != _wcsicmp(szIndex, m_szMyGuid))
                                        {
                                            // Add this element to the list
                                            CString sz = stPDI.pszPackageName;
                                            if (0 != _wcsicmp(m_szGPO, m_pScope->m_szGPO))
                                            {
                                                // This isn't in the host GPO
                                                sz += L" (";
                                                sz += m_szGPOName;
                                                sz += L")";
                                            }
                                            CUpgradeData data;
                                            data.m_szClassStore = szCSPath;
                                            memcpy(&data.m_PackageGuid, &stPDI.PackageGuid, sizeof(GUID));
                                            m_NameIndex[sz] = data;
                                        }
                                    }
                                }
                                else
                                {
                                    break;
                                }
                                OLESAFE_DELETE(stPDI.pszPackageName);
                                OLESAFE_DELETE(stPDI.pszScriptPath);
                                OLESAFE_DELETE(stPDI.pszPublisher);
                                OLESAFE_DELETE(stPDI.pszUrl);
                                UINT n = stPDI.cUpgrades;
                                while (n--)
                                {
                                    OLESAFE_DELETE(stPDI.prgUpgradeInfoList[n].szClassStore);
                                }
                                OLESAFE_DELETE(stPDI.prgUpgradeInfoList);
                            }
                            pIPE->Release();
                        }

                        pIClassAdmin->Release();
                    }
                    OLESAFE_DELETE(szCSPath);
                }
            }
        }
        pGPO->Release();
    }

    RefreshList();
}

void CAddUpgrade::OnAllContainers()
{
    RefreshList();
}

//+--------------------------------------------------------------------------
//
//  Function:   GetDomainFromLDAPPath
//
//  Synopsis:   returns a freshly allocated string containing the LDAP path
//              to the domain name contained with an arbitrary LDAP path.
//
//  Arguments:  [szIn] - LDAP path to the initial object
//
//  Returns:    NULL - if no domain could be found or if OOM
//
//  History:     5-06-1998   stevebl   Created
//              10-20-1998   stevebl   modified to preserve server names
//
//  Notes:      This routine works by repeatedly removing leaf elements from
//              the LDAP path until an element with the "DC=" prefix is
//              found, indicating that a domain name has been located.  If a
//              path is given that is not rooted in a domain (is that even
//              possible?) then NULL would be returned.
//
//              The caller must free this path using the standard c++ delete
//              operation. (I/E this isn't an exportable function.)
//
//              Stolen from GPEDIT\UTIL.CPP
//
//---------------------------------------------------------------------------

LPOLESTR GetDomainFromLDAPPath(LPOLESTR szIn)
{
    LPOLESTR sz = NULL;
    IADsPathname * pADsPathname = NULL;
    HRESULT hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (SUCCEEDED(hr))
    {
        hr = pADsPathname->Set(szIn, ADS_SETTYPE_FULL);
        if (SUCCEEDED(hr))
        {
            BSTR bstr;
            BOOL fStop = FALSE;

            while (!fStop)
            {
                hr = pADsPathname->Retrieve(ADS_FORMAT_LEAF, &bstr);
                if (SUCCEEDED(hr))
                {

                    // keep peeling them off until we find something
                    // that is a domain name
                    fStop = (0 == _wcsnicmp(L"DC=", bstr, 3));
                    SysFreeString(bstr);
                }
                else
                {
                     DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve leaf with 0x%x."), hr));
                }

                if (!fStop)
                {
                    hr = pADsPathname->RemoveLeafElement();
                    if (FAILED(hr))
                    {
                        DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to remove leaf with 0x%x."), hr));
                        fStop = TRUE;
                    }
                }
            }

            hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
            if (SUCCEEDED(hr))
            {
                sz = new OLECHAR[wcslen(bstr)+1];
                if (sz)
                {
                    wcscpy(sz, bstr);
                }
                SysFreeString(bstr);
            }
            else
            {
                 DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve full path with 0x%x."), hr));
            }
        }
        else
        {
             DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to set pathname with 0x%x."), hr));
        }

        pADsPathname->Release();
    }
    else
    {
         DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to CoCreateInstance for IID_IADsPathname with 0x%x."), hr));
    }


    return sz;
}


void CAddUpgrade::OnBrowse()
{
    // Browse to the other container and then call OnOtherContainer.
    OLECHAR szPath[MAX_DS_PATH];
    OLECHAR szName[256];
    GPOBROWSEINFO stGBI;
    memset(&stGBI, 0, sizeof(GPOBROWSEINFO));
    stGBI.dwSize = sizeof(GPOBROWSEINFO);
    stGBI.dwFlags = GPO_BROWSE_NOCOMPUTERS | GPO_BROWSE_INITTOALL;
    stGBI.hwndOwner = m_hWnd;
    stGBI.lpInitialOU =  GetDomainFromLDAPPath((LPWSTR)((LPCWSTR)m_szGPO));
    stGBI.lpDSPath = szPath;
    stGBI.dwDSPathSize = MAX_DS_PATH;
    stGBI.lpName = szName;
    stGBI.dwNameSize = 256;
    if (SUCCEEDED(BrowseForGPO(&stGBI)))
    {
        m_szGPO = szPath;
        m_szGPOName = szName;
        m_iSource = 1;
        UpdateData(FALSE);
        OnOtherContainer();
    }
    if (stGBI.lpInitialOU != NULL)
    {
        delete [] stGBI.lpInitialOU;
    }
}

LRESULT CAddUpgrade::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CAddUpgrade::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_FIND_UPGRADE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\category.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Category.h
//
//  Contents:   categories property page (for an application)
//
//  Classes:    CCategory
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Category.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCategory dialog

class CCategory : public CPropertyPage
{
        DECLARE_DYNCREATE(CCategory)

// Construction
public:
        CCategory();
        ~CCategory();

        CCategory ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CCategory)
        enum { IDD = IDD_CATEGORY };
        CListBox        m_Available;
        CListBox        m_Assigned;
        //}}AFX_DATA
        CAppData *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fModified;
        BOOL            m_fRSOP;
        BOOL            m_fPreDeploy;
        APPCATEGORYINFOLIST * m_pCatList;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCategory)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CCategory)
        afx_msg void OnAssign();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        afx_msg void OnSelchangeList1();
        afx_msg void OnSelchangeList2();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshData(void);
        BOOL IsAssigned(GUID &);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\catlist.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       CatList.h
//
//  Contents:   master category list property page
//
//  Classes:    CCatList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CatList.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCatList dialog

class CCatList : public CPropertyPage
{
        DECLARE_DYNCREATE(CCatList)

// Construction
public:
        CCatList();
        ~CCatList();

        CCatList ** m_ppThis;
        CScopePane * m_pScopePane;
        multimap<CString, DWORD>    m_Categories;
        CString         m_szDomainName;
        BOOL            m_fRSOP;

// Dialog Data
        //{{AFX_DATA(CCatList)
        enum { IDD = IDD_CATEGORIES };
        CListBox        m_cList;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCatList)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CCatList)
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        afx_msg void OnModify();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
        void RefreshData(void);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\catlist.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       CatList.cpp
//
//  Contents:   main tool-wide categories list property page
//
//  Classes:    CCatList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAXCATEGORYNAME 40

/////////////////////////////////////////////////////////////////////////////
// CCatList property page

IMPLEMENT_DYNCREATE(CCatList, CPropertyPage)

CCatList::CCatList() : CPropertyPage(CCatList::IDD)
{
        //{{AFX_DATA_INIT(CCatList)
        //}}AFX_DATA_INIT
}

CCatList::~CCatList()
{
    *m_ppThis = NULL;
}
void CCatList::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCatList)
        DDX_Control(pDX, IDC_LIST1, m_cList);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCatList, CPropertyPage)
        //{{AFX_MSG_MAP(CCatList)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
        ON_LBN_DBLCLK(IDC_LIST1, OnModify)
        ON_BN_CLICKED(IDC_BUTTON3, OnModify)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCatList message handlers

void CCatList::OnAdd()
{
    CEditString dlgEditString;
    dlgEditString.m_szTitle.LoadString(IDS_NEWCATEGORY);
    if (IDOK == dlgEditString.DoModal())
    {
        if (dlgEditString.m_sz.GetLength() == 0)
        {
            // empty name
            CString szMessage;
            szMessage.LoadString(IDS_SHORTCATNAME);
            MessageBox(szMessage,
                         NULL,
                         MB_OK | MB_ICONEXCLAMATION);
            return;
        }
        if (dlgEditString.m_sz.GetLength() > MAXCATEGORYNAME)
        {
            // long name
            CString szMessage;
            szMessage.LoadString(IDS_LONGCATNAME);
            MessageBox(szMessage,
                         NULL,
                         MB_OK | MB_ICONEXCLAMATION);
            return;
        }
        // only add categories that are unique
        if (m_Categories.find(dlgEditString.m_sz) == m_Categories.end())
        {
            m_Categories.insert(pair<const CString,ULONG>(dlgEditString.m_sz, (ULONG)-1));
            m_cList.AddString(dlgEditString.m_sz);
            m_cList.SelectString(0, dlgEditString.m_sz);
            GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE);
            GetDlgItem(IDC_BUTTON3)->EnableWindow(TRUE);
            CDC * pDC = m_cList.GetDC();
            CSize size = pDC->GetTextExtent(dlgEditString.m_sz);
            pDC->LPtoDP(&size);
            m_cList.ReleaseDC(pDC);
            if (m_cList.GetHorizontalExtent() < size.cx)
            {
                m_cList.SetHorizontalExtent(size.cx);
            }
            SetModified();
        }
    }
}

void CCatList::OnRemove()
{
    int i = m_cList.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_cList.GetText(i, sz);
        m_Categories.erase(m_Categories.find(sz));
        m_cList.DeleteString(i);
        if (i > 0 && i >= m_cList.GetCount())
        {
            i = m_cList.GetCount() - 1;
        }
        m_cList.SetCurSel(i);
        int n = m_cList.GetCount();
        BOOL fEnable = n > 0;
        GetDlgItem(IDC_BUTTON2)->EnableWindow(fEnable);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(fEnable);
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        SetModified();
    }
}

LRESULT CCatList::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CCatList::RefreshData(void)
{
    // build up m_Categories and populate the list box
    m_cList.ResetContent();
    m_cList.SetHorizontalExtent(0);
    m_Categories.erase(m_Categories.begin(), m_Categories.end());
    UINT i = m_pScopePane->m_CatList.cCategory;
    while (i--)
    {
        m_Categories.insert(pair<const CString, ULONG>(m_pScopePane->m_CatList.pCategoryInfo[i].pszDescription, i));
        m_cList.AddString(m_pScopePane->m_CatList.pCategoryInfo[i].pszDescription);
        CDC * pDC = m_cList.GetDC();
        CSize size = pDC->GetTextExtent(m_pScopePane->m_CatList.pCategoryInfo[i].pszDescription);
        pDC->LPtoDP(&size);
        m_cList.ReleaseDC(pDC);
        if (m_cList.GetHorizontalExtent() < size.cx)
        {
            m_cList.SetHorizontalExtent(size.cx);
        }
    }
    m_cList.SetCurSel(0);
    int n = m_cList.GetCount();
    BOOL fEnable = (n > 0) && (!m_fRSOP);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(fEnable);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(fEnable);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
    SetModified(FALSE);
}


BOOL CCatList::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        CWnd * pCtrl = GetDlgItem(IDC_STATIC1);
        CString sz;
        CString szNew;
        pCtrl->GetWindowText(sz);
        szNew.Format(sz, m_szDomainName);
        pCtrl->SetWindowText(szNew);

        // unmarshal the IClassAdmin interface
        RefreshData();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CCatList::OnModify()
{
    int i = m_cList.GetCurSel();
    if (i != LB_ERR)
    {
        CEditString dlgEditString;
        dlgEditString.m_szTitle.LoadString(IDS_CHANGECATEGORY);
        CString sz;
        m_cList.GetText(i, sz);
        dlgEditString.m_sz = sz;
        if (IDOK == dlgEditString.DoModal())
        {
            if (dlgEditString.m_sz.GetLength() == 0)
            {
                // empty name
                CString szMessage;
                szMessage.LoadString(IDS_SHORTCATNAME);
                MessageBox(  szMessage,
                             NULL,
                             MB_OK | MB_ICONEXCLAMATION);
                return;
            }
            if (dlgEditString.m_sz.GetLength() > MAXCATEGORYNAME)
            {
                // long name
                CString szMessage;
                szMessage.LoadString(IDS_LONGCATNAME);
                MessageBox(  szMessage,
                             NULL,
                             MB_OK | MB_ICONEXCLAMATION);
                return;
            }
            multimap<CString, ULONG>::iterator element = m_Categories.find(sz);
            ULONG index = element->second;
            m_Categories.erase(element);
            m_Categories.insert(pair<const CString, ULONG>(dlgEditString.m_sz, index));
            m_cList.DeleteString(i);
            m_cList.AddString(dlgEditString.m_sz);
            m_cList.SelectString(0, dlgEditString.m_sz);
            CDC * pDC = m_cList.GetDC();
            CSize size = pDC->GetTextExtent(dlgEditString.m_sz);
            pDC->LPtoDP(&size);
            m_cList.ReleaseDC(pDC);
            if (m_cList.GetHorizontalExtent() < size.cx)
            {
                m_cList.SetHorizontalExtent(size.cx);
            }
            SetModified();
        }
    }
}


BOOL CCatList::OnApply()
{
    if (this->m_fRSOP)
    {
        return CPropertyPage::OnApply();
    }
    // Build up a set of indexes.  As an element is found in our private
    // list, it will be removed from this set.  Whatever is left in the set
    // are elements that are to be removed from the class store.
    set<ULONG> sIndexes;
    ULONG n = m_pScopePane->m_CatList.cCategory;
    while (n--)
    {
        sIndexes.insert(n);
    }

    // walk our list of categories modifying or adding categories on the
    // class store as necessary
    HRESULT hr = S_OK;
    multimap<CString, ULONG>::iterator element;
    for (element = m_Categories.begin(); element != m_Categories.end(); element++)
    {
        if (element->second == (ULONG)-1)
        {
            // this is a new category
            APPCATEGORYINFO AppCategory;
            AppCategory.Locale = GetUserDefaultLCID();
            AppCategory.pszDescription = (LPOLESTR)((LPCOLESTR)element->first);
            hr = CoCreateGuid(&AppCategory.AppCategoryId);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_NOCATEGORYGUID_ERROR, hr, AppCategory.pszDescription);
                goto failure;
            }
            hr = CsRegisterAppCategory(&AppCategory);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_ADDCATEGORY_ERROR, hr, AppCategory.pszDescription);
                goto failure;
            }
            LogADEEvent(EVENTLOG_SUCCESS, EVENT_ADE_ADDCATEGORY, hr, AppCategory.pszDescription);
        }
        else
        {
            // this is an old category
            sIndexes.erase(element->second);

            if (0 != element->first.Compare(m_pScopePane->m_CatList.pCategoryInfo[element->second].pszDescription))
            {
                // the category has been renamed
                APPCATEGORYINFO AppCategory;
                AppCategory.Locale = GetUserDefaultLCID();
                AppCategory.pszDescription = (LPOLESTR)((LPCOLESTR)element->first);
                AppCategory.AppCategoryId = m_pScopePane->m_CatList.pCategoryInfo[element->second].AppCategoryId;
                hr = CsRegisterAppCategory(&AppCategory);
                if (FAILED(hr))
                {
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_RENAMECATEGORY_ERROR, hr, AppCategory.pszDescription);
                    goto failure;
                }
                LogADEEvent(EVENTLOG_SUCCESS, EVENT_ADE_RENAMECATEGORY, hr, AppCategory.pszDescription);
            }
        }
    }

    // remove deleted categories
    {
        set<ULONG>::iterator i;
        for (i = sIndexes.begin(); i != sIndexes.end(); i++)
        {
            hr = CsUnregisterAppCategory(&m_pScopePane->m_CatList.pCategoryInfo[*i].AppCategoryId);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_REMOVECATEGORY_ERROR, hr, m_pScopePane->m_CatList.pCategoryInfo[*i].pszDescription);
                goto failure;
            }
            LogADEEvent(EVENTLOG_SUCCESS, EVENT_ADE_REMOVECATEGORY, hr, m_pScopePane->m_CatList.pCategoryInfo[*i].pszDescription);
        }
    }

failure:
    // reload the list of categories from the class store
    m_pScopePane->ClearCategories();
    CsGetAppCategories(&m_pScopePane->m_CatList);

    // tell any open package category property pages to refresh
    {
        map<MMC_COOKIE, CAppData>::iterator i;
        for (i = m_pScopePane->m_AppData.begin(); i != m_pScopePane->m_AppData.end(); i++)
        {
            if (i->second.m_pCategory)
            {
                i->second.m_pCategory->SendMessage(WM_USER_REFRESH, 0, 0);
            }
        }
    }
    // refresh the data
    RefreshData();
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CATEGORYFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    return CPropertyPage::OnApply();
}


void CCatList::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_CATEGORIES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\advdep.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       AdvDep.h
//
//  Contents:   advanced deployment settings dialog
//
//  Classes:
//
//  Functions:
//
//  History:    01-28-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#if !defined(AFX_ADVDEP_H__5F6E7E00_B6D2_11D2_B91F_0080C7971BE1__INCLUDED_)
#define AFX_ADVDEP_H__5F6E7E00_B6D2_11D2_B91F_0080C7971BE1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AdvDep.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAdvDep dialog

class CDeploy;

class CAdvDep : public CDialog
{
// Construction
public:
    CAdvDep(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CAdvDep)
    enum { IDD = IDD_ADVDEP };
    BOOL    m_fIgnoreLCID;
    BOOL    m_fInstallOnAlpha;
    BOOL    m_fUninstallUnmanaged;
    BOOL    m_f32On64;
    BOOL    m_fIncludeOLEInfo;
    CString m_szProductCode;
    CString m_szDeploymentCount;
    CString m_szScriptName;
    //}}AFX_DATA

    CDeploy *   m_pDeploy;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAdvDep)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAdvDep)
    virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADVDEP_H__5F6E7E00_B6D2_11D2_B91F_0080C7971BE1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\category.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Category.cpp
//
//  Contents:   Categories property page (for an application)
//
//  Classes:    CCategory
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCategory property page

IMPLEMENT_DYNCREATE(CCategory, CPropertyPage)

CCategory::CCategory() : CPropertyPage(CCategory::IDD)
{
        //{{AFX_DATA_INIT(CCategory)
        //}}AFX_DATA_INIT
    m_pIClassAdmin = NULL;
    m_ppThis = NULL;
    m_fPreDeploy = FALSE;
}

CCategory::~CCategory()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CCategory::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCategory)
        DDX_Control(pDX, IDC_LIST1, m_Available);
        DDX_Control(pDX, IDC_LIST2, m_Assigned);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCategory, CPropertyPage)
        //{{AFX_MSG_MAP(CCategory)
        ON_BN_CLICKED(IDC_BUTTON1, OnAssign)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
        ON_LBN_DBLCLK(IDC_LIST1, OnAssign)
        ON_LBN_DBLCLK(IDC_LIST2, OnRemove)
        ON_LBN_SELCHANGE(IDC_LIST1, OnSelchangeList1)
        ON_LBN_SELCHANGE(IDC_LIST2, OnSelchangeList2)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCategory message handlers

void CCategory::OnSelchangeList1()
{
    BOOL fOK = FALSE;
    int iSel = m_Available.GetCurSel();
    if (iSel != LB_ERR)
    {
        fOK = TRUE;
    }
    GetDlgItem(IDC_BUTTON1)->EnableWindow(fOK && (!m_fRSOP));
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CCategory::OnSelchangeList2()
{
    BOOL fOK = FALSE;
    int iSel = m_Assigned.GetCurSel();
    if (iSel != LB_ERR)
    {
        fOK = TRUE;
    }
    GetDlgItem(IDC_BUTTON2)->EnableWindow(fOK && (!m_fRSOP));
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}


void CCategory::OnAssign()
{
    if ( m_fRSOP )
    {
        return;
    }

    int i = m_Available.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_Available.GetText(i, sz);
        m_Available.DeleteString(i);
        if (i > 0 && i >= m_Available.GetCount())
        {
            i = m_Available.GetCount() - 1;
        }
        GetDlgItem(IDC_BUTTON1)->EnableWindow(
            LB_ERR != m_Available.SetCurSel(i));
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        m_Assigned.AddString(sz);
        CDC * pDC = m_Assigned.GetDC();
        CSize size = pDC->GetTextExtent(sz);
        pDC->LPtoDP(&size);
        m_Assigned.ReleaseDC(pDC);
        if (m_Assigned.GetHorizontalExtent() < size.cx)
        {
            m_Assigned.SetHorizontalExtent(size.cx);
        }
        m_Assigned.SelectString(-1, sz);
        GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE);
        m_fModified = TRUE;
        if (!m_fPreDeploy)
            SetModified();
    }
}

void CCategory::OnRemove()
{
    if ( m_fRSOP )
    {
        return;
    }

    int i = m_Assigned.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_Assigned.GetText(i, sz);
        m_Assigned.DeleteString(i);
        if (i > 0 && i >= m_Assigned.GetCount())
        {
            i = m_Assigned.GetCount() - 1;
        }
        GetDlgItem(IDC_BUTTON2)->EnableWindow(
            LB_ERR != m_Assigned.SetCurSel(i));
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        m_Available.AddString(sz);
        m_Available.SelectString(-1, sz);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(TRUE);
        m_fModified = TRUE;
        if (!m_fPreDeploy)
            SetModified();
    }
}

BOOL CCategory::OnApply()
{
    if (m_fModified)
    {
        if (this->m_fRSOP)
        {
            return CPropertyPage::OnApply();
        }
        multimap<CString, GUID> Categories;

        // build a mapping from category names to guids
        DWORD n = m_pCatList->cCategory;
        while (n--)
        {
            Categories.insert(pair<const CString, GUID>(m_pCatList->pCategoryInfo[n].pszDescription, m_pCatList->pCategoryInfo[n].AppCategoryId));
        }

        // build the list of categories assigned to this app
        UINT cCategories = m_Assigned.GetCount();
        HRESULT hr = E_FAIL;
        GUID * rpCategory = (GUID *)OLEALLOC(sizeof(GUID) * cCategories);
        CString sz;
        if (rpCategory)
        {
            UINT index = cCategories;
            while (index--)
            {
                m_Assigned.GetText(index, sz);
                rpCategory[index] = Categories.find(sz)->second;
            }

            if (m_pIClassAdmin)
            {
                hr = m_pIClassAdmin->ChangePackageCategories(m_pData->m_pDetails->pszPackageName,
                                                             cCategories,
                                                             rpCategory);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            OLESAFE_DELETE(m_pData->m_pDetails->rpCategory);
            m_pData->m_pDetails->cCategories = cCategories;
            m_pData->m_pDetails->rpCategory = rpCategory;
            m_fModified = FALSE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ChangePackageCategories failed with 0x%x"), hr));
            // apply failed
            OLESAFE_DELETE(rpCategory);
            CString sz;
            sz.LoadString(IDS_CATEGORYFAILED);
            ReportGeneralPropertySheetError(m_hWnd, sz, hr);
            return FALSE;
        }
    }
    return CPropertyPage::OnApply();
}

BOOL CCategory::OnInitDialog()
{
        CPropertyPage::OnInitDialog();
        RefreshData();
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CCategory::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

BOOL CCategory::IsAssigned(GUID & guid)
{
    UINT n = m_pData->m_pDetails->cCategories;
    while (n--)
    {
        if (IsEqualGUID(guid, m_pData->m_pDetails->rpCategory[n]))
        {
            return TRUE;
        }
    }

    return FALSE;
}

void CCategory::RefreshData()
{
    GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(FALSE);
    m_Assigned.ResetContent();
    m_Available.ResetContent();
    m_Assigned.SetHorizontalExtent(0);
    m_Available.SetHorizontalExtent(0);

    // for each category available, determine if it has been assigned or not
    DWORD n = m_pCatList->cCategory;
    while (n--)
    {
        if (IsAssigned(m_pCatList->pCategoryInfo[n].AppCategoryId))
        {
            // it's assigned
            m_Assigned.AddString(m_pCatList->pCategoryInfo[n].pszDescription);
            CDC * pDC = m_Assigned.GetDC();
            CSize size = pDC->GetTextExtent(m_pCatList->pCategoryInfo[n].pszDescription);
            pDC->LPtoDP(&size);
            m_Assigned.ReleaseDC(pDC);
            if (m_Assigned.GetHorizontalExtent() < size.cx)
            {
                m_Assigned.SetHorizontalExtent(size.cx);
            }
            GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE && (!m_fRSOP));
        }
        else
        {
            // it's not assigned
            m_Available.AddString(m_pCatList->pCategoryInfo[n].pszDescription);
            CDC * pDC = m_Available.GetDC();
            CSize size = pDC->GetTextExtent(m_pCatList->pCategoryInfo[n].pszDescription);
            pDC->LPtoDP(&size);
            m_Available.ReleaseDC(pDC);
            if (m_Available.GetHorizontalExtent() < size.cx)
            {
                m_Available.SetHorizontalExtent(size.cx);
            }
            GetDlgItem(IDC_BUTTON1)->EnableWindow(TRUE && (!m_fRSOP));
        }
    }

    m_Assigned.SetCurSel(0);
    m_Available.SetCurSel(0);
    m_fModified = FALSE;
    SetModified(FALSE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}


void CCategory::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_CATEGORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\cause.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       cause.h
//
//  Contents:   RSOP's Cause property sheet
//
//  Classes:    CCause
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#if !defined(AFX_CAUSE_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CAUSE_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CCause dialog

class CCause : public CPropertyPage
{
        DECLARE_DYNCREATE(CCause)

// Construction
public:
        CCause();
        ~CCause();
        CCause ** m_ppThis;
        CAppData * m_pData;
        BOOL    m_fRemovedView;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CCause)
        enum { IDD = IDD_RSOPCAUSE};
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCause)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CCause)
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG\

        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CAUSE_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\common.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       common.h
//
//  Contents:   common definitions used by the main snapin modules
//
//  Classes:    CResultPane, CScopePane
//
//  History:    03-14-1998   stevebl   Commented
//              05-20-1998   RahulTh   Added CScopePane::DetectUpgrades
//                                     for auto-upgrade detection
//              05-10-2001   RahulTh   Added infrastructure for enabling
//                                     theme'ing of UI components.
//
//---------------------------------------------------------------------------

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#include "objidl.h"
#include "data.h"
#include "gpedit.h"
#include "adeevent.h"
#include "iads.h"
#include <iadsp.h>
#include <ntdsapi.h>
#include <dssec.h>
#include <set>
#include <shfusion.h>

//
// Add theme'ing support. Since we use MFC, we need to perform some additional
// tasks in order to get all our UI elements theme'd. We need this class to
// activate the theme'ing context around any UI that we want theme'd.
//
class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};


// Uncomment the next line to re-enable the digital signatures code.
// #define DIGITAL_SIGNATURES 1
// Digital signatures have been cut in faver of the "SAFER" technology.

class CUpgrades;    //forward declaration; added RahulTh 5/19/1998.

// private notifications
#define WM_USER_REFRESH     (WM_USER + 1000)
#define WM_USER_CLOSE       (WM_USER + 1001)

// very big number to be sure that we can always squeeze a DS path into it
#define MAX_DS_PATH         1024

// Note - This is the offset in my image list that represents the folder
const FOLDER_IMAGE_IDX = 0;
const OPEN_FOLDER_IMAGE_IDX = 5;
extern HINSTANCE ghInstance;

extern const CLSID CLSID_Snapin;
extern CLSID CLSID_Temp;
extern const wchar_t * szCLSID_Snapin;
extern const CLSID CLSID_MachineSnapin;
extern const wchar_t * szCLSID_MachineSnapin;
extern const GUID cNodeType;
extern const wchar_t*  cszNodeType;
extern GUID guidExtension;
extern GUID guidUserSnapin;
extern GUID guidMachSnapin;

// RSOP GUIDS
extern const CLSID CLSID_RSOP_Snapin;
extern const wchar_t * szCLSID_RSOP_Snapin;
extern const CLSID CLSID_RSOP_MachineSnapin;
extern const wchar_t * szCLSID_RSOP_MachineSnapin;
extern GUID guidRSOPUserSnapin;
extern GUID guidRSOPMachSnapin;

typedef enum NEW_PACKAGE_BEHAVIORS
{
    NP_PUBLISHED = 0,
    NP_ASSIGNED,
    NP_DISABLED,
    NP_UPGRADE
} NEW_PACKAGE_BEHAVIOR;

typedef enum tagUPGRADE_DISPOSITION
{
    UNINSTALL_EXISTING = 0x0,
    BLOCK_INSTALL = 0x1,
    INSTALLED_GREATER = 0x2,
    INSTALLED_LOWER = 0x4,
    INSTALLED_EQUAL = 0x8,
    MIGRATE_SETTINGS = 0x10
} UPGRADE_DISPOSITION;

#define IMG_OPENBOX   0
#define IMG_CLOSEDBOX 1
#define IMG_DISABLED  2
#define IMG_PUBLISHED 3
#define IMG_ASSIGNED  4
#define IMG_UPGRADE   5
#define IMG_OPEN_FAILED 6
#define IMG_CLOSED_FAILED 7

#define CFGFILE _T("ADE.CFG")

// Uncomment the next line to return to the old way of deploying packages
// with multiple LCIDs.  With this commented only the primary (first)
// LCID gets a deployment.
//#define DEPLOY_MULTIPLE_LCIDS

// Uncomment the next line to include country names in text representations
// of LCIDs.
//#define SHOWCOUNTRY 0

//
// MACROS for allocating and freeing memory via OLE's common allocator: IMalloc.
//
// (NOTE) the Class Store API no longer use IMalloc so thes macros have been
// reverted back to using new and free.
//

//extern IMalloc * g_pIMalloc;

// UNDONE - throw exception on failure

#define OLEALLOC(x) LocalAlloc(0, x)
//#define OLEALLOC(x) g_pIMalloc->Alloc(x)

#define OLESAFE_DELETE(x) if (x) {LocalFree(x); x = NULL;}
//#define OLESAFE_DELETE(x) if (x) {g_pIMalloc->Free(x); x = NULL;}

#define OLESAFE_COPYSTRING(szO, szI) {if (szI) {int i_dontcollidewithanything = wcslen(szI); szO=(OLECHAR *)OLEALLOC(sizeof(OLECHAR) * (i_dontcollidewithanything+1)); if (szO) wcscpy(szO, szI);} else szO=NULL;}

// Keys used in the CFG file.
//
// The CFG file is found in the Applications directory of the SysVol (which
// is the same directory as the script files).
//
// The format of an entry in the CFG file is:
//
//      %key%=%data%
//
// where %data% is either an integer or a string as appropriate.
//
// Order is not important and if a key is not present in the CFG file then
// the default setting will be used.  Some keys (iDebugLevel and
// fShowPkgDetails) will only be saved in the CFG file if their values are
// different from the default settings.
//
#define KEY_NPBehavior      L"Default Deployment"
#define KEY_fCustomDeployment L"Use Custom Deployment"
#define KEY_fUseWizard      L"Use Deployment Wizard"
#define KEY_UILevel         L"UI Level"
#define KEY_szStartPath     L"Start Path"
#define KEY_iDebugLevel     L"Debug Level"
#define KEY_fShowPkgDetails L"Package Details"
#define KEY_f32On64         L"Run 32b Apps on 64b"
#define KEY_fZapOn64        L"Run ZAP Apps on 64b"
#define KEY_fExtensionsOnly L"Only Deploy Extension Info"
#define KEY_nUninstallTrackingMonths L"Uninstall Tracking Months"
#define KEY_fUninstallOnPolicyRemoval L"Uninstall On Policy Removal"

typedef struct tagTOOL_DEFAULTS
{
    NEW_PACKAGE_BEHAVIOR    NPBehavior;
    BOOL                    fCustomDeployment;
    BOOL                    fUseWizard;
    INSTALLUILEVEL          UILevel;
    CString                 szStartPath;
    int                     iDebugLevel;
    BOOL                    fShowPkgDetails;
    ULONG                   nUninstallTrackingMonths;
    BOOL                    fUninstallOnPolicyRemoval;
    BOOL                    fZapOn64;
    BOOL                    f32On64;
    BOOL                    fExtensionsOnly;
} TOOL_DEFAULTS;

/////////////////////////////////////////////////////////////////////////////
// Snapin

typedef set<long> EXTLIST;

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);

class CToolDefs;
class CToolAdvDefs;
class CTracking;
class CCatList;
class CFileExt;
class CSignatures;

class CScopePane:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public IExtendPropertySheet,
    public ISnapinAbout,
    public ISnapinHelp,
    public CComObjectRoot
{

    friend class CResultPane;
    friend class CDataObject;

public:
        CScopePane();
        ~CScopePane();

        HWND m_hwndMainWindow;
        LPRSOPINFORMATION    m_pIRSOPInformation;  // Interface pointer to the GPT
protected:
    LPGPEINFORMATION    m_pIGPEInformation;  // Interface pointer to the GPT
    BOOL                m_fRSOPEnumerate;      // OK to enumerate RSoP data
    BOOL                m_fRSOPPolicyFailed;  // TRUE if there was a failure applying SI policy

public:
    DWORD               m_dwRSOPFlags;
    virtual IUnknown * GetMyUnknown() = 0;

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStreamInit interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(InitNew)(VOID);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// ISnapinAbout interface
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR * lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion);
    STDMETHOD(GetSnapinImage)(HICON * hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP * hSmallImage,
                                 HBITMAP * hSmallImageOpen,
                                 HBITMAP * hLargeImage,
                                 COLORREF * cMask);
    //
    // Implemented ISnapinHelp interface members
    //
public:
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile);

// Notify handler declarations
private:
    HRESULT OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);
    STDMETHOD(ChangePackageState)(CAppData & data, DWORD dwNewFlags, BOOL fShowUI);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CScopePane::AddRef  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CScopePane::Release  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    void DeleteList();
    void EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);
    HRESULT InitializeADE();
    HRESULT GetDeploymentType(PACKAGEDETAIL * ppd, BOOL & fShowPropertySheet);
    HRESULT DeployPackage(PACKAGEDETAIL * ppd, BOOL fShowPropertySheet);
    HRESULT AddZAPPackage(LPCOLESTR szPackagePath,
                          LPCOLESTR lpFileTitle);
    HRESULT AddMSIPackage(LPCOLESTR szPackagePath,
                          LPCOLESTR lpFileTitle);
    HRESULT RemovePackage(MMC_COOKIE cookie, BOOL fForceUninstall, BOOL fRemoveNow);
    void Refresh();
    HRESULT DetectUpgrades (LPCOLESTR szPackagePath, const PACKAGEDETAIL* ppd, CUpgrades& dlgUpgrade);
    HRESULT TestForRSoPData(BOOL * pfPolicyFailed);

private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;
    BOOL                    m_bIsDirty;
    IClassAdmin *           m_pIClassAdmin;
    BOOL m_fExtension;
    BOOL m_fLoaded;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    void AddScopeItemToResultPane(MMC_COOKIE cookie);
    UINT CreateNestedDirectory (LPTSTR lpPath, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    HRESULT GetClassStore(BOOL fCreateOK);
    void LoadToolDefaults();
    void SaveToolDefaults();
    set <CResultPane *> m_sResultPane;
    IPropertySheetProvider * m_pIPropertySheetProvider;

    BOOL                    m_fBlockAddPackage; // don't use a crit-sec
                                                // because all MMC UI is
                                                // always called from
                                                // the same thread

public:
    void GetUniquePackageName(CString szIn, CString &szOut, int &nHint);
    HRESULT GetClassStoreName(CString &, BOOL fCreateOK);
    void    DisplayPropSheet(CString szPackageName, int iPage);
    HRESULT PopulateUpgradeLists();
    HRESULT InsertUpgradeEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT RemoveUpgradeEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT PopulateExtensions();
    HRESULT InsertExtensionEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT RemoveExtensionEntry(MMC_COOKIE cookie, CAppData &data);
    HRESULT PrepareExtensions(PACKAGEDETAIL &pd);
    HRESULT ClearCategories();
    HRESULT GetPackageDSPath(CString &szPath, LPOLESTR szPackageName);
    HRESULT GetPackageNameFromUpgradeInfo(CString &szPackageName, GUID & PackageGuid, LPOLESTR szCSPath);
    HRESULT GetRSoPCategories(void);
    void    CScopePane::RemoveResultPane(CResultPane * pRP);

    // global property pages
    CToolDefs *             m_pToolDefs;
    CToolAdvDefs *          m_pToolAdvDefs;
    CTracking *             m_pTracking;
    CCatList *              m_pCatList;
    CFileExt *              m_pFileExt;
#ifdef DIGITAL_SIGNATURES
    CSignatures *           m_pSignatures;
#endif // DIGITAL_SIGNATURES

    CString m_szGPT_Path;
    CString m_szGPO;
    CString m_szGPODisplayName;
    CString m_szDomainName;
    CString m_szLDAP_Path;
    CString m_szFolderTitle;
    CString m_szRSOPNamespace;

    map <MMC_COOKIE, CAppData>    m_AppData;      // One entry for each
                                            // application in the class
                                            // store.  Maps cookies to
                                            // application packages.
    map <CString, EXTLIST>  m_Extensions;   // Maps extensions to the
                                            // list of apps that support
                                            // them.
    map <CString, MMC_COOKIE>     m_UpgradeIndex; // Maps upgrade GUIDs to the
                                            // apps that they belong to.
    APPCATEGORYINFOLIST     m_CatList;      // category list
    TOOL_DEFAULTS m_ToolDefaults;
    BOOL        m_fMachine;
    BOOL        m_fRSOP;
    int         m_iViewState;
    BOOL        m_fDisplayedRsopARPWarning;

    MMC_COOKIE m_lLastAllocated;
};

class CMachineComponentDataImpl:
    public CScopePane,
    public CComCoClass<CMachineComponentDataImpl, &CLSID_MachineSnapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CMachineComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CMachineComponentDataImpl()
    {
        m_fMachine = TRUE;
        m_fRSOP = FALSE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CUserComponentDataImpl, &CLSID_Snapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CUserComponentDataImpl()
    {
        m_fMachine = FALSE;
        m_fRSOP = FALSE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CRSOPMachineComponentDataImpl:
    public CScopePane,
    public CComCoClass<CRSOPMachineComponentDataImpl, &CLSID_RSOP_MachineSnapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CRSOPMachineComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CRSOPMachineComponentDataImpl()
    {
        m_fMachine = TRUE;
        m_fRSOP = TRUE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CRSOPUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CRSOPUserComponentDataImpl, &CLSID_RSOP_Snapin>
{
public:

DECLARE_REGISTRY(CScopePane, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CRSOPUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CRSOPUserComponentDataImpl()
    {
        m_fMachine = FALSE;
        m_fRSOP = TRUE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CResultPane :
    public IComponent,
    public IExtendContextMenu,
    public IExtendControlbar,
    public IExtendPropertySheet,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
    BOOL _fVisible;
        CResultPane();
        ~CResultPane();

BEGIN_COM_MAP(CResultPane)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;
    LPDISPLAYHELP m_pDisplayHelp;

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helpers for CResultPane
public:
    void SetIComponentData(CScopePane* pData);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CResultPane::AddRef  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
//        DebugMsg((DM_WARNING, TEXT("CResultPane::Release  this=%08x ref=%u"), this, dbg_cRef));
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPARAM param);
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick);
    BOOL OnFileDrop (LPDATAOBJECT lpDataObject);

public:
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);

// IExtendContextMenu
public:

    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// Helper functions
protected:
    void Construct();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

    void Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent);

public:
    void EnumerateResultPane(MMC_COOKIE cookie);
    HRESULT EnumerateRSoPData(void);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    CScopePane * m_pScopePane;
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LONG                m_lViewMode;    // View mode

public:
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPTOOLBAR           m_pToolbar;
    LPCONTROLBAR        m_pControlbar;

    int                 m_nSortColumn;
    DWORD               m_dwSortOptions;


protected:
//    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
//    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
//    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars

//    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
//    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar

// Header titles for each nodetype(s)
protected:
    CString m_szFolderTitle;
};

inline void CResultPane::SetIComponentData(CScopePane* pData)
{
    ASSERT(pData);
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::SetIComponentData  pData=%08x."), pData));
    ASSERT(m_pScopePane == NULL);
    LPUNKNOWN pUnk = pData->GetMyUnknown();
    pUnk->AddRef();
#if 0
    HRESULT hr;

    LPCOMPONENTDATA lpcd;
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&lpcd));
    ASSERT(hr == S_OK);
    if (SUCCEEDED(hr))
    {
        m_pScopePane = dynamic_cast<CScopePane*>(lpcd);
    }
#else
    m_pScopePane = pData;
#endif
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

class CHourglass
{
    private:
    HCURSOR m_hcurSaved;

    public:
    CHourglass()
    {
        m_hcurSaved = ::SetCursor(::LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    ~CHourglass()
    {
        ::SetCursor(m_hcurSaved);
    };
};

class CUpgradeData
{
public:
    GUID    m_PackageGuid;
    CString m_szClassStore;
    int     m_flags;
};

LRESULT SetPropPageToDeleteOnClose(void * vpsp);

CString GetUpgradeIndex(GUID & PackageID);

#define HELP_FILE TEXT("ade.hlp")

void LogADEEvent(WORD wType, DWORD dwEventID, HRESULT hr, LPCWSTR szOptional = NULL);
void ReportGeneralPropertySheetError(HWND hwnd, LPCWSTR sz, HRESULT hr);
void ReportPolicyChangedError(HWND hwnd);
void WINAPI StandardHelp(HWND hWnd, UINT nIDD, BOOL fRsop = FALSE);
void WINAPI StandardContextMenu(HWND hWnd, UINT nIDD, BOOL fRsop = FALSE);

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)

//
// Helper function and defines for theme'ing property pages put up by the snap-in.
//
#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE CreateThemedPropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\cause.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       cause.cpp
//
//  Contents:   Digital Signitures property page
//
//  Classes:    CCause
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include "wincrypt.h"
#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCause property page

IMPLEMENT_DYNCREATE(CCause, CPropertyPage)

CCause::CCause() : CPropertyPage(CCause::IDD),
    m_fRemovedView(FALSE)
{
        //{{AFX_DATA_INIT(CCause)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

CCause::~CCause()
{
    *m_ppThis = NULL;
}

void CCause::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCause)
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCause, CPropertyPage)
        //{{AFX_MSG_MAP(CCause)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCause message handlers

BOOL CCause::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    RefreshData();
    return TRUE;
}

BOOL CCause::OnApply()
{
    return CPropertyPage::OnApply();
}


LRESULT CCause::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD, TRUE);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CCause::RefreshData(void)
{
    CString sz;
    CString szTemp;

    sz.LoadString(IDS_RSOP_APPLY);
    sz += TEXT("\r\n\r\n");

    switch (m_pData->m_dwApplyCause)
    {
    case 1:
        szTemp.LoadString(IDS_RSOP_AC1);
        break;
    case 2:
        szTemp.LoadString(IDS_RSOP_AC2);
        break;
    case 3:
        szTemp.LoadString(IDS_RSOP_AC3);
        break;
    case 4:
        szTemp.LoadString(IDS_RSOP_AC4);
        break;
    case 5:
        szTemp.LoadString(IDS_RSOP_AC5);
        break;
    case 6:
        szTemp.LoadString(IDS_RSOP_AC6);
        break;
    case 7:
        szTemp.LoadString(IDS_RSOP_AC7);
        break;
    case 8:
        szTemp.LoadString(IDS_RSOP_AC8);
        break;
    default:
        szTemp.LoadString(IDS_NODATA);
    }
    sz += szTemp;
    if (m_pData->m_dwApplyCause >= 1)
    {
        switch (m_pData->m_dwLanguageMatch)
        {
        case 1:
            szTemp.LoadString(IDS_RSOP_LM1);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 2:
            szTemp.LoadString(IDS_RSOP_LM2);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 3:
            szTemp.LoadString(IDS_RSOP_LM3);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 4:
            szTemp.LoadString(IDS_RSOP_LM4);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 5:
            szTemp.LoadString(IDS_RSOP_LM5);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        default:
            szTemp = TEXT("");
            break;
        }
        sz += szTemp;

        switch (m_pData->m_dwApplyCause)
        {
        case 4:
            szTemp.Format(IDS_RSOP_EXTACT, m_pData->m_szOnDemandFileExtension);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 5:
            szTemp.Format(IDS_RSOP_CLSIDACT, m_pData->m_szOnDemandClsid);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        case 7:
            szTemp.Format(IDS_RSOP_PROGIDACT, m_pData->m_szOnDemandProgid);
            szTemp = TEXT("\r\n") + szTemp;
            break;
        default:
            szTemp = TEXT("");
        }
        sz += szTemp;
    }

    if (m_fRemovedView)
    {
        sz += TEXT("\r\n\r\n\r\n");
        szTemp.LoadString(IDS_RSOP_REMOVAL);
        sz += szTemp;
        sz += TEXT("\r\n\r\n");

        switch (m_pData->m_dwRemovalType)
        {
        case 2:
            szTemp.LoadString(IDS_RSOP_RT2);
            break;
        case 3:
            szTemp.LoadString(IDS_RSOP_RT3);
            break;
        case 4:
            szTemp.LoadString(IDS_RSOP_RT4);
            break;
        default:
            szTemp.LoadString(IDS_NODATA);
        }
        sz += szTemp;

        if (m_pData->m_dwRemovalType >= 2 && m_pData->m_dwRemovalType <= 4)
        {
            switch (m_pData->m_dwRemovalCause)
            {
            case 2:
            {
                szTemp.Format(IDS_RSOP_RC2, m_pData->m_szRemovingApplicationName); 
                szTemp = TEXT("\r\n") + szTemp;
            }
                break;
            case 3:
                szTemp.LoadString(IDS_RSOP_RC3);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 4:
                szTemp.LoadString(IDS_RSOP_RC4);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 5:
                szTemp.LoadString(IDS_RSOP_RC5);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 6:
                szTemp.Format(IDS_RSOP_RC6, m_pData->m_szRemovingApplicationName);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 7:
                szTemp.Format(IDS_RSOP_RC7, m_pData->m_szRemovingApplicationName);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            case 8:
                szTemp.LoadString(IDS_RSOP_RC8);
                szTemp = TEXT("\r\n") + szTemp;
                break;
            default:
                szTemp = TEXT("");
            }
            sz += szTemp;
        }
    }

    CEdit * pEd = (CEdit *) GetDlgItem(IDC_EDIT1);
    pEd->Clear();
    pEd->ReplaceSel(sz);
    SetModified(FALSE);
}

void CCause::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_RSOPCAUSE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\data.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       data.cpp
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:    CAppData
//
//  History:    05-27-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CAppData::CAppData()
{
    m_pDetails = NULL;
    m_itemID = 0;
    m_fVisible = 0;
    m_fHide = FALSE;
    m_pProduct = NULL;
    m_pDeploy = NULL;
    m_pCategory = NULL;
    m_pXforms = NULL;
    m_pPkgDetails = NULL;
    m_pUpgradeList = NULL;
    m_pErrorInfo = NULL;
    m_pCause = NULL;
    m_fRSoP = FALSE;
    m_psd = NULL;
    m_dwApplyCause = 0;
    m_dwLanguageMatch = 0;
    m_szOnDemandFileExtension = L"";
    m_szOnDemandClsid = L"";
    m_szOnDemandProgid = L"";
    m_dwRemovalCause = 0;
    m_dwRemovalType = 0;
    m_szRemovingApplication = L"";
    m_szEventSource = L"";
    m_szEventLogName = L"";
    m_dwEventID = 0;
    m_szEventTime = L"";
    m_szEventLogText = L"";
    m_hrErrorCode = 0;
    m_nStatus = 0;
}

CAppData::~CAppData()
{
    if (m_pProduct)
    {
        m_pProduct->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pDeploy)
    {
        m_pDeploy->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pCategory)
    {
        m_pCategory->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pUpgradeList)
    {
        m_pUpgradeList->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pXforms)
    {
        m_pXforms->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pPkgDetails)
    {
        m_pPkgDetails->SendMessage(WM_USER_CLOSE, 0, 0);
    }
    if (m_pErrorInfo)
    {
        m_pErrorInfo->SendMessage(WM_USER_CLOSE, 0, 0);
    }
}

void CAppData::NotifyChange(void)
{
    if (m_pProduct)
    {
        m_pProduct->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pDeploy)
    {
        m_pDeploy->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pCategory)
    {
        m_pCategory->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pUpgradeList)
    {
        m_pUpgradeList->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pXforms)
    {
        m_pXforms->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pPkgDetails)
    {
        m_pPkgDetails->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (m_pErrorInfo)
    {
        m_pErrorInfo->SendMessage(WM_USER_REFRESH, 0, 0);
    }
}

void CAppData::InitializeExtraInfo(void)
{
    // at the moment, there is no extra info
    return;
}

void CAppData::GetSzPublisher(CString &sz)
{
    sz = m_pDetails->pszPublisher;
}

void CAppData::GetSzOOSUninstall(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_UninstallOnPolicyRemoval) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzShowARP(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_UserInstall) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzUIType(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->InstallUiLevel == INSTALLUILEVEL_FULL) ? IDS_MAXIMUM : IDS_BASIC);
}

void CAppData::GetSzIgnoreLoc(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_IgnoreLanguage) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzRemovePrev(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_UninstallUnmanaged) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzX86onIA64(CString &sz)
{
    BOOL fYes = 0;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Check this only for 32-bit apps
    //
    if ( ! Is64Bit() )
    {
        fYes = 0 != (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_ExcludeX86OnIA64);
    }


    if ( ! Is64Bit() )
    {
        if (m_pDetails->pInstallInfo->PathType == SetupNamePath)
        {
            //reverse the sense for legacy apps
            // (this flag  has the opposite meaning for legacy apps)
            fYes = !fYes;
        }
    }

    sz.LoadString(fYes ? IDS_YES : IDS_NO);
}

void CAppData::GetSzFullInstall(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
    {
        sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_InstallUserAssign) ? IDS_YES : IDS_NO);
    }
    else
    {
        sz.LoadString(IDS_NA);
    }
}

void CAppData::GetSzProductCode(CString &sz)
{
 //   szA = dataA.m_pDetails->pInstallInfo->ProductCode
    OLECHAR szTemp[80];
    StringFromGUID2(m_pDetails->pInstallInfo->ProductCode,
                    szTemp,
                    sizeof(szTemp) / sizeof(szTemp[0]));
    sz = szTemp;
}

void CAppData::GetSzOrigin(CString &sz)
{
    sz = m_szGPOName;
}

void CAppData::GetSzSOM(CString &sz)
{
    sz = m_szSOMID;
}

void CAppData::GetSzDeployment(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    int id;
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
        id = IDS_ASSIGNED;
    else
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Published)
        id = IDS_PUBLISHED;
    else
        id = IDS_DISABLED;
    sz.LoadString(id);
}

void CAppData::GetSzAutoInstall(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((m_pDetails->pInstallInfo->dwActFlags & ACTFLG_OnDemandInstall) ? IDS_YES : IDS_NO);
}

void CAppData::GetSzLocale(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    TCHAR szBuffer[256];
    sz = "";
    UINT i = 0;
    while (i < m_pDetails->pPlatformInfo->cLocales)
    {
        if (i > 0)
        {
            sz += ", ";
        }
        if (m_pDetails->pPlatformInfo->prgLocale[i])
        {
            GetLocaleInfo(m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SLANGUAGE, szBuffer, 256);
            sz += szBuffer;
    #ifdef SHOWCOUNTRY
            GetLocaleInfo(m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SCOUNTRY, szBuffer, 256);
            sz += _T(" - ");
            sz += szBuffer;
    #endif
        }
        else
        {
            // neutral locale
            CString szNeutral;
            szNeutral.LoadString(IDS_NEUTRAL_LOCALE);
            sz += szNeutral;
        }
        i++;
    }
}

void CAppData::GetSzPlatform(CString &sz)
{
    TCHAR szBuffer[256];
    sz = "";
    UINT i = 0;
    while (i < m_pDetails->pPlatformInfo->cPlatforms)
    {
        if (i > 0)
        {
            sz += ", ";
        }
#if 0       // I'm only going to display the processor to simplify the display
        ::LoadString(ghInstance, IDS_OS + m_pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId + 1, szBuffer, 256);
        sz += szBuffer;
        wsprintf(szBuffer, _T(" %u.%u/"), m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi, pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo);
        sz += szBuffer;
#endif
        ::LoadString(ghInstance, IDS_HW + m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch, szBuffer, 256);
        sz += szBuffer;
        i++;
    }
}

void CAppData::GetSzUpgrades(CString &sz, CScopePane * pScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (!m_szUpgrades.IsEmpty())
    {
        sz = m_szUpgrades;
        return;
    }

    if (m_fRSoP)
    {
        switch (m_setUpgrade.size() + m_setReplace.size())
        {
        case 0:
            sz.LoadString(IDS_NONE);
            break;
        case 1:
            if (1 == m_setUpgrade.size())
            {
                sz = *m_setUpgrade.begin();
            }
            else
            {
                sz = *m_setReplace.begin();
            }
            break;
        default:
            sz.LoadString(IDS_MULTIPLE);
            break;
        }
    }
    else
    {
        sz="";
        CString szName;
        UINT n = m_pDetails->pInstallInfo->cUpgrades;
        while (n--)
        {
            if (0 == (UPGFLG_UpgradedBy & m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
            {
                HRESULT hr = pScopePane->GetPackageNameFromUpgradeInfo(szName, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore);
                if (SUCCEEDED(hr))
                {
                    if (sz.GetLength())
                    {
                        // We'd already found one
                        sz.LoadString(IDS_MULTIPLE);
                        m_szUpgrades = sz;
                        return;
                    }
                    sz = szName;
                }
            }
        }
        if (0 == sz.GetLength())
        {
            sz.LoadString(IDS_NONE);
        }
    }
    m_szUpgrades = sz;
}

void CAppData::GetSzUpgradedBy(CString &sz, CScopePane * pScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_fRSoP)
    {
        switch (m_setUpgradedBy.size())
        {
        case 0:
            sz.LoadString(IDS_NONE);
            break;
        case 1:
            sz = *m_setUpgradedBy.begin();
            break;
        default:
            sz.LoadString(IDS_MULTIPLE);
            break;
        }
    }
    else
    {
        UINT n = m_pDetails->pInstallInfo->cUpgrades;
        CString szName;
        sz="";
        while (n--)
        {
            if (0 != (UPGFLG_UpgradedBy & m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
            {
                HRESULT hr = pScopePane->GetPackageNameFromUpgradeInfo(szName, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid, m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore);
                if (SUCCEEDED(hr))
                {
                    if (sz.GetLength())
                    {
                        // We'd already found one
                        sz.LoadString(IDS_MULTIPLE);
                        return;
                    }
                    sz = szName;
                }
            }
        }
        if (0 == sz.GetLength())
        {
            sz.LoadString(IDS_NONE);
        }
    }
}

void CAppData::GetSzStage(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    BOOL fUpgrades = FALSE;

    if (m_fRSoP)
    {
        fUpgrades = (m_setUpgrade.size() + m_setReplace.size()) != 0;
    }
    else
    {
        UINT n = m_pDetails->pInstallInfo->cUpgrades;
        while (n-- && !fUpgrades)
        {
            if (0 == (UPGFLG_UpgradedBy & m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
            {
                fUpgrades = TRUE;
            }
        }
    }
    if (!fUpgrades)
    {
        sz.LoadString(IDS_NONE);
    }
    else
    if (ACTFLG_ForceUpgrade & m_pDetails->pInstallInfo->dwActFlags)
        sz.LoadString(IDS_REQUIRED);
    else
        sz.LoadString(IDS_OPTIONAL);
}

void CAppData::GetSzVersion(CString &sz)
{
    TCHAR szBuffer[256];
    wsprintf(szBuffer, _T("%u.%u"), m_pDetails->pInstallInfo->dwVersionHi, m_pDetails->pInstallInfo->dwVersionLo);
    sz = szBuffer;
}

void CAppData::GetSzSource(CString &sz)
{
    if (1 <= m_pDetails->cSources)
    {
        sz = m_pDetails->pszSourceList[0];
    }
    else
        sz = "";
}

void CAppData::GetSzMods(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (2 < m_pDetails->cSources)
    {
        sz.LoadString(IDS_MULTIPLE);
    }
    else
    {
        if (2 == m_pDetails->cSources)
        {
            sz = m_pDetails->pszSourceList[1];
        }
        else
            sz = "";
    }
}

int CAppData::GetImageIndex(CScopePane * pScopePane)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_nStatus == 3)
    {
        // RSoP setting failed status
        return IMG_OPEN_FAILED;
    }
    CString sz;
    GetSzUpgrades(sz, pScopePane);
    CString sz2;
    sz2.LoadString(IDS_NONE);
    // gonna use the upgrade icon but it's only gonna be used when
    // m_szUpgrades doesn't read "none"
    if (0 != sz2.Compare(sz))
    {
        // we must be upgrading something
        return IMG_UPGRADE;
    }
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
        return IMG_ASSIGNED;
    else
    if (m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Published)
        return IMG_PUBLISHED;
    else
        return IMG_DISABLED;
}

BOOL CAppData::Is64Bit( PACKAGEDETAIL* pPackageDetails )
{
    UINT n = pPackageDetails->pPlatformInfo->cPlatforms;
    while (n--)
    {
        if (pPackageDetails->pPlatformInfo->prgPlatform[n].dwProcessorArch == PROCESSOR_ARCHITECTURE_IA64)
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CAppData::Is64Bit(void)
{
    return Is64Bit( m_pDetails );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "precomp.hxx"

#if DBG

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPEdit[] = TEXT("APPMGR(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPEditDebugLevel")

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//              9-23-1998   stevebl    shamelessly stolen from Eric's code
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[4096];
    va_list marker;
    DWORD dwErrCode;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        wsprintf (szDebugTitle, c_szGPEdit, GetCurrentProcessId());
        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;

            hFile = CreateFile(TEXT("\\GPEdit.log"),
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }

        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\dataobj.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.cpp
//
//  Contents:   implementation of IDataObject
//
//  Classes:    CDataObject
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

        return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
        return E_NOTIMPL;
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
        return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
                    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    return Create(cszNodeType, ((wcslen(cszNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    if (m_fMachine)
        return Create((LPVOID)&CLSID_MachineSnapin, sizeof(CLSID), lpMedium);
    else
        return Create((LPVOID)&CLSID_Snapin, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\data.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       data.h
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:    CAppData
//
//  Functions:
//
//  History:    05-27-1997   stevebl   Created
//              03-14-1998   stevebl   corrected
//
//---------------------------------------------------------------------------

#ifndef _DATA_H_
#define _DATA_H_

#define _NEW_
#include <map>
#include <set>
#include <algorithm>
using namespace std;

typedef enum DEPLOYMENT_TYPES
{
    DT_ASSIGNED = 0,
    DT_PUBLISHED
} DEPLOYMENT_TYPE;

class CScopePane;
class CProduct;
class CDeploy;
class CCategory;
class CXforms;
class CPackageDetails;
class CUpgradeList;
class CPrecedence;
class CErrorInfo;
class CCause;

class CAppData
{
public:
    CAppData();
    ~CAppData();

// data
    PACKAGEDETAIL *     m_pDetails;
    MMC_COOKIE          m_itemID;
    BOOL                m_fVisible;
    BOOL                m_fHide;
    BOOL                m_fRSoP;

    // property pages:  (NULL unless property pages are being displayed)
    CProduct *          m_pProduct;
    CDeploy *           m_pDeploy;
    CCategory *         m_pCategory;
    CUpgradeList *      m_pUpgradeList;
    CXforms *           m_pXforms;
    CPrecedence *       m_pPrecedence;
    CPackageDetails *   m_pPkgDetails;
    CErrorInfo *        m_pErrorInfo;
    CCause *            m_pCause;
    CString             m_szUpgrades;   // cache of upgrade relationships
    void                NotifyChange(void);

    // RSOP MODE data members
    CString             m_szGPOID;    // path to originating GPO
    CString             m_szGPOName;  // Friendly name of originating GPO
    CString             m_szSOMID;
    CString             m_szDeploymentGroupID;
    DWORD               m_dwApplyCause;
    DWORD               m_dwLanguageMatch;
    CString             m_szOnDemandFileExtension;
    CString             m_szOnDemandClsid;
    CString             m_szOnDemandProgid;
    DWORD               m_dwRemovalCause;
    DWORD               m_dwRemovalType;
    CString             m_szRemovingApplication;
    CString             m_szRemovingApplicationName;
    PSECURITY_DESCRIPTOR m_psd;
    set <CString>       m_setUpgradedBy;
    set <CString>       m_setUpgrade;
    set <CString>       m_setReplace;

    // failed settings data
    CString             m_szEventSource;
    CString             m_szEventLogName;
    DWORD               m_dwEventID;
    CString             m_szEventTime;
    HRESULT             m_hrErrorCode;
    int                 m_nStatus; // Values { "Unspecified", "Applied", "Ignored", "Failed", "SubsettingFailed" }
    CString             m_szEventLogText;

// methods - NOTE: all methods require a valid pDetails
    void                InitializeExtraInfo(void);
    void                GetSzDeployment(CString &);
    void                GetSzAutoInstall(CString &);
    void                GetSzLocale(CString &);
    void                GetSzPlatform(CString &);
    void                GetSzStage(CString &);
    void                GetSzUpgrades(CString &, CScopePane *);
    void                GetSzUpgradedBy(CString &, CScopePane *);
    void                GetSzVersion(CString &);
    void                GetSzMods(CString &);
    void                GetSzSource(CString &);
    void                GetSzPublisher(CString &);
    void                GetSzOOSUninstall(CString &);
    void                GetSzShowARP(CString &);
    void                GetSzUIType(CString &);
    void                GetSzIgnoreLoc(CString &);
    void                GetSzRemovePrev(CString &);
    void                GetSzProductCode(CString &);
    void                GetSzOrigin(CString &);
    void                GetSzSOM(CString &);
    int                 GetImageIndex(CScopePane *);
    BOOL                Is64Bit(void);
    static BOOL         Is64Bit( PACKAGEDETAIL* pPackageDetails );
    void                GetSzX86onIA64(CString &);
    void                GetSzFullInstall(CString &);
};


#endif // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\dataobj.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.h
//
//  Contents:   implementation of IDataObject for the snapin objects
//
//  Classes:    CDataObject
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CResultPane;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() {};
    ~CDataObject() {};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfInternal; // Step 3

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) // Step 3
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    BOOL    m_fMachine;

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;    // Step 3
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#if DBG

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) _DebugMsg x
#define DebugReportFailure(x, y) if (FAILED(x)) DebugMsg(y)

//
// Debug function proto-types
//

void __cdecl _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);

#else

#define DebugMsg(x)
#define DebugReportFailure(x, y)


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\dplapp.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       DplApp.cpp
//
//  Contents:   Application deployment dialog
//
//  Classes:    CDeployApp
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeployApp dialog


CDeployApp::CDeployApp(CWnd* pParent /*=NULL*/)
        : CDialog(CDeployApp::IDD, pParent)
{
        //{{AFX_DATA_INIT(CDeployApp)
        m_iDeployment = 0;
        //}}AFX_DATA_INIT
}


void CDeployApp::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDeployApp)
        DDX_Radio(pDX, IDC_RADIO2, m_iDeployment);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeployApp, CDialog)
        //{{AFX_MSG_MAP(CDeployApp)
    ON_WM_CONTEXTMENU()
    ON_BN_CLICKED(IDC_RADIO2, OnPublished)
    ON_BN_CLICKED(IDC_RADIO3, OnAssigned)
    ON_BN_CLICKED(IDC_RADIO1, OnCustom)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CDeployApp::OnPublished()
{
    CString sz;
    sz.LoadString(IDS_DEPLOYTEXTPUB);
    SetDlgItemText(IDC_STATIC1, sz);
}

void CDeployApp::OnAssigned()
{
    CString sz;
    sz.LoadString(IDS_DEPLOYTEXTASSIGNED);
    SetDlgItemText(IDC_STATIC1, sz);
}

void CDeployApp::OnCustom()
{
    CString sz;
    sz.LoadString(IDS_DEPLOYTEXTCUSTOM);
    SetDlgItemText(IDC_STATIC1, sz);
}

BOOL CDeployApp::OnInitDialog()
{
    if (m_fCrappyZaw)
    {
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
    }
    if (m_fMachine)
    {
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
        if (0 == m_iDeployment)
        {
            m_iDeployment++;
        }
    }
    CString sz;
    switch (m_iDeployment)
    {
    case 0:
        // Published
        sz.LoadString(IDS_DEPLOYTEXTPUB);
        break;
    case 1:
        // Assigned
        sz.LoadString(IDS_DEPLOYTEXTASSIGNED);
        break;
    case 2:
        // Custom
        sz.LoadString(IDS_DEPLOYTEXTCUSTOM);
        break;
    }
    SetDlgItemText(IDC_STATIC1, sz);
    CDialog::OnInitDialog();


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CDeployApp::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CDeployApp::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_DEPLOY_APP_DIALOG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\deploy.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       deploy.cpp
//
//  Contents:   application deployment property page
//
//  Classes:    CDeploy
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Guid of appmgmt client side GP extension, and guids for snapins
//

GUID guidExtension = { 0xc6dc5466, 0x785a, 0x11d2, {0x84, 0xd0, 0x00, 0xc0, 0x4f, 0xb1, 0x69, 0xf7}};
GUID guidUserSnapin = CLSID_Snapin;
GUID guidMachSnapin = CLSID_MachineSnapin;
GUID guidRSOPUserSnapin = CLSID_RSOP_Snapin;
GUID guidRSOPMachSnapin = CLSID_RSOP_MachineSnapin;


/////////////////////////////////////////////////////////////////////////////
// CDeploy property page

IMPLEMENT_DYNCREATE(CDeploy, CPropertyPage)

CDeploy::CDeploy() : CPropertyPage(CDeploy::IDD)
{
        //{{AFX_DATA_INIT(CDeploy)
        m_fAutoInst = FALSE;
        m_fFullInst = FALSE;
        m_iUI = -1;
        m_iDeployment = -1;
        m_fUninstallOnPolicyRemoval = FALSE;
        m_hConsoleHandle = NULL;
        m_fNotUserInstall = FALSE;
        //}}AFX_DATA_INIT
        m_pIClassAdmin = NULL;
        m_fPreDeploy = FALSE;
        m_ppThis = NULL;
        m_dlgAdvDep.m_pDeploy = this;
}

CDeploy::~CDeploy()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    MMCFreeNotifyHandle(m_hConsoleHandle);
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CDeploy::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDeploy)
        DDX_Check(pDX, IDC_CHECK2, m_fAutoInst);
        DDX_Radio(pDX, IDC_RADIO3, m_iUI);
        DDX_Radio(pDX, IDC_RADIO2, m_iDeployment);
        DDX_Check(pDX, IDC_CHECK1, m_fUninstallOnPolicyRemoval);
        DDX_Check(pDX, IDC_CHECK3, m_fNotUserInstall);
        DDX_Check(pDX, IDC_CHECK4, m_fFullInst);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeploy, CPropertyPage)
        //{{AFX_MSG_MAP(CDeploy)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdvanced)
        ON_BN_CLICKED(IDC_RADIO2, OnPublished)
        ON_BN_CLICKED(IDC_RADIO1, OnAssigned)
        ON_BN_CLICKED(IDC_CHECK2, OnChanged)
        ON_BN_CLICKED(IDC_CHECK3, OnChanged)
        ON_BN_CLICKED(IDC_RADIO3, OnChanged)
        ON_BN_CLICKED(IDC_RADIO4, OnChanged)
        ON_BN_CLICKED(IDC_CHECK1, OnChanged)
        ON_BN_CLICKED(IDC_CHECK4, OnChanged)
        ON_WM_DESTROY()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeploy message handlers

BOOL CDeploy::OnApply()
{
    if (m_fRSOP)
    {
        return CPropertyPage::OnApply();
    }
    DWORD dwActFlags = m_pData->m_pDetails->pInstallInfo->dwActFlags;
    dwActFlags &= ~(ACTFLG_Assigned | ACTFLG_Published |
                    ACTFLG_OnDemandInstall | ACTFLG_UserInstall |
                    ACTFLG_OrphanOnPolicyRemoval | ACTFLG_UninstallOnPolicyRemoval |
                    ACTFLG_InstallUserAssign |
                    ACTFLG_ExcludeX86OnIA64 | ACTFLG_IgnoreLanguage | ACTFLG_UninstallUnmanaged);
    switch (m_iDeployment)
    {
    case 2:
        // Disabled
        break;
    case 0:
        // Published
        dwActFlags |= ACTFLG_Published;
        if (m_fAutoInst)
        {
            dwActFlags |= ACTFLG_OnDemandInstall;
        }
        if (!m_fNotUserInstall)
        {
            dwActFlags |= ACTFLG_UserInstall;
        }
        break;
    case 1:
        // Assigned
        dwActFlags |= (ACTFLG_Assigned | ACTFLG_OnDemandInstall);
        if (!m_fNotUserInstall)
        {
            dwActFlags |= ACTFLG_UserInstall;
        }
        if (m_fFullInst)
        {
            dwActFlags |= ACTFLG_InstallUserAssign;
        }
        break;
    default:
        break;
    }

    if (m_pData->m_pDetails->pInstallInfo->PathType == SetupNamePath)
    {
        // legacy app
        if (m_dlgAdvDep.m_f32On64)
            dwActFlags |= ACTFLG_ExcludeX86OnIA64;
    }
    else
    {
        // not a legacy app
        if (!m_dlgAdvDep.m_f32On64)
            dwActFlags |= ACTFLG_ExcludeX86OnIA64;
    }

    if (m_fUninstallOnPolicyRemoval)
    {
        dwActFlags |= ACTFLG_UninstallOnPolicyRemoval;
    }
    else
    {
        // never set this flag for legacy applications
        if (m_pData->m_pDetails->pInstallInfo->PathType != SetupNamePath)
            dwActFlags |= ACTFLG_OrphanOnPolicyRemoval;
    }

    if (m_dlgAdvDep.m_fIgnoreLCID)
    {
        dwActFlags |= ACTFLG_IgnoreLanguage;
    }

    if (m_dlgAdvDep.m_fUninstallUnmanaged)
    {
        dwActFlags |= ACTFLG_UninstallUnmanaged;
    }

    UINT UILevel;
    switch (m_iUI)
    {
    case 1:
        UILevel = INSTALLUILEVEL_FULL;
        break;
    case 0:
    default:
        UILevel = INSTALLUILEVEL_BASIC;
        break;
    }

    HRESULT hr = E_FAIL;
    if (m_pIClassAdmin)
    {
        hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                     NULL,
                                                     &dwActFlags,
                                                     NULL,
                                                     NULL,
                                                     &UILevel,
                                                     NULL);
    }
    if (SUCCEEDED(hr))
    {
        m_pData->m_pDetails->pInstallInfo->InstallUiLevel = UILevel;
        m_pData->m_pDetails->pInstallInfo->dwActFlags = dwActFlags;
#if 0
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine,
                                                    TRUE,
                                                    &guidExtension,
                                                    m_fMachine ? &guidMachSnapin
                                                        : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hWnd);
        }
#endif
        if (!m_fPreDeploy)
        {
            MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);
        }
        else
        {
            // we're in pre-deploy mode - check to see if the fExtensionsOnly
            // flag has changed (which requires a re-deploy)
            // note that these two flags are normally the same,
            // meaning that when they're different, the user has requested a
            // change.
            if (m_dlgAdvDep.m_fIncludeOLEInfo != m_pData->m_pDetails->pActInfo->bHasClasses)
            {
                // need to redeploy
                BOOL fBuildSucceeded = FALSE;
                PACKAGEDETAIL * ppd;

                //
                // Apply the current setting for classes
                //
                m_pData->m_pDetails->pActInfo->bHasClasses = m_dlgAdvDep.m_fIncludeOLEInfo;

                if (FAILED(CopyPackageDetail(ppd, m_pData->m_pDetails)))
                {
                    return FALSE;
                }

                CString sz;

                // Create a name for the new script file.

                // set the script path
                GUID guid;
                HRESULT hr = CoCreateGuid(&guid);
                if (FAILED(hr))
                {
                    // undone
                }

                //
                // For MSI packages, we must regenerate class information
                //
                if ( DrwFilePath == ppd->pInstallInfo->PathType )
                {
                    OLECHAR szGuid [256];
                    StringFromGUID2(guid, szGuid, 256);

                    CString szScriptFile  = m_pScopePane->m_szGPT_Path;
                    szScriptFile += L"\\";
                    szScriptFile += szGuid;
                    szScriptFile += L".aas";
                    OLESAFE_DELETE(ppd->pInstallInfo->pszScriptPath);
                    OLESAFE_COPYSTRING(ppd->pInstallInfo->pszScriptPath, szScriptFile);
                    CString szOldName = ppd->pszPackageName;
                    hr = BuildScriptAndGetActInfo(*ppd, !m_dlgAdvDep.m_fIncludeOLEInfo);

                    if ( SUCCEEDED( hr ) )
                    {
                        if (0 != wcscmp(m_szInitialPackageName, szOldName))
                        {
                            // The User changed the name so we have to preserve his choice.
                            // If the user hasn't changed the package name then it's ok to
                            // set the packagename to whatever is in the script file.
                            OLESAFE_DELETE(ppd->pszPackageName);
                            OLESAFE_COPYSTRING(ppd->pszPackageName, szOldName);
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    fBuildSucceeded = TRUE;
                    hr = m_pScopePane->PrepareExtensions(*ppd);
                    if (SUCCEEDED(hr))
                    {
                        CString szUniqueName;
                        int     nHint;

                        nHint = 1;

                        m_pScopePane->GetUniquePackageName(ppd->pszPackageName, szUniqueName, nHint);
                        OLESAFE_DELETE(ppd->pszPackageName);
                        OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueName);

                        if ( ppd->pszPackageName )
                        {
                            hr = m_pIClassAdmin->RedeployPackage(
                                &m_pData->m_pDetails->pInstallInfo->PackageGuid,
                                ppd);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }

                        if (SUCCEEDED(hr))
                        {
                            // delete the old script
                            DeleteFile(m_pData->m_pDetails->pInstallInfo->pszScriptPath);
                            // update indexes and property sheets
                            m_pScopePane->RemoveExtensionEntry(m_cookie, *m_pData);
                            m_pScopePane->RemoveUpgradeEntry(m_cookie, *m_pData);
                            FreePackageDetail(m_pData->m_pDetails);
                            m_pData->m_pDetails = ppd;
                            m_pScopePane->InsertExtensionEntry(m_cookie, *m_pData);
                            m_pScopePane->InsertUpgradeEntry(m_cookie, *m_pData);
                            if (m_pScopePane->m_pFileExt)
                            {
                                m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                            }
                        }
                    }
                }
                if (FAILED(hr))
                {
                    CString sz;
                    sz.LoadString(fBuildSucceeded ? IDS_REDEPLOY_FAILED_IN_CS : IDS_REDEPLOY_FAILED);
                    ReportGeneralPropertySheetError(m_hWnd, sz, hr);

                    // delete new script file (assuming it was created)
                    if ( ( DrwFilePath == ppd->pInstallInfo->PathType ) &&
                         ppd->pInstallInfo->pszScriptPath )
                    {
                        DeleteFile(ppd->pInstallInfo->pszScriptPath);
                    }

                    FreePackageDetail(ppd);
                    return FALSE;
                }

            }
        }
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }

    return CPropertyPage::OnApply();
}

BOOL CDeploy::OnInitDialog()
{
    RefreshData();
    if (m_pData->m_pDetails->pInstallInfo->PathType == SetupNamePath)
    {
        // legacy apps can't be assigned
        GetDlgItem(IDC_RADIO1)->EnableWindow(FALSE);
        // legacy apps don't have a UI level
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
        // legacy apps can't be uninstalled
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    }

    m_szInitialPackageName = m_pData->m_pDetails->pszPackageName;

    if (m_fMachine)
    {
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
        // machine deployed apps don't have a UI
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
    }
    if (0 != (m_pData->m_pDetails->pInstallInfo->dwActFlags & ACTFLG_MinimalInstallUI))
    {
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
    }
    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CDeploy::OnAdvanced()
{
    BOOL fIgnoreLCID = m_dlgAdvDep.m_fIgnoreLCID;
    BOOL fInstallOnAlpha = m_dlgAdvDep.m_fInstallOnAlpha;
    BOOL fUninstallUnmanaged = m_dlgAdvDep.m_fUninstallUnmanaged;
    BOOL f32On64 = m_dlgAdvDep.m_f32On64;
    BOOL fIncludeOLEInfo = m_dlgAdvDep.m_fIncludeOLEInfo;

    m_dlgAdvDep.m_szScriptName = m_pData->m_pDetails->pInstallInfo->pszScriptPath;

    if (IDOK == m_dlgAdvDep.DoModal())
    {
        if (fIgnoreLCID != m_dlgAdvDep.m_fIgnoreLCID
            || fInstallOnAlpha != m_dlgAdvDep.m_fInstallOnAlpha
            || fUninstallUnmanaged != m_dlgAdvDep.m_fUninstallUnmanaged
            || f32On64 != m_dlgAdvDep.m_f32On64
            || fIncludeOLEInfo != m_dlgAdvDep.m_fIncludeOLEInfo)
        {
            if (!m_fPreDeploy)
                SetModified();
        }
    }
}

void CDeploy::OnDisable()
{
    if (!m_fPreDeploy)
        SetModified();
    m_fAutoInst = FALSE;
    GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CDeploy::OnPublished()
{
    if (!m_fPreDeploy)
        SetModified();
    GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
    GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
    GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CDeploy::OnAssigned()
{
    if (!m_fPreDeploy)
        SetModified();
    m_fAutoInst = TRUE;
    GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
    GetDlgItem(IDC_CHECK4)->EnableWindow(TRUE);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

void CDeploy::OnChanged()
{
    if (!m_fPreDeploy)
        SetModified();
}


LRESULT CDeploy::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        UpdateData(FALSE);
        return 0;
    case WM_USER_CLOSE:
        m_dlgAdvDep.EndDialog(IDCANCEL);
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CDeploy::RefreshData(void)
{
    DWORD dwActFlags = m_pData->m_pDetails->pInstallInfo->dwActFlags;
    m_fAutoInst = (0 != (dwActFlags & ACTFLG_OnDemandInstall));
    m_fNotUserInstall = (0 == (dwActFlags & ACTFLG_UserInstall));
    m_fFullInst = (0 != (dwActFlags & ACTFLG_InstallUserAssign));

    if (dwActFlags & ACTFLG_Assigned)
    {
        m_iDeployment = 1;
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
        // Only enable full assign checkbox when an app is
        // assigned and not legacy.  And only enable this
        // when we're in USER mode.
        // Of course .ZAP (legacy) packages can't be assigned
        // anyway so we don't actually need to check for that.
        GetDlgItem(IDC_CHECK4)->EnableWindow( m_fMachine == FALSE);
    }
    else if (dwActFlags & ACTFLG_Published)
    {
        m_iDeployment = 0;
        GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(!m_fMachine);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }
    else
    {
        m_iDeployment = 2;
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }
    if (this->m_fRSOP)
    {
        // disable EVERYTHING
        GetDlgItem(IDC_RADIO1)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO3)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK3)->EnableWindow(FALSE);
        GetDlgItem(IDC_CHECK4)->EnableWindow(FALSE);
    }
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }

    if (dwActFlags & ACTFLG_UninstallOnPolicyRemoval)
    {
        m_fUninstallOnPolicyRemoval = TRUE;
    }
    else
    {
        m_fUninstallOnPolicyRemoval = FALSE;
    }

    // initialize the state flags for the advanced dialog
    m_dlgAdvDep.m_szDeploymentCount.Format(TEXT("%u"), m_pData->m_pDetails->pInstallInfo->dwRevision);
    OLECHAR szTemp[80];
    StringFromGUID2(m_pData->m_pDetails->pInstallInfo->ProductCode,
                    szTemp,
                    sizeof(szTemp) / sizeof(szTemp[0]));
    m_dlgAdvDep.m_szProductCode = szTemp;
    m_dlgAdvDep.m_f32On64 = ((dwActFlags & ACTFLG_ExcludeX86OnIA64) == ACTFLG_ExcludeX86OnIA64);

    if (m_pData->m_pDetails->pInstallInfo->PathType != SetupNamePath)
    {
        // this is not a legacy app
        // reverse the sense of m_f32On64
        m_dlgAdvDep.m_f32On64 = !m_dlgAdvDep.m_f32On64;
    }

    if (dwActFlags & ACTFLG_UninstallUnmanaged)
    {
        m_dlgAdvDep.m_fUninstallUnmanaged = TRUE;
    }
    else
    {
        m_dlgAdvDep.m_fUninstallUnmanaged = FALSE;
    }

    m_dlgAdvDep.m_fInstallOnAlpha = FALSE;

    m_dlgAdvDep.m_fIncludeOLEInfo = m_pData->m_pDetails->pActInfo->bHasClasses;

    if (dwActFlags & ACTFLG_IgnoreLanguage)
    {
        m_dlgAdvDep.m_fIgnoreLCID = TRUE;
    }
    else
    {
        m_dlgAdvDep.m_fIgnoreLCID = FALSE;
    }

    switch (m_pData->m_pDetails->pInstallInfo->InstallUiLevel)
    {
    case INSTALLUILEVEL_FULL:
        m_iUI = 1;
        break;
    case INSTALLUILEVEL_BASIC:
    default:
        m_iUI = 0;
        break;
    }

    SetModified(FALSE);
}

void CDeploy::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_DEPLOYMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\dplapp.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       DplApp.h
//
//  Contents:   app deployment dialog
//
//  Classes:    CDeployApp
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
#define AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDeployApp dialog

class CDeployApp : public CDialog
{
// Construction
public:
        CDeployApp(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CDeployApp)
        enum { IDD = IDD_DEPLOY_APP_DIALOG };
        int             m_iDeployment;
        BOOL    m_fMachine;
        BOOL    m_fCrappyZaw;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CDeployApp)
    protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CDeployApp)
        virtual BOOL OnInitDialog();
        afx_msg void OnCustom();
        afx_msg void OnAssigned();
        afx_msg void OnPublished();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\deploy.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Deploy.h
//
//  Contents:   deployment property page
//
//  Classes:    CDeploy
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDeploy dialog

class CDeploy : public CPropertyPage
{
        DECLARE_DYNCREATE(CDeploy)

// Construction
public:
        CDeploy();
        ~CDeploy();

        CDeploy **      m_ppThis;

// Dialog Data
        //{{AFX_DATA(CDeploy)
        enum { IDD = IDD_DEPLOYMENT };
        BOOL    m_fAutoInst;
        BOOL    m_fFullInst;
        int             m_iUI;
        int             m_iDeployment;
        BOOL    m_fUninstallOnPolicyRemoval;
        BOOL    m_fNotUserInstall;
        CString         m_szInitialPackageName;
        //}}AFX_DATA
        CAppData *      m_pData;
        CScopePane *    m_pScopePane;
        IClassAdmin *   m_pIClassAdmin;
#if 0
        LPGPEINFORMATION m_pIGPEInformation;
#endif
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fPreDeploy;
        BOOL            m_fMachine;
        BOOL            m_fRSOP;
        CAdvDep         m_dlgAdvDep;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CDeploy)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CDeploy)
        virtual BOOL OnInitDialog();
        afx_msg void OnDisable();
        afx_msg void OnAdvanced();
        afx_msg void OnPublished();
        afx_msg void OnAssigned();
        afx_msg void OnChanged();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshData(void);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\edtstr.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       EdtStr.cpp
//
//  Contents:   simple string edit dialog
//
//  Classes:    CEditString
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditString dialog


CEditString::CEditString(CWnd* pParent /*=NULL*/)
        : CDialog(CEditString::IDD, pParent)
{
        //{{AFX_DATA_INIT(CEditString)
        m_sz = _T("");
        m_szTitle = _T("");
        //}}AFX_DATA_INIT
}


void CEditString::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CEditString)
        DDX_Text(pDX, IDC_EDIT1, m_sz);
	DDV_MaxChars(pDX, m_sz, 40);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditString, CDialog)
        //{{AFX_MSG_MAP(CEditString)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditString message handlers

BOOL CEditString::OnInitDialog()
{
        CDialog::OnInitDialog();

        SetWindowText(m_szTitle);
        // TODO: Add extra initialization here

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CEditString::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_EDITSTRING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\edtstr.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       EdtStr.h
//
//  Contents:   a simple string edit dialog box
//
//  Classes:    CEditString
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_EDTSTR_H__E95370C1_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
#define AFX_EDTSTR_H__E95370C1_ADF8_11D1_A763_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CEditString dialog

class CEditString : public CDialog
{
// Construction
public:
        CEditString(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CEditString)
        enum { IDD = IDD_EDITSTRING };
        CString m_sz;
        CString m_szTitle;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CEditString)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CEditString)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDTSTR_H__E95370C1_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\error.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       error.h
//
//  Contents:   Faild Settings property sheet
//
//  Classes:    CErrorInfo
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#if !defined(AFX_ERROR_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_ERROR_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CErrorInfo dialog

class CErrorInfo : public CPropertyPage
{
        DECLARE_DYNCREATE(CErrorInfo)

// Construction
public:
        CErrorInfo();
        ~CErrorInfo();
        CErrorInfo ** m_ppThis;
        CAppData * m_pData;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CErrorInfo)
        enum { IDD = IDD_ERRORINFO };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CErrorInfo)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CErrorInfo)
        afx_msg void OnSaveAs();
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG\

        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ERROR_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\fileext.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       FileExt.cpp
//
//  Contents:   file extension property page
//
//  Classes:    CFileExt
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileExt property page

IMPLEMENT_DYNCREATE(CFileExt, CPropertyPage)

CFileExt::CFileExt() : CPropertyPage(CFileExt::IDD)
{
        //{{AFX_DATA_INIT(CFileExt)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_pIClassAdmin = NULL;
}

CFileExt::~CFileExt()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CFileExt::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CFileExt)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFileExt, CPropertyPage)
        //{{AFX_MSG_MAP(CFileExt)
        ON_BN_CLICKED(IDC_BUTTON1, OnMoveUp)
        ON_BN_CLICKED(IDC_BUTTON2, OnMoveDown)
        ON_CBN_SELCHANGE(IDC_COMBO1, OnExtensionChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileExt message handlers

void CFileExt::OnMoveUp()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i != LB_ERR && i > 0)
    {
        // change the selection
        CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
        CString sz;
        pCombo->GetLBText(pCombo->GetCurSel(), sz);
        EXT & Ext = m_Extensions[sz];
        Ext.fDirty = TRUE;
        EXTEL t = Ext.v[i-1];
        Ext.v[i-1] = Ext.v[i];
        Ext.v[i] = t;
        pList->GetText(i, sz);
        pList->DeleteString(i);
        pList->InsertString(i-1, sz);
        pList->SetCurSel(i-1);
        SetModified();
    }
}

void CFileExt::OnMoveDown()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i != LB_ERR && i < pList->GetCount()-1)
    {
        // change the selection
        CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
        CString sz;
        pCombo->GetLBText(pCombo->GetCurSel(), sz);
        EXT & Ext = m_Extensions[sz];
        Ext.fDirty = TRUE;
        EXTEL t = Ext.v[i+1];
        Ext.v[i+1] = Ext.v[i];
        Ext.v[i] = t;
        pList->GetText(i+1, sz);
        pList->DeleteString(i+1);
        pList->InsertString(i, sz);
        pList->SetCurSel(i+1);
        SetModified();
    }
}

void CFileExt::OnExtensionChanged()
{
    CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    CString szExt;
    pCombo->GetLBText(pCombo->GetCurSel(), szExt);
    pList->ResetContent();
    pList->SetHorizontalExtent(0);
    if (szExt.IsEmpty())
    {
        return; // nothing to do if there are no entries
    }

    // First check to see if we already have set up our own data for this extension.
    if (m_Extensions.end() == m_Extensions.find(szExt))
    {
        // need to set up our list
        EXT Ext;
        Ext.fDirty = FALSE;

        EXTLIST::iterator i;
        EXTLIST & ExtList = m_pScopePane->m_Extensions[szExt];
        for (i = ExtList.begin(); i != ExtList.end(); i++)
        {
            EXTEL ExtEl;
            ExtEl.lCookie = *i;

            // look for the entry that matches this file extension
            CAppData & data = m_pScopePane->m_AppData[*i];
            UINT n2 = data.m_pDetails->pActInfo->cShellFileExt;
            while (n2--)
            {
                if (0 == szExt.CompareNoCase(data.m_pDetails->pActInfo->prgShellFileExt[n2]))
                {
                    break;
                }
            }
            ExtEl.lPriority = data.m_pDetails->pActInfo->prgPriority[n2];
            Ext.v.push_back(ExtEl);
        }
        order_EXTEL func;
        sort(Ext.v.begin(), Ext.v.end(), func);
        m_Extensions[szExt] = Ext;
    }
    vector<EXTEL>::iterator i;
    EXT & Ext = m_Extensions[szExt];
    for (i = Ext.v.begin(); i != Ext.v.end(); i++)
    {
        CString sz = m_pScopePane->m_AppData[i->lCookie].m_pDetails->pszPackageName;
        pList->AddString(sz);
        CDC * pDC = pList->GetDC();
        CSize size = pDC->GetTextExtent(sz);
        pDC->LPtoDP(&size);
        pList->ReleaseDC(pDC);
        if (pList->GetHorizontalExtent() < size.cx)
        {
            pList->SetHorizontalExtent(size.cx);
        }
    }
    pList->SetCurSel(0);
    int n = pList->GetCount();
    GetDlgItem(IDC_BUTTON1)->EnableWindow(n > 1);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(n > 1);
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
}

BOOL CFileExt::OnInitDialog()
{
    RefreshData();

    CPropertyPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CFileExt::OnApply()
{
    HRESULT hr = S_OK;
    map <CString, EXT>::iterator iExt;
    // walk the list looking for dirty entries
    for (iExt = m_Extensions.begin(); iExt != m_Extensions.end(); iExt++)
    {
        if (iExt->second.fDirty)
        {
            ULONG uPriority = iExt->second.v.size();
            vector<EXTEL>::iterator i;
            for (i = iExt->second.v.begin(); i != iExt->second.v.end(); i++)
            {
                CAppData & data = m_pScopePane->m_AppData[i->lCookie];
                CString sz = data.m_pDetails->pszPackageName;
                ASSERT(m_pIClassAdmin);
                hr = m_pIClassAdmin->SetPriorityByFileExt((LPOLESTR)((LPCOLESTR)sz), (LPOLESTR)((LPCOLESTR)iExt->first), --uPriority);

                // look for the entry that matches this file extension
                UINT n2 = data.m_pDetails->pActInfo->cShellFileExt;
                while (n2--)
                {
                    if (0 == iExt->first.CompareNoCase(data.m_pDetails->pActInfo->prgShellFileExt[n2]))
                    {
                        break;
                    }
                }
                data.m_pDetails->pActInfo->prgPriority[n2] = uPriority;
            }
            iExt->second.fDirty = FALSE;
        }
    }
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    return CPropertyPage::OnApply();
}


LRESULT CFileExt::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CFileExt::RefreshData(void)
{
    CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
    pCombo->ResetContent();
    if (m_pIClassAdmin)
    {
        // only populate the extension list when we have an IClassAdmin interface
        map <CString, EXTLIST>::iterator iExt;
        for (iExt=m_pScopePane->m_Extensions.begin(); iExt != m_pScopePane->m_Extensions.end(); iExt++)
        {
            pCombo->AddString(iExt->first);
        }
    }
    pCombo->SetCurSel(0);
    // clear the record of extension changes
    m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
    // and populate the list box
    SetModified(FALSE);

    OnExtensionChanged();
}


void CFileExt::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_FILE_EXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\error.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       error.cpp
//
//  Contents:   Digital Signitures property page
//
//  Classes:    CErrorInfo
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include "wincrypt.h"
#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CErrorInfo property page

IMPLEMENT_DYNCREATE(CErrorInfo, CPropertyPage)

CErrorInfo::CErrorInfo() : CPropertyPage(CErrorInfo::IDD)
{
        //{{AFX_DATA_INIT(CErrorInfo)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

CErrorInfo::~CErrorInfo()
{
    *m_ppThis = NULL;
}

void CErrorInfo::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CErrorInfo)
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorInfo, CPropertyPage)
        //{{AFX_MSG_MAP(CErrorInfo)
        ON_BN_CLICKED(IDC_BUTTON1, OnSaveAs)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorInfo message handlers

void CErrorInfo::OnSaveAs()
{
    OPENFILENAME ofn;
    CString szExtension;
    CString szFilter;
    szExtension.LoadString(IDS_TEXT_DEF_EXT);
    szFilter.LoadString(IDS_TEXT_EXT_FILT);
    LPTSTR lpTemp;
    TCHAR szFile[2*MAX_PATH];
    HANDLE hFile;
    DWORD dwSize, dwBytesWritten;

    //
    // Call the Save common dialog
    //

    szFile[0] = TEXT('\0');
    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFilter = szFilter;
    lpTemp = (LPTSTR)ofn.lpstrFilter;
    int iBreak = 0;
    while (lpTemp[iBreak])
    {
        if (lpTemp[iBreak] == TEXT('|'))
        {
            lpTemp[iBreak] = 0;
        }
        iBreak++;
    }
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = 2*MAX_PATH;
    ofn.lpstrDefExt = szExtension;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    if (!GetSaveFileName (&ofn))
    {
        return;
    }


    CHourglass hourglass;

    //
    // Create the text file
    //

    hFile = CreateFile (szFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("CErrorInfo::OnSaveAs: CreateFile failed with %d"), GetLastError()));
        return;
    }


    //
    // Get the text out of the edit control
    //
    dwSize = (DWORD) SendDlgItemMessage (IDC_EDIT1, WM_GETTEXTLENGTH, 0, 0);

    lpTemp = (LPTSTR) LocalAlloc (LPTR, (dwSize+2) * sizeof(TCHAR));

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CErrorInfo::OnSaveAs: LocalAlloc failed with %d"), GetLastError()));
        CloseHandle (hFile);
        return;
    }

    SendDlgItemMessage (IDC_EDIT1, WM_GETTEXT, (dwSize+1), (LPARAM) lpTemp);



    //
    // Save it to the new file
    //

    if (!WriteFile (hFile, lpTemp, (dwSize * sizeof(TCHAR)), &dwBytesWritten, NULL) ||
        (dwBytesWritten != (dwSize * sizeof(TCHAR))))
    {
        DebugMsg((DM_WARNING, TEXT("CErrorInfo::OnSaveAs: WriteFile failed with %d"),
                 GetLastError()));
    }


    LocalFree (lpTemp);
    CloseHandle (hFile);
}

BOOL CErrorInfo::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    RefreshData();
    return TRUE;
}

BOOL CErrorInfo::OnApply()
{
    return CPropertyPage::OnApply();
}


LRESULT CErrorInfo::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CErrorInfo::RefreshData(void)
{
    CString szTime = L"";
    BSTR bstr = SysAllocString(m_pData->m_szEventTime);
    if (bstr)
    {
        CStringFromWBEMTime(szTime, bstr, FALSE);
        SysFreeString(bstr);
    }

    CEdit * pEd = (CEdit *) GetDlgItem(IDC_EDIT1);
    pEd->Clear();
    CString sz;
    sz.Format(TEXT("%s\r\n\r\n%s"),
              szTime,
              m_pData->m_szEventLogText);

    pEd->ReplaceSel(sz);
    SetModified(FALSE);
}

void CErrorInfo::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_ERRORINFO);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\lcidpick.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       lcidpick.cpp
//
//  Contents:   locale picker dialog
//
//  Classes:    CLcidPick
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLcidPick dialog


CLcidPick::CLcidPick(CWnd* pParent /*=NULL*/)
        : CDialog(CLcidPick::IDD, pParent)
{
        //{{AFX_DATA_INIT(CLcidPick)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}


void CLcidPick::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CLcidPick)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLcidPick, CDialog)
        //{{AFX_MSG_MAP(CLcidPick)
        ON_BN_CLICKED(IDC_BUTTON1, OnRemove)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLcidPick message handlers

void CLcidPick::OnRemove()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int iSel = pList->GetCurSel();
    if (iSel != LB_ERR)
    {
        pList->DeleteString(iSel);
        set<LCID>::iterator i = m_psLocales->begin();
        while (iSel--)
        {
            i++;
        }
        m_psLocales->erase(*i);
    }
}

BOOL CLcidPick::OnInitDialog()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    TCHAR szBuffer[256];

    // for every item in m_psLocales
    set<LCID>::iterator i;
    for (i = m_psLocales->begin(); i != m_psLocales->end(); i++)
    {
        // UNDONE - convert to a human readable string (not a number)
        CString sz;
        GetLocaleInfo(*i, LOCALE_SLANGUAGE, szBuffer, 256);
        sz += szBuffer;
#ifdef SHOWCOUNTRY
        sz += _T(" - ");
        GetLocaleInfo(*i, LOCALE_SCOUNTRY, szBuffer, 256);
        sz += szBuffer;
#endif
        pList->AddString(sz);
    }

    CDialog::OnInitDialog();


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CLcidPick::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CLcidPick::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_LOCALE_PICKER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\fileext.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       FileExt.h
//
//  Contents:   file extension property sheet
//
//  Classes:    CFileExt
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

typedef struct tagEXTEL
{
    long lCookie;
    long lPriority;
} EXTEL;

typedef struct tagEXT
{
    vector<EXTEL> v;
    bool              fDirty;
} EXT;

// Comparitor used to sort the vector of EXTEL elements.
// This ensures that the item with the highest priority is put at the top of
// the list.
class order_EXTEL : public binary_function <const EXTEL&, const EXTEL&, bool>
{
public:
    bool operator () (const EXTEL& a, const EXTEL& b) const
    {
        return a.lPriority > b.lPriority;
    }
};

/////////////////////////////////////////////////////////////////////////////
// CFileExt dialog

class CFileExt : public CPropertyPage
{
        DECLARE_DYNCREATE(CFileExt)

// Construction
public:
        CFileExt();
        ~CFileExt();
        CScopePane * m_pScopePane;
        map<CString, EXT> m_Extensions;
        IClassAdmin *   m_pIClassAdmin;

        CFileExt ** m_ppThis;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CFileExt)
        enum { IDD = IDD_FILE_EXT };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CFileExt)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CFileExt)
        afx_msg void OnMoveUp();
        afx_msg void OnMoveDown();
        afx_msg void OnExtensionChanged();
        virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\msibase.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msibase.cpp
//
//  Contents:   msi database abstractions
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"


CMsiState::CMsiState() :
    _MsiHandle( NULL )
{
    //
    // The MSIHANDLE encapsulates the state for
    // all msi operations / data -- clearing this
    // member is akin to clearing the state.
    //
}

CMsiState::~CMsiState()
{
    //
    // The lifetime of the object is the lifetime
    // of the underlying state -- be sure to release it
    //
    MsiCloseHandle( _MsiHandle );
}

void
CMsiState::SetState( MSIHANDLE MsiHandle )
{
    //
    // Set the state of this object based on
    // a handle retrieved from an MSI operation --
    // note that this should only be done if this
    // object has an empty state
    //
    ASSERT( ! _MsiHandle );

    _MsiHandle = MsiHandle;
}

MSIHANDLE
CMsiState::GetState()
{
    //
    // Allow callers that need to perform explicit MSI
    // operations to retrieve state compatible with MSI
    //
    return _MsiHandle;
}


CMsiValue::CMsiValue() :
    _dwDiscriminant( TYPE_NOT_SET ),
    _wszValue( NULL ),
    _cchSize( sizeof( _wszDefaultBuf ) / sizeof( *_wszDefaultBuf ) )
{
    //
    // The goal of this initialization is to set this object to
    // an "empty" state -- consumers must explicitly invoke methods
    // on this object to alter this condition so that Get methods
    // will succeed.
    //
}

CMsiValue::~CMsiValue()
{
    //
    // Setting the type to "none" implicitly clears our state
    // (e.g. allocated memory, any other resources)
    //
    SetType( TYPE_NOT_SET );
}

DWORD
CMsiValue::GetDWORDValue()
{
    ASSERT( TYPE_DWORD == _dwDiscriminant );

    //
    // Retrieve this value as a DWORD -- note that this
    // does not coerce non-DWORD values to DWORD -- the
    // value must already be a DWORD for this to have meaning
    //
    return _dwValue;
}


WCHAR*
CMsiValue::GetStringValue()
{
    ASSERT( TYPE_STRING == _dwDiscriminant );


    //
    // Retrieve this value as a string -- note that this
    // does not coerce non-string values to string -- the
    // value must already be a string for this to have meaning.
    // Note that the value is returned as a reference to the address
    // at which this value actually stores the string -- thus, this
    // may also be used to retrieve the value's buffer so that its
    // contents may be edited outside the strictures of this class.
    //
    return _wszValue;
}

WCHAR*
CMsiValue::DuplicateString()
{
    WCHAR* wszResult;

    ASSERT( TYPE_STRING == _dwDiscriminant );

    //
    // The caller requires ownership of a duplicate
    // of this string's data.
    //

    //
    // First, allocate memory for this
    //
    wszResult = (WCHAR*) LocalAlloc(
        0,
        sizeof(WCHAR*) * (lstrlen ( _wszValue ) + 1 ) );

    //
    // If we successfully obtained room for the string,
    // copy it
    //
    if ( wszResult )
    {
        lstrcpy( wszResult, _wszValue);
    }

    return wszResult;
}

void
CMsiValue::SetDWORDValue( DWORD dwValue )
{
    //
    // This operation will implicitly set the type
    // of this value to DWORD
    //
    SetType( TYPE_DWORD );

    //
    // Now we can safely set the value
    //
    _dwValue = dwValue;
}

LONG
CMsiValue::SetStringValue( WCHAR* wszValue )
{
    DWORD cchSize;
    LONG  Status;

    Status = ERROR_SUCCESS;

    //
    // This operation will implicitly set the
    // type of this value to string
    //
    SetType( TYPE_STRING );

    //
    // We need to determine the size of this string,
    // in chars, without the null terminator, in order to
    // allow this value to represent it
    //
    cchSize = lstrlen( wszValue );

    if ( cchSize > _cchSize )
    {
        //
        // Attempt to get space for this string
        // by setting its size -- if this fails,
        // our type will be implicitly set to none
        //
        Status = SetStringSize( cchSize );

        if ( ERROR_SUCCESS != Status )
        {
            return Status;
        }

        //
        // We have room for the string, so copy it
        // into its newly allocated space
        //
        lstrcpy( _wszValue, wszValue );
    }

    return Status;
}

DWORD
CMsiValue::GetStringSize()
{
    ASSERT( TYPE_STRING == _dwDiscriminant );

    //
    // Retrieve the size of this string in chars,
    // WITHOUT the null terminator
    //
    return _cchSize;
}

LONG
CMsiValue::SetStringSize( DWORD cchSize )
{
    ASSERT( TYPE_STRING == _dwDiscriminant );

    //
    // This method only makes sense if the
    // type of this object is already string
    //

    //
    // If the requested size is less than or
    // equal to our current size, we already have
    // enough space -- we can exit now.  We do
    // not "shrink" space, only expand as necessary
    //
    if ( cchSize <= _cchSize )
    {
        return ERROR_SUCCESS;
    }

    //
    // At this point, we know we don't have enough
    // space, so we'll have to allocate it. Before we
    // do so, reset our type to none so that if we fail
    // to get space, we can indicate the indeterminate
    // state.
    //
    SetType( TYPE_NOT_SET );

    //
    // Allocate space, and include the zero terminator
    //
    _wszValue = new WCHAR [ cchSize + 1 ];

    if ( ! _wszValue )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // We are successful, remember the current size
    //
    _cchSize = cchSize;

    //
    // Change the type back to string since we can
    // safely represent a string of this size
    //
    SetType( TYPE_STRING );

    return ERROR_SUCCESS;
}

void
CMsiValue::SetType( DWORD dwType )
{
    //
    // Setting the type to a new type implicitly clears
    // state associated with the new type
    //

    //
    // If the current type and requested type are the same
    // this is a no op and we are done.
    //
    if ( dwType == _dwDiscriminant )
    {
        return;
    }

    //
    // If the requested type is string, we need to
    // set this object to have appropriate state
    //
    if ( TYPE_STRING == dwType )
    {
        //
        // If we have no space for a string
        //
        if ( ! _wszValue )
        {
            //
            // Use the default buffer...
            //
            _wszValue = _wszDefaultBuf;

            //
            // ... and set the size accordingly
            //
            _cchSize = sizeof( _wszDefaultBuf ) / sizeof( *_wszDefaultBuf );
        }

        //
        // We are done -- this object can now represent a string, though
        // at this point it must be a string of size _cchSize -- the size
        // will have to be increased through SetStringSize if there's
        // a need to represent a larger string
        //
        return;
    }

    //
    // If the current type is string, we use the fact that the requested
    // type is not string as a hint to free the state associated with
    // the string.  This is a heuristic designed to ensure that we
    // do not continue to hold memory of which we are not actively making
    // use.
    //
    if ( TYPE_STRING == _dwDiscriminant )
    {
        //
        // If the string's current storage is not that of our default
        // buffer (which is part of the object itself), we
        // release that storage as it was allocated on the heap.
        //
        if ( _wszValue != _wszDefaultBuf )
        {
            delete [] _wszValue;
            _wszValue = NULL;
        }
    }

    //
    // We may now set the type to that requested by the caller
    //
    _dwDiscriminant = dwType;
}

LONG
CMsiRecord::GetValue(
    DWORD      dwType,
    DWORD      dwValue,
    CMsiValue* pMsiValue)
{
    LONG Status = ERROR_SUCCESS;

    //
    // Values are the properties of the column of an
    // msi record -- we are retrieving members of the
    // record
    //

    //
    // The value is our out parameter -- set it
    // to the type desired by the caller
    //
    pMsiValue->SetType( dwType );

    switch ( dwType )
    {
    case CMsiValue::TYPE_STRING:

        DWORD cchSize;

        //
        // We must determine the maximum size of the
        // string that can be represented by the value
        // so we can pass it to the msi api
        //
        cchSize = pMsiValue->GetStringSize();

        //
        // Attempt to retrieve the string by storing
        // it in the buffer of the value
        //
        Status = MsiRecordGetString(
            GetState(),
            dwValue,
            pMsiValue->GetStringValue(),
            &cchSize);

        //
        // Our attempt to retrieve the string data will
        // fail if the value's string buffer is not sufficiently
        // large.
        //
        if ( ERROR_MORE_DATA == Status )
        {
            //
            // In the case where the value's buffer is not large enough,
            // we explicitly set the size of the value to that of the
            // size returned by the msi api PLUS a zero terminator --
            // this is because the size returned by MSI does NOT
            // include the zero terminator.
            //
            cchSize++;

            Status = pMsiValue->SetStringSize( cchSize );

            //
            // We now retry the string retrieval since we have the
            // correct size now.
            //
            if ( ERROR_SUCCESS == Status )
            {
                Status = MsiRecordGetString(
                    GetState(),
                    dwValue,
                    pMsiValue->GetStringValue(),
                    &cchSize);
            }
        }
        break;

    case CMsiValue::TYPE_DWORD:

        Status = ERROR_INVALID_PARAMETER;

        int IntegerValue;

        //
        // Retrieve an integer by calling the msi api
        //
        IntegerValue = MsiRecordGetInteger(
            GetState(),
            dwValue);

        if ( MSI_NULL_INTEGER != IntegerValue )
        {
            //
            // We now set the value to that retrieved by the api
            //
            pMsiValue->SetDWORDValue( (DWORD) IntegerValue );

            Status = ERROR_SUCCESS;
        }

        break;

    default:
        ASSERT( FALSE );
        break;
    }

    return Status;
}

LONG
CMsiQuery::GetNextRecord( CMsiRecord* pMsiRecord)
{
    LONG       Status;
    MSIHANDLE  MsiHandle;

    //
    // The MsiViewFetch api will retrieve a record from a query --
    // it does this in an enumeration style, so we are retrieving
    // the next record in the query
    //

    Status = MsiViewFetch(
        GetState(),
        &MsiHandle);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // We successfully obtained an MSIHANDLE corresponding to the
        // retrieved record, so we use this to set the state of our
        // abstraction of the record
        //
        pMsiRecord->SetState( MsiHandle );
    }

    return Status;
}

LONG
CMsiQuery::UpdateQueryFromFilter( CMsiRecord* pFilterRecord )
{
    LONG       Status;

    //
    // The MsiViewExecute api causes the results of the query to
    // be computed.  The filter record passed in allows us to
    // specify a filter for the query results
    //
    Status = MsiViewExecute(
        GetState(),
        pFilterRecord ? pFilterRecord->GetState() : NULL );

    return Status;
}

LONG
CMsiDatabase::Open(
    WCHAR*  wszPath,
    DWORD   cTransforms,
    WCHAR** rgwszTransforms)
{
    MSIHANDLE  DatabaseHandle;
    LONG       Status;

    //
    // The MsiOpenDatabase api abstracts an .msi package
    //
    Status = MsiOpenDatabase(
        wszPath,
        MSIDBOPEN_READONLY,
        &DatabaseHandle);

    if ( ERROR_SUCCESS == Status )
    {
        DWORD iTransform;

        //
        // The successful open above does not include transforms --
        // we need to add each transform to generate a resultant
        // database that includes the changes of each transform
        //

        //
        // We apply the transforms in the order in which they are
        // stored in the vector -- this order conforms to that
        // specified by the administrator, and since order affects
        // the result, we must honor the administrator's ordering
        //
        for ( iTransform = 0; iTransform < cTransforms; iTransform++ )
        {
            if ( ERROR_SUCCESS == Status )
            {
                //
                // This api adds the effects of the transform to the
                // database.
                //
                Status = MsiDatabaseApplyTransform(
                    DatabaseHandle,
                    rgwszTransforms[iTransform],
                    0);
            }

            if ( ERROR_SUCCESS != Status )
            {
                //
                // If we failed to apply a transform, we bail
                //
                break;
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We have successfully created an database of the
            // package + transforms, so we allow the lifetime of its state
            // to be controlled by this object
            //
            SetState( DatabaseHandle );
        }
        else
        {
            //
            // If we failed to apply a transform, the database
            // resource is useless, so we free it
            //
            MsiCloseHandle( DatabaseHandle );
        }
    }

    return Status;
}

LONG
CMsiDatabase::OpenQuery(
    WCHAR*     wszQuery,
    CMsiQuery* pQuery )
{
    LONG       Status;
    MSIHANDLE  MsiHandle;

    //
    // This api will initialize a query without comoputing its
    // results.  This will allow the caller finer control over result
    // computation later, which distinguishes this method from GetQueryResults
    //
    Status = MsiDatabaseOpenView(
        GetState(),
        wszQuery,
        &MsiHandle);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Give the caller's query object the state for the query
        // so that it can control its lifetime
        //
        pQuery->SetState( MsiHandle );
    }

    return Status;
}

LONG
CMsiDatabase::GetQueryResults(
    WCHAR*     wszQuery,
    CMsiQuery* pQuery )
{
    LONG       Status;
    MSIHANDLE  MsiHandle;

    //
    // This api will initialize a query without computing the results
    //
    Status = MsiDatabaseOpenView(
        GetState(),
        wszQuery,
        &MsiHandle);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // The semantics of this method are that the caller may also
        // enumerate results after calling the method, so we must
        // now computer the results so that the caller may enumerate --
        // the api below will do this
        //
        Status = MsiViewExecute(
            MsiHandle,
            NULL);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // In the success case, we give the lifetime of the msi
            // state to the query object
            //
            pQuery->SetState( MsiHandle );
        }
        else
        {
            //
            // On failure, we must clear the msi query state
            // since it is useless now.
            //
            MsiCloseHandle( MsiHandle );
        }
    }

    return Status;
}

LONG
CMsiDatabase::TableExists(
    WCHAR* wszTableName,
    BOOL*  pbTableExists )
{
    MSICONDITION TableState;

    TableState = MsiDatabaseIsTablePersistent( GetState(), wszTableName );

    if ( MSICONDITION_ERROR == TableState )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbTableExists = MSICONDITION_TRUE == TableState;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\locpkg.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LocPkg.cpp
//
//  Contents:   locale - platform property page
//
//  Classes:    CLocPkg
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocPkg property page

IMPLEMENT_DYNCREATE(CLocPkg, CPropertyPage)

CLocPkg::CLocPkg() : CPropertyPage(CLocPkg::IDD)
{
        //{{AFX_DATA_INIT(CLocPkg)
        m_fIA64 = FALSE;
        m_fX86 = FALSE;
        //}}AFX_DATA_INIT
        m_pIClassAdmin = NULL;
}

CLocPkg::~CLocPkg()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CLocPkg::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CLocPkg)
        DDX_Check(pDX, IDC_CHECK1, m_fIA64);
        DDX_Check(pDX, IDC_CHECK2, m_fX86);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLocPkg, CPropertyPage)
        //{{AFX_MSG_MAP(CLocPkg)
        ON_BN_CLICKED(IDC_CHECK1, OnChange)
        ON_BN_CLICKED(IDC_CHECK2, OnChange)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLocPkg message handlers

BOOL CLocPkg::OnApply()
{
    PLATFORMINFO * pPlatformInfo = m_pData->m_pDetails->pPlatformInfo;
    UINT i = 0;
    if (m_fX86)
    {
        i++;
    }
    if (m_fIA64)
    {
        i++;
    }
    if (i == 0)
    {
        CString szTitle;
        szTitle.LoadString(IDS_BADDATA);
        CString szText;
        szText.LoadString(IDS_PLATFORMREQUIRED);
        MessageBox(szText, szTitle, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }
    m_pData->m_pDetails->pPlatformInfo = new PLATFORMINFO;
    m_pData->m_pDetails->pPlatformInfo->cPlatforms = i;
    m_pData->m_pDetails->pPlatformInfo->prgPlatform = new CSPLATFORM[i];
    m_pData->m_pDetails->pPlatformInfo->cLocales = pPlatformInfo->cLocales;
    m_pData->m_pDetails->pPlatformInfo->prgLocale = pPlatformInfo->prgLocale;
    i = 0;
    if (m_fX86)
    {
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId = VER_PLATFORM_WIN32_NT;
            m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi = 5;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo = 0;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch = PROCESSOR_ARCHITECTURE_INTEL;
        i++;
    }
    if (m_fIA64)
    {
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId = VER_PLATFORM_WIN32_NT;
            m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi = 5;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo = 0;
        m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch = PROCESSOR_ARCHITECTURE_IA64;
    }
    HRESULT hr = S_OK;
#if 0
    hr = m_pIClassAdmin->UpgradePackage(m_pData->m_pDetails->pszPackageName,
                                                m_pData->m_pDetails);
    if (FAILED(hr))
    {
        PLATFORMINFO * pTemp = m_pData->m_pDetails->pPlatformInfo;
        m_pData->m_pDetails->pPlatformInfo = pPlatformInfo;
        pPlatformInfo = pTemp;
    }
    else
        MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);
#endif
    delete [] pPlatformInfo->prgPlatform;
    delete pPlatformInfo;
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(sz, hr);
        return FALSE;
    }
    SetModified(FALSE);
    return CPropertyPage::OnApply();
}

BOOL CLocPkg::OnInitDialog()
{
    UINT i;
    for (i = m_pData->m_pDetails->pPlatformInfo->cPlatforms; i--;)
    {
        switch (m_pData->m_pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
        {
        case PROCESSOR_ARCHITECTURE_INTEL:
            m_fX86 = TRUE;
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            m_fIA64 = TRUE;
            break;
        default:
            break;
        }
    }
    TCHAR szBuffer[256];
    CString sz;
    i = 0;
    while (i < m_pData->m_pDetails->pPlatformInfo->cLocales)
    {
        GetLocaleInfo(m_pData->m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SLANGUAGE, szBuffer, 256);
        sz = szBuffer;
#ifdef SHOWCOUNTRY
        GetLocaleInfo(m_pData->m_pDetails->pPlatformInfo->prgLocale[i], LOCALE_SCOUNTRY, szBuffer, 256);
        sz += _T(" - ");
        sz += szBuffer;
#endif
        i++;
        ((CListBox *)GetDlgItem(IDC_LIST1))->AddString(sz);
    }

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CLocPkg::OnChange()
{
    SetModified();
}

LRESULT CLocPkg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}


void CLocPkg::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_LOCALE_PACKAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\lcidpick.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       lcidpick.h
//
//  Contents:   locale picker dialog (used to choose which of a set of
//              locales an app should be deployed in)
//
//  Classes:    CLcidPick
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
#define AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CLcidPick dialog

class CLcidPick : public CDialog
{
// Construction
public:
        CLcidPick(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CLcidPick)
        enum { IDD = IDD_LOCALE_PICKER };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA
        set<LCID> * m_psLocales;


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CLcidPick)
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CLcidPick)
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\locpkg.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LocPkg.h
//
//  Contents:   local and deployment platform property page
//
//  Classes:    CLocPkg
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CLocPkg dialog

class CLocPkg : public CPropertyPage
{
        DECLARE_DYNCREATE(CLocPkg)

// Construction
public:
        CLocPkg();
        ~CLocPkg();

        CLocPkg ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CLocPkg)
        enum { IDD = IDD_LOCALE_PACKAGE };
        BOOL    m_fIA64;
        BOOL    m_fX86;
        //}}AFX_DATA
        CAppData *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CLocPkg)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CLocPkg)
        virtual BOOL OnInitDialog();
        afx_msg void OnChange();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\msiclass.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msiclass.cpp
//
//  Contents:   msi class collection abstraction
//
//  Classes:
//
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

WCHAR* CClassCollection::_wszQueries[ TYPE_COUNT ] =
{
    QUERY_EXTENSIONS,
    QUERY_CLSIDS,
    QUERY_VERSION_INDEPENDENT_PROGIDS
};

CClassCollection::CClassCollection( PACKAGEDETAIL* pPackageDetail ) :
    _pPackageDetail( pPackageDetail ),
    _cMaxClsids( 0 ),
    _cMaxExtensions( 0 ),
    _InstallLevel( 0 )
{
    //
    // All memory referenced by the pPackageDetail must be
    // freed by the caller after the GetClasses method is called,
    // even if the call fails.
    //

    //
    // We need to clear any existing class information in the
    // PACKAGEDETAIL structure since we are going to overwrite
    // it eventually anyway
    //

    //
    // First clear the clsid's
    //
    DWORD iClass;

    //
    // Free each individual class
    //
    for ( iClass = 0; iClass < _pPackageDetail->pActInfo->cClasses; iClass++ )
    {
        FreeClassDetail( &(_pPackageDetail->pActInfo->pClasses[ iClass ]) );
    }

    //
    // Now free the vector that held the classes
    //
    LocalFree( _pPackageDetail->pActInfo->pClasses );

    //
    // Set our vector reference to the initial state of none
    //
    _pPackageDetail->pActInfo->pClasses = NULL;

    //
    // Set the initial state of no clsid's since they have all been freed
    //
    _pPackageDetail->pActInfo->cClasses = 0;


    //
    // Now clear the extensions
    //
    DWORD iExtension;

    //
    // For each individual extension
    //
    for ( iExtension = 0; iExtension < _pPackageDetail->pActInfo->cShellFileExt; iExtension++ )
    {
        LocalFree( _pPackageDetail->pActInfo->prgShellFileExt[ iExtension ] );
    }

    //
    // Free the vector that held the extensions
    //
    LocalFree( _pPackageDetail->pActInfo->prgShellFileExt );

    //
    // Also destroy the vector that held extension priorities
    //
    LocalFree( _pPackageDetail->pActInfo->prgPriority );

    //
    // Set our vector references to the initial state of none
    //
    _pPackageDetail->pActInfo->prgShellFileExt = NULL;
    _pPackageDetail->pActInfo->prgPriority = NULL;

    //
    // Set the initial state of no file extensions since they have all been freed
    //
    _pPackageDetail->pActInfo->cShellFileExt = 0;
}


HRESULT
CClassCollection::GetClasses( BOOL bFileExtensionsOnly )
{
    HRESULT hr;
    LONG    Status;
    DWORD   cTransforms;

    //
    // This method obtains the class metadata from an msi package + transforms.
    // The goal is to approximate the set of class data that would be advertised
    // on any system (regardless of system configuration) if the package were
    // advertised.
    //

    //
    // The classes will all be stored in the PACKAGEDETAIL structure.  The caller
    // must free this memory after finishing with the structure, even if this
    // method fails
    //

    //
    // First, we must create a database representation of the package + transforms
    //

    //
    // The source list vector contains the package + transforms in application order --
    // we must subtract one source since the original package is included in the list
    //
    cTransforms = _pPackageDetail->cSources - 1;

    //
    // Now we create a database out of the package plus transforms.  Since the
    // first item in the source list is the package, we pass that in as the package,
    // and all other items after it in the vector are passed in as the transform vector
    //
    Status = _Database.Open(
        _pPackageDetail->pszSourceList[0],
        cTransforms,
        cTransforms ? &(_pPackageDetail->pszSourceList[1]) : NULL );

    if ( ERROR_SUCCESS == Status )
    {
        //
        // We've successfully opened the package, now obtain its friendly name.
        //
        Status = GetFriendlyName();

        if (ERROR_SUCCESS == Status)
        {
            //
            // Now obtain its install level.
            // The install level affects whether or not a class will get advertised
            //
            Status = GetInstallLevel();

        }

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Now that we know the install level of the package, we have
            // enough information to flag each advertisable feature in the database.
            // We need this because a class is only advertised if its associated
            // feature is advertised.
            //
            Status = FlagAdvertisableFeatures();
        }

        //
        // We may now retrieve the set of classes that will be advertised based
        // on the set of advertised features we flagged earlier.  We care only
        // about 3 types of classes: Clsid's, ProgId's, and File Extenions.
        //
        if ( ! bFileExtensionsOnly )
        {
            if ( ERROR_SUCCESS == Status )
            {
                Status = GetClsids();
            }

            if ( ERROR_SUCCESS == Status )
            {
                Status = GetProgIds();
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = GetExtensions();
        }

        LONG StatusFree;

        //
        // We must remove the scratch flags we added to the database
        //
        StatusFree = RemoveAdvertisableFeatureFlags();

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Take care to preserve the return value -- a failure
            // before cleaning up the database takes precedence over
            // a failure in cleaning up the database.
            //
            Status = StatusFree;
        }
    }

    return HRESULT_FROM_WIN32(Status);
}

LONG
CClassCollection::GetExtensions()
{
    LONG Status;
    BOOL bTableExists;

    //
    // First check to see if we even have an extension table to query
    //
    Status = _Database.TableExists( TABLE_FILE_EXTENSIONS, &bTableExists );

    if ( ( ERROR_SUCCESS == Status ) && bTableExists )
    {
        //
        // Set up a destination in the user's PACKAGEDETAIL structure
        // for the shell extension class data
        //
        DataDestination Destination(
            TYPE_EXTENSION,
            (void**)&(_pPackageDetail->pActInfo->prgShellFileExt),
            &(_pPackageDetail->pActInfo->cShellFileExt),
            (UINT*) &_cMaxExtensions);

        //
        // Now retrieve the shell extensions
        //
        Status = GetElements(
            TYPE_EXTENSION,
            &Destination );

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We've successfully retrieved the shell extensions --
            // the caller also expects a parallel array of priorities
            // with each shell extension -- the values are unimportant
            // since the caller will fill those in, but the memory must
            // exist, so we will allocate it.
            //
            _pPackageDetail->pActInfo->prgPriority =
                (UINT*) LocalAlloc(
                    0,
                    sizeof(UINT) *
                    _pPackageDetail->pActInfo->cShellFileExt );

            if ( ! _pPackageDetail->pActInfo->prgPriority )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    return Status;
}


LONG
CClassCollection::GetClsids()
{
    LONG Status;
    BOOL bTableExists;

    //
    // First check to see if we even have a clsid table to query
    //
    Status = _Database.TableExists( TABLE_CLSIDS, &bTableExists );

    if ( ( ERROR_SUCCESS == Status ) && bTableExists )
    {
        //
        // Set the destination for the clsid's to a location
        // in the caller's PACKAGEDETAIL structure
        //
        DataDestination Destination(
            TYPE_CLSID,
            (void**)&(_pPackageDetail->pActInfo->pClasses),
            &(_pPackageDetail->pActInfo->cClasses),
            (UINT*) &_cMaxClsids);

        //
        // Now retrieve the clsid's for each package
        //
        Status = GetElements(
            TYPE_CLSID,
            &Destination );
    }

    return Status;
}

LONG
CClassCollection::GetProgIds()
{
    LONG Status;
    BOOL bTableExists;

    //
    // First check to see if we even have a ProgId table to query
    //
    Status = _Database.TableExists( TABLE_PROGIDS, &bTableExists );

    if ( ( ERROR_SUCCESS == Status ) && bTableExists )
    {
        //
        // This method MUST be called AFTER GetClsids -- progid's
        // are stored within their associated clsid's, so we will
        // not have a place to store the progid's unless we've
        // already obtained the clsid's.
        //

        //
        // At this point, we know only that we want to retrieve ProgId's --
        // we do not know their destination because this differs for
        // each progid depending on the associated clsid -- the NULL
        // parameters indicate that some callee will need to determine
        // the location for this data.
        //
        DataDestination Destination(
            TYPE_PROGID,
            NULL,
            NULL,
            NULL);

        //
        // Retrieve the progid's into the appropriate locations in the structure
        //
        Status = GetElements(
            TYPE_PROGID,
            &Destination );
    }

    return ERROR_SUCCESS;
}

LONG
CClassCollection::GetElements(
    DWORD            dwType,
    DataDestination* pDestination )
{
    LONG      Status;

    CMsiQuery ElementQuery;

    //
    // Perform the query for the class elements
    //
    Status = _Database.GetQueryResults(
        _wszQueries[ dwType ],
        &ElementQuery);

    if ( ERROR_SUCCESS != Status )
    {
        return Status;
    }

    for (;;)
    {
        //
        // We've obtained the results -- now we enumerate them so
        // that we can persist them in the caller's PACKAGEDETAIL
        // structure.
        //

        //
        // Note that we start a new scope so that our record object
        // will automatically free its resources
        //
        {
            CMsiRecord CurrentRecord;

            //
            // Enumerate the next record in the query result set
            //
            Status = ElementQuery.GetNextRecord( &CurrentRecord );

            if ( ERROR_SUCCESS != Status )
            {
                if ( ERROR_NO_MORE_ITEMS == Status )
                {
                    Status = ERROR_SUCCESS;
                }

                break;
            }

            //
            // Now attempt to add the class data from this record into
            // the PACKAGEDETAIL structure
            //
            Status = ProcessElement(
                dwType,
                &CurrentRecord,
                pDestination);
        }

        if ( ERROR_SUCCESS != Status )
        {
            break;
        }
    }

    return Status;
}


LONG
CClassCollection::FlagAdvertisableFeatures()
{
    LONG Status;

    CMsiQuery FeatureQueryCreate;

    //
    // We will attempt to mark each feature in the database
    // with a flag indicating whether or not it will be advertised
    //

    //
    // First, add a column to the feature table of the database
    // so that we can use the column to flag whether or not the
    // feature is advertised.
    //
    Status = _Database.GetQueryResults(
        QUERY_ADVERTISED_FEATURES_CREATE,
        &FeatureQueryCreate);

    CMsiQuery FeatureQueryInit;

    //
    // Now intialize the new column's flags to 0 which
    // indicates that no features will be advertised (yet)
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = _Database.GetQueryResults(
            QUERY_ADVERTISED_FEATURES_INIT,
            &FeatureQueryInit);
    }

    CMsiQuery AllFeatures;

    //
    // Now we perform the query to retrieve all features --
    // records in this query will contain the newly added
    // flag column.
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = _Database.GetQueryResults(
            QUERY_ADVERTISED_FEATURES_RESULT,
            &AllFeatures);
    }

    CMsiQuery SetAdvertised;

    //
    // Create a query that will allow us to set the flag --
    // this query is not yet computed, simply initialized
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = _Database.OpenQuery(
            QUERY_FEATURES_SET,
            &SetAdvertised);
    }

    //
    // Now we enumerate through all the features and
    // set the flag for each feature that passes the tests
    // for advertisability.
    //
    for (; ERROR_SUCCESS == Status ;)
    {
        CMsiRecord CurrentRecord;
        BOOL       bAdvertised;

        //
        // Retrieve the current feature
        //
        Status = AllFeatures.GetNextRecord(
            &CurrentRecord);

        if ( ERROR_SUCCESS != Status )
        {
            if ( ERROR_NO_MORE_ITEMS == Status )
            {
                Status = ERROR_SUCCESS;
            }

            break;
        }

        //
        // Determine whether or not this feature should be advertised
        //
        Status = GetFeatureAdvertiseState(
            &CurrentRecord,
            &bAdvertised );

        if ( ( ERROR_SUCCESS == Status ) &&
             bAdvertised )
        {
            //
            // This feature is advertisable -- use our SetAdvertised query
            // to set the advertisability flag to true.
            //
            Status = SetAdvertised.UpdateQueryFromFilter( &CurrentRecord );
        }
    }

    return Status;
}

LONG
CClassCollection::RemoveAdvertisableFeatureFlags()
{
    LONG Status;

    CMsiQuery FreeQuery;

    //
    // Retrieving the results of this query will
    // eliminate the extra flag column we added
    // to the feature table to flag advertisable
    // features.
    //
    Status = _Database.GetQueryResults(
        QUERY_ADVERTISED_FEATURES_DESTROY,
        &FreeQuery);

    return Status;
}

LONG
CClassCollection::GetInstallLevel()
{
    LONG Status;

    CMsiQuery InstallLevelQuery;

    //
    // Perform a query which retrieves the install level
    // property from the package's property table
    //
    Status = _Database.GetQueryResults(
        QUERY_INSTALLLEVEL,
        &InstallLevelQuery);

    CMsiRecord InstallLevelRecord;

    //
    // This query should only have one record in it since
    // it was targeted at the specific record for install level --
    // we now read that record
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = InstallLevelQuery.GetNextRecord(
            &InstallLevelRecord);
    }

    if ( ERROR_SUCCESS == Status )
    {
        CMsiValue InstallLevelProperty;

        //
        // We now attempt to obtain the installlevel property value
        // from the retrieved record.
        //
        Status = InstallLevelRecord.GetValue(
            CMsiValue::TYPE_DWORD,
            PROPERTY_COLUMN_VALUE,
            &InstallLevelProperty);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We've successfully obtained the value, so we set it
            //
            _InstallLevel = InstallLevelProperty.GetDWORDValue();
        }
    }
    else if ( ERROR_NO_MORE_ITEMS == Status )
    {
        //
        // This will only happen if the install level property
        // is not present.  As fundamental as this property is,
        // some packages do not specify it.  The Darwin engine
        // treats this case as an implicit install level of 1, so
        // we must do the same here
        //
        _InstallLevel = 1;

        Status = ERROR_SUCCESS;
    }


    return Status;
}

LONG
CClassCollection::GetFriendlyName()
{
    LONG Status;

    CMsiQuery FriendlyNameQuery;

    //
    // Perform a query which retrieves the install level
    // property from the package's property table
    //
    Status = _Database.GetQueryResults(
        QUERY_FRIENDLYNAME,
        &FriendlyNameQuery);

    CMsiRecord FriendlyNameRecord;

    //
    // This query should only have one record in it since
    // it was targeted at the specific record
    // we now read that record
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = FriendlyNameQuery.GetNextRecord(
            &FriendlyNameRecord);
    }

    if ( ERROR_SUCCESS == Status )
    {
        CMsiValue FriendlyNameProperty;

        //
        // We now attempt to obtain the property value
        // from the retrieved record.
        //
        Status = FriendlyNameRecord.GetValue(
            CMsiValue::TYPE_STRING,
            PROPERTY_COLUMN_VALUE,
            &FriendlyNameProperty);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We've successfully obtained the value, so we set it
            //
            CString szName = FriendlyNameProperty.GetStringValue();
            OLESAFE_DELETE(_pPackageDetail->pszPackageName);
            OLESAFE_COPYSTRING(_pPackageDetail->pszPackageName, szName);
        }
    }

    return Status;
}

LONG
CClassCollection::GetFeatureAdvertiseState(
    CMsiRecord* pFeatureRecord,
    BOOL*       pbAdvertised )
{
    LONG      Status;
    CMsiValue Attributes;
    CMsiValue InstallLevel;

    //
    // Set the out paramter's initial value to FALSE,
    // indicating that the feature is not advertised
    //
    *pbAdvertised = FALSE;

    //
    // The Attributes column of the feature table
    // contains a flag indicating that a feature
    // should be not advertised
    //
    Status = pFeatureRecord->GetValue(
        CMsiValue::TYPE_DWORD,
        FEATURE_COLUMN_ATTRIBUTES,
        &Attributes);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // If the disable advertise flag is set, this feature
        // cannot be advertised
        //
        if ( Attributes.GetDWORDValue() & MSI_DISABLEADVERTISE )
        {
            return ERROR_SUCCESS;
        }

        //
        // The disable flag was not set -- that still does not mean that
        // the feature is advertised -- we must check the install level.
        // We retrieve the install level for this feature here
        //
        Status = pFeatureRecord->GetValue(
            CMsiValue::TYPE_DWORD,
            FEATURE_COLUMN_LEVEL,
            &InstallLevel);
    }

    if ( ERROR_SUCCESS == Status )
    {
        DWORD dwInstallLevel;

        //
        // Obtain the value for the install level so
        // we can compare against the package install level
        //
        dwInstallLevel = InstallLevel.GetDWORDValue();

        //
        // An install level of 0 indicates that the package will
        // not be advertised.  The install level of the feature
        // must be no higher than the package's global install
        // level
        //
        if ( ( 0 != dwInstallLevel ) &&
             ( dwInstallLevel <= _InstallLevel ) )
        {
            //
            // This feature passes the tests -- set the out parameter
            // to TRUE to indicate that the feature should be advertised
            //
            *pbAdvertised = TRUE;
        }
    }

    return Status;
}


LONG
CClassCollection::AddElement(
    void*            pvDataSource,
    DataDestination* pDataDestination)
{
    DWORD*  pcMax;
    BYTE*   pNewResults;
    DWORD   cCurrent;

    //
    // We attempt to add an element to a vector
    //

    //
    // Set the count for how many elements are stored in the vector to
    // that specified by the caller
    //
    cCurrent = *(pDataDestination->_pcCurrent);

    //
    // Set the element count for the maximum number of elements that
    // will fit in the vector currently to that specified by the caller
    //
    pcMax = (DWORD*) pDataDestination->_pcMax;

    //
    // Set our results to point to the vector specified by the caller
    //
    pNewResults = (BYTE*) pDataDestination->_ppvData;

    //
    // If we already have the maximum number of elements in the vector,
    // we will have to make room for more
    //
    if ( *pcMax >= cCurrent)
    {
        DWORD cbSize;

        //
        // Calculate the new size in bytes so that we can ask the system
        // for memory.  We take our current size in elements and add on a fixed
        // allocation increment.  The caller has specified the size
        // of each individual element, so we use that to turn the number
        // of elements to a memory size.
        //
        cbSize = ( *pcMax + CLASS_ALLOC_SIZE ) *
            pDataDestination->_cbElementSize;

        //
        // Make the request for memory
        //
        pNewResults = (BYTE*) LocalAlloc( 0, cbSize );

        if ( ! pNewResults )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Clear the memory -- any data structures embedded in the element
        // will have NULL references and thus will be properly initialized
        //
        memset( pNewResults, 0, cbSize );

        //
        // If the original maximum size of the vector was nonzero, then we must
        // copy to original contents of the vector to the newly allocated memory
        // location.
        //
        if ( *pcMax )
        {
            memcpy(
                pNewResults,
                *(pDataDestination->_ppvData),
                *pcMax * pDataDestination->_cbElementSize);
        }

        //
        // Free the original vector as it is no longer needed
        //
        LocalFree( *(pDataDestination->_ppvData) );

        //
        // Change the caller's reference to point to the new vector
        //
        *(pDataDestination->_ppvData) = pNewResults;

        //
        // Set the new maximum size (in elements) to that of the newly allocated vector
        //
        *pcMax += CLASS_ALLOC_SIZE;
    }

    //
    // At this point, we know we have a memory location in the vector into
    // which we can safely copy the new element
    //
    memcpy(
        pNewResults + ( cCurrent * pDataDestination->_cbElementSize ),
        pvDataSource,
        pDataDestination->_cbElementSize);

    //
    // Update the count of elements currently stored in the vector
    //
    *(pDataDestination->_pcCurrent) = cCurrent + 1;

    return ERROR_SUCCESS;
}


LONG
CClassCollection::ProcessElement(
    DWORD            dwType,
    CMsiRecord*      pRecord,
    DataDestination* pDataDestination)
{
    LONG        Status = ERROR_SUCCESS;
    void*       pvData;
    WCHAR*      wszData;
    CLASSDETAIL ClassDetail;

    pvData = NULL;
    wszData = NULL;

    //
    // We attempt to create a new class element based
    // on the record passed in by the caller, and then
    // add that element to the caller's PACKAGEDETAIL structure
    //

    //
    // The type of element to be added depends on the type
    // of class requested by the caller.  The pvData variable
    // will point to the element to be added if we can successfully
    // create a representation for it.
    //
    switch ( dwType )
    {
    case TYPE_EXTENSION:

        //
        // Get a file extension representation from the record --
        // note that wszData points to memory allocated by the callee
        // on success, so it must be freed by this function.
        //
        Status = ProcessExtension(
            pRecord,
            &wszData);

        if ( ERROR_SUCCESS == Status )
        {
            pvData = &wszData;
        }

        break;

    case TYPE_CLSID:

        //
        // Get a clsid representation from the record --
        // in this case, the ClassDetail itself does not
        // need to be freed since it does not contain any references
        // to memory after this call
        //
        BOOL bIgnoreClsid;

        Status = ProcessClsid(
            pRecord,
            &ClassDetail,
            &bIgnoreClsid);

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Check to see if we should add this clsid -- we may be prohibited from
            // this because it is a duplicate of an exsting clsid, which would be
            // redundant and furthermore the PACKAGEDETAIL format requires
            // that all (clsid, clsctx) pairs be unique. Or the clsid itself
            // may have an unsupported clsctx.  This is not a failure
            // case, so we return success here and simply avoid addding this
            // class
            //
            if ( bIgnoreClsid )
            {
                return ERROR_SUCCESS;
            }

            pvData = &ClassDetail;
        }

        break;

    case TYPE_PROGID:

        //
        // Get a progid representation from the record.  In addition
        // to retrieving the progid in the form of an allocated string
        // which must be freed by this funciton, we also retrieve the
        // location at which to add the progid to the caller's
        // PACKAGEDETAIL structure. This is necessary since the
        // ProgId must be part of the CLASSDETAIL structure with which
        // it is associated.
        //
        Status = ProcessProgId(
            pRecord,
            pDataDestination,
            &wszData);

        if ( ( ERROR_SUCCESS == Status ) &&
             wszData )
        {
            pvData = &wszData;
        }

        break;

    default:
        ASSERT(FALSE);
        break;
    }

    //
    // If we were successful in obtaining a representation of the record
    // that can be stored in the caller's PACKAGEDETAIL structure, attempt
    // to add it to the structure
    //
    if ( pvData )
    {
        Status = AddElement(
            pvData,
            pDataDestination);
    }

    //
    // Be sure that in the failure case, we free any memory
    // that may have been allocated.
    //
    if ( ERROR_SUCCESS != Status )
    {
        if (wszData )
        {
            LocalFree( wszData );
        }
    }

    return Status;
}

LONG
CClassCollection::ProcessExtension(
    CMsiRecord*      pRecord,
    WCHAR**          ppwszExtension)
{
    LONG      Status;
    CMsiValue FileExtension;

    *ppwszExtension = NULL;

    //
    // We retrieve the actual file extension string
    //
    Status = pRecord->GetValue(
        CMsiValue::TYPE_STRING,
        EXTENSION_COLUMN_EXTENSION,
        &FileExtension);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // We have the value.  Note that it does not contain
        // an initial '.', but the usage of the PACKAGEDETAIL
        // structure mandates that file extensions begin with the '.'
        // char, so we will have to prepend the '.' here.
        //

        //
        // First, get space for a copy of the string that includes
        // the '.' as well as the zero terminator.
        //
        *ppwszExtension = (WCHAR*) LocalAlloc(
            0,
            (FileExtension.GetStringSize() + 1 + 1) * sizeof(WCHAR) );

        if ( ! *ppwszExtension )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            return Status;
        }

        //
        // Set the first char to be '.'
        //
        **ppwszExtension = L'.';

        //
        // Now append the actual extension to the '.'
        //
        lstrcpy( *ppwszExtension + 1, FileExtension.GetStringValue() );
    }

    return Status;
}


LONG
CClassCollection::ProcessClsid(
    CMsiRecord*      pRecord,
    CLASSDETAIL*     pClsid,
    BOOL*            pbIgnoreClsid)
{
    LONG  Status;
    DWORD dwClsCtx;
    
    CMsiValue GuidString;
    CMsiValue ClassContext;

    //
    // Clear the clsid to a safe state
    //
    memset( pClsid, 0, sizeof( *pClsid ) );

    //
    // Reset out parameters
    //
    *pbIgnoreClsid = FALSE;

    dwClsCtx = 0;

    //
    // Retrieve the actual clsid
    //
    Status = pRecord->GetValue(
        CMsiValue::TYPE_STRING,
        CLSID_COLUMN_CLSID,
        &GuidString);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Get the clsctx for this clsid
        //
        Status = pRecord->GetValue(
            CMsiValue::TYPE_STRING,
            CLSID_COLUMN_CONTEXT,
            &ClassContext);
    }

    if ( ERROR_SUCCESS == Status )
    {
        CMsiValue Attribute;
        WCHAR*    wszClassContext;
        DWORD     dwInprocClsCtx;

        dwInprocClsCtx = 0;

        //
        // Retrieve a string representation of the clsctx for this clsid
        //
        wszClassContext = ClassContext.GetStringValue();

        //
        // Now map the clsctx strings to COM CLSCTX_* values
        //
        if ( 0 == lstrcmpi( wszClassContext, COM_INPROC_CONTEXT) )
        {
            dwInprocClsCtx |= CLSCTX_INPROC_SERVER;
        }
        else if ( 0 == lstrcmpi( wszClassContext, COM_INPROCHANDLER_CONTEXT) )
        {
            dwInprocClsCtx |= CLSCTX_INPROC_HANDLER;
        }
        else if ( 0 == lstrcmpi( wszClassContext, COM_LOCALSERVER_CONTEXT) )
        {
            dwClsCtx |= CLSCTX_LOCAL_SERVER;
        }
        else if ( 0 == lstrcmpi( wszClassContext, COM_REMOTESERVER_CONTEXT) )
        {
            dwClsCtx |= CLSCTX_REMOTE_SERVER;
        }
        else
        {
            //
            // If the clsctx is one we do not support, we will ignore it
            //
            *pbIgnoreClsid = TRUE;

            return ERROR_SUCCESS;
        }

        BOOL b64Bit;

        b64Bit = FALSE;

        //
        // We must disginguish between 32-bit and 64-bit in-process servers, since
        // 64-bit Windows does not allows modules of different bitness to coexist in the
        // same process.  If this is an in-process component, we will also check to see
        // whether it is 64-bit or not.
        //
        if ( ( dwInprocClsCtx & CLSCTX_INPROC_HANDLER ) ||
             ( dwInprocClsCtx & CLSCTX_INPROC_SERVER ) )
        {
            //
            // The Attributes column of the record has a flag indicating bitness -- this
            // will only fail if the property is NULL
            //
            Status = pRecord->GetValue(
                CMsiValue::TYPE_DWORD,
                CLSID_COLUMN_ATTRIBUTES,
                &Attribute);

            //
            // Check the flag to see if this is 64-bit
            //
            if ( ERROR_SUCCESS == Status )
            {
                b64Bit = Attribute.GetDWORDValue() & MSI_64BIT_CLASS;
            }
            else
            {
                //
                // This means the property is NULL, so we interpret that as
                // meaning the application is not 64 bit
                //
                Status = ERROR_SUCCESS;
            }

            //
            // Map this 64-bit clsctx to a custom (non-COM) CLSCTX that
            // indicates that this is a 64-bit-only in-process class.
            //
            if ( ( ERROR_SUCCESS == Status ) && b64Bit )
            {
                if ( dwInprocClsCtx & CLSCTX_INPROC_SERVER )
                {
                    dwClsCtx |= CLSCTX64_INPROC_SERVER;
                }

                if ( dwInprocClsCtx & CLSCTX_INPROC_HANDLER )
                {
                    dwClsCtx |= CLSCTX64_INPROC_HANDLER;
                }
            }
        }

        //
        // In the 32-bit case, just or in the values we already computed for
        // inproc case
        //
        if ( ! b64Bit )
        {
            dwClsCtx |= dwInprocClsCtx;
        }
    }
    
    //
    // Check to see if this is a duplicate -- we do this because our query
    // returned results distinct in (clsid, clsctx, attribute).  Since we
    // are mapping attribute to clsctx above and we only support 1 attribute
    // flag (the 64-bit flag) out of several, we may end up with duplicate
    // (clsid, clsctx) pairs, and the PACKAGEDETAIL format requires that
    // we have unique (clsid, clsctx) pairs.  Another way to get this would
    // be if COM introduced new clsctx types which we did not support -- these
    // would map to zero, and again we could have duplicates
    //
    if ( ERROR_SUCCESS == Status )
    {
        CLASSDETAIL* pClassDetail;

        pClassDetail = NULL;

        Status = FindClass(
            GuidString.GetStringValue(),
            &pClassDetail);

        //
        // If we already have an entry for this clsid, check to see if
        // it has the same clsctx bits -- if so it is a duplicate entry
        // and we will cease processing it
        //
        if ( ( ERROR_SUCCESS == Status ) && pClassDetail )
        {
            *pbIgnoreClsid = ( dwClsCtx & pClassDetail->dwComClassContext );

            if ( *pbIgnoreClsid )
            {
                return ERROR_SUCCESS;
            }
        }
    }

    //
    // Convert the clsid string to a guid as mandated by the
    // CLASSDETAIL structure
    //
    if ( ERROR_SUCCESS == Status )
    {
        HRESULT hr;

        hr = CLSIDFromString(
            GuidString.GetStringValue(),
            &(pClsid->Clsid));

        if ( FAILED(hr) )
        {
            Status = ERROR_GEN_FAILURE;
        }
    }

    //
    // Set the clsctx we computed above.
    //
    if ( ERROR_SUCCESS == Status )
    {
        pClsid->dwComClassContext = dwClsCtx;
    }

    return Status;
}

LONG
CClassCollection::ProcessProgId(
    CMsiRecord*      pRecord,
    DataDestination* pDataDestination,
    WCHAR**          ppwszProgId)
{
    LONG  Status;

    CMsiValue    ProgIdString;
    CMsiValue    ClsidString;

    CLASSDETAIL* pClassDetail;

    //
    // We attempt to map a progid record to a
    // clsid that we've already processed, since
    // the progid will eventually need to go
    // inside the clsid's structure.
    //

    *ppwszProgId = NULL;

    pClassDetail = NULL;

    //
    // Retrieve the value for the progid itself
    //
    Status = pRecord->GetValue(
        CMsiValue::TYPE_STRING,
        PROGID_COLUMN_PROGID,
        &ProgIdString);

    //
    // Retrieve the value of the clsid associated with
    // the progid
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = pRecord->GetValue(
            CMsiValue::TYPE_STRING,
            PROGID_COLUMN_CLSID,
            &ClsidString);
    }

    //
    // We must find the existing CLASSDETAIL structure
    // that we are maintaining for the progid since the
    // progid must eventually be referenced in that structure.
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = FindClass(
            ClsidString.GetStringValue(),
            &pClassDetail);
    }

    if ( ERROR_SUCCESS == Status )
    {
        //
        // If we have successfully found the class,
        //
        if ( pClassDetail )
        {
            //
            // Give the caller the progid string since
            // we know that we have a class in which
            // to place it
            //
            *ppwszProgId = ProgIdString.DuplicateString();

            if ( ! *ppwszProgId )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                //
                // Set the caller's data destination to that of the
                // progid vector within the clsid associated with this progid
                //
                pDataDestination->_ppvData = (void**) &( pClassDetail->prgProgId );

                pDataDestination->_pcCurrent = (UINT*) &( pClassDetail->cProgId );

                pDataDestination->_pcMax = (UINT*) &( pClassDetail->cMaxProgId );
            }
        }
    }

    //
    // On failure, free any resources we've allocated
    //
    if ( ( ERROR_SUCCESS != Status ) &&
         *ppwszProgId )
    {
        LocalFree( *ppwszProgId );
    }

    return Status;
}


LONG
CClassCollection::FindClass(
    WCHAR*        wszClsid,
    CLASSDETAIL** ppClass)
{
    CLSID   Clsid;
    HRESULT hr;

    //
    // Attempt to find a CLASSDETAIL structure in the PACKAGEDETAIL structure
    // for the clsid given in string form in wszClsid
    //

    *ppClass = NULL;

    //
    // The PACKAGEDETAIL structure stores the clsid in guid form,
    // so we must convert the string to that form before searching
    //
    hr = CLSIDFromString(
        wszClsid,
        &Clsid);

    if ( FAILED(hr) )
    {
        return ERROR_GEN_FAILURE;
    }

    UINT iClsid;

    //
    // We now perform a simple linear search for the clsid
    //
    for (
        iClsid = 0;
        iClsid < _pPackageDetail->pActInfo->cClasses;
        iClsid++)
    {
        if ( IsEqualGUID(
            _pPackageDetail->pActInfo->pClasses[iClsid].Clsid,
            Clsid) )
        {
            *ppClass = &(_pPackageDetail->pActInfo->pClasses[iClsid]);
            return ERROR_SUCCESS;
        }
    }

    return ERROR_SUCCESS;
}

void
CClassCollection::FreeClassDetail( CLASSDETAIL* pClass )
{
    DWORD iProgId;

    //
    // Free each individual progid string
    //
    for ( iProgId = 0; iProgId < pClass->cProgId; iProgId++ )
    {
        LocalFree( pClass->prgProgId[ iProgId ] );
    }

    //
    // Free the array of progid strings
    //
    LocalFree( pClass->prgProgId );
}


DataDestination::DataDestination(
    DWORD        dwType,
    void**       prgpvDestination,
    UINT*        pcCurrent,
    UINT*        pcMax ) :
    _pcCurrent( pcCurrent ),
    _ppvData( prgpvDestination ),
    _pcMax ( pcMax )
{
    //
    // The size of the elements stored by
    // the vector referenced from this class
    // depend on the type of element --
    // clsid, file extension, or progid
    //

    switch ( dwType )
    {
    case TYPE_EXTENSION:
        _cbElementSize = sizeof( WCHAR* );
        break;

    case TYPE_CLSID:
        _cbElementSize = sizeof( CLASSDETAIL );
        break;

    case TYPE_PROGID:
        _cbElementSize = sizeof( WCHAR* );
        break;

    default:
        ASSERT(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\msiclass.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msiclass.h
//
//  Contents:   msi class collection abstraction
//
//  Classes:
//
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#if !defined(__MSICLASS_H__)
#define __MSICLASS_H__

//
// MSI Tables containing classes
//
#define TABLE_FILE_EXTENSIONS L"Extension"
#define TABLE_CLSIDS          L"Class"
#define TABLE_PROGIDS         L"ProgId"


//
// Package metadata queries
//

//
// Property table queries -- used to find out global information about the package
//

//
// This query is used to determine the package's global install level
//
#define QUERY_INSTALLLEVEL                L"SELECT DISTINCT `Value` FROM `Property` WHERE `Property`=\'INSTALLLEVEL\'"

// This query is used to determine the package's friendly name
//
#define QUERY_FRIENDLYNAME                L"SELECT DISTINCT `Value` FROM `Property` WHERE `Property`=\'ProductName\'"

//
// Feature table queries -- these are used to find out which features will be
// advertised so that we can later determine if the classes associated with the
// features should be advertised
//

//
// This query is less a query and more a modification operation.  It adds an additional
// temporary "_IsAdvertised" column to the table.  We use this to perform joins in
// subsequent queries.
//
#define QUERY_ADVERTISED_FEATURES_CREATE  L"ALTER TABLE `Feature` ADD `_IsAdvertised` INT TEMPORARY HOLD"

//
// Again, this query really serves as a modification operation.  This one initializes the
// temporary "_IsAdvertised" column to 0, which in our parlance is the same as initializing
// the column to "not advertised."
//
#define QUERY_ADVERTISED_FEATURES_INIT    L"UPDATE `Feature` SET `_IsAdvertised`=0"

//
// This is a conventional query -- this returns all the features in the package
//
#define QUERY_ADVERTISED_FEATURES_RESULT  L"SELECT `Feature`, `Level`, `Attributes` FROM `Feature`"

//
// Another modification query -- this eliminates the temporary changes (the additional
// column) we made to the table in the create query.
//
#define QUERY_ADVERTISED_FEATURES_DESTROY L"ALTER TABLE `Feature` FREE"

//
// The last modification query -- this allows us to set a particular feature's "_IsAdvertised"
// column to 1, which will indicate that the feature should be advertised.
//
#define QUERY_FEATURES_SET                L"UPDATE `Feature` SET `_IsAdvertised`=1 WHERE `Feature`=?"

//
// Classes queries -- retrieves file extensions, clsid's, and progid's of the package
//


//
// The rest of these queries are straightforward "read-only" queries.  They are all joins
// to the feature table, requiring that the feature table's "_IsAdvertised" property
// is set to the advertised state (1).  Thus, these queries will only give us classes that
// should be advertised
//

//
// File extensions query
//
#define QUERY_EXTENSIONS                  L"SELECT DISTINCT `Extension` FROM `Extension`, `Feature` WHERE `Extension` IS NOT NULL "  \
                                          L"AND `Extension`.`Feature_`=`Feature`.`Feature` AND `Feature`.`_IsAdvertised`=1"

//
// Clsid query
//
#define QUERY_CLSIDS                      L"SELECT DISTINCT `CLSID`, `Context`, `Component`.`Attributes` FROM `Class`, `Feature`, " \
                                          L"`Component` WHERE `CLSID` IS NOT NULL AND `Class`.`Feature_`=`Feature`.`Feature` "    \
                                          L"AND `Feature`.`_IsAdvertised`=1 AND `Component`.`Component`=`Class`.`Component_`"

//
// ProgId query
//
#define QUERY_VERSION_INDEPENDENT_PROGIDS L"SELECT DISTINCT `ProgId`,`CLSID` FROM `ProgId`, `Class`, `Feature` WHERE `ProgId` IS NOT NULL " \
                                          L"AND `ProgId`.`Class_`=`Class`.`CLSID` AND `Class`.`Feature_`=`Feature`.`Feature` "       \
                                          L"AND `Feature`.`_IsAdvertised`=1"

//
// COM clsctx values as they are stored in the package's class (clsid) table
//
#define COM_INPROC_CONTEXT        L"InprocServer32"
#define COM_INPROCHANDLER_CONTEXT L"InprocHandler32"
#define COM_LOCALSERVER_CONTEXT   L"LocalServer32"
#define COM_REMOTESERVER_CONTEXT  L"RemoteServer"

//
// MSI attribute flags
//
#define MSI_64BIT_CLASS      msidbComponentAttributes64bit
#define MSI_DISABLEADVERTISE msidbFeatureAttributesDisallowAdvertise

#define CLASS_ALLOC_SIZE 256

//
// Indices of colums for each read-only query
//

enum
{
    PROPERTY_COLUMN_VALUE = 1
};

enum
{
    FEATURE_COLUMN_FEATURE = 1,
    FEATURE_COLUMN_LEVEL,
    FEATURE_COLUMN_ATTRIBUTES
};

enum
{
    EXTENSION_COLUMN_EXTENSION = 1
};

enum
{
    CLSID_COLUMN_CLSID = 1,
    CLSID_COLUMN_CONTEXT,
    CLSID_COLUMN_ATTRIBUTES
};


enum
{
    PROGID_COLUMN_PROGID = 1,
    PROGID_COLUMN_CLSID
};

enum
{
    TYPE_EXTENSION,
    TYPE_CLSID,
    TYPE_PROGID,
    TYPE_COUNT
};


//
// Structure describing where to write an atom
// of class information.  It is also used as
// an intermediate scratch pad by CClassCollection
// in between private method calls to keep track
// of when and where to allocate new memory
// for retrieved classes.
//
struct DataDestination
{
    DataDestination(
        DWORD  dwType,
        void** prgpvDestination,
        UINT*  pcCurrent,
        UINT*  pcMax);

    DWORD  _cbElementSize;
    UINT*  _pcCurrent;
    UINT*  _pcMax;

    void** _ppvData;
};


//
// Class that uses queries to create a collection of
// a package's class data
//
class CClassCollection
{
public:

    CClassCollection( PACKAGEDETAIL* pPackageDetail );

    HRESULT
    GetClasses( BOOL bFileExtensionsOnly );

private:

    LONG
    GetClsids();

    LONG
    GetProgIds();

    LONG
    GetExtensions();

    LONG
    GetElements(
        DWORD            dwType,
        DataDestination* pDestination);

    LONG
    FlagAdvertisableFeatures();

    LONG
    RemoveAdvertisableFeatureFlags();

    LONG
    GetInstallLevel();

    LONG
    GetFriendlyName();

    LONG
    GetFeatureAdvertiseState(
        CMsiRecord* pFeatureRecord,
        BOOL*       pbAdvertised );


    LONG
    AddElement(
        void*            pvDataSource,
        DataDestination* pDataDestination);

    LONG
    ProcessElement(
        DWORD            dwType,
        CMsiRecord*      pRecord,
        DataDestination* pDataDestination);

    LONG
    ProcessExtension(
        CMsiRecord*      pRecord,
        WCHAR**          ppwszExtension);

    LONG
    ProcessClsid(
        CMsiRecord*      pRecord,
        CLASSDETAIL*     pClsid,
        BOOL*            pbIgnoreClsid);

    LONG
    ProcessProgId(
        CMsiRecord*      pRecord,
        DataDestination* pDataDestination,
        WCHAR**          ppwszProgId);

    LONG
    FindClass(
        WCHAR*        wszClsid,
        CLASSDETAIL** ppClass );

    void
    FreeClassDetail( CLASSDETAIL* pClass );

    CMsiDatabase    _Database;

    PACKAGEDETAIL*  _pPackageDetail;

    DWORD           _cMaxClsids;
    DWORD           _cMaxExtensions;

    UINT            _InstallLevel;

    static WCHAR*   _wszQueries[ TYPE_COUNT ];
};

#endif // __MSICLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\msibase.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       msibase.h
//
//  Contents:   msi database abstractions
//
//  History:    4-14-2000   adamed   Created
//
//---------------------------------------------------------------------------

#if !defined(__MSIBASE_H__)
#define __MSIBASE_H__


//
//  Module Notes
//
//  Class Relational Overview
//
//  Below we describe how the classes declared in this module
//  relate to each other -- the --> notation indicates the "yields" relation:
//
//  - A path to an MSI package --> CMsiDatabase: A path to an MSI package, along
//      with a set of transforms, can be used to instantiate a CMsiDatabase
//      object that abstracts the package with a database style view.
//
//  - CMsiDatabase --> CMsiQuery: a CMsiDatabase allows one to retrieve
//      queries against the database (MSI package).
//
//  - CMsiQuery --> CMsiRecord: a CMsiQuery allows one to retrieve or
//      alter records that are part of the results of the msi database query.
//
//  - CMsiRecord --> CMsiValue: a CMsiValue allows the retrieval of
//      individual values of an MSI database record.
//
//  -CMsiState is a base class for the classes above that maintain
//      MSI database engine state (e.g. msi handles) -- this class
//      has no direct utility to classes outside this module
//
//-------------------------------------------------------------------------------------
//
//  Class sequential Overview:
//
//  The following sequence is typical of the use of the classes envisioned
//  in the design of this module:
//
//  1.  CMsiDatabase: Instantiate a CMsiDatabase object, and call its Open method
//      in order to get a database view of a particular package.
//  2.  CMsiQuery: Use the GetQueryResults method to place the results of a query into
//      a CMsiQuery which was passed into the call as an out parameter,
//      or use the OpenQuery method to start a query without retrieving results
//      immediately (they can be retrieved later).  The latter is useful
//      when performing queries that need to update a single record -- you
//      use OpenQuery with a query string that allows the results records to be changed,
//      then call the UpdateQueryFromFilter method of CMsiQuery in order to
//      alter a record.
//  3.  CMsiRecord: Use the GetNextRecord methods of CMsiQuery to retrieve a 
//      CMsiRecord that represents a record from the query.
//  4.  CMsiValue: Use the GetValue method of CMsiRecord to retrieve a particular
//      value of the msi record.
//
//
//  For information on the individual methods of each class, please see the source
//  file where the methods are implemented.
//



#if defined(DBG)
#define DEFAULT_STRING_SIZE 16
#else // defined(DBG)
#define DEFAULT_STRING_SIZE 256
#endif // defined(DBG)


//+--------------------------------------------------------------------------
//
//  Class: CMsiState
//
//  Synopsis: class that encapsulates an msi handle.  It ensures that
//      the handle is freed when instances of the class are destroyed.
//
//  Notes: this class is generally only needed by classes in this module --
//      it has no useful methods for classes outside this module
//
//---------------------------------------------------------------------------
class CMsiState
{
public:
    
    CMsiState();
    ~CMsiState();

    void
    SetState( MSIHANDLE pMsiHandle );

    MSIHANDLE
    GetState();

private:

    MSIHANDLE _MsiHandle;
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiValue
//
//  Synopsis: Class that encapsulates values that can be returned by
//      a record of an msi database.  It ensures that resources (e.g. memory)
//      associated with instances of the class are freed when the class is
//      destroyed. It also attempts to avoid heap allocation in favor of
//      stack allocation when possible -- this is abstracted from the consumer
//
//  Notes: This class is designed to be used as follows:
//      1. Declare an instance of this class on the stack
//      2. Pass a reference to the instance to a function which takes
//         a reference to this class as an out parameter.
//      3. The function that is called will "fill in" the value using
//         the Set methods of this class.
//      4. The caller may then use Get methods to retrieve the value
//         in a useful form (such as DWORD or WCHAR*).
//
//---------------------------------------------------------------------------
class CMsiValue
{
public:
    
    enum
    {
        TYPE_NOT_SET,
        TYPE_DWORD,
        TYPE_STRING
    };
        
    CMsiValue();
    ~CMsiValue();

    DWORD
    GetDWORDValue();

    WCHAR*
    GetStringValue(); 

    DWORD
    GetStringSize();

    WCHAR*
    DuplicateString();

    void
    SetDWORDValue( DWORD dwValue );
 
    LONG
    SetStringValue( WCHAR* wszValue );
        
    LONG
    SetStringSize( DWORD cchSize );        

    void
    SetType( DWORD dwType );

private:
    
    WCHAR  _wszDefaultBuf[DEFAULT_STRING_SIZE];

    DWORD  _dwDiscriminant;

    WCHAR* _wszValue;
    DWORD  _cchSize;

    DWORD  _dwValue;
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiRecord
//
//  Synopsis: Class that encapsulates msi database records.  It ensures
//      that any state (e.g. msi handle) associated with an instance of
//      this class will be freed when the instance is destroyed.
//
//  Notes: This class is designed to be used as follows:
//      1. Declare an instance of this class on the stack
//      2. Pass a reference to the instance to a function which takes
//         a reference to this class as an out parameter.
//      3. The function that is called will "fill in" the value using
//         the SetState method of this class.
//      4. The caller may then use the GetValue method to retrieve individual
//         values of the record, which in turn may be converted into
//         concrete data types (see the CMsiValue class).
//
//---------------------------------------------------------------------------
class CMsiRecord : public CMsiState
{
public:

    LONG        
    GetValue( 
	DWORD      dwType,
        DWORD      dwValue,
	CMsiValue* pMsiValue);
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiQuery
//
//  Synopsis: Class that encapsulates msi database queries.  It ensures
//      that any state (e.g. msi handle) associated with an instance of
//      this class will be freed when the instance is destroyed.
//
//  Notes: This class is designed to be used as follows:
//      1. Declare an instance of this class on the stack
//      2. Pass a reference to the instance to a function which takes
//         a reference to this class as an out parameter.
//      3. The function that is called will "fill in" the value using
//         the SetState method of this class.
//      4. The caller may then use the GetNextRecord method to retrieve a
//         record from the results of the query, or use the 
//         UpdateQueryFromFilter method to alter one of the records in
//         the query.
//
//---------------------------------------------------------------------------
class CMsiQuery : public CMsiState
{
public:

    LONG
    GetNextRecord( CMsiRecord* pMsiRecord );

    LONG
    UpdateQueryFromFilter( CMsiRecord* pFilterRecord );
};


//+--------------------------------------------------------------------------
//
//  Class: CMsiDatabase
//
//  Synopsis: Class that an msi database (package).  It ensures
//      that any state (e.g. msi handle) associated with an instance of
//      this class will be freed when the instance is destroyed.
//
//  Notes: This class is designed to be used as follows:
//  1. Create an instance of this class
//  2. Use the Open method to gain access to a package + set of transforms
//     as a database that can be queried
//  3. To create and retrieve results of a query on an opened database,
//     Use the GetQueryResults method
//  4. To create a query (but not retrieve its results), use the OpenQuery
//     method.  This is useful with when the query's UpdateQueryFromFilter
//     method is used to change an individual record, rather than retrieving
//     a result set (a la GetQueryResults).
//
//---------------------------------------------------------------------------
class CMsiDatabase : public CMsiState
{
public:

    LONG
    Open(
        WCHAR*  wszPath,
        DWORD   cTransforms,
        WCHAR** rgwszTransforms);

    LONG
    GetQueryResults(
        WCHAR*     wszQuery,
        CMsiQuery* pQuery );

    LONG
    OpenQuery(
        WCHAR*     wszQuery,
        CMsiQuery* pQuery);

    LONG
    TableExists( 
        WCHAR* wszTableName,
        BOOL*  pbTableExists );

};


#endif // __MSIBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\packages.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       packages.cpp
//
//  Contents:   Methods on CScopePane related to package deployment
//              and maintenence of the various index and cross-reference
//              structures.
//
//  Classes:
//
//  Functions:  CopyPackageDetail
//              FreePackageDetail
//              GetMsiProperty
//
//  History:    2-03-1998   stevebl   Created
//              3-25-1998   stevebl   Added GetMsiProperty
//              5-20-1998   RahulTh   - Added DetectUpgrades for automatic upgrade
//                                      detection
//                                    - Added GetCapitalizedExt
//
//---------------------------------------------------------------------------

// UNDONE - put in exception handling for low memory conditions

#include "precomp.hxx"

// uncomment this line to get the old behavior of putting up an upgrade
// dialog for auto-detected upgrades
//#define SHOWDETECTEDUPGRADEDIALOG

//IMalloc * g_pIMalloc = NULL;

BOOL IsNullGUID (GUID *pguid)
{

    return ( (pguid->Data1 == 0)    &&
             (pguid->Data2 == 0)    &&
             (pguid->Data3 == 0)    &&
             (pguid->Data4[0] == 0) &&
             (pguid->Data4[1] == 0) &&
             (pguid->Data4[2] == 0) &&
             (pguid->Data4[3] == 0) &&
             (pguid->Data4[4] == 0) &&
             (pguid->Data4[5] == 0) &&
             (pguid->Data4[6] == 0) &&
             (pguid->Data4[7] == 0) );
}

void FreePlatformInfo(PLATFORMINFO * &ppiOut)
{
    if (ppiOut)
    {
        OLESAFE_DELETE(ppiOut->prgPlatform);
        OLESAFE_DELETE(ppiOut->prgLocale);
        OLESAFE_DELETE(ppiOut);
    }
}

HRESULT CopyPlatformInfo(PLATFORMINFO * &ppiOut, PLATFORMINFO * & ppiIn)
{
    if (NULL == ppiIn)
    {
        ppiOut = NULL;
        return S_OK;
    }
    UINT n;
    ppiOut = (PLATFORMINFO *)OLEALLOC(sizeof(PLATFORMINFO));
    if (!ppiOut)
    {
        goto out_of_memory;
    }
    memcpy(ppiOut, ppiIn, sizeof(PLATFORMINFO));
    ppiOut->prgPlatform = NULL;
    ppiOut->prgLocale = NULL;
    n = ppiIn->cPlatforms;
    if (n)
    {
        ppiOut->prgPlatform = (CSPLATFORM*) OLEALLOC(sizeof(CSPLATFORM) * n);
        if (!ppiOut->prgPlatform)
        {
            goto out_of_memory;
        }

        memcpy(ppiOut->prgPlatform, ppiIn->prgPlatform, sizeof(CSPLATFORM) * n);
    }
    n = ppiIn->cLocales;
    if (n)
    {
        ppiOut->prgLocale = (LCID *) OLEALLOC(sizeof(LCID) * n);
        if (!ppiOut->prgLocale)
        {
            goto out_of_memory;
        }
        memcpy(ppiOut->prgLocale, ppiIn->prgLocale, sizeof(LCID) * n);
    }
    return S_OK;
out_of_memory:
    FreePlatformInfo(ppiOut);
    return E_OUTOFMEMORY;
}

void FreeActInfo(ACTIVATIONINFO * &paiOut)
{
    if (paiOut)
    {
        if (paiOut->pClasses)
        {
            UINT n = paiOut->cClasses;
            while (n--)
            {
                OLESAFE_DELETE(paiOut->pClasses[n].prgProgId);
            }
            OLESAFE_DELETE(paiOut->pClasses);
        }
        OLESAFE_DELETE(paiOut->prgInterfaceId);
        OLESAFE_DELETE(paiOut->prgPriority);
        if (paiOut->prgShellFileExt)
        {
            UINT n = paiOut->cShellFileExt;
            while (n--)
            {
                OLESAFE_DELETE(paiOut->prgShellFileExt[n])
            }
            OLESAFE_DELETE(paiOut->prgShellFileExt);
        }
        OLESAFE_DELETE(paiOut->prgTlbId);
        OLESAFE_DELETE(paiOut);
    }
}

HRESULT CopyActInfo(ACTIVATIONINFO * & paiOut, ACTIVATIONINFO * & paiIn)
{
    if (NULL == paiIn)
    {
        paiOut = NULL;
        return S_OK;
    }
    UINT n;
    paiOut = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
    if (!paiOut)
    {
        goto out_of_memory;
    }
    memcpy(paiOut, paiIn, sizeof(ACTIVATIONINFO));
    paiOut->prgInterfaceId = NULL;
    paiOut->prgPriority = NULL;
    paiOut->prgShellFileExt = NULL;
    paiOut->prgTlbId = NULL;
    paiOut->pClasses = NULL;
    n = paiIn->cClasses;

    paiOut->bHasClasses = paiIn->bHasClasses;

    if (n)
    {
        paiOut->pClasses = (CLASSDETAIL *) OLEALLOC(sizeof(CLASSDETAIL) * n);
        if (!paiOut->pClasses)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->pClasses, paiIn->pClasses, sizeof(CLASSDETAIL) * n);
        while (n--)
        {
            UINT n2 = paiIn->pClasses[n].cProgId;
            if (n2)
            {
                paiOut->pClasses[n].prgProgId = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n2);
                if (!paiOut->pClasses[n].prgProgId)
                {
                    goto out_of_memory;
                }
                while (n2--)
                {
                    OLESAFE_COPYSTRING(paiOut->pClasses[n].prgProgId[n2], paiIn->pClasses[n].prgProgId[n2]);
                }
            }
        }
    }
    n = paiIn->cShellFileExt;
    if (n)
    {
        paiOut->prgPriority = (UINT *) OLEALLOC(sizeof(UINT) * n);
        if (!paiOut->prgPriority)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->prgPriority, paiIn->prgPriority, sizeof(UINT) * n);
        paiOut->prgShellFileExt = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        if (!paiOut->prgShellFileExt)
        {
            goto out_of_memory;
        }
        while (n--)
        {
            OLESAFE_COPYSTRING(paiOut->prgShellFileExt[n], paiIn->prgShellFileExt[n]);
        }
    }
    n = paiIn->cInterfaces;
    if (n)
    {
        paiOut->prgInterfaceId = (IID *) OLEALLOC(sizeof(IID) * n);
        if (!paiOut->prgInterfaceId)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->prgInterfaceId, paiIn->prgInterfaceId, sizeof(IID) * n);
    }
    n = paiIn->cTypeLib;
    if (n)
    {
        paiOut->prgTlbId = (GUID *) OLEALLOC(sizeof(GUID) * n);
        if (!paiOut->prgTlbId)
        {
            goto out_of_memory;
        }
        memcpy(paiOut->prgTlbId, paiIn->prgTlbId, sizeof(GUID) * n);
    }
    return S_OK;
out_of_memory:
    FreeActInfo(paiOut);
    return E_OUTOFMEMORY;
}

void FreeInstallInfo(INSTALLINFO * &piiOut)
{
    if (piiOut)
    {
        if (piiOut->prgUpgradeInfoList)
        {
            UINT n = piiOut->cUpgrades;
            while (n--)
            {
                OLESAFE_DELETE(piiOut->prgUpgradeInfoList[n].szClassStore);
            }
            OLESAFE_DELETE(piiOut->prgUpgradeInfoList);
        }
        OLESAFE_DELETE(piiOut->pClsid);
        OLESAFE_DELETE(piiOut->pszScriptPath);
        OLESAFE_DELETE(piiOut->pszSetupCommand);
        OLESAFE_DELETE(piiOut->pszUrl);
        OLESAFE_DELETE(piiOut);
    }
}

HRESULT CopyInstallInfo(INSTALLINFO * & piiOut, INSTALLINFO * & piiIn)
{
    ULONG n;
    if (NULL == piiIn)
    {
        piiOut = NULL;
        return S_OK;
    }
    piiOut = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
    if (!piiOut)
    {
        goto out_of_memory;
    }
    memcpy(piiOut, piiIn, sizeof(INSTALLINFO));
    piiOut->pClsid = NULL;
    piiOut->prgUpgradeInfoList = NULL;
    piiOut->pszScriptPath = NULL;
    piiOut->pszSetupCommand = NULL;
    piiOut->pszUrl = NULL;
    OLESAFE_COPYSTRING(piiOut->pszScriptPath, piiIn->pszScriptPath);
    OLESAFE_COPYSTRING(piiOut->pszSetupCommand, piiIn->pszSetupCommand);
    OLESAFE_COPYSTRING(piiOut->pszUrl, piiIn->pszUrl);
    if (piiIn->pClsid)
    {
        piiOut->pClsid = (GUID *) OLEALLOC(sizeof(GUID));
        if (!piiOut->pClsid)
        {
            goto out_of_memory;
        }
        memcpy(piiOut->pClsid, piiIn->pClsid, sizeof(GUID));
    }
    n = piiIn->cUpgrades;
    if (n)
    {
        piiOut->prgUpgradeInfoList = (UPGRADEINFO *) OLEALLOC(sizeof(UPGRADEINFO) * n);
        if (!piiOut->prgUpgradeInfoList)
        {
            goto out_of_memory;
        }
        memcpy(piiOut->prgUpgradeInfoList, piiIn->prgUpgradeInfoList, sizeof(UPGRADEINFO) * n);
        while (n--)
        {
            OLESAFE_COPYSTRING(piiOut->prgUpgradeInfoList[n].szClassStore, piiIn->prgUpgradeInfoList[n].szClassStore);
        }
    }
    return S_OK;
out_of_memory:
    FreeInstallInfo(piiOut);
    return E_OUTOFMEMORY;
}

void InternalFreePackageDetail(PACKAGEDETAIL * &ppdOut)
{
    if (ppdOut)
    {
        FreeActInfo(ppdOut->pActInfo);
        FreePlatformInfo(ppdOut->pPlatformInfo);
        FreeInstallInfo(ppdOut->pInstallInfo);
        OLESAFE_DELETE(ppdOut->pszPackageName);
        OLESAFE_DELETE(ppdOut->pszPublisher);
        if (ppdOut->pszSourceList)
        {
            UINT n = ppdOut->cSources;
            while (n--)
            {
                OLESAFE_DELETE(ppdOut->pszSourceList[n]);
            }
            OLESAFE_DELETE(ppdOut->pszSourceList);
        }
        OLESAFE_DELETE(ppdOut->rpCategory);
    }
}

HRESULT CopyPackageDetail(PACKAGEDETAIL * & ppdOut, PACKAGEDETAIL * & ppdIn)
{
    ULONG n;
    if (NULL == ppdIn)
    {
        ppdOut = NULL;
        return S_OK;
    }
    ppdOut = new PACKAGEDETAIL;
    if (!ppdOut)
    {
        goto out_of_memory;
    }
    memcpy(ppdOut, ppdIn, sizeof(PACKAGEDETAIL));
    ppdOut->pActInfo = NULL;
    ppdOut->pInstallInfo = NULL;
    ppdOut->pPlatformInfo = NULL;
    ppdOut->pszPackageName = NULL;
    ppdOut->pszPublisher = NULL;
    ppdOut->pszSourceList = NULL;
    ppdOut->rpCategory = NULL;
    OLESAFE_COPYSTRING(ppdOut->pszPackageName, ppdIn->pszPackageName);
    n = ppdIn->cSources;
    if (n)
    {
        ppdOut->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        if (!ppdOut->pszSourceList)
        {
            goto out_of_memory;
        }
        while (n--)
        {
            OLESAFE_COPYSTRING(ppdOut->pszSourceList[n], ppdIn->pszSourceList[n]);
        }
    }
    n = ppdIn->cCategories;
    if (n)
    {
        ppdOut->rpCategory = (GUID *)OLEALLOC(sizeof(GUID) * n);
        if (!ppdOut->rpCategory)
        {
            goto out_of_memory;
        }
        memcpy(ppdOut->rpCategory, ppdIn->rpCategory, sizeof(GUID) * n);
    }
    if FAILED(CopyActInfo(ppdOut->pActInfo, ppdIn->pActInfo))
        goto out_of_memory;
    if FAILED(CopyPlatformInfo(ppdOut->pPlatformInfo, ppdIn->pPlatformInfo))
        goto out_of_memory;
    if FAILED(CopyInstallInfo(ppdOut->pInstallInfo, ppdIn->pInstallInfo))
        goto out_of_memory;
    return S_OK;
out_of_memory:
    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, E_OUTOFMEMORY);
    InternalFreePackageDetail(ppdOut);
    if (ppdOut)
        delete ppdOut;
    return E_OUTOFMEMORY;
}

void FreePackageDetail(PACKAGEDETAIL * & ppd)
{
    if (ppd)
    {
        ReleasePackageDetail(ppd);
        delete ppd;
        ppd = NULL;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetUniquePackageName
//
//  Synopsis:   Returns a unique package name.
//
//  Arguments:  [sz] - [in]  the name of the package
//                     [out] the new name, guaranteed unique on this cs
//
//  History:    1-23-1998   stevebl   Created
//
//  Notes:      First the input name is checked for uniqueness.  If it is
//              already unique it is returned unchanged.  If it is not
//              unique then a new name is formed by adding " (2)" to the end
//              of the string, then " (3)" and " (4)" and so on until a
//              unique name is found.
//
//              If you don't want a number appended to the name, nHint must
//              be 1.
//
//              The value passed back in nHint will be the seed for the
//              next try.
//
//---------------------------------------------------------------------------

void CScopePane::GetUniquePackageName(CString szRoot, CString &szOut, int &nHint)
{
    map<MMC_COOKIE, CAppData>::iterator i;
    set<CString> sNames;
    int cch = szRoot.GetLength();
    for (i=m_AppData.begin(); i != m_AppData.end(); i++)
    {
        // As an optimization, I'm only going to add names that might match
        // this one to the set.
        LPOLESTR szName = i->second.m_pDetails->pszPackageName;
        if ((0 == wcsncmp(szRoot, szName, cch)) && (i->second.m_fVisible))
            sNames.insert(szName);
    }
    szOut = szRoot;
    if (nHint++ == 1) // try the first name
    {
        if (sNames.end() == sNames.find(szOut))
            return;
    }
    // now check for a match
    do
    {
        szOut.Format(L"%s (%i)", (LPCTSTR)szRoot, nHint++);
        if (sNames.end() == sNames.find(szOut))
        {
            // we are unique
            return;
        }
        // try a different name
    } while (TRUE);
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePand::GetDeploymentType
//
//  Synopsis:
//
//  Arguments:  [szPackagePath] -
//              [lpFileTitle]   -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    6-29-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetDeploymentType(PACKAGEDETAIL * ppd, BOOL & fShowPropertySheet)
{
    INSTALLINFO * pii = ppd->pInstallInfo;
    if (m_ToolDefaults.fUseWizard)
    {
        CDeployApp dlgDeployApp;
        // Turn on theme'ing for the dialog by activating the theme context
        CThemeContextActivator themer;
        
        dlgDeployApp.m_fMachine = m_fMachine;
        dlgDeployApp.m_fCrappyZaw = pii->PathType == SetupNamePath;
        if (IDCANCEL == dlgDeployApp.DoModal())
        {
            return E_FAIL;
        }
        switch (dlgDeployApp.m_iDeployment)
        {
        default:
        case 0: //published
            pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            break;
        case 1: // assigned
            pii->dwActFlags = ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            break;
        case 3: // disabled
            pii->dwActFlags = 0;
            break;
        case 2: // custom
            if (m_fMachine)
            {
                pii->dwActFlags = ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            else
            {
                pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            fShowPropertySheet = TRUE;
        }
    }
    else
    {
        switch (m_ToolDefaults.NPBehavior)
        {
        default:
        case NP_PUBLISHED:
            if (!m_fMachine)
            {
                pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
                break;
            }
        case NP_ASSIGNED:
            if (pii->PathType != SetupNamePath)
            {
                pii->dwActFlags = ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            else
            {
                // Crappy ZAW app.. force it to be published.
                pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
            }
            break;
        case NP_DISABLED:
            pii->dwActFlags = 0;
            break;
        }
        if (m_ToolDefaults.fCustomDeployment)
        {
            fShowPropertySheet = TRUE;
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::DeployPackage
//
//  Synopsis:
//
//  Arguments:  [hr] -
//              [hr] -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    6-29-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CScopePane::DeployPackage(PACKAGEDETAIL * ppd, BOOL fShowPropertySheet)
{
    CHourglass hourglass;
    INSTALLINFO * pii = ppd->pInstallInfo;
    HRESULT hr = S_OK;
    hr = PrepareExtensions(*ppd);
    if (SUCCEEDED(hr))
    {
        DWORD dwRememberFlags;
        // put the entry in the class store
        if (fShowPropertySheet)
        {
            dwRememberFlags = pii->dwActFlags;
            pii->dwActFlags = 0; // disabled state
        }
        if (!m_pIClassAdmin)
        {
            hr = GetClassStore(TRUE);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_NOCLASSSTORE_ERROR, hr);
                DebugMsg((DM_WARNING, TEXT("GetClassStore failed with 0x%x"), hr));
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pIClassAdmin->AddPackage(ppd, &ppd->pInstallInfo->PackageGuid);
            if (FAILED(hr))
            {
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_ADDPACKAGE_ERROR, hr, ppd->pszPackageName);
                DebugMsg((DM_WARNING, TEXT("AddPackage failed with 0x%x"), hr));
            }
        }
        if (FAILED(hr))
        {
            return hr;
        }
        if (fShowPropertySheet)
        {
            pii->dwActFlags = dwRememberFlags; // restore state
        }
    }

    if (SUCCEEDED(hr))
    {
        CString szCSPath;
        hr = GetClassStoreName(szCSPath, FALSE);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
            return hr;
        }

        CAppData data;

        hr = CopyPackageDetail(data.m_pDetails, ppd);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CopyPackageDetail failed with 0x%x"), hr));
            return hr;
        }

        data.InitializeExtraInfo();

        m_lLastAllocated++;

        // make sure that m_lLastAllocated hasn't already been used
        while (m_AppData.end() != m_AppData.find(m_lLastAllocated))
        {
            m_lLastAllocated++;
        }

        data.m_fVisible = FALSE;
        m_AppData[m_lLastAllocated] = data;

        BOOL fAddOk = TRUE;

        // The admin has said he wants to do a "custom" deployment.
        if (fShowPropertySheet)
        {
            HRESULT hr;     // errors that happen while setting up
                            // the property sheets are NOT to be
                            // reported as deployment errors.

            MMC_COOKIE cookie = m_lLastAllocated;

            PROPSHEETHEADER psh;
            memset(&psh, 0, sizeof(psh));
            psh.dwSize = sizeof(psh);
            psh.dwFlags = PSH_NOAPPLYNOW | PSH_PROPTITLE;
            psh.pszCaption = m_AppData[m_lLastAllocated].m_pDetails->pszPackageName;
            int nPage = 0;
            HPROPSHEETPAGE rgPages[6];
            psh.phpage = rgPages;

            //
            // Create the Product property page
            //
            CProduct prpProduct;
            prpProduct.m_fPreDeploy = TRUE;
            prpProduct.m_pData = &m_AppData[m_lLastAllocated];
            prpProduct.m_cookie = cookie;
            prpProduct.m_pScopePane = this;
            prpProduct.m_pAppData = &m_AppData;
            prpProduct.m_pIGPEInformation = m_pIGPEInformation;
            prpProduct.m_fMachine = m_fMachine;
            prpProduct.m_fRSOP = m_fRSOP;
            // no longer need to marshal this interface, just set it

            prpProduct.m_pIClassAdmin = m_pIClassAdmin;
            m_pIClassAdmin->AddRef();

            rgPages[nPage++] = CreateThemedPropertySheetPage(&prpProduct.m_psp);

            //
            // Create the Depeployment property page
            //
            CDeploy prpDeploy;
            prpDeploy.m_fPreDeploy = TRUE;
            prpDeploy.m_pData = &m_AppData[m_lLastAllocated];
            prpDeploy.m_cookie = cookie;
            prpDeploy.m_fMachine = m_fMachine;
            prpDeploy.m_fRSOP = m_fRSOP;
            prpDeploy.m_pScopePane = this;
#if 0
            prpDeploy.m_pIGPEInformation = m_pIGPEInformation;
#endif

            // no longer need to marshal this interface, just set it
            prpDeploy.m_pIClassAdmin = m_pIClassAdmin;
            m_pIClassAdmin->AddRef();

            rgPages[nPage++] = CreateThemedPropertySheetPage(&prpDeploy.m_psp);

            CUpgradeList prpUpgradeList;
            if (pii->PathType != SetupNamePath)
            {
                //
                // Create the upgrades property page
                //
                prpUpgradeList.m_pData = &m_AppData[m_lLastAllocated];
                prpUpgradeList.m_cookie = cookie;
                prpUpgradeList.m_pScopePane = this;
                prpUpgradeList.m_fPreDeploy = TRUE;
                prpUpgradeList.m_fMachine = m_fMachine;
                prpUpgradeList.m_fRSOP = m_fRSOP;
#if 0
                prpUpgradeList.m_pIGPEInformation = m_pIGPEInformation;
#endif

                // no longer need to marshal the interface, just set it
                prpUpgradeList.m_pIClassAdmin = m_pIClassAdmin;
                m_pIClassAdmin->AddRef();

                rgPages[nPage++] = CreateThemedPropertySheetPage(&prpUpgradeList.m_psp);
            }

            //
            // make sure we have an up-to-date categories list
            //
            ClearCategories();
            hr = CsGetAppCategories(&m_CatList);
            if (FAILED(hr))
            {
                // report it
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GETCATEGORIES_ERROR, hr, NULL);

                // Since failure only means the categories list will be
                // empty, we'll proceed as if nothing happened.

                hr = S_OK;
            }

            //
            // Create the Category property page
            //
            CCategory prpCategory;
            prpCategory.m_pData = &m_AppData[m_lLastAllocated];
            prpCategory.m_cookie = cookie;
            prpCategory.m_pCatList = &m_CatList;
            prpCategory.m_fRSOP = m_fRSOP;
            prpCategory.m_fPreDeploy = TRUE;

            // no longer need to marshal this interface, just set it
            prpCategory.m_pIClassAdmin = m_pIClassAdmin;
            m_pIClassAdmin->AddRef();

            rgPages[nPage++] = CreateThemedPropertySheetPage(&prpCategory.m_psp);

            CXforms prpXforms;
            if (pii->PathType != SetupNamePath)
            {
                //
                // Create the Xforms property page
                //
                prpXforms.m_fPreDeploy = TRUE;
                prpXforms.m_pData = &m_AppData[m_lLastAllocated];
                prpXforms.m_cookie = cookie;
                prpXforms.m_pScopePane = this;

                // no longer need to marshal the interface, just set it
                prpXforms.m_pIClassAdmin = m_pIClassAdmin;
                m_pIClassAdmin->AddRef();

                rgPages[nPage++] = CreateThemedPropertySheetPage(&prpXforms.m_psp);
            }

            //
            // Create the security property page
            //

            CString szPath;
            hr = GetPackageDSPath(szPath, m_AppData[m_lLastAllocated].m_pDetails->pszPackageName);
            if (SUCCEEDED(hr))
            {
                LPSECURITYINFO pSI;
                hr = DSCreateISecurityInfoObject(szPath,
                                                 NULL,
                                                 0,
                                                 &pSI,
                                                 NULL,
                                                 NULL,
                                                 0);
                if (SUCCEEDED(hr))
                {
                    rgPages[nPage++] = CreateSecurityPage(pSI);
                    pSI->Release();
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("DSCreateISecurityInfoObject failed with 0x%x"), hr));
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("GetPackageDSPath failed with 0x%x"), hr));
            }
            psh.nPages = nPage;
            psh.hwndParent = m_hwndMainWindow;

            if (IDOK != PropertySheet(&psh))
            {
                fAddOk = FALSE;
                RemovePackage(cookie, FALSE, TRUE);
            }
            else
            {
                // Make sure that the package is deployed with the proper
                // deployment type
                hr = m_pIClassAdmin->ChangePackageProperties(m_AppData[m_lLastAllocated].m_pDetails->pszPackageName,
                                                             NULL,
                                                             &m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->dwActFlags,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL);
                if (SUCCEEDED(hr))
                {
                    if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                                      m_fMachine ? &guidMachSnapin
                                                                 : &guidUserSnapin )))
                    {
                        ReportPolicyChangedError(m_hwndMainWindow);
                    }
                }

            }
        }

        if (fAddOk)
        {
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                RESULTDATAITEM resultItem;
                memset(&resultItem, 0, sizeof(resultItem));

                if ((*i)->_fVisible)
                {
                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = m_AppData[m_lLastAllocated].GetImageIndex(this);
                    resultItem.lParam = m_lLastAllocated;
                    hr = (*i)->m_pResult->InsertItem(&resultItem);
                }

                // The following code must be excecuted wheather the InsertItem
                // call succeeds or not.
                // There are legitimate cases when InsertItem will fail.  For
                // instance, if the scope pane is being shown, but not the
                // result pane.

                m_AppData[m_lLastAllocated].m_fVisible = TRUE;
                m_AppData[m_lLastAllocated].m_itemID = resultItem.itemID;
                InsertExtensionEntry(m_lLastAllocated, m_AppData[m_lLastAllocated]);
                if (m_pFileExt)
                {
                    m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                }
                InsertUpgradeEntry(m_lLastAllocated, m_AppData[m_lLastAllocated]);
                m_UpgradeIndex[GetUpgradeIndex(m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->PackageGuid)] = m_lLastAllocated;
                // if this is an upgrade, set icons for upgraded apps to
                // the proper icon and refresh any open property sheets
                UINT n = m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->cUpgrades;
                while (n--)
                {
                    map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(m_AppData[m_lLastAllocated].m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid));
                    if (i != m_UpgradeIndex.end())
                    {
                        if (m_AppData[i->second].m_pUpgradeList)
                        {
                            m_AppData[i->second].m_pUpgradeList->SendMessage(WM_USER_REFRESH, 0, 0);
                        }
                    }
                }


                if ((*i)->_fVisible)
                {
                    if (SUCCEEDED(hr))
                    {
                        (*i)->m_pResult->SetItem(&resultItem);
                        (*i)->m_pResult->Sort((*i)->m_nSortColumn, (*i)->m_dwSortOptions, -1);
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("InsertItem failed with 0x%x"), hr));
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::AddZAPPackage
//
//  Synopsis:
//
//  Arguments:  [szPackagePath] -
//              [lpFileTitle]   -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    6-29-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CScopePane::AddZAPPackage(LPCOLESTR szPackagePath, LPCOLESTR lpFileTitle)
{
    CHourglass hourglass;
    HRESULT hr = E_FAIL;

    OLECHAR szBuffer[1024];
    OLECHAR * sz = szBuffer;
    CString szFriendlyName;
    CString szUniqueFriendlyName;
    int nHint = 1;
    DWORD dw = GetPrivateProfileString(
                    L"Application",
                    L"FriendlyName",
                    NULL,
                    sz,
                    sizeof(szBuffer) / sizeof(szBuffer[0]),
                    szPackagePath);
    if (0 == dw)
    {
        // either bogus FriendlyName or no setup command, both of which are fatal
        goto bad_script;
    }
    szFriendlyName = sz;    // save this for later

    dw = GetPrivateProfileString(
                    L"Application",
                    L"SetupCommand",
                    NULL,
                    sz,
                    sizeof(szBuffer) / sizeof(szBuffer[0]),
                    szPackagePath);
    if (0 == dw)
    {
        // either bogus file or no setup command, both of which are fatal
bad_script:
        {
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADZAP_ERROR, HRESULT_FROM_WIN32(dw), lpFileTitle);
            TCHAR szBuffer[256];
            ::LoadString(ghInstance, IDS_ADDFAILED_ZAP, szBuffer, 256);
            m_pConsole->MessageBox(szBuffer,
                                   lpFileTitle,
                                   MB_OK | MB_ICONEXCLAMATION, NULL);
        }
        return E_FAIL;
    }
    INSTALLINFO * pii = NULL;
    PLATFORMINFO * ppi = NULL;
    ACTIVATIONINFO * pai = NULL;
    PACKAGEDETAIL  *ppd = new PACKAGEDETAIL;
    if (!ppd)
    {
        goto out_of_memory;
    }
    memset(ppd, 0, sizeof(PACKAGEDETAIL));
    pii = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
    ppd->pInstallInfo = pii;
    if (!pii)
    {
        goto out_of_memory;
    }
    memset(pii, 0, sizeof(INSTALLINFO));
    ppi = (PLATFORMINFO *) OLEALLOC(sizeof(PLATFORMINFO));
    ppd->pPlatformInfo = ppi;
    if (!ppi)
    {
        goto out_of_memory;
    }
    memset(ppi, 0, sizeof(PLATFORMINFO));
    pai = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
    ppd->pActInfo = pai;
    if (!pai)
    {
        goto out_of_memory;
    }
    else
    {
        memset(pai, 0, sizeof(ACTIVATIONINFO));

        pai->bHasClasses = ! m_ToolDefaults.fExtensionsOnly;

        // Munge the setup path.
        // surround the path in quotes to be sure that spaces are dealt
        // with properly
        CString szPath = L'"';
        szPath += szPackagePath;
        // strip off the package name
        int ich = szPath.ReverseFind(L'\\');
        // check for either slash symbol (just in case)
        int ich2 = szPath.ReverseFind(L'/');
        if (ich2 > ich)
        {
            ich = ich2;
        }
        if (ich >= 0)
        {
            szPath = szPath.Left(ich + 1); // keep the path separator
        }

        // merge it with the setup command string
        BOOL fNeedQuote = TRUE;
        if (sz[0] == L'"')
        {
            // remember that we had a leading quote (no need to insert a quote)
            // and strip it off
            sz++;
            fNeedQuote = FALSE;
        }
        while (sz[0])
        {
            if (sz[0] == L'.' && sz[1] == L'.' && (sz[2] == L'/' || sz[2] == L'\\'))
            {
                // strip off the last path element
                // First strip off the path separator (the one we kept previously)
                szPath = szPath.Left(ich);
                // now find the symbol
                ich = szPath.ReverseFind(L'\\');
                // check for either slash symbol (just in case)
                ich2 = szPath.ReverseFind(L'/');
                if (ich2 > ich)
                {
                    ich = ich2;
                }
                if (ich >= 0)
                {
                    szPath = szPath.Left(ich + 1); // keep the path separator
                }
                // skip the "..\"
                sz += 3;
            }
            else
            {
                if ((0 != sz[0] && L':' == sz[1])
                    ||
                    ((L'\\' == sz[0] || L'/' == sz[0]) && (L'\\' == sz[1] || L'/' == sz[1]))
                    ||
                    (0 == wcsncmp(L"http:",sz,5)))
                {
                    // hard path
                    // throw away szPath;
                    szPath = L"";
                    if (!fNeedQuote)
                    {
                        // make sure we don't drop that quote
                        szPath += L'"';
                    }
                    // and make sure we don't insert quotes where they're not wanted
                    fNeedQuote = FALSE;
                }
                // break the loop on anything other than "..\"
                break;
            }
        }

        if (fNeedQuote)
        {
            CString szTemp = sz;
            // copy everything up to the first space
            ich = szTemp.Find(L' ');
            szPath += szTemp.Left(ich);
            // then add a quote
            szPath += L'"';
            szPath += szTemp.Mid(ich);
        }
        else
        {
            szPath += sz;
        }

        OLESAFE_COPYSTRING(pii->pszScriptPath, szPath);

        sz = szBuffer;
        dw = GetPrivateProfileString(
                        L"Application",
                        L"DisplayVersion",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            // parse product version
            CString sz = szBuffer;
            sz.TrimLeft();
            CString szTemp = sz.SpanIncluding(L"0123456789");
            swscanf(szTemp, L"%u", &pii->dwVersionHi);
            sz = sz.Mid(szTemp.GetLength());
            szTemp = sz.SpanExcluding(L"0123456789");
            sz = sz.Mid(szTemp.GetLength());
            swscanf(sz, L"%u", &pii->dwVersionLo);
        }

        dw = GetPrivateProfileString(
                        L"Application",
                        L"Publisher",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            OLESAFE_COPYSTRING(ppd->pszPublisher, sz);
        }

        dw = GetPrivateProfileString(
                        L"Application",
                        L"URL",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            OLESAFE_COPYSTRING(pii->pszUrl, sz);
        }

        set<DWORD> sPlatforms;
        dw = GetPrivateProfileString(
                        L"Application",
                        L"Architecture",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);

        BOOL fValidPlatform;

        fValidPlatform = FALSE;

        if (dw)
        {
            CString szPlatforms = szBuffer;
            CString szTemp;
            while (szPlatforms.GetLength())
            {
                szTemp = szPlatforms.SpanExcluding(L",");
                if (0 == szTemp.CompareNoCase(L"intel"))
                {
                    sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
                    fValidPlatform = TRUE;
                }
                else if (0 == szTemp.CompareNoCase(L"intel64"))
                {
                    sPlatforms.insert(PROCESSOR_ARCHITECTURE_IA64);
                    fValidPlatform = TRUE;
                }
                szPlatforms = szPlatforms.Mid(szTemp.GetLength()+1);
            }
        }

        //
        // Ensure that if we saw any platforms, at least one of them
        // was a supported platform
        //
        if ( dw && ! fValidPlatform )
        {
            TCHAR szBuffer[256];
            ::LoadString(ghInstance, IDS_ILLEGAL_PLATFORM, szBuffer, 256);
            m_pConsole->MessageBox(szBuffer,
                                   lpFileTitle,
                                   MB_OK | MB_ICONEXCLAMATION, NULL);

            delete ppd;

            return E_FAIL;
        }

        if (0 == sPlatforms.size())
        {
            // If the ZAP file doesn't specify an architecture
            // then we'll treat is as an x86 package
            sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
            DebugMsg((DL_VERBOSE, TEXT("No platform detected, assuming x86.")));
        }
        ppi->cPlatforms = sPlatforms.size();
        ppi->prgPlatform = (CSPLATFORM *) OLEALLOC(sizeof(CSPLATFORM) * (ppi->cPlatforms));;
        if (!ppi->prgPlatform)
        {
            ppi->cPlatforms = 0;
            goto out_of_memory;
        }
        set<DWORD>::iterator iPlatform;
        INT n = 0;
        for (iPlatform = sPlatforms.begin(); iPlatform != sPlatforms.end(); iPlatform++, n++)
        {
            ppi->prgPlatform[n].dwPlatformId = VER_PLATFORM_WIN32_NT;
            ppi->prgPlatform[n].dwVersionHi = 5;
            ppi->prgPlatform[n].dwVersionLo = 0;
            ppi->prgPlatform[n].dwProcessorArch = *iPlatform;
        }


        ppi->prgLocale = (LCID *) OLEALLOC(sizeof(LCID));
        if (!ppi->prgLocale)
        {
            goto out_of_memory;
        }
        ppi->cLocales = 1;
        ppi->prgLocale[0] = 0; // if none is supplied we assume language neutral

        dw = GetPrivateProfileString(
                        L"Application",
                        L"LCID",
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            swscanf(szBuffer, L"%i", &ppi->prgLocale[0]);
            // we only deploy one LCID (the primary one)
        }

        // Get the list of extensions
        dw = GetPrivateProfileString(
                        L"ext",
                        NULL,
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            vector<CString> v;
            TCHAR szName[256];
            while (sz < &szBuffer[dw])
            {
                while ('.' == sz[0])
                    sz++;
                CString szExt = ".";
                szExt += sz;
                v.push_back(szExt);
                sz += (wcslen(sz) + 1);
            }
            // build the new list
            UINT n = v.size();
            if (n > 0)
            {
                pai->prgShellFileExt = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
                if (!pai->prgShellFileExt)
                {
                    goto out_of_memory;
                }
                pai->prgPriority = (UINT *) OLEALLOC(sizeof(UINT) * n);
                if (!pai->prgPriority)
                {
                    goto out_of_memory;
                }
                pai->cShellFileExt = n;
                while (n--)
                {
                    CString &sz = v[n];
                    sz.MakeLower();
                    OLESAFE_COPYSTRING(pai->prgShellFileExt[n], sz);
                    pai->prgPriority[n] = 0;
                }
            }
        }

        // get the list of CLSIDs
        vector<CLASSDETAIL> v;
        sz = szBuffer;
        dw = GetPrivateProfileString(
                        L"CLSIDs",
                        NULL,
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            while (sz < &szBuffer[dw])
            {
                OLECHAR szType[256];
                DWORD dwSubKey = GetPrivateProfileString(
                        L"CLSIDs",
                        sz,
                        NULL,
                        szType,
                        sizeof(szType) / sizeof(szType[0]),
                        szPackagePath);
                CLASSDETAIL cd;
                memset(&cd, 0, sizeof(CLASSDETAIL));
                hr = CLSIDFromString(sz, &cd.Clsid);
                if (SUCCEEDED(hr))
                {
                    CString szTypes = szType;
                    szTypes.MakeLower();
                    if (szTypes.Find(L"inprocserver32") >= 0)
                    {
                        cd.dwComClassContext |= CLSCTX_INPROC_SERVER;
                    }
                    if (szTypes.Find(L"localserver32") >= 0)
                    {
                        cd.dwComClassContext |= CLSCTX_LOCAL_SERVER;
                    }
                    if (szTypes.Find(L"inprochandler32") >= 0)
                    {
                        cd.dwComClassContext |= CLSCTX_INPROC_HANDLER;
                    }
                    v.push_back(cd);
                }
                sz += (wcslen(sz) + 1);
            }
        }

        // get the list of ProgIDs
        sz = szBuffer;
        dw = GetPrivateProfileString(
                        L"ProgIDs",
                        NULL,
                        NULL,
                        sz,
                        sizeof(szBuffer) / sizeof(szBuffer[0]),
                        szPackagePath);
        if (dw)
        {
            while (sz < &szBuffer[dw])
            {
                OLECHAR szType[256];
                DWORD dwSubKey = GetPrivateProfileString(
                        L"ProgIDs",
                        sz,
                        NULL,
                        szType,
                        sizeof(szType) / sizeof(szType[0]),
                        szPackagePath);
                CLSID cid;
                hr = CLSIDFromString(sz, &cid);
                if (SUCCEEDED(hr))
                {
                    // Match it to its CLASSDETAIL structure and insert it into the
                    // ProgID list.
                    // (fat and slow method)
                    vector<CLASSDETAIL>::iterator i;
                    for (i = v.begin(); i != v.end(); i++)
                    {
                        if (0 == memcmp(&i->Clsid, &cid, sizeof(CLSID)))
                        {
                            // found a match
                            // hereiam
                            vector <CString> vIds;
                            CString szAppIds = szType;
                            CString szTemp;
                            while (szAppIds.GetLength())
                            {
                                szTemp = szAppIds.SpanExcluding(L",");
                                szTemp.TrimLeft();
                                vIds.push_back(szTemp);
                                szAppIds = szAppIds.Mid(szTemp.GetLength()+1);
                            }
                            while (i->cProgId--)
                            {
                                OLESAFE_DELETE(i->prgProgId[i->cProgId]);
                            }
                            OLESAFE_DELETE(i->prgProgId);
                            DWORD cProgId = vIds.size();
                            LPOLESTR * prgProgId = (LPOLESTR *)
                                OLEALLOC(sizeof(LPOLESTR) * (cProgId));
                            if (!prgProgId)
                            {
                                goto out_of_memory;
                            }
                            i->cProgId = cProgId;
                            while (cProgId--)
                            {
                                OLESAFE_COPYSTRING(prgProgId[cProgId], vIds[cProgId]);
                            }
                            i->prgProgId = prgProgId;
                        }
                    }
                }
                sz += (wcslen(sz) + 1);
            }
        }

        // create the list of CLASSDETAIL structures
        {
            UINT n = v.size();
            if (n > 0)
            {
                pai->pClasses = (CLASSDETAIL *) OLEALLOC(sizeof(CLASSDETAIL) * n);
                if (!pai->pClasses)
                {
                    goto out_of_memory;
                }
                pai->cClasses = n;
                while (n--)
                {
                    pai->pClasses[n] = v[n];
                }
            }
        }

        ppd->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR));
        if (!ppd->pszSourceList)
        {
            goto out_of_memory;
        }
        ppd->cSources = 1;
        OLESAFE_COPYSTRING(ppd->pszSourceList[0], szPackagePath);

        GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
        OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);

        // Popup UI
        pii->PathType = SetupNamePath;

        BOOL fShowPropertyPage = FALSE;

        hr = GetDeploymentType(ppd, fShowPropertyPage);

        if (SUCCEEDED(hr))
        {
            CHourglass hourglass;
            if (m_ToolDefaults.fZapOn64)
            {
                pii->dwActFlags |= ACTFLG_ExcludeX86OnIA64; // same as ACTFLG_ZAP_IncludeX86OfIA64
            }
            do
            {
                hr = DeployPackage(ppd, fShowPropertyPage);
                if (hr == CS_E_OBJECT_ALREADY_EXISTS)
                {
                    OLESAFE_DELETE(ppd->pszPackageName);
                    GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
                    OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);
                }
            } while (hr == CS_E_OBJECT_ALREADY_EXISTS);
        }

        if (FAILED(hr) && hr != E_FAIL) // don't report E_FAIL error
                                        // because it's a benign error
                                        // (probably a dialog cancellation)
        {
            // report the error in the event log
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_DEPLOYMENT_ERROR, hr, lpFileTitle);

            // now try to come up with a meaningful message for the user

            TCHAR szBuffer[256];
            if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
            {
                // access permission failure
                ::LoadString(ghInstance, IDS_ADDFAILED_ACCESS_DENIED, szBuffer, 256);
            }
            else
            {
                switch (hr)
                {
                // For these errors, we'll report the party line:
                case CS_E_CLASS_NOTFOUND:
                case CS_E_INVALID_VERSION:
                case CS_E_NO_CLASSSTORE:
                case CS_E_OBJECT_NOTFOUND:
                case CS_E_OBJECT_ALREADY_EXISTS:
                case CS_E_INVALID_PATH:
                case CS_E_NETWORK_ERROR:
                case CS_E_ADMIN_LIMIT_EXCEEDED:
                case CS_E_SCHEMA_MISMATCH:
                case CS_E_PACKAGE_NOTFOUND:
                case CS_E_INTERNAL_ERROR:
                    {
                        DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                                 NULL,
                                                 hr,
                                                 0,
                                                 szBuffer,
                                                 sizeof(szBuffer) / sizeof(szBuffer[0]),
                                                 NULL);
                        if (0 != dw)
                        {
                            // got a valid message string
                            break;
                        }
                        // otherwise fall through and give the generic message
                    }
                // Either these CS errors don't apply or an admin
                // wouldn't know what they mean:
                case CS_E_NOT_DELETABLE:
                default:
                    // generic class store problem
                    ::LoadString(ghInstance, IDS_ADDFAILED_CSFAILURE, szBuffer, 256);
                    break;
                }
            }
    #if DBG
            TCHAR szDebugBuffer[256];
            DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                     NULL,
                                     hr,
                                     0,
                                     szDebugBuffer,
                                     sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                     NULL);
            if (0 == dw)
            {
                wsprintf(szDebugBuffer, TEXT("(HRESULT: 0x%lX)"), hr);
            }
            wcscat(szBuffer, szDebugBuffer);
    #endif
            m_pConsole->MessageBox(szBuffer,
                               lpFileTitle,
                               MB_OK | MB_ICONEXCLAMATION, NULL);
        }
        FreePackageDetail(ppd);
    }

    return hr;
out_of_memory:
    if (ppd)
    {
        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, E_OUTOFMEMORY);
        InternalFreePackageDetail(ppd);
        delete ppd;
    }
    return E_OUTOFMEMORY;
}


//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::AddMSIPackage
//
//  Synopsis:   Add's one or more packages to the class store and adds the
//              appropriate entries to the result pane.
//
//  Arguments:  [szPackagePath] - Full path to the Darwin package.
//              [lpFileTitle]   - file title from the open file dialog (used
//                                 for UI)
//
//  Returns:    S_OK    - succeeded
//              E_FAIL  - benign failure (probably a cancellation or something)
//              other   - significant failure
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::AddMSIPackage(LPCOLESTR szPackagePath, LPCOLESTR lpFileTitle)
{
    CHourglass hourglass;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = E_FAIL;
    BOOL fPreparationDone = FALSE;  // Used to identify if the routine has
                                    // progressed passed the "prep" stage
                                    // and is now in the deployment stage.
                                    // Errors in the earlier part are most
                                    // likely due to Darwin problems.
                                    // Errors in teh latter part are most
                                    // likely due to Class Store problems.
    set<LCID> sLocales;
    CUpgrades dlgUpgrade;
    int nLocales;
    set<LCID>::iterator iLocale;
    PACKAGEDETAIL  *ppd = NULL;
    CString szFriendlyName;
    CString szUniqueFriendlyName;
    int nHint = 1;

    ASSERT(m_pConsole);
    {
        BOOL fShowPropertySheet = FALSE;
        GUID guid;
        INSTALLINFO *pii = NULL;
        PLATFORMINFO *ppi = NULL;
        ACTIVATIONINFO *pai = NULL;
        ppd = new PACKAGEDETAIL;
        if (!ppd)
        {
            goto out_of_memory;
        }
        memset(ppd, 0, sizeof(PACKAGEDETAIL));
        pii = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
        if (!pii)
        {
            goto out_of_memory;
        }
        memset(pii, 0, sizeof(INSTALLINFO));
        ppi = (PLATFORMINFO *) OLEALLOC(sizeof(PLATFORMINFO));
        ppd->pPlatformInfo = ppi;
        if (!ppi)
        {
            goto out_of_memory;
        }
        ppd->pInstallInfo = pii;
        memset(ppi, 0, sizeof(PLATFORMINFO));
        pai = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
        ppd->pActInfo = pai;
        if (!pai)
        {
            goto out_of_memory;
        }
        else
        {
            memset(pai, 0, sizeof(ACTIVATIONINFO));

            pai->bHasClasses = ! m_ToolDefaults.fExtensionsOnly;

            pii->PathType = DrwFilePath;

            hr = GetDeploymentType(ppd, fShowPropertySheet);
            CHourglass hourglass;
            if (FAILED(hr))
            {
                goto done;
            }
            if (!m_ToolDefaults.f32On64)
            {
                pii->dwActFlags |= ACTFLG_ExcludeX86OnIA64; // same as ACTFLG_ZAP_IncludeX86OfIA64
            }
            if (m_ToolDefaults.fUninstallOnPolicyRemoval)
            {
                pii->dwActFlags |= ACTFLG_UninstallOnPolicyRemoval;
            }
            else
            {
                pii->dwActFlags |= ACTFLG_OrphanOnPolicyRemoval;
            }
            if (m_fMachine)
            {
                pii->dwActFlags |= ACTFLG_ForceUpgrade;
            }
            pii->InstallUiLevel = m_ToolDefaults.UILevel;

            // disable MSI ui
            MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

            // Use MsiSummaryInfoGetProperty to get platform and locale info.
            {
                MSIHANDLE hSummaryInfo;
                UINT msiReturn = MsiGetSummaryInformation(0, szPackagePath, 0, &hSummaryInfo);
                if (ERROR_SUCCESS == msiReturn)
                {
                    TCHAR szBuffer[256];
                    DWORD dwSize = 256;
                    msiReturn = MsiSummaryInfoGetProperty(hSummaryInfo,
                                                          7, // PID_TEMPLATE
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          szBuffer,
                                                          &dwSize);
                    if (ERROR_SUCCESS == msiReturn)
                    {
                        // break out the locale and platform properties
                        CString szLocales = szBuffer;
                        CString szPlatforms = szLocales.SpanExcluding(L";");
                        szLocales = szLocales.Mid(szPlatforms.GetLength()+1);
                        CString szTemp;
                        set<DWORD> sPlatforms;
                        BOOL       fValidPlatform;
                        BOOL       fPlatformsSpecified;

                        fValidPlatform = FALSE;

                        fPlatformsSpecified = 0 != szPlatforms.GetLength();

                        while (szPlatforms.GetLength())
                        {
                            szTemp = szPlatforms.SpanExcluding(L",");
                            if (0 == szTemp.CompareNoCase(L"intel"))
                            {
                                sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
                                fValidPlatform = TRUE;
                            }
                            else if (0 == szTemp.CompareNoCase(L"intel64"))
                            {
                                sPlatforms.insert(PROCESSOR_ARCHITECTURE_IA64);
                                fValidPlatform = TRUE;
                            }
                            szPlatforms = szPlatforms.Mid(szTemp.GetLength()+1);
                        }

                        //
                        // If platforms have been specified, at least one of them
                        // must be valid
                        //
                        if ( fPlatformsSpecified && ! fValidPlatform )
                        {
                            hr = HRESULT_FROM_WIN32( ERROR_INSTALL_PLATFORM_UNSUPPORTED );
                            ppi->cPlatforms = 0;
                            goto done;
                        }

                        while (szLocales.GetLength())
                        {
                            szTemp = szLocales.SpanExcluding(L",");
                            LCID lcid;
                            swscanf(szTemp, L"%i", &lcid);
                            sLocales.insert(lcid);
                            szLocales = szLocales.Mid(szTemp.GetLength()+1);
                        }
                        if (0 == sPlatforms.size())
                        {
                            // If the MSI file doesn't specify an architecture
                            // then we'll mark it X86-allow on IA64.
                            sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
                            pii->dwActFlags &= ~ACTFLG_ExcludeX86OnIA64;
                            DebugMsg((DL_VERBOSE, TEXT("No platform detected, setting to X86 - allow on IA64.")));
                        }
                        if (0 == sLocales.size())
                        {
                            // If the MSI file doesn't specify a locale then
                            // we'll just assume it's language neutral.
                            DebugMsg((DL_VERBOSE, TEXT("No locale detected, assuming neutral.")));
                            sLocales.insert(0);
                        }
                        ppi->cPlatforms = sPlatforms.size();
                        ppi->prgPlatform = (CSPLATFORM *) OLEALLOC(sizeof(CSPLATFORM) * (ppi->cPlatforms));;
                        if (!ppi->prgPlatform)
                        {
                            ppi->cPlatforms = 0;
                            goto out_of_memory;
                        }
                        set<DWORD>::iterator iPlatform;
                        INT n = 0;
                        for (iPlatform = sPlatforms.begin(); iPlatform != sPlatforms.end(); iPlatform++, n++)
                        {
                            ppi->prgPlatform[n].dwPlatformId = VER_PLATFORM_WIN32_NT;
                            ppi->prgPlatform[n].dwVersionHi = 5;
                            ppi->prgPlatform[n].dwVersionLo = 0;
                            ppi->prgPlatform[n].dwProcessorArch = *iPlatform;
                        }
                    }
                    MsiCloseHandle(hSummaryInfo);
                }
                if (ERROR_SUCCESS != msiReturn)
                {
                    hr =  HRESULT_FROM_WIN32(msiReturn);
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                    goto done;
                }
            }
            {
                // Grovel through the database to get additional information
                // that for some reason MSI won't give us any other way.
                TCHAR szBuffer[256];
                DWORD cch = 256;
                UINT msiReturn = GetMsiProperty(szPackagePath, L"ProductVersion", szBuffer, &cch);
                if (ERROR_SUCCESS != msiReturn)
                {
                    hr =  HRESULT_FROM_WIN32(msiReturn);
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                    goto done;
                }
                if (ERROR_SUCCESS == msiReturn)
                {
                    // Parse Product Version
                    CString sz = szBuffer;
                    sz.TrimLeft();
                    CString szTemp = sz.SpanIncluding(L"0123456789");
                    swscanf(szTemp, L"%u", &pii->dwVersionHi);
                    sz = sz.Mid(szTemp.GetLength());
                    szTemp = sz.SpanExcluding(L"0123456789");
                    sz = sz.Mid(szTemp.GetLength());
                    swscanf(sz, L"%u", &pii->dwVersionLo);
                }
                cch = 256;
                msiReturn = GetMsiProperty(szPackagePath, L"ProductCode", szBuffer, &cch);
                if (ERROR_SUCCESS != msiReturn)
                {
                    hr =  HRESULT_FROM_WIN32(msiReturn);
                    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, lpFileTitle);
                    goto done;
                }
                if (ERROR_SUCCESS == msiReturn)
                {
                    // Parse Product Code
                    CLSIDFromString(szBuffer, &pii->ProductCode);
                }
                cch = 256;
                msiReturn = GetMsiProperty(szPackagePath, L"ARPHELPLINK", szBuffer, &cch);
                if (ERROR_SUCCESS == msiReturn)
                {
                    OLESAFE_COPYSTRING(pii->pszUrl, szBuffer);
                }
                cch = 256;
                msiReturn = GetMsiProperty(szPackagePath, L"LIMITUI", szBuffer, &cch);
                if (ERROR_SUCCESS == msiReturn)
                {
                    pii->dwActFlags |= ACTFLG_MinimalInstallUI;
                    pii->InstallUiLevel = INSTALLUILEVEL_BASIC;
                }
            }
            ppi->prgLocale = (LCID *) OLEALLOC(sizeof(LCID));
            if (!ppi->prgLocale)
            {
                goto out_of_memory;
            }
            ppi->cLocales = 1;
            ppd->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR));
            if (!ppd->pszSourceList)
            {
                goto out_of_memory;
            }
            ppd->cSources = 1;
            OLESAFE_COPYSTRING(ppd->pszSourceList[0], szPackagePath);

            if (S_OK == DetectUpgrades(szPackagePath, ppd, dlgUpgrade))
            {
                UINT n = dlgUpgrade.m_UpgradeList.size();
                if (n)
                {
                    pii->prgUpgradeInfoList = (UPGRADEINFO *) OLEALLOC(sizeof(UPGRADEINFO) * n);
                    if (!pii->prgUpgradeInfoList)
                    {
                        goto out_of_memory;
                    }
                    pii->cUpgrades = n;
                    map<CString, CUpgradeData>::iterator i = dlgUpgrade.m_UpgradeList.begin();
                    while (n--)
                    {
                        pii->prgUpgradeInfoList[n].Flag = i->second.m_flags;
                        OLESAFE_COPYSTRING(pii->prgUpgradeInfoList[n].szClassStore, i->second.m_szClassStore);
                        memcpy(&pii->prgUpgradeInfoList[n].PackageGuid, &i->second.m_PackageGuid, sizeof(GUID));
                        i++;
                    }
                }
            }

            //
            // Only one locale may be specified for this package
            //
            nLocales = 1;
            iLocale = sLocales.begin();

            {
                ppi->prgLocale[0] = *iLocale;

                // set the script path
                hr = CoCreateGuid(&guid);
                if (FAILED(hr))
                {
                    goto done;
                }
                OLECHAR sz [256];
                StringFromGUID2(guid, sz, 256);
                CString szScriptPath = m_szGPT_Path;
                szScriptPath += L"\\";
                szScriptPath += sz;
                szScriptPath += L".aas";
                OLESAFE_DELETE(pii->pszScriptPath);
                OLESAFE_COPYSTRING(pii->pszScriptPath, szScriptPath);

                HWND hwnd;
                m_pConsole->GetMainWindow(&hwnd);
                hr = BuildScriptAndGetActInfo(*ppd, m_ToolDefaults.fExtensionsOnly);

                // make sure the name is unique
                szFriendlyName = ppd->pszPackageName;
                GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
                OLESAFE_DELETE(ppd->pszPackageName);
                OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);

                if (SUCCEEDED(hr))
                {
                    fPreparationDone = TRUE;
                    do
                    {
                        hr = DeployPackage(ppd, fShowPropertySheet);
                        if (hr == CS_E_OBJECT_ALREADY_EXISTS)
                        {
                            GetUniquePackageName(szFriendlyName, szUniqueFriendlyName, nHint);
                            OLESAFE_DELETE(ppd->pszPackageName);
                            OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueFriendlyName);
                        }
                    } while (hr == CS_E_OBJECT_ALREADY_EXISTS);
                }
                if (FAILED(hr))
                {
                    // clean up script file if deployment fails
                    DeleteFile(pii->pszScriptPath);
                }
            }
        done:
            if (FAILED(hr) && hr != E_FAIL) // don't report E_FAIL error
                                            // because it's a benign error
                                            // (probably a dialog cancellation)
            {
                // report the error in the event log
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_DEPLOYMENT_ERROR, hr, lpFileTitle);

                TCHAR szBuffer[256];
                if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
                {
                    // access permission failure
                    ::LoadString(ghInstance, IDS_ADDFAILED_ACCESS_DENIED, szBuffer, 256);
                }
                else if ( HRESULT_FROM_WIN32( ERROR_INSTALL_PLATFORM_UNSUPPORTED ) == hr )
                {
                    ::LoadString(ghInstance, IDS_ILLEGAL_PLATFORM, szBuffer, 256);
                }
                else if ( HRESULT_FROM_WIN32( CS_E_ADMIN_LIMIT_EXCEEDED ) == hr )
                {
                    ::LoadString(ghInstance, IDS_ADDFAILED_METADATA_OVERFLOW, szBuffer, 256);
                }
                else
                {
                    if (fPreparationDone)
                    {
                        switch (hr)
                        {
                        // For these errors, we'll report the party line:
                        case CS_E_CLASS_NOTFOUND:
                        case CS_E_INVALID_VERSION:
                        case CS_E_NO_CLASSSTORE:
                        case CS_E_OBJECT_NOTFOUND:
                        case CS_E_OBJECT_ALREADY_EXISTS:
                        case CS_E_INVALID_PATH:
                        case CS_E_NETWORK_ERROR:
                        case CS_E_SCHEMA_MISMATCH:
                        case CS_E_PACKAGE_NOTFOUND:
                        case CS_E_INTERNAL_ERROR:
                            {
                                DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                                         NULL,
                                                         hr,
                                                         0,
                                                         szBuffer,
                                                         sizeof(szBuffer) / sizeof(szBuffer[0]),
                                                         NULL);
                                if (0 != dw)
                                {
                                    // got a valid message string
                                    break;
                                }
                                // otherwise fall through and give the generic message
                            }
                        // Either these CS errors don't apply or an admin
                        // wouldn't know what they mean:
                        case CS_E_NOT_DELETABLE:
                        default:
                            // generic class store problem
                            ::LoadString(ghInstance, IDS_ADDFAILED_CSFAILURE, szBuffer, 256);
                            break;
                        }
                    }
                    else
                    {
                        // probably some error with the package itself
                        ::LoadString(ghInstance, IDS_ADDFAILED, szBuffer, 256);
                    }
                }
    #if DBG
                TCHAR szDebugBuffer[256];
                DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                         NULL,
                                         hr,
                                         0,
                                         szDebugBuffer,
                                         sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                         NULL);
                if (0 == dw)
                {
                    wsprintf(szDebugBuffer, TEXT("(HRESULT: 0x%lX)"), hr);
                }
                wcscat(szBuffer, szDebugBuffer);
    #endif
                m_pConsole->MessageBox(szBuffer,
                                   lpFileTitle,
                                   MB_OK | MB_ICONEXCLAMATION, NULL);
            }
            InternalFreePackageDetail(ppd);
            delete ppd;
        }
    }
    return hr;
out_of_memory:
    if (ppd)
    {
        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, E_OUTOFMEMORY);
        InternalFreePackageDetail(ppd);
        delete ppd;
    }
    return E_OUTOFMEMORY;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::DetectUpgrades
//
//  Synopsis:   This functions checks if any of the existing packages in the
//              class store can be upgraded by a given package. If any such
//              packages exist, then this function populates the m_UpgradeList
//              member of the dlgUpgrade parameter passed to it. This function
//              also adds the upgrade code GUID to the PACKAGEDETAIL structure
//              passed to it.
//
//  Arguments:
//              szPackagePath - the path of the given package
//              ppd           - pointer to the PACKAGEDETAIL structure of the
//                              given package
//              dlgUpgrade    - the dialog whose member m_UpgradeList needs to be
//                              populated
//
//  Returns:
//              S_OK        the function succeeded in finding upgradeable packages
//              S_FALSE     the function did not encounter any errors, but no
//                          upgradeable packages were found
//    other failure codes   the function encountered errors
//
//  History:    5/19/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HRESULT CScopePane::DetectUpgrades (LPCOLESTR szPackagePath, const PACKAGEDETAIL* ppd, CUpgrades& dlgUpgrade)
{
    DWORD dwBufSize = 50;
    TCHAR szUpgradeCode[50];    //the upgrade GUID
    GUID guidUpgradeCode;
    TCHAR szData[50];
    DWORD dwOperator;
    HRESULT hr;
    HRESULT hres;
    MSIHANDLE hDatabase;
    UINT msiReturn;
    map<MMC_COOKIE, CAppData>::iterator i;
    INSTALLINFO* pii;
    BOOL fUpgradeable;
    LARGE_INTEGER verNew, verExisting;
    CString szCSPath;
    hr = GetClassStoreName(szCSPath, FALSE);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
    }

    msiReturn = GetMsiProperty(szPackagePath, TEXT("UpgradeCode"), szUpgradeCode, &dwBufSize);
    if (ERROR_SUCCESS != msiReturn)
        return HRESULT_FROM_WIN32(msiReturn);     //no upgrade code was found

    hr = CLSIDFromString(szUpgradeCode, &guidUpgradeCode);
    if (FAILED(hr))
        return hr;

    //insert the upgrade code GUID into the packagedetail structure.
    memcpy((LPVOID)&(ppd->pInstallInfo->Mvipc), (LPVOID)&guidUpgradeCode, sizeof(GUID));

    verNew.LowPart = ppd->pInstallInfo->dwVersionLo;
    verNew.HighPart = ppd->pInstallInfo->dwVersionHi;
    hr = S_FALSE;   //this will get set to S_OK only if we find any upgradeable packages

    msiReturn = MsiOpenDatabase (szPackagePath, MSIDBOPEN_READONLY, &hDatabase);
    if (ERROR_SUCCESS == msiReturn)
    {
        CString szQuery;
        szQuery.Format (TEXT("SELECT `UpgradeCode`, `Attributes`, `VersionMin`, `VersionMax`, `Language` FROM `Upgrade`"));
        MSIHANDLE hView;
        msiReturn = MsiDatabaseOpenView(hDatabase, szQuery, &hView);
        if (ERROR_SUCCESS == msiReturn)
        {
            msiReturn = MsiViewExecute (hView, 0);
            if (ERROR_SUCCESS == msiReturn)
            {
                MSIHANDLE hRecord;
                //for each operator value returned by the query, if an operator is found that permits
                //upgrades, iterate through the list of existing packages to see if any of those are
                //upgradeable by the supplied package. If any such package is found, add it to the
                //m_UpgradeList member of the upgrade dialog dlgUpgrade.
                do
                {
                    msiReturn = MsiViewFetch (hView, &hRecord);
                    if (ERROR_SUCCESS == msiReturn)
                    {
                        //reset dwBufSize since it is modified by MsiRecordString during every iteration
                        //of the loop.
                        dwBufSize = 50;
                        //get the upgrade code for this upgrade table entry
                        msiReturn = MsiRecordGetString (hRecord, 1, szData, &dwBufSize);
                        hres = CLSIDFromString (szData, &guidUpgradeCode);
                        if (FAILED(hres))
                        {
                            MsiCloseHandle(hRecord);
                            continue;   //ignore this package and move on to the next
                        }
                        dwBufSize = 50; //must reset to reflect the correct buffer size
                        //get the operator for this upgrade table entry
                        msiReturn = MsiRecordGetString (hRecord, 2, szData, &dwBufSize);
                        swscanf(szData, TEXT("%d"), &dwOperator);
                        if (0 == (dwOperator & 0x002))
                        {
                            // we have a potential hit
                            LARGE_INTEGER verMin;
                            LARGE_INTEGER verMax;

                            // get min version
                            dwBufSize = 50; //must reset to reflect the correct buffer size
                            BOOL fMin = FALSE;
                            msiReturn = MsiRecordGetString (hRecord, 3, szData, &dwBufSize);
                            if (ERROR_SUCCESS == msiReturn && 0 != szData[0])
                            {
                                fMin = TRUE;
                                // Parse Product Version
                                CString sz = szData;
                                sz.TrimLeft();
                                CString szTemp = sz.SpanIncluding(L"0123456789");
                                swscanf(szTemp, L"%u", &verMin.HighPart);
                                sz = sz.Mid(szTemp.GetLength());
                                szTemp = sz.SpanExcluding(L"0123456789");
                                sz = sz.Mid(szTemp.GetLength());
                                swscanf(sz, L"%u", &verMin.LowPart);
                            }
                            else
                            {
                                LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                            }

                            // get max version
                            dwBufSize = 50; //must reset to reflect the correct buffer size
                            BOOL fMax = FALSE;
                            msiReturn = MsiRecordGetString (hRecord, 4, szData, &dwBufSize);
                            if (ERROR_SUCCESS == msiReturn && 0 != szData[0])
                            {
                                fMax = TRUE;
                                // Parse Product Version
                                CString sz = szData;
                                sz.TrimLeft();
                                CString szTemp = sz.SpanIncluding(L"0123456789");
                                swscanf(szTemp, L"%u", &verMax.HighPart);
                                sz = sz.Mid(szTemp.GetLength());
                                szTemp = sz.SpanExcluding(L"0123456789");
                                sz = sz.Mid(szTemp.GetLength());
                                swscanf(sz, L"%u", &verMax.LowPart);
                            }
                            else
                            {
                                LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                            }
                            // get lcid list
                            dwBufSize = 0; //must reset to reflect the correct buffer size
                            BOOL fLcids = FALSE;
                            set<LCID> sLCID;
                            msiReturn = MsiRecordGetString (hRecord, 5, szData, &dwBufSize);
                            if (ERROR_MORE_DATA == msiReturn)
                            {
                                dwBufSize++;
                                TCHAR * szLanguages = new TCHAR[dwBufSize];
                                if (szLanguages)
                                {
                                    msiReturn = MsiRecordGetString (hRecord, 5, szLanguages, &dwBufSize);
                                    if (ERROR_SUCCESS == msiReturn)
                                    {
                                        // build set of LCIDs

                                        CString sz = szLanguages;
                                        sz.TrimLeft();
                                        while (!sz.IsEmpty())
                                        {
                                            fLcids = TRUE;
                                            LCID lcid;
                                            CString szTemp = sz.SpanIncluding(L"0123456789");
                                            swscanf(szTemp, L"%u", &lcid);
                                            sz = sz.Mid(szTemp.GetLength());
                                            szTemp = sz.SpanExcluding(L"0123456789");
                                            sz = sz.Mid(szTemp.GetLength());
                                            sLCID.insert(lcid);
                                        }
                                    }
                                    else
                                    {
                                        LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                                    }
                                    delete [] szLanguages;
                                }
                            }
                            else
                            {
                                LogADEEvent(EVENTLOG_WARNING_TYPE, EVENT_ADE_UNEXPECTEDMSI_ERROR, HRESULT_FROM_WIN32(msiReturn), szPackagePath);
                            }

                            //if an operator is found that that does not block installs and
                            //does not force uninstalling of existing apps, then search
                            //for any packages that can be upgraded
                            for (i = m_AppData.begin(); i != m_AppData.end(); i++)
                            {
                                //get the install info. for the app.
                                pii = (i->second.m_pDetails)->pInstallInfo;
                                //process this only if it has the same upgrade code
                                if ( (guidUpgradeCode == pii->Mvipc) && ! IsNullGUID(&guidUpgradeCode) )
                                {
                                    //check if other conditions for the operator are satisfied.
                                    verExisting.LowPart = pii->dwVersionLo;
                                    verExisting.HighPart = pii->dwVersionHi;

                                    // don't even bother to upgrade unless the
                                    // new version is greater or equal to the
                                    // old version
                                    fUpgradeable = (verNew.QuadPart >= verExisting.QuadPart);

                                    if (fMin && fUpgradeable)
                                    {
                                        // check minimum
                                        if (0 != (dwOperator & 0x100))
                                        {
                                            // inclusive
                                            fUpgradeable = verExisting.QuadPart >= verMin.QuadPart;
                                        }
                                        else
                                        {
                                            // exclusive
                                            fUpgradeable = verExisting.QuadPart > verMin.QuadPart;
                                        }
                                    }

                                    if (fMax && fUpgradeable)
                                    {
                                        // check maximum
                                        if (0 != (dwOperator & 0x200))
                                        {
                                            // inclusive
                                            fUpgradeable = verExisting.QuadPart <= verMax.QuadPart;
                                        }
                                        else
                                        {
                                            // exclusive
                                            fUpgradeable = verExisting.QuadPart < verMax.QuadPart;
                                        }
                                    }

                                    if (fLcids && fUpgradeable)
                                    {
                                        // check the lcid
                                        BOOL fMatch = FALSE;

                                        // look for a match
                                        PLATFORMINFO * ppi = (i->second.m_pDetails)->pPlatformInfo;

                                        UINT n = ppi->cLocales;
                                        while ((n--) && !fMatch)
                                        {
                                            if (sLCID.end() != sLCID.find(ppi->prgLocale[n]))
                                            {
                                                fMatch = TRUE;
                                            }
                                        }

                                        // set the upgradeable flag
                                        if (0 != (dwOperator & 0x400))
                                        {
                                            // exclusive
                                            fUpgradeable = !fMatch;
                                        }
                                        else
                                        {
                                            // inclusive
                                            fUpgradeable = fMatch;
                                        }
                                    }

                                    if (fUpgradeable)   //the package in question can be upgraded
                                    {
                                        CUpgradeData data;
                                        data.m_szClassStore = szCSPath;
                                        memcpy(&data.m_PackageGuid, &pii->PackageGuid, sizeof(GUID));
                                        data.m_flags = UPGFLG_NoUninstall | UPGFLG_Enforced;
                                        dlgUpgrade.m_UpgradeList.insert(pair<const CString, CUpgradeData>(GetUpgradeIndex(data.m_PackageGuid), data));
                                        hr = S_OK;
                                    }
                                }
                            }
                        }
                        MsiCloseHandle(hRecord);
                    }
                } while (NULL != hRecord && ERROR_SUCCESS == msiReturn);
                MsiViewClose (hView);   //close the view to be on the safe side, though it is not absolutely essential
            }
            else
                hr = HRESULT_FROM_WIN32(msiReturn);

            MsiCloseHandle(hView);
        }
        else
            hr = HRESULT_FROM_WIN32(msiReturn);

        MsiCloseHandle (hDatabase);
    }
    else
        hr = HRESULT_FROM_WIN32(msiReturn);

    if (FAILED(hr))
    {
        if (msiReturn != ERROR_SUCCESS)
        {
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_BADMSI_ERROR, hr, szPackagePath);
        }
        else
        {
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, hr);
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::DisplayPropSheet
//
//  Synopsis:   a generic routine for showing the property sheet for a package
//
//  Arguments:  [szPackeName] - name of the package to show properties for
//              [iPage]       - index of the preferred page to display
//
//  Returns:    nothing
//
//  History:    3-11-1998   stevebl   Created
//
//  Notes:      The property sheet will be started on the preferred page
//              only if it isn't already being displayed, in which case
//              whatever page was being displayed will retain the focus.
//
//---------------------------------------------------------------------------

void CScopePane::DisplayPropSheet(CString szPackageName, int iPage)
{
    map <MMC_COOKIE, CAppData>::iterator i = m_AppData.begin();
    while (i != m_AppData.end())
    {
        if (0 == szPackageName.Compare(i->second.m_pDetails->pszPackageName))
        {
            IDataObject * pDataObject;
            HRESULT hr = QueryDataObject(i->first, CCT_RESULT, &pDataObject);
            if (SUCCEEDED(hr))
            {
                set <CResultPane *>::iterator i2;
                for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
                {
                    hr = m_pIPropertySheetProvider->FindPropertySheet(i->first, (*i2), pDataObject);
                    if (S_FALSE == hr)
                    {
                        m_pIPropertySheetProvider->CreatePropertySheet(i->second.m_pDetails->pszPackageName, TRUE, i->first, pDataObject, 0);
                        m_pIPropertySheetProvider->AddPrimaryPages((*i2)->GetUnknown(), FALSE, NULL, FALSE);
                        m_pIPropertySheetProvider->AddExtensionPages();
                        m_pIPropertySheetProvider->Show(NULL, iPage);
                    }
                }
            }
            return;
        }
        i++;
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::RemovePackage
//
//  Synopsis:   Removes a package from the class store and the result pane.
//
//  Arguments:  [pDataObject] - data object for this result pane item
//              [fForceUninstall] - TRUE -  force app to be uninstalled on
//                                          client machines
//                                  FALSE - orphan any installations
//
//  Returns:    S_OK - success
//
//  History:    2-03-1998   stevebl   Created
//              3-30-1998   stevebl   adde fForceUninstall
//
//  Notes:      bAssigned is used
//
//---------------------------------------------------------------------------

HRESULT CScopePane::RemovePackage(MMC_COOKIE cookie, BOOL fForceUninstall, BOOL fRemoveNow)
{
    BOOL fAssigned;
    HRESULT hr = E_FAIL;
    // put up an hourglass (this could take a while)
    CHourglass hourglass;
    CAppData & data = m_AppData[cookie];
    CString szPackageName = data.m_pDetails->pszPackageName;

    // We are now not removing script files here; instead the script
    // file will be removed by the class store code when the package
    // is actually removed from the DS.
#if 0
    // only remove script files for packages that have script files
    if (data.m_pDetails->pInstallInfo->PathType == DrwFilePath)
    {
        // We need to make sure it gets removed from
        // the GPT before we delete it from the class store.
        // check to see if it's an old style relative path
        if (L'\\' != data.m_pDetails->pInstallInfo->pszScriptPath[0])
        {
            // find the last element in the path
            int iBreak = m_szGPT_Path.ReverseFind(L'{');
            CString sz = m_szGPT_Path.Left(iBreak-1);
            sz += L"\\";
            sz += data.m_pDetails->pInstallInfo->pszScriptPath;
            DeleteFile(sz);
        }
        else
        DeleteFile(data.m_pDetails->pInstallInfo->pszScriptPath);
    }
#endif

    if (0 != (data.m_pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned))
    {
        fAssigned = TRUE;
    }
    else
    {
        fAssigned = FALSE;
    }
    hr = m_pIClassAdmin->RemovePackage((LPOLESTR)((LPCOLESTR)(data.m_pDetails->pszPackageName)),
                                       fRemoveNow ? 0 :
                                       ((fForceUninstall ? ACTFLG_Uninstall : ACTFLG_Orphan) |
                                        (data.m_pDetails->pInstallInfo->dwActFlags &
                                         (ACTFLG_ExcludeX86OnIA64 | ACTFLG_IgnoreLanguage))) );

    if (SUCCEEDED(hr))
    {
        // Notify clients of change
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                          m_fMachine ? &guidMachSnapin
                                                     : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hwndMainWindow);
        }

#if 0
        if (data.m_fVisible)
        {
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                (*i)->m_pResult->DeleteItem(data.m_itemID, 0);
            }
        }
        if (SUCCEEDED(hr))
        {
            CString szCSPath;
            hr = GetClassStoreName(szCSPath, FALSE);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
            }

            // remove its entries in the extension table
            RemoveExtensionEntry(cookie, data);
            if (m_pFileExt)
            {
                m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
            }
            RemoveUpgradeEntry(cookie, data);
            m_UpgradeIndex.erase(GetUpgradeIndex(data.m_pDetails->pInstallInfo->PackageGuid));
            // If this thing upgraded other apps or had apps that were
            // upgrading, make sure that they get the proper icons and any
            // property sheets get updated.
            UINT n = data.m_pDetails->pInstallInfo->cUpgrades;
            while (n--)
            {
                map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(data.m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid));
                if (i != m_UpgradeIndex.end())
                {
                    RESULTDATAITEM rd;
                    memset(&rd, 0, sizeof(rd));
                    rd.mask = RDI_IMAGE;
                    rd.itemID = m_AppData[i->second].m_itemID;
                    rd.nImage = m_AppData[i->second].GetImageIndex(this);
                    set <CResultPane *>::iterator i2;
                    for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
                    {
                        (*i2)->m_pResult->SetItem(&rd);
                    }
                    if (m_AppData[i->second].m_pUpgradeList)
                    {
                        m_AppData[i->second].m_pUpgradeList->SendMessage(WM_USER_REFRESH, 0, 0);
                    }
                }
            }
            FreePackageDetail(data.m_pDetails);
            m_AppData.erase(cookie);
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                (*i)->m_pResult->Sort((*i)->m_nSortColumn, (*i)->m_dwSortOptions, -1);
            }
        }
#else
        // just force a refresh
        Refresh();
    }
#endif
    else
    {
        DebugMsg((DM_WARNING, TEXT("RemovePackage failed with 0x%x"), hr));
    }

    if (FAILED(hr) && hr != E_FAIL) // don't report E_FAIL error
    {
        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_REMOVE_ERROR, hr, data.m_pDetails->pszPackageName);
        TCHAR szBuffer[256];
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
        {
            // access permission failure
            ::LoadString(ghInstance, IDS_DELFAILED_ACCESS_DENIED, szBuffer, 256);
        }
        else
        {
            switch (hr)
            {
            // For these errors, we'll report the party line:
            case CS_E_CLASS_NOTFOUND:
            case CS_E_INVALID_VERSION:
            case CS_E_NO_CLASSSTORE:
            case CS_E_OBJECT_NOTFOUND:
            case CS_E_OBJECT_ALREADY_EXISTS:
            case CS_E_INVALID_PATH:
            case CS_E_NETWORK_ERROR:
            case CS_E_ADMIN_LIMIT_EXCEEDED:
            case CS_E_SCHEMA_MISMATCH:
            case CS_E_PACKAGE_NOTFOUND:
            case CS_E_INTERNAL_ERROR:
            case CS_E_NOT_DELETABLE:
                {
                    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                             NULL,
                                             hr,
                                             0,
                                             szBuffer,
                                             sizeof(szBuffer) / sizeof(szBuffer[0]),
                                             NULL);
                    if (0 != dw)
                    {
                        // got a valid message string
                        break;
                    }
                    // otherwise fall through and give the generic message
                }
            // Either these CS errors don't apply or an admin
            // wouldn't know what they mean:
            default:
                // generic class store problem
                ::LoadString(ghInstance, IDS_DELFAILED_CSFAILURE, szBuffer, 256);
                break;
            }
        }
#if DBG
        TCHAR szDebugBuffer[256];
        DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 hr,
                                 0,
                                 szDebugBuffer,
                                 sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                 NULL);
        if (0 == dw)
        {
            wsprintf(szDebugBuffer, TEXT("(HRESULT: 0x%lX)"), hr);
        }
        wcscat(szBuffer, szDebugBuffer);
#endif
        m_pConsole->MessageBox(szBuffer,
                           szPackageName,
                           MB_OK | MB_ICONEXCLAMATION, NULL);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::PopulateUpgradeLists
//
//  Synopsis:   Walks the list of apps, making sure that all the upgrade
//              tables are complete.
//
//  Arguments:  none
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::PopulateUpgradeLists()
{
    HRESULT hr = S_OK;
    // For each app in the list, insert an entry in the upgrade tables of
    // the apps it upgrades.
    map <MMC_COOKIE, CAppData>::iterator iAppData;
    for (iAppData=m_AppData.begin(); iAppData != m_AppData.end(); iAppData++)
    {
        hr = InsertUpgradeEntry(iAppData->first, iAppData->second);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::InsertUpgradeEntry
//
//  Synopsis:   For every app that this app upgrades, place an entry in its
//              upgrades set so that it points back to this one.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//  Notes:      Needs to be able to deal with scripts that might not be in
//              this OU.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::InsertUpgradeEntry(MMC_COOKIE cookie, CAppData & data)
{
    CString szCSPath;
    HRESULT hr = GetClassStoreName(szCSPath, FALSE);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
    }
    UINT n = data.m_pDetails->pInstallInfo->cUpgrades;
    while (n--)
    {
        map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(data.m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid));
        if (m_UpgradeIndex.end() != i)
        {
            // Make sure the entry isn't already added:
            INSTALLINFO * pii = m_AppData[i->second].m_pDetails->pInstallInfo;
            BOOL fExists = FALSE;
            UINT n = pii->cUpgrades;
            while (n--)
            {
                if (0 == memcmp(&data.m_pDetails->pInstallInfo->PackageGuid, &pii->prgUpgradeInfoList[n].PackageGuid, sizeof(GUID)))
                {
                    // it already exists
                    fExists = TRUE;
                    break;
                }
            }
            if (!fExists)
            {
                // Add the entry to this app.
                // We don't need to update the class store because it should
                // maintain referential integrity for us.  But we do need to
                // update our own internal structures so we're consistent with
                // what's in the class store.
                UINT n = ++(pii->cUpgrades);
                UPGRADEINFO * prgUpgradeInfoList = (UPGRADEINFO *)OLEALLOC(sizeof(UPGRADEINFO) * n);
                if (!prgUpgradeInfoList)
                {
                    // out of memory
                    // back out the change (this would be unfortunate but not fatal)
                    pii->cUpgrades--;
                }
                else
                {
                    if (n > 1)
                    {
                        memcpy(prgUpgradeInfoList, pii->prgUpgradeInfoList, sizeof(UPGRADEINFO) * (n-1));
                        OLESAFE_DELETE(pii->prgUpgradeInfoList);
                    }
                    OLESAFE_COPYSTRING(prgUpgradeInfoList[n-1].szClassStore, (LPOLESTR)((LPCWSTR)szCSPath));
                    memcpy(&prgUpgradeInfoList[n-1].PackageGuid, &data.m_pDetails->pInstallInfo->PackageGuid, sizeof(GUID));
                    prgUpgradeInfoList[n-1].Flag = UPGFLG_UpgradedBy;
                    pii->prgUpgradeInfoList = prgUpgradeInfoList;
                }
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::RemoveUpgradeEntry
//
//  Synopsis:   For every app that this app upgraded, remove the entry from
//              its upgrades set.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//  Notes:      Needs to be able to deal with scripts that might not be in
//              this OU.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::RemoveUpgradeEntry(MMC_COOKIE cookie, CAppData & data)
{
    UINT n = data.m_pDetails->pInstallInfo->cUpgrades;
    while (n--)
    {
        map<CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(data.m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid));
        if (m_UpgradeIndex.end() != i)
        {
            // Find which entry needs to be erased.
            INSTALLINFO * pii = m_AppData[i->second].m_pDetails->pInstallInfo;
            UINT n = pii->cUpgrades;
            while (n--)
            {
                if (0 == memcmp(&data.m_pDetails->pInstallInfo->PackageGuid, &pii->prgUpgradeInfoList[n].PackageGuid, sizeof(GUID)))
                {
                    // Now free this entry, copy the last entry over this
                    // one and decrement cUpgrades.  Don't need to actually
                    // reallocate the array because it will be freed later.
                    OLESAFE_DELETE(pii->prgUpgradeInfoList[n].szClassStore);
                    if (--(pii->cUpgrades))
                    {
                        memcpy(&pii->prgUpgradeInfoList[n], &pii->prgUpgradeInfoList[pii->cUpgrades], sizeof(UPGRADEINFO));
                    }
                    else
                    {
                        OLESAFE_DELETE(pii->prgUpgradeInfoList);
                    }
                    // If we ever were to need to update the class store,
                    // this is where we would do it.
                    break;
                }
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::PopulateExtensions
//
//  Synopsis:   Builds the file extension table from the list of applications.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::PopulateExtensions()
{
    HRESULT hr = S_OK;
    // first erase the old extension list
    m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
    // now add each app's extensions to the table
    map <MMC_COOKIE, CAppData>::iterator iAppData;
    for (iAppData=m_AppData.begin(); iAppData != m_AppData.end(); iAppData++)
    {
        hr = InsertExtensionEntry(iAppData->first, iAppData->second);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    if (m_pFileExt)
    {
        m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::InsertExtensionEntry
//
//  Synopsis:   Adds a single entry to the extension tables.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::InsertExtensionEntry(MMC_COOKIE cookie, CAppData & data)
{
    UINT n = data.m_pDetails->pActInfo->cShellFileExt;
    while (n--)
    {
        m_Extensions[data.m_pDetails->pActInfo->prgShellFileExt[n]].insert(cookie);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::RemoveExtensionEntry
//
//  Synopsis:   Removes ane entry from the extension tables.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::RemoveExtensionEntry(MMC_COOKIE cookie, CAppData & data)
{
    UINT n = data.m_pDetails->pActInfo->cShellFileExt;
    while (n--)
    {
        m_Extensions[data.m_pDetails->pActInfo->prgShellFileExt[n]].erase(cookie);
        if (m_Extensions[data.m_pDetails->pActInfo->prgShellFileExt[n]].empty())
        {
            m_Extensions.erase(data.m_pDetails->pActInfo->prgShellFileExt[n]);
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::PrepareExtensions
//
//  Synopsis:   Sets extension priorities so that this data can be inserted
//              into the extension list with the proper priority.
//
//  Arguments:  [pd] -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::PrepareExtensions(PACKAGEDETAIL &pd)
{
    UINT n = pd.pActInfo->cShellFileExt;
    while (n--)
    {
        // For each extension that is going to be added, we need to assign
        // it a priority that is one larger than the largest priority
        // already added.

        // NOTE: The odds of this number rolling over to 0 are so
        // unlikely that it would be pointless to check for it.  In any case
        // the results of such a bug would be easy for the admin to remedy
        // via the file extension priority dialog.

        pd.pActInfo->prgPriority[n] = 0;
        EXTLIST::iterator i;
        CString sz = pd.pActInfo->prgShellFileExt[n];
        for (i= m_Extensions[sz].begin(); i != m_Extensions[sz].end(); i++)
        {
            // look for the entry that matches this file extension
            CAppData & data = m_AppData[*i];
            UINT n2 = data.m_pDetails->pActInfo->cShellFileExt;
            while (n2--)
            {
                if (0 == sz.CompareNoCase(data.m_pDetails->pActInfo->prgShellFileExt[n2]))
                {
                    break;
                }
            }
            if (data.m_pDetails->pActInfo->prgPriority[n2] >= pd.pActInfo->prgPriority[n])
            {
                pd.pActInfo->prgPriority[n] = data.m_pDetails->pActInfo->prgPriority[n2] + 1;
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::ChangePackageState
//
//  Synopsis:   Changes the state of a package and puts up advisory message
//              boxes informing the admin about the effects of the change.
//
//  Arguments:  [data]       - entry to change
//              [dwNewState] - new state
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP CScopePane::ChangePackageState(CAppData &data, DWORD dwNewState, BOOL fShowUI)
{
    HRESULT hr = S_OK;

    // first detect what's changed
    DWORD dwOldState = data.m_pDetails->pInstallInfo->dwActFlags;
    DWORD dwChange = dwOldState ^ dwNewState;

    if (dwChange)
    {
        // commit changes
        hr = m_pIClassAdmin->ChangePackageProperties(data.m_pDetails->pszPackageName, NULL, &dwNewState, NULL, NULL, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            if (data.m_fVisible)
            {
                data.m_pDetails->pInstallInfo->dwActFlags = dwNewState;
                RESULTDATAITEM rd;
                memset(&rd, 0, sizeof(rd));
                rd.mask = RDI_IMAGE;
                rd.itemID = data.m_itemID;
                rd.nImage = data.GetImageIndex(this);
                set <CResultPane *>::iterator i;
                for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
                {
                    (*i)->m_pResult->SetItem(&rd);
                    (*i)->m_pResult->Sort((*i)->m_nSortColumn, (*i)->m_dwSortOptions, -1);
                }
            }
            data.NotifyChange();
            if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                              m_fMachine ? &guidMachSnapin
                                                         : &guidUserSnapin)))
            {
                ReportPolicyChangedError(m_hwndMainWindow);
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
        }
    }

    return hr;
}

HRESULT CScopePane::ClearCategories()
{
    while (m_CatList.cCategory)
    {
        m_CatList.cCategory--;
        OLESAFE_DELETE(m_CatList.pCategoryInfo[m_CatList.cCategory].pszDescription);
    }
    OLESAFE_DELETE(m_CatList.pCategoryInfo);
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetUpgradeIndex
//
//  Synopsis:   utility function that returns an upgrade index entry for a package.
//
//  Arguments:  [PackageID]    - the PackageID guid
//
//  Returns:    S_OK on success
//
//  History:    8-12-1998   stevebl   Created
//
//  Notes:      Pretty simple really, the index is just the string form of
//              the GUID.
//
//---------------------------------------------------------------------------

CString GetUpgradeIndex(GUID & PackageID)
{
    CString szIndex;
    WCHAR wsz[256];
    StringFromGUID2(PackageID, wsz, 256);
    return wsz;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetPackageNameFromUpgradeInfo
//
//  Synopsis:   returns the name of a package given its PackageGuid and CSPath
//
//  Arguments:  [szPackageName] - [out] name of the package associated with
//                                 this script
//              [szScript]      - [in] path to the script
//
//  Returns:    S_OK - found a package associated with this script
//              (other) - failed to find a package (could be for any number
//              of reasons)
//
//  History:    4-07-1998   stevebl   Created
//
//  Notes:      In cases where the package does not reside in this
//              container, the package name will be returned as
//                  "Package Name (container name)"
//              Note that this does not return the friendly name of the
//              MSI package, it returns the name of the package entry in the
//              class store.  The two are not always the same.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetPackageNameFromUpgradeInfo(CString & szPackageName, GUID &PackageGuid, LPOLESTR szCSPath)
{
    HRESULT hr;
    IEnumPackage * pIPE = NULL;

    CString szMyCSPath;
    hr = GetClassStoreName(szMyCSPath, FALSE);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetClassStoreName failed with 0x%x"), hr));
    }

    // see if it's in our container
    if (0 == _wcsicmp((LPOLESTR)((LPCWSTR)szMyCSPath), szCSPath))
    {
        hr = E_FAIL;
        map <CString, MMC_COOKIE>::iterator i = m_UpgradeIndex.find(GetUpgradeIndex(PackageGuid));
        if (m_UpgradeIndex.end() != i)
        {
            szPackageName = m_AppData[i->second].m_pDetails->pszPackageName;
            hr = S_OK;
        }
    }
    else
    {
        IClassAdmin * pIClassAdmin;
        hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&pIClassAdmin);
        if (SUCCEEDED(hr))
        {
            PACKAGEDETAIL pd;
            hr = pIClassAdmin->GetPackageDetailsFromGuid(PackageGuid,
                                                         &pd);
            if (SUCCEEDED(hr))
            {
                if (0 == (pd.pInstallInfo->dwActFlags & (ACTFLG_Orphan | ACTFLG_Uninstall)))
                {
                    GUID guid;
                    LPOLESTR pszPolicyName;

                    hr = pIClassAdmin->GetGPOInfo(&guid,
                                                  &pszPolicyName);
                    if (SUCCEEDED(hr))
                    {
                        szPackageName = pd.pszPackageName;
                        szPackageName += L" (";
                        szPackageName += pszPolicyName;
                        szPackageName += L")";
                        OLESAFE_DELETE(pszPolicyName);
                    }
                }
                else
                {
                    // this app is marked as deleted
                    hr = E_FAIL;
                }
                ReleasePackageDetail(&pd);
            }
            pIClassAdmin->Release();
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetMsiProperty
//
//  Synopsis:   Retrieves a property from the Property table of an MSI package.
//
//  Arguments:  [szPackagePath] - path to the MSI package
//              [szProperty]    - property to fetch
//              [szValue]       - buffer to contain the value
//              [puiSize]       - size of the buffer
//
//  Returns:    ERROR_SUCCESS if successful
//
//  History:    3-25-1998   stevebl   Created
//
//---------------------------------------------------------------------------

UINT GetMsiProperty(const TCHAR * szPackagePath, const TCHAR* szProperty, TCHAR* szValue, DWORD* puiSize)
{
    MSIHANDLE hDatabase;
    UINT msiReturn = MsiOpenDatabase(szPackagePath, MSIDBOPEN_READONLY, &hDatabase);
    if (ERROR_SUCCESS == msiReturn)
    {
        CString szQuery;
        szQuery.Format(L"SELECT `Value` FROM `Property` WHERE `Property`='%s'", szProperty);
        MSIHANDLE hView;
        msiReturn = MsiDatabaseOpenView(hDatabase, szQuery, &hView);
        if (ERROR_SUCCESS == msiReturn)
        {
            msiReturn = MsiViewExecute(hView, 0);
            if (ERROR_SUCCESS == msiReturn)
            {
                MSIHANDLE hRecord;
                msiReturn = MsiViewFetch(hView, &hRecord);
                if (ERROR_SUCCESS == msiReturn)
                {
                    msiReturn = MsiRecordGetString(hRecord, 1, szValue, puiSize);
                    MsiCloseHandle(hRecord);
                }
            }
            MsiCloseHandle(hView);
        }
        MsiCloseHandle(hDatabase);
    }
    return msiReturn;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetCapitalizedExt
//
//  Synopsis:   Given a file name, this function finds the filename
//              extension, and returns it capitalized.
//
//  Arguments:
//          [in] [szName] The file name
//          [out][szExt]  The capitalized extension
//
//  Returns:
//          TRUE  - an extension was found
//          FALSE - an extension could not be found
//
//  History:    5/20/1998  RahulTh  created
//
//  Notes:      If an extension cannot be found, then this function makes
//              szExt an empty string
//
//---------------------------------------------------------------------------
BOOL GetCapitalizedExt (LPCOLESTR szName, CString& szExt)
{
    int slashpos, dotpos;
    BOOL fRetVal = FALSE;
    CString szFileName = szName;

    szExt.Empty(); //to be on the safe side

    //get the positions of the last . and last backslash
    dotpos = szFileName.ReverseFind('.');
    slashpos = szFileName.ReverseFind('\\');

    //if the last dot occurs after the last slash, this file has an extension
    if (dotpos > slashpos)
    {
        szExt = szFileName.Mid(dotpos + 1);
        szExt.MakeUpper();
        fRetVal = TRUE;
    }

    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\pkgdtl.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       pkgdtl.cpp
//
//  Contents:   package details property page (normally hidden)
//
//  Classes:    CPackageDetails
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include "fcntl.h"
#include "io.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails property page

IMPLEMENT_DYNCREATE(CPackageDetails, CPropertyPage)

CPackageDetails::CPackageDetails() : CPropertyPage(CPackageDetails::IDD)
{
        //{{AFX_DATA_INIT(CPackageDetails)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_hConsoleHandle = NULL;
}

CPackageDetails::~CPackageDetails()
{
    *m_ppThis = NULL;
}

void CPackageDetails::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPackageDetails)
        DDX_Control(pDX, IDC_LIST1, m_cList);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPackageDetails, CPropertyPage)
        //{{AFX_MSG_MAP(CPackageDetails)
        ON_WM_DESTROY()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails message handlers


// removes tabs and \n characters
void Convert(WCHAR * wsz, CString &sz)
{
    sz="";

    int iIn=0;
    int iOut=0;
    WCHAR ch;
    while (ch = wsz[iIn++])
    {
        switch (ch)
        {
        case L'\t':
            iOut++;
            sz += ' ';
            while (iOut % 4)
            {
                iOut++;
                sz += ' ';
            }
            break;
        case L'\n':
            break;
        default:
            iOut++;
            sz += ch;
            break;
        }
    }
}

void CPackageDetails::DumpClassDetail(FILE * stream, CLASSDETAIL * pClass)
{
    WCHAR wsz[256];
    StringFromGUID2(pClass->Clsid, wsz, 256);
    fwprintf(stream, L"\t\tClsid = %s\n",wsz);
    StringFromGUID2(pClass->TreatAs, wsz, 256);
    fwprintf(stream, L"\t\tTreatAs = %s\n",wsz);
    fwprintf(stream, L"\t\tdwComClassContext = %u\n", pClass->dwComClassContext);
    fwprintf(stream, L"\t\tcProgId = %u\n",pClass->cProgId);
    int i;
    for (i = 0; i < pClass->cProgId; i++)
    {
        fwprintf(stream, L"\t\tprgProgId[%u] = %s\n",i, pClass->prgProgId[i]);
    }
}

void CPackageDetails::DumpDetails(FILE * stream)
{
    PACKAGEDETAIL * pDetails = m_pData->m_pDetails;
    WCHAR wsz[256];
    fwprintf(stream, L"pszPackageName = %s\n", pDetails->pszPackageName);
    fwprintf(stream, L"pszPublisher = %s\n", pDetails->pszPublisher);
    fwprintf(stream, L"cSources = %u\n",pDetails->cSources);
    int i;
    for (i = 0; i < pDetails->cSources; i++)
    {
        fwprintf(stream, L"pszSourceList[%u] = %s\n",i, pDetails->pszSourceList[i]);
    }
    fwprintf(stream, L"cCategories = %u\n",pDetails->cCategories);
    for (i = 0; i < pDetails->cCategories; i++)
    {
        StringFromGUID2(pDetails->rpCategory[i], wsz, 256);
        fwprintf(stream, L"rpCategory[%u]\n", i, wsz);
    }
    fwprintf(stream,L"pActInfo = \n{\n");

    ACTIVATIONINFO * pActInfo = pDetails->pActInfo;
    fwprintf(stream,L"\tcClasses = %u\n",pActInfo->cClasses);
    for (i = 0; i < pActInfo->cClasses; i++)
    {
        fwprintf(stream, L"\tpClasses[%u] = \n\t{\n",i);
        DumpClassDetail(stream, &pActInfo->pClasses[i]);
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream,L"\tcShellFileExt = %u\n",pActInfo->cShellFileExt);
    for (i = 0; i < pActInfo->cShellFileExt; i++)
    {
        fwprintf(stream, L"\tprgShellFileExt[%u] = %s\n", i, pActInfo->prgShellFileExt[i]);
        fwprintf(stream, L"\tprgPriority[%u] = %u\n", i, pActInfo->prgPriority[i]);
    }
    fwprintf(stream, L"\tcInterfaces = %u\n", pActInfo->cInterfaces);
    for (i = 0; i < pActInfo->cInterfaces; i++)
    {
        StringFromGUID2(pActInfo->prgInterfaceId[i], wsz, 256);
        fwprintf(stream, L"\tprgInterfaceId[%u] = %s\n", i, wsz);
    }
    fwprintf(stream, L"\tcTypeLib = %u\n", pActInfo->cTypeLib);
    for (i = 0; i < pActInfo->cTypeLib; i++)
    {
        StringFromGUID2(pActInfo->prgTlbId[i], wsz, 256);
        fwprintf(stream, L"\tprgTlbId[%u] = %s\n", i, wsz);
    }

    fwprintf(stream,L"}\npPlatformInfo = \n{\n");

    PLATFORMINFO * pPlatformInfo = pDetails->pPlatformInfo;
    fwprintf(stream, L"\tcPlatforms = %u\n",pPlatformInfo->cPlatforms);
    for (i = 0; i < pPlatformInfo->cPlatforms; i++)
    {
        fwprintf(stream, L"\tprgPlatform[%u] = \n\t{\n",i);
        fwprintf(stream, L"\t\tdwPlatformId = 0x%04X\n", pPlatformInfo->prgPlatform[i].dwPlatformId);
        fwprintf(stream, L"\t\tdwVersionHi = %u\n", pPlatformInfo->prgPlatform[i].dwVersionHi);
        fwprintf(stream, L"\t\tdwVersionLo = %u\n", pPlatformInfo->prgPlatform[i].dwVersionLo);
        fwprintf(stream, L"\t\tdwProcessorArch = 0x%04X\n", pPlatformInfo->prgPlatform[i].dwProcessorArch);
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream, L"\tcLoacles = %u\n", pPlatformInfo->cLocales);
    for (i = 0; i < pPlatformInfo->cLocales; i++)
    {
        fwprintf(stream, L"\tprgLocale[%u] = 0x%04X\n", i, pPlatformInfo->prgLocale[i]);
    }

    fwprintf(stream,L"}\npInstallInfo = \n{\n");

    INSTALLINFO * pInstallInfo = pDetails->pInstallInfo;
    fwprintf(stream, L"\tdwActFlags = 0x%04X\n", pInstallInfo->dwActFlags);
    fwprintf(stream, L"\tPathType = %u\n", pInstallInfo->PathType);
    fwprintf(stream, L"\tpszScriptPath = %s\n", pInstallInfo->pszScriptPath);
    fwprintf(stream, L"\tpszSetupCommand = %s\n",pInstallInfo->pszSetupCommand);
    fwprintf(stream, L"\tpszUrl = %s\n",pInstallInfo->pszUrl);
    fwprintf(stream, L"\tUsn = %I64u\n",pInstallInfo->Usn);
    fwprintf(stream, L"\tInstallUiLevel = %u\n", pInstallInfo->InstallUiLevel);
    wsz[0] = 0;
    if (pInstallInfo->pClsid)
    {
        StringFromGUID2(*pInstallInfo->pClsid, wsz, 256);
    }
    fwprintf(stream, L"\tpClsid = %s\n", wsz);
    StringFromGUID2(pInstallInfo->ProductCode, wsz, 256);
    fwprintf(stream, L"\tProductCode = %s\n", wsz);
    StringFromGUID2(pInstallInfo->Mvipc, wsz, 256);
    fwprintf(stream, L"\tMvipc = %s\n", wsz);
    fwprintf(stream, L"\tdwVersionHi = %u\n", pInstallInfo->dwVersionHi);
    fwprintf(stream, L"\tdwVersionLo = %u\n", pInstallInfo->dwVersionLo);
    fwprintf(stream, L"\tdwRevision = %u\n", pInstallInfo->dwRevision);
    fwprintf(stream, L"\tcUpgrades = %u\n", pInstallInfo->cUpgrades);
    if (pInstallInfo->cUpgrades > 0)
    {
        fwprintf(stream, L"\tprgUpgradeInfoList[%u] = \n\t{\n", i);
        for (i = 0; i < pInstallInfo->cUpgrades; i++)
        {
            fwprintf(stream, L"\t\tszClassStore = %s\n", pInstallInfo->prgUpgradeInfoList[i].szClassStore);
            StringFromGUID2(pInstallInfo->prgUpgradeInfoList[i].PackageGuid, wsz, 256);
            fwprintf(stream, L"\t\tPackageGuid = %s\n", wsz);
            fwprintf(stream, L"\t\tFlag = %u\n", pInstallInfo->prgUpgradeInfoList[i].Flag);
        }
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream, L"\tcScriptLen = %u\n", pInstallInfo->cScriptLen);
    fwprintf(stream,L"}\n");
}

BOOL CPackageDetails::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        RefreshData();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CPackageDetails::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CPackageDetails::RefreshData(void)
{
    m_cList.ResetContent();

    // Dump the m_pData->m_pDetails structure here

    FILE * stream = tmpfile();
    if (stream)
    {
        _setmode(_fileno(stream), _O_TEXT);

        DumpDetails(stream);

        rewind(stream);

        WCHAR wsz[256];
        CString szTemp;
        int cWidth = 0;

        while (fgetws(wsz, 256, stream))
        {
            Convert(wsz, szTemp);
            CDC * pDC = m_cList.GetDC();
            CSize csExtent = pDC->GetTextExtent(szTemp);
            pDC->LPtoDP(&csExtent);
            m_cList.ReleaseDC(pDC);
            if (cWidth < csExtent.cx)
            {
                cWidth = csExtent.cx;
            }
            m_cList.AddString(szTemp);
        }
        m_cList.SetHorizontalExtent(cWidth);
        fclose(stream);
    }
}

void CPackageDetails::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_PACKAGE_DETAILS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\pkgdtl.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       pkgdtl.h
//
//  Contents:   package details property page (not normally visible)
//
//  Classes:    CPackageDetails
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// pkgdtl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails dialog

class CPackageDetails : public CPropertyPage
{
        DECLARE_DYNCREATE(CPackageDetails)

// Construction
public:
        CPackageDetails();
        ~CPackageDetails();

        CPackageDetails ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CPackageDetails)
        enum { IDD = IDD_PACKAGE_DETAILS };
        CListBox        m_cList;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPackageDetails)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

        void RefreshData(void);

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CPackageDetails)
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
        void DumpDetails(FILE *);
        void DumpClassDetail(FILE *, CLASSDETAIL *);

        public:
            LONG_PTR   m_hConsoleHandle; // Handle given to the snap-in by the console
            CAppData * m_pData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\prec.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       prec.cpp
//
//  Contents:   precedence property pane (RSOP mode only)
//
//  Classes:
//
//  Functions:
//
//  History:    02-16-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include <wbemcli.h>
#include "rsoputil.h"

/////////////////////////////////////////////////////////////////////////////
// CPrecedence property page

IMPLEMENT_DYNCREATE(CPrecedence, CPropertyPage)

CPrecedence::CPrecedence() : CPropertyPage(CPrecedence::IDD)
{
    //{{AFX_DATA_INIT(CPrecedence)
    m_szTitle = _T("");
    //}}AFX_DATA_INIT
    m_hConsoleHandle = NULL;
}

CPrecedence::~CPrecedence()
{
    *m_ppThis = NULL;
}

void CPrecedence::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrecedence)
    DDX_Control(pDX, IDC_LIST1, m_list);
    DDX_Text(pDX, IDC_TITLE, m_szTitle);
    //}}AFX_DATA_MAP
}

int CALLBACK ComparePrecedenceItems(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CListCtrl * pList = (CListCtrl *)lParamSort;
    DWORD dw1, dw2;
    return lParam1 - lParam2;
}

BEGIN_MESSAGE_MAP(CPrecedence, CPropertyPage)
    //{{AFX_MSG_MAP(CPrecedence)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrecedence message handlers

LRESULT CPrecedence::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    // TODO: Add your specialized code here and/or call the base class
    switch (message )
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD, TRUE);
        return 0;
    }

    return CPropertyPage::WindowProc(message, wParam, lParam);
}

BOOL CPrecedence::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // TODO: Add extra initialization here

    RECT rect;
    m_list.GetClientRect(&rect);

    // add columns to the precedence pane
    CString szTemp;
    szTemp.LoadString(IDS_PRECEDENCE_COL1);
    m_list.InsertColumn(0, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.125);
    szTemp.LoadString(IDS_PRECEDENCE_COL2);
    m_list.InsertColumn(1, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.29);
    szTemp.LoadString(IDS_PRECEDENCE_COL3);
    m_list.InsertColumn(2, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.29);
    szTemp.LoadString(IDS_PRECEDENCE_COL4);
    m_list.InsertColumn(3, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.29);

    int i = 0;

    HRESULT hr = S_OK;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));

    szTemp = TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE Id=\"")
             + m_pData->m_szDeploymentGroupID + TEXT("\"");
    switch (m_iViewState)
    {
    case IDM_WINNER:
        szTemp += TEXT(" AND EntryType=1");
        break;
    case IDM_FAILED:
        szTemp += TEXT(" AND EntryType=4");
        break;
    case IDM_REMOVED:
        szTemp += TEXT(" AND EntryType=2");
        break;
    case IDM_ARP:
        szTemp += TEXT(" AND EntryType=3");
        break;
    }

    BSTR strQuery = SysAllocString(szTemp);
    BSTR strNamespace = SysAllocString(m_szRSOPNamespace);
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    do
    {
        hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
        if (FAILED(hr))
        {
            goto cleanup;
        }
        if (n > 0)
        {
            // prepare the data entry and populate all the fields
            CString szPackageName;
            CString szGPOID;
            CString szGPOName;
            CString szCreation;
            BSTR bstrCreation = NULL;
            ULONG ulPrecedence;
            hr = GetParameter(pObj,
                              TEXT("precedence"),
                              ulPrecedence);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameter(\"precedence\") failed with 0x%x"), hr));
            hr = GetParameter(pObj,
                              TEXT("Name"),
                              szPackageName);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameter(\"Name\") failed with 0x%x"), hr));
            hr = GetParameter(pObj,
                              TEXT("GPOID"),
                              szGPOID);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameter(\"GPOID\") failed with 0x%x"), hr));
            hr = GetParameterBSTR(pObj,
                                  TEXT("creationtime"),
                                  bstrCreation);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetParameterBSTR(\"creationtime\") failed with 0x%x"), hr));
            hr = CStringFromWBEMTime(szCreation, bstrCreation, TRUE);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: CStringFromWBEMTime failed with 0x%x"), hr));
            LPTSTR pszGPOName = NULL;
            hr = GetGPOFriendlyName(pNamespace,
                                    (LPTSTR)((LPCTSTR) szGPOID),
                                    strQueryLanguage,
                                    &pszGPOName);
            DebugReportFailure(hr, (DM_WARNING, TEXT("CPrecedence::OnInitDialog: GetGPOFriendlyName failed with 0x%x"), hr));
            if (SUCCEEDED(hr))
            {
                szGPOName = pszGPOName;
                OLESAFE_DELETE(pszGPOName);
            }

            // insert the entry in the list
            CString szPrecedence;
            szPrecedence.Format(TEXT("%lu"), ulPrecedence);
            i = m_list.InsertItem(i, szPrecedence);
            m_list.SetItemText(i, 1, szPackageName);
            m_list.SetItemText(i, 2, szGPOName);
            m_list.SetItemText(i, 3, szCreation);
            m_list.SetItemData(i, ulPrecedence);
            ulPrecedence = m_list.GetItemData(i);
            i++;

            if (bstrCreation)
            {
                SysFreeString(bstrCreation);
            }
        }
    } while (n > 0);
    m_list.SortItems(ComparePrecedenceItems, (LPARAM)&m_list);
cleanup:
    SysFreeString(strQuery);
    SysFreeString(strQueryLanguage);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CPrecedence::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_PRECEDENCE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\packages.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       packages.h
//
//  Contents:   Methods on CScopePane related to package deployment
//              and maintenence of the various index and cross-reference
//              structures.
//
//  Classes:
//
//  Functions:  CopyPackageDetail
//              FreePackageDetail
//              GetPackageProperty
//
//  History:    2-03-1998   stevebl   Created
//              3-25-1998   stevebl   Added GetMsiProperty
//              5-20-1998   RahulTh   Added GetUNCPath
//                                    Added GetCapitalizedExt
//
//---------------------------------------------------------------------------

HRESULT CopyPackageDetail(PACKAGEDETAIL * & ppdOut, PACKAGEDETAIL * & ppdIn);

void FreePackageDetail(PACKAGEDETAIL * & ppd);

UINT GetMsiProperty(const TCHAR * szPackagePath, const TCHAR* szProperty, TCHAR* szValue, DWORD* puiSize);
HRESULT GetUNCPath (LPCOLESTR szPath, CString& szUNCPath);
BOOL GetCapitalizedExt (LPCOLESTR szName, CString& szExt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\prec.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       prec.h
//
//  Contents:   precedence property pane (RSOP mode only)
//
//  Classes:
//
//  Functions:
//
//  History:    02-16-2000   stevebl   Created
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////
// CPrecedence dialog

class CPrecedence : public CPropertyPage
{
    DECLARE_DYNCREATE(CPrecedence)

// Construction
public:
    CPrecedence();
    ~CPrecedence();

    CPrecedence ** m_ppThis;

// Dialog Data
    //{{AFX_DATA(CPrecedence)
    enum { IDD = IDD_PRECEDENCE };
    CListCtrl   m_list;
    CString m_szTitle;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrecedence)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrecedence)
    virtual BOOL OnInitDialog();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    LONG_PTR   m_hConsoleHandle; // Handle given to the snap-in by the console
    CAppData * m_pData;
    int         m_iViewState;
    CString m_szRSOPNamespace;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\product.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Product.h
//
//  Contents:   product info property page
//
//  Classes:    CProduct
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CProduct dialog

class CProduct : public CPropertyPage
{
        DECLARE_DYNCREATE(CProduct)

// Construction
public:
        CProduct();
        ~CProduct();

        CProduct ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CProduct)
        enum { IDD = IDD_PRODUCT };
        CString m_szVersion;
        CString m_szPublisher;
        CString m_szLanguage;
        CString m_szContact;
        CString m_szPhone;
        CString m_szURL;
        CString m_szName;
        CString m_szPlatform;
        CString m_szRevision;
        //}}AFX_DATA

        CAppData * m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        CScopePane * m_pScopePane;
        map<MMC_COOKIE, CAppData> * m_pAppData;
        BOOL            m_fPreDeploy;
        LPGPEINFORMATION m_pIGPEInformation;
        BOOL            m_fMachine;
        BOOL            m_fRSOP;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CProduct)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

        void RefreshData(void);

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CProduct)
        afx_msg void OnChangeName();
        afx_msg void OnChange();
        virtual BOOL OnInitDialog();
        afx_msg void OnKillfocusEdit1();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\remove.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       remove.cpp
//
//  Contents:   remove application dialog
//
//  Classes:    CRemove
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRemove dialog


CRemove::CRemove(CWnd* pParent /*=NULL*/)
        : CDialog(CRemove::IDD, pParent)
{
        //{{AFX_DATA_INIT(CRemove)
        m_iState = 0;
        //}}AFX_DATA_INIT
}


void CRemove::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CRemove)
        DDX_Radio(pDX, IDC_RADIO1, m_iState);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemove, CDialog)
        //{{AFX_MSG_MAP(CRemove)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRemove::OnInitDialog()
{
        CDialog::OnInitDialog();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CRemove::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    default:
        return CDialog::WindowProc(message, wParam, lParam);
    }
}

void CRemove::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_REMOVE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\product.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Product.cpp
//
//  Contents:   product information property sheet
//
//  Classes:    CProduct
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProduct property page

IMPLEMENT_DYNCREATE(CProduct, CPropertyPage)

CProduct::CProduct() : CPropertyPage(CProduct::IDD)
{
        //{{AFX_DATA_INIT(CProduct)
        m_szVersion = _T("");
        m_szPublisher = _T("");
        m_szLanguage = _T("");
        m_szContact = _T("");
        m_szPhone = _T("");
        m_szURL = _T("");
        m_szName = _T("");
        m_szPlatform = _T("");
        m_szRevision = _T("");
        //}}AFX_DATA_INIT
        m_pIClassAdmin = NULL;
        m_fPreDeploy = FALSE;
        m_ppThis = NULL;
}

CProduct::~CProduct()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CProduct::DoDataExchange(CDataExchange* pDX)
{
    // Make sure the variables have the correct info
    m_pData->GetSzVersion(m_szVersion);
    m_pData->GetSzPublisher(m_szPublisher);
    m_pData->GetSzLocale(m_szLanguage);
    m_pData->GetSzPlatform(m_szPlatform);
    TCHAR szBuffer[256];
    DWORD cch = 256;
    UINT msiReturn = 0;
    if (m_pData->m_pDetails->pszSourceList)
    {
        msiReturn = GetMsiProperty(m_pData->m_pDetails->pszSourceList[0], L"ARPHELPTELEPHONE", szBuffer, &cch);
        if (ERROR_SUCCESS == msiReturn)
        {
            m_szPhone = szBuffer;
        }
        cch = 256;
        msiReturn = GetMsiProperty(m_pData->m_pDetails->pszSourceList[0], L"ARPCONTACT", szBuffer, &cch);
        if (ERROR_SUCCESS == msiReturn)
        {
            m_szContact = szBuffer;
        }
    }
    else
    {
        m_szPhone = "";
        m_szContact = "";
    }

        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CProduct)
        DDX_Text(pDX, IDC_STATIC2, m_szVersion);
        DDX_Text(pDX, IDC_STATIC3, m_szPublisher);
        DDX_Text(pDX, IDC_STATIC4, m_szLanguage);
        DDX_Text(pDX, IDC_STATIC5, m_szContact);
        DDX_Text(pDX, IDC_STATIC6, m_szPhone);
        DDX_Text(pDX, IDC_STATIC7, m_szURL);
        DDX_Text(pDX, IDC_EDIT1, m_szName);
        DDX_Text(pDX, IDC_STATIC9, m_szPlatform);
        DDX_Text(pDX, IDC_STATIC8, m_szRevision);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProduct, CPropertyPage)
        //{{AFX_MSG_MAP(CProduct)
        ON_EN_CHANGE(IDC_EDIT1, OnChangeName)
        ON_EN_CHANGE(IDC_STATIC7, OnChange)
        ON_EN_KILLFOCUS(IDC_EDIT1, OnKillfocusEdit1)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CProduct::OnApply()
{
    if (m_fRSOP)
    {
        return CPropertyPage::OnApply();
    }
    HRESULT hr = S_OK;
    CString szOldURL = m_pData->m_pDetails->pInstallInfo->pszUrl;
    if (0 != szOldURL.Compare(m_szURL))
    {
        hr = E_FAIL;
        if (m_pIClassAdmin)
        {
            hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                                 NULL,
                                                                 NULL,
                                                                 (LPOLESTR)((LPCOLESTR)m_szURL),
                                                                 NULL,
                                                                 NULL,
                                                                 NULL);
            if (SUCCEEDED(hr))
            {
                OLESAFE_DELETE(m_pData->m_pDetails->pInstallInfo->pszUrl);
                OLESAFE_COPYSTRING(m_pData->m_pDetails->pInstallInfo->pszUrl, m_szURL);
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        CString szOldName = m_pData->m_pDetails->pszPackageName;
        if (0 != szOldName.Compare(m_szName))
        {
            hr = E_FAIL;
            if (m_pIClassAdmin)
            {
                hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                                     (LPOLESTR)((LPCOLESTR)m_szName),
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL);
            }
            if (SUCCEEDED(hr))
            {
                OLESAFE_DELETE(m_pData->m_pDetails->pszPackageName);
                OLESAFE_COPYSTRING(m_pData->m_pDetails->pszPackageName, m_szName);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
            }
        }
    }
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine,
                                                TRUE,
                                                &guidExtension,
                                                m_fMachine ? &guidMachSnapin
                                                    : &guidUserSnapin)))
    {
        ReportPolicyChangedError(m_hWnd);
    }
    if (m_pScopePane->m_pFileExt)
    {
        m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (!m_fPreDeploy)
    {
        MMCPropertyChangeNotify(m_hConsoleHandle, (LPARAM) m_cookie);
    }
    return CPropertyPage::OnApply();
}

void CProduct::OnChange()
{
    SetModified(TRUE);
}

void CProduct::OnChangeName()
{
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT1);
    CString sz;
    pEdit->GetWindowText(sz);
    if (!m_fPreDeploy)
    {
        if (0 != sz.Compare(m_pData->m_pDetails->pszPackageName))
            SetModified();
        else
            SetModified(FALSE);
    }
}

BOOL CProduct::OnInitDialog()
{
    RefreshData();

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CProduct::OnKillfocusEdit1()
{
    // check that the new name is legitimate
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT1);
    CString sz;
    pEdit->GetWindowText(sz);
    if (sz.GetLength() == 0)
    {
        // empty name
        CString szMessage;
        szMessage.LoadString(IDS_SHORTNAME);
        MessageBox(  szMessage,
                     NULL,
                     MB_OK | MB_ICONEXCLAMATION);
        pEdit->SetWindowText(m_pData->m_pDetails->pszPackageName);
        SetModified(FALSE);
        return;
    }
    if (sz.GetLength() > 200)  // gonna disallow names longer than 200 chars
    {
        // long name
        CString szMessage;
        szMessage.LoadString(IDS_LONGNAME);
        MessageBox(  szMessage,
                     NULL,
                     MB_OK | MB_ICONEXCLAMATION);
        pEdit->SetWindowText(m_pData->m_pDetails->pszPackageName);
        SetModified(FALSE);
        return;
    }
    if (0 != sz.Compare(m_pData->m_pDetails->pszPackageName))
    {
        map<MMC_COOKIE, CAppData>::iterator i;
        for (i = m_pAppData->begin(); i != m_pAppData->end(); i++)
        {
            if (0 == sz.Compare(i->second.m_pDetails->pszPackageName))
            {
                // another package has the same name
                CString szMessage;
                szMessage.LoadString(IDS_DUPLICATENAME);
                MessageBox(  szMessage,
                             NULL,
                             MB_OK | MB_ICONEXCLAMATION);
                pEdit->SetWindowText(m_pData->m_pDetails->pszPackageName);
                SetModified(FALSE);
                return;
            }
        }
    }
}

LRESULT CProduct::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        UpdateData(FALSE);
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CProduct::RefreshData(void)
{
    if (m_fRSOP)
    {
        // make the package name edit control read only
        ( (CEdit*) GetDlgItem(IDC_EDIT1) )->SetReadOnly();

        // remove focus from read-only edit controls
        // by setting it to the ok button

        // make the support url edit control read-only
        ( (CEdit*) GetDlgItem(IDC_STATIC7) )->SetReadOnly();

        // disable EVERYTHING else

        // hide the phone and contact fields
        GetDlgItem(IDC_STATICNOHELP6)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATICNOHELP7)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATIC5)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATIC6)->ShowWindow(SW_HIDE);
    }
    if (NULL == GetFocus())
    {
        GetParent()->GetDlgItem(IDOK)->SetFocus();
    }
    m_szName = m_pData->m_pDetails->pszPackageName;
    m_szURL = m_pData->m_pDetails->pInstallInfo->pszUrl;
    m_szRevision.Format(TEXT("%u"), m_pData->m_pDetails->pInstallInfo->dwRevision);
}


void CProduct::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_PRODUCT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\remove.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       remove.h
//
//  Contents:   remove application dialog
//
//  Classes:    CRemove
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CRemove dialog

class CRemove : public CDialog
{
// Construction
public:
        CRemove(CWnd* pParent = NULL);   // standard constructor
// Dialog Data
        //{{AFX_DATA(CRemove)
        enum { IDD = IDD_REMOVE };
        int             m_iState;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CRemove)
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CRemove)
        virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by appdeped.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_VERSION                     3
#define IDS_STAGE                       4
#define IDS_RELATION                    5
#define IDS_STATE                       6
#define IDS_AUTOINST                    7
#define IDS_LOC                         8
#define IDS_MACH                        9
#define IDS_MODS                        10
#define IDS_PUB                         11
#define IDS_SOURCE                      12
#define IDS_NODENAME                    13
#define IDS_ADD_APP_DESC                14
#define IDS_DEL_APP_DESC                15
#define IDS_REFRESH_DESC                16
#define IDS_AUTOINST_DESC               17
#define IDS_ASSIGN_DESC                 18
#define IDS_PUBLISH_DESC                19
#define IDS_DISABLE_DESC                20
#define IDS_REDEPLOY_DESC               21
#define IDS_REDEPLOYERROR               22
#define IDS_X86ONIA64                   23
#define IDS_FULLINSTALL                 24
#define IDS_FOLDER_TITLE                30
#define IDS_ASSIGNED                    31
#define IDS_PUBLISHED                   32
#define IDS_DISABLED                    33
#define IDS_ORIGIN                      42
#define IDS_SOM                         43
#define IDS_WINNER_DESC                 44
#define IDS_REMOVED_DESC                45
#define IDS_ARP_DESC                    47
#define IDS_SNAPIN_NAME_USER            50
#define IDS_SNAPIN_NAME_MACHINE         51
#define IDD_UPGRADE                     101
#define IDD_DEPLOY_APP_DIALOG           102
#define IDD_PRODUCT                     106
#define IDD_GENERAL                     107
#define IDD_UPGRADES                    107
#define IDD_INSTALLATION                108
#define IDD_ENVIRONMENT                 109
#define IDD_DEPLOYMENT                  110
#define IDD_MODIFICATIONS               111
#define IDD_AUTO_INSTALL                112
#define IDD_CATEGORY                    113
#define IDD_SECURITY                    114
#define IDD_TOOL_DEFAULTS               115
#define IDD_LOCALE_PLATFORM             116
#define IDD_CATEGORIES                  117
#define IDD_FILE_EXT                    118
#define IDD_LOCALE_PACKAGE              119
#define IDD_FIND_UPGRADE                120
#define IDD_FIND_PACKAGE_UPGRADE        121
#define IDC_NAME                        201
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDC_EDIT2                       203
#define IDC_DEPLOY                      204
#define IDI_FOLDER                      205
#define IDC_CPU                         205
#define IDC_DESCRIPTION                 206
#define IDB_TOOLBAR1                    207
#define IDC_PATH                        207
#define IDC_LOCALE                      208
#define IDC_BROWSE                      209
#define IDD_PACKAGE_DETAILS             210
#define IDC_OS                          211
#define IDD_REMOVE                      211
#define IDC_VERSION                     212
#define IDD_LOCALE_PICKER               213
#define IDD_UNINSTALLTRACKING           214
#define IDD_EDITSTRING                  215
#define IDD_DIALOG1                     217
#define IDD_ADVDEP                      217
#define IDI_ZAPFILE                     218
#define IDD_SIGNATURES                  218
#define IDD_PRECEDENCE                  219
#define IDB_CERTIFICATE                 219
#define IDD_ERRORINFO                   220
#define IDD_TOOL_ADVANCEDDEFAULTS       221
#define IDD_RSOPCAUSE                   222
#define IDM_ADD_APP                     300
#define IDM_REFRESH                     301
#define IDM_DEL_APP                     302
#define IDM_AUTOINST                    303
#define IDM_ASSIGN                      304
#define IDM_PUBLISH                     305
#define IDM_DISABLE                     306
#define IDM_REDEPLOY                    307
#define IDS_REDEPLOYWARNING             308
#define IDS_DEF_EXTENSION               309
#define IDS_EXTENSION_FILTER_M          310
#define IDS_EXTENSION_FILTER            311
#define IDS_GPTFAILED                   313
#define IDS_ADDFAILED                   314
#define IDS_ADDFAILED_ACCESS_DENIED     315
#define IDS_ADDFAILED_CSFAILURE         316
#define IDS_DEF_TRANSFORM_EXTENSION     317
#define IDS_TRANSFORM_EXTENSION_FILTER  318
#define IDS_TRANSFORM_FAILED            319
#define IDS_BROWSEFOLDERS               320
#define IDS_TRANSFORM_FAILED_IN_CS      321
#define IDS_ADDEXISTSALREADY            322
#define IDS_CLSIDCONFLICT1              323
#define IDS_CLSIDCONFLICT2              324
#define IDS_BOGUS_EXTENSION             325
#define IDS_NO                          326
#define IDS_YES                         327
#define IDS_MULTIPLE                    328
#define IDS_NONE                        329
#define IDS_OPTIONAL                    330
#define IDS_REQUIRED                    331
#define IDS_NO_UNIVERSAL_NAME           332
#define IDS_DELFAILED_ACCESS_DENIED     333
#define IDS_DELFAILED_CSFAILURE         334
#define IDS_REMOVE_LEGACY_TITLE         335
#define IDS_REMOVE_LEGACY_TEXT          336
#define IDS_NO_ZAPS_ALLOWED             337
#define IDS_ADDFAILED_ZAP               338
#define IDM_WINNER                      339
#define IDM_REMOVED                     340
#define IDM_FAILED                      341
#define IDM_ARP                         342
#define IDS_ILLEGAL_PATH                343
#define IDS_ILLEGAL_PLATFORM            344
#define IDS_CERT_DEF_EXT                345
#define IDS_CERT_EXT_FILT               346
#define IDS_TEXT_DEF_EXT                347
#define IDS_TEXT_EXT_FILT               348
#define IDS_ADDFAILED_METADATA_OVERFLOW 349
#define IDS_REDEPLOY_FAILED             350
#define IDS_REDEPLOY_FAILED_IN_CS       351
#define IDS_OS                          400
#define IDS_HW                          410
#define IDM_ASSIGN_T                    504
#define IDM_PUBLISH_T                   505
#define IDM_DISABLE_T                   506
#define IDS_AUTOINSTALL_ON              600
#define IDS_AUTOINSTALL_OFF             601
#define IDS_ASK_AUTOINSTALL             602
#define IDS_USERINSTALL_ON              603
#define IDS_USERINSTALL_OFF             604
#define IDS_TO_PUBLISHED                605
#define IDS_TO_ASSIGNED                 606
#define IDS_BADDATA                     607
#define IDS_PLATFORMREQUIRED            608
#define IDS_CHANGECATEGORY              609
#define IDS_NEWCATEGORY                 610
#define IDS_CATEGORYFAILED              611
#define IDS_REPLACE                     612
#define IDS_UPGRADE                     613
#define IDS_INVALIDUPGRADE              614
#define IDS_COMPUTER                    615
#define IDS_USER                        616
#define IDS_CHANGEFAILED                617
#define IDS_DUPLICATENAME               618
#define IDS_SHORTNAME                   619
#define IDS_LONGNAME                    620
#define IDS_GENERALERROR                621
#define IDS_ERRORPOLICYCHANGED          622
#define IDS_SHORTCATNAME                623
#define IDS_LONGCATNAME                 624
#define IDS_DEPLOYTEXTPUB               625
#define IDS_DEPLOYTEXTASSIGNED          626
#define IDS_DEPLOYTEXTCUSTOM            627
#define IDS_ADVANCEDUSERS               628
#define IDS_ADVANCEDMACHINES            629
#define IDS_OOSUNINST                   630
#define IDS_SHOWARP                     631
#define IDS_UITYPE                      632
#define IDS_IGNORELOC                   633
#define IDS_REMPREV                     634
#define IDS_PRODCODE                    635
#define IDS_UPGRADEDBY                  636
#define IDS_SCRIPT                      637
#define IDS_BASIC                       638
#define IDS_MAXIMUM                     639
#define IDS_ACTRL_READ_CONTROL          640
#define IDS_ACTRL_CHANGE_ACCESS         641
#define IDS_ACTRL_CHANGE_OWNER          642
#define IDS_ACTRL_DS_CREATE_CHILD       643
#define IDS_ACTRL_DS_DELETE_CHILD       644
#define IDS_ACTRL_DS_LIST               645
#define IDS_ACTRL_DS_SELF               646
#define IDS_ACTRL_DS_READ_PROP          647
#define IDS_ACTRL_DS_WRITE_PROP         648
#define IDS_ACTRL_DS_DELETE_TREE        649
#define IDS_ACTRL_DS_LIST_OBJECT        650
#define IDS_ACTRL_DS_CONTROL_ACCESS     651
#define IDS_DS_GENERIC_READ             652
#define IDS_DS_GENERIC_WRITE            653
#define IDS_DS_GENERIC_EXECUTE          654
#define IDS_DS_GENERIC_ALL              655
#define IDS_ACTRL_DELETE                656
#define IDS_NO_ACCESS                   657
#define IDS_PRECEDENCE_COL1             658
#define IDS_PRECEDENCE_COL2             659
#define IDS_PRECEDENCE_COL3             660
#define IDS_PRECEDENCE_COL4             661
#define IDS_NEUTRAL_LOCALE              662
#define IDS_SIGS_COL1                   663
#define IDS_SIGS_COL2                   664
#define IDS_SIGS_COL3                   665
#define IDS_WIN_TEXT                    666
#define IDS_WIN_TOOLTEXT                667
#define IDS_ARP_TEXT                    668
#define IDS_ARP_TOOLTEXT                669
#define IDS_REM_TEXT                    670
#define IDS_REM_TOOLTEXT                671
#define IDS_CERTFROMMSIFAILED           672
#define IDS_ADDCERTFAILED               673
#define IDS_RSOPUPGRADEDTEXT            674
#define IDS_NA                          675
#define IDS_NODATA                      676
#define IDS_RSOP_APPLY                  677
#define IDS_RSOP_AC1                    678
#define IDS_RSOP_AC2                    679
#define IDS_RSOP_AC3                    680
#define IDS_RSOP_AC4                    681
#define IDS_RSOP_AC5                    682
#define IDS_RSOP_AC6                    683
#define IDS_RSOP_AC7                    684
#define IDS_RSOP_AC8                    703
#define IDS_RSOP_LM1                    685
#define IDS_RSOP_LM2                    686
#define IDS_RSOP_LM3                    687
#define IDS_RSOP_LM4                    688
#define IDS_RSOP_LM5                    689
#define IDS_RSOP_EXTACT                 690
#define IDS_RSOP_CLSIDACT               691
#define IDS_RSOP_PROGIDACT              692
#define IDS_RSOP_REMOVAL                693
#define IDS_RSOP_RT2                    694
#define IDS_RSOP_RT3                    695
#define IDS_RSOP_RT4                    696
#define IDS_RSOP_RC2                    697
#define IDS_RSOP_RC3                    698
#define IDS_RSOP_RC4                    699
#define IDS_RSOP_RC5                    700
#define IDS_RSOP_RC6                    701
#define IDS_RSOP_RC7                    702
#define IDS_RSOP_RC8                    704
#define IDS_RSOP_ARP_WARNING            705
#define IDS_RSOP_ARP_WARNING_TITLE      706
#define IDC_LIST1                       1000
#define IDC_LIST3                       1001
#define IDC_EDIT1                       1002
#define IDC_RADIO1                      1003
#define IDC_RADIO2                      1004
#define IDC_CHECK1                      1005
#define IDC_RADIO10                     1005
#define IDC_CHECK2                      1006
#define IDC_RADIO3                      1007
#define IDC_RADIO4                      1008
#define IDC_BUTTON1                     1009
#define IDC_BUTTON2                     1010
#define IDC_BUTTON3                     1011
#define IDC_BUTTON4                     1012
#define IDC_RADIO5                      1013
#define IDC_BUTTON5                     1013
#define IDC_RADIO6                      1014
#define IDC_BUTTON6                     1014
#define IDC_RADIO7                      1015
#define IDC_RADIO8                      1016
#define IDC_RADIO9                      1017
#define IDC_LIST2                       1018
#define IDC_RADIO11                     1018
#define IDC_COMBO1                      1019
#define IDC_STATIC1                     1020
#define IDC_STATIC2                     1021
#define IDC_STATIC3                     1022
#define IDC_STATIC4                     1023
#define IDC_STATIC5                     1024
#define IDC_CN                          1025
#define IDC_STATIC9                     1025
#define IDC_STATIC6                     1026
#define IDC_STATIC7                     1027
#define IDC_STATIC8                     1028
#define IDC_SPIN1                       1030
#define IDC_TITLE                       1034
#define IDC_CHECK3                      1035
#define IDC_CHECK4                      1036
#define IDC_CHECK5                      1037
#define IDC_CHECK6                      1038
#define IDC_RICHEDIT1                   1039
#define IDC_CHECK7                      1039
#define IDC_STATICNOHELP1               1501
#define IDC_STATICNOHELP2               1502
#define IDC_STATICNOHELP3               1503
#define IDC_STATICNOHELP4               1504
#define IDC_STATICNOHELP5               1505
#define IDC_STATICNOHELP6               1506
#define IDC_STATICNOHELP7               1507
#define IDC_STATICNOHELP8               1508
#define IDC_STATICNOHELP9               1509
#define IDC_STATICNOHELP10              1510
#define IDC_STATICNOHELP11              1511
#define IDC_STATICNOHELP12              1512
#define IDC_STATICNOHELP13              1513
#define IDC_STATICNOHELP14              1514
#define IDC_STATICNOHELP15              1515
#define IDC_STATICNOHELP16              1516
#define RT_HELPINFO                     5000
#define IDH_NOCONTEXTHELP              -1L

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        220
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1040
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\result.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       result.cpp
//
//  Contents:   implementation of the result pane
//
//  Classes:    CResultPane
//
//  History:    03-14-1998   stevebl   Created
//              05-20-1998   RahulTh   Added drag-n-drop support for adding
//                                     packages
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#include <atlimpl.cpp>
#include <wbemcli.h>
#include "rsoputil.h"
#include <list>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

long CResultPane::lDataObjectRefCount = 0;

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"APPMGR_INTERNAL";

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

//+--------------------------------------------------------------------------
//
//  Function:   ExtractInternalFormat
//
//  Synopsis:   Returns a pointer to our private object format given an
//              LPDATAOBJECT
//
//  Arguments:  [lpDataObject] - pointer to a DATAOBJECT, generally from a
//                                MMC call.
//
//  Returns:    A pointer to INTERNAL, our internal object structure.
//              NULL - if the object doesn't contain one of our objects
//              (wasn't created by us)
//
//  History:    3-13-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    INTERNAL* internal = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    if (!lpDataObject)
        return NULL;


    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        internal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);

                if (internal == NULL)
                        break;

        } while (FALSE);

    return internal;
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's IComponent implementation

STDMETHODIMP CResultPane::GetResultViewType(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions)
{
    // Use default view
    return S_FALSE;
}

STDMETHODIMP CResultPane::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    return S_OK;
}

STDMETHODIMP CResultPane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MMC_COOKIE cookie;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else
    {
        //kluge for drag-n-drop through explorer. To enable drag-n-drop
        //through explorer, the paste verb is always enabled. since
        //it is also hidden (see OnSelect), the user cannot use the
        //standard toolbar to paste. However, if the user uses CTRL-V
        //to paste when nothing has been cut, Notify gets invoked with
        //a negative lpDataObject value, therefore, in that particular
        //case, we simply return with an S_OK  -RahulTh 5/20/1998
        if ((LONG_PTR)lpDataObject <= 0)
            return S_OK;

        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            return E_UNEXPECTED;
        }
        else
        {
            cookie = pInternal->m_cookie;
        }
        switch(event)
        {
        case MMCN_COLUMNS_CHANGED:
            break;
        case MMCN_ACTIVATE:
            hr = OnActivate(cookie, arg, param);
            break;

        case MMCN_CLICK:
            hr = OnResultItemClkOrDblClk(cookie, FALSE);
            break;

        case MMCN_DBLCLICK:
            if (pInternal->m_type == CCT_RESULT)
                hr = OnResultItemClkOrDblClk(cookie, TRUE);
            else
                hr = S_FALSE;
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow(cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

        case MMCN_SELECT:
            hr = OnSelect(pInternal->m_type, cookie, arg, param);
            break;

        case MMCN_COLUMN_CLICK:
            // retain column number and sort option flags so we can pass
            // them in to sort in the event we need to trigger a resort of
            // the result pane
            m_nSortColumn = arg;
            m_dwSortOptions = param;
            break;

        case MMCN_DELETE:
            hr = Command(IDM_DEL_APP, lpDataObject);
            break;

        case MMCN_REFRESH:
            hr = Command(IDM_REFRESH, lpDataObject);
            break;

        case MMCN_QUERY_PASTE:
            //always return S_OK here because there is no way we can check
            //for the validity of the dragged objects here, so we simply
            //give the green signal and wait for the MMCN_PASTE notification
            //to see if the objects being dragged are valid at all.
            hr = S_OK;
            break;

        case MMCN_PASTE:
            if (arg > 0)    //better be safe than sorry
                OnFileDrop ((LPDATAOBJECT)arg);
            hr = S_OK;
            break;

        case MMCN_CONTEXTHELP:
            if (m_pDisplayHelp)
            {
                if (m_pScopePane->m_fRSOP)
                {
                    SHELLEXECUTEINFO ShellInfo;
                    WCHAR            pszHelpFilePath[ MAX_PATH ];

                    memset( &ShellInfo, 0, sizeof( ShellInfo ) );

                    ExpandEnvironmentStringsW (
                        L"%SystemRoot%\\Help\\RSOPsnp.chm",
                        pszHelpFilePath, MAX_PATH);

                    ShellInfo.cbSize = sizeof( ShellInfo );
                    ShellInfo.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_DOENVSUBST;
                    ShellInfo.lpVerb = L"open";
                    ShellInfo.lpFile = L"%SystemRoot%\\hh.exe";
                    ShellInfo.lpParameters = pszHelpFilePath;
                    ShellInfo.nShow = SW_SHOWNORMAL;
                    
                    (void) ShellExecuteEx( &ShellInfo );
                }
                else
                {
                    m_pDisplayHelp->ShowTopic (L"SPConcepts.chm::/ADE.htm");
                }
            }
            break;

        // Note - Future expansion of notify types possible
        default:
            hr = E_UNEXPECTED;
            break;
        }

        FREE_INTERNAL(pInternal);
    }

    return hr;
}

STDMETHODIMP CResultPane::Destroy(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::Destroy  this=%08x cookie=%u"), this, cookie));

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pConsoleVerb);
        SAFE_RELEASE(m_pDisplayHelp);
        SAFE_RELEASE(m_pToolbar);
        SAFE_RELEASE(m_pControlbar);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        if (m_pScopePane)
        {
            m_pScopePane->RemoveResultPane(this);
            ((IComponentData*)m_pScopePane)->Release(); // QI'ed in IComponentDataImpl::CreateComponent
            m_pScopePane = NULL;
        }
    }

    return S_OK;
}

STDMETHODIMP CResultPane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    // Delegate it to the IComponentData
    ASSERT(m_pScopePane != NULL);
    return m_pScopePane->QueryDataObject(cookie, type, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CResultPane);

CResultPane::CResultPane()
{
#if DBG
    dbg_cRef = 0;
#endif
    DEBUG_INCREMENT_INSTANCE_COUNTER(CResultPane);
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::CResultPane  this=%08x ref=%u"), this, dbg_cRef));
    CResultPane::lDataObjectRefCount = 0;
    m_pDisplayHelp = NULL;
    m_lViewMode = LVS_REPORT;
    BOOL _fVisible = FALSE;
    m_nSortColumn = 0;
    m_dwSortOptions = 0;
    Construct();
}

CResultPane::~CResultPane()
{
#if DBG
    ASSERT(dbg_cRef == 0);
#endif
    DebugMsg((DM_VERBOSE, TEXT("CResultPane::~CResultPane  this=%08x ref=%u"), this, dbg_cRef));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CResultPane);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);

    Construct();

    ASSERT(CResultPane::lDataObjectRefCount == 0);
}

void CResultPane::Construct()
{
#if DBG
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pScopePane = NULL;
    m_pControlbar = NULL;
    m_pToolbar = NULL;
}

CString szExtension;
CString szFilter;

HRESULT CResultPane::InitializeHeaders(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    ASSERT(m_pHeader);

    CString sz;
    sz.LoadString(IDS_NAME);
    if (m_pScopePane->m_fRSOP)
    {
        // in RSOP mode the name follows the name for the view

    }
    int n = 0;
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 150);    // name
    sz.LoadString(IDS_VERSION);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 50);     // version
    sz.LoadString(IDS_STATE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 100);    // state
    sz.LoadString(IDS_AUTOINST);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN /*75*/); // auto-inst
    sz.LoadString(IDS_SOURCE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 200);    // source
    sz.LoadString(IDS_MODS);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);    // mods
    sz.LoadString(IDS_LOC);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);     // loc
    sz.LoadString(IDS_OOSUNINST);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_SHOWARP);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_UITYPE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_IGNORELOC);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_REMPREV);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_PRODCODE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_STAGE);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);     // stage
    sz.LoadString(IDS_RELATION);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);    // Upgrading
    sz.LoadString(IDS_UPGRADEDBY);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_SCRIPT);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_MACH);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_X86ONIA64);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    sz.LoadString(IDS_FULLINSTALL);
    m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);
    if (m_pScopePane->m_fRSOP)
    {
        sz.LoadString(IDS_ORIGIN);
        m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, 150);   // origin
        sz.LoadString(IDS_SOM);
        m_pHeader->InsertColumn(n++, sz, LVCFMT_LEFT, HIDE_COLUMN);   // origin
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation

STDMETHODIMP CResultPane::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG * pInsertionAllowed)
{
    return m_pScopePane->
        AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}

STDMETHODIMP CResultPane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    if (m_pScopePane)
        return m_pScopePane->
            Command(nCommandID, pDataObject);
    else
        return S_OK;
}

HRESULT CResultPane::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
    {
        return E_INVALIDARG;
    }

    // add the images for the scope tree
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    LPIMAGELIST lpScopeImage = (LPIMAGELIST)arg;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

// Result item property pages:
STDMETHODIMP CResultPane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (pInternal && (m_pScopePane->m_fRSOP || m_pScopePane->m_pIClassAdmin))
    {
        HRESULT hr = S_OK;
        MMC_COOKIE cookie = pInternal->m_cookie;
        CAppData & data = m_pScopePane->m_AppData[cookie];
        FREE_INTERNAL(pInternal);
        HPROPSHEETPAGE hSecurity = NULL;
        LPSECURITYINFO pSI = NULL;

        //
        // make sure we have an up-to-date categories list
        //
        m_pScopePane->ClearCategories();
        if (m_pScopePane->m_fRSOP)
        {
            m_pScopePane->GetRSoPCategories();
        }
        else
        {
            hr = CsGetAppCategories(&m_pScopePane->m_CatList);
            if (FAILED(hr))
            {
                // report it
                LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GETCATEGORIES_ERROR, hr, NULL);

                // Since failure only means the categories list will be
                // empty, we'll proceed as if nothing happened.

                hr = S_OK;
            }
        }

        //
        // prepare the security property page
        //

        // check to make sure that we have access to this object
        if (m_pScopePane->m_fRSOP)
        {
            pSI = new CRSOPSecurityInfo(&data);
        }
        else
        {
            CString szPath;
            hr = m_pScopePane->GetPackageDSPath(szPath, data.m_pDetails->pszPackageName);
            if (SUCCEEDED(hr))
            {
                hr = DSCreateISecurityInfoObject(szPath,
                                                 NULL,
                                                 0,
                                                 &pSI,
                                                 NULL,
                                                 NULL,
                                                 0);
            }
        }
        if (FAILED(hr))
        {
            // we don't have access to this object (probably due to permissions)
            DebugMsg((DM_WARNING, TEXT("DSCreateISecurityInfoObject failed with 0x%x"), hr));
            // force a refresh
            hr = Command(IDM_REFRESH, lpIDataObject);
            // DON'T quit just because we couldn't create the security page!
            // return S_FALSE;
        }
        if (pSI)
        {
            hSecurity = CreateSecurityPage(pSI);
            pSI->Release();
            if (hSecurity == NULL)
                return E_UNEXPECTED;
        }

        // we have access

        //
        // Create the Product property page
        //
        data.m_pProduct = new CProduct();
        data.m_pProduct->m_ppThis = &data.m_pProduct;
        data.m_pProduct->m_pData = &data;
        data.m_pProduct->m_cookie = cookie;
        data.m_pProduct->m_hConsoleHandle = handle;
        data.m_pProduct->m_pScopePane = m_pScopePane;
        data.m_pProduct->m_pAppData = &m_pScopePane->m_AppData;
        data.m_pProduct->m_pIGPEInformation = m_pScopePane->m_pIGPEInformation;
        data.m_pProduct->m_fMachine = m_pScopePane->m_fMachine;
        data.m_pProduct->m_fRSOP = m_pScopePane->m_fRSOP;
        // no longer need to marshal, just set it
        if (!m_pScopePane->m_fRSOP)
        {
            data.m_pProduct->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
            data.m_pProduct->m_pIClassAdmin->AddRef();
        }
        else
            data.m_pProduct->m_pIClassAdmin = NULL;

        hr = SetPropPageToDeleteOnClose(&data.m_pProduct->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hProduct = CreateThemedPropertySheetPage(&data.m_pProduct->m_psp);
            if (hProduct == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hProduct);
        }

        //
        // Create the Depeployment property page
        //
        data.m_pDeploy = new CDeploy();
        data.m_pDeploy->m_ppThis = &data.m_pDeploy;
        data.m_pDeploy->m_pData = &data;
        data.m_pDeploy->m_cookie = cookie;
        data.m_pDeploy->m_hConsoleHandle = handle;
        data.m_pDeploy->m_fMachine = m_pScopePane->m_fMachine;
        data.m_pDeploy->m_fRSOP = m_pScopePane->m_fRSOP;
        data.m_pDeploy->m_pScopePane = m_pScopePane;
#if 0
        data.m_pDeploy->m_pIGPEInformation = m_pScopePane->m_pIGPEInformation;
#endif

        // no longer need to marsahl this interface, just set it
        if (!m_pScopePane->m_fRSOP)
        {
            data.m_pDeploy->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
            data.m_pDeploy->m_pIClassAdmin->AddRef();
        }
        else
            data.m_pDeploy->m_pIClassAdmin = NULL;

        hr = SetPropPageToDeleteOnClose(&data.m_pDeploy->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hDeploy = CreateThemedPropertySheetPage(&data.m_pDeploy->m_psp);
            if (hDeploy == NULL)
            {
                return E_UNEXPECTED;
                }
            lpProvider->AddPage(hDeploy);
        }

        if (data.m_pDetails->pInstallInfo->PathType != SetupNamePath)
        {
            //
            // Create the upgrades property page
            //
            data.m_pUpgradeList = new CUpgradeList();
            data.m_pUpgradeList->m_ppThis = &data.m_pUpgradeList;
            data.m_pUpgradeList->m_pData = &data;
            data.m_pUpgradeList->m_cookie = cookie;
            data.m_pUpgradeList->m_hConsoleHandle = handle;
            data.m_pUpgradeList->m_pScopePane = m_pScopePane;
            data.m_pUpgradeList->m_fMachine = m_pScopePane->m_fMachine;
            data.m_pUpgradeList->m_fRSOP = m_pScopePane->m_fRSOP;
#if 0
            data.m_pUpgradeList->m_pIGPEInformation = m_pScopePane->m_pIGPEInformation;
#endif

            // no longer need to marshal this interface, just set it
            if (!m_pScopePane->m_fRSOP)
            {
                data.m_pUpgradeList->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
                data.m_pUpgradeList->m_pIClassAdmin->AddRef();
            }
            else
                data.m_pUpgradeList->m_pIClassAdmin = NULL;

            hr = SetPropPageToDeleteOnClose(&data.m_pUpgradeList->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hUpgradeList = CreateThemedPropertySheetPage(&data.m_pUpgradeList->m_psp);
                if (hUpgradeList == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hUpgradeList);
            }
        }

        //
        // Create the Category property page
        //
        if ( ! m_pScopePane->m_fRSOP || ( IDM_ARP == m_pScopePane->m_iViewState ) )
        {
            data.m_pCategory = new CCategory();
            data.m_pCategory->m_ppThis = &data.m_pCategory;
            data.m_pCategory->m_pData = &data;
            data.m_pCategory->m_cookie = cookie;
            data.m_pCategory->m_hConsoleHandle = handle;
            data.m_pCategory->m_pCatList = &m_pScopePane->m_CatList;
            data.m_pCategory->m_fRSOP = m_pScopePane->m_fRSOP;

            // no longer need to marshal this interface, just set it
            if (!m_pScopePane->m_fRSOP)
            {
                data.m_pCategory->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
                data.m_pCategory->m_pIClassAdmin->AddRef();
            }
            else
                data.m_pCategory->m_pIClassAdmin = NULL;

            hr = SetPropPageToDeleteOnClose(&data.m_pCategory->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hCategory = CreateThemedPropertySheetPage(&data.m_pCategory->m_psp);
                if (hCategory == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hCategory);
            }
        }

        if (data.m_pDetails->pInstallInfo->PathType != SetupNamePath)
        {
            //
            // Create the Xforms property page
            //
            data.m_pXforms = new CXforms();
            data.m_pXforms->m_ppThis = &data.m_pXforms;
            data.m_pXforms->m_pData = &data;
            data.m_pXforms->m_cookie = cookie;
            data.m_pXforms->m_hConsoleHandle = handle;
            data.m_pXforms->m_pScopePane = m_pScopePane;

            // marshal the IClassAdmin interface to the page
            if (!m_pScopePane->m_fRSOP)
            {
                data.m_pXforms->m_pIClassAdmin = m_pScopePane->m_pIClassAdmin;
                data.m_pXforms->m_pIClassAdmin->AddRef();
            }
            else
                data.m_pXforms->m_pIClassAdmin = NULL;

            hr = SetPropPageToDeleteOnClose(&data.m_pXforms->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hXforms = CreateThemedPropertySheetPage(&data.m_pXforms->m_psp);
                if (hXforms == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hXforms);
            }
        }

        //
        // Add the security property page
        //
        if (hSecurity)
        {
            lpProvider->AddPage(hSecurity);
        }

        if (m_pScopePane->m_fRSOP)
        {
            // add precedence pane
            data.m_pPrecedence = new CPrecedence();
            data.m_pPrecedence->m_ppThis = &data.m_pPrecedence;
            data.m_pPrecedence->m_szRSOPNamespace = m_pScopePane->m_szRSOPNamespace;
            data.m_pPrecedence->m_pData = &data;
            data.m_pPrecedence->m_iViewState = m_pScopePane->m_iViewState;
            hr = SetPropPageToDeleteOnClose(&data.m_pPrecedence->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hPrecedence = CreateThemedPropertySheetPage(&data.m_pPrecedence->m_psp);
                if (hPrecedence == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hPrecedence);
            }

            if (m_pScopePane->m_iViewState != IDM_ARP)
            {
                // add Cause pane
                data.m_pCause = new CCause();
                data.m_pCause->m_ppThis = &data.m_pCause;
                data.m_pCause->m_pData = &data;
                data.m_pCause->m_fRemovedView = IDM_REMOVED == m_pScopePane->m_iViewState;
                hr = SetPropPageToDeleteOnClose(&data.m_pCause->m_psp);
                if (SUCCEEDED(hr))
                {
                    HPROPSHEETPAGE hCause = CreateThemedPropertySheetPage(&data.m_pCause->m_psp);
                    if (hCause == NULL)
                    {
                        return E_UNEXPECTED;
                    }
                    lpProvider->AddPage(hCause);
                }
            }

            // check for failed settings and add the error pane if necessary
            if (data.m_nStatus == 3)
            {
                data.m_pErrorInfo = new CErrorInfo();
                data.m_pErrorInfo->m_ppThis = &data.m_pErrorInfo;
                data.m_pErrorInfo->m_pData = &data;
                hr = SetPropPageToDeleteOnClose(&data.m_pErrorInfo->m_psp);
                if (SUCCEEDED(hr))
                {
                    HPROPSHEETPAGE hErrorInfo = CreateThemedPropertySheetPage(&data.m_pErrorInfo->m_psp);
                    if (hErrorInfo == NULL)
                    {
                        return E_UNEXPECTED;
                    }
                    lpProvider->AddPage(hErrorInfo);
                }
            }
        }

        if (m_pScopePane->m_ToolDefaults.fShowPkgDetails)
        {
            //
            // Create the Package Details page (debug only)
            //
            data.m_pPkgDetails = new CPackageDetails();
            data.m_pPkgDetails->m_ppThis = &data.m_pPkgDetails;
            data.m_pPkgDetails->m_hConsoleHandle = handle;
            data.m_pPkgDetails->m_pData = &data;
            hr = SetPropPageToDeleteOnClose(&data.m_pPkgDetails->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hDetails = CreateThemedPropertySheetPage(&data.m_pPkgDetails->m_psp);

                if (hDetails == NULL)
                    return E_UNEXPECTED;
                lpProvider->AddPage(hDetails);
            }
        }
    }
    else
        return S_FALSE;

    return S_OK;
}

// Result items property pages:
STDMETHODIMP CResultPane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // Look at the data object and see if it an item that we want to have a property sheet
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal)
    {
        if (CCT_RESULT == pInternal->m_type)
        {
            FREE_INTERNAL(pInternal);
            return S_OK;
        }

        FREE_INTERNAL(pInternal);
    }
    return S_FALSE;
}

STDMETHODIMP CResultPane::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

STDMETHODIMP CResultPane::SetControlbar(LPCONTROLBAR pControlbar)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    if (m_pToolbar)
    {
        SAFE_RELEASE(m_pToolbar);
    }

    if (m_pControlbar)
    {
        SAFE_RELEASE(m_pControlbar);
    }

    if (pControlbar && m_pScopePane->m_fRSOP)
    {
        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        hr = m_pControlbar->Create(TOOLBAR,
                                   dynamic_cast<IExtendControlbar *>(this),
                                   reinterpret_cast<IUnknown **>(&m_pToolbar));
        DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: Create failed with 0x%x"), hr));
        if (FAILED(hr))
        {
            return hr;
        }

        m_pToolbar->AddRef();

        // add the bitmap

        CBitmap bmp;
        if (!bmp.LoadBitmap(IDB_TOOLBAR1))
        {
            DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: LoadBitmap failed with 0x%x"), GetLastError()));
            return E_FAIL;
        }

        hr = m_pToolbar->AddBitmap(3,
                                   bmp,
                                   16,
                                   16,
                                   RGB(255, 0, 255));

        DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: AddBitmap failed with 0x%x"), hr));
        if (FAILED(hr))
        {
            return hr;
        }

        // add the buttons depending upon our state

        CString szText;
        CString szTooltipText;
        int i = 0;

        MMCBUTTON stButton;
        stButton.nBitmap = 0;
        stButton.idCommand = IDM_WINNER;
        stButton.fsState = TBSTATE_ENABLED | ( m_pScopePane->m_iViewState == IDM_WINNER ? TBSTATE_PRESSED : 0 );
        stButton.fsType = BTNS_GROUP;
        szText.LoadString(IDS_WIN_TEXT);
        szTooltipText.LoadString(IDS_WIN_TOOLTEXT);
        stButton.lpButtonText = (LPOLESTR)((LPCWSTR) szText);
        stButton.lpTooltipText = (LPOLESTR)((LPCWSTR) szTooltipText);
        hr = m_pToolbar->InsertButton(i++, &stButton);
        DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: InsertButton failed with 0x%x"), hr));

        if ((m_pScopePane->m_dwRSOPFlags & RSOP_INFO_FLAG_DIAGNOSTIC_MODE) == RSOP_INFO_FLAG_DIAGNOSTIC_MODE)
        {
            // removed packages only apply in diagnostic mode
            stButton.nBitmap = 1;
            stButton.idCommand = IDM_REMOVED;
            stButton.fsState = TBSTATE_ENABLED | ( m_pScopePane->m_iViewState == IDM_REMOVED ? TBSTATE_PRESSED : 0 );;
            szText.LoadString(IDS_REM_TEXT);
            szTooltipText.LoadString(IDS_REM_TOOLTEXT);
            stButton.lpButtonText = (LPOLESTR)((LPCWSTR) szText);
            stButton.lpTooltipText = (LPOLESTR)((LPCWSTR) szTooltipText);
            hr = m_pToolbar->InsertButton(i++, &stButton);
            DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: InsertButton failed with 0x%x"), hr));
        }

        if (!m_pScopePane->m_fMachine)
        {
            // ARP packages only apply to users
            stButton.nBitmap = 2;
            stButton.idCommand = IDM_ARP;
            stButton.fsState = TBSTATE_ENABLED | ( m_pScopePane->m_iViewState == IDM_ARP ? TBSTATE_PRESSED : 0 );;
            szText.LoadString(IDS_ARP_TEXT);
            szTooltipText.LoadString(IDS_ARP_TOOLTEXT);
            stButton.lpButtonText = (LPOLESTR)((LPCWSTR) szText);
            stButton.lpTooltipText = (LPOLESTR)((LPCWSTR) szTooltipText);
            hr = m_pToolbar->InsertButton(i++, &stButton);
            DebugReportFailure(hr, (DM_WARNING, TEXT("SetControlBar: InsertButton failed with 0x%x"), hr));
        }

    }

    return hr;
}

STDMETHODIMP CResultPane::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    if (m_pControlbar)
    {
        if (event == MMCN_SELECT)
        {
            if (HIWORD(arg))    // is it selected or not
            {
                hr = m_pControlbar->Attach(TOOLBAR,
                                           m_pToolbar);
                DebugReportFailure(hr, (DM_WARNING, TEXT("ControlBarNotify: Attach failed with 0x%x"), hr));
            }
            else if ( (BOOL) LOWORD(arg) )
            {
                hr = m_pControlbar->Detach(m_pToolbar);
                DebugReportFailure(hr, (DM_WARNING, TEXT("ControlBarNotify: Detach failed with 0x%x"), hr));
            }
        }
        else if (event == MMCN_BTN_CLICK)
        {
            hr = Command(param, reinterpret_cast<IDataObject *>(arg));
            DebugReportFailure(hr, (DM_WARNING, TEXT("ControlBarNotify: Command failed with 0x%x"), hr));
        }
    }
    return hr;
}

STDMETHODIMP CResultPane::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;

    *pnResult = 0;

    CAppData & dataA = m_pScopePane->m_AppData[cookieA];
    CAppData & dataB = m_pScopePane->m_AppData[cookieB];
    // compare the two based on column and the cookies
    CString szA, szB;

    switch (nCol)
    {
    case 0:
        szA = dataA.m_pDetails->pszPackageName;
        szB = dataB.m_pDetails->pszPackageName;
        break;
    case 1:
        dataA.GetSzVersion(szA);
        dataB.GetSzVersion(szB);
        break;
    case 2:
        dataA.GetSzDeployment(szA);
        dataB.GetSzDeployment(szB);
        break;
    case 3:
        dataA.GetSzAutoInstall(szA);
        dataB.GetSzAutoInstall(szB);
        break;
    case 4:
        dataA.GetSzSource(szA);
        dataB.GetSzSource(szB);
        break;
    case 5:
        dataA.GetSzMods(szA);
        dataB.GetSzMods(szB);
        break;
    case 6:
        dataA.GetSzLocale(szA);
        dataB.GetSzLocale(szB);
        break;
    case 7:
        dataA.GetSzOOSUninstall(szA);
        dataB.GetSzOOSUninstall(szB);
        break;
    case 8:
        dataA.GetSzShowARP(szA);
        dataB.GetSzShowARP(szB);
        break;
    case 9:
        dataA.GetSzUIType(szA);
        dataB.GetSzUIType(szB);
        break;
    case 10:
        dataA.GetSzIgnoreLoc(szA);
        dataB.GetSzIgnoreLoc(szB);
        break;
    case 11:
        dataA.GetSzRemovePrev(szA);
        dataB.GetSzRemovePrev(szB);
        break;
    case 12:
        dataA.GetSzProductCode(szA);
        dataB.GetSzProductCode(szB);
        break;
    case 13:
        dataA.GetSzStage(szA);
        dataB.GetSzStage(szB);
        break;
    case 14:
        dataA.GetSzUpgrades(szA, m_pScopePane);
        dataB.GetSzUpgrades(szB, m_pScopePane);
        break;
    case 15:
        dataA.GetSzUpgradedBy(szA, m_pScopePane);
        dataB.GetSzUpgradedBy(szB, m_pScopePane);
        break;
    case 16:
        szA = dataA.m_pDetails->pInstallInfo->pszScriptPath;
        szB = dataB.m_pDetails->pInstallInfo->pszScriptPath;
        break;
    case 17:
        dataA.GetSzPlatform(szA);
        dataB.GetSzPlatform(szB);
        break;
    case 18:
        dataA.GetSzX86onIA64(szA);
        dataB.GetSzX86onIA64(szB);
        break;
    case 19:
        dataA.GetSzFullInstall(szA);
        dataB.GetSzFullInstall(szB);
        break;
    case 20: // only valid in rsop
        dataA.GetSzOrigin(szA);
        dataB.GetSzOrigin(szB);
        break;
    case 21: // only valid in rsop
        dataA.GetSzSOM(szA);
        dataB.GetSzSOM(szB);
        break;
    }
    *pnResult = szA.CompareNoCase(szB);
    return S_OK;
}


STDMETHODIMP CResultPane::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    static CString sz;
    ASSERT(pResult != NULL);
    if (pResult)
    {
        if (pResult->lParam == -1)
        {
            switch (pResult->nCol)
            {
            case 0:
                pResult->str = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
                break;
            default:
                pResult->str = (BSTR)_T("");
                break;
            }
        }
        else
        {
            map<MMC_COOKIE, CAppData>::iterator i = m_pScopePane->m_AppData.find(pResult->lParam);
            if (i != m_pScopePane->m_AppData.end())
            {
                CAppData & data = i->second;
                switch (pResult->nCol)
                {
                case 0:
                    sz = data.m_pDetails->pszPackageName;
                    break;
                case 1:
                    data.GetSzVersion(sz);
                    break;
                case 2:
                    data.GetSzDeployment(sz);
                    break;
                case 3:
                    data.GetSzAutoInstall(sz);
                    break;
                case 4:
                    data.GetSzSource(sz);
                    break;
                case 5:
                    data.GetSzMods(sz);
                    break;
                case 6:
                    data.GetSzLocale(sz);
                    break;
                case 7:
                    data.GetSzOOSUninstall(sz);
                    break;
                case 8:
                    data.GetSzShowARP(sz);
                    break;
                case 9:
                    data.GetSzUIType(sz);
                    break;
                case 10:
                    data.GetSzIgnoreLoc(sz);
                    break;
                case 11:
                    data.GetSzRemovePrev(sz);
                    break;
                case 12:
                    data.GetSzProductCode(sz);
                    break;
                case 13:
                    data.GetSzStage(sz);
                    break;
                case 14:
                    data.GetSzUpgrades(sz, m_pScopePane);
                    break;
                case 15:
                    data.GetSzUpgradedBy(sz, m_pScopePane);
                    break;
                case 16:
                    sz = data.m_pDetails->pInstallInfo->pszScriptPath;
                    break;
                case 17:
                    data.GetSzPlatform(sz);
                    break;
                case 18:
                    data.GetSzX86onIA64(sz);
                    break;
                case 19:
                    data.GetSzFullInstall(sz);
                    break;
                case 20:
                    data.GetSzOrigin(sz);
                    break;
                case 21:
                    data.GetSzSOM(sz);
                    break;
                default:
                    sz = "";
                    break;
                }
                pResult->str = (unsigned short *)((LPCOLESTR)sz);
            }
        }
    }

    return S_OK;
}

HRESULT CResultPane::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CResultPane::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    _fVisible = (BOOL)arg;

    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        ASSERT(m_pScopePane != NULL);
        InitializeHeaders(cookie);
        m_pResult->SetViewMode(m_lViewMode);

        if (m_pScopePane->m_fRSOP || m_pScopePane->m_pIClassAdmin)
        {
            // if there's no IClassAdmin then there's nothing to enumerate
            // unless we're in RSOP mode
            Enumerate(cookie, param);
        }
    }
    else
    {
        m_pResult->GetViewMode(&m_lViewMode);
    }

    return hr;
}

HRESULT CResultPane::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CResultPane::OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick)
{
    return S_FALSE;
}

HRESULT CResultPane::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CResultPane::OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (m_pConsoleVerb)
    {
        // If it's in the result pane then "properties" should be the
        // default action.  Otherwise "open" should be the default action.
        if (type == CCT_RESULT)
        {
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            // Enable the delete verb.
            // (UI review - we're NOT going to enable
            // the delete verb after all.)
            // m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

            // Enable the properties verb.
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
        }
        else
        {
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
            if (!m_pScopePane->m_fRSOP)
            {
                // Enable the properties verb.
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
            }
        }
        // Set the default verb to open

        // Enable the refresh verb.
        if (!m_pScopePane->m_fRSOP)
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
        }
        // Enable the paste verb and hide. due to the weird way in which
        // MMC handles drag-n-drop scenarios, the only way to enable drag-n-drop
        // from explorer is to keep the paste verb enabled forever.
        // But do this only if we are not in RSoP because PASTE is meaningless
        // for RSoP which is Read-Only.
        if (!m_pScopePane->m_fRSOP)
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
        }
        else
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
        }
    }

    return S_OK;
}

HRESULT CResultPane::OnPropertyChange(LPARAM param)   // param is the cookie of the item that changed
{
    HRESULT hr = S_OK;
    if(m_pScopePane->m_AppData[param].m_fVisible)
    {
        RESULTDATAITEM rd;
        memset(&rd, 0, sizeof(rd));
        rd.mask = RDI_IMAGE;
        rd.itemID = m_pScopePane->m_AppData[param].m_itemID;
        rd.nImage = m_pScopePane->m_AppData[param].GetImageIndex(m_pScopePane);
        m_pResult->SetItem(&rd);
        m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);
    }
    return hr;
}

HRESULT CResultPane::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

void CResultPane::Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    EnumerateResultPane(cookie);
}


HRESULT GetFailedSettings(IWbemServices * pNamespace,
                          CAppData &data,
                          IWbemClassObject * pInst)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    BSTR strLanguage = SysAllocString(TEXT("WQL"));
    if (strLanguage)
    {
        CString szRelPath;
        hr = GetParameter(pInst,
                          TEXT("__RELPATH"),
                          szRelPath);
        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"__RELPATH\") failed with 0x%x", hr));
        if (SUCCEEDED(hr))
        {
            // build the proper query
            CString szQuery = TEXT("ASSOCIATORS OF {");
            szQuery += szRelPath;
            szQuery += TEXT("} WHERE ResultClass=RSOP_PolicySettingStatus");

            BSTR strQuery = SysAllocString(szQuery);
            if (strQuery)
            {
                IEnumWbemClassObject * pEnum = NULL;
                // execute the query
                hr = pNamespace->ExecQuery(strLanguage,
                                           strQuery,
                                           WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           NULL,
                                           &pEnum);
                DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  pNamespace->ExecQuery failed with 0x%x", hr));
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject * pObj = NULL;
                    ULONG n = 0;
                    // get the result (only care about the first entry)
                    hr = pEnum->Next(WBEM_INFINITE,
                                     1,
                                     &pObj,
                                     &n);
                    DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  pEnum->Next failed with 0x%x", hr));
                    if (SUCCEEDED(hr) && n > 0)
                    {
                        hr = GetParameter(pObj, TEXT("EventSource"), data.m_szEventSource);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventSource\") failed with 0x%x", hr));
                        hr = GetParameter(pObj, TEXT("EventLogName"), data.m_szEventLogName);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventLogName\") failed with 0x%x", hr));
                        hr = GetParameter(pObj, TEXT("EventID"), data.m_dwEventID);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventId\") failed with 0x%x", hr));
                        BSTR bstrTime = NULL;
                        hr = GetParameterBSTR(pObj, TEXT("EventTime"),bstrTime);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"EventTime\") failed with 0x%x", hr));
                        if (SUCCEEDED(hr))
                        {
                            data.m_szEventTime = bstrTime;
                            if (bstrTime)
                                SysFreeString(bstrTime);
                        }
                        hr = GetParameter(pObj, TEXT("ErrorCode"), data.m_hrErrorCode);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"ErrorCode\") failed with 0x%x", hr));
                        hr = GetParameter(pObj, TEXT("Status"), data.m_nStatus);
                        DebugReportFailure(hr, (DM_WARNING, L"GetFailedSettings:  GetParameter(\"Status\") failed with 0x%x", hr));
                    }
                    pEnum->Release();
                }
                SysFreeString(strQuery);
            }
            else
            {
                DebugMsg((DM_WARNING, L"GetFailedSettings:  SysAllocString failed with %u", GetLastError()));
            }
        }
        SysFreeString(strLanguage);
    }
    VariantClear(&var);
    return hr;
}


HRESULT
GetUniqueUpgradeName(
    IWbemServices * pNamespace,
    BSTR            strLanguage,
    CString&        szGPOID,
    CString         szGPOName,
    CString&        szUpgradeName)
{
    HRESULT hr;
    CString GpoName;

    hr = S_OK;

    if ( pNamespace )
    {
        LPTSTR pszGPOName = NULL;

        hr = GetGPOFriendlyName(pNamespace,
                                (LPTSTR)((LPCTSTR) szGPOID),
                                strLanguage,
                                &pszGPOName);

        GpoName = pszGPOName;

        DebugReportFailure(hr, (DM_WARNING, L"GetUniqueUpgradeName:  GetGPOFriendlyName failed with 0x%x", hr));

        OLESAFE_DELETE(pszGPOName);
    }
    else
    {
        GpoName = szGPOName;
    }

    if (SUCCEEDED(hr))
    {
        szUpgradeName += TEXT(" (");
        szUpgradeName += GpoName;
        szUpgradeName += TEXT(")");
    }

    return hr;
}


HRESULT GetRsopFriendlyAppName(
    IWbemServices * pNamespace,
    CAppData &data)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    CString szGPO;

    BSTR strLanguage = SysAllocString(TEXT("WQL"));

    if (strLanguage)
    {
        if (SUCCEEDED(hr))
        {
            // build the proper query
            CString szQuery = TEXT("SELECT Name, GPOID FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=1");
            szQuery += TEXT(" AND ApplicationId=\"");
            szQuery += data.m_szRemovingApplication;
            szQuery +=L'\"';

            BSTR strQuery = SysAllocString(szQuery);
            if (strQuery)
            {
                IEnumWbemClassObject * pEnum = NULL;
                // execute the query
                hr = pNamespace->ExecQuery(strLanguage,
                                           strQuery,
                                           WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           NULL,
                                           &pEnum);
                DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  pNamespace->ExecQuery failed with 0x%x", hr));
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject * pObj = NULL;
                    ULONG n = 0;
                    // get the result (only care about the first entry)
                    hr = pEnum->Next(WBEM_INFINITE,
                                     1,
                                     &pObj,
                                     &n);
                    DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  pEnum->Next failed with 0x%x", hr));
                    if (SUCCEEDED(hr) && n > 0)
                    {
                        hr = GetParameter(pObj, TEXT("Name"), data.m_szRemovingApplicationName);
                        DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  GetParameter(\"Name\") failed with 0x%x", hr));
                    }

                    if (SUCCEEDED(hr) && n > 0)
                    {
                        hr = GetParameter(pObj,
                                          TEXT("GPOID"),
                                          szGPO);
                        DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  GetParameter(\"GPOID\") failed with 0x%x", hr));
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        hr = GetUniqueUpgradeName(
                            pNamespace,
                            strLanguage,
                            szGPO,
                            TEXT(""),
                            data.m_szRemovingApplicationName);
                    }

                    pEnum->Release();
                }

                DebugReportFailure(hr, (DM_WARNING, L"GetRsopFriendlyAppName:  GetUniqueUpgradeName failed with 0x%x", hr));

                SysFreeString(strQuery);
            }
            else
            {
                DebugMsg((DM_WARNING, L"GetRsopFriendlyAppName:  SysAllocString failed with %u", GetLastError()));
            }
        }
        SysFreeString(strLanguage);
    }
    VariantClear(&var);
    return hr;
}


HRESULT GetRSOPUpgrades(IWbemServices * pNamespace,
                        TCHAR * szGPOID,
                        IWbemClassObject * pInst,
                        TCHAR * szParam,
                        set <CString> &s)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    BSTR strLanguage = SysAllocString(TEXT("WQL"));

    if (strLanguage)
    {
        CString EntryType;

        hr = pInst->Get(szParam, 0, &var, 0, 0);
        DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  pInst->Get(\"%s\") failed with 0x%x", szParam, hr));

        if ( SUCCEEDED(hr) )
        {
            VARIANT varEntryType;

            VariantInit( &varEntryType );

            hr = pInst->Get( L"EntryType", 0, &varEntryType, 0, 0 );

            if ( SUCCEEDED(hr) )
            {
                if ( VT_I4 == varEntryType.vt )
                {
                    EntryType.Format( TEXT("%d"), varEntryType.lVal );
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }

            VariantClear( &varEntryType );
        }

        if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
        {
            CString sz;
            SAFEARRAY * parray = var.parray;
            BSTR * rgData = (BSTR *)parray->pvData;
            UINT ui = parray->rgsabound[0].cElements;
            while (ui--)
            {
                sz = rgData[ui];

                // Find the app that this guid matches

                // first build the proper query
                CString szQuery = TEXT("SELECT Name, GPOID FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=");

                szQuery += EntryType;
                szQuery += TEXT(" AND ApplicationId=");
                szQuery +=L'\"';
                szQuery += sz;
                szQuery +=L'\"';

                BSTR strQuery = SysAllocString(szQuery);
                if (strQuery)
                {
                    IEnumWbemClassObject * pEnum = NULL;
                    // execute the query
                    hr = pNamespace->ExecQuery(strLanguage,
                                               strQuery,
                                               WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                               NULL,
                                               &pEnum);
                    DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  pNamespace->ExecQuery failed with 0x%x", hr));
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject * pObj = NULL;
                        ULONG n;
                        // get the result (only care about the first entry)
                        hr = pEnum->Next(WBEM_INFINITE,
                                         1,
                                         &pObj,
                                         &n);
                        DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  pEnum->Next failed with 0x%x", hr));
                        if (SUCCEEDED(hr) && n > 0)
                        {
                            // get the PackageName
                            hr = GetParameter(pObj,
                                              TEXT("Name"),
                                              sz);
                            DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  GetParameter(\"Name\") failed with 0x%x", hr));

                            // get the GPOID
                            CString szGPO;
                            hr = GetParameter(pObj,
                                              TEXT("GPOID"),
                                              szGPO);
                            DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  GetParameter(\"GPOID\") failed with 0x%x", hr));

                            hr = GetUniqueUpgradeName(pNamespace,
                                                strLanguage,
                                                szGPO,
                                                TEXT(""),
                                                sz);

                            DebugReportFailure(hr, (DM_WARNING, L"GetRSOPUpgrades:  GetUniqueUpgradeName failed with 0x%x", hr));

                            // insert the name
                            s.insert(sz);
                            pObj->Release();
                        }
                        pEnum->Release();
                    }
                    SysFreeString(strQuery);
                }
            }
        }
        SysFreeString(strLanguage);
    }
    VariantClear(&var);
    return hr;
}

HRESULT
GetRSOPUpgradedBy( map<MMC_COOKIE, CAppData>* pAppData )
{
    map<MMC_COOKIE, CAppData>::iterator AppIterator;
    CString UpgradeId;
    CString AppId;

    BSTR strLanguage = SysAllocString(TEXT("WQL"));

    if ( ! strLanguage )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr;

    hr = S_OK;

    //
    // For each app, retrieve the set of apps that it upgrades
    //
    for ( AppIterator = pAppData->begin(); AppIterator != pAppData->end(); AppIterator++)
    {
        {
            CAppData& AppData = AppIterator->second;

            AppId = AppData.m_pDetails->pszPackageName;

            hr = GetUniqueUpgradeName(
                NULL,
                strLanguage,
                AppData.m_szGPOID,
                AppData.m_szGPOName,
                AppId);

            if ( FAILED(hr) )
            {
                break;
            }

            //
            // Iterate through each upgrade to see if
            // we can find the upgrade in the list of apps
            //
            set <CString>::iterator CurrentUpgrade;

            for (
                CurrentUpgrade = AppData.m_setUpgrade.begin();
                CurrentUpgrade != AppData.m_setUpgrade.end();
                CurrentUpgrade++)
            {
                map<MMC_COOKIE, CAppData>::iterator UpgradeIterator;

                for (
                    UpgradeIterator = pAppData->begin();
                    pAppData->end() != UpgradeIterator;
                    UpgradeIterator++)
                {
                    UpgradeId = UpgradeIterator->second.m_pDetails->pszPackageName;

                    hr = GetUniqueUpgradeName(
                        NULL,
                        strLanguage,
                        UpgradeIterator->second.m_szGPOID,
                        UpgradeIterator->second.m_szGPOName,
                        UpgradeId);

                    if ( FAILED(hr) )
                    {
                        break;
                    }

                    //
                    // See if this potential upgrade corresponds to the current upgrade
                    // listed in the current app -- if so, mark the upgraded app as being
                    // upgraded by the current app
                    //
                    if ( *CurrentUpgrade == UpgradeId )
                    {
                        UpgradeIterator->second.m_setUpgradedBy.insert( AppId );
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                for (
                    CurrentUpgrade = AppData.m_setReplace.begin();
                    CurrentUpgrade != AppData.m_setReplace.end();
                    CurrentUpgrade++)
                {
                    map<MMC_COOKIE, CAppData>::iterator UpgradeIterator;

                    for (
                        UpgradeIterator = pAppData->begin();
                        pAppData->end() != UpgradeIterator;
                        UpgradeIterator++)
                    {
                        UpgradeId = UpgradeIterator->second.m_pDetails->pszPackageName;

                        hr = GetUniqueUpgradeName(
                            NULL,
                            strLanguage,
                            UpgradeIterator->second.m_szGPOID,
                            UpgradeIterator->second.m_szGPOName,
                            UpgradeId);

                        if ( FAILED(hr) )
                        {
                            break;
                        }

                        //
                        // See if this potential upgrade corresponds to the current upgrade
                        // listed in the current app -- if so, mark the upgraded app as being
                        // upgraded by the current app
                        //
                        if ( *CurrentUpgrade == UpgradeId )
                        {
                            UpgradeIterator->second.m_setUpgradedBy.insert( AppId );
                        }
                    }
                }
            }

            if ( FAILED(hr) )
            {
                break;
            }
        }

        if ( FAILED( hr) )
        {
            break;
        }
    }

    SysFreeString(strLanguage);

    return hr;
}

HRESULT CResultPane::EnumerateRSoPData(void)
{
    HRESULT hr = S_OK;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = NULL;
    CString szText;

    m_pScopePane->m_AppData.erase(m_pScopePane->m_AppData.begin(), m_pScopePane->m_AppData.end());

    switch (m_pScopePane->m_iViewState)
    {
    case IDM_WINNER:
        strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=1"));
        szText.LoadString(IDS_WIN_TEXT);
        break;
    case IDM_REMOVED:
        strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=2"));
        szText.LoadString(IDS_REM_TEXT);
        break;
    case IDM_ARP:
        strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting WHERE EntryType=3"));
        szText.LoadString(IDS_ARP_TEXT);
        break;
    }
    // set text of first column to match the view state
    m_pHeader->SetColumnText(0, szText);

    BSTR strNamespace = SysAllocString(m_pScopePane->m_szRSOPNamespace);
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  CoCreateInstance failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  pLocator->ConnectServer failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  pNamespace->ExecQuery failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    do
    {
        hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
        DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  pEnum->Next failed with 0x%x", hr));
        if (FAILED(hr))
        {
            goto cleanup;
        }
        if (n > 0)
        {
            // prepare the data entry and populate all the fields
            CAppData data;
            data.m_fRSoP = TRUE;
            BOOL fDemandInstallable = FALSE;
            int iLossOfScopeAction = 0;
            BOOL fDisplayInARP = FALSE;
            BOOL fIgnoreLanguage = FALSE;
            BOOL fUpgradeSettingsMandatory = FALSE;
            BOOL fUninstallUnmanaged = FALSE;
            BOOL fAllowX86OnIA64 = FALSE;
            int iAssignmentType = 0;
            UINT uiDeploymentType = 0;
            WCHAR * szPackageLocation = NULL;
            UINT nTransforms = 0;
            WCHAR ** rgszTransforms = NULL;
            PACKAGEDETAIL * pd = new PACKAGEDETAIL;
            ACTIVATIONINFO * pa = (ACTIVATIONINFO *)OLEALLOC(sizeof(ACTIVATIONINFO));
            PLATFORMINFO * pp = (PLATFORMINFO *)OLEALLOC(sizeof(PLATFORMINFO));
            INSTALLINFO * pi = (INSTALLINFO *)OLEALLOC(sizeof(INSTALLINFO));
            if (pd && pa && pi && pp)
            {
                memset(pi, 0, sizeof(INSTALLINFO));
                memset(pp, 0, sizeof(PLATFORMINFO));
                memset(pa, 0, sizeof(ACTIVATIONINFO));
                memset(pd, 0, sizeof(PACKAGEDETAIL));
                pd->pActInfo = pa;
                pd->pPlatformInfo = pp;
                pd->pInstallInfo = pi;
            }
            else
            {
                // out of memory
                if (pd)
                {
                    delete pd;
                }
                if (pa)
                {
                    delete pa;
                }
                if (pi)
                {
                    delete pi;
                }
                if (pp)
                {
                    delete pp;
                }
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
            hr = GetParameter(pObj,
                              TEXT("Name"),
                              pd->pszPackageName);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Name\") failed with 0x%x", hr));
            DWORD dwPrecedence;
            hr = GetParameter(pObj,
                              TEXT("Precedence"),
                              dwPrecedence);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Precedence\") failed with 0x%x", hr));
            if ((1 != dwPrecedence) &&  (IDM_REMOVED != m_pScopePane->m_iViewState))
            {
                data.m_fHide = TRUE;
            }
            hr = GetParameter(pObj,
                              TEXT("VersionNumberLo"),
                              pi->dwVersionLo);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"VersionNumberLo\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("VersionNumberHi"),
                              pi->dwVersionHi);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"VersionNumberHi\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("Publisher"),
                              pd->pszPublisher);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Publisher\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("ProductId"),
                              pi->ProductCode);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"ProductId\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("ScriptFile"),
                              pi->pszScriptPath);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"ScriptFile\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("SupportURL"),
                              pi->pszUrl);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"SupportURL\") failed with 0x%x", hr));
            pp->prgLocale = (LCID *) OLEALLOC(sizeof(LCID));
            if (!pp->prgLocale)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
            pp->cLocales = 1;
            hr = GetParameter(pObj,
                              TEXT("LanguageID"),
                              pp->prgLocale[0]);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LanguageID\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("MachineArchitectures"),
                              pp->cPlatforms,
                              pp->prgPlatform);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"MachineArchitectures\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("DeploymentType"),
                              uiDeploymentType);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"DeploymentType\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("InstallationUI"),
                              pi->InstallUiLevel);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"InstallationUI\") failed with 0x%x", hr));
            if (pi->InstallUiLevel == 2)
            {
                pi->InstallUiLevel = INSTALLUILEVEL_FULL;
            }
            else
            {
                pi->InstallUiLevel = INSTALLUILEVEL_BASIC;
            }
            hr = GetParameter(pObj,
                              TEXT("RedeployCount"),
                              pi->dwRevision);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RedeployCount\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("DemandInstallable"),
                              fDemandInstallable);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"DemandInstallable\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("LossOfScopeAction"),
                              iLossOfScopeAction);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LossOfScopeAction\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("DisplayInARP"),
                              fDisplayInARP);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"DisplayInARP\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("IgnoreLanguage"),
                              fIgnoreLanguage);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"IgnoreLanguage\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("UninstallUnmanaged"),
                              fUninstallUnmanaged);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"UninstallUnmanaged\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("AssignmentType"),
                              iAssignmentType);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"AssignmentType\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("AllowX86OnIA64"),
                              fAllowX86OnIA64);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"AllowX86OnIA64\") failed with 0x%x", hr));

            // build proper flags
            pi->dwActFlags = (uiDeploymentType == 2 ? ACTFLG_Published : ACTFLG_Assigned)
                | (fDemandInstallable ? ACTFLG_OnDemandInstall : 0)
                | (iLossOfScopeAction == 1 ? ACTFLG_UninstallOnPolicyRemoval : ACTFLG_OrphanOnPolicyRemoval)
                | (fDisplayInARP ? ACTFLG_UserInstall : 0)
                | (fUninstallUnmanaged ? ACTFLG_UninstallUnmanaged : 0)
                | (fIgnoreLanguage ? ACTFLG_IgnoreLanguage : 0)
                | (iAssignmentType == 3 ? ACTFLG_InstallUserAssign : 0);
            {
                int nArch = pp->cPlatforms;
                while (nArch--)
                {
                    if (pp->prgPlatform[nArch].dwProcessorArch == PROCESSOR_ARCHITECTURE_INTEL)
                    {
                        if (!fAllowX86OnIA64)
                        {
                            pi->dwActFlags |= ACTFLG_ExcludeX86OnIA64;
                        }
                    }
                }
            }

            hr = GetParameter(pObj,
                              TEXT("UpgradeSettingsMandatory"),
                              fUpgradeSettingsMandatory);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"UpgradeSettingsMandatory\") failed with 0x%x", hr));
            if (fUpgradeSettingsMandatory)
            {
                pi->dwActFlags |= ACTFLG_ForceUpgrade;
            }
            hr = GetParameter(pObj,
                              TEXT("PackageLocation"),
                              szPackageLocation);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"PackageLocation\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("transforms"),
                              nTransforms,
                              rgszTransforms
                              );
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"transforms\") failed with 0x%x", hr));
            pd->pszSourceList = (TCHAR **)OLEALLOC(sizeof(TCHAR *) * (nTransforms + 1));
            if (!pd->pszSourceList)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
            pd->cSources = nTransforms + 1;
            if (NULL != pd->pszSourceList)
            {
                pd->pszSourceList[0] = szPackageLocation;
                UINT n = nTransforms;
                while (n--)
                {
                    pd->pszSourceList[1 + n] = rgszTransforms[n];
                }
                OLESAFE_DELETE(rgszTransforms);
            }
            /* UNDONE
            hr = GetParameter(pObj,
                              TEXT("localeMatchType"),
                              );
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LocaleMatchType\") failed with 0x%x", hr));
                     */
            hr = GetParameter(pObj,
                              TEXT("categories"),
                              pd->cCategories,
                              pd->rpCategory
                              );
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"categories\") failed with 0x%x", hr));
            data.m_pDetails = pd;
            data.InitializeExtraInfo();

            hr = GetParameter(pObj,
                              TEXT("GPOID"),
                              data.m_szGPOID);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"GPOID\") failed with 0x%x", hr));
            LPTSTR pszGPOName = NULL;
            hr = GetGPOFriendlyName(pNamespace,
                                    (LPTSTR)((LPCTSTR) data.m_szGPOID),
                                    strQueryLanguage,
                                    &pszGPOName);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetGPOFriendlyName failed with 0x%x", hr));
            if (SUCCEEDED(hr))
            {
                data.m_szGPOName = pszGPOName;
                OLESAFE_DELETE(pszGPOName);
            }

            hr = GetParameter(pObj,
                              TEXT("Id"),
                              data.m_szDeploymentGroupID);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"Id\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("SOMID"),
                              data.m_szSOMID);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"SOMID\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("SecurityDescriptor"),
                              data.m_psd);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"SecurityDescriptor\") failed with 0x%x", hr));
            hr = GetRSOPUpgrades(pNamespace,
                                 0,
                                 pObj,
                                 TEXT("UpgradeableApplications"),
                                 data.m_setUpgrade);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetRSOPUpgrades(\"UpgradeableApplications\") failed with 0x%x", hr));
            hr = GetRSOPUpgrades(pNamespace,
                                 0,
                                 pObj,
                                 TEXT("ReplaceableApplications"),
                                 data.m_setReplace);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetRSOPUpgrades(\"ReplaceableApplications\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("ApplyCause"),
                              data.m_dwApplyCause);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"ApplyCause\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("LanguageMatch"),
                              data.m_dwLanguageMatch);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"LanguageMatch\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("OnDemandFileExtension"),
                              data.m_szOnDemandFileExtension);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"OnDemandFileExtension\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("OnDemandClsid"),
                              data.m_szOnDemandClsid);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"OnDemandClsid\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("OnDemandProgid"),
                              data.m_szOnDemandProgid);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"OnDemandProgid\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("RemovalCause"),
                              data.m_dwRemovalCause);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RemovalCause\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("RemovalType"),
                              data.m_dwRemovalType);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RemovalType\") failed with 0x%x", hr));

            hr = GetParameter(pObj,
                              TEXT("RemovingApplication"),
                              data.m_szRemovingApplication);
            DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetParameter(\"RemovingType\") failed with 0x%x", hr));

            if ( SUCCEEDED(hr) )
            {
                hr = GetRsopFriendlyAppName(
                    pNamespace,
                    data);
            }

            hr = GetFailedSettings(pNamespace,
                                   data,
                                   pObj);
            if (SUCCEEDED(hr))
            {
                LPOLESTR lpText;
                hr = this->m_pScopePane->m_pIRSOPInformation->GetEventLogEntryText((LPOLESTR)(LPCOLESTR)data.m_szEventSource,
                                                                                   (LPOLESTR)(LPCOLESTR)data.m_szEventLogName,
                                                                                   (LPOLESTR)(LPCOLESTR)data.m_szEventTime,
                                                                                   data.m_dwEventID,
                                                                                   &lpText);
                DebugReportFailure(hr, (DM_WARNING, L"EnumerateRSoPData:  GetEventLogEntryText failed with 0x%x", hr));
                if (SUCCEEDED(hr))
                {
                    data.m_szEventLogText = lpText;
                    CoTaskMemFree(lpText);
                }
            }

            // insert the entry in the list
            m_pScopePane->m_AppData[++m_pScopePane->m_lLastAllocated] = data;
            m_pScopePane->m_UpgradeIndex[GetUpgradeIndex(data.m_pDetails->pInstallInfo->PackageGuid)] = m_pScopePane->m_lLastAllocated;
            // prepare for the next itteration
            if (pObj)
            {
                pObj->Release();
                pObj = NULL;
            }
        }
    } while (n > 0);

    hr = GetRSOPUpgradedBy( &(m_pScopePane->m_AppData) );

cleanup:
    SysFreeString(strQuery);
    SysFreeString(strQueryLanguage);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}

void CResultPane::EnumerateResultPane(MMC_COOKIE cookie)
{
    // put up an hourglass (this could take a while)
    CHourglass hourglass;

    if (m_pScopePane) // make sure we've been initialized before we do any of this.
    {
        ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
        RESULTDATAITEM resultItem;
        memset(&resultItem, 0, sizeof(RESULTDATAITEM));

        // Right now we only have one folder and it only
        // contains a list of application packages so this is really simple.

        if ( ( m_pScopePane->m_AppData.begin() == m_pScopePane->m_AppData.end() ) ||
            m_pScopePane->m_fRSOP )  // test to see if the data has been initialized
        {
            HRESULT hr = S_OK;
            if (m_pScopePane->m_fRSOP)
            {
                // get the data from RSOP database
                hr = EnumerateRSoPData();
            }
            else
            {
                // get the data from ClassStore
                ASSERT(m_pScopePane->m_pIClassAdmin != NULL);
                IClassAdmin * pICA = m_pScopePane->m_pIClassAdmin;
                CSPLATFORM csPlatform;
                memset(&csPlatform, 0, sizeof(CSPLATFORM));

                IEnumPackage * pIPE = NULL;

                hr = pICA->EnumPackages(
                                    NULL,
                                    NULL,
                                    APPQUERY_ADMINISTRATIVE,
                                    NULL,
                                    NULL,
                                    &pIPE);
                if (SUCCEEDED(hr))
                {
                    PACKAGEDISPINFO * pi = new PACKAGEDISPINFO;
                    if (pi)
                    {
                        hr = pIPE->Reset();
                        while (SUCCEEDED(hr))
                        {
                            ULONG nceltFetched;

                            hr = pIPE->Next(1, pi, &nceltFetched);
                            if (nceltFetched)
                            {
                                PACKAGEDETAIL * pd = new PACKAGEDETAIL;
                                HRESULT hr = pICA->GetPackageDetails(pi->pszPackageName, pd);
                                if (SUCCEEDED(hr))
                                {
                                    CAppData data;
                                    data.m_pDetails = pd;

                                    data.InitializeExtraInfo();

                                    m_pScopePane->m_AppData[++m_pScopePane->m_lLastAllocated] = data;
                                    m_pScopePane->m_UpgradeIndex[GetUpgradeIndex(data.m_pDetails->pInstallInfo->PackageGuid)] = m_pScopePane->m_lLastAllocated;
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("GetPackageDetails failed with 0x%x"), hr));
                                    delete pd;
                                }
                            }
                            else
                            {
                                break;
                            }
                            ReleasePackageInfo(pi);
                        }
                        delete pi;
                    }
                    SAFE_RELEASE(pIPE);
                }
            }
            if (SUCCEEDED(hr))
            {
                hr = m_pScopePane->PopulateExtensions();
                if (SUCCEEDED(hr))
                {
                    hr = m_pScopePane->PopulateUpgradeLists();
                }
            }
        }
        if (_fVisible)
        {
            map<MMC_COOKIE, CAppData>::iterator i = m_pScopePane->m_AppData.begin();
            while (i != m_pScopePane->m_AppData.end())
            {
                if (!i->second.m_fHide)
                {
                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = i->second.GetImageIndex(m_pScopePane);
                    resultItem.lParam = i->first;
                    m_pResult->InsertItem(&resultItem);
                    i->second.m_fVisible = TRUE;
                    i->second.m_itemID = resultItem.itemID;
                }
                i++;
            }
            m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);
        }

    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CResultPane::OnFileDrop
//
//  Synopsis:   this functions handles files dropped into the MMC snapin
//
//  Arguments:
//          [in] lpDataObject : the data object being dropped
//
//  Returns:
//          TRUE  - all the dropped objects were successfully added
//          FALSE - at least some of the dropped objects could not be added
//
//  History:    5/20/1998  RahulTh  created
//
//  Notes: The dropped files are required to have a .msi extension
//
//---------------------------------------------------------------------------
BOOL CResultPane::OnFileDrop (LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    ASSERT (lpDataObject);

    int nFiles, index, nRequired, iSlashPos;
    STGMEDIUM medium;
    HDROP hDrop;
    TCHAR* szFileName;
    UINT cbSize;
    FORMATETC fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    CString szDisplayName;
    CString szSource;
    CString szExt;
    BOOL fRetVal = TRUE;
    BOOL fOneDropSucceeded = FALSE; //at least one file drop succeeded
    HRESULT hr;

    // always fail if we're in RSOP mode (we're read-only in this mode)
    if (m_pScopePane->m_fRSOP)
    {
        return FALSE;
    }

    //check if the dropped items support HDROP
    //for files dragged from explorer, this is always supported
    if (FAILED(hr = lpDataObject->GetData(&fe, &medium)))
    {
        return FALSE;
    }

    //the data object supports HDROP.
    //this means that files are being dragged & dropped from explorer.

    //crack open the data object to get the names of the files being dropped.
    hDrop = (HDROP)medium.hGlobal;
    //start with MAX_PATH, will work for most cases.
    //if not, we will increase buffer size based on need.
    //but we start with MAX_PATH in an attempt to minimize re-allocations
    szFileName = new TCHAR [cbSize = MAX_PATH];
    nFiles = ::DragQueryFile (hDrop, 0xFFFFFFFF, NULL, 0);

    for (index = 0; index < nFiles; index++)
    {
        //find out the size of the buffer required (including the terminating
        //NULL)
        nRequired = ::DragQueryFile (hDrop, index, NULL, 0) + 1;

        //expand the buffer if necessary. Note that we never contract it.
        //Saves code and time
        if (nRequired > cbSize)
        {
            delete [] szFileName;
            szFileName = new TCHAR [cbSize = nRequired];
        }
        //get the full filename of the file being dropped.
        ::DragQueryFile (hDrop, index, szFileName, cbSize);
#if 0
        // stevebl - gonna let any file through at this point.  If it isn't
        // a valid darwin file, AddMSIPackage will catch it and display an
        // appropriate error.

        //check the file extension
        if (!(GetCapitalizedExt(szFileName, szExt) && TEXT("MSI") == szExt))
        {
            //do we put up an error message here?
            fRetVal = FALSE;    //failed for this file. wrong extension
            continue;
        }
#endif
        //try to get a UNC path
        hr = GetUNCPath (szFileName, szSource);

        if (FAILED(hr))
        {
            CString sz;
            sz.LoadString (IDS_NO_UNIVERSAL_NAME);
            if (IDYES != ::MessageBox (m_pScopePane->m_hwndMainWindow, sz, szSource, MB_YESNO | MB_ICONEXCLAMATION))
                continue;
        }

        //now get the display name for the file.
        iSlashPos = szSource.ReverseFind ('\\');
        if (-1 == iSlashPos)
            szDisplayName = szSource;
        else
            szDisplayName = szSource.Mid (iSlashPos + 1);

        //check the file extension to see if it's a ZAP file
        if (GetCapitalizedExt(szFileName, szExt) && TEXT("ZAP") == szExt)
        {
            if (m_pScopePane->m_fMachine)
            {
                CString szText;
                CString szTitle;
                szText.LoadString(IDS_NO_ZAPS_ALLOWED);
                // only allow ZAP files to be deployed to users
                ::MessageBox(m_pScopePane->m_hwndMainWindow,
                             szText,
                             szTitle,
                             MB_OK | MB_ICONEXCLAMATION);
                hr = E_FAIL;
            }
            else
            {
                hr = m_pScopePane->AddZAPPackage (szSource, szDisplayName);
            }
        }
        else
        {
            hr = m_pScopePane->AddMSIPackage (szSource, szDisplayName);
        }
        if (SUCCEEDED(hr))
            fOneDropSucceeded = TRUE;
    }

    //notify the clients
    if (fOneDropSucceeded && m_pScopePane->m_pIGPEInformation)
    {
        if (FAILED(m_pScopePane->m_pIGPEInformation->PolicyChanged (m_pScopePane->m_fMachine,
                                                         TRUE, &guidExtension,
                                                         m_pScopePane->m_fMachine ? &guidMachSnapin
                                                                                  : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_pScopePane->m_hwndMainWindow);
        }
    }
    //keep the environment clean. Pick up your litter.
    delete [] szFileName;

    return fRetVal;
}

// This code is needed to ensure that property pages get cleaned up properly.
// This ensures that when the property sheet is closed all my of property
// pages that are associated with that property sheet will get deleted.
LPFNPSPCALLBACK _MMCHookProp;

UINT CALLBACK HookPropertySheetProp(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UINT i = _MMCHookProp(hwnd, uMsg, ppsp);
    switch (uMsg)
    {
    case PSPCB_RELEASE:
        delete (CPropertyPage *) ppsp->lParam;
        return TRUE;
    default:
        break;
    }
    return i;
}

LRESULT SetPropPageToDeleteOnClose(void * vpsp)
{
    HRESULT hr = MMCPropPageCallback(vpsp);
    if (SUCCEEDED(hr))
    {
        if (vpsp == NULL)
            return E_POINTER;

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)vpsp;

        if ((void*)psp->pfnCallback == (void*)HookPropertySheetProp)
            return E_UNEXPECTED;

        _MMCHookProp = psp->pfnCallback;

        psp->pfnCallback = HookPropertySheetProp;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\rsopsec.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rsopsec.cpp
//
//  Contents:   implementation used by the RSOP mode security pane
//
//  Classes:    CRSOPSecurityInfo
//
//  Functions:
//
//  History:    02-15-2000   stevebl   Created
//
//---------------------------------------------------------------------------


#include "precomp.hxx"

const
ACCESS_MASK
GENERIC_READ_MAPPING =    ((STANDARD_RIGHTS_READ)     | \
                           (ACTRL_DS_LIST)            | \
                           (ACTRL_DS_READ_PROP)       | \
                           (ACTRL_DS_LIST_OBJECT));

const
ACCESS_MASK
GENERIC_EXECUTE_MAPPING = ((STANDARD_RIGHTS_EXECUTE)  | \
                           (ACTRL_DS_LIST));

const
ACCESS_MASK
GENERIC_WRITE_MAPPING =   ((STANDARD_RIGHTS_WRITE)    | \
                           (ACTRL_DS_SELF)            | \
                           (ACTRL_DS_WRITE_PROP));

const
ACCESS_MASK
GENERIC_ALL_MAPPING =     ((STANDARD_RIGHTS_REQUIRED) | \
                           (ACTRL_DS_CREATE_CHILD)    | \
                           (ACTRL_DS_DELETE_CHILD)    | \
                           (ACTRL_DS_DELETE_TREE)     | \
                           (ACTRL_DS_READ_PROP)       | \
                           (ACTRL_DS_WRITE_PROP)      | \
                           (ACTRL_DS_LIST)            | \
                           (ACTRL_DS_LIST_OBJECT)     | \
                           (ACTRL_DS_CONTROL_ACCESS)  | \
                           (ACTRL_DS_SELF));

//The Following array defines the permission names for DS Key Objects
SI_ACCESS siDSAccesses[] =
{
    { NULL, DS_GENERIC_ALL,           MAKEINTRESOURCE(IDS_DS_GENERIC_ALL),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { NULL, DS_GENERIC_READ,          MAKEINTRESOURCE(IDS_DS_GENERIC_READ),       SI_ACCESS_GENERAL },
    { NULL, DS_GENERIC_WRITE,         MAKEINTRESOURCE(IDS_DS_GENERIC_WRITE),      SI_ACCESS_GENERAL },
    { NULL, ACTRL_DS_LIST,            MAKEINTRESOURCE(IDS_ACTRL_DS_LIST),         SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_LIST_OBJECT,     MAKEINTRESOURCE(IDS_ACTRL_DS_LIST_OBJECT),  SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_READ_PROP,       MAKEINTRESOURCE(IDS_ACTRL_DS_READ_PROP),    SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { NULL, ACTRL_DS_WRITE_PROP,      MAKEINTRESOURCE(IDS_ACTRL_DS_WRITE_PROP),   SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { NULL, DELETE,                   MAKEINTRESOURCE(IDS_ACTRL_DELETE),          SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_DELETE_TREE,     MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_TREE),  SI_ACCESS_SPECIFIC },
    { NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_ACTRL_READ_CONTROL),    SI_ACCESS_SPECIFIC },
    { NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_ACTRL_CHANGE_ACCESS),   SI_ACCESS_SPECIFIC },
    { NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_ACTRL_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { NULL, 0,                        MAKEINTRESOURCE(IDS_NO_ACCESS),             0 },
    { NULL, ACTRL_DS_SELF,            MAKEINTRESOURCE(IDS_ACTRL_DS_SELF),         SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_CONTROL_ACCESS,  MAKEINTRESOURCE(IDS_ACTRL_DS_CONTROL_ACCESS),SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_CREATE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { NULL, ACTRL_DS_DELETE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
};

/*
SI_INHERIT_TYPE siDSInheritTypes[] =
{
    { &GUID_NULL, 0,                                        MAKEINTRESOURCE(IDS_DS_CONTAINER_ONLY)     },
    { &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_DS_CONTAINER_SUBITEMS) },
    { &GUID_NULL, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, MAKEINTRESOURCE(IDS_DS_SUBITEMS_ONLY)      },
};
*/

STDMETHODIMP CRSOPSecurityInfo::QueryInterface(REFIID riid,
                                               LPVOID *ppv)
{
    if (IsEqualIID(riid, IID_ISecurityInformation) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CRSOPSecurityInfo::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRSOPSecurityInfo::Release()
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CRSOPSecurityInfo::MapGeneric(const GUID *pguidObjectType,
                                           UCHAR *pAceFlags,
                                           ACCESS_MASK *pMask)
{
    GENERIC_MAPPING gm;
    gm.GenericRead = GENERIC_READ_MAPPING;
    gm.GenericWrite = GENERIC_WRITE_MAPPING;
    gm.GenericExecute = GENERIC_EXECUTE_MAPPING;
    gm.GenericAll = GENERIC_ALL_MAPPING;
    MapGenericMask(pMask, &gm);
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    pObjectInfo->dwFlags = SI_READONLY | SI_ADVANCED | SI_SERVER_IS_DC;
    pObjectInfo->hInstance = ghInstance;
    pObjectInfo->pszServerName = NULL;
    pObjectInfo->pszObjectName = m_pData->m_pDetails->pszPackageName;
    pObjectInfo->pszPageTitle = NULL;
    memset(&pObjectInfo->guidObjectType, 0, sizeof(GUID));
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::GetSecurity(SECURITY_INFORMATION RequestedInformation,
                                            PSECURITY_DESCRIPTOR *ppSD,
                                            BOOL fDefault)
{
    HRESULT hr = S_OK;
    if (IsValidSecurityDescriptor(m_pData->m_psd))
    {
        ULONG nLength = GetSecurityDescriptorLength(m_pData->m_psd);

        *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, nLength);
        if (*ppSD != NULL)
            CopyMemory(*ppSD, m_pData->m_psd, nLength);
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppSD = NULL;
    }
    return hr;
}

STDMETHODIMP CRSOPSecurityInfo::SetSecurity(SECURITY_INFORMATION SecurityInformation,
                                            PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    return E_ACCESSDENIED;
}

STDMETHODIMP CRSOPSecurityInfo::GetAccessRights(const GUID * pguidObjectType,
                                                DWORD dwFlags,
                                                PSI_ACCESS * ppAccess,
                                                ULONG *pcAccesses,
                                                ULONG *piDefaultAccess)
{
    *ppAccess = siDSAccesses;
    *pcAccesses = sizeof(siDSAccesses)/sizeof(siDSAccesses[0]);
    *piDefaultAccess = 0;
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::GetInheritTypes(PSI_INHERIT_TYPE * ppInheritTypes,
                                                ULONG *pcInheritTypes)
{
    *ppInheritTypes = NULL;
    *pcInheritTypes = 0;
    return S_OK;
}

STDMETHODIMP CRSOPSecurityInfo::PropertySheetPageCallback(HWND hwnd,
                                                          UINT uMsg,
                                                          SI_PAGE_TYPE uPage)
{
    return S_FALSE; // prevents UI from displaying pop-ups
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\rsopsec.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rsopsec.h
//
//  Contents:   used in RSOP mode security pane
//
//  Classes:    CRSOPSecurityInfo
//
//  Functions:
//
//  History:    02-15-2000   stevebl   Created
//
//---------------------------------------------------------------------------


class CRSOPSecurityInfo : public ISecurityInformation
{
private:
    ULONG       m_cRef;
    CAppData *  m_pData;
public:
    CRSOPSecurityInfo(CAppData * pData) {m_pData = pData; m_cRef = 1;}
    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
                                                     LPVOID *ppvObj);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE MapGeneric(const GUID *pguidObjectType,
                                                 UCHAR *pAceFlags,
                                                 ACCESS_MASK *pMask);
    // *** ISecurityInformation methods ***
    virtual HRESULT STDMETHODCALLTYPE GetObjectInformation(PSI_OBJECT_INFO pObjectInfo);
    virtual HRESULT STDMETHODCALLTYPE GetSecurity(SECURITY_INFORMATION RequestedInformation,
                                                  PSECURITY_DESCRIPTOR *ppSecurityDescriptor, BOOL fDefault);
    virtual HRESULT STDMETHODCALLTYPE SetSecurity(SECURITY_INFORMATION SecurityInformation,
                                                  PSECURITY_DESCRIPTOR pSecurityDescriptor);
    virtual HRESULT STDMETHODCALLTYPE GetAccessRights(const GUID *pguidObjectType,
                                                      DWORD dwFlags, PSI_ACCESS *ppAccess,
                                                      ULONG *pcAccesses,
                                                      ULONG *piDefaultAccess);
    virtual HRESULT STDMETHODCALLTYPE GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                                      ULONG *pcInheritTypes);
    virtual HRESULT STDMETHODCALLTYPE PropertySheetPageCallback(HWND hwnd,
                                                                UINT uMsg,
                                                                SI_PAGE_TYPE uPage);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\rsoputil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.cpp
//
//  Contents:   helper functions for working with the RSOP databases
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "sddl.h"

//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(szData);
    hr = pInst->Put(szParam, 0, &var, 0);
    SysFreeString(var.bstrVal);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        delete [] szData;
        szData = NULL;
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            szData = (TCHAR *) OLEALLOC(sizeof(TCHAR) * (_tcslen(var.bstrVal) + 1));
            if (szData)
            {
                _tcscpy(szData, var.bstrVal);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        szData = "";
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            szData = var.bstrVal;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (bstrData)
    {
        SysFreeString(bstrData);
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        bstrData = SysAllocStringLen(var.bstrVal, SysStringLen(var.bstrVal));
        if (NULL == bstrData)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        fData = var.bVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        hrData = (HRESULT) var.lVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ulData = var.ulVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid)
{
    TCHAR * sz = NULL;
    memset(&guid, 0, sizeof(GUID));
    HRESULT hr = GetParameter(pInst, szParam, sz);
    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromString(sz, &guid);
    }
    if (sz)
    {
        OLESAFE_DELETE(sz);
    }
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    ui = 0;
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ui = (HRESULT) var.uiVal;
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of guids and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, GUID * &rgGuid)
{
    VARIANT var;
    HRESULT hr = S_OK;
    uiCount = 0;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgGuid = (GUID *)OLEALLOC(sizeof(GUID) * uiCount);
            if (rgGuid)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    hr = CLSIDFromString(rgData[ui], &rgGuid[ui]);
                    if (FAILED(hr))
                    {
                        return hr;
                    }
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of strings and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, TCHAR ** &rgszData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    uiCount = 0;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgszData = (TCHAR **)OLEALLOC(sizeof(TCHAR *) * uiCount);
            if (rgszData)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    OLESAFE_COPYSTRING(rgszData[ui], rgData[ui]);
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of CSPLATFORM objects and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, CSPLATFORM * &rgData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    uiCount = 0;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_I4))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgData = (CSPLATFORM *)OLEALLOC(sizeof(CSPLATFORM) * uiCount);
            if (rgData)
            {
                ULONG * rgulData = (ULONG *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    rgData[ui].dwPlatformId = VER_PLATFORM_WIN32_NT;
                    rgData[ui].dwVersionHi = 5;
                    rgData[ui].dwVersionLo = 0;
                    rgData[ui].dwProcessorArch = rgulData[ui];
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd)
{
    VARIANT var;
    HRESULT hr = S_OK;
    if (psd)
    {
        LocalFree(psd);
        psd = NULL;
    }
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        psd = (PSECURITY_DESCRIPTOR) LocalAlloc( LPTR, var.parray->rgsabound[0].cElements * sizeof( BYTE ) );

        if ( psd )
        {
            memcpy( psd, var.parray->pvData, var.parray->rgsabound[0].cElements * sizeof( BYTE ) );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (!IsValidSecurityDescriptor(psd))
        {
            LocalFree(psd);
            psd = NULL;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID, BSTR pLanguage,
                           LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for unicode query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);


    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        //
        // In this case, we cannot find the gpo -- it has most likely been deleted.  To give the user some
        // useful information, we will fall back to the guid.
        //
        *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpGPOID) + 1) * sizeof(TCHAR));

        if ( *pGPOName )
        {
            DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Using GPO guid for friendly name because GPO can't be found")));
            lstrcpy( *pGPOName, lpGPOID );
            hr = S_OK;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for GPO Name in GUID form")));
            hr = E_OUTOFMEMORY;
        }

        goto Exit;
    }

    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Save the name
    //

    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOFriendlyName: Failed to allocate memory for GPO Name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    lstrcpy (*pGPOName, varGPOName.bstrVal);

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}

HRESULT CStringFromWBEMTime(CString &szOut, BSTR bstrIn, BOOL fShortFormat)
{
    HRESULT hr = E_FAIL;
    WBEMTime wt(bstrIn);
    FILETIME ft;
    if (wt.GetFILETIME(&ft))
    {
        CTime t(ft);
        if (fShortFormat)
        {
            szOut = t.Format(TEXT("%x"));
        }
        else
        {
            szOut = t.Format(TEXT("%#c"));
        }
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\script.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       script.h
//
//  Contents:   Functions for working with Darwin files, both packages,
//              transforms and scripts.
//
//  Classes:
//
//  Functions:  BuildScriptAndGetActInfo
//
//  History:    1-14-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#define _NEW_
#include <vector>
using namespace std;

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey);
HRESULT BuildScriptAndGetActInfo(PACKAGEDETAIL & pd, BOOL bFileExtensionsOnly);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "safereg.hxx"


//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;
    ULONG   ulType;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszPathBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    lstrcpy(pwszPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
    }
    else if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\script.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       script.cpp
//
//  Contents:   Functions for working with Darwin files, both packages,
//              transforms and scripts.
//
//  Classes:
//
//  Functions:  BuildScriptAndGetActInfo
//
//  History:    1-14-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

//+--------------------------------------------------------------------------
//
//  Function:   RegDeleteTree
//
//  Synopsis:   deletes a registry key and all of its children
//
//  Arguments:  [hKey]     - handle to the key's parent
//              [szSubKey] - name of the key to be deleted
//
//  Returns:    ERROR_SUCCESS
//
//  History:    1-14-1998   stevebl   Moved from old project
//
//---------------------------------------------------------------------------

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKey(hKey, szSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    TCHAR szName[256];
    szName[0] = 0;
    while (ERROR_SUCCESS == RegEnumKey(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKey(hKey, szSubKey);
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildScriptAndGetActInfo
//
//  Synopsis:   Builds the script file and fills in the ACTINFO structure
//              member in the PACKAGEDETAIL structure.
//
//  Arguments:  [szScriptRoot] - [in] the subdirectory that the script file
//                                should be place in.
//              [pd]           - [in/out] package detail structure - see
//                                notes for complete list of fields that
//                                should be filled in and the list of fields
//                                that are set on return
//
//  Returns:    S_OK - success
//              <other> - error
//
//  Modifies:   all fields under pd.pActInfo (only on success)
//              also modifies pd.pInstallInfo->cScriptLen
//
//  History:    1-14-1998   stevebl   Created
//
//  Notes:      On input:
//              pd.cSources must be >= 1.
//              pd.pszSourceList[] contains the MSI package and the list of
//              (if any) transforms to be applied.
//              pd.pPlatformInfo should be completely filled in (only one
//              locale).
//              pd.pInstallInfo->pszScriptFile contains the name of the
//              script file to be generated.
//
//              On output:
//              The script file will be generated under the appropriate name
//              and in the appropriate directory.
//              pd.pActInfo will be completely filled in.
//
//---------------------------------------------------------------------------

HRESULT BuildScriptAndGetActInfo(PACKAGEDETAIL & pd, BOOL bFileExtensionsOnly)
{
    DebugMsg((DM_VERBOSE, TEXT("BuldScriptAndGetActInfo called with bFileExtensionsOnly == %u"), bFileExtensionsOnly));
    CHourglass hourglass;
    HRESULT hr;
    UINT uMsiStatus;
    LONG error;
    int i;
    CString szScriptPath = pd.pInstallInfo->pszScriptPath;
    CString szTransformList = L"";

    CClassCollection Classes( &pd );

    if (pd.cSources > 1)
    {
        CString szSource = pd.pszSourceList[0];
        int nChars = 1 + szSource.ReverseFind(L'\\');
        BOOL fTransformsAtSource = TRUE;
        for (i = 1; i < pd.cSources && TRUE == fTransformsAtSource; i++)
        {
            if (0 == wcsncmp(szSource, pd.pszSourceList[i], nChars))
            {
                // make sure there isn't a sub-path
                int n = nChars;
                while (0 != pd.pszSourceList[i][n] && TRUE == fTransformsAtSource)
                {
                    if (pd.pszSourceList[i][n] == L'\\')
                    {
                        fTransformsAtSource = FALSE;
                    }
                    n++;
                }
            }
            else
            {
                fTransformsAtSource = FALSE;
            }
        }
        if (fTransformsAtSource)
        {
            szTransformList = L"@";
        }
        else
        {
            szTransformList = L"|";
            nChars = 0;
        }
        for (i = 1; i < pd.cSources; i++)
        {
            if (i > 1)
            {
                szTransformList += L";";
            }
            szTransformList += &pd.pszSourceList[i][nChars];
        }
    }

    // disable MSI ui
    MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

    // build the script file

    TCHAR szTempPath[MAX_PATH];
    TCHAR szTempFileName[MAX_PATH];
    if (0 != GetTempPath(sizeof(szTempPath) / sizeof(szTempPath[0]), szTempPath))
    {
        if (0 == GetTempFileName(szTempPath, TEXT("ADE"), 0, szTempFileName))
        {
            goto Failure;
        }

        DWORD dwPlatform;

        if ( CAppData::Is64Bit( &pd ) )
        {
            dwPlatform = MSIARCHITECTUREFLAGS_IA64;
        }
        else
        {
            dwPlatform = MSIARCHITECTUREFLAGS_X86;
        }

        uMsiStatus = MsiAdvertiseProductEx(
            pd.pszSourceList[0],
            szTempFileName,
            szTransformList,
            LANGIDFROMLCID(pd.pPlatformInfo->prgLocale[0]),
            dwPlatform,
            0);

        if (uMsiStatus)
        {
            DeleteFile(szTempFileName);
            DebugMsg((DM_WARNING, TEXT("MsiAdvertiseProduct failed with %u"), uMsiStatus));
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERATESCRIPT_ERROR, HRESULT_FROM_WIN32(uMsiStatus), pd.pszSourceList[0]);
            // an error occurred
            return HRESULT_FROM_WIN32((long)uMsiStatus);
        }

        // fill in the ActInfo

        hr = Classes.GetClasses( bFileExtensionsOnly );

        if ( SUCCEEDED( hr ) )
        {
            if (!CopyFile(szTempFileName, szScriptPath, FALSE))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DeleteFile(szTempFileName);
                return hr;
            }
        }
        DeleteFile(szTempFileName);
    }
    else
    {
Failure:
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\scope.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scope.cpp
//
//  Contents:   implementation of the scope pane
//
//  Classes:    CScopePane
//
//  History:    03-14-1998   stevebl   Created
//              05-20-1998   RahulTh   added GetUNCPath and modified Command to
//                                     use this function
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <wbemcli.h>
#include "rsoputil.h"
#include <list>

// Comment this line to stop trying to set the main snapin icon in the
// scope pane.
#define SET_SCOPE_ICONS 1

// Un-comment the next line to persist snap-in related data.  (This really
// shouldn't be necessary since I get all my info from my parent anyway.)
// #define PERSIST_DATA 1

///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CScopePane);

CScopePane::CScopePane()
{
#if DBG
    dbg_cRef = 0;
#endif
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopePane);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::CScopePane  this=%08x ref=%u"), this, dbg_cRef));

    m_pToolDefs = NULL;
    m_pTracking = NULL;
    m_pCatList = NULL;
    m_pFileExt = NULL;
    m_bIsDirty = FALSE;

    m_hwndMainWindow = NULL;
    m_fMachine = FALSE;
    m_fRSOP = FALSE;
    m_iViewState = IDM_WINNER;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_pIClassAdmin = NULL;
    m_pIPropertySheetProvider = NULL;
    m_fLoaded = FALSE;
    m_fExtension = FALSE;
    m_pIGPEInformation = NULL;
    m_pIRSOPInformation = NULL;
    m_dwRSOPFlags = 0;
    m_lLastAllocated = 0;
    m_ToolDefaults.NPBehavior = NP_PUBLISHED;
    m_ToolDefaults.fUseWizard = TRUE;
    m_ToolDefaults.fCustomDeployment = FALSE;
    m_ToolDefaults.UILevel = INSTALLUILEVEL_FULL;
    m_ToolDefaults.szStartPath = L"";   // UNDONE - need to come up with a
                                        // good default setting for this
    m_ToolDefaults.iDebugLevel = 0;
    m_ToolDefaults.fShowPkgDetails = 0;
    m_ToolDefaults.nUninstallTrackingMonths = 12;
    m_ToolDefaults.fUninstallOnPolicyRemoval = FALSE;
    m_ToolDefaults.fZapOn64 = FALSE;
    m_ToolDefaults.f32On64 = TRUE;
    m_ToolDefaults.fExtensionsOnly = TRUE;
    m_CatList.cCategory = 0;
    m_CatList.pCategoryInfo = NULL;
    m_fBlockAddPackage = FALSE;
    m_fDisplayedRsopARPWarning = FALSE;
    
}

CScopePane::~CScopePane()
{

    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopePane);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::~CScopePane  this=%08x ref=%u"), this, dbg_cRef));
    ClearCategories();
    ASSERT(m_pScope == NULL);
    ASSERT(CResultPane::lDataObjectRefCount == 0);
}
#include <msi.h>

STDMETHODIMP CScopePane::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pScope));
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IPropertySheetProvider,
                        (void **)&m_pIPropertySheetProvider);
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);


#ifdef SET_SCOPE_ICONS
    LPIMAGELIST lpScopeImage;
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(hr == S_OK);

    // Load the bitmaps from the dll
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));
    SAFE_RELEASE(lpScopeImage);
#endif

    // get the main window
    hr = m_pConsole->GetMainWindow(&m_hwndMainWindow);
    ASSERT(hr == S_OK);
    return S_OK;
}

void CScopePane::RemoveResultPane(CResultPane * pRP)
{
    m_sResultPane.erase(pRP);
}

STDMETHODIMP CScopePane::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::CreateComponent  this=%08x ppComponent=%08x."), this, ppComponent));

    CComObject<CResultPane>* pObject;
    CComObject<CResultPane>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    DebugMsg((DM_VERBOSE, TEXT("CScopePane::CreateComponent  pObject=%08x."), pObject));

    m_sResultPane.insert(pObject);

    // Store IComponentData
    pObject->SetIComponentData(this);
    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

HRESULT CScopePane::TestForRSoPData(BOOL * pfPolicyFailed)
{
    *pfPolicyFailed = FALSE;
    HRESULT hr = S_OK;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strNamespace = SysAllocString(m_szRSOPNamespace);
    BSTR strObject = SysAllocString(TEXT("RSOP_ExtensionStatus.extensionGuid=\"{c6dc5466-785a-11d2-84d0-00c04fb169f7}\""));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementPolicySetting"));
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: CoCreateInstance failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pLocator->ConnectServer failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pNamespace->ExecQuery failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pEnum->Next failed with 0x%x"), hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    if (n == 0)
    {
        // there's no data here
        hr = E_FAIL;
        goto cleanup;
    }
    if (pObj)
    {
        pObj->Release();
        pObj=NULL;
    }

    // check for failed settings
    hr = pNamespace->GetObject(strObject,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pObj,
                          NULL);
    DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: pNamespace->GetObject failed with 0x%x"), hr));
    if (SUCCEEDED(hr))
    {
        HRESULT hrStatus;
        hr = GetParameter(pObj,
                          TEXT("error"),
                          hrStatus);
        DebugReportFailure(hr, (DM_WARNING, TEXT("TestForRSoPData: GetParameter(\"error\") failed with 0x%x"), hr));
        if (SUCCEEDED(hr))
        {
            *pfPolicyFailed = hrStatus != 0;
        }
    }
cleanup:
    SysFreeString(strObject);
    SysFreeString(strQuery);
    SysFreeString(strQueryLanguage);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}


STDMETHODIMP CScopePane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        SaveToolDefaults();
        hr = OnProperties(param);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
        MMC_COOKIE cookie = 0;
        if (pInternal != NULL)
        {
            cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
        }
        else
        {
            // only way we could not be able to extract our own format is if we're operating as an extension
            m_fExtension = TRUE;
        }

        if (m_fRSOP)
        {
            if (m_pIRSOPInformation == NULL)
            {
                WCHAR szBuffer[MAX_DS_PATH];
                m_fRSOPEnumerate = FALSE;
                IRSOPInformation * pIRSOPInformation;
                hr = lpDataObject->QueryInterface(IID_IRSOPInformation,
                                reinterpret_cast<void**>(&pIRSOPInformation));
                if (SUCCEEDED(hr))
                {
                    m_pIRSOPInformation = pIRSOPInformation;
                    m_pIRSOPInformation->AddRef();

                    hr = m_pIRSOPInformation->GetFlags(&m_dwRSOPFlags);
                    if (SUCCEEDED(hr))
                    {
                        /*  extract the namespace here */
                        hr = m_pIRSOPInformation->GetNamespace(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                        if (SUCCEEDED(hr))
                        {
                            m_szRSOPNamespace = szBuffer;
                            // check to be sure that there is data to show in the RSoP database
                            if SUCCEEDED(TestForRSoPData(&m_fRSOPPolicyFailed))
                                m_fRSOPEnumerate = TRUE;
                        }
                        pIRSOPInformation->Release();
                    }
                }
            }
        }
        else
        {
            if (m_pIGPEInformation == NULL)
            {
                IGPEInformation * pIGPEInformation;
                hr = lpDataObject->QueryInterface(IID_IGPEInformation,
                                reinterpret_cast<void**>(&pIGPEInformation));
                if (SUCCEEDED(hr))
                {
                    GROUP_POLICY_OBJECT_TYPE gpoType;
                    hr = pIGPEInformation->GetType(&gpoType);
                    if (SUCCEEDED(hr))
                    {
                        if (gpoType == GPOTypeDS)
                        {
                            WCHAR szBuffer[MAX_DS_PATH];
                            do
                            {
                                hr = pIGPEInformation->GetDSPath(GPO_SECTION_ROOT, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                                if (FAILED(hr))
                                {
                                    break;
                                }
                                m_szGPO = szBuffer;
                                hr = pIGPEInformation->GetDisplayName(szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                                if (FAILED(hr))
                                {
                                    break;
                                }
                                m_szGPODisplayName = szBuffer;
                                hr = pIGPEInformation->GetDSPath(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                                if (FAILED(hr))
                                {
                                    break;
                                }
                                m_pIGPEInformation = pIGPEInformation;
                                m_pIGPEInformation->AddRef();
                                m_szLDAP_Path = szBuffer;
                                hr = pIGPEInformation->GetFileSysPath(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));

                                if (FAILED(hr)) break;
                                m_szGPT_Path = szBuffer;

                                // Here we get the domain name from the GPT_Path.
                                // The domain name is the very first element in
                                // the path so this is quite trivial.
                                m_szDomainName = &((LPCTSTR)m_szGPT_Path)[2]; // skip the "\\"
                                m_szDomainName = m_szDomainName.SpanExcluding(L"\\");

                                m_szGPT_Path += L"\\Applications";
                                hr = InitializeADE();
                                LoadToolDefaults();
                                if (SUCCEEDED(hr))
                                {
                                    // cleanup archived records in the class store
                                    FILETIME ft;
                                    SYSTEMTIME st;
                                    // get current time
                                    GetSystemTime(&st);
                                    // convert it to a FILETIME value
                                    SystemTimeToFileTime(&st, &ft);
                                    // subtract the right number of days
                                    LARGE_INTEGER li;
                                    li.LowPart = ft.dwLowDateTime;
                                    li.HighPart = ft.dwHighDateTime;
                                    li.QuadPart -= ONE_FILETIME_DAY * (((LONGLONG)m_ToolDefaults.nUninstallTrackingMonths * 365)/12);
                                    ft.dwLowDateTime = li.LowPart;
                                    ft.dwHighDateTime = li.HighPart;
                                    // tell the CS to clean up anything older
                                    m_pIClassAdmin->Cleanup(&ft);
                                }
                                else
                                {
                                    // we can still continue even if
                                    // initialization failed provided
                                    // that the reason it failed is that
                                    // the ClassStore object doesn't exist.
                                    if (CS_E_OBJECT_NOTFOUND == hr)
                                    {
                                        hr = S_OK;
                                    }
                                    else
                                    {
                                        // report error
                                        LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_INIT_FAILED, hr);
                                    }
                                }
                            } while (0);
                        }
                        else
                        {
                            // force this to fail
                            hr = E_FAIL;
                        }
                    }
                    pIGPEInformation->Release();
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            switch(event)
            {
            case MMCN_EXPAND:
                {
                    hr = OnExpand(cookie, arg, param);
                }
                break;

            case MMCN_SELECT:
                hr = OnSelect(cookie, arg, param);
                break;

            case MMCN_CONTEXTMENU:
                hr = OnContextMenu(cookie, arg, param);
                break;

            case MMCN_REFRESH:
                hr = Command(IDM_REFRESH, lpDataObject);
                break;

            default:
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CScopePane::Destroy()
{
    // Delete enumerated scope items
    DeleteList();

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);
    SAFE_RELEASE(m_pIClassAdmin);
    SAFE_RELEASE(m_pIPropertySheetProvider);
    SAFE_RELEASE(m_pIGPEInformation);
    SAFE_RELEASE(m_pIRSOPInformation);

    return S_OK;
}

STDMETHODIMP CScopePane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    pObject->m_fMachine = m_fMachine;
    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStreamInit interface members

STDMETHODIMP CScopePane::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    if (m_fRSOP)
    {
        if (m_fMachine)
            *pClassID = CLSID_RSOP_MachineSnapin;
        else
            *pClassID = CLSID_RSOP_Snapin;
    }
    else
    {
        if (m_fMachine)
            *pClassID = CLSID_MachineSnapin;
        else
            *pClassID = CLSID_Snapin;
    }

    return S_OK;
}

STDMETHODIMP CScopePane::IsDirty()
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CScopePane::Load(IStream *pStm)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // Read the string
    TCHAR psz[MAX_DS_PATH];
    ULONG nBytesRead;
    ULONG cb;
    HRESULT hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
    if (SUCCEEDED(hr))
    {
        hr = pStm->Read(psz, cb, &nBytesRead);
        if (SUCCEEDED(hr))
        {
            if (cb > MAX_DS_PATH * sizeof(TCHAR))
            {
                return E_FAIL;
            }
            m_szLDAP_Path = psz;

            hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
            if (SUCCEEDED(hr))
            {
                if (cb > MAX_DS_PATH * sizeof(TCHAR))
                {
                    return E_FAIL;
                }
                hr = pStm->Read(psz, cb, &nBytesRead);

                if (SUCCEEDED(hr))
                {
                    m_szGPT_Path = psz;
                    m_fLoaded = TRUE;
                    ClearDirty();
                    LoadToolDefaults();
                }
            }
        }
    }
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
#else
    return S_OK;
#endif
}

STDMETHODIMP CScopePane::Save(IStream *pStm, BOOL fClearDirty)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // Write the string
    ULONG nBytesWritten;
    ULONG cb = (m_szLDAP_Path.GetLength() + 1) * sizeof(TCHAR);
    HRESULT hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szLDAP_Path, cb, &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    cb = (m_szGPT_Path.GetLength() + 1) * sizeof(TCHAR);
    hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szGPT_Path, cb, &nBytesWritten);

    if (FAILED(hr))
        return STG_E_CANTSAVE;
#endif
    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CScopePane::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
#ifdef PERSIST_DATA
    ASSERT(pcbSize);

    ULONG cb = (m_szLDAP_Path.GetLength() + m_szGPT_Path.GetLength() + 2) * sizeof(TCHAR) + 2 * sizeof(ULONG);
    // Set the size of the string to be saved
#else
    ULONG cb = 0;
#endif
    ULISet32(*pcbSize, cb);

    return S_OK;
}

STDMETHODIMP CScopePane::InitNew(void)
{
    return S_OK;
}

void CScopePane::LoadToolDefaults()
{
    CString szFileName = m_szGPT_Path;
    szFileName += L"\\";
    szFileName += CFGFILE;
    FILE * f = _wfopen(szFileName, L"rt");
    if (f)
    {
        WCHAR sz[256];
        CString szData;
        CString szKey;
        while (fgetws(sz, 256, f))
        {
            szData = sz;
            szKey = szData.SpanExcluding(L"=");
            szData = szData.Mid(szKey.GetLength()+1);
            szData.TrimRight();
            szData.TrimLeft();
            szKey.TrimRight();
            if (0 == szKey.CompareNoCase(KEY_NPBehavior))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.NPBehavior);
            }
            else if (0 == szKey.CompareNoCase(KEY_fUseWizard))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fUseWizard);
            }
            else if (0 == szKey.CompareNoCase(KEY_fCustomDeployment))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fCustomDeployment);
            }
            else if (0 == szKey.CompareNoCase(KEY_UILevel))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.UILevel);
            }
            else if (0 == szKey.CompareNoCase(KEY_szStartPath))
            {
                m_ToolDefaults.szStartPath = szData;
            }
            else if (0 == szKey.CompareNoCase(KEY_nUninstallTrackingMonths))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.nUninstallTrackingMonths);
            }
            else if (0 == szKey.CompareNoCase(KEY_iDebugLevel))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.iDebugLevel);
            }
            else if (0 == szKey.CompareNoCase(KEY_fShowPkgDetails))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fShowPkgDetails);
            }
            else if (0 == szKey.CompareNoCase(KEY_fUninstallOnPolicyRemoval))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fUninstallOnPolicyRemoval);
            }
            else if (0 == szKey.CompareNoCase(KEY_f32On64))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.f32On64);
            }
            else if (0 == szKey.CompareNoCase(KEY_fZapOn64))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fZapOn64);
            }
            else if (0 == szKey.CompareNoCase(KEY_fExtensionsOnly))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fExtensionsOnly);
            }
        }
        fclose(f);
    }
}

void CScopePane::SaveToolDefaults()
{
    CString szFileName = m_szGPT_Path;
    szFileName += L"\\";
    szFileName += CFGFILE;
    FILE * f = _wfopen(szFileName, L"wt");
    if (f)
    {
        fwprintf(f, L"%s=%i\n", KEY_NPBehavior, m_ToolDefaults.NPBehavior);
        fwprintf(f, L"%s=%i\n", KEY_fUseWizard, m_ToolDefaults.fUseWizard);
        fwprintf(f, L"%s=%i\n", KEY_fCustomDeployment, m_ToolDefaults.fCustomDeployment);
        fwprintf(f, L"%s=%i\n", KEY_UILevel, m_ToolDefaults.UILevel);
        fwprintf(f, L"%s=%s\n", KEY_szStartPath, m_ToolDefaults.szStartPath);
        fwprintf(f, L"%s=%i\n", KEY_nUninstallTrackingMonths, m_ToolDefaults.nUninstallTrackingMonths);
        fwprintf(f, L"%s=%i\n", KEY_fUninstallOnPolicyRemoval, m_ToolDefaults.fUninstallOnPolicyRemoval);
        fwprintf(f, L"%s=%i\n", KEY_f32On64, m_ToolDefaults.f32On64);
        fwprintf(f, L"%s=%i\n", KEY_fZapOn64, m_ToolDefaults.fZapOn64);
        fwprintf(f, L"%s=%i\n", KEY_fExtensionsOnly, m_ToolDefaults.fExtensionsOnly);
        if (m_ToolDefaults.iDebugLevel > 0)
        {
            fwprintf(f, L"%s=%i\n", KEY_iDebugLevel, m_ToolDefaults.iDebugLevel);
        }
        if (m_ToolDefaults.fShowPkgDetails > 0)
        {
            fwprintf(f, L"%s=%i\n", KEY_fShowPkgDetails, m_ToolDefaults.fShowPkgDetails);
        }
        fclose(f);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetClassStoreName
//
//  Synopsis:   Gets the name of the class store from the DS.
//              If the name isn't stored under the "defaultClassStore"
//              property then the name "CN = Class Store" is used and the
//              property is set.
//
//  Arguments:  [sz]        - [out] name of the class store
//              [fCreateOK] - [in] TRUE if the class store is to be created
//                             if it doesn't already exist.  Otherwise this
//                             routine fails if the class store isn't found.
//
//  Returns:    S_OK on success
//
//  History:    2-17-1998   stevebl   Created
//
//  Notes:      Assumes m_szLDAP_Path contains the path to the DS object.
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetClassStoreName(CString &sz, BOOL fCreateOK)
{
    if (m_fRSOP)
    {
        return E_UNEXPECTED;
    }
    HRESULT hr;
    LPOLESTR szCSPath;
    hr = CsGetClassStorePath((LPOLESTR)((LPCOLESTR)m_szLDAP_Path), &szCSPath);
    if (SUCCEEDED(hr))
    {
        sz = szCSPath;
        OLESAFE_DELETE(szCSPath);
    }
    else
    {
        if (fCreateOK)
        {
            // set sz to the default setting and save the path
            IADsPathname * pADsPathname = NULL;
            hr = CoCreateInstance(CLSID_Pathname,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname,
                                  (LPVOID*)&pADsPathname);

            if (FAILED(hr))
            {
                return hr;
            }

            hr = pADsPathname->Set((LPOLESTR)((LPCOLESTR)m_szLDAP_Path), ADS_SETTYPE_FULL);
            if (FAILED(hr))
            {
                pADsPathname->Release();
                return hr;
            }

            hr = pADsPathname->AddLeafElement(L"CN=Class Store");
            if (FAILED(hr))
            {
                pADsPathname->Release();
                return hr;
            }

            BSTR bstr;

            hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);

            pADsPathname->Release();
            if (FAILED(hr))
            {
                return hr;
            }

            sz = bstr;
            SysFreeString(bstr);

            // This has to be here becuase CsSetClassStorePath will fail if the
            // class store doesn't already exist.
            hr = CsCreateClassStore((LPOLESTR)((LPCOLESTR)sz));
            if (FAILED(hr))
            {
                // Changed to CS_E_OBJECT_ALREADY_EXISTS.
                // I check for both ERROR_ALREAD_EXISTS and CS_E_OBJECT_ALREADY_EXISTS
                // just to be safe.
                if ((hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) && (hr != CS_E_OBJECT_ALREADY_EXISTS))
                {
                    return hr;
                }
            }
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetPackageDSPath
//
//  Synopsis:   gets the path to an individual package's DS object
//
//  Arguments:  [szPath]        - [out] LDAP path to the package
//              [szPackageName] - [in] name of the package
//
//  Returns:    S_OK on success
//
//  History:    3-26-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetPackageDSPath(CString &szPath, LPOLESTR szPackageName)
{
#if 1
    LPOLESTR sz;
    HRESULT hr = m_pIClassAdmin->GetDNFromPackageName(szPackageName, &sz);

    if (FAILED(hr))
    {
        return hr;
    }

    szPath = sz;
    OLESAFE_DELETE(sz);
#else
    HRESULT hr = GetClassStoreName(szPath, FALSE);

    if (FAILED(hr))
    {
        return hr;
    }

    // set sz to the default setting and save the path
    IADsPathname * pADsPathname = NULL;
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = pADsPathname->Set((LPOLESTR)((LPCOLESTR)szPath), ADS_SETTYPE_FULL);
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    hr = pADsPathname->AddLeafElement(L"CN=Packages");
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    CString sz = L"CN=";
    sz+= szPackageName;
    hr = pADsPathname->AddLeafElement((LPOLESTR)((LPCOLESTR)sz));
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    BSTR bstr;

    hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);

    pADsPathname->Release();
    if (FAILED(hr))
    {
        return hr;
    }

    szPath = bstr;
    SysFreeString(bstr);
#endif
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::GetClassStore
//
//  Synopsis:   gets the IClassAdmin interface and creates a class store if
//              it doesn't already exist.
//
//  Arguments:  [fCreateOK] - TRUE if the Class Store should be created if
//                             it doesn't already exist.
//
//  Returns:
//
//  Modifies:   m_pIClassAdmin
//
//  Derivation:
//
//  History:    2-11-1998   stevebl   Created
//
//  Notes:      Assumes m_szLDAP_Path contains the path to the DS object
//
//---------------------------------------------------------------------------

HRESULT CScopePane::GetClassStore(BOOL fCreateOK)
{
    HRESULT hr;
    CString szCSPath;
    hr = GetClassStoreName(szCSPath, fCreateOK);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&m_pIClassAdmin);
    if (FAILED(hr) && fCreateOK)
    {
        // Sometimes we can get into this wierd state where
        // GetClassStoreName was able to create a entry for the class store
        // name but it wasn't able to actually create the class store.  This
        // should handle that special case.
        // Try and create it here and then bind to it again.
        hr = CsCreateClassStore((LPOLESTR)((LPCOLESTR)szCSPath));
        if (FAILED(hr))
        {
            // Changed to CS_E_OBJECT_ALREADY_EXISTS.
            // I check for both ERROR_ALREAD_EXISTS and CS_E_OBJECT_ALREADY_EXISTS
            // just to be safe.
            // I'll check for both just to be safe.
            if ((hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) && (hr != CS_E_OBJECT_ALREADY_EXISTS))
            {
                return hr;
            }
        }
        hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&m_pIClassAdmin);
    }
    return hr;
}

UINT CScopePane::CreateNestedDirectory (LPTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        SetLastError(ERROR_INVALID_DATA);
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    return 0;

}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CScopePane::OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}


HRESULT CScopePane::OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(cookie,
            param);
    }

    return S_OK;
}

HRESULT CScopePane::OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}

HRESULT CScopePane::OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CScopePane::OnProperties(LPARAM param)
{
    if (param == NULL)
    {
        return S_OK;
    }

    ASSERT(param != NULL);

    return S_OK;
}


void CScopePane::EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    if (m_fRSOP && !m_fRSOPEnumerate)
    {
        // don't allow an empty RSOP database to enumerate the snapin
        return;
    }
    // make sure that the result pane gets enumerated once
    // so that internal structures get initialized.

    // We only have one folder so this is really easy.
    if (cookie != NULL)
        return ;

    if (m_fExtension)
    {
        // if we're an extension then add a root folder to hang everything off of
        SCOPEDATAITEM * m_pScopeItem = new SCOPEDATAITEM;
        memset(m_pScopeItem, 0, sizeof(SCOPEDATAITEM));
        m_pScopeItem->mask = SDI_STR | SDI_PARAM | SDI_CHILDREN;
#ifdef SET_SCOPE_ICONS
        m_pScopeItem->mask |= SDI_IMAGE | SDI_OPENIMAGE;
        if (m_fRSOP && m_fRSOPPolicyFailed)
        {
            m_pScopeItem->nImage = IMG_CLOSED_FAILED;
            m_pScopeItem->nOpenImage = IMG_OPEN_FAILED;
        }
        else
        {
            m_pScopeItem->nImage = IMG_CLOSEDBOX;
            m_pScopeItem->nOpenImage = IMG_OPENBOX;
        }
#endif
        m_pScopeItem->relativeID = pParent;
        m_pScopeItem->displayname = (unsigned short *)-1;
        m_pScopeItem->lParam = -1; // made up cookie for my main folder
        m_pScope->InsertItem(m_pScopeItem);
    }
    if (m_pIClassAdmin)
    {
        // if there's no IClassAdmin then there's nothing to enumerate
        set <CResultPane *>::iterator i;
        for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
        {
            (*i)->EnumerateResultPane(cookie);
        }
    }
}

STDMETHODIMP CScopePane::GetSnapinDescription(LPOLESTR * lpDescription)
{
    OLESAFE_COPYSTRING(*lpDescription, L"description");
    return S_OK;
}

STDMETHODIMP CScopePane::GetProvider(LPOLESTR * lpName)
{
    OLESAFE_COPYSTRING(*lpName, L"provider");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinVersion(LPOLESTR * lpVersion)
{
    OLESAFE_COPYSTRING(*lpVersion, L"version");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinImage(HICON * hAppIcon)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetStaticFolderImage(HBITMAP * hSmallImage,
                             HBITMAP * hSmallImageOpen,
                             HBITMAP * hLargeImage,
                             COLORREF * cMask)
{
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CScopePane::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    if (m_fRSOP)
    {
        ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\RSOP.chm::/RSPintro.htm",
                                   lpHelpFile, MAX_PATH);
    }
    else
    {
        ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\SPConcepts.chm::/ADE.htm",
                                   lpHelpFile, MAX_PATH);
    }

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}

void CScopePane::DeleteList()
{
    return;
}

STDMETHODIMP CScopePane::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    if (pScopeDataItem->lParam == -1)
    {
        m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
    }
    else
    {
        ASSERT(pScopeDataItem->mask == TVIF_TEXT);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_AppData[pScopeDataItem->lParam].m_pDetails->pszPackageName);
    }

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CScopePane::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

// Scope item property pages:
STDMETHODIMP CScopePane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    HRESULT hr;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);

    if (!pInternal)
    {
        return E_UNEXPECTED;
    }

    MMC_COOKIE cookie = pInternal->m_cookie;
    FREE_INTERNAL(pInternal);

    //
    // make sure we have an up-to-date categories list
    //
    ClearCategories();
    if (m_fRSOP)
    {
        GetRSoPCategories();
    }
    else
    {
        hr = CsGetAppCategories(&m_CatList);
        if (FAILED(hr))
        {
            // report it
            LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GETCATEGORIES_ERROR, hr, NULL);

            // Since failure only means the categories list will be
            // empty, we'll proceed as if nothing happened.

            hr = S_OK;
        }
    }

    //
    // Create the ToolDefs property page
    //
    m_pToolDefs = new CToolDefs();
    m_pToolDefs->m_ppThis = &m_pToolDefs;
    m_pToolDefs->m_pToolDefaults = & m_ToolDefaults;
    m_pToolDefs->m_cookie = cookie;
    m_pToolDefs->m_hConsoleHandle = handle;
    m_pToolDefs->m_fMachine = m_fMachine;
    hr = SetPropPageToDeleteOnClose(&m_pToolDefs->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hToolDefs = CreateThemedPropertySheetPage(&m_pToolDefs->m_psp);
        if (hToolDefs == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hToolDefs);
    }


    //
    // Create the ToolAdvDefs property page
    //
    m_pToolAdvDefs = new CToolAdvDefs();
    m_pToolAdvDefs->m_ppThis = &m_pToolAdvDefs;
    m_pToolAdvDefs->m_pToolDefaults = & m_ToolDefaults;
    m_pToolAdvDefs->m_cookie = cookie;
    m_pToolAdvDefs->m_hConsoleHandle = handle;
    m_pToolAdvDefs->m_fMachine = m_fMachine;
    hr = SetPropPageToDeleteOnClose(&m_pToolAdvDefs->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hToolAdvDefs = CreateThemedPropertySheetPage(&m_pToolAdvDefs->m_psp);
        if (hToolAdvDefs == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hToolAdvDefs);
    }

    CString szCSPath;
    hr = GetClassStoreName(szCSPath, FALSE);
    if (SUCCEEDED(hr) && m_pIClassAdmin)
    {
        //
        // Create the FileExt property page
        //
        m_pFileExt = new CFileExt();
        m_pFileExt->m_ppThis = &m_pFileExt;
        m_pFileExt->m_pScopePane = this;

        // no longer need to marshal this, just set it
        m_pFileExt->m_pIClassAdmin = m_pIClassAdmin;
        m_pIClassAdmin->AddRef();

        hr = SetPropPageToDeleteOnClose(&m_pFileExt->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hFileExt = CreateThemedPropertySheetPage(&m_pFileExt->m_psp);
            if (hFileExt == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hFileExt);
        }
    }
    else
    {
        //
        // Create the FileExt property page without an IClassAdmin
        //
        m_pFileExt = new CFileExt();
        m_pFileExt->m_ppThis = &m_pFileExt;
        m_pFileExt->m_pScopePane = this;
        hr = SetPropPageToDeleteOnClose(&m_pFileExt->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hFileExt = CreateThemedPropertySheetPage(&m_pFileExt->m_psp);
            if (hFileExt == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hFileExt);
        }
    }

    //
    // Create the CatList property page
    //

    m_pCatList = new CCatList();
    m_pCatList->m_szDomainName = m_szDomainName;
    m_pCatList->m_ppThis = &m_pCatList;
    m_pCatList->m_pScopePane = this;
    m_pCatList->m_fRSOP = m_fRSOP;
    hr = SetPropPageToDeleteOnClose(&m_pCatList->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hCatList = CreateThemedPropertySheetPage(&m_pCatList->m_psp);
        if (hCatList == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hCatList);
    }
#ifdef DIGITAL_SIGNATURES
    //
    // Create the Digital Signatures property page
    //
    m_pSignatures = new CSignatures();
    m_pSignatures->m_ppThis = &m_pSignatures;
    m_pSignatures->m_pScopePane = this;
    m_pSignatures->m_fRSOP = m_fRSOP;
    m_pSignatures->m_pIGPEInformation = m_pIGPEInformation;
    hr = SetPropPageToDeleteOnClose(&m_pSignatures->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hSignatures = CreateThemedPropertySheetPage(&m_pSignatures->m_psp);
        if (hSignatures == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hSignatures);
    }
#endif // DIGITAL_SIGNATURES

    return S_OK;
}

// Scope item property pages:
STDMETHODIMP CScopePane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // Look at the data object and see if it an item that we want to have a property sheet
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal)
    {
        // The main Software Installation node only has a property sheet if
        // we are not in RSOP mode.
        if ((m_fRSOP != TRUE) && (CCT_SCOPE == pInternal->m_type))
        {
            FREE_INTERNAL(pInternal);
            return S_OK;
        }

        FREE_INTERNAL(pInternal);
    }
    return S_FALSE;
}

BOOL CScopePane::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal)
    {
        if (pInternal->m_type == CCT_SCOPE)
            bResult = TRUE;

        FREE_INTERNAL(pInternal);
    }

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CScopePane::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              LONG * pInsertionAllowed)
{
    HRESULT hr = S_OK;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (!pInternal)
    {
        return E_UNEXPECTED;
    }

    CONTEXTMENUITEM menuitem;
    WCHAR szName[256];
    WCHAR szStatus[256];
    menuitem.strName = szName;
    menuitem.strStatusBarText = szStatus;
    menuitem.fFlags = 0;
    menuitem.fSpecialFlags = 0;

    do {

        if ((m_fRSOP != TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_NEW))
        {
            //
            // Add Application menu item
            //
            ::LoadString(ghInstance, IDM_ADD_APP, szName, 256);
            ::LoadString(ghInstance, IDS_ADD_APP_DESC, szStatus, 256);
            menuitem.lCommandID = IDM_ADD_APP;
            menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;

            hr = pContextMenuCallback->AddItem(&menuitem);

            if (FAILED(hr))
                    break;
        }

        if ((m_fRSOP == TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_VIEW))
        {
            menuitem.lCommandID = 0;
            menuitem.fFlags = MFT_SEPARATOR;
            menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
            hr = pContextMenuCallback->AddItem(&menuitem);
            if (FAILED(hr))
                    break;
            ::LoadString(ghInstance, IDM_WINNER, szName, 256);
            ::LoadString(ghInstance, IDS_WINNER_DESC, szStatus, 256);
            menuitem.lCommandID = IDM_WINNER;
            menuitem.fFlags = menuitem.lCommandID == m_iViewState ? MFS_CHECKED | MFT_RADIOCHECK : 0;
            menuitem.fSpecialFlags = 0;
            hr = pContextMenuCallback->AddItem(&menuitem);
            if (FAILED(hr))
                    break;

            if ((m_dwRSOPFlags & RSOP_INFO_FLAG_DIAGNOSTIC_MODE) == RSOP_INFO_FLAG_DIAGNOSTIC_MODE)
            {
                // removed packages should only apply when I'm in diagnostic mode
                ::LoadString(ghInstance, IDM_REMOVED, szName, 256);
                ::LoadString(ghInstance, IDS_REMOVED_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_REMOVED;
                menuitem.fFlags = menuitem.lCommandID == m_iViewState ? MFS_CHECKED | MFT_RADIOCHECK : 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }

            if (!m_fMachine)
            {
                ::LoadString(ghInstance, IDM_ARP, szName, 256);
                ::LoadString(ghInstance, IDS_ARP_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ARP;
                menuitem.fFlags = menuitem.lCommandID == m_iViewState ? MFS_CHECKED | MFT_RADIOCHECK : 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
        }

        //
        // Update & Remove application if this is a result pane item
        //

        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData & data = m_AppData[pInternal->m_cookie];
            DWORD dwFlags = data.m_pDetails->pInstallInfo->dwActFlags;

            if ((m_fRSOP != TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TOP))
            {
                ::LoadString(ghInstance, IDM_AUTOINST, szName, 256);
                ::LoadString(ghInstance, IDS_AUTOINST_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_AUTOINST;
                menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;

                // only enable for published apps
                if (dwFlags & ACTFLG_Published)
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                if (dwFlags & ACTFLG_OnDemandInstall)
                    menuitem.fFlags += MFS_CHECKED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_ASSIGN, szName, 256);
                ::LoadString(ghInstance, IDS_ASSIGN_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ASSIGN;
                if ((dwFlags & ACTFLG_Assigned) || (data.m_pDetails->pInstallInfo->PathType == SetupNamePath))
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_PUBLISH, szName, 256);
                ::LoadString(ghInstance, IDS_PUBLISH_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_PUBLISH;
                if ((dwFlags & ACTFLG_Published) || m_fMachine)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#if 0
                ::LoadString(ghInstance, IDM_DISABLE, szName, 256);
                ::LoadString(ghInstance, IDS_DISABLE_DESC, szStatus, 256);

                if (dwFlags & (ACTFLG_Published | ACTFLG_Assigned))
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                menuitem.lCommandID = IDM_DISABLE;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#endif
                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
            if ((m_fRSOP != TRUE) && ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TASK))
            {
                ::LoadString(ghInstance, IDM_ASSIGN, szName, 256);
                ::LoadString(ghInstance, IDS_ASSIGN_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ASSIGN_T;
                menuitem.fSpecialFlags = 0;
                if ((dwFlags & ACTFLG_Assigned) || (data.m_pDetails->pInstallInfo->PathType == SetupNamePath))
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_PUBLISH, szName, 256);
                ::LoadString(ghInstance, IDS_PUBLISH_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_PUBLISH_T;
                if ((dwFlags & ACTFLG_Published) || m_fMachine)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#if 0
                ::LoadString(ghInstance, IDM_DISABLE, szName, 256);
                ::LoadString(ghInstance, IDS_DISABLE_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_DISABLE_T;
                if (dwFlags & (ACTFLG_Published | ACTFLG_Assigned))
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
#endif
                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_DEL_APP, szName, 256);
                ::LoadString(ghInstance, IDS_DEL_APP_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_DEL_APP;
                menuitem.fFlags = 0;
                menuitem.fSpecialFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_REDEPLOY, szName, 256);
                ::LoadString(ghInstance, IDS_REDEPLOY_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_REDEPLOY;
                if (data.m_pDetails->pInstallInfo->PathType == SetupNamePath)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
        }
    } while (FALSE);


    FREE_INTERNAL(pInternal);
    return hr;
}

HRESULT CScopePane::GetRSoPCategories(void)
{
    HRESULT hr = S_OK;
    list <APPCATEGORYINFO> CatList;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQueryCategories = SysAllocString(TEXT("SELECT * FROM RSOP_ApplicationManagementCategory"));
    BSTR strNamespace = SysAllocString(m_szRSOPNamespace);
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories:  CoCreateInstance failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories:  pLocator->ConnectServer failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // First perform the query to get the list of categories

    // erase any existing list
    ClearCategories();

    // create a new one
    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQueryCategories,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories:  pNamespace->ExecQuery failed with 0x%x", hr));
    if (FAILED(hr))
    {
        goto cleanup;
    }
    do
    {
        hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
        if (FAILED(hr))
        {
            goto cleanup;
        }
        if (n > 0)
        {
            APPCATEGORYINFO ci;
            memset(&ci, 0, sizeof(APPCATEGORYINFO));
            ci.Locale = 0;
            hr = GetParameter(pObj,
                              TEXT("CategoryId"),
                              ci.AppCategoryId);
            DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories: GetParameter(\"CategoryId\") failed with 0x%x", hr));
            hr = GetParameter(pObj,
                              TEXT("Name"),
                              ci.pszDescription);
            DebugReportFailure(hr, (DM_WARNING, L"GetRSoPCategories: GetParameter(\"Name\") failed with 0x%x", hr));
            CatList.push_back(ci);
        }
    } while (n > 0);

    // put the list of categories into the proper format so it matches
    // what we would get from the class store
    n = CatList.size();
    if (n > 0)
    {
        m_CatList.pCategoryInfo =
            (APPCATEGORYINFO *)OLEALLOC(sizeof(APPCATEGORYINFO) * n);
        if (m_CatList.pCategoryInfo)
        {
            m_CatList.cCategory = n;
            while (n--)
            {
                m_CatList.pCategoryInfo[n] = *CatList.begin();
                CatList.erase(CatList.begin());
            }
        }
    }
cleanup:
    SysFreeString(strQueryLanguage);
    SysFreeString(strQueryCategories);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}



HRESULT CScopePane::InitializeADE()
{
    HRESULT hr = S_OK;

    if ((!m_fRSOP) && (!m_pIClassAdmin))
    {
        // make sure directories are created:
        CreateNestedDirectory ((LPOLESTR)((LPCOLESTR)m_szGPT_Path), NULL);

        // try and get IClassAdmin
        hr = GetClassStore(FALSE);
    }
    return hr;
}

void CScopePane::Refresh()
{
    if (m_fRSOP || ((!m_fBlockAddPackage) && (m_pIClassAdmin)))
    {

        map <MMC_COOKIE, CAppData>::iterator i;
        set <CResultPane *>::iterator i2;
        for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
        {
            (*i2)->m_pResult->DeleteAllRsltItems();
        }
        for (i=m_AppData.begin(); i != m_AppData.end(); i++)
        {
         //   if (i->second.m_fVisible)
         //   {
         //   }
            OLESAFE_DELETE(i->second.m_psd);
            FreePackageDetail(i->second.m_pDetails);
        }
        m_AppData.erase(m_AppData.begin(), m_AppData.end());
        m_UpgradeIndex.erase(m_UpgradeIndex.begin(), m_UpgradeIndex.end());
        m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
        m_lLastAllocated = 0;
        for (i2 = m_sResultPane.begin(); i2 != m_sResultPane.end(); i2++)
        {
            (*i2)->EnumerateResultPane(0);
        }
    }
}

STDMETHODIMP CScopePane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (!pInternal)
    {
        return E_UNEXPECTED;
    }

    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.

    // Handle each of the commands.
    switch (nCommandID)
    {
    case IDM_AUTOINST:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags ^ ACTFLG_OnDemandInstall;
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_ASSIGN:
    case IDM_ASSIGN_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~(ACTFLG_Published);
            dwNewFlags |= (ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_OnDemandInstall);
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_PUBLISH:
    case IDM_PUBLISH_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~ACTFLG_Assigned;
            dwNewFlags |= ACTFLG_Published | ACTFLG_UserInstall;
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_DISABLE:
    case IDM_DISABLE_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.m_pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~(ACTFLG_OnDemandInstall | ACTFLG_Assigned | ACTFLG_UserInstall | ACTFLG_Published);
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_REDEPLOY:
        {
            CAppData &data = m_AppData[pInternal->m_cookie];
            CString sz;
            sz.LoadString(IDS_REDEPLOYWARNING);
            int iReturn = IDNO;
            m_pConsole->MessageBox(    sz,
                                       data.m_pDetails->pszPackageName,
                                       MB_YESNO,
                                       &iReturn);
            if (IDYES == iReturn)
            {
                CHourglass hourglass;
                //CString szScriptPath = data.m_pDetails->pInstallInfo->pszScriptPath;
                CString szScriptPath = m_szGPT_Path;
                DWORD dwRevision;
                HRESULT hr = S_OK;
                BOOL bStatus;

                szScriptPath += L"\\temp.aas";
                CString szTransformList = L"";
                int i;
                if (data.m_pDetails->cSources > 1)
                {
                    CString szSource = data.m_pDetails->pszSourceList[0];
                    int nChars = 1 + szSource.ReverseFind(L'\\');
                    BOOL fTransformsAtSource = TRUE;
                    for (i = 1; i < data.m_pDetails->cSources && TRUE == fTransformsAtSource; i++)
                    {
                        if (0 == wcsncmp(szSource, data.m_pDetails->pszSourceList[i], nChars))
                        {
                            // make sure there isn't a sub-path
                            int n = nChars;
                            while (0 != data.m_pDetails->pszSourceList[i][n] && TRUE == fTransformsAtSource)
                            {
                                if (data.m_pDetails->pszSourceList[i][n] == L'\\')
                                {
                                    fTransformsAtSource = FALSE;
                                }
                                n++;
                            }
                        }
                        else
                        {
                            fTransformsAtSource = FALSE;
                        }
                    }
                    if (fTransformsAtSource)
                    {
                        szTransformList = L"@";
                    }
                    else
                    {
                        szTransformList = L"|";
                        nChars = 0;
                    }
                    for (i = 1; i < data.m_pDetails->cSources; i++)
                    {
                        if (i > 1)
                        {
                            szTransformList += L";";
                        }
                        szTransformList += &data.m_pDetails->pszSourceList[i][nChars];
                    }
                }

                // disable MSI ui
                MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                // build the script file

                DWORD dwPlatform;

                if ( CAppData::Is64Bit( data.m_pDetails ) )
                {
                    dwPlatform = MSIARCHITECTUREFLAGS_IA64;
                }
                else
                {
                    dwPlatform = MSIARCHITECTUREFLAGS_X86;
                }

                UINT uMsiStatus = MsiAdvertiseProductEx(
                    data.m_pDetails->pszSourceList[0],
                    szScriptPath,
                    szTransformList,
                    LANGIDFROMLCID(data.m_pDetails->pPlatformInfo->prgLocale[0]),
                    dwPlatform,
                    0);

                if (uMsiStatus)
                {
                    DebugMsg((DM_WARNING, TEXT("MsiAdvertiseProduct failed with %u"), uMsiStatus));
                    hr = HRESULT_FROM_WIN32(uMsiStatus);
                }

                if (SUCCEEDED(hr))
                {
                    dwRevision = data.m_pDetails->pInstallInfo->dwRevision + 1;
                    hr = m_pIClassAdmin->ChangePackageProperties(data.m_pDetails->pszPackageName,
                                                                         NULL,
                                                                         NULL,
                                                                         NULL,
                                                                         NULL,
                                                                         NULL,
                                                                         &dwRevision);
                }

                if (SUCCEEDED(hr))
                {
                    // delete the old script
                    bStatus = DeleteFile(data.m_pDetails->pInstallInfo->pszScriptPath);

                    // rename the new one
                    if ( bStatus )
                        bStatus = MoveFile(szScriptPath, data.m_pDetails->pInstallInfo->pszScriptPath);

                    data.m_pDetails->pInstallInfo->dwRevision = dwRevision;

                    if ( bStatus )
                    {
                        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                                          m_fMachine ? &guidMachSnapin
                                                                     : &guidUserSnapin)))
                        {
                            ReportPolicyChangedError(m_hwndMainWindow);
                        }
                    }
                    else
                        hr = HRESULT_FROM_WIN32(GetLastError());
                }

                if ( ! SUCCEEDED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
                    // display failure message
                    sz.LoadString(IDS_REDEPLOYERROR);
                    m_pConsole->MessageBox(sz,
                                       data.m_pDetails->pszPackageName,
                                       MB_OK | MB_ICONEXCLAMATION, NULL);
                }
            }
        }
        break;
    case IDM_ADD_APP:
        {
            if (!m_fBlockAddPackage)
            {
                m_fBlockAddPackage=TRUE;
                CString szExtension;
                CString szFilter;
                szExtension.LoadString(IDS_DEF_EXTENSION);
                if (m_fMachine)
                {
                    szFilter.LoadString(IDS_EXTENSION_FILTER_M);
                }
                else
                    szFilter.LoadString(IDS_EXTENSION_FILTER);
                OPENFILENAME ofn;
                memset(&ofn, 0, sizeof(ofn));
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner = GetActiveWindow();
                ofn.hInstance = ghInstance;
                TCHAR lpstrFilter[MAX_PATH];
                wcsncpy(lpstrFilter, szFilter, MAX_PATH);
                ofn.lpstrFilter = lpstrFilter;
                TCHAR szFileTitle[MAX_PATH];
                TCHAR szFile[MAX_PATH];
                szFile[0] = NULL;
                ofn.lpstrFile = szFile;
                ofn.nMaxFile = MAX_PATH;
                ofn.lpstrFileTitle = szFileTitle;
                ofn.nMaxFileTitle = MAX_PATH;
                ofn.lpstrInitialDir = m_ToolDefaults.szStartPath;
                ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
                ofn.lpstrDefExt = szExtension;
                int iBreak = 0;
                while (lpstrFilter[iBreak])
                {
                    if (lpstrFilter[iBreak] == TEXT('|'))
                    {
                        lpstrFilter[iBreak] = 0;
                    }
                    iBreak++;
                }
                if (GetOpenFileName(&ofn))
                {
                    CHourglass hourglass;
                    CString szPackagePath;
                    HRESULT hr = E_FAIL;
                    TCHAR szFile[MAX_PATH];
                    TCHAR * szNextFile = ofn.lpstrFile + ofn.nFileOffset;
                    TCHAR * szFileTitle = szFile + ofn.nFileOffset;
                    _tcscpy(szFile, ofn.lpstrFile);
                    if (0 == szFile[ofn.nFileOffset - 1])
                    {
                        // this is a list of files (not just one)
                        // need to put a slash here so it will work
                        szFile[ofn.nFileOffset - 1] = TEXT('\\');
                    }
                    TCHAR * szFileExtension;

                    // don't allow deployment over http or ftp
                    if (_wcsnicmp(ofn.lpstrFile, TEXT("http:"), 5) == 0
                        ||
                        _wcsnicmp(ofn.lpstrFile, TEXT("ftp:"), 4) == 0)
                    {
                        CString sz;
                        sz.LoadString(IDS_ILLEGAL_PATH);
                        int iReturn = IDNO;
                        m_pConsole->MessageBox(sz, szPackagePath,
                                               MB_OK | MB_ICONEXCLAMATION,
                                               &iReturn);
                        goto skip_deployment;
                    }

                    // at this point I have a path and I have a list of file names

                    do
                    {
                        _tcscpy(szFileTitle, szNextFile);

                        hr = GetUNCPath (szFile, szPackagePath);
                        DebugMsg((DM_VERBOSE, TEXT("GetUNCPath(%s) returned %s"), szFile, szPackagePath));
                        if (FAILED(hr))
                        {
                            CString sz;
                            sz.LoadString(IDS_NO_UNIVERSAL_NAME);
                            int iReturn = IDNO;
                            m_pConsole->MessageBox(sz, szPackagePath,
                                                   MB_YESNO | MB_ICONEXCLAMATION,
                                                   &iReturn);
                            if (IDYES != iReturn)
                            {
                                goto skip_deployment;
                            }
                        }

                        szFileExtension = _tcsrchr(szFile, TEXT('.'));


                        if ((szFileExtension) &&
                            (0 == _wcsicmp(szFileExtension, L".zap")))
                        {
                            if (m_fMachine)
                            {
                                CString szText;
                                CString szTitle;
                                szText.LoadString(IDS_NO_ZAPS_ALLOWED);
                                // only allow ZAP files to be deployed to users
                                m_pConsole->MessageBox(
                                             szText,
                                             szTitle,
                                             MB_OK | MB_ICONEXCLAMATION,
                                             NULL);
                                hr = E_FAIL;
                            }
                            else
                            {
                                hr = AddZAPPackage(szPackagePath, szFileTitle);
                            }
                        }
                        else
                        {
                            hr = AddMSIPackage(szPackagePath, szFileTitle);
                        }
                        szNextFile += _tcslen(szNextFile) + 1;
                    } while (szNextFile[0]);

           skip_deployment:
                    // Notify clients of change
                    if (SUCCEEDED(hr) && m_pIGPEInformation)
                    {
                        if (FAILED(m_pIGPEInformation->PolicyChanged(m_fMachine, TRUE, &guidExtension,
                                                          m_fMachine ? &guidMachSnapin
                                                                     : &guidUserSnapin)))
                        {
                            ReportPolicyChangedError(m_hwndMainWindow);
                        }
                    }
                }
                m_fBlockAddPackage = FALSE;
            }
            else
            {
                // consider a message here
            }

        }
        break;
    case IDM_WINNER:
    case IDM_REMOVED:
    case IDM_FAILED:
    case IDM_ARP:
        m_iViewState = nCommandID;
        {
            // change toolbar state
            set <CResultPane *>::iterator i;
            for (i = m_sResultPane.begin(); i != m_sResultPane.end(); i++)
            {
                if ((*i)->m_pToolbar)
                {
                    (*i)->m_pToolbar->SetButtonState(IDM_WINNER,
                                                     BUTTONPRESSED,
                                                     FALSE);
                    (*i)->m_pToolbar->SetButtonState(IDM_REMOVED,
                                                     BUTTONPRESSED,
                                                     FALSE);
                    (*i)->m_pToolbar->SetButtonState(IDM_ARP,
                                                     BUTTONPRESSED,
                                                     FALSE);
                    (*i)->m_pToolbar->SetButtonState(nCommandID,
                                                     BUTTONPRESSED,
                                                     TRUE);
                }
            }
        }
        // deliberately fall through to REFRESH
    case IDM_REFRESH:
        Refresh();

        //
        // In logging mode, we need to show a message box to the user
        // in the case that ARP view is empty so that users are clear
        // that this may be because ARP has not been run yet
        //
        if ( m_fRSOP && 
             ( IDM_ARP == nCommandID ) && 
             ( m_dwRSOPFlags & RSOP_INFO_FLAG_DIAGNOSTIC_MODE ) && 
             ! m_fDisplayedRsopARPWarning  &&
             ( m_AppData.end() == m_AppData.begin() ) )
        {
            CString szTitle;
            CString szText;
            szTitle.LoadString(IDS_RSOP_ARP_WARNING_TITLE);
            szText.LoadString(IDS_RSOP_ARP_WARNING);
            int iReturn;
            m_pConsole->MessageBox(szText,
                                   szTitle,
                                   MB_OK,
                                   &iReturn);

            m_fDisplayedRsopARPWarning = TRUE;
        }
        break;
    case IDM_DEL_APP:
        if (pInternal->m_type == CCT_RESULT)
        {
            CAppData & data = m_AppData[pInternal->m_cookie];
            if ((data.m_pDetails->pInstallInfo->PathType == SetupNamePath))
            {
                // this is a legacy app it can't be uninstalled
                CString szTitle;
                CString szText;
                szTitle.LoadString(IDS_REMOVE_LEGACY_TITLE);
                szText.LoadString(IDS_REMOVE_LEGACY_TEXT);
                int iReturn = IDNO;
                m_pConsole->MessageBox(szText,
                                       szTitle,
                                       MB_YESNO,
                                       &iReturn);
                if (IDYES == iReturn)
                {
                    RemovePackage(pInternal->m_cookie, FALSE, FALSE);
                }
            }
            else
            {
                CRemove dlg;
                // Activate the theme context in order to theme this dialog
                CThemeContextActivator themer;
                
                int iReturn = dlg.DoModal();

                if (IDOK == iReturn)
                {
                    switch (dlg.m_iState)
                    {
                    case 0:
                        RemovePackage(pInternal->m_cookie, TRUE, FALSE);
                        break;
                    case 1:
                        RemovePackage(pInternal->m_cookie, FALSE, FALSE);
                        break;
                    }
                }
            }
        }
        break;

    default:
        break;
    }
    return S_OK;
}

static PFNDSCREATEISECINFO pDSCreateISecurityInfoObject = NULL;
static HINSTANCE hInst_dssec = NULL;
STDAPI DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                                   LPCWSTR pwszObjectClass,
                                   DWORD dwFlags,
                                   LPSECURITYINFO * ppSI,
                                   PFNREADOBJECTSECURITY pfnReadSD,
                                   PFNWRITEOBJECTSECURITY pfnWriteSD,
                                   LPARAM lpContext)
{
    if (NULL == pDSCreateISecurityInfoObject)
    {
        if (NULL == hInst_dssec)
        {
            hInst_dssec = LoadLibrary(L"dssec.dll");
            if (NULL == hInst_dssec)
            {
                return E_UNEXPECTED;
            }
        }
        pDSCreateISecurityInfoObject = (PFNDSCREATEISECINFO)
            GetProcAddress(hInst_dssec, "DSCreateISecurityInfoObject");
        if (NULL == pDSCreateISecurityInfoObject)
        {
            return E_UNEXPECTED;
        }
    }
    return pDSCreateISecurityInfoObject(pwszObjectPath, pwszObjectClass, dwFlags, ppSI, pfnReadSD, pfnWriteSD, lpContext);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetUNCPath
//
//  Synopsis:   This function takes in a driver based path and converts
//              it to a UNC path
//
//  Arguments:
//          [in] [szPath]    - The drive based path
//          [out][szUNCPath] - The UNC path
//
//  Returns:
//          S_OK    - If the function succeeds in obtaining a UNC path
//          E_FAIL  - If the function cannot obtain a UNC path
//
//  History:    5/20/1998  RahulTh  created
//
//  Notes: If the function cannot obtain a UNC path, it simply copies szPath
//         into szUNCPath on return.
//
//---------------------------------------------------------------------------
HRESULT GetUNCPath (LPCOLESTR szPath, CString& szUNCPath)
{
    TCHAR* lpszUNCName;
    UNIVERSAL_NAME_INFO * pUni;
    ULONG cbSize;
    HRESULT hr;
    DWORD retVal;

    szUNCPath.Empty();  //safety measure
    lpszUNCName = new TCHAR[MAX_PATH];
    pUni = (UNIVERSAL_NAME_INFO*) lpszUNCName;
    cbSize = MAX_PATH * sizeof(TCHAR);

    retVal = WNetGetUniversalName(szPath,
                                  UNIVERSAL_NAME_INFO_LEVEL,
                                  (LPVOID) pUni,
                                  &cbSize);
    if (ERROR_MORE_DATA == retVal)  //if the buffer was not large enough
    {
        delete [] pUni;
        pUni = (UNIVERSAL_NAME_INFO *) new BYTE [cbSize];
        retVal = WNetGetUniversalName(szPath,
                                      UNIVERSAL_NAME_INFO_LEVEL,
                                      pUni,
                                      &cbSize);
    }

    if (NO_ERROR == retVal)
    {
        szUNCPath = pUni->lpUniversalName;
        hr = S_OK;
    }
    else
    {
        szUNCPath = szPath;
        if (0 != wcsncmp(szPath, L"\\\\", 2))
            hr = E_FAIL;    //probably not a remote share.
        else
            hr = S_OK;  //probably a remote share.
    }
    delete[] pUni;

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   LogADEEvent
//
//  Synopsis:   logs an ADE event in the event log
//
//  Arguments:  [wType]      - type of event
//              [dwEventID]  - event ID
//              [hr]         - HRESULT that triggered the event to be logged
//              [szOptional] - additional descriptive text used by some events
//
//  Returns:    nothing
//
//  Modifies:   nothing
//
//  History:    05-27-1999   stevebl   Created
//              04-28-2000   stevebl   Modified to allow more complex logging
//
//  Notes:      We attempt to use FormatMessage to craft a legible message
//              but in the case that it fails, we just log the HRESULT.
//
//---------------------------------------------------------------------------

void LogADEEvent(WORD wType, DWORD dwEventID, HRESULT hr, LPCWSTR szOptional)
{
    TCHAR szBuffer[256];
    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             hr,
                             0,
                             szBuffer,
                             sizeof(szBuffer) / sizeof(szBuffer[0]),
                             NULL);
    if (0 == dw)
    {
        // FormatMessage failed.
        // We'll have to come up with some sort of reasonable message.
        wsprintf(szBuffer, TEXT("(HRESULT: 0x%lX)"), hr);

    }
    HANDLE hEventLog = OpenEventLog( NULL, ADE_EVENT_SOURCE );

    if (hEventLog)
    {
        LPCWSTR rgsz[2];
        rgsz[0] = szBuffer;
        rgsz[1] = szOptional;
        ReportEvent(hEventLog,
                    wType,
                    0,
                    dwEventID,
                    NULL,
                    NULL == szOptional ? 1 : 2,
                    sizeof(hr),
                    rgsz,
                    &hr);

        CloseEventLog(hEventLog);
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   ReportGeneralPropertySheetError
//
//  Synopsis:   Pops up a message box indicating why changes to a property
//              page could not be applies and logs the error in the event log.
//
//  Arguments:  [sz] - Title bar text
//              [hr] - hresult of the error
//
//  Returns:    nothing
//
//  History:    9-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void ReportGeneralPropertySheetError(HWND hwnd, LPCWSTR sz, HRESULT hr)
{
    LogADEEvent(EVENTLOG_ERROR_TYPE, EVENT_ADE_GENERAL_ERROR, hr);

    CString szMessage;
    szMessage.LoadString(IDS_GENERALERROR);

    MessageBox(  hwnd,
                 szMessage,
                 sz,
                 MB_OK | MB_ICONEXCLAMATION);
}

void ReportPolicyChangedError(HWND hwnd)
{
    CString szMessage;
    szMessage.LoadString(IDS_ERRORPOLICYCHANGED);
    MessageBox(hwnd,
               szMessage,
               NULL,
               MB_OK | MB_ICONEXCLAMATION);
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadHelpInfo
//
//  Synopsis:   routine that loads and locks the help mapping resources
//
//  Arguments:  [nIDD] - ID of the dialog making the help request
//
//  Returns:    handle to the locked and loaded mapping table
//
//  History:    10-22-1998   stevebl   Created
//
//---------------------------------------------------------------------------

LPDWORD LoadHelpInfo(UINT nIDD)
{
    HRSRC hrsrc = FindResource(ghInstance, MAKEINTRESOURCE(nIDD),
        MAKEINTRESOURCE(RT_HELPINFO));
    if (hrsrc == NULL)
        return NULL;

    HGLOBAL hHelpInfo = LoadResource(ghInstance, hrsrc);
    if (hHelpInfo == NULL)
        return NULL;

    LPDWORD lpdwHelpInfo = (LPDWORD)LockResource(hHelpInfo);
    return lpdwHelpInfo;
}

#define RSOP_HELP_FILE TEXT("gpedit.hlp")

//+--------------------------------------------------------------------------
//
//  Function:   StandardHelp
//
//  Synopsis:   Standardized routine for bringing up context sensitive help.
//
//  Arguments:  [hWnd] - window that needs help
//              [nIDD] - ID of the dialog making the request
//  Notes:
//
//
//  History:    10-22-1998   stevebl   modified from the OLEDLG sources
//
//---------------------------------------------------------------------------

void WINAPI StandardHelp(HWND hWnd, UINT nIDD, BOOL fRsop /* = FALSE */ )
{
    LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
    if (lpdwHelpInfo == NULL)
    {
        DebugMsg((DL_VERBOSE, TEXT("Warning: unable to load help information (RT_HELPINFO)\n")));
        return;
    }
    WinHelp(hWnd, fRsop ? RSOP_HELP_FILE : HELP_FILE, HELP_WM_HELP, (DWORD_PTR)lpdwHelpInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   StandardContextMenu
//
//  Synopsis:   Standardized routine for bringing up context menu based help.
//
//  Arguments:  [hWnd] -
//              [nIDD]   - ID of the dialog making the request
//
//  History:    10-22-1998   stevebl   modified from the OLEDLG sources
//
//---------------------------------------------------------------------------

void WINAPI StandardContextMenu(HWND hWnd,  UINT nIDD, BOOL fRsop /* = FALSE */ )
{
    LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
    if (lpdwHelpInfo == NULL)
    {
        DebugMsg((DL_VERBOSE, TEXT("Warning: unable to load help information (RT_HELPINFO)\n")));
        return;
    }
    WinHelp(hWnd, fRsop ? RSOP_HELP_FILE : HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR)lpdwHelpInfo);
}


//+--------------------------------------------------------------------------
//
//  Function:   CreateThemedPropertyPage
//
//  Synopsis:   Helper function to make sure that property pages put up
//              by the snap-in are themed.
//
//  Arguments:
//
//  Returns:
//
//  History:    4/20/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HPROPSHEETPAGE CreateThemedPropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\sigs.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Sigs.cpp
//
//  Contents:   Digital Signatures property page
//
//  Classes:    CSignatures
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#ifdef DIGITAL_SIGNATURES

#include "wincrypt.h"
#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSignatures property page

IMPLEMENT_DYNCREATE(CSignatures, CPropertyPage)

CSignatures::CSignatures() : CPropertyPage(CSignatures::IDD)
{
        //{{AFX_DATA_INIT(CSignatures)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_fAllow = FALSE;
    m_fIgnoreForAdmins = FALSE;
    m_pIClassAdmin = NULL;
    m_nSortedColumn = 0;
}

CSignatures::~CSignatures()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
    // delete temporary stores
    m_list1.DeleteAllItems();
    m_list2.DeleteAllItems();

    DeleteFile(m_szTempInstallableStore);
    DeleteFile(m_szTempNonInstallableStore);
}

void CSignatures::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CSignatures)
        DDX_Check(pDX, IDC_CHECK1, m_fAllow);
        DDX_Check(pDX, IDC_CHECK2, m_fIgnoreForAdmins);
        DDX_Control(pDX, IDC_LIST1, m_list1);
        DDX_Control(pDX, IDC_LIST2, m_list2);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSignatures, CPropertyPage)
        //{{AFX_MSG_MAP(CSignatures)
        ON_BN_CLICKED(IDC_BUTTON1, OnAddAllow)
        ON_BN_CLICKED(IDC_BUTTON2, OnDeleteAllow)
        ON_BN_CLICKED(IDC_BUTTON3, OnPropertiesAllow)
        ON_BN_CLICKED(IDC_BUTTON4, OnAddDisallow)
        ON_BN_CLICKED(IDC_BUTTON5, OnDeleteDisallow)
        ON_BN_CLICKED(IDC_BUTTON6, OnPropertiesDisallow)
        ON_BN_CLICKED(IDC_CHECK1, OnAllowChanged)
        ON_BN_CLICKED(IDC_CHECK2, OnIgnoreChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSignatures message handlers

void CSignatures::RemoveCertificate(CString &szStore, CListCtrl &List)
{
    int nItem = -1;

    for (;;)
    {
        nItem = List.GetNextItem(nItem, LVNI_SELECTED);
        if (-1 == nItem)
        {
            break;
        }

        //
        // Open the certificate store
        //

        PCCERT_CONTEXT pcLocalCert = NULL;
        PCCERT_CONTEXT pcItemCert = (PCCERT_CONTEXT) List.GetItemData(nItem);
        HCERTSTORE hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                               NULL,
                                               CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                               szStore);

        if (hCertStore)
        {
            //
            // Enumerate the cert store looking for the match
            //

            int i = 0;

            for (;;) {
                pcLocalCert = CertEnumCertificatesInStore(hCertStore, pcLocalCert);

                if (!pcLocalCert) {
                    if (GetLastError() != CRYPT_E_NOT_FOUND )
                    {
                        DebugMsg((DM_WARNING, TEXT("CSignatures::RemoveCertificate: Failed to find certificate to delete.")));
                    }
                    break;
                }

                if (CertCompareCertificate(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                           pcLocalCert->pCertInfo ,
                                           pcItemCert->pCertInfo))
                {
                    CertDeleteCertificateFromStore(pcLocalCert);
                    break;
                }

                //pcLocalCert should get deleted when it is repassed into CertEnumCerti..
            }
            CertCloseStore(hCertStore, 0);
        }
    }

    RefreshData();
    SetModified();
}

void CSignatures::CertificateProperties(CString &szStore, CListCtrl &List)
{
    int nItem = -1;

    for (;;)
    {
        nItem = List.GetNextItem(nItem, LVNI_SELECTED);
        if (-1 == nItem)
        {
            break;
        }

        PCCERT_CONTEXT pcc = (PCCERT_CONTEXT) List.GetItemData(nItem);

        // display the property sheet for this item
        CRYPTUI_VIEWCERTIFICATE_STRUCT cvs;
        memset(&cvs, 0, sizeof(cvs));
        cvs.dwSize = sizeof(cvs);
        cvs.hwndParent = m_hWnd;
        cvs.pCertContext = pcc;
        cvs.dwFlags = CRYPTUI_DISABLE_EDITPROPERTIES |
                      CRYPTUI_DISABLE_ADDTOSTORE;

        BOOL fChanged = FALSE;
        CryptUIDlgViewCertificate(&cvs, &fChanged);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CSignatures::ReportFailure
//
//  Synopsis:   General failure reporting mechanism.
//
//  Arguments:  [dwMessage] - resource ID of the root message string
//              [hr]        - HRESULT encountered
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    07-26-2000   stevebl   Created
//
//  Notes:      Builds an error message with a line of text determined by
//              dwMessage, and followed by text returned by Format Message
//              string.
//              The error message is then displayed in a message box.
//
//---------------------------------------------------------------------------

void CSignatures::ReportFailure(DWORD dwMessage, HRESULT hr)
{
    CString szMessage;
    szMessage.LoadString(dwMessage);
    szMessage += TEXT("\n");
    TCHAR szBuffer[256];
    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             hr,
                             0,
                             szBuffer,
                             sizeof(szBuffer) / sizeof(szBuffer[0]),
                             NULL);
    if (0 == dw)
    {
        // FormatMessage failed.
        // We'll have to come up with some sort of reasonable message.
        wsprintf(szBuffer, TEXT("(HRESULT: 0x%lX)"), hr);

    }
    szMessage += szBuffer;
    MessageBox(szMessage,
               NULL,
               MB_OK | MB_ICONEXCLAMATION);
}

//+--------------------------------------------------------------------------
//
//  Function:   AddMSIToCertStore
//
//  Synopsis:   Gets a certificate from an MSI file and adds it to the
//              certificate store.
//
//  Arguments:  [lpFileName]  - path to the MSI file
//              [lpFileStore] - path to the certificate store
//
//  Returns:
//
//  Modifies:
//
//  History:    07-26-2000   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT CSignatures::AddMSIToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore)
{
    PCCERT_CONTEXT pcc = NULL;
    HCERTSTORE hCertStore = NULL;
    BOOL bRet;
    HRESULT hrRet = MsiGetFileSignatureInformation(lpFileName,
                                                0,
                                                &pcc,
                                                NULL,
                                                NULL);
    if (SUCCEEDED(hrRet))
    {
        //
        // Open the certificate store
        //
        hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                    lpFileStore);

        if (hCertStore == NULL) {
            DebugMsg((DM_WARNING, L"AddMSIToCertStore: CertOpenStore failed with %u",GetLastError()));
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // add the given certificate to the store
        //

        bRet = CertAddCertificateContextToStore(hCertStore,
                                                pcc,
                                                CERT_STORE_ADD_NEW,
                                                NULL);

        if (!bRet) {
            DebugMsg((DM_WARNING, L"AddToCertStore: CertAddCertificateContextToStore failed with %u", GetLastError()));
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Save the store
        //

        bRet = CertCloseStore(hCertStore, 0);
        hCertStore = NULL; // Make the store handle NULL, Nothing more we can do

        if (!bRet) {
            DebugMsg((DM_WARNING, L"AddToCertStore: CertCloseStore failed with %u", GetLastError()));
            hrRet = HRESULT_FROM_WIN32(GetLastError());
        }

        hrRet = S_OK;


    Exit:

        if (hCertStore) {

            //
            // No need to get the error code
            //

            CertCloseStore(hCertStore, 0);
        }
        CertFreeCertificateContext(pcc);
        if (FAILED(hrRet))
        {
            ReportFailure(IDS_ADDCERTFAILED, hrRet);
        }
    }
    else
    {
        ReportFailure(IDS_CERTFROMMSIFAILED, hrRet);
        DebugMsg((DM_WARNING, L"AddMSIToCertStore: MsiGetFileSignatureInformation failed with 0x%x", hrRet));
    }

    return hrRet;
}

//+-------------------------------------------------------------------------
// AddToCertStore
//
// Purpose:
//      Adds the certificate from the given filename to the certificate store
//      and saves it to the given location
//
//
// Parameters
//          lpFIleName  - Location of the certificate file
//          lpFileStore - Location where the resultant cetrtficate path should
//                        be stored
//
//
// Return Value:
//      S_OK if successful or the corresponding error code
//
// Comments:    Shamefully stolen from Shaji's code.
//+-------------------------------------------------------------------------


HRESULT CSignatures::AddToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore)
{
    CRYPTUI_WIZ_IMPORT_SRC_INFO cui_src;
    HCERTSTORE hCertStore = NULL;
    BOOL       bRet = FALSE;
    HRESULT    hrRet = S_OK;


    //
    // Need to make the store usable and saveable from
    // multiple admin consoles..
    //
    // For that the file has to be saved and kept on a temp file
    // and then modified..
    //

    if (!lpFileName || !lpFileName[0] || !lpFileStore || !lpFileStore[0]) {
        return E_INVALIDARG;
    }


    //
    // Open the certificate store
    //

    hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                NULL,
                                CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                lpFileStore);

    if (hCertStore == NULL) {
        DebugMsg((DM_WARNING, L"AddToCertStore: CertOpenStore failed with %u",GetLastError()));
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // add the given certificate to the store
    //

    cui_src.dwFlags = 0;
    cui_src.dwSize = sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
    cui_src.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
    cui_src.pwszFileName = lpFileName;
    cui_src.pwszPassword = NULL;

    bRet = CryptUIWizImport(CRYPTUI_WIZ_NO_UI, NULL, NULL, &cui_src, hCertStore);

    if (!bRet) {
        DebugMsg((DM_WARNING, L"AddToCertStore: CryptUIWizImport failed with %u", GetLastError()));
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Save the store
    //

    bRet = CertCloseStore(hCertStore, 0);
    hCertStore = NULL; // Make the store handle NULL, Nothing more we can do

    if (!bRet) {
        DebugMsg((DM_WARNING, L"AddToCertStore: CertCloseStore failed with %u", GetLastError()));
        hrRet = HRESULT_FROM_WIN32(GetLastError());
    }

    hrRet = S_OK;


Exit:

    if (hCertStore) {

        //
        // No need to get the error code
        //

        CertCloseStore(hCertStore, 0);
    }

    if (FAILED(hrRet))
    {
        ReportFailure(IDS_ADDCERTFAILED, hrRet);
    }
    return hrRet;
}


void CSignatures::AddCertificate(CString &szStore)
{
    CString szExtension;
    CString szFilter;
    szExtension.LoadString(IDS_CERT_DEF_EXT);
    szFilter.LoadString(IDS_CERT_EXT_FILT);
    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = ghInstance;
    TCHAR lpstrFilter[MAX_PATH];
    wcsncpy(lpstrFilter, szFilter, MAX_PATH);
    ofn.lpstrFilter = lpstrFilter;
    TCHAR szFileTitle[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    szFile[0] = NULL;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = MAX_PATH;
    ofn.lpstrInitialDir = m_pScopePane->m_ToolDefaults.szStartPath;
    ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST | OFN_EXPLORER;
    ofn.lpstrDefExt = szExtension;
    int iBreak = 0;
    while (lpstrFilter[iBreak])
    {
        if (lpstrFilter[iBreak] == TEXT('|'))
        {
            lpstrFilter[iBreak] = 0;
        }
        iBreak++;
    }
    if (GetOpenFileName(&ofn))
    {
        CHourglass hourglass;
        CString szPackagePath;
        HRESULT hr = E_FAIL;
        if ((ofn.nFileExtension > 0) &&
            (0 == _wcsicmp(ofn.lpstrFile + ofn.nFileExtension, L"msi")))
        {
            // this is an MSI package

            HRESULT hr = AddMSIToCertStore(ofn.lpstrFile, (LPWSTR)((LPCWSTR)szStore));
            if (SUCCEEDED(hr))
            {
                RefreshData();
                SetModified();
            }
        }
        else
        {
            // this is a simple certificate
            HRESULT hr = AddToCertStore(ofn.lpstrFile, (LPWSTR)((LPCWSTR)szStore));
            if (SUCCEEDED(hr))
            {
                RefreshData();
                SetModified();
            }
        }
    }
}

void CSignatures::OnAddAllow()
{
    AddCertificate(m_szTempInstallableStore);
}

void CSignatures::OnDeleteAllow()
{
    RemoveCertificate(m_szTempInstallableStore, m_list1);
}

void CSignatures::OnPropertiesAllow()
{
    CertificateProperties(m_szTempInstallableStore, m_list1);
}

void CSignatures::OnAddDisallow()
{
    AddCertificate(m_szTempNonInstallableStore);
}

void CSignatures::OnDeleteDisallow()
{
    RemoveCertificate(m_szTempNonInstallableStore, m_list2);
}

void CSignatures::OnPropertiesDisallow()
{
    CertificateProperties(m_szTempNonInstallableStore, m_list2);
}

void CSignatures::OnAllowChanged()
{
    BOOL fAllow = IsDlgButtonChecked(IDC_CHECK1);
    if (m_fAllow != fAllow)
    {
        SetModified();
    }
    m_fAllow = fAllow;
    GetDlgItem(IDC_BUTTON1)->EnableWindow(m_fAllow);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(m_fAllow);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(m_fAllow);
    GetDlgItem(IDC_LIST1)->EnableWindow(m_fAllow);
}
void CSignatures::OnIgnoreChanged()
{
    BOOL fIgnoreForAdmins = IsDlgButtonChecked(IDC_CHECK2);
    if (m_fIgnoreForAdmins != fIgnoreForAdmins)
    {
        SetModified();
    }
    m_fIgnoreForAdmins = fIgnoreForAdmins;
}

BOOL CSignatures::OnInitDialog()
{
    // create temporary store files
    BOOL fFilesCreated = FALSE;
    TCHAR szTempPath[MAX_PATH];
    if (GetTempPath(MAX_PATH, szTempPath))
    {
        TCHAR szTempFile[MAX_PATH];
        if (GetTempFileName(szTempPath,
                            NULL,
                            0,
                            szTempFile))
        {
            m_szTempInstallableStore = szTempFile;
            if (GetTempFileName(szTempPath,
                            NULL,
                            0,
                            szTempFile))
            {
                m_szTempNonInstallableStore = szTempFile;
                fFilesCreated = TRUE;
            }
        }
    }
    if (fFilesCreated)
    {
        CString szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_installable_certs");
        CopyFile(szPath, m_szTempInstallableStore, FALSE);
         szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_non_installable_certs");
        CopyFile(szPath, m_szTempNonInstallableStore, FALSE);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CSignatures::OnInitDialog : Failed to create temporary certificate stores.")));
    }

    CPropertyPage::OnInitDialog();

    // add columns to the lists
    RECT rect;
    m_list1.GetClientRect(&rect);

    CString szTemp;
    szTemp.LoadString(IDS_SIGS_COL1);
    m_list1.InsertColumn(0, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    m_list2.InsertColumn(0, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    szTemp.LoadString(IDS_SIGS_COL2);
    m_list1.InsertColumn(1, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    m_list2.InsertColumn(1, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.35);
    szTemp.LoadString(IDS_SIGS_COL3);
    m_list1.InsertColumn(2, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.25);
    m_list2.InsertColumn(2, szTemp, LVCFMT_LEFT, (rect.right - rect.left) * 0.25);

    // add image lists
    CImageList * pil = NULL;
    pil =  new CImageList;
    if (pil)
    {
        pil->Create(IDB_CERTIFICATE, 16, 0, RGB(255, 0, 255));
        m_list1.SetImageList(pil, LVSIL_SMALL);
    }

    pil =  new CImageList;
    if (pil)
    {
        pil->Create(IDB_CERTIFICATE, 16, 0, RGB(255, 0, 255));
        m_list2.SetImageList(pil, LVSIL_SMALL);
    }

    // retrieve initial registry key setting
    HKEY hKey;
    HRESULT hr = m_pIGPEInformation->GetRegistryKey(m_pScopePane->m_fMachine ?
                                                    GPO_SECTION_MACHINE :
                                                    GPO_SECTION_USER, &hKey);
    if (SUCCEEDED(hr))
    {
        HKEY hSubKey;
        if(ERROR_SUCCESS == RegOpenKeyEx(hKey,
                                      TEXT("Microsoft\\Windows\\Installer"),
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hSubKey))
        {
            DWORD dw;
            DWORD dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hSubKey,
                                                 TEXT("InstallKnownPackagesOnly"),
                                                 NULL,
                                                 NULL,
                                                 (BYTE *)&dw,
                                                 &dwSize))
            {
                m_fAllow = (dw == 1) ? TRUE : FALSE;
                CheckDlgButton(IDC_CHECK1, m_fAllow);
            }
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hSubKey,
                                                 TEXT("IgnoreSignaturePolicyForAdmins"),
                                                 NULL,
                                                 NULL,
                                                 (BYTE *)&dw,
                                                 &dwSize))
            {
                m_fIgnoreForAdmins = (dw == 1) ? TRUE : FALSE;
                CheckDlgButton(IDC_CHECK2, m_fIgnoreForAdmins);
            }
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    RefreshData();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSignatures::OnApply()
{
    HRESULT hr = E_NOTIMPL;
    HKEY hKey;
    hr = m_pIGPEInformation->GetRegistryKey(m_pScopePane->m_fMachine ?
                                                    GPO_SECTION_MACHINE :
                                                    GPO_SECTION_USER, &hKey);
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        HKEY hSubKey;
        if(ERROR_SUCCESS == RegCreateKeyEx(hKey,
                                           TEXT("Microsoft\\Windows\\Installer"),
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hSubKey,
                                           NULL))
        {
            DWORD dw = m_fAllow ? 1 : 0;
            DWORD dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegSetValueEx(hSubKey,
                                               TEXT("InstallKnownPackagesOnly"),
                                               0,
                                               REG_DWORD,
                                               (BYTE *)&dw,
                                               dwSize))
            {
                hr = S_OK;
            }
            dw = m_fIgnoreForAdmins ? 1 : 0;
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegSetValueEx(hSubKey,
                                               TEXT("IgnoreSignaturePolicyForAdmins"),
                                               0,
                                               REG_DWORD,
                                               (BYTE *)&dw,
                                               dwSize))
            {
                hr = S_OK;
            }
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    // copy back the certificate stores
    if (SUCCEEDED(hr))
    {
        m_list1.DeleteAllItems();
        m_list2.DeleteAllItems();

        CString szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_installable_certs");
        CopyFile(m_szTempInstallableStore, szPath, FALSE);
        szPath = m_pScopePane->m_szGPT_Path;
        szPath += TEXT("\\msi_non_installable_certs");
        CopyFile(m_szTempNonInstallableStore, szPath, FALSE);

        RefreshData();
    }
    if (FAILED(hr))
    {
        CString sz;
        sz.LoadString(IDS_CHANGEFAILED);
        ReportGeneralPropertySheetError(m_hWnd, sz, hr);
        return FALSE;
    }
    else
    {
        GUID guid = REGISTRY_EXTENSION_GUID;
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_pScopePane->m_fMachine,
                                                    TRUE,
                                                    &guid,
                                                    m_pScopePane->m_fMachine ? &guidMachSnapin
                                                        : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hWnd);
        }
        // need to call PolicyChanged for Shaji's extension too.

// REMOVE THIS LINE WHEN SHAJI CHECKS IN HIS GUID
#define GUID_MSICERT_CSE  { 0x000c10f4, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }

        GUID guid2 = GUID_MSICERT_CSE;
        if (FAILED(m_pIGPEInformation->PolicyChanged(m_pScopePane->m_fMachine,
                                                    TRUE,
                                                    &guid2,
                                                    m_pScopePane->m_fMachine ? &guidMachSnapin
                                                        : &guidUserSnapin)))
        {
            ReportPolicyChangedError(m_hWnd);
        }
    }
    return CPropertyPage::OnApply();
}


LRESULT CSignatures::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    case WM_NOTIFY:
        {
            LPNMLISTVIEW pnmh = (LPNMLISTVIEW) lParam;
            if (pnmh->hdr.code == LVN_DELETEITEM)
            {
                switch(wParam)
                {
                case IDC_LIST1:
                    CertFreeCertificateContext((PCCERT_CONTEXT)m_list1.GetItemData(pnmh->iItem));
                    break;
                case IDC_LIST2:
                    CertFreeCertificateContext((PCCERT_CONTEXT)m_list2.GetItemData(pnmh->iItem));
                    break;
                }
            }
        }
        return CPropertyPage::WindowProc(message, wParam, lParam);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CSignatures::RefreshData(void)
{
    // populate the listview controls

    m_list1.DeleteAllItems();
    m_list2.DeleteAllItems();

    HCERTSTORE hCertStore = NULL;;
    PCCERT_CONTEXT pcLocalCert = NULL;

    //
    // open the local cert store
    //

    hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                NULL,
//                                CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                CERT_STORE_READONLY_FLAG,
                                m_szTempInstallableStore);

    if (hCertStore)
    {
        //
        // Enumerate the cert store
        //

        int i = 0;

        for (;;) {
            pcLocalCert = CertEnumCertificatesInStore(hCertStore, pcLocalCert);

            if (!pcLocalCert) {
                if (GetLastError() != CRYPT_E_NOT_FOUND )
                {
                    DebugMsg((DM_WARNING, TEXT("CSignatures::RefreshData : Failed to enumerate certificate store.")));
                }
                break;
            }

            TCHAR szCertName[1024];
            TCHAR szIssuerName[1024];
            // crack open the returned certificate and display the data
            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              0,
                              NULL,
                              szCertName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              CERT_NAME_ISSUER_FLAG,
                              NULL,
                              szIssuerName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CTime tExpires(pcLocalCert->pCertInfo->NotAfter);
            CString szExpires = tExpires.Format(TEXT("%x"));

            i = m_list1.InsertItem(i, szCertName, 0);
            m_list1.SetItem(i, 1, LVIF_TEXT, szIssuerName, 0, 0, 0, 0);
            m_list1.SetItem(i, 2, LVIF_TEXT, szExpires, 0, 0, 0, 0);
            m_list1.SetItemData(i, (DWORD_PTR)CertDuplicateCertificateContext(pcLocalCert));

            //pcLocalCert should get deleted when it is repassed into CertEnumCerti..
        }
        CertCloseStore(hCertStore, 0);
    }

    //
    // open the local cert store
    //

    hCertStore = CertOpenStore( CERT_STORE_PROV_FILENAME,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                NULL,
//                                CERT_FILE_STORE_COMMIT_ENABLE_FLAG,
                                CERT_STORE_READONLY_FLAG,
                                m_szTempNonInstallableStore);

    if (hCertStore)
    {
        //
        // Enumerate the cert store
        //

        int i = 0;

        for (;;) {
            pcLocalCert = CertEnumCertificatesInStore(hCertStore, pcLocalCert);

            if (!pcLocalCert) {
                if (GetLastError() != CRYPT_E_NOT_FOUND )
                {
                    DebugMsg((DM_WARNING, TEXT("CSignatures::RefreshData : Failed to enumerate certificate store.")));
                }
                break;
            }

            TCHAR szCertName[1024];
            TCHAR szIssuerName[1024];
            // crack open the returned certificate and display the data
            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              0,
                              NULL,
                              szCertName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CertGetNameString(pcLocalCert,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                              CERT_NAME_ISSUER_FLAG,
                              NULL,
                              szIssuerName,
                              sizeof(szCertName) / sizeof(szCertName[0]));

            CTime tExpires(pcLocalCert->pCertInfo->NotAfter);
            CString szExpires = tExpires.Format(TEXT("%x"));

            i = m_list2.InsertItem(i, szCertName, 0);
            m_list2.SetItem(i, 1, LVIF_TEXT, szIssuerName, 0, 0, 0, 0);
            m_list2.SetItem(i, 2, LVIF_TEXT, szExpires, 0, 0, 0, 0);
            m_list2.SetItemData(i, (DWORD_PTR)CertDuplicateCertificateContext(pcLocalCert));

            //pcLocalCert should get deleted when it is repassed into CertEnumCerti..
        }
        CertCloseStore(hCertStore, 0);
    }

    OnAllowChanged();

    SetModified(FALSE);
}


void CSignatures::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_FILE_EXT);
}
#endif // DIGITAL_SIGNATURES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\sigs.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Sigs.h
//
//  Contents:   Digital Signatures property sheet
//
//  Classes:    CSignatures
//
//  History:    07-10-2000   stevebl   Created
//
//---------------------------------------------------------------------------

#ifdef DIGITAL_SIGNATURES

#if !defined(AFX_SIGS_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_SIGS_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CSignatures dialog

class CSignatures : public CPropertyPage
{
        DECLARE_DYNCREATE(CSignatures)

// Construction
public:
        CSignatures();
        ~CSignatures();
        CScopePane * m_pScopePane;
        IClassAdmin *   m_pIClassAdmin;
        BOOL m_fAllow;
        BOOL m_fIgnoreForAdmins;
        BOOL m_fRSOP;
        LPGPEINFORMATION    m_pIGPEInformation;
        CListCtrl   m_list1;
        CListCtrl   m_list2;
        CString     m_szTempInstallableStore;
        CString     m_szTempNonInstallableStore;
        CSignatures ** m_ppThis;
        int         m_nSortedColumn;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CSignatures)
        enum { IDD = IDD_SIGNATURES };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CSignatures)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CSignatures)
        afx_msg void OnAddAllow();
        afx_msg void OnDeleteAllow();
        afx_msg void OnPropertiesAllow();
        afx_msg void OnAddDisallow();
        afx_msg void OnDeleteDisallow();
        afx_msg void OnPropertiesDisallow();
        afx_msg void OnAllowChanged();
        afx_msg void OnIgnoreChanged();
        virtual BOOL OnInitDialog();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG\

        void AddCertificate(CString &szStore);
        void RemoveCertificate(CString &szStore, CListCtrl &list);
        void CertificateProperties(CString &szStore, CListCtrl &list);
        HRESULT AddToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore);
        HRESULT AddMSIToCertStore(LPWSTR lpFileName, LPWSTR lpFileStore);
        void ReportFailure(DWORD dwMessage, HRESULT hr);

        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIGS_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#endif DIGITAL_SIGNATURES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\rsoputil.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.h
//
//  Contents:   helper functions for working with the RSOP database
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData);

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//              (Note that BSTR is a special case since the compiler can't
//              distinguish it from a TCHAR * but it's semantics are
//              different.)
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData);
HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, GUID * &rgGuid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, TCHAR ** &rgszData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, CSPLATFORM * &rgPlatform);
HRESULT CStringFromWBEMTime(CString &szOut, BSTR bstrIn, BOOL fShortFormat);

//+--------------------------------------------------------------------------
//
//  Function:   GetGPOFriendlyName
//
//  Synopsis:
//
//  Arguments:  [pIWbemServices] -
//              [lpGPOID]        -
//              [pLanguage]      -
//              [pGPOName]       -
//              [pGPOPath]       -
//
//  Returns:
//
//  Modifies:
//
//  History:    01-26-2000   stevebl   Stolen from code written by EricFlo
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID,
                           BSTR pLanguage,
                           LPTSTR *pGPOName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\stdafx.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       stdafx.h
//
//  Contents:   include file for standard system include files, or project
//              specific include files that are used frequently, but are
//              changed infrequently
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#ifdef DBG
//
// ATL's implementation of Release always returns 0 unless _DEBUG is
// defined. The debug version of OLE.DLL asserts Release() != 0 in certain
// circumstances.  I don't want to define _DEBUG because it brings in a
// whole lot of baggage from MMC that I don't want to deal with, but I do
// want to avoid this assertion in OLE, so on debug builds, I'll go ahead
// and define _DEBUG for the appropriate ATL header file but I'll undefine
// it again right afterward.  This is a little flakey but it is relatively
// safe and it achieves the desired goal.
//
// - SteveBl
//
#define _DEBUG
#endif
#include <atlcom.h>
#ifdef DBG
#undef _DEBUG
#endif

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

const long UNINITIALIZED = -1;

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    CString             m_string;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};


// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\tooladv.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolAdv.h
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolAdvDefs
//
//  History:    09-12-2000   stevebl   Split from the General property page
//
//---------------------------------------------------------------------------

#if !defined(AFX_TOOLADV_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_TOOLADV_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CToolAdvDefs dialog

class CToolAdvDefs : public CPropertyPage
{
// Construction
public:
        CToolAdvDefs(CWnd* pParent = NULL);   // standard constructor
        ~CToolAdvDefs();

// Dialog Data
        //{{AFX_DATA(CToolAdvDefs)
        enum { IDD = IDD_TOOL_ADVANCEDDEFAULTS };
        BOOL    m_fUninstallOnPolicyRemoval;
        BOOL    m_fShowPackageDetails;
        BOOL    m_fZapOn64;
        BOOL    m_f32On64;
        BOOL    m_fIncludeOLEInfo;
        //}}AFX_DATA
        TOOL_DEFAULTS * m_pToolDefaults;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fMachine;

        CToolAdvDefs ** m_ppThis;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CToolAdvDefs)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CToolAdvDefs)
        virtual BOOL OnInitDialog();
        afx_msg void OnChanged();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TOOLADV_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\tooldefs.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolDefs.cpp
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolDefs
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolDefs dialog


CToolDefs::CToolDefs(CWnd* pParent /*=NULL*/)
    : CPropertyPage(CToolDefs::IDD)
{
    //{{AFX_DATA_INIT(CToolDefs)
    m_szStartPath = _T("");
    m_iUI = -1;
        m_iDeployment = -1;
        //}}AFX_DATA_INIT
}

CToolDefs::~CToolDefs()
{
    *m_ppThis = NULL;
}

void CToolDefs::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CToolDefs)
    DDX_Text(pDX, IDC_EDIT1, m_szStartPath);
    DDX_Radio(pDX, IDC_RADIO8, m_iUI);
        DDX_Radio(pDX, IDC_RADIO2, m_iDeployment);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CToolDefs, CDialog)
    //{{AFX_MSG_MAP(CToolDefs)
    ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
    ON_BN_CLICKED(IDC_RADIO1, OnChanged)
    ON_BN_CLICKED(IDC_RADIO2, OnChanged)
    ON_BN_CLICKED(IDC_RADIO4, OnChanged)
    ON_BN_CLICKED(IDC_RADIO5, OnChanged)
    ON_BN_CLICKED(IDC_RADIO6, OnChanged)
    ON_BN_CLICKED(IDC_RADIO8, OnChanged)
    ON_BN_CLICKED(IDC_RADIO7, OnChanged)
    ON_EN_CHANGE(IDC_EDIT1, OnChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolDefs message handlers

BOOL CToolDefs::OnInitDialog()
{
    GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE==m_fMachine);
    m_szStartPath = m_pToolDefaults->szStartPath;
    if (m_pToolDefaults->fUseWizard)
    {
        m_iDeployment = 0;
    }
    else
    {
        if (m_pToolDefaults->fCustomDeployment)
        {
            m_iDeployment = 3;
        }
        else
        {
            switch (m_pToolDefaults->NPBehavior)
            {
            default:
            case NP_PUBLISHED:
                m_iDeployment = 1;
                if (m_fMachine)
                {
                    m_iDeployment = 0;
                }
                break;
            case NP_ASSIGNED:
                m_iDeployment = 2;
                break;
            case NP_DISABLED:
                m_iDeployment = 4;
                break;
            }
        }
    }

    switch (m_pToolDefaults->UILevel)
    {
    case INSTALLUILEVEL_FULL:
        m_iUI = 1;
        break;
    case INSTALLUILEVEL_BASIC:
    default:
        m_iUI = 0;
        break;
    }

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

#include <shlobj.h>

void CToolDefs::OnBrowse()
{
    IMalloc * pmalloc;
    if (SUCCEEDED(SHGetMalloc(&pmalloc)))
    {
        LPITEMIDLIST pidlNetwork;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_NETWORK, &pidlNetwork)))
        {
            BROWSEINFO bi;
            memset(&bi, 0, sizeof(bi));
            OLECHAR szDisplayName[MAX_PATH];
            bi.pszDisplayName = szDisplayName;
            CString sz;
            sz.LoadString(IDS_BROWSEFOLDERS);
            bi.lpszTitle = sz;
            bi.pidlRoot = pidlNetwork;
            bi.ulFlags = BIF_RETURNONLYFSDIRS;
            LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
            if (NULL != pidl)
            {
                OLECHAR szPath[MAX_PATH];
                if (SHGetPathFromIDList(pidl, szPath))
                {
                    m_szStartPath = szPath;
                    UpdateData(FALSE);
                    SetModified();
                }
                pmalloc->Free(pidl);
            }
        }
        pmalloc->Release();
    }

}

BOOL CToolDefs::OnApply()
{
    m_pToolDefaults->fUseWizard = FALSE;
    m_pToolDefaults->fCustomDeployment = FALSE;
    m_pToolDefaults->szStartPath = m_szStartPath;
    switch (m_iDeployment)
    {
    default:
    case 0: // display dialog
        m_pToolDefaults->fUseWizard = TRUE;
        m_pToolDefaults->NPBehavior = NP_PUBLISHED;
        break;
    case 1: // published
        m_pToolDefaults->NPBehavior = NP_PUBLISHED;
        break;
    case 2: // assigned
        m_pToolDefaults->NPBehavior = NP_ASSIGNED;
        break;
    case 3: // configure
        m_pToolDefaults->NPBehavior = NP_PUBLISHED;
        m_pToolDefaults->fCustomDeployment = TRUE;
        break;
    case 4: // disabled
        m_pToolDefaults->NPBehavior = NP_DISABLED;
        break;
    }

    switch (m_iUI)
    {
    case 1:
        m_pToolDefaults->UILevel = INSTALLUILEVEL_FULL;
        break;
    case 0:
    default:
        m_pToolDefaults->UILevel = INSTALLUILEVEL_BASIC;
    }

    MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);

    return CPropertyPage::OnApply();
}


void CToolDefs::OnChanged()
{
    SetModified();
}

LRESULT CToolDefs::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}


void CToolDefs::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_TOOL_DEFAULTS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\tooladv.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolAdv.cpp
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolAdvDefs
//
//  History:    09-12-2000   stevebl   Split from General property page
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolAdvDefs dialog


CToolAdvDefs::CToolAdvDefs(CWnd* pParent /*=NULL*/)
    : CPropertyPage(CToolAdvDefs::IDD)
{
    //{{AFX_DATA_INIT(CToolAdvDefs)
        m_fUninstallOnPolicyRemoval = FALSE;
        m_fShowPackageDetails = FALSE;
        m_fZapOn64 = FALSE;
        m_f32On64=FALSE;
        m_fIncludeOLEInfo = FALSE;
        //}}AFX_DATA_INIT
}

CToolAdvDefs::~CToolAdvDefs()
{
    *m_ppThis = NULL;
}

void CToolAdvDefs::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CToolAdvDefs)
        DDX_Check(pDX, IDC_CHECK4, m_fUninstallOnPolicyRemoval);
        DDX_Check(pDX, IDC_CHECK2, m_fShowPackageDetails);
        DDX_Check(pDX, IDC_CHECK5, m_f32On64);
        DDX_Check(pDX, IDC_CHECK6, m_fZapOn64);
        DDX_Check(pDX, IDC_CHECK7, m_fIncludeOLEInfo);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CToolAdvDefs, CDialog)
    //{{AFX_MSG_MAP(CToolAdvDefs)
    ON_BN_CLICKED(IDC_CHECK2, OnChanged)
    ON_BN_CLICKED(IDC_CHECK4, OnChanged)
    ON_BN_CLICKED(IDC_CHECK5, OnChanged)
    ON_BN_CLICKED(IDC_CHECK6, OnChanged)
    ON_BN_CLICKED(IDC_CHECK7, OnChanged)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolAdvDefs message handlers

BOOL CToolAdvDefs::OnInitDialog()
{
#if DBG
    GetDlgItem(IDC_CHECK2)->ShowWindow(SW_SHOW);
    GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
#endif
    m_fUninstallOnPolicyRemoval = m_pToolDefaults->fUninstallOnPolicyRemoval;
    m_fShowPackageDetails = m_pToolDefaults->fShowPkgDetails;
    m_fZapOn64 = m_pToolDefaults->fZapOn64;
    m_f32On64 = m_pToolDefaults->f32On64;
    m_fIncludeOLEInfo = !m_pToolDefaults->fExtensionsOnly;

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

#include <shlobj.h>

BOOL CToolAdvDefs::OnApply()
{
    m_pToolDefaults->fShowPkgDetails = m_fShowPackageDetails;
    m_pToolDefaults->fUninstallOnPolicyRemoval = m_fUninstallOnPolicyRemoval;
    m_pToolDefaults->f32On64 = m_f32On64;
    m_pToolDefaults->fZapOn64 = m_fZapOn64;
    m_pToolDefaults->fExtensionsOnly = !m_fIncludeOLEInfo;

    MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);

    return CPropertyPage::OnApply();
}


void CToolAdvDefs::OnChanged()
{
    SetModified();
}

LRESULT CToolAdvDefs::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}


void CToolAdvDefs::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_TOOL_ADVANCEDDEFAULTS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\snapin.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       snapin.cpp
//
//  Contents:   DLL support routines, class factory and registration
//              functions.
//
//  Classes:
//
//  Functions:
//
//  History:    2-12-1998   stevebl   comment header added
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "initguid.h"
#include "gpedit.h"

extern const CLSID CLSID_Snapin = {0xBACF5C8A,0xA3C7,0x11D1,{0xA7,0x60,0x00,0xC0,0x4F,0xB9,0x60,0x3F}};
extern const wchar_t * szCLSID_Snapin = L"{BACF5C8A-A3C7-11D1-A760-00C04FB9603F}";
extern const CLSID CLSID_MachineSnapin = {0x942A8E4F,0xA261,0x11D1,{0xA7,0x60,0x00,0xc0,0x4f,0xb9,0x60,0x3f}};
extern const wchar_t * szCLSID_MachineSnapin = L"{942A8E4F-A261-11D1-A760-00C04FB9603F}";

// Main NodeType GUID on numeric format
extern const GUID cNodeType = {0xF8B3A900,0X8EA5,0X11D0,{0X8D,0X3C,0X00,0XA0,0XC9,0X0D,0XCA,0XE7}};

// Main NodeType GUID on string format
extern const wchar_t*  cszNodeType = L"{F8B3A900-8EA5-11D0-8D3C-00A0C90DCAE7}";

// No public place for this now, real def is in gina\gpext\appmgmt\cs.idl.
extern const IID IID_IClassAdmin = {0x00000191,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// RSOP flavors:

extern const CLSID CLSID_RSOP_Snapin = {
    0x1bc972d6,
    0x555c,
    0x4ff7,
    {0xbe, 0x2c, 0xc5, 0x84, 0x02, 0x1a, 0x0a, 0x6a}};
extern const wchar_t * szCLSID_RSOP_Snapin = L"{1BC972D6-555C-4FF7-BE2C-C584021A0A6A}";
extern const CLSID CLSID_RSOP_MachineSnapin = {
    0x7e45546f,
    0x6d52,
    0x4d10,
    {0xb7, 0x02, 0x9c, 0x2e, 0x67, 0x23, 0x2e, 0x62}};
extern const wchar_t * szCLSID_RSOP_MachineSnapin = L"{7E45546F-6D52-4D10-B702-9C2E67232E62}";

#include "safereg.hxx"

#define BREAK_ON_FAIL_HRESULT(hr) if (FAILED(hr)) break

#define PSBUFFER_STR    L"AppManagementBuffer"
#define THREADING_STR   L"Apartment"

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Snapin, CUserComponentDataImpl)
        OBJECT_ENTRY(CLSID_MachineSnapin, CMachineComponentDataImpl)
        OBJECT_ENTRY(CLSID_RSOP_Snapin, CRSOPUserComponentDataImpl)
        OBJECT_ENTRY(CLSID_RSOP_MachineSnapin, CRSOPMachineComponentDataImpl)
END_OBJECT_MAP()

CLSID CLSID_Temp;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSnapinApp theApp;

HINSTANCE ghInstance;

BOOL CSnapinApp::InitInstance()
{
        ghInstance = m_hInstance;
        _Module.Init(ObjectMap, m_hInstance);
//        CoGetMalloc(1, &g_pIMalloc);
#if DBG
       InitDebugSupport();
#endif
        // Add theme'ing support
        SHFusionInitializeFromModuleID (m_hInstance, 2);
        
        return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNT(CResultPane);
        DEBUG_VERIFY_INSTANCE_COUNT(CScopePane);

        // Cleanup required by fusion support
        SHFusionUninitialize();
        
//        g_pIMalloc->Release();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

const wchar_t * szUser_Namespace = L"{59849DF9-A256-11D1-A760-00C04FB9603F}";
const wchar_t * szMachine_Namespace = L"{4D53F093-A260-11D1-A760-00C04FB9603F}";
const wchar_t * szMachineAppName = L"Software Installation (Computers)";
const wchar_t * szUserAppName = L"Software Installation (Users)";
const wchar_t * szUser_RSOP_Namespace = L"{9D5EB218-8EA3-4EE9-B120-52FC68C8D128}";
const wchar_t * szMachine_RSOP_Namespace = L"{DFA38559-8B35-42EF-8B00-E8F6CBF99BC0}";

const wchar_t * szUserAppNameIndirect = L"@appmgr.dll,-50";
const wchar_t * szMachineAppNameIndirect = L"@appmgr.dll,-51";

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    CSafeReg    shk;
    CSafeReg    shkCLSID;
    CSafeReg    shkServer;
    CSafeReg    shkTemp;
    HRESULT hr = S_OK;

    do
    {
        CLSID_Temp = CLSID_Snapin;
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szUserAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szUserAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();

        hr = shkCLSID.Create(szCLSID_MachineSnapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szMachineAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szMachine_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        hr = shkCLSID.Create(szMachine_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        WCHAR szGUID[50];
        StringFromGUID2 (NODEID_UserSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();

        StringFromGUID2 (NODEID_MachineSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_MachineSnapin,
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();


        //
        // RSOP versions
        //

        CLSID_Temp = CLSID_RSOP_Snapin;
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_RSOP_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szUserAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szUserAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_RSOP_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();

        hr = shkCLSID.Create(szCLSID_RSOP_MachineSnapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));

        hr = shk.SetValue(L"NameStringIndirect",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppNameIndirect,
                          sizeof(WCHAR) * (lstrlen(szMachineAppNameIndirect)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szMachine_RSOP_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_RSOP_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        hr = shkCLSID.Create(szMachine_RSOP_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        StringFromGUID2 (NODEID_RSOPUserSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_RSOP_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();

        StringFromGUID2 (NODEID_RSOPMachineSWSettings, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_RSOP_MachineSnapin,
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();


        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    CLSID_Temp = CLSID_Snapin;
    _Module.UnregisterServer();

    HKEY hkey;
    CString sz;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_Snapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_Namespace));
        RegCloseKey(hkey);
    }
    WCHAR szGUID[50];
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_UserSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_Snapin);
        RegCloseKey(hkey);
    }

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_MachineSnapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szMachine_Namespace));
        RegCloseKey(hkey);
    }
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_MachineSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_MachineSnapin);
        RegCloseKey(hkey);
    }

    //
    // RSOP versions
    //

    CLSID_Temp = CLSID_RSOP_Snapin;
    _Module.UnregisterServer();

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_RSOP_Snapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_RSOP_Namespace));
        RegCloseKey(hkey);
    }
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_RSOPUserSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_Snapin);
        RegCloseKey(hkey);
    }

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_RSOP_MachineSnapin));
        RegCloseKey(hkey);
    }
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szMachine_Namespace));
        RegCloseKey(hkey);
    }
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_RSOPMachineSWSettings, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    if (hkey)
    {
        RegDeleteValue(hkey, szCLSID_RSOP_MachineSnapin);
        RegCloseKey(hkey);
    }

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RegisterInterface
//
//  Synopsis:   Add the registry entries required for an interface.
//
//  Arguments:  [pshkInterface]    - handle to CLSID\Interface key
//              [wszInterfaceGUID] - GUID of interface to add
//              [wszInterfaceName] - human-readable name of interface
//              [wszNumMethods]    - number of methods (including inherited)
//              [wszProxyCLSID]    - GUID of dll containing proxy/stubs
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//              5-09-1997   SteveBl    Modified for use with AppMgr
//
//---------------------------------------------------------------------------

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID)
{
    HRESULT     hr = S_OK;
    CSafeReg    shkIID;
    CSafeReg    shkNumMethods;
    CSafeReg    shkProxy;

    do
    {
        hr = pshkInterface->Create(wszInterfaceGUID, &shkIID);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.SetValue(NULL,
                             REG_SZ,
                             (CONST BYTE *) wszInterfaceName,
                             sizeof(WCHAR) * (lstrlen(wszInterfaceName) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"NumMethods", &shkNumMethods);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNumMethods.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)wszNumMethods,
                                sizeof(WCHAR) * (lstrlen(wszNumMethods) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"ProxyStubClsid32", &shkProxy);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkProxy.SetValue(NULL,
                               REG_SZ,
                               (CONST BYTE *)wszProxyCLSID,
                               sizeof(WCHAR) * (lstrlen(wszProxyCLSID) + 1));
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\tooldefs.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       ToolDefs.h
//
//  Contents:   tool-wide default settings property page
//
//  Classes:    CToolDefs
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CToolDefs dialog

class CToolDefs : public CPropertyPage
{
// Construction
public:
        CToolDefs(CWnd* pParent = NULL);   // standard constructor
        ~CToolDefs();

// Dialog Data
        //{{AFX_DATA(CToolDefs)
        enum { IDD = IDD_TOOL_DEFAULTS };
        CString m_szStartPath;
        int             m_iUI;
        int             m_iDeployment;
        //}}AFX_DATA
        TOOL_DEFAULTS * m_pToolDefaults;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fMachine;

        CToolDefs ** m_ppThis;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CToolDefs)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CToolDefs)
        virtual BOOL OnInitDialog();
        afx_msg void OnBrowse();
        afx_msg void OnChanged();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\tracking.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Tracking.cpp
//
//  Contents:   tracking property sheet
//
//  Classes:    CTracking
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTracking property page

IMPLEMENT_DYNCREATE(CTracking, CPropertyPage)

CTracking::CTracking() : CPropertyPage(CTracking::IDD)
{
        //{{AFX_DATA_INIT(CTracking)
        //}}AFX_DATA_INIT
    m_pIClassAdmin = NULL;
}

CTracking::~CTracking()
{
    *m_ppThis = NULL;
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CTracking::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CTracking)
        DDX_Control(pDX, IDC_SPIN1, m_spin);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTracking, CPropertyPage)
        //{{AFX_MSG_MAP(CTracking)
        ON_BN_CLICKED(IDC_BUTTON1, OnCleanUpNow)
        ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN1, OnDeltaposSpin1)
        ON_EN_CHANGE(IDC_EDIT1, OnChangeEdit1)
        ON_EN_KILLFOCUS(IDC_EDIT1, OnKillfocusEdit1)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTracking message handlers

void CTracking::OnCleanUpNow()
{
    FILETIME ft;
    SYSTEMTIME st;
    // get current time
    GetSystemTime(&st);
    // convert it to a FILETIME value
    SystemTimeToFileTime(&st, &ft);
    // subtract the right number of days
    LARGE_INTEGER li;
    li.LowPart = ft.dwLowDateTime;
    li.HighPart = ft.dwHighDateTime;
    li.QuadPart -= ONE_FILETIME_DAY * (((LONGLONG)m_pToolDefaults->nUninstallTrackingMonths * 365) / 12);
    ft.dwLowDateTime = li.LowPart;
    ft.dwHighDateTime = li.HighPart;
    // tell the CS to clean up anything older
    m_pIClassAdmin->Cleanup(&ft);
}

BOOL CTracking::OnApply()
{
        // TODO: Add your specialized code here and/or call the base class
        m_pToolDefaults->nUninstallTrackingMonths = (ULONG) m_spin.GetPos();
        MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);
        return CPropertyPage::OnApply();
}

BOOL CTracking::OnInitDialog()
{
        CPropertyPage::OnInitDialog();
        m_spin.SetRange(1,60);
        m_spin.SetPos(m_pToolDefaults->nUninstallTrackingMonths);
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CTracking::OnDeltaposSpin1(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
        *pResult = 0;
        SetModified(m_spin.GetPos() != m_pToolDefaults->nUninstallTrackingMonths);
}

LRESULT CTracking::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CTracking::OnChangeEdit1()
{
    SetModified(m_spin.GetPos() != m_pToolDefaults->nUninstallTrackingMonths);
}

void CTracking::OnKillfocusEdit1()
{
    // Reset the spin control to pull any values in the edit control back
    // into range if necessary.
    m_spin.SetPos(m_spin.GetPos());
}

void CTracking::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_UNINSTALLTRACKING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\uplist.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       UpList.cpp
//
//  Contents:   upgrade realationships property sheet
//
//  Classes:    CUpgradeList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// uncomment the following line to allow double clicking on a list box to
// launch a property sheet for the the thing you've double clicked on
// #define DOUBLECLICKLAUNCH 1

/////////////////////////////////////////////////////////////////////////////
// CUpgradeList property page

IMPLEMENT_DYNCREATE(CUpgradeList, CPropertyPage)

CUpgradeList::CUpgradeList() : CPropertyPage(CUpgradeList::IDD)
{
    //{{AFX_DATA_INIT(CUpgradeList)
        m_fForceUpgrade = FALSE;
        //}}AFX_DATA_INIT
    m_ppThis = NULL;
    m_fModified = FALSE;
    m_pIClassAdmin = NULL;
    m_fPreDeploy = FALSE;
}

CUpgradeList::~CUpgradeList()
{
    if (m_ppThis)
    {
        *m_ppThis = NULL;
    }
    if (m_pIClassAdmin)
    {
        m_pIClassAdmin->Release();
    }
}

void CUpgradeList::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUpgradeList)
    DDX_Control(pDX, IDC_LIST2, m_UpgradedBy);
    DDX_Control(pDX, IDC_LIST1, m_Upgrades);
        DDX_Check(pDX, IDC_CHECK1, m_fForceUpgrade);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUpgradeList, CPropertyPage)
    //{{AFX_MSG_MAP(CUpgradeList)
        ON_LBN_DBLCLK(IDC_LIST1, OnDblclkList1)
        ON_LBN_DBLCLK(IDC_LIST2, OnDblclkList2)
        ON_BN_CLICKED(IDC_CHECK1, OnRequire)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON3, OnRemove)
        ON_BN_CLICKED(IDC_BUTTON2, OnEdit)
        ON_LBN_SELCHANGE(IDC_LIST1, OnSelchangeList1)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUpgradeList message handlers

LRESULT CUpgradeList::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        m_dlgAdd.EndDialog(IDCANCEL);
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

BOOL CUpgradeList::OnInitDialog()
{
    m_dlgAdd.m_pUpgradeList = &m_UpgradeList;
    m_dlgAdd.m_pScope = m_pScopePane;
    m_fForceUpgrade = (0 != (m_pData->m_pDetails->pInstallInfo->dwActFlags & ACTFLG_ForceUpgrade));
    if (m_fMachine)
    {
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    }
    if (m_fRSOP)
    {
        CString szText;
        szText.LoadString(IDS_RSOPUPGRADEDTEXT);
        SetDlgItemText(IDC_STATIC1, szText);
    }

    CPropertyPage::OnInitDialog();

    RefreshData();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CUpgradeList::RefreshData()
{
    GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
    CString szUpgrade;
    CString szReplace;
    szUpgrade.LoadString(IDS_UPGRADE);
    szReplace.LoadString(IDS_REPLACE);
    m_Upgrades.ResetContent();
    m_Upgrades.SetHorizontalExtent(0);
    m_UpgradedBy.ResetContent();
    m_UpgradedBy.SetHorizontalExtent(0);
    m_UpgradeList.erase(m_UpgradeList.begin(), m_UpgradeList.end());
    m_NameIndex.erase(m_NameIndex.begin(), m_NameIndex.end());

    // populate m_Upgrades and m_UpgradedBy
    if (m_fRSOP)
    {
        // disable EVERYTHING
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);

        // populate the upgrade lists using the RSOP data
        set <CString>::iterator i;
        i = m_pData->m_setUpgradedBy.begin();
        while (i != m_pData->m_setUpgradedBy.end())
        {
            m_UpgradedBy.AddString(*i);
            CDC * pDC = m_UpgradedBy.GetDC();
            CSize size = pDC->GetTextExtent(*i);
            pDC->LPtoDP(&size);
            m_UpgradedBy.ReleaseDC(pDC);
            if (m_UpgradedBy.GetHorizontalExtent() < size.cx)
            {
                m_UpgradedBy.SetHorizontalExtent(size.cx);
            }
            i++;
        }
        i = m_pData->m_setUpgrade.begin();
        while (i != m_pData->m_setUpgrade.end())
        {
            CString sz;
            sz = szUpgrade;
            sz += L'\t';
            sz += *i;
            m_Upgrades.AddString(sz);
            CDC * pDC = m_Upgrades.GetDC();
            CSize size = pDC->GetTextExtent(*i);
            pDC->LPtoDP(&size);
            m_Upgrades.ReleaseDC(pDC);
            if (m_Upgrades.GetHorizontalExtent() < size.cx)
            {
                m_Upgrades.SetHorizontalExtent(size.cx);
            }
            i++;
        }
        i = m_pData->m_setReplace.begin();
        while (i != m_pData->m_setReplace.end())
        {
            CString sz;
            sz = szReplace;
            sz += L'\t';
            sz += *i;
            m_Upgrades.AddString(sz);
            CDC * pDC = m_Upgrades.GetDC();
            CSize size = pDC->GetTextExtent(*i);
            pDC->LPtoDP(&size);
            m_Upgrades.ReleaseDC(pDC);
            if (m_Upgrades.GetHorizontalExtent() < size.cx)
            {
                m_Upgrades.SetHorizontalExtent(size.cx);
            }
            i++;
        }
    }
    else
    {
        UINT n = m_pData->m_pDetails->pInstallInfo->cUpgrades;
        while (n--)
        {
            CString szPackageName;
            CUpgradeData data;
            memcpy(&data.m_PackageGuid, &m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid, sizeof(GUID));
            data.m_szClassStore = m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore;
            data.m_flags = m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag;
            HRESULT hr = m_pScopePane->GetPackageNameFromUpgradeInfo(szPackageName, data.m_PackageGuid, (LPOLESTR)((LPCWSTR)data.m_szClassStore));
            if (SUCCEEDED(hr))
            {
                // found a match
                if (0 != (UPGFLG_UpgradedBy & data.m_flags))
                {
                    m_UpgradedBy.AddString(szPackageName);
                    CDC * pDC = m_UpgradedBy.GetDC();
                    CSize size = pDC->GetTextExtent(szPackageName);
                    pDC->LPtoDP(&size);
                    m_UpgradedBy.ReleaseDC(pDC);
                    if (m_UpgradedBy.GetHorizontalExtent() < size.cx)
                    {
                        m_UpgradedBy.SetHorizontalExtent(size.cx);
                    }
                }
                else
                {
                    CString sz = UPGFLG_Uninstall == m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag ? szReplace : szUpgrade;
                    sz += L'\t';
                    sz += szPackageName;
                    m_Upgrades.AddString(sz);
                    CDC * pDC = m_Upgrades.GetDC();
                    CSize size = pDC->GetTextExtent(sz);
                    pDC->LPtoDP(&size);
                    m_Upgrades.ReleaseDC(pDC);
                    if (m_Upgrades.GetHorizontalExtent() < size.cx)
                    {
                        m_Upgrades.SetHorizontalExtent(size.cx);
                    }
                    CString szIndex = GetUpgradeIndex(data.m_PackageGuid);
                    m_UpgradeList[szIndex] = data;
                    m_NameIndex[sz] = szIndex;
                }
            }
        }
    }
}


void CUpgradeList::OnDblclkList1()
{
#if DOUBLECLICKLAUNCH
    int i = m_Upgrades.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_Upgrades.GetText(i, sz);
        m_pScopePane->DisplayPropSheet(sz, 2);
    }
#endif
}

void CUpgradeList::OnDblclkList2()
{
#if DOUBLECLICKLAUNCH
    int i = m_UpgradedBy.GetCurSel();
    if (i != LB_ERR)
    {
        CString sz;
        m_UpgradedBy.GetText(i, sz);
        m_pScopePane->DisplayPropSheet(sz, 2);
    }
#endif
}

void CUpgradeList::OnRequire()
{
    if (!m_fPreDeploy)
        SetModified();
    m_fModified = TRUE;
}

void CUpgradeList::OnAdd()
{
    CString szUpgrade;
    CString szReplace;
    szUpgrade.LoadString(IDS_UPGRADE);
    szReplace.LoadString(IDS_REPLACE);

    m_dlgAdd.m_szMyGuid = GetUpgradeIndex(m_pData->m_pDetails->pInstallInfo->PackageGuid);

    if (IDOK == m_dlgAdd.DoModal())
    {
        CString szIndex = GetUpgradeIndex(m_dlgAdd.m_UpgradeData.m_PackageGuid);
        if (IsUpgradeLegal(szIndex))
        {
            // add the chosen app
            m_UpgradeList[szIndex] = m_dlgAdd.m_UpgradeData;
            // m_dlgAdd.m_fUninstall ? UPGFLG_Uninstall : UPGFLG_NoUninstall;
            CString sz = 0 != (m_dlgAdd.m_UpgradeData.m_flags & UPGFLG_Uninstall) ? szReplace : szUpgrade;
            sz += L'\t';
            sz += m_dlgAdd.m_szPackageName;
            m_Upgrades.AddString(sz);
            CDC * pDC = m_Upgrades.GetDC();
            CSize size = pDC->GetTextExtent(sz);
            pDC->LPtoDP(&size);
            m_Upgrades.ReleaseDC(pDC);
            if (m_Upgrades.GetHorizontalExtent() < size.cx)
            {
                m_Upgrades.SetHorizontalExtent(size.cx);
            }
            m_NameIndex[sz] = szIndex;
            if (!m_fPreDeploy)
                SetModified();
            m_fModified = TRUE;
        }
        else
        {
            CString szText;
            szText.LoadString(IDS_INVALIDUPGRADE);
            MessageBox(szText, m_dlgAdd.m_szPackageName, MB_ICONEXCLAMATION | MB_OK);
        }
    }

}

BOOL CUpgradeList::IsUpgradeLegal(CString sz)
{
    // for now I'll just check to make sure that this guy isn't upgrading me
    CString sz2;
    UINT n = m_pData->m_pDetails->pInstallInfo->cUpgrades;
    while (n--)
    {
        if (0 != (UPGFLG_UpgradedBy & m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].Flag))
        {
            sz2 = GetUpgradeIndex(m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].PackageGuid);
            if (0 == sz.CompareNoCase(sz2))
                return FALSE;
        }
    }
    return TRUE;
}

void CUpgradeList::OnSelchangeList1()
{
    int iSel = m_Upgrades.GetCurSel();
    if (iSel != LB_ERR)
    {
        CString sz;
        m_Upgrades.GetText(iSel, sz);
    }
    GetDlgItem(IDC_BUTTON3)->EnableWindow( !m_fRSOP );
}

void CUpgradeList::OnRemove()
{
    int iSel = m_Upgrades.GetCurSel();
    if (iSel != LB_ERR)
    {
        CString sz;
        m_Upgrades.GetText(iSel, sz);
        // check to be sure app does not have UPGFLG_Enforced

        m_UpgradeList.erase(m_NameIndex[sz]);
        m_NameIndex.erase(sz);
        m_Upgrades.DeleteString(iSel);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
        if (GetDlgItem(IDC_BUTTON3) == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
        GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
    }
}

void CUpgradeList::OnEdit()
{
    // TODO: Add your control notification handler code here
}

BOOL CUpgradeList::OnApply()
{
    if (m_fModified)
    {
        // Set the new upgrade list and flags
        DWORD dwActFlags = m_pData->m_pDetails->pInstallInfo->dwActFlags;

        if (m_fForceUpgrade)
            dwActFlags |= ACTFLG_ForceUpgrade;
        else
            dwActFlags &= ~ACTFLG_ForceUpgrade;

        // Pilot flag stuff is for backward compatability - it will
        // eventually be yanked.
        UINT n = m_UpgradeList.size();
        if (n)
        {
            if (m_fForceUpgrade)
                dwActFlags &= ~ACTFLG_Pilot;
            else
                dwActFlags |= ACTFLG_Pilot;
        }
        else
        {
            // no upgrades left in the list - remove the pilot flag just
            // to be safe
            dwActFlags &= ~ACTFLG_Pilot;
        }

        // count the "upgraded by" elements
        UINT n2 = m_pData->m_pDetails->pInstallInfo->cUpgrades;
        while (n2--)
        {
            if (0 != (UPGFLG_UpgradedBy & m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].Flag))
            {
                n++;
            }
        }
        UINT cUpgrades = n;
        UPGRADEINFO * prgUpgradeInfoList = NULL;

        if (n)
        {
            prgUpgradeInfoList = (UPGRADEINFO *) OLEALLOC(sizeof(UPGRADEINFO) * n);

            if (prgUpgradeInfoList)
            {
                n = 0;

                // add the "upgraded by" elements
                n2 = m_pData->m_pDetails->pInstallInfo->cUpgrades;
                while (n2--)
                {
                    if (0 != (UPGFLG_UpgradedBy & m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].Flag))
                    {
                        prgUpgradeInfoList[n].Flag = m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].Flag;
                        OLESAFE_COPYSTRING(prgUpgradeInfoList[n].szClassStore, m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].szClassStore);
                        memcpy(&prgUpgradeInfoList[n].PackageGuid, &m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n2].PackageGuid, sizeof(GUID));
                        n++;
                    }
                }

                // add the "upgrading" elements
                map <CString, CUpgradeData>::iterator i;
                for (i = m_UpgradeList.begin(); i != m_UpgradeList.end(); i++)
                {
                    prgUpgradeInfoList[n].Flag = i->second.m_flags;
                    OLESAFE_COPYSTRING(prgUpgradeInfoList[n].szClassStore, i->second.m_szClassStore);
                    memcpy(&prgUpgradeInfoList[n].PackageGuid, &i->second.m_PackageGuid, sizeof(GUID));
                    n++;
                }
            }
            else
            {
                // out of memory
                HRESULT hr = E_OUTOFMEMORY;
                CString sz;
                sz.LoadString(IDS_CHANGEFAILED);
                ReportGeneralPropertySheetError(m_hWnd, sz, hr);
                return FALSE;
            }
        }

        HRESULT hr = E_FAIL;

        if (m_pIClassAdmin)
        {
            hr = m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                         NULL,
                                                         &dwActFlags,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         NULL);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pIClassAdmin->ChangePackageUpgradeList(m_pData->m_pDetails->pszPackageName,
                                                                  cUpgrades,
                                                                  prgUpgradeInfoList);
            if (SUCCEEDED(hr))
            {
                m_pScopePane->RemoveExtensionEntry(m_cookie, *m_pData);
                m_pScopePane->RemoveUpgradeEntry(m_cookie, *m_pData);
                n = m_pData->m_pDetails->pInstallInfo->cUpgrades;
                if (n)
                {
                    while (n--)
                    {
                        OLESAFE_DELETE(m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList[n].szClassStore);
                    }
                    OLESAFE_DELETE(m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList);
                }
                m_pData->m_pDetails->pInstallInfo->prgUpgradeInfoList = prgUpgradeInfoList;
                m_pData->m_pDetails->pInstallInfo->cUpgrades = cUpgrades;
                m_pData->m_pDetails->pInstallInfo->dwActFlags = dwActFlags;
                m_pScopePane->InsertExtensionEntry(m_cookie, *m_pData);
                m_pScopePane->InsertUpgradeEntry(m_cookie, *m_pData);
                if (m_pScopePane->m_pFileExt)
                {
                    m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                }
                m_pData->m_szUpgrades.Empty(); // Clear the cached
                                               // upgrade relation
                                               // string so it will be
                                               // refreshed.
                m_fModified = FALSE;

                if (!m_fPreDeploy)
                {
                    MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);
                }
                m_fModified = FALSE;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("ChangePackageUpgradeList failed with 0x%x"), hr));
                // Put back the original flags if for some reason we were
                // able to change the flags but unable to change the upgrade
                // list.
                m_pIClassAdmin->ChangePackageProperties(m_pData->m_pDetails->pszPackageName,
                                                             NULL,
                                                             &m_pData->m_pDetails->pInstallInfo->dwActFlags,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             NULL);
                // Note that if this fails there's little we could do to
                // recover so I just assume it succeeds.
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ChangePackageProperties failed with 0x%x"), hr));
        }
        if (FAILED(hr))
        {
            CString sz;
            sz.LoadString(IDS_CHANGEFAILED);
            ReportGeneralPropertySheetError(m_hWnd, sz, hr);
            n = cUpgrades;
            if (n)
            {
                while (n--)
                {
                    OLESAFE_DELETE(prgUpgradeInfoList[n].szClassStore);
                }
                OLESAFE_DELETE(prgUpgradeInfoList);
            }
            return FALSE;
        }
    }
    return CPropertyPage::OnApply();
}


void CUpgradeList::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_UPGRADES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\upgrades.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       upgrades.h
//
//  Contents:   upgrades dialog (during deployment)
//
//  Classes:    CUpgrades
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
#define AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CUpgrades dialog

class CUpgrades
{
// Construction
public:
        // m_UpgradeList: maps UpgradeIndex to UpgradeData
        map<CString, CUpgradeData> m_UpgradeList;

        // m_NameIndex: maps name to UpgradeIndex
        map<CString, CString> m_NameIndex;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\uplist.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       UpList.h
//
//  Contents:   upgrade relationships property sheet
//
//  Classes:    CUpgradeList
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_UPLIST_H__3ACA8212_B87C_11D1_BD2A_00C04FB9603F__INCLUDED_)
#define AFX_UPLIST_H__3ACA8212_B87C_11D1_BD2A_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CUpgradeList dialog

class CUpgradeList : public CPropertyPage
{
        DECLARE_DYNCREATE(CUpgradeList)

// Construction
public:
        CUpgradeList();
        ~CUpgradeList();

// Dialog Data
        //{{AFX_DATA(CUpgradeList)
        enum { IDD = IDD_UPGRADES };
        CListBox        m_UpgradedBy;
        CListBox        m_Upgrades;
        BOOL    m_fForceUpgrade;
        BOOL            m_fRSOP;
        //}}AFX_DATA
        CUpgradeList **         m_ppThis;
        CAppData *              m_pData;
        LONG_PTR                m_hConsoleHandle;
        MMC_COOKIE              m_cookie;
        CScopePane *    m_pScopePane;
        BOOL            m_fMachine;
#if 0
        LPGPEINFORMATION m_pIGPEInformation;
#endif
        map<CString, CUpgradeData>      m_UpgradeList;
        map<CString, CString>   m_NameIndex;
        IClassAdmin *   m_pIClassAdmin;
        BOOL            m_fPreDeploy;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CUpgradeList)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CUpgradeList)
        virtual BOOL OnInitDialog();
        afx_msg void OnDblclkList1();
        afx_msg void OnDblclkList2();
        afx_msg void OnRequire();
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        afx_msg void OnEdit();
        afx_msg void OnSelchangeList1();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshData(void);
        BOOL IsUpgradeLegal(CString sz);
        CAddUpgrade             m_dlgAdd;
        BOOL                    m_fModified;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UPLIST_H__3ACA8212_B87C_11D1_BD2A_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\tracking.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Tracking.h
//
//  Contents:   tracking settings property page
//
//  Classes:    CTracking
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_TRACKING_H__E95370C0_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
#define AFX_TRACKING_H__E95370C0_ADF8_11D1_A763_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afxcmn.h>

/////////////////////////////////////////////////////////////////////////////
// CTracking dialog

class CTracking : public CPropertyPage
{
        DECLARE_DYNCREATE(CTracking)

// Construction
public:
        CTracking();
        ~CTracking();

// Dialog Data
        //{{AFX_DATA(CTracking)
        enum { IDD = IDD_UNINSTALLTRACKING };
        CSpinButtonCtrl m_spin;
        //}}AFX_DATA
        TOOL_DEFAULTS * m_pToolDefaults;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        IClassAdmin *   m_pIClassAdmin;
        CTracking ** m_ppThis;


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CTracking)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CTracking)
        afx_msg void OnCleanUpNow();
        virtual BOOL OnInitDialog();
        afx_msg void OnDeltaposSpin1(NMHDR* pNMHDR, LRESULT* pResult);
        afx_msg void OnChangeEdit1();
        afx_msg void OnKillfocusEdit1();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

// The number of FILETIME values that equals a single day, used to compute
// value to send to IClassAdmin->CleanUp.
// Each FILETIME value (or tick) is 100 nano-seconds.
//    0.01 tics/nano-seconds
//    * 1,000,000,000 nano-seconds/sec
//    * 60 sec/min
//    * 60 min/hour
//    * 24 hour/day
//    = 864,000,000,000 ticks/day
#define ONE_FILETIME_DAY 864000000000

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRACKING_H__E95370C0_ADF8_11D1_A763_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\xforms.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Xforms.h
//
//  Contents:   modifications (transforms) property sheet
//
//  Classes:    XForms
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#if !defined(AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CXforms dialog

class CXforms : public CPropertyPage
{
        DECLARE_DYNCREATE(CXforms)

// Construction
public:
        CXforms();
        ~CXforms();

        CXforms ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CXforms)
        enum { IDD = IDD_MODIFICATIONS };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA
        CAppData *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        LONG_PTR        m_hConsoleHandle;
        MMC_COOKIE      m_cookie;
        BOOL            m_fModified;
        CScopePane * m_pScopePane;
        BOOL            m_fPreDeploy;
        CString         m_szInitialPackageName;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CXforms)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        void RefreshData();
        // Generated message map functions
        //{{AFX_MSG(CXforms)
        afx_msg void OnMoveUp();
        afx_msg void OnMoveDown();
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\ade\xforms.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       Xforms.cpp
//
//  Contents:   modifications (transforms) property page
//
//  Classes:    CXforms
//
//  History:    03-14-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXforms property page

IMPLEMENT_DYNCREATE(CXforms, CPropertyPage)

CXforms::CXforms() : CPropertyPage(CXforms::IDD)
{
        //{{AFX_DATA_INIT(CXforms)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
        m_fModified = FALSE;
        m_pIClassAdmin = NULL;
        m_fPreDeploy = FALSE;
        m_ppThis = NULL;
}

CXforms::~CXforms()
{
        if (m_ppThis)
        {
            *m_ppThis = NULL;
        }
        if (m_pIClassAdmin)
        {
            m_pIClassAdmin->Release();
        }
}

void CXforms::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CXforms)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CXforms, CPropertyPage)
        //{{AFX_MSG_MAP(CXforms)
        ON_BN_CLICKED(IDC_BUTTON3, OnMoveUp)
        ON_BN_CLICKED(IDC_BUTTON4, OnMoveDown)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXforms message handlers

void CXforms::OnMoveUp()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (LB_ERR != i && i > 0)
    {
        CString sz;
        pList->GetText(i, sz);
        pList->DeleteString(i);
        pList->InsertString(i-1, sz);
        pList->SetCurSel(i-1);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
    }
}

void CXforms::OnMoveDown()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i != LB_ERR && i < pList->GetCount() - 1)
    {
        CString sz;
        pList->GetText(i+1, sz);
        pList->DeleteString(i+1);
        pList->InsertString(i, sz);
        pList->SetCurSel(i+1);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
    }
}

void CXforms::OnAdd()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szExtension;
    CString szFilter;
    szExtension.LoadString(IDS_DEF_TRANSFORM_EXTENSION);
    szFilter.LoadString(IDS_TRANSFORM_EXTENSION_FILTER);

    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = ghInstance;
    TCHAR lpstrFilter[MAX_PATH];
    wcsncpy(lpstrFilter, szFilter, MAX_PATH);
    ofn.lpstrFilter = lpstrFilter;
    TCHAR szFileTitle[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    szFile[0] = NULL;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = MAX_PATH;
    ofn.lpstrInitialDir = m_pScopePane->m_ToolDefaults.szStartPath;
    ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = szExtension;
    int iBreak = 0;
    while (lpstrFilter[iBreak])
    {
        if (lpstrFilter[iBreak] == TEXT('|'))
        {
            lpstrFilter[iBreak] = 0;
        }
        iBreak++;
    }
    if (GetOpenFileName(&ofn))
    {
        // user selected an application
        UNIVERSAL_NAME_INFO * pUni = new UNIVERSAL_NAME_INFO;
        ULONG cbSize = sizeof(UNIVERSAL_NAME_INFO);
        HRESULT hr = WNetGetUniversalName(ofn.lpstrFile,
                                          UNIVERSAL_NAME_INFO_LEVEL,
                                          pUni,
                                          &cbSize);
        if (ERROR_MORE_DATA == hr)  // we expect this to be true
        {
            delete [] pUni;
            pUni = (UNIVERSAL_NAME_INFO *) new BYTE [cbSize];
            hr = WNetGetUniversalName(ofn.lpstrFile,
                                      UNIVERSAL_NAME_INFO_LEVEL,
                                      pUni,
                                      &cbSize);
        }

        CString szTransformPath;

        if (S_OK == hr)
        {
            szTransformPath = pUni->lpUniversalName;
        }
        else
        {
            szTransformPath = ofn.lpstrFile;
        }
        delete[] pUni;

        CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
        pList->AddString(szTransformPath);
        CDC * pDC = pList->GetDC();
        CSize size = pDC->GetTextExtent(szTransformPath);
        pDC->LPtoDP(&size);
        pList->ReleaseDC(pDC);
        if (pList->GetHorizontalExtent() < size.cx)
        {
            pList->SetHorizontalExtent(size.cx);
        }
        pList->SetCurSel(pList->GetCount() - 1);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
        int n = pList->GetCount();
        GetDlgItem(IDC_BUTTON2)->EnableWindow(n > 0);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(n > 1);
        GetDlgItem(IDC_BUTTON4)->EnableWindow(n > 1);
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
    }
}

void CXforms::OnRemove()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (LB_ERR != i)
    {
        pList->DeleteString(i);
        pList->SetCurSel(0);
        if (!m_fPreDeploy)
            SetModified();
        m_fModified = TRUE;
        int n = pList->GetCount();
        GetDlgItem(IDC_BUTTON2)->EnableWindow(n > 0);
        GetDlgItem(IDC_BUTTON3)->EnableWindow(n > 1);
        GetDlgItem(IDC_BUTTON4)->EnableWindow(n > 1);
        if (NULL == GetFocus())
        {
            GetParent()->GetDlgItem(IDOK)->SetFocus();
        }
    }
}

BOOL CXforms::OnInitDialog()
{
    if (m_pScopePane->m_fRSOP || !m_fPreDeploy)
    {
        GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
        SetDlgItemText(IDC_STATICNOHELP1, TEXT(""));
    }
    GetDlgItem(IDC_BUTTON2)->EnableWindow(FALSE);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
    GetDlgItem(IDC_BUTTON4)->EnableWindow(FALSE);
    // Remember what the package name was at first so we can tell if the
    // user's changed it.

    m_szInitialPackageName = m_pData->m_pDetails->pszPackageName;

    RefreshData();

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CXforms::OnApply()
{
    // NOTE
    //
    // If the transform list changes we really have no choice but to
    // re-deploy the app because it can cause virtually every field in the
    // package details structure to change (a change in the transform list
    // causes a rebuild of the script file which could potentially affect
    // almost everything).
    //
    // For this reason, this property sheet MUST NOT BE ACTIVE once an app
    // is deployed.
    //
    BOOL fBuildSucceeded = FALSE;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_fModified)
    {
        CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
        PACKAGEDETAIL * ppd;
        if (FAILED(CopyPackageDetail(ppd, m_pData->m_pDetails)))
        {
            return FALSE;
        }

        CString sz;
        int i;
        for (i = ppd->cSources; i--;)
        {
            OLESAFE_DELETE(ppd->pszSourceList[i]);
        }
        OLESAFE_DELETE(ppd->pszSourceList);
        int n = pList->GetCount();
        ppd->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * (n + 1));
        if (ppd->pszSourceList)
        {
            OLESAFE_COPYSTRING(ppd->pszSourceList[0], m_pData->m_pDetails->pszSourceList[0]);
            for (i = 0; i < n; i++)
            {
                pList->GetText(i, sz);
                OLESAFE_COPYSTRING(ppd->pszSourceList[i+1], sz);
            }
            ppd->cSources = n + 1;
        }
        else
        {
            ppd->cSources = 0;
            return FALSE;
        }

        // Create a name for the new script file.

        // set the script path
        GUID guid;
        HRESULT hr = CoCreateGuid(&guid);
        if (FAILED(hr))
        {
            // undone
        }
        OLECHAR szGuid [256];
        StringFromGUID2(guid, szGuid, 256);

        CString szScriptFile  = m_pScopePane->m_szGPT_Path;
        szScriptFile += L"\\";
        szScriptFile += szGuid;
        szScriptFile += L".aas";
        OLESAFE_DELETE(ppd->pInstallInfo->pszScriptPath);
        OLESAFE_COPYSTRING(ppd->pInstallInfo->pszScriptPath, szScriptFile);
        CString szOldName = ppd->pszPackageName;
        hr = BuildScriptAndGetActInfo(*ppd, ! m_pData->m_pDetails->pActInfo->bHasClasses);
        if (SUCCEEDED(hr))
        {
            if (0 != wcscmp(m_szInitialPackageName, szOldName))
            {
                // The User changed the name so we have to preserve his choice.
                // If the user hasn't changed the package name then it's ok to
                // set the packagename to whatever is in the script file.
                OLESAFE_DELETE(ppd->pszPackageName);
                OLESAFE_COPYSTRING(ppd->pszPackageName, szOldName);
            }

            fBuildSucceeded = TRUE;
            hr = m_pScopePane->PrepareExtensions(*ppd);
            if (SUCCEEDED(hr))
            {
                CString szUniqueName;
                int     nHint;

                nHint = 1;

                m_pScopePane->GetUniquePackageName(ppd->pszPackageName, szUniqueName, nHint);
                OLESAFE_DELETE(ppd->pszPackageName);
                OLESAFE_COPYSTRING(ppd->pszPackageName, szUniqueName);

                hr = m_pIClassAdmin->RedeployPackage(
                        &m_pData->m_pDetails->pInstallInfo->PackageGuid,
                        ppd);

                if (SUCCEEDED(hr))
                {
                    // delete the old script
                    DeleteFile(m_pData->m_pDetails->pInstallInfo->pszScriptPath);
                    // update indexes and property sheets
                    m_pScopePane->RemoveExtensionEntry(m_cookie, *m_pData);
                    m_pScopePane->RemoveUpgradeEntry(m_cookie, *m_pData);
                    FreePackageDetail(m_pData->m_pDetails);
                    m_pData->m_pDetails = ppd;
                    m_pScopePane->InsertExtensionEntry(m_cookie, *m_pData);
                    m_pScopePane->InsertUpgradeEntry(m_cookie, *m_pData);
                    if (m_pScopePane->m_pFileExt)
                    {
                        m_pScopePane->m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                    }
                    m_fModified = FALSE;
                    if (!m_fPreDeploy)
                    {
                        MMCPropertyChangeNotify(m_hConsoleHandle, m_cookie);
                    }
                }
            }
        }
        if (FAILED(hr))
        {
            CString sz;
            sz.LoadString(fBuildSucceeded ? IDS_TRANSFORM_FAILED_IN_CS : IDS_TRANSFORM_FAILED);
            ReportGeneralPropertySheetError(m_hWnd, sz, hr);

            // delete new script file (assuming it was created)
            DeleteFile(szScriptFile);

            FreePackageDetail(ppd);
            return FALSE;
        }
    }
    return CPropertyPage::OnApply();
}

LRESULT CXforms::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_HELP:
        StandardHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, IDD);
        return 0;
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CXforms::RefreshData(void)
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    pList->ResetContent();
    pList->SetHorizontalExtent(0);

    UINT i;
    // Item at 0 is the package.  Items > 0 are transforms.
    for (i = 1; i < m_pData->m_pDetails->cSources; i++)
    {
        pList->AddString(m_pData->m_pDetails->pszSourceList[i]);
        CDC * pDC = pList->GetDC();
        CSize size = pDC->GetTextExtent(m_pData->m_pDetails->pszSourceList[i]);
        pDC->LPtoDP(&size);
        pList->ReleaseDC(pDC);
        if (pList->GetHorizontalExtent() < size.cx)
        {
            pList->SetHorizontalExtent(size.cx);
        }
    }
    pList->SetCurSel(0);

    SetModified(FALSE);
    m_fModified = FALSE;
}


void CXforms::OnContextMenu(CWnd* pWnd, CPoint point)
{
    StandardContextMenu(pWnd->m_hWnd, IDD_MODIFICATIONS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\dataobj.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.h
//
//  Contents:   implementation of IDataObject for the snapin objects
//
//  Classes:    CDataObject
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CResultPane;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() {};
    ~CDataObject() {};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfInternal;

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CResultPane::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type)
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetID (long ID) { m_internal.m_scopeID = ID; }

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\error.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    error.cxx

Abstract:

    Contains error reporting routines. All functions are fairly straightforward

Author:

    Rahul Thombre (RahulTh) 4/12/1998

Revision History:

    4/12/1998   RahulTh         Created this module.
    10/1/1998   RahulTh         Massive changes to the error reporting mechanism
                                now better and more convenient

--*/

#include "precomp.hxx"

//+--------------------------------------------------------------------------
//
//  Member:     CError::ConstructMessage
//
//  Synopsis:   this is an internal helper function that constructs a message
//              from the available error codes it is called by both ShowMessage
//              and ShowConsoleMessage
//
//  Arguments:  [in] argList : the va_list of arguments
//              [out] szErrMsg : the formatted error message
//
//  Returns:    nothing
//
//  History:    10/2/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::ConstructMessage (va_list argList, CString& szErrMsg)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    TCHAR   lpszMessage[2048];

    szErrMsg.LoadString (m_msgID);

    wvsprintf (lpszMessage, (LPCTSTR) szErrMsg, argList);

    szErrMsg = lpszMessage;

    if (ERROR_SUCCESS != m_winErr)
    {
        LPVOID lpMsgBuf;
        DWORD dwRet;
        dwRet = ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                                 NULL,
                                 m_winErr,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 (LPTSTR) &lpMsgBuf,
                                 0,
                                 NULL
                               );
        if (dwRet)
        {
            szErrMsg += TEXT("\n\n");
            szErrMsg += (LPCTSTR) lpMsgBuf;
            LocalFree (lpMsgBuf);
        }
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::SetTitle
//
//  Synopsis:   sets the value of the member that determines the title of the
//              message box.
//
//  Arguments:  titleID : the resource id of the title.
//
//  Returns:    nothing
//
//  History:    4/12/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::SetTitle (UINT titleID)
{
    m_titleID = titleID;
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::SetStyle
//
//  Synopsis:   sets the value of the member that determines the message
//              box style.
//
//  Arguments:  nStyle : the message box style.
//
//  Returns:    nothing
//
//  History:    4/12/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::SetStyle (UINT nStyle)
{
    m_nStyle = nStyle;
}

//+--------------------------------------------------------------------------
//
//  Member:    CError::SetError
//
//  Synopsis:  sets the value of the member that stores the windows error
//             encountered if any.
//
//  Arguments: dwWinError : the value of the windows error encountered
//
//  Returns:   nothing
//
//  History:   12/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::SetError (DWORD dwWinError)
{
   m_winErr = dwWinError;
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::ShowMessage
//
//  Synopsis:   displays an error message in a message box based on the
//              members of the object
//
//  Arguments:  message id for the error + more
//
//  Returns:    the return value of the message box
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:      if the resultant message is longer than 2048 characters
//              then result is unpredictable and may also cause AVs.
//              but this is a limitation of wvsprintf. However, this is not
//              so bad since we can make sure that we do not have any error
//              message that exceed this self imposed limit
//
//---------------------------------------------------------------------------
int CError::ShowMessage (UINT errID, ...)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    va_list argList;
    CString szErrMsg;
    CString szTitle;

    m_msgID = errID;    //update the message ID with the new one

    szTitle.LoadString (m_titleID);

    va_start (argList, errID);
    ConstructMessage (argList, szErrMsg);
    va_end (argList);

    return ::MessageBox (m_hWndParent, (LPCTSTR)szErrMsg,
                         (LPCTSTR) szTitle, m_nStyle);
}

//+--------------------------------------------------------------------------
//
//  Member:     ShowConsoleMessage
//
//  Synopsis:   displays a message using MMC's IConsole interface
//
//  Arguments:  [in] pConsole : pointer to IConsole interface
//              [in] errID : error resource ID
//              + other codes
//
//  Returns:    return value of the message box
//
//  History:    10/2/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
int CError::ShowConsoleMessage (LPCONSOLE pConsole, UINT errID, ...)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    va_list argList;
    CString szErrMsg;
    CString szTitle;
    int     iRet;

    m_msgID = errID;

    szTitle.LoadString (m_titleID);

    va_start(argList, errID);
    ConstructMessage (argList, szErrMsg);
    va_end (argList);

    pConsole->MessageBox ((LPCTSTR)szErrMsg, (LPCTSTR) szTitle, m_nStyle,
                          &iRet);

    return iRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   _DbgMsg
//
//  Synopsis:   function that sends messages to the debugger
//
//  Arguments:  format string + more
//
//  Returns:    nothing
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:      Do not try to print debug messages longer than 2048 characters.
//
//---------------------------------------------------------------------------
void _DbgMsg (LPCTSTR szFormat ...)
{
    CString cszFormat;
    va_list argList;
    //do not try to print debug messages longer than 2048 characters.
    TCHAR lpszMessage[2048];
    CTime theTime = CTime::GetCurrentTime();

    va_start (argList, szFormat);
    wvsprintf (lpszMessage, szFormat, argList);
    va_end(argList);

    cszFormat =  ((TEXT("FDE.DLL@") + theTime.Format(TEXT("[%x, %X]>> "))) + lpszMessage) + '\n';

    OutputDebugString ((LPCTSTR)cszFormat);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\dataobj.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dataobj.cpp
//
//  Contents:   implementation of IDataObject
//
//  Classes:    CDataObject
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

        return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
        return E_NOTIMPL;
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
        return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
                    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    return Create(cszNodeType, ((wcslen(cszNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_Snapin, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\common.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       common.h
//
//  Contents:   common definitions used by the main snapin modules
//
//  Classes:    CResultPane, CScopePane
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#include <vector>
#include <malloc.h>
#include <objsel.h>
#include <shlwapi.h>
#include "objidl.h"
#include "gpedit.h"
#include "iads.h"
#include "HelpArr.h"
#include "Path.hxx"
#include "PathSlct.hxx"
#include "redirect.hxx"
#include "FileInfo.hxx"
#include "utils.hxx"
#include "error.hxx"
#include "security.hxx"
#include "secpath.hxx"
#include "prefs.hxx"
#include "rsopinfo.h"
#include "rsopprop.h"

///////////////////////////////////////////////////////////////////
// workaround macro for MFC bug
// (see NTRAID 342926 and MFC "Monte Carlo" RAID db # 1034)
#define FIX_THREAD_STATE_MFC_BUG() \
                AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState(); \
                CWinThread _dummyWinThread; \
                if (pState->m_pCurrentWinThread == NULL) \
                { \
                    pState->m_pCurrentWinThread = &_dummyWinThread; \
                }

//get the index of a cookie in the folder cache of the scope pane
#define GETINDEX(x)         (((x) < IDS_DIRS_END && (x) >= IDS_DIRS_START) ? ((x) - IDS_DIRS_START) : -1)
// private notifications
#define WM_USER_REFRESH     WM_USER
#define WM_USER_CLOSE       (WM_USER + 1)
#define MAX_DS_PATH 1024

// Other private notifications.
#define WM_PATH_TWEAKED     (WM_APP + 1)

//the max. possible length of the path that can be entered into the edit control
#define TARGETPATHLIMIT     MAX_PATH - 4

// Note - This is the offset in my image list that represents the folder
const FOLDER_IMAGE_IDX = 0;
const OPEN_FOLDER_IMAGE_IDX = 5;
extern HINSTANCE ghInstance;

extern const CLSID CLSID_Snapin;
extern const wchar_t * szCLSID_Snapin;
extern const GUID cNodeType;
extern const wchar_t*  cszNodeType;

//the GUID for the client side extension
extern GUID guidExtension;

extern CString szExtension;
extern CString szFilter;

// RSOP GUIDS
extern const CLSID CLSID_RSOP_Snapin;
extern const wchar_t * szCLSID_RSOP_Snapin;

#define IMG_OPENBOX   0
#define IMG_CLOSEDBOX 1
#define IMG_DISABLED  2
#define IMG_PUBLISHED 3
#define IMG_ASSIGNED  4
#define IMG_UPGRADE   5

//
// MACROS for allocating and freeing memory via OLE's common allocator: IMalloc.
//
extern IMalloc * g_pIMalloc;

// UNDONE - throw exception on failure

//#define OLEALLOC(x) new char [x]
#define OLEALLOC(x) g_pIMalloc->Alloc(x)

//#define OLESAFE_DELETE(x) if (x) {delete x; x = NULL;}
#define OLESAFE_DELETE(x) if (x) {g_pIMalloc->Free(x); x = NULL;}

#define OLESAFE_COPYSTRING(szO, szI) {if (szI) {int i_dontcollidewithanything = wcslen(szI); szO=(OLECHAR *)OLEALLOC(sizeof(OLECHAR) * (i_dontcollidewithanything+1)); wcscpy(szO, szI);} else szO=NULL;}

/////////////////////////////////////////////////////////////////////////////
// Snapin

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);

class CScopePane:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public CComObjectRoot,
    public IExtendPropertySheet,
    public ISnapinAbout,
    public ISnapinHelp
{

    friend class CResultPane;
    friend class CDataObject;
    friend class CRedirect;
    friend HRESULT ConvertOldStyleSection (const CString&, const CScopePane*);

public:
        CScopePane();
        ~CScopePane();

protected:
    LPGPEINFORMATION    m_pIGPEInformation;  // Interface pointer to the GPT
    LPRSOPINFORMATION    m_pIRSOPInformation;  // Interface pointer to the GPT
    CFileInfo m_FolderData[IDS_DIRS_END - IDS_DIRS_START];

public:
    virtual IUnknown * GetMyUnknown() = 0;

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStreamInit interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(InitNew)(VOID);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// ISnapinAbout interface
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR * lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion);
    STDMETHOD(GetSnapinImage)(HICON * hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP * hSmallImage,
                                 HBITMAP * hSmallImageOpen,
                                 HBITMAP * hLargeImage,
                                 COLORREF * cMask);

    //
    // Implemented ISnapinHelp interface members
    //
public:
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile);

// Notify handler declarations
private:
    HRESULT OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    void EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);

private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;
    LPDISPLAYHELP           m_pDisplayHelp;
    BOOL                    m_bIsDirty;
    BOOL m_fExtension;
    BOOL m_fLoaded;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    UINT CreateNestedDirectory (LPTSTR lpPath, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    void LoadToolDefaults();
    void SaveToolDefaults();
    CResultPane * m_pResultPane;
    IPropertySheetProvider * m_pIPropertySheetProvider;

public:
    CString m_szFileRoot;
    CString m_szFolderTitle;
    CString             m_szRSOPNamespace;
    BOOL                m_fRSOP;
};

class CResultPane :
    public IComponent,
    public IExtendContextMenu,
//    COM_INTERFACE_ENTRY(IExtendControlbar)
    public IExtendPropertySheet,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
        CResultPane();
        ~CResultPane();

BEGIN_COM_MAP(CResultPane)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
//    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;


// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
//    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
//    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helpers for CResultPane
public:
    void SetIComponentData(CScopePane* pData);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPARAM param); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick);
    HRESULT OnContextHelp(void);
public:
    HRESULT TestForRSOPData(MMC_COOKIE cookie);
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);

// IExtendContextMenu
public:

    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// Helper functions
protected:
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    CScopePane *        m_pScopePane;
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LONG                m_lViewMode;    // View mode
    HSCOPEITEM          m_hCurrScopeItem;   //the scope item whose elements are
                                            //currently being displayed in the
                                            //result pane

public:
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane

    int                 m_nSortColumn;
    DWORD               m_dwSortOptions;


protected:
//    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
//    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
//    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars

//    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
//    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar

// Header titles for each nodetype(s)
protected:
    CString m_columns[IDS_LAST_COL - IDS_FIRST_COL];
    CString m_RSOP_columns[IDS_LAST_RSOP_COL - IDS_FIRST_RSOP_COL];

    CString m_szFolderTitle;

    map <UINT, CRSOPInfo> m_RSOPData;
    UINT    m_nIndex ;
};

class CUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CUserComponentDataImpl, &CLSID_Snapin>
{
public:

DECLARE_REGISTRY(CResultPane, _T("FDE.1"), _T("FDE"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CUserComponentDataImpl()
    {
        m_fRSOP = FALSE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CRSOPUserComponentDataImpl:
    public CScopePane,
    public CComCoClass<CRSOPUserComponentDataImpl, &CLSID_RSOP_Snapin>
{
public:

DECLARE_REGISTRY(CResultPane, _T("FDE.1"), _T("FDE"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CRSOPUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    CRSOPUserComponentDataImpl()
    {
        m_fRSOP = TRUE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

inline void CResultPane::SetIComponentData(CScopePane* pData)
{
    ASSERT(pData);
    ASSERT(m_pScopePane == NULL);
    LPUNKNOWN pUnk = pData->GetMyUnknown();
    HRESULT hr;

    LPCOMPONENTDATA lpcd;
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&lpcd));
    ASSERT(hr == S_OK);
    m_pScopePane = dynamic_cast<CScopePane*>(lpcd);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

class CHourglass
{
    private:
    HCURSOR m_hcurSaved;

    public:
    CHourglass()
    {
        m_hcurSaved = ::SetCursor(::LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    ~CHourglass()
    {
        ::SetCursor(m_hcurSaved);
    };
};

LRESULT SetPropPageToDeleteOnClose(void * vpsp);

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\helparr.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    HelpArr.h

Abstract:

    #defines for context sensitive help.


Author:

    Rahul Thombre (RahulTh) 2/3/1999

Revision History:

    2/3/1999    RahulTh         Created this module.

--*/

#ifndef __HELPARR_H__
#define __HELPARR_H__

//help id for controls that don't have context sensitive help
#define     IDH_DISABLEHELP         ((DWORD) -1)

//help ids for controls on IDD_REDIRECT
#define     IDH_REDIR_CHOICE        2001
#define     IDH_LIST_ADVANCED       2004
#define     IDH_BTNADD              2005
#define     IDH_BTNEDIT             2006
#define     IDH_BTNREMOVE           2007

// Help IDs for controls in IDD_PATHCHOOSER
#define     IDH_ROOT_PATH           2002
#define     IDH_BROWSE              2003
#define     IDH_DESTTYPE            2008

//help ids for controls on IDD_SECPATH
#define     IDH_EDIT_SECGROUP       2101
#define     IDH_BROWSE_SECGROUP     2102

//help ids for controls on IDD_REDIRMETHOD
#define     IDH_PREF_APPLYSECURITY  2201
#define     IDH_PREF_MOVE           2202
#define     IDH_PREF_ORPHAN         2203
#define     IDH_PREF_RELOCATE       2204
#define     IDH_PREF_CHANGEMYPICS   2205
#define     IDH_PREF_LEAVEMYPICS    2206


#endif  //__HELPARR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\path.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

    path.cxx

Abstract:
    Implementation of the methods in the CRedirPath class. This class
    parses a path and breaks it up into different components and categorizes
    it into one of the well known paths:
        (a) a path in the local user profile location
        (b) a path in the user's home directory
        (c) a specific user specified path
        (d) a per-user path in a user specified location

Author:

    Rahul Thombre (RahulTh) 3/3/2000

Revision History:

    3/3/2000    RahulTh         Created this module.

--*/

#include "precomp.hxx"

CRedirPath::CRedirPath(UINT cookie) : _bDataValid (FALSE), _cookie(cookie)
{
    _szPrefix.Empty();
    _szSuffix.Empty();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirPath::GeneratePath
//
//  Synopsis:   Generate the full path from the components
//
//  Arguments:  [out] szPath : the generated path
//              [in, optional] szUser : sample username
//
//  Returns:    TRUE : if the generated path is valid.
//              FALSE: if there is no valid path stored in this object. In
//                     this case szPath is set to an empty string.
//
//  History:    3/3/2000  RahulTh  created
//
//  Notes:      For per user paths, this function uses a sample username
//              if supplied, otherwise, it uses the username variable
//              string %username%
//
//---------------------------------------------------------------------------
BOOL CRedirPath::GeneratePath (OUT CString & szPath,
                               OPTIONAL IN const CString & szUser //= USERNAME_STR
                               ) const
{
    BOOL    bStatus;

    if (! _bDataValid)
        return FALSE;

    szPath = L"";
    bStatus = TRUE;
    switch (_type)
    {
    case IDS_SPECIFIC_PATH:
        szPath = _szPrefix;
        if (! IsValidPrefix (_type, (LPCTSTR) _szPrefix))
            bStatus = FALSE;
        break;
    case IDS_HOMEDIR_PATH:
        szPath = HOMEDIR_STR;
        if (!_szSuffix.IsEmpty())
            szPath += _szSuffix;
        bStatus = TRUE;
        break;
    case IDS_PERUSER_PATH:
        if (_szPrefix.IsEmpty() ||
            ! IsValidPrefix (_type, (LPCTSTR) _szPrefix))
        {
            bStatus = FALSE;
        }
        else
        {
            szPath = (_szPrefix + L'\\') + szUser;
            if (! _szSuffix.IsEmpty())
                szPath += _szSuffix;
            bStatus = TRUE;
        }
        break;
    case IDS_USERPROFILE_PATH:
        if (_szSuffix.IsEmpty())
        {
            bStatus = FALSE;
        }
        else
        {
            szPath = PROFILE_STR + _szSuffix;
            bStatus = TRUE;
        }
        break;
    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirPath::GenerateSuffix
//
//  Synopsis:   generates a new suffix based on a given path type and folder
//
//  Arguments:  [out]   szSuffix
//              [in]    cookie
//              [in]    pathType
//
//  Returns:
//
//  History:    3/7/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirPath::GenerateSuffix (OUT    CString &   szSuffix,
                                 IN     UINT        cookie,
                                 IN     UINT        pathType
                                 ) const
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    szSuffix.Empty();

    if (IDS_HOMEDIR_PATH == pathType)
        return;

    if (IDS_MYPICS == cookie)
	{
		//
		// Use the full My Documents\My Pictures path
		// only if we are going to the user profile.
		// Otherwise stick to vanilla My Pictures
		// This ensures that when My Pictures is redirected independently
		// to another location, we do not create an extra level of folders
		// as this might cause security problems for MyDocs if they are 
		// also redirected to the same share.
		//
		if (IDS_USERPROFILE_PATH == pathType)
			szSuffix.LoadString (IDS_MYPICS_RELPATH);
		else
			szSuffix.LoadString (IDS_MYPICS);
	}
    else
        szSuffix.LoadString (cookie);

    // Precede it with a "\"
    szSuffix = L'\\' + szSuffix;

    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirPath::Load
//
//  Synopsis:   parses a given path and breaks it into different components
//              so that it can be categorized into one of the well known
//              types
//
//  Arguments:  [in] szPath : the given full path
//
//  Returns:    TRUE: if the categorization was succesful.
//              FALSE otherwise
//
//  History:    3/3/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CRedirPath::Load (IN LPCTSTR pwszPath)
{
    CString     szPath;
    BOOL        bStatus = FALSE;

    szPath = pwszPath;
    szPath.TrimLeft();
    szPath.TrimRight();
    szPath.TrimRight (L'\\');

    // First check to see if it is a homedir path.
    bStatus = this->LoadHomedir ((LPCTSTR)szPath);

    // If not, try per-user
    if (!bStatus)
        bStatus = this->LoadPerUser ((LPCTSTR) szPath);

    // If not, try local userprofile
    if (!bStatus)
        bStatus = this->LoadUserprofile ((LPCTSTR) szPath);

    //
    // If not try a user defined path.
    // Note: we cannot use the value blindly here because we need to
    // make sure that there are no environment variables in there.
    //
    if (!bStatus)
        bStatus = this->LoadSpecific ((LPCTSTR) szPath);

    return bStatus;
}

// Determines if a valid path is stored in this object.
BOOL CRedirPath::IsPathValid (void) const
{
    return _bDataValid;
}

//
// Determines if the supplied path is different from the path stored in the
// object. Note: the suffix is immaterial in these comparisons.
//
BOOL CRedirPath::IsPathDifferent (IN UINT type, IN LPCTSTR pwszPrefix) const
{
    CString     szPrefix;

    // Make sure that a path has been loaded in this object first.
    if (! _bDataValid)
        return TRUE;

    // If the types of the paths aren't the same, tnen the paths surely aren't
    if (type != _type)
        return TRUE;

    // If we are here, the types of the path are the same

    //
    // Comparing the prefix does not make sense for a homedir path or
    // a userprofile path
    //
    if (IDS_USERPROFILE_PATH == type ||
        IDS_HOMEDIR_PATH == type)
    {
        return FALSE;
    }

    szPrefix = pwszPrefix;
    szPrefix.TrimLeft();
    szPrefix.TrimRight();
    szPrefix.TrimRight (L'\\');
    if (szPrefix != _szPrefix)
        return TRUE;
    else
        return FALSE;
}

// parse the path to see if it is a homedir path
BOOL CRedirPath::LoadHomedir (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;
    int     len, lenHomedir;

    // Only the My Documents folder is allowed to have a homedir path
    if (IDS_MYDOCS != _cookie)
        return FALSE;

    len = lstrlen (pwszPath);
    lenHomedir = lstrlen (HOMEDIR_STR);

    if (lenHomedir <= len &&
        0 == _wcsnicmp (pwszPath, HOMEDIR_STR, lenHomedir) &&
        (L'\0' == pwszPath[lenHomedir] || L'\\' == pwszPath[lenHomedir]) &&
        NULL == wcsstr (&pwszPath[lenHomedir], L"%")    // Variables are not allowed anywhere else
        )
    {
        bStatus = TRUE;
        _type = IDS_HOMEDIR_PATH;
        _szPrefix.Empty();
        _szSuffix = &pwszPath[lenHomedir];
    }

    _bDataValid = bStatus;
    return bStatus;
}

// parse the path to see if it is a per-user path
BOOL CRedirPath::LoadPerUser (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;
    WCHAR * pwszPos = NULL;
    int     lenUsername, len;

    // Start menu is not allowed to have a per user path.
    if (IDS_STARTMENU == _cookie)
        return FALSE;

    pwszPos = wcsstr (pwszPath, L"%");

    if (pwszPos)
    {
        *pwszPos = L'\0';   // Temporarily look at only the prefix.
        if (!IsValidPrefix (IDS_PERUSER_PATH, pwszPath))
        {
            *pwszPos = L'%';    // Reset the character at pwszPos
            goto LoadPerUser_End;
        }
        else
        {
            *pwszPos = L'%';    // Reset the character at pwszPos
        }
    }

    //
    // %username% should be the first variable that appears in the path
    // if this is to be a per-user path, but it should not be the first
    // thing in the path
    //
    if (NULL != pwszPos && pwszPos != pwszPath)
    {
        len = lstrlen (pwszPos);
        lenUsername = lstrlen (USERNAME_STR);
        if (lenUsername <= len &&
            0 == _wcsnicmp (pwszPos, USERNAME_STR, lenUsername) &&
            NULL == wcsstr (&pwszPos[lenUsername], L"%")
            )
        {
            bStatus = TRUE;
            _type = IDS_PERUSER_PATH;
            _szPrefix = pwszPath;
            _szPrefix = _szPrefix.Left (pwszPos - pwszPath);
            _szPrefix.TrimLeft();
            _szPrefix.TrimRight();
            _szPrefix.TrimRight(L'\\');
            _szSuffix = &pwszPos[lenUsername];
        }
    }

LoadPerUser_End:
    _bDataValid = bStatus;
    return bStatus;
}

// parse the path to see if it is a userprofile path
BOOL CRedirPath::LoadUserprofile (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;
    int     len, lenUserprofile;

    len = lstrlen (pwszPath);
    lenUserprofile = lstrlen (PROFILE_STR);

	//
	// Note: it is considered a userprofile path only if it is of the form
	// %userprofile%\<name> where <name> does not contain any variables
	//
    if (lenUserprofile + 1 < len &&
        0 == _wcsnicmp (pwszPath, PROFILE_STR, lenUserprofile) &&
        (L'\0' == pwszPath[lenUserprofile] || L'\\' == pwszPath[lenUserprofile]) &&
        NULL == wcsstr (&pwszPath[lenUserprofile], L"%")
        )
    {
        bStatus = TRUE;
        _type = IDS_USERPROFILE_PATH;
        _szPrefix.Empty();
        _szSuffix = &pwszPath[lenUserprofile];
    }

    _bDataValid = bStatus;
    return bStatus;
}

// parse the path to see if it is a specific path provided by the user
BOOL CRedirPath::LoadSpecific (LPCTSTR pwszPath)
{
    BOOL    bStatus = FALSE;

    // We pretty much allow all paths other than empty paths.

    if (NULL != pwszPath && L'\0' != *pwszPath)
    {
        bStatus = TRUE;
        _type = IDS_SPECIFIC_PATH;
        _szPrefix = pwszPath;
        _szPrefix.TrimLeft();
        _szPrefix.TrimRight();
        _szPrefix.TrimRight(L'\\');
		// use X:\ rather than X: to make sure client does not fail
		if (2 == _szPrefix.GetLength() && L':' == ((LPCTSTR)_szPrefix)[1])
			_szPrefix += L'\\';
        _szSuffix.Empty();
    }

    _bDataValid = bStatus;
    return bStatus;
}

//
// Validates the arguments and loads the path into the object.
// The existing object is not modified if the data is invalid
//
BOOL CRedirPath::Load (UINT type, LPCTSTR pwszPrefix, LPCTSTR pwszSuffix)
{
    CString szPrefix;
    CString szSuffix;

    // First process the strings.
    szPrefix = pwszPrefix;
    szPrefix.TrimLeft();
    szPrefix.TrimRight();
    szPrefix.TrimRight(L'\\');

    szSuffix = pwszSuffix;
    szSuffix.TrimLeft();
    szSuffix.TrimRight();
    szSuffix.TrimRight(L'\\');

    //
    // The suffix should never have a variable name in it, except
    // IDS_SPECIFIC_PATH, for which a suffix really does not make
    // much sense.
    //
    if (IDS_SPECIFIC_PATH != type &&
        -1 != szSuffix.Find (L'%'))
    {
        return FALSE;
    }

    // Now do the remaining validation on the type and the suffix.
    switch (type)
    {
    case IDS_PERUSER_PATH:
        if (szPrefix.IsEmpty() ||
            ! IsValidPrefix (type, (LPCTSTR) szPrefix))
            return FALSE;
        break;
    case IDS_SPECIFIC_PATH:
        if (!IsValidPrefix (type, (LPCTSTR) szPrefix))
            return FALSE;
		// use X:\ rather than X: to make sure client does not fail.
		if (2 == szPrefix.GetLength() && L':' == ((LPCTSTR)szPrefix)[1])
			szPrefix += L'\\';
        szSuffix.Empty();   // The entire path is in the prefix. Suffix does not make sense here.
        break;
    case IDS_USERPROFILE_PATH:
    case IDS_HOMEDIR_PATH:
        szPrefix.Empty();   // The prefix does not make sense for these paths
        break;
    default:
        return FALSE;
        break;
    }

    //
    // If we are here, the data is okay. So populate the members.
    // Note: It is okay for the suffix to be an empty string.
    //
    _bDataValid = TRUE;
    _type = type;
    _szPrefix = szPrefix;
    _szSuffix = szSuffix;

    return TRUE;
}

void CRedirPath::GetPrefix (OUT CString & szPrefix) const
{
    if (_bDataValid)
        szPrefix = _szPrefix;
    else
        szPrefix.Empty();
}

UINT CRedirPath::GetType (void) const
{
    return _type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\fileinfo.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1994 - 1998.

Module Name:

    FileInfo.cxx

Abstract:

    This file contains the methods of the class CFileInfo. This is the class
    of objects that are used by the code to keep track of files/folders that
    are displayed in the MMC snapin.

Author:

    Rahul Thombre (RahulTh) 4/5/1998

Revision History:

    4/5/1998    RahulTh         Created this module.
    6/22/1998   RahulTh         added comments.

--*/


#include "precomp.hxx"

//static members
UINT CFileInfo::class_res_id = IDS_DIRS_START; //since we have an array of structures for the folders
                                               //in the same order as the resource ids of their names
                                               //we can use this static member to figure out the cookie
                                               //for each folder in the constructor. This ensures
                                               //that the default flags are set properly

WCHAR * g_szEnglishNames [] =
{
    L"Application Data",
    L"Desktop",
    L"My Documents",
    L"Start Menu",
    L"My Pictures",
    L"Programs",
    L"Startup"
};

//////////////////////////////////////////////
// Construction
//
// initializes the members of this class to some default values
//////////////////////////////////////////////
CFileInfo::CFileInfo(LPCTSTR lpszFullPathname /*= NULL*/
                     )
{
    m_pRedirPage = NULL;
    m_pSettingsPage = NULL;
    m_bSettingsInitialized = FALSE;
    m_bHideChildren = TRUE;
    Initialize (class_res_id,  //use a random cookie for the time being
                NULL    //for now, we use a null path for the file root.
                );
    class_res_id++;
}

/////////////////////////////////////
// Destruction
//
CFileInfo::~CFileInfo()
{
    //clean up here... if there is anything to clean up in this class
    DeleteAllItems();
}

/////////////////////////////////////////////////////////////
// this routine set the scope item id for the node in its object
//
void CFileInfo::SetScopeItemID (IN LONG scopeID)
{
    m_scopeID = scopeID;
}

/////////////////////////////////////////////////////////////
// this routine sets the default values on most of the members of this class
//
void CFileInfo::Initialize (long cookie, LPCTSTR szGPTPath)
{
    SHFILEINFO fileInfo;
    CString szTmp;
    CString szExt;
    LONG    i;

    i = GETINDEX (cookie);

    //set the cookie
    m_cookie = cookie;

    //set the file root
    if (szGPTPath)
        m_szFileRoot = szGPTPath;
    else
        m_szFileRoot.Empty();

    //set the name and type.
    m_szDisplayname = TEXT("???");
    m_szRelativePath = TEXT ("???");
    m_szTypename.LoadString (IDS_FOLDER_TYPE);
    
    if (-1 != i)
    {
        m_szDisplayname.LoadString (m_cookie);
        m_szEnglishDisplayName = g_szEnglishNames[i];
        m_szTypename.LoadString (IDS_FOLDER_TYPE);
        m_dwFlags = REDIR_DONT_CARE;
        switch (m_cookie)
        {
        case IDS_MYPICS:
            m_szRelativePath.LoadString (IDS_MYPICS_RELPATH);
            break;
        case IDS_PROGRAMS:
            m_szRelativePath.LoadString (IDS_PROGRAMS_RELPATH);
            break;
        case IDS_STARTUP:
            m_szRelativePath.LoadString (IDS_STARTUP_RELPATH);
            break;
        default:
            m_szRelativePath = m_szDisplayname;
            break;
        }
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::LoadSection
//
//  Synopsis:   This member function loads the redirection info. for this
//              folder from the ini file
//
//  Arguments:  none
//
//  Returns:    S_OK : if the section was loaded successfully
//              or other error codes
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HRESULT CFileInfo::LoadSection (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    i;
    BOOL    bStatus;
    DWORD   Status;
    const TCHAR lpszDefault[] = TEXT("*");  //a random default value
    DWORD   cbSize = 1024;
    DWORD   cbCopied;
    TCHAR*  lpszValue;
    TCHAR*  szEntry;
    CString IniFile;
    CString Value;
    BOOL    bValueFound;
    HRESULT hr;
    CString Pair;
    CString Key;
    CString Val;

    i = GETINDEX (m_cookie);

    if (-1 == i)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto LoadSec_Quit;
    }

    //get the name of the ini file
    IniFile.LoadString (IDS_INIFILE);
    IniFile = m_szFileRoot + '\\' + IniFile;

    m_dwFlags = REDIR_DONT_CARE;    //set the default value
    m_RedirGroups.erase (m_RedirGroups.begin(), m_RedirGroups.end());
    m_RedirPaths.erase (m_RedirPaths.begin(), m_RedirPaths.end());

    //read in the data from the FolderStatus section
    do
    {
        lpszValue = new TCHAR [cbSize];
        //set it to something other than the default value
        lpszValue[0] = '+';
        lpszValue[1] = '\0';
        //now try to read it from the ini file
        cbCopied = GetPrivateProfileString (TEXT("FolderStatus"),
                                            m_szEnglishDisplayName,
                                            lpszDefault,
                                            lpszValue,
                                            cbSize,
                                            (LPCTSTR) IniFile
                                            );
        if ('*' == lpszValue[0])    //the default string was copied, so the key does not exist
        {
            bValueFound = FALSE;
            break;
        }

        if (cbSize - 1 == cbCopied)
        {
            delete [] lpszValue;
            cbSize *= 2;
            continue;
        }

        bValueFound = TRUE;
        break;
    } while (TRUE);

    if (!bValueFound)
    {
        hr = S_OK;
        goto LoadSec_CleanupAndQuit;
    }

    Value = lpszValue;
    Value.TrimLeft();
    Value.TrimRight();

    swscanf ((LPCTSTR) Value, TEXT("%x"), &m_dwFlags);

    if ((m_dwFlags & REDIR_DONT_CARE) || (m_dwFlags & REDIR_FOLLOW_PARENT))
    {
        hr = S_OK;
        goto LoadSec_CleanupAndQuit;
    }

    //if we are here, there is more redirection path info. to be read off
    //of the ini file
    //so we first load the section
    do
    {
        cbCopied = GetPrivateProfileSection ((LPCTSTR) m_szEnglishDisplayName,
                                             lpszValue,
                                             cbSize,
                                             (LPCTSTR) IniFile
                                             );
        if (cbSize - 2 == cbCopied)
        {
            delete [] lpszValue;
            cbSize *= 2;
            lpszValue = new TCHAR [cbSize];
            continue;
        }

        break;
    } while (TRUE);

    //we now have the other section too.
    for (szEntry = lpszValue; *szEntry; szEntry += (lstrlen(szEntry) + 1))
    {
        Pair = szEntry;
        hr = SplitProfileString (Pair, Key, Val);
        Key.MakeLower();    //since CString comparison operator == is case
                            //sensitive
        Insert (Key, Val, FALSE, FALSE);
    }

    hr = S_OK;  //the section has been successfully loaded

LoadSec_CleanupAndQuit:
    delete [] lpszValue;

LoadSec_Quit:
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::SaveSection
//
//  Synopsis:   this function saves the redir info. for the object to
//              the ini file on the sysvol
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS : if we were successful in saving
//              or other error codes
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CFileInfo::SaveSection (void)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    DWORD   cbSize = 1024;
    TCHAR*  lpszSection;
    CString szIniFile;
    CString szVal;
    BOOL    bStatus;
    CFileInfo*  pChildInfo;
    DWORD   Status = ERROR_SUCCESS;

    //derive the name of the ini file
    szIniFile.LoadString (IDS_INIFILE);
    szIniFile = m_szFileRoot + '\\' + szIniFile;

    //create an empty section and write it to the ini file
    //so that the new data can be saved easily
    lpszSection = new TCHAR [cbSize];
    lpszSection[0] = lpszSection [1] = '\0';

    //pre-create the ini file in unicode so that the WritePrivateProfile*
    //APIs do not write in ANSI.
    PrecreateUnicodeIniFile ((LPCTSTR) szIniFile);

    bStatus = WritePrivateProfileSection ((LPCTSTR) m_szEnglishDisplayName,
                                          lpszSection,
                                          (LPCTSTR) szIniFile
                                          );

    //write the data into the FolderStatus section
    if (bStatus)
    {
        szVal.Format (TEXT("%x"), m_dwFlags);
        bStatus = WritePrivateProfileString (TEXT("FolderStatus"),
                                             (LPCTSTR) m_szEnglishDisplayName,
                                             (LPCTSTR) szVal,
                                             szIniFile
                                             );

    }

    if (bStatus)
    {
        for (i = m_RedirGroups.begin(), j = m_RedirPaths.begin();
             i != m_RedirGroups.end();
             i++, j++)
        {
            bStatus = WritePrivateProfileString ((LPCTSTR) m_szEnglishDisplayName,
                                                 (LPCTSTR) (*i),
                                                 (LPCTSTR) (*j),
                                                 szIniFile
                                                 );
            if (!bStatus)
                break;
        }
    }

    if (!bStatus)
        Status = GetLastError();
    else
        Status = ERROR_SUCCESS;

    delete [] lpszSection;

    return Status;

}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::Insert
//
//  Synopsis:   inserts a key value pair in the redir info structure of the
//              object. also note the description of the parameter fReplace
//
//  Arguments:  [in] szKey : the key
//              [in] szVal : the value
//              [in] fReplace : if FALSE, the key value pair won't be inserted
//                              if another entry with the same key exists
//              [in] fSaveSection : save the section after insertions if true
//
//  Returns:    ERROR_SUCCESS : if the key value pair was inserted
//              ERROR_ALREADY_EXISTS : if the key value pair was not inserted
//                                     since another entry with the same key
//                                     already exists
//              or other error codes that might be encountered while saving
//                 the section
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      to keep the sysvol updated, it also calls SaveSection at the end
//
//---------------------------------------------------------------------------
DWORD CFileInfo::Insert (const CString& szKey, const CString& szVal,
                           BOOL fReplace, BOOL fSaveSection /*= TRUE*/)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    CString     Key;
    CString     Val;
    DWORD       Status = ERROR_SUCCESS;

    Key = szKey;
    Key.MakeLower();
    Val = szVal;

    //in this case, we must first check if an entry exists with that key
    for (i = m_RedirGroups.begin(), j = m_RedirPaths.begin();
         i != m_RedirGroups.end();
         i++, j++)
    {
        if (Key == *i)
            break;
    }

    if (m_RedirGroups.end() == i)   //we do not have an entry with this key
    {
        m_RedirGroups.push_back(Key);
        m_RedirPaths.push_back (Val);
    }
    else    //we do have an entry that matches the key
    {
        if (fReplace)
            *j = Key;
        else
            Status = ERROR_ALREADY_EXISTS;
    }

    if (ERROR_SUCCESS == Status && fSaveSection)
        Status = SaveSection();

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::Delete
//
//  Synopsis:   deletes the entry corresponding to a given key
//
//  Arguments:  [in] szKey : the key that needs to get deleted
//
//  Returns:    ERROR_SUCCESS : if the deletion was successful
//              or other error codes that might be encountered while saving
//              the section (see notes below)
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      to maintain the ini file on the sysvol in sync with the
//              snapin, we save the redir info. at the end of every deletion
//
//---------------------------------------------------------------------------
DWORD CFileInfo::Delete (const CString& szKey, BOOL fSaveSection /*= TRUE*/)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    DWORD   Status = ERROR_SUCCESS;

    for (i = m_RedirGroups.begin(), j = m_RedirPaths.begin();
         i != m_RedirGroups.end();
         i++, j++)
    {
        if (szKey == *i)
            break;
    }

    if (m_RedirGroups.end() != i)   //an entry with that key was found
    {
        m_RedirGroups.erase(i);
        m_RedirPaths.erase (j);
        if (fSaveSection)
            Status = SaveSection ();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileInfo::DeleteAllItems
//
//  Synopsis:   this functions deletes all the group and path information
//              stored in the object
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CFileInfo::DeleteAllItems (void)
{
    m_RedirGroups.erase (m_RedirGroups.begin(), m_RedirGroups.end());
    m_RedirPaths.erase (m_RedirPaths.begin(), m_RedirPaths.end());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\rsopprop.cpp ===
// rsopprop.cpp : implementation file
//


#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// rsopprop property page

IMPLEMENT_DYNCREATE(CRsopProp, CPropertyPage)

CRsopProp::CRsopProp() : CPropertyPage(CRsopProp::IDD)
{
    //{{AFX_DATA_INIT(CRsopProp)
    m_szGroup = _T("");
    m_szGPO = _T("");
    m_szPath = _T("");
    m_szSetting = _T("");
    m_fMove = FALSE;
    m_fApplySecurity = FALSE;
    m_iRemoval = -1;
    //}}AFX_DATA_INIT
}

CRsopProp::~CRsopProp()
{
    *m_ppThis = NULL;
}

void CRsopProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsopProp)
    DDX_Text(pDX, IDC_GROUP, m_szGroup);
    DDX_Text(pDX, IDC_GPO, m_szGPO);
    DDX_Text(pDX, IDC_PATH, m_szPath);
    DDX_Text(pDX, IDC_SETTING, m_szSetting);
    DDX_Check(pDX, IDC_PREF_MOVE, m_fMove);
    DDX_Check(pDX, IDC_PREF_APPLYSECURITY, m_fApplySecurity);
    DDX_Radio(pDX, IDC_PREF_ORPHAN, m_iRemoval);
    //}}AFX_DATA_MAP
}

BOOL CRsopProp::OnInitDialog()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString sz;
    CString sz2;

    GetDlgItemText(IDC_GPO, sz);
    m_szGPO.Format(sz, m_pInfo->m_szGPO);

    GetDlgItemText(IDC_SETTING, sz);
    sz2.LoadString(IDS_SETTINGS + m_pInfo->m_nInstallationType);
    m_szSetting.Format(sz, sz2);

    GetDlgItemText(IDC_GROUP, sz);
    m_szGroup.Format(sz, m_pInfo->m_szGroup);

    m_szPath = m_pInfo->m_szPath;

    m_fMove = m_pInfo->m_fMoveType;

    m_fApplySecurity = m_pInfo->m_fGrantType;

    m_iRemoval = m_pInfo->m_nPolicyRemoval - 1;

    GetDlgItemText(IDC_PREF_TITLE, sz);
    sz2.Format(sz, m_szFolder);
    SetDlgItemText(IDC_PREF_TITLE, sz2);

    GetDlgItemText(IDC_PREF_APPLYSECURITY, sz);
    sz2.Format(sz, m_szFolder);
    SetDlgItemText(IDC_PREF_APPLYSECURITY, sz2);

    GetDlgItemText(IDC_PREF_MOVE, sz);
    sz2.Format(sz, m_szFolder);
    SetDlgItemText(IDC_PREF_MOVE, sz2);

    CPropertyPage::OnInitDialog();

    return TRUE;
}


BEGIN_MESSAGE_MAP(CRsopProp, CPropertyPage)
    //{{AFX_MSG_MAP(CRsopProp)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsopProp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\pathslct.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

    pathslct.cxx

Abstract:
    This module contains the methods and message handlers for the dialog
    that is used to select the redirection destination. This dialog is
    used as a child dialog by both the basic and the advanced settings.

Author:

    Rahul Thombre (RahulTh) 3/1/2000

Revision History:

    3/1/2000    RahulTh         Created this module.

--*/

#include "precomp.hxx"

BEGIN_MESSAGE_MAP (CEditNoVars, CEdit)
    ON_WM_CHAR()
END_MESSAGE_MAP()

//+--------------------------------------------------------------------------
//
//  Member:     CEditNoVars::OnChar
//
//  Synopsis:   Customized edit control behavior. Prevents users from
//              entering variables.
//
//  Arguments:  see MFC documentation
//
//  Returns:    nothing
//
//  History:    3/2/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CEditNoVars::OnChar (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    // Ignore the * symbol. Do not allow users to type it in.
    if ('*' != nChar)
    {
        CEdit::OnChar (nChar, nRepCnt, nFlags);
    }
    else
    {
        // Indicate to the user that % is not permitted in the path.
        ::MessageBeep (-1);
    }
}


// Mapping between control IDs and Help IDs for the path chooser
const DWORD g_aHelpIDMap_IDD_PATHCHOOSER[] =
{
    IDC_DESTTYPE,           IDH_DESTTYPE,
    IDC_ROOT_DESC,          IDH_DISABLEHELP,
    IDC_ROOT_PATH,          IDH_ROOT_PATH,
    IDC_BROWSE,             IDH_BROWSE,
    IDC_SAMPLE_PATH,        IDH_DISABLEHELP,
    0,                      0
};

CPathChooser::CPathChooser(CWnd* pParent /*=NULL*/)
    : CDialog(CPathChooser::IDD, pParent), m_pParent (pParent)
{
    //{{AFX_DATA_INIT(CPathChooser)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_iCurrType = 0;
}

void CPathChooser::GetRoot (CString & szRoot)
{
    m_rootPath.GetWindowText (szRoot);
    szRoot.TrimLeft();
    szRoot.TrimRight();
    szRoot.TrimRight(L'\\');
	// When redirecting to the root of a drive, redirect to X:\ rather than X:
	if (2 == szRoot.GetLength() && L':' == ((LPCTSTR)szRoot)[1])
		szRoot += L'\\';
}

UINT CPathChooser::GetType (void)
{
    return m_iCurrType + m_iTypeStart;
}


void
CPathChooser::Instantiate (IN UINT          cookie,
                           IN CWnd *        pParent,
                           IN CWnd *        pwndInsertAt,
                           IN const CRedirPath *  pRedirPath,
                           IN UINT          nFlags     // = SWP_HIDEWINDOW
                           )
{
    RECT    rc;
    RECT    rc_ctrl;

    //
    // Now initialize the member variables.
    // Note: it is important to set the parent before the making the call to
    // Create so that CPathChooser's OnInitDialog is able to set the right
    // parent. Otherwise, the window positioning won't work as expected.
    //
    m_pParent = pParent;
    m_cookie = cookie;
    m_pRedirPath = pRedirPath;

    // First create the modeless window.
    this->Create (IDD, pParent);

    //
    // Set a limit on the number of characters that can be entered into
    // into the edit control
    //
    m_rootPath.SetLimitText (TARGETPATHLIMIT);

    // Now adjust the dimensions and place the window that the right location.
    pwndInsertAt->ShowWindow (SW_HIDE);
    pwndInsertAt->GetWindowRect (&rc);
    pParent->ScreenToClient (&rc);
    this->SetWindowPos (pwndInsertAt,
                        rc.left,
                        rc.top,
                        rc.right - rc.left,
                        rc.bottom - rc.top,
                        nFlags
                        );

    //
    // Now resize and move the controls within this dialog to fit the new size
    // Widen the dest. type combo box.
    //
    m_destType.GetClientRect (&rc_ctrl);
    m_destType.SetWindowPos (NULL,
                             -1,
                             -1,
                             rc.right - rc.left,
                             rc_ctrl.bottom,
                             SWP_NOZORDER | SWP_NOMOVE
                             );
    //
    // Widen the edit control -- set the height to be the same as the
    // combo box above
    //
    m_rootPath.SetWindowPos (NULL,
                             -1,
                             -1,
                             rc.right - rc.left,
                             rc_ctrl.bottom,
                             SWP_NOZORDER | SWP_NOMOVE
                             );

    //
    // Move the browse button so that it is aligned with the right
    // edge of the edit control
    //
    m_rootPath.GetWindowRect (&rc);
    this->ScreenToClient (&rc);
    m_browse.GetWindowRect (&rc_ctrl);
    this->ScreenToClient (&rc_ctrl);
    m_browse.SetWindowPos (NULL,
                           rc_ctrl.left + rc.right - rc_ctrl.right,
                           rc_ctrl.top,
                           -1,
                           -1,
                           SWP_NOZORDER | SWP_NOSIZE
                           );

    //
    // Change the height and width of the static control used to display
    // example per user paths so that it is as wide as the dialog and is
    // aligned with the bottom of the control
    //
    this->GetClientRect (&rc);
    m_peruserPathDesc.GetWindowRect (&rc_ctrl);
    this->ScreenToClient (&rc_ctrl);
    m_iPathDescWidth = rc.right;
    m_peruserPathDesc.SetWindowPos (NULL,
                                    -1,
                                    -1,
                                    m_iPathDescWidth,
                                    rc.bottom - rc_ctrl.top,
                                    SWP_NOZORDER | SWP_NOMOVE
                                    );

    // Load the values into the controls
    PopulateControls ();
}


// Populates the controls based on the values passed into the dialog

void
CPathChooser::PopulateControls (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    i;
    CString szText;

    m_iCurrType = 0;
    switch (m_cookie)
    {
    case IDS_MYDOCS:
        m_iTypeStart = IDS_MYDOCS_DESTTYPE_START;
        break;
    case IDS_STARTMENU:
        m_iTypeStart = IDS_SMENU_DESTTYPE_START;
        break;
    default:
        m_iTypeStart = IDS_DESTTYPE_START;
        break;
    }

    // Now populate the destination type combo box based on the settings
    for (i = m_iTypeStart; i < IDS_DESTTYPE_END; i++)
    {
        szText.LoadString (i);
        m_destType.AddString ((LPCTSTR) szText);
    }

    // Put data in the controls.
    if (m_pRedirPath->IsPathValid())
    {
        m_iCurrType = m_pRedirPath->GetType() - m_iTypeStart;
        m_pRedirPath->GetPrefix (szText);
        m_rootPath.SetWindowText (szText);
        m_rootPath.SetModify (TRUE);
    }
    else
    {
        //
        // Use the first choice for all but the MyDocs folder.
        // because the first choice for MyDocs is the HOMEDIR option
        // and we want to encourage users to specify the path through
        // group policy rather than use the HOMEDIR path set on the user
        // object
        //
        if (IDS_MYDOCS == m_cookie)
            m_iCurrType = IDS_PERUSER_PATH - m_iTypeStart;
        else
            m_iCurrType = 0;
        m_rootPath.SetWindowText (L"");
        m_rootPath.SetModify (TRUE);
    }
    // Set the current type
    m_destType.SetCurSel (m_iCurrType);

    // Make sure that some of the controls are hidden if required
    ShowControls ();

    //
    // Notify the parent that the path has been tweaked so that it can
    // update any controls that on it that might depend on the contents of
    // this dialog
    //
    TweakPathNotify ();

}


void CPathChooser::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPathChooser)
    DDX_Control(pDX, IDC_DESTTYPE, m_destType);
    DDX_Control(pDX, IDC_ROOT_DESC, m_rootDesc);
    DDX_Control(pDX, IDC_ROOT_PATH, m_rootPath);
    DDX_Control(pDX, IDC_SAMPLE_PATH, m_peruserPathDesc);
    DDX_Control(pDX, IDC_BROWSE, m_browse);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPathChooser, CDialog)
    //{{AFX_MSG_MAP(CPathChooser)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_CBN_SELCHANGE (IDC_DESTTYPE, OnDestTypeChange)
    ON_EN_CHANGE (IDC_ROOT_PATH, OnChangeRoot)
    ON_EN_KILLFOCUS (IDC_ROOT_PATH, OnRootKillFocus)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPathChooser message handlers

BOOL CPathChooser::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // Always hide by default. Actual visible state will be determined
    // later in the instantiate method.
    //
    this->ShowWindow (SW_HIDE);
    this->SetParent (m_pParent);

    // Subclass the edit control to modify behavior
    m_rootPath.SubclassDlgItem (IDC_ROOT_PATH, this);


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CPathChooser::OnCancel()
{
    DestroyWindow ();
}

void CPathChooser::OnBrowse()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    BROWSEINFO      browseInfo;
    CString         szInstructions;
    TCHAR           pszSelectedFolder[MAX_PATH];
    LPITEMIDLIST    lpItemIDList;
    LPMALLOC        pMalloc;
    CError          error(this);
    DWORD           dwError;
    CString         szSelectedPath;
    CString         szUNC;

    szSelectedPath.Empty();
    szInstructions.LoadString (IDS_FOLDERBROWSE_DESC);

    browseInfo.hwndOwner = m_hWnd;
    browseInfo.pidlRoot = NULL;
    browseInfo.pszDisplayName = pszSelectedFolder;
    browseInfo.lpszTitle = (LPCTSTR)szInstructions;
    browseInfo.ulFlags = BIF_RETURNONLYFSDIRS;
    browseInfo.lpfn = BrowseCallbackProc;
    browseInfo.lParam = (LPARAM) (&szSelectedPath);

    if (NULL != (lpItemIDList = SHBrowseForFolder (&browseInfo)))
    {
        //try to get the path from the item id list
        dwError = GetUNCPath (szSelectedPath, szUNC);
        if (NO_ERROR != dwError)  //then do the best you can
            szUNC = szSelectedPath;

        if (TARGETPATHLIMIT < szUNC.GetLength())
            error.ShowMessage (IDS_PATHTOOLONG_ERROR, TARGETPATHLIMIT);
        else
        {
            m_rootPath.SetWindowText (szUNC);
            m_rootPath.SetModify(TRUE);
            // Notify the parent that the path has been modified
            TweakPathNotify();
        }

        SHGetMalloc(&pMalloc);
        pMalloc->Free (lpItemIDList);
        pMalloc->Release();
    }
}

void CPathChooser::OnDestTypeChange (void)
{
    int     Sel;

    Sel = m_destType.GetCurSel();

    if (Sel == m_iCurrType)
        return;                     // The choice has not changed

    // Update the current choice.
    m_iCurrType = Sel;
    ShowControls();

    // Notify the parent of the change
    TweakPathNotify ();
}

void CPathChooser::ShowControls (void)
{
    int nCmdShow;

    switch (m_iCurrType + m_iTypeStart)
    {
    case IDS_SPECIFIC_PATH:
    case IDS_PERUSER_PATH:
        nCmdShow = SW_SHOW;
        break;
    case IDS_USERPROFILE_PATH:
    case IDS_HOMEDIR_PATH:
        nCmdShow = SW_HIDE;
        break;
    }

    m_browse.ShowWindow (nCmdShow);
    m_rootPath.ShowWindow (nCmdShow);
    m_rootDesc.ShowWindow (nCmdShow);
}

void CPathChooser::OnChangeRoot()
{
    // Notify the parent that the path has changed.
    TweakPathNotify ();
}

void CPathChooser::OnRootKillFocus()
{
    CString     szUNC;
    CString     szCurr;

    m_rootPath.GetWindowText (szCurr);
    szCurr.TrimLeft();
    szCurr.TrimRight();
    szCurr.TrimRight(L'\\');
    if (szCurr.IsEmpty() || PathIsUNC ((LPCTSTR)szCurr))
	{
        return;
	}
	
    if (NO_ERROR == GetUNCPath (szCurr, szUNC))
	{
		if (TARGETPATHLIMIT < szUNC.GetLength())
			return;
	}
	else
	{
		szUNC = szCurr;
	}
	
    //
	// if the path is of the form X: change it to X:\ (so that
    // the redirection at the client does not run into problems
    //
	if (2 == szUNC.GetLength() && L':' == ((LPCTSTR)szUNC)[1])
		szUNC += L'\\';
	
    m_rootPath.SetWindowText (szUNC);
}

LONG CPathChooser::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_PATHCHOOSER);

    return lResult;
}

LONG CPathChooser::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_PATHCHOOSER);

    return lResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CPathChooser::TweakPathNotify
//
//  Synopsis:   Notifies the parent that the path has been tweaked.
//
//  Arguments:
//
//  Returns:
//
//  History:    3/3/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void
CPathChooser::TweakPathNotify (void)
{
    LPARAM  lParam;
    WPARAM  wParam;
    CString szRootPath;
    WCHAR   szCompactPath[MAX_PATH];
    static CString szUser = TEXT("");
    static CString szPathDesc = TEXT("");

    lParam = (LPARAM) (m_iCurrType + m_iTypeStart);

    if (-1 == m_iCurrType)
    {
        wParam = (WPARAM) FALSE;
    }
    else
    {
        switch (m_iCurrType + m_iTypeStart)
        {
        case IDS_PERUSER_PATH:
            if (IDS_STARTMENU == m_cookie)
            {
                wParam = (WPARAM) FALSE;
            }
            else
            {
                m_rootPath.GetWindowText (szRootPath);
                szRootPath.TrimLeft();
                szRootPath.TrimRight();
                szRootPath.TrimRight (L'\\');
                if (szRootPath.IsEmpty() ||
                    ! IsValidPrefix (IDS_PERUSER_PATH, (LPCTSTR) szRootPath))
                {
                    wParam = (WPARAM) FALSE;
                    m_peruserPathDesc.ShowWindow (SW_HIDE);
                }
                else
                {
                    wParam = (WPARAM) TRUE;

                    if (szUser.IsEmpty())
                        szUser.LoadString (IDS_SAMPLE_USER);

                    if (szPathDesc.IsEmpty())
                        szPathDesc.LoadString (IDS_SAMPLE_PATHDESC);

                    CString     szTmp;
                    CString     szPath;
                    BOOL        bShowPath;

                    // Check if the path has changed
                    if (m_pRedirPath->IsPathDifferent (IDS_PERUSER_PATH, szRootPath))
                    {
                        CRedirPath  displayPath (m_cookie);
                        displayPath.GenerateSuffix (szTmp, m_cookie, IDS_PERUSER_PATH);
                        bShowPath = displayPath.Load (IDS_PERUSER_PATH, szRootPath, szTmp);
                        if (bShowPath)
                        {
                            bShowPath = displayPath.GeneratePath (szPath, szUser);
                        }
                    }
                    else
                    {
                        bShowPath = m_pRedirPath->GeneratePath (szPath, szUser);
                    }

                    if (bShowPath)
                        bShowPath = (MAX_PATH > szPath.GetLength());

                    if (bShowPath)
                    {
                        lstrcpy (szCompactPath, (LPCTSTR) szPath);
                        bShowPath = PathCompactPath (NULL, szCompactPath, m_iPathDescWidth);
                        if (bShowPath)
                            szTmp.Format (szPathDesc, szUser, szCompactPath);
                    }

                    if (bShowPath)
                    {
                        m_peruserPathDesc.SetWindowText (szTmp);
                        m_peruserPathDesc.ShowWindow (SW_SHOW);
                    }
                    else
                    {
                        m_peruserPathDesc.ShowWindow (SW_HIDE);
                    }
                }
            }
            break;
        case IDS_SPECIFIC_PATH:
            m_peruserPathDesc.ShowWindow (SW_HIDE);
            m_rootPath.GetWindowText(szRootPath);
            szRootPath.TrimLeft();
            szRootPath.TrimRight();
            szRootPath.TrimRight ('\\');
            if (! IsValidPrefix (IDS_SPECIFIC_PATH, (LPCTSTR) szRootPath))
                wParam = (WPARAM) FALSE;
            else
                wParam = (WPARAM) TRUE;
            break;
		case IDS_HOMEDIR_PATH:
			{
				CString szTmp;

				szTmp.LoadString (IDS_HOMEDIR_WARNING);
				m_peruserPathDesc.SetWindowText (szTmp);
				m_peruserPathDesc.ShowWindow (SW_SHOW);
				wParam = (WPARAM) (m_cookie == IDS_MYDOCS ? TRUE : FALSE);
				break;
			}
        case IDS_USERPROFILE_PATH:
            m_peruserPathDesc.ShowWindow (SW_HIDE);
            wParam = (WPARAM) TRUE;
            break;
        default:
            m_peruserPathDesc.ShowWindow (SW_HIDE);
            wParam = (WPARAM) FALSE;
            break;
        }
    }

    m_pParent->SendMessage (WM_PATH_TWEAKED, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\result.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       result.cpp
//
//  Contents:   implementation of the result pane
//
//  Classes:    CResultPane
//
//  History:    03-17-1998   stevebl   Created
//              07-16-1998   rahulth   added calls to IGPEInformation::PolicyChanged()
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <shlobj.h>

#include <atlimpl.cpp>
#include <wbemcli.h>
#include "rsoputil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const int HeaderWidths [] =
{
    200,    //name
    60,    //size
    100,    //type
    100     //modified date
};

const int RSOPHeaderWidths [] =
{
    150,      // precedence
    200,      // redirected path
    100,      // group
    75,       // setting
    100,      // gpo
    60,      // exclusive
    50,      // move
    150       // policy removal
};

long CResultPane::lDataObjectRefCount = 0;

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"FDE_INTERNAL";

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

//+--------------------------------------------------------------------------
//
//  Function:   ExtractInternalFormat
//
//  Synopsis:   Returns a pointer to our private object format given an
//              LPDATAOBJECT
//
//  Arguments:  [lpDataObject] - pointer to a DATAOBJECT, generally from a
//                                MMC call.
//
//  Returns:    A pointer to INTERNAL, our internal object structure.
//              NULL - if the object doesn't contain one of our objects
//              (wasn't created by us)
//
//  History:    3-13-1998   stevebl   Commented
//
//---------------------------------------------------------------------------

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    INTERNAL* internal = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    if (!lpDataObject)
        return NULL;


    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        internal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);

                if (internal == NULL)
                        break;

        } while (FALSE);

    return internal;
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's IComponent implementation

STDMETHODIMP CResultPane::GetResultViewType(MMC_COOKIE cookie,  BSTR* ppViewType, LONG * pViewOptions)
{
    // Use default view
    return S_FALSE;
}

STDMETHODIMP CResultPane::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    return S_OK;
}

STDMETHODIMP CResultPane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MMC_COOKIE cookie;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            cookie = 0;
        }
        else
        {
            cookie = pInternal->m_cookie;
        }


        switch(event)
        {
        case MMCN_ACTIVATE:
            hr = OnActivate(cookie, arg, param);
            break;

        case MMCN_CLICK:
            hr = OnResultItemClkOrDblClk(cookie, FALSE);
            break;

        case MMCN_DBLCLICK:
            if (pInternal && pInternal->m_type == CCT_RESULT)
                hr = OnResultItemClkOrDblClk(cookie, TRUE);
            else
                hr = S_FALSE;
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow (cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

                case MMCN_SELECT:
                        if (pInternal)
                                hr = OnSelect(pInternal->m_type, cookie, arg, param);
                        else
                                hr = S_FALSE;
            break;

        case MMCN_COLUMNS_CHANGED:
            break;

        case MMCN_COLUMN_CLICK:
            // retain column number and sort option flags so we can pass
            // them in to sort in the event we need to trigger a resort of
            // the result pane
            m_nSortColumn = arg;
            m_dwSortOptions = param;
            break;

        case MMCN_CONTEXTHELP:
            hr = OnContextHelp();
            break;

        // Note - Future expansion of notify types possible
        default:
            //perform the default action
            hr = S_FALSE;
            break;
        }

                if (pInternal)
                {
                        FREE_INTERNAL(pInternal);
                }
    }

    return hr;
}

STDMETHODIMP CResultPane::Destroy(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pConsoleVerb);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        if (m_pScopePane)
        {
            ((IComponentData*)m_pScopePane)->Release(); // QI'ed in IComponentDataImpl::CreateComponent
        }
    }

    return S_OK;
}

STDMETHODIMP CResultPane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    CComObject<CDataObject>* pObject = NULL;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    if (!pObject)
        return E_UNEXPECTED;

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

/////////////////////////////////////////////////////////////////////////////
// CResultPane's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CResultPane);

CResultPane::CResultPane()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CResultPane);
    CResultPane::lDataObjectRefCount = 0;
    m_lViewMode = LVS_REPORT;
    m_nSortColumn = 0;
    m_dwSortOptions = 0;
    m_nIndex = 0;
    Construct();
}

CResultPane::~CResultPane()
{
#if DBG
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CResultPane);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);

    Construct();

    ASSERT(CResultPane::lDataObjectRefCount == 0);
}

void CResultPane::Construct()
{
#if DBG
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pScopePane = NULL;
    m_hCurrScopeItem = -1;
}

void CResultPane::LoadResources()
{
    // Load strings from resources
    int i, j;

    for (j = 0, i = IDS_FIRST_COL; i < IDS_LAST_COL; i++, j++)
        m_columns[j].LoadString(i);
    for (j = 0, i = IDS_FIRST_RSOP_COL; i < IDS_LAST_RSOP_COL; i++, j++)
        m_RSOP_columns[j].LoadString(i);
    m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
}

HRESULT CResultPane::InitializeHeaders(MMC_COOKIE cookie)
{
    HRESULT hr = S_OK;
    int i;

    ASSERT(m_pHeader);

    // Put the correct headers depending on the cookie
    // Note - cookie ignored for this sample
    if (m_pScopePane->m_fRSOP && cookie != IDS_FOLDER_TITLE)
    {
        for (i = 0; i < RSOPCOLUMNID(IDS_LAST_RSOP_COL); i++)
            m_pHeader->InsertColumn(i, m_RSOP_columns[i], LVCFMT_LEFT, RSOPHeaderWidths[i]); //add the columns
    }
    else
    {
        for (i = 0; i < COLUMNID(IDS_LAST_COL); i++)
            m_pHeader->InsertColumn(i, m_columns[i], LVCFMT_LEFT, HeaderWidths[i]); //add the columns
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation

STDMETHODIMP CResultPane::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG * pInsertionAllowed)
{
    //we do not have any special commands on the menu
    return S_OK;
}

STDMETHODIMP CResultPane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    //we do not have any special commands on the menu
    return S_OK;
}

HRESULT CResultPane::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
    {
        return E_INVALIDARG;
    }

    // add the images for the scope tree
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    LPIMAGELIST lpScopeImage = (LPIMAGELIST)arg;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

// Result item property pages:
STDMETHODIMP CResultPane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    if (!m_pScopePane->m_fRSOP)
        return S_FALSE;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);

        if (! pInternal)
                return S_FALSE;

    DWORD   cookie = pInternal->m_cookie;
    LONG    i;
    BOOL    fShowPage = FALSE;
    AFX_OLDPROPSHEETPAGE * pPsp;
    CRSOPInfo * pRSOPInfo;

    //it is one of the folders
    pRSOPInfo = &(m_RSOPData[cookie]);

    if (!pRSOPInfo->m_pRsopProp)   //make sure that the property page is not already up.
    {
        pRSOPInfo->m_pRsopProp = new CRsopProp;
        pRSOPInfo->m_pRsopProp->m_ppThis = &(pRSOPInfo->m_pRsopProp);
        pRSOPInfo->m_pRsopProp->m_pInfo = pRSOPInfo;
        pRSOPInfo->m_pRsopProp->m_szFolder = pRSOPInfo->m_pRsopProp->m_pInfo->m_szFolder;
        fShowPage = TRUE;
        pPsp = (AFX_OLDPROPSHEETPAGE *)&(pRSOPInfo->m_pRsopProp->m_psp);
    }

    if (fShowPage)  //show page if it is not already up.
    {
        hr = SetPropPageToDeleteOnClose (pPsp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hProp = CreateThemedPropertySheetPage(pPsp);
            if (NULL == hProp)
                hr = E_UNEXPECTED;
            else
            {
                lpProvider->AddPage(hProp);
                hr = S_OK;
            }
        }
    }

    FREE_INTERNAL(pInternal);

    return hr;
}

// Result items property pages:
STDMETHODIMP CResultPane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    if (!m_pScopePane->m_fRSOP)
        return S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (! pInternal)
                return S_FALSE;

    MMC_COOKIE cookie = pInternal->m_cookie;
    HRESULT hr = S_FALSE;
    CError  error;

    if (CCT_RESULT == pInternal->m_type)
    {
        hr = S_OK;
    }

    FREE_INTERNAL(pInternal);
    return hr;
}

STDMETHODIMP CResultPane::CompareObjects(LPDATAOBJECT lpDataObjectA,
                                         LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

STDMETHODIMP CResultPane::Compare(LPARAM lUserParam,
                                  MMC_COOKIE cookieA,
                                  MMC_COOKIE cookieB,
                                  int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;

    *pnResult = 0;

    // Retrieve the objects referred to by the two cookies and compare them
    // based upon the data that's associated with nCol.  (The values you
    // compare depends on which column the caller asks for.)
    CString szA, szB;
    CRSOPInfo &dataA = m_RSOPData[cookieA];
    CRSOPInfo &dataB = m_RSOPData[cookieB];

    switch (nCol)
    {
    case 0: // precedence
        *pnResult = dataA.m_nPrecedence - dataB.m_nPrecedence;
        return S_OK;
    case 1: // redirected path
        szA = dataA.m_szPath;
        szB = dataB.m_szPath;
        break;
    case 2: // group
        szA = dataA.m_szGroup;
        szB = dataB.m_szGroup;
        break;
    case 3: // GPO
        szA = dataA.m_szGPO;
        szB = dataB.m_szGPO;
        break;
    case 4: // setting
        szA.LoadString(dataA.m_nInstallationType + IDS_SETTINGS);
        szB.LoadString(dataB.m_nInstallationType + IDS_SETTINGS);
        break;
    case 5: // exclusive
        szA.LoadString(dataA.m_fGrantType ? IDS_YES : IDS_NO);
        szB.LoadString(dataB.m_fGrantType ? IDS_YES : IDS_NO);
        break;
    case 6: // move
        szA.LoadString(dataA.m_fMoveType ? IDS_YES : IDS_NO);
        szB.LoadString(dataB.m_fMoveType ? IDS_YES : IDS_NO);
        break;
    case 7: // policy removal
        szA.LoadString(IDS_ONPOLICYREMOVAL + dataA.m_nPolicyRemoval);
        szB.LoadString(IDS_ONPOLICYREMOVAL + dataB.m_nPolicyRemoval);
        break;
    }

    *pnResult = szA.CompareNoCase(szB);
    return S_OK;
}


STDMETHODIMP CResultPane::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    static CString sz;
    CString szExt;

    ASSERT(pResult != NULL);
    ASSERT(pResult->bScopeItem);

    if (pResult)
    {
        if (pResult->bScopeItem)
        {
            switch (pResult->nCol)
            {
            case 0: //display name
                if (IDS_FOLDER_TITLE == pResult->lParam)
                    sz.LoadString (IDS_FOLDER_TITLE);
                else
                    sz = m_pScopePane->m_FolderData[GETINDEX(pResult->lParam)].m_szDisplayname;
                break;
            case 1: //type
                sz = m_pScopePane->m_FolderData[GETINDEX(pResult->lParam)].m_szTypename;
                break;
            default:
                sz = TEXT("");
                break;
            }
        }
        else
        {
            CRSOPInfo &data = m_RSOPData[pResult->lParam];
            switch (pResult->nCol)
            {
            case 0: // precedence
                sz.Format(TEXT("(%u) %s"), data.m_nPrecedence, data.m_szFolder);
                break;
            case 1: // redirected path
                sz = data.m_szPath;
                break;
            case 2: // group
                sz = data.m_szGroup;
                break;
            case 3: // GPO
                sz = data.m_szGPO;
                break;
            case 4: // setting
                sz.LoadString(data.m_nInstallationType + IDS_SETTINGS);
                break;
            case 5: // exclusive
                sz.LoadString(data.m_fGrantType ? IDS_YES : IDS_NO);
                break;
            case 6: // move
                sz.LoadString(data.m_fMoveType ? IDS_YES : IDS_NO);
                break;
            case 7: // policy removal
                sz.LoadString(IDS_ONPOLICYREMOVAL + data.m_nPolicyRemoval);
                break;
            default:
                sz = TEXT("");
                break;
            }

        }
        pResult->str = (unsigned short *)((LPCOLESTR)sz);
    }

    return S_OK;
}

HRESULT CResultPane::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CResultPane::TestForRSOPData(MMC_COOKIE cookie)
{
    HRESULT hr = S_OK;
    ASSERT(m_pScopePane != NULL);

    // Test for RSOP data for this folder
    RESULTDATAITEM  resultItem;
    memset(&resultItem, 0, sizeof(resultItem));
    resultItem.mask = RDI_STR | RDI_PARAM;
    resultItem.str = MMC_CALLBACK;

    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pObj = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    CString szQuery = TEXT("SELECT * FROM RSOP_FolderRedirectionPolicySetting");
    if (cookie && (cookie != IDS_FOLDER_TITLE))
    {
        szQuery = TEXT("SELECT * FROM RSOP_FolderRedirectionPolicySetting where id = \"");
        szQuery += g_szEnglishNames[GETINDEX(cookie)];
        szQuery += TEXT("\"");
    }
    BSTR strQuery = SysAllocString(szQuery);
    BSTR strNamespace = SysAllocString(m_pScopePane->m_szRSOPNamespace);
    ULONG n = 0;
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) & pLocator);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pLocator->ConnectServer(strNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    if (n == 0)
    {
        hr = E_FAIL;
    }
cleanup:
    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);
    SysFreeString(strNamespace);
    if (pObj)
    {
        pObj->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);

    return hr;
}

HRESULT CResultPane::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        ASSERT(m_pScopePane != NULL);
        m_pResult->SetViewMode(m_lViewMode);
        InitializeHeaders(cookie);
        m_hCurrScopeItem = m_pScopePane->m_FolderData[GETINDEX(cookie)].m_scopeID;
        if (m_pScopePane->m_fRSOP)
        {
            // Enumerate the RSOP data for this folder
            // and add a result item for each entry
            RESULTDATAITEM  resultItem;
            memset(&resultItem, 0, sizeof(resultItem));
            resultItem.mask = RDI_STR | RDI_PARAM;
            resultItem.str = MMC_CALLBACK;

            HRESULT hr = S_OK;
            IWbemLocator * pLocator = NULL;
            IWbemServices * pNamespace = NULL;
            IWbemClassObject * pObj = NULL;
            IEnumWbemClassObject * pEnum = NULL;
            BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
            CString szQuery = TEXT("SELECT * FROM RSOP_FolderRedirectionPolicySetting where name = \"");
            szQuery += g_szEnglishNames[GETINDEX(cookie)];
            szQuery += TEXT("\"");
            BSTR strQuery = SysAllocString(szQuery);
            BSTR strNamespace = SysAllocString(m_pScopePane->m_szRSOPNamespace);
            ULONG n = 0;
            hr = CoCreateInstance(CLSID_WbemLocator,
                                  0,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IWbemLocator,
                                  (LPVOID *) & pLocator);
            if (FAILED(hr))
            {
                goto cleanup;
            }
            hr = pLocator->ConnectServer(strNamespace,
                                         NULL,
                                         NULL,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL,
                                         &pNamespace);
            if (FAILED(hr))
            {
                goto cleanup;
            }

            // First perform the query
            hr = pNamespace->ExecQuery(strQueryLanguage,
                                       strQuery,
                                       WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                       NULL,
                                       &pEnum);
            if (FAILED(hr))
            {
                goto cleanup;
            }
            do
            {
                hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
                if (FAILED(hr))
                {
                    goto cleanup;
                }
                if (n > 0)
                {
                    // process the data
                    UINT    nPrecedence;
                    LPTSTR pszGPOName = NULL;
                    CString szGPOID;
                    UINT    nGroups = 0;
                    TCHAR * * rgszGroups = NULL;
                    UINT    nPaths = 0;
                    TCHAR * * rgszPaths = NULL;
                    BOOL    fGrantType;
                    BOOL    fMoveType;
                    UINT    nPolicyRemoval;
                    UINT    nInstallationType;
                    CString ResultantPath;
                    CString RedirectingGroup;

                    hr = GetParameter(pObj,
                                      TEXT("GPOID"),
                                      szGPOID);
                    hr = GetGPOFriendlyName(pNamespace,
                                            (LPTSTR)((LPCTSTR) szGPOID),
                                            strQueryLanguage,
                                            &pszGPOName);
                    hr = GetParameter(pObj,
                                      TEXT("Precedence"),
                                      nPrecedence);
                    hr = GetParameter(pObj,
                                      TEXT("GrantType"),
                                      fGrantType);
                    hr = GetParameter(pObj,
                                      TEXT("MoveType"),
                                      fMoveType);
                    hr = GetParameter(pObj,
                                      TEXT("PolicyRemoval"),
                                      nPolicyRemoval);
                    hr = GetParameter(pObj,
                                      TEXT("securityGroups"),
                                      nGroups,
                                      rgszGroups);
                    hr = GetParameter(pObj,
                                      TEXT("RedirectedPaths"),
                                      nPaths,
                                      rgszPaths);
                    hr = GetParameter(pObj,
                                      TEXT("installationType"),
                                      nInstallationType);
                    hr = GetParameter(pObj,
                                      TEXT("resultantPath"),
                                      ResultantPath);
                    hr = GetParameter(pObj,
                                      TEXT("redirectingGroup"),
                                      RedirectingGroup);
                    if (nInstallationType != 2)
                    {
                        // force a valid value
                        nInstallationType = 1;
                    }

                    if (nPaths != nGroups)
                    {
                        // If we don't have the same number of paths
                        // as groups then we have a problem.
                        hr = E_UNEXPECTED;
                    }
                     
                    
                    CString szDir;
                    CString szAcct;
                    CRSOPInfo & info = m_RSOPData[m_nIndex++];
                    info.m_nPrecedence = nPrecedence;
                    info.m_szPath = ResultantPath;
                   
                    if (STATUS_SUCCESS == GetFriendlyNameFromStringSid(
                        RedirectingGroup,
                        szDir,
                        szAcct))
                    {
                        if (!szDir.IsEmpty())
                            szAcct = szDir + '\\' + szAcct;
                    }
                    else    //just display the unfriendly string if the friendly name cannot be obtained
                    {
                        szAcct = RedirectingGroup;
                        szAcct.MakeUpper();
                    }

                    info.m_szGroup = szAcct;
                    info.m_szGPO = pszGPOName;
                    info.m_fGrantType = FALSE != fGrantType;
                    info.m_fMoveType = FALSE != fMoveType;
                    info.m_nPolicyRemoval = nPolicyRemoval;
                    info.m_nInstallationType = nInstallationType;
                    info.m_szFolder = m_pScopePane->m_FolderData[GETINDEX(cookie)].m_szDisplayname;
                    resultItem.lParam = m_nIndex - 1;;
                    m_pResult->InsertItem(&resultItem);

                    // erase allocated data
                    OLESAFE_DELETE(pszGPOName);
                    while (nPaths--)
                    {
                        OLESAFE_DELETE(rgszPaths[nPaths]);
                    }
                    OLESAFE_DELETE(rgszPaths);
                    while (nGroups--)
                    {
                        OLESAFE_DELETE(rgszGroups[nGroups]);
                    }
                    OLESAFE_DELETE(rgszGroups);

                }
            } while (n > 0);
        cleanup:
            SysFreeString(strQueryLanguage);
            SysFreeString(strQuery);
            SysFreeString(strNamespace);
            if (pObj)
            {
                pObj->Release();
            }
            if (pEnum)
            {
                pEnum->Release();
            }
            if (pNamespace)
            {
                pNamespace->Release();
            }
            if (pLocator)
            {
                pLocator->Release();
            }
            m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);

        }
    }
    else
    {
        m_pResult->GetViewMode(&m_lViewMode);
    }

    return hr;
}

HRESULT CResultPane::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CResultPane::OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick)
{
    return S_FALSE;
}

HRESULT CResultPane::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CResultPane::OnSelect(DATA_OBJECT_TYPES type, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (m_pConsoleVerb)
    {
        if (m_pScopePane->m_fRSOP)
        {
            if (type == CCT_RESULT)
            {
                // Set the default verb to properties
                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

                // Enable the properties verb.
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
            }
            else
            {
                // Set the default verb to open
                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

                // disable the properties verb
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
            }
        }
        else
        {
            if (type == CCT_SCOPE)
            {
                // Set the default verb to open
                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

                if (IDS_FOLDER_TITLE != cookie)
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, HIDDEN, TRUE);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                }
            }
        }
    }

    return S_OK;
}

HRESULT CResultPane::OnPropertyChange(LPARAM param)   // param is the cookie of the item that changed
{
    HRESULT hr = S_OK;
    // UNDONE - Make any updates to internal structures or visual
    // representation that might be necessary.
    m_pResult->Sort(m_nSortColumn, m_dwSortOptions, -1);
    return hr;
}

HRESULT CResultPane::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    if (m_pScopePane->m_fRSOP)
    {
        return S_OK;
    }
    INTERNAL* pInternal = ExtractInternalFormat (lpDataObject);

    if (!pInternal)
        return E_UNEXPECTED;

    if (m_hCurrScopeItem == pInternal->m_scopeID)
    {
        //also update the folders
        m_pScopePane->m_pScope->DeleteItem (pInternal->m_scopeID, FALSE);
        m_pScopePane->EnumerateScopePane (pInternal->m_cookie, pInternal->m_scopeID);

        //reenumerate the scope pane
        m_pConsole->SelectScopeItem (pInternal->m_scopeID);
    }
    FREE_INTERNAL (pInternal);
    return S_OK;
}

HRESULT CResultPane::OnContextHelp(void)
{
    LPOLESTR lpHelpTopic;
    LPCTSTR  pszHelpTopic = L"gpedit.chm::/Folder.htm";

    ASSERT (m_pDisplayHelp);

    lpHelpTopic = (LPOLESTR) CoTaskMemAlloc ((wcslen(pszHelpTopic) + 1) * sizeof(WCHAR));

    if (!lpHelpTopic)
    {
        DbgMsg((TEXT("CScopePane::OnContexHelp: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    wcscpy (lpHelpTopic, pszHelpTopic);
    return m_pScopePane->m_pDisplayHelp->ShowTopic (lpHelpTopic);
}

// This code is needed to ensure that property pages get cleaned up properly.
// This ensures that when the property sheet is closed all my of property
// pages that are associated with that property sheet will get deleted.
LPFNPSPCALLBACK _MMCHookProp;

UINT CALLBACK HookPropertySheetProp(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UINT i = _MMCHookProp(hwnd, uMsg, ppsp);
    switch (uMsg)
    {
    case PSPCB_RELEASE:
        delete (CPropertyPage *) ppsp->lParam;
        return TRUE;
    default:
        break;
    }
    return i;
}

LRESULT SetPropPageToDeleteOnClose(void * vpsp)
{
    HRESULT hr = MMCPropPageCallback(vpsp);
    if (SUCCEEDED(hr))
    {
        if (vpsp == NULL)
            return E_POINTER;

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)vpsp;

        if ((void*)psp->pfnCallback == (void*)HookPropertySheetProp)
            return E_UNEXPECTED;

        _MMCHookProp = psp->pfnCallback;

        psp->pfnCallback = HookPropertySheetProp;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\prefs.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    prefs.cxx

Abstract:
    Code for the property page that is used to obtaining the redirection
    preferences e.g. Move Contents, Apply ACLs,... etc.


Author:

    Rahul Thombre (RahulTh) 11/8/1998

Notes:

Revision History:

    11/8/1998   RahulTh         Created this module.
    1/26/1999   RahulTh         converted the dialog into a property page

--*/


#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//mapping between help ids and control ids for context sensitive help
//
const DWORD g_aHelpIDMap_IDD_REDIRMETHOD[] =
{
    IDC_PREF_ICON,          IDH_DISABLEHELP,
    IDC_PREF_TITLE,         IDH_DISABLEHELP,
    IDC_PREF_APPLYSECURITY, IDH_PREF_APPLYSECURITY,
    IDC_PREF_MOVE,          IDH_PREF_MOVE,
    IDC_GROUP_ORPHAN,       IDH_DISABLEHELP,
    IDC_PREF_ORPHAN,        IDH_PREF_ORPHAN,
    IDC_PREF_RELOCATE,      IDH_PREF_RELOCATE,
    IDC_PREF_MYPICS_GROUP,  IDH_DISABLEHELP,
    IDC_PREF_CHANGEMYPICS,  IDH_PREF_CHANGEMYPICS,
    IDC_PREF_LEAVEMYPICS,   IDH_PREF_LEAVEMYPICS,
    0,                      0
};

/////////////////////////////////////////////////////////////////////////////
// CRedirPref property page


CRedirPref::CRedirPref()
    : CPropertyPage (CRedirPref::IDD)
{
    //{{AFX_DATA_INIT(CRedirPref)
    m_szFolderName.Empty();
    m_fInitialized = FALSE;
    m_fMyPicsValid = FALSE;
    m_fMyPicsFollows = TRUE;
    m_fSettingsChanged = FALSE;
    //}}AFX_DATA_INIT

    //m_ppThis and m_pFileInfo are set immediately after creation in CScopePane routines
}

CRedirPref::~CRedirPref()
{
    //reset the pointer to this property page from its corresponding
    //CFileInfo object so that it know that it is gone.
    *m_ppThis = NULL;
    //reset the settings initialized member since this page is being destroyed
    m_fInitialized = m_pFileInfo->m_bSettingsInitialized = FALSE;
}

void CRedirPref::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRedirPref)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    DDX_Control (pDX, IDC_PREF_TITLE, m_csTitle);
    DDX_Control (pDX, IDC_PREF_MOVE, m_cbMoveContents);
    DDX_Control (pDX, IDC_PREF_APPLYSECURITY, m_cbApplySecurity);
    DDX_Control (pDX, IDC_GROUP_ORPHAN, m_grOrphan);
    DDX_Control (pDX, IDC_PREF_ORPHAN, m_rbOrphan);
    DDX_Control (pDX, IDC_PREF_RELOCATE, m_rbRelocate);
    DDX_Control (pDX, IDC_PREF_MYPICS_GROUP, m_grMyPics);
    DDX_Control (pDX, IDC_PREF_CHANGEMYPICS, m_rbFollowMyDocs);
    DDX_Control (pDX, IDC_PREF_LEAVEMYPICS, m_rbNoModify);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRedirPref, CPropertyPage)
    //{{AFX_MSG_MAP(CRedirPref)
    ON_BN_CLICKED (IDC_PREF_MOVE, OnModify)
    ON_BN_CLICKED (IDC_PREF_APPLYSECURITY, OnModify)
    ON_BN_CLICKED (IDC_PREF_ORPHAN, OnModify)
    ON_BN_CLICKED (IDC_PREF_RELOCATE, OnModify)
    ON_BN_CLICKED (IDC_PREF_CHANGEMYPICS, OnMyPicsChange)
    ON_BN_CLICKED (IDC_PREF_LEAVEMYPICS, OnMyPicsChange)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRedirPref message handlers

BOOL CRedirPref::OnInitDialog()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    RECT        rc;
    RECT        rcDlg;
    int         top, height;
    CString     szFormat;
    CString     szText;

    CPropertyPage::OnInitDialog();

    //tell the other property pages that InitDialog has been received.
    m_fInitialized = m_pFileInfo->m_bSettingsInitialized = TRUE;

    //get the display name
    m_szFolderName = m_pFileInfo->m_szDisplayname;

    //set the right text in the check boxes etc.
    szFormat.LoadString (IDS_PREF_TITLE);
    szText.Format ((LPCTSTR) szFormat, (LPCTSTR) m_szFolderName);
    m_csTitle.SetWindowText (szText);

    szFormat.LoadString (IDS_PREF_APPLYSECURITY);
    szText.Format ((LPCTSTR) szFormat, (LPCTSTR) m_szFolderName);
    m_cbApplySecurity.SetWindowText (szText);

    szFormat.LoadString (IDS_PREF_MOVE);
    szText.Format ((LPCTSTR) szFormat, (LPCTSTR) m_szFolderName);
    m_cbMoveContents.SetWindowText (szText);

   return TRUE; //return TRUE unless you set focus to a control.
}

BOOL CRedirPref::OnSetActive ()
{
    BOOL    bRet;
    CRedirect * pPage = NULL;

    bRet = CPropertyPage::OnSetActive();
    pPage = m_pFileInfo->m_pRedirPage;

    switch (pPage->m_iCurrChoice + pPage->m_iChoiceStart)
    {
    case IDS_DONT_CARE:
    case IDS_FOLLOW_PARENT:
        DisableSettings();
        break;
    case IDS_SCALEABLE:
        if (pPage->m_lstSecGroups.GetItemCount())
            EnableSettings();
        else
            DisableSettings();
        break;
    default:
        EnableSettings();
        break;
    }

    return bRet;
}

void CRedirPref::EnablePage (BOOL bEnable /* = TRUE*/)
{
    //enable or disable the contents of a page depending on whether
    if (!m_fInitialized)
        return;

    if (bEnable)
        EnableSettings();
    else
        DisableSettings();
}

void CRedirPref::DisableSettings(void)
{
    //since the settings are being disabled, the modifications in the
    //settings (if any) obviously have no significance.
    SetModified (FALSE);

    //disable all the options on this page... also uncheck all of them.
    m_csTitle.EnableWindow (FALSE);

    m_cbMoveContents.SetCheck(0);
    m_cbMoveContents.EnableWindow(FALSE);

    m_cbApplySecurity.SetCheck (0);
    m_cbApplySecurity.EnableWindow (FALSE);

    m_grOrphan.EnableWindow (FALSE);
    m_rbOrphan.SetCheck(0);
    m_rbOrphan.EnableWindow (FALSE);
    m_rbRelocate.SetCheck (0);
    m_rbRelocate.EnableWindow (FALSE);

    EnableMyPicsSettings (FALSE);

    return;
}

void CRedirPref::EnableMyPicsSettings (BOOL bEnable /* = TRUE*/)
{
    CRedirect * pPage = m_pFileInfo->m_pRedirPage;

    //my pics preferences are shown only in the tab for my documents
    if (IDS_MYDOCS != m_pFileInfo->m_cookie)
    {
        m_grMyPics.ShowWindow (SW_HIDE);
        m_rbFollowMyDocs.ShowWindow (SW_HIDE);
        m_rbNoModify.ShowWindow (SW_HIDE);
        return;
    }

    //this is the my docs folder
    m_grMyPics.ShowWindow (SW_SHOW);
    m_rbNoModify.ShowWindow (SW_SHOW);
    m_rbFollowMyDocs.ShowWindow (SW_SHOW);

    LONG index = pPage->m_iCurrChoice + pPage->m_iChoiceStart - IDS_CHILD_REDIR_START;
    if (bEnable &&
        pPage->m_fEnableMyPics &&
        pPage->m_fSettingModified [index])
    {
        m_grMyPics.EnableWindow ();
        m_rbFollowMyDocs.EnableWindow ();
        m_rbNoModify.EnableWindow ();

        if (m_fMyPicsValid)
        {
            m_rbFollowMyDocs.SetCheck (m_fMyPicsFollows ? 1 : 0);
            m_rbNoModify.SetCheck (m_fMyPicsFollows ? 0 : 1);
        }
        else    //set defaults as the setting
        {
            m_rbFollowMyDocs.SetCheck (1);
            m_rbNoModify.SetCheck (0);
            m_fMyPicsFollows = TRUE;
            m_fMyPicsValid = TRUE;
        }
    }
    else
    {
        m_grMyPics.EnableWindow (FALSE);

        //even when disabled, show the current status of My Pictures as far
        //as possible. The only situation when both the radio buttons should
        //be unchecked is when My Pics is getting redirected independently.

        m_rbFollowMyDocs.EnableWindow (FALSE);
        m_rbFollowMyDocs.SetCheck ((REDIR_FOLLOW_PARENT == pPage->m_dwMyPicsCurr) ? 1 : 0);

        m_rbNoModify.EnableWindow (FALSE);
        m_rbNoModify.SetCheck ((REDIR_DONT_CARE == pPage->m_dwMyPicsCurr) ? 1 : 0);
    }
}

void CRedirPref::EnableSettings (void)
{
    CRedirect * pPage = m_pFileInfo->m_pRedirPage;

    //the page is being enabled. If the settings had been modified earlier,
    //we need to make sure that the modified state indicates that.
    SetModified (m_fSettingsChanged);

    //enables applicable settings
    m_csTitle.EnableWindow (TRUE);

    if (IDS_STARTMENU == pPage->m_cookie)
    {
        m_cbMoveContents.EnableWindow (FALSE);
        m_cbMoveContents.SetCheck (0);

        m_cbApplySecurity.EnableWindow (FALSE);
        m_cbApplySecurity.SetCheck (0);
    }
    else
    {
        m_cbApplySecurity.EnableWindow ();
        m_cbMoveContents.EnableWindow ();
        if (pPage->m_fValidFlags)
        {
            m_cbApplySecurity.SetCheck ((pPage->m_dwFlags & REDIR_SETACLS)?1:0);
            m_cbMoveContents.SetCheck ((pPage->m_dwFlags & REDIR_MOVE_CONTENTS)? 1 : 0);
        }
        else
        {
            m_cbApplySecurity.SetCheck (1);
            m_cbMoveContents.SetCheck (1);
        }
    }

    m_grOrphan.EnableWindow ();
    m_rbOrphan.EnableWindow();
    m_rbRelocate.EnableWindow ();
    if (pPage->m_fValidFlags)
    {
        m_rbRelocate.SetCheck ((pPage->m_dwFlags & REDIR_RELOCATEONREMOVE)?1:0);
        m_rbOrphan.SetCheck ((pPage->m_dwFlags & REDIR_RELOCATEONREMOVE)?0:1);
    }
    else
    {
        m_rbOrphan.SetCheck (1);
        m_rbRelocate.SetCheck (0);
    }

    //enable my pics preferences for the My Docs folder
    EnableMyPicsSettings ();
    return;
}

void CRedirPref::OnModify()
{
    CRedirect * pPage = m_pFileInfo->m_pRedirPage;

    //modify the flags
    if (m_cbMoveContents.GetCheck())
        pPage->m_dwFlags |= REDIR_MOVE_CONTENTS;
    else
        pPage->m_dwFlags &= ~REDIR_MOVE_CONTENTS;

    if (m_cbApplySecurity.GetCheck())
        pPage->m_dwFlags |= REDIR_SETACLS;
    else
        pPage->m_dwFlags &= ~REDIR_SETACLS;

    if (m_rbRelocate.GetCheck())
        pPage->m_dwFlags |= REDIR_RELOCATEONREMOVE;
    else
        pPage->m_dwFlags &= ~REDIR_RELOCATEONREMOVE;

    //the flag now contains valid values
    pPage->m_fValidFlags = TRUE;

    DirtyPage (TRUE);
}

void CRedirPref::OnMyPicsChange()
{
    m_fMyPicsValid = TRUE;
    m_fMyPicsFollows = m_rbFollowMyDocs.GetCheck();

    DirtyPage(TRUE);
}

void CRedirPref::DirtyPage (BOOL fModified)
{
    m_fSettingsChanged = fModified;

    SetModified (fModified);
}

LONG CRedirPref::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_REDIRMETHOD);

    return lResult;
}

LONG CRedirPref::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_REDIRMETHOD);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\rsopinfo.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsopinfo.h
//
//  Contents:   Data for the RSOP mode result pane items
//
//  Classes:
//
//  Functions:
//
//  History:    03-16-2000   stevebl   Created
//
//---------------------------------------------------------------------------

class CRsopProp;

class CRSOPInfo
{
public:
    UINT        m_nPrecedence;
    CString     m_szPath;
    CString     m_szGroup;
    CString     m_szGPO;
    CString     m_szFolder;
    BOOL        m_fGrantType;
    BOOL        m_fMoveType;
    UINT        m_nPolicyRemoval;
    UINT        m_nInstallationType;
    CRsopProp *  m_pRsopProp;
    CRSOPInfo(){
        m_pRsopProp = NULL;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\redirect.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    redirect.cxx

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/24/1998

Revision History:

    4/24/1998   RahulTh
    7/16/1998   RahulTh     added calls to IGPEInformation::PolicyChanged()
    10/5/1998   RahulTh     massive changes for scaleability
    10/12/1998  RahulTh     added parameters for PolicyChanged

    Created this module.

--*/

#include "precomp.hxx"

//
// Guid of fdeploy client side GP extension
//

GUID guidExtension = {0x25537BA6, 0x77A8, 0x11D2, {0x9B, 0x6C, 0x00, 0x00, 0xF8,
                        0x08, 0x08, 0x61}};

//
//mapping between help ids and control ids for context sensitive help
//
const DWORD g_aHelpIDMap_IDD_REDIRECT[] =
{
    IDC_REDIR_ICON,         IDH_DISABLEHELP,
    IDC_REDIR_DESC,         IDH_DISABLEHELP,
    IDC_SETTING_TITLE,      IDH_DISABLEHELP,
    IDC_REDIR_CHOICE,       IDH_REDIR_CHOICE,
    IDC_SEL_DESC,           IDH_DISABLEHELP,
    IDC_STORE_GROUP,        IDH_DISABLEHELP,
    IDC_LIST_ADVANCED,      IDH_LIST_ADVANCED,
    IDC_BTNADD,             IDH_BTNADD,
    IDC_BTNEDIT,            IDH_BTNEDIT,
    IDC_BTNREMOVE,          IDH_BTNREMOVE,
    IDC_LIST_STRSIDS,       IDH_DISABLEHELP,
    0,                      0
};

CRedirect::CRedirect (UINT nID) : CPropertyPage (CRedirect::IDD), m_basicLocation (nID)
{
    m_szFolderName.Empty();
    m_ppThis = NULL;
    m_pScope = NULL;
    m_pFileInfo = NULL;
    m_cookie = nID;
    m_dwFlags = REDIR_DONT_CARE;
    m_iCurrChoice = 0;      // Be safe. initialize it to a valid value.
    m_fValidFlags = FALSE;
    m_fEnableMyPics = FALSE;
    m_dwMyPicsCurr = 0;     //the current status of MyPics -- don't care/follow my docs/independent redirection (= 0)

    //m_ppThis, m_pScope and m_pFileInfo are set immediately after creation in CScopePane routines
}

CRedirect::~CRedirect()
{
    //reset the pointer to this property page from its corresponding
    //CFileInfo object so that it know that it is gone.
    *m_ppThis = NULL;
}

BOOL CRedirect::OnApply ()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CError  error(this);
    UINT    errCode;
    int     count;
    int     i;
    LONG    iSel;
    CString Key;
    CString Val;
    CString szSuffix;
    UINT    pathType;
    CRedirPath newPath (m_cookie);
    BOOL    bShowMyPics = FALSE;
    BOOL    bMyPicsShouldFollow;
    CHourglass  hourGlass;  //this may take a while.
    GUID guidSnapin = CLSID_Snapin;
    CRedirPref * pSettings = m_pFileInfo->m_pSettingsPage;
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bPathChanged;
    BOOL    bStatus;

    //first check if it is necessary to go through the entire operation
    //maybe the Apply button has already been pressed and there is nothing
    //more to commit
    if (!m_fSettingModified [ m_iCurrChoice + m_iChoiceStart - IDS_CHILD_REDIR_START] &&
        !(pSettings->m_fSettingsChanged))
        return TRUE;

    m_pathChooser.OnRootKillFocus();

    //clear out the group+path info. in the associated fileinfo. object
    m_pFileInfo->DeleteAllItems();

    if (m_dwFlags & REDIR_DONT_CARE)
        goto OnApply_SaveChanges;

    if (m_dwFlags & REDIR_FOLLOW_PARENT)
        goto OnApply_SaveChanges;


    if (m_dwFlags & REDIR_SCALEABLE)
    {
        count = m_lstSavedStrSids.GetItemCount();

        for (i = 0; i < count; i++)
        {
            Key = m_lstSavedStrSids.GetItemText (i, 0); //the sid
            Val = m_lstSecGroups.GetItemText (i, 1);    //the path
            m_pFileInfo->Insert(Key, Val, FALSE, FALSE);
        }

        if (count) //does not makes sense to get the move contents flags if no sec/path pairs have been specified
            GetPrefFlags (&bMyPicsShouldFollow);
        else
            bMyPicsShouldFollow = FALSE;

        goto OnApply_SaveChanges;
    }

    // If we are here, it means that the basic option was chosen
    Key.LoadString (IDS_SID_EVERYONE);
    m_pathChooser.GetRoot (Val);
    pathType = m_pathChooser.GetType();

    // First check if the path has changed from what we started out with
    bPathChanged = m_basicLocation.IsPathDifferent (pathType, (LPCTSTR) Val);

    if (!bPathChanged)   // The path has not changed, so use the same one as before
    {
        m_basicLocation.GeneratePath (Val);
    }
    else
    {
        //
        // The path has changed, so generate the correct suffix
        //
        newPath.GenerateSuffix (szSuffix, m_cookie, pathType);
        bStatus = newPath.Load (pathType, (LPCTSTR) Val, (LPCTSTR) szSuffix);
        if (bStatus)
        {
            // Make sure that the path is not just a "*"
            newPath.GeneratePath (Val);
            if (TEXT("*") == Val)
                bStatus = FALSE;
        }

        if (!bStatus)
        {
            // The path in the edit location is invalid. Display an error message
            // Also make sure that the target tab is visible
            ((CPropertySheet *)GetParent())->SetActivePage(0);
            errCode = IDS_INVALID_PATH;
            goto OnApply_ReportError;
        }
    }

    //
    // If we are here, Val has the right path
    // If it is not the local userprofile path and it is not a UNC path
    // pop up a warning message -- if the path has changed.
    //
    if (bPathChanged &&
        pathType != IDS_USERPROFILE_PATH &&
        m_fSettingModified [m_iCurrChoice + m_iChoiceStart - IDS_CHILD_REDIR_START] &&
        ! PathIsUNC ((LPCTSTR) Val)
        )
    {
        //no point in popping up this warning if only the redirection
        //preference were changed but not the redirection path.

        //make sure that the target tab is visible
        ((CPropertySheet *)GetParent())->SetActivePage(0);

        //pop-up the warning message.
        error.SetStyle (MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
        error.SetTitle (IDS_DEFAULT_WARNING_TITLE);
        if (IDNO == error.ShowMessage (IDS_PATHNOTUNC_WARNING))
            goto OnApply_QuitWithoutApply;
    }

    // If we are here, we are ready to commit changes.
    m_pFileInfo->Insert (Key, Val, TRUE, FALSE);

    GetPrefFlags (&bMyPicsShouldFollow);

OnApply_SaveChanges:
    //copy the flags to the associated fileinfo. object
    //this cannot be done earlier since the value of the move contents
    //flag is only know for sure at this point
    //also we don't want to modify the flags on the fileinfo object
    //unless we are sure that there are no other errors.
    if (ERROR_SUCCESS != (dwError = CommitChanges(bMyPicsShouldFollow)))
    {
        error.SetError (dwError);
        errCode = IDS_SAVE_ERROR;
        goto OnApply_ReportError;
    }
    //else accept changes and move on

    iSel = m_iCurrChoice + m_iChoiceStart;
    if (IDS_NETWORK == iSel ||
        (IDS_SCALEABLE == iSel && m_lstSavedStrSids.GetItemCount()))
    {
        m_fValidFlags = TRUE;
    }
    else
    {
        m_fValidFlags = FALSE;
    }

    //this needs to be called so that the policy engine knows that
    //the policy has been modified
    if (m_pScope->m_pIGPEInformation)
        m_pScope->m_pIGPEInformation->PolicyChanged(FALSE, TRUE, &guidExtension, &guidSnapin);

    DirtyPage(FALSE);
    pSettings->DirtyPage (FALSE);
    return TRUE;

OnApply_ReportError:
    //set all message box parameters to be on the safe side. They might have been
    //modified by the warning message above.
    error.SetStyle (MB_OK | MB_ICONERROR);
    error.SetTitle (IDS_DEFAULT_ERROR_TITLE);
    error.ShowMessage (errCode);

OnApply_QuitWithoutApply:
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::GetPrefFlags
//
//  Synopsis:   this function finds out the values of the various flags
//              related to moving : REDIR_MOVE_CONTENTS and REDIR_APPLY_ACLS
//              also, in the My Docs case, it can be used to change the settings
//              on MyPics
//
//  Arguments:  [out] bMyPicsShouldFollow : on return, if this, this contains
//                       a value that indicates whether My Pics should be forced
//                       to follow My Docs.
//
//  Returns:    nothing
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:      if this is not My Documents, the value of bMyPicsShouldFollow
//              is not pertinent
//
//---------------------------------------------------------------------------
void CRedirect::GetPrefFlags (BOOL* bMyPicsShouldFollow)
{
    CString     szFormat;
    CString     szPrompt;
    CString     szTitle;
    int         retVal;
    CRedirPref * pSettings = m_pFileInfo->m_pSettingsPage;

    if (m_pFileInfo->m_bSettingsInitialized)
    {
        if (pSettings->m_cbMoveContents.GetCheck())
            m_dwFlags |= REDIR_MOVE_CONTENTS;
        else
            m_dwFlags &= ~REDIR_MOVE_CONTENTS;

        if (pSettings->m_rbRelocate.GetCheck())
            m_dwFlags |= REDIR_RELOCATEONREMOVE;
        else
            m_dwFlags &= ~REDIR_RELOCATEONREMOVE;

        if (pSettings->m_cbApplySecurity.GetCheck())
            m_dwFlags |= REDIR_SETACLS;
        else
            m_dwFlags &= ~REDIR_SETACLS;

        if (m_fEnableMyPics && pSettings->m_fMyPicsValid)
            *bMyPicsShouldFollow = pSettings->m_fMyPicsFollows;
        else
            *bMyPicsShouldFollow = FALSE;
    }
    else    //the settings page was never initialized
    {
        //so use the defaults if the current flags are not valid
        if (!m_fValidFlags)
        {
            m_dwFlags &= ~REDIR_RELOCATEONREMOVE;
            if (IDS_STARTMENU == m_cookie)
            {
                m_dwFlags &= ~REDIR_MOVE_CONTENTS;
                m_dwFlags &= ~REDIR_SETACLS;
            }
            else
            {
                m_dwFlags |= REDIR_MOVE_CONTENTS;
                m_dwFlags |= REDIR_SETACLS;
            }
        }

        //decide what to do with  the My Pics folder
        if (IDS_MYDOCS == m_cookie && m_fEnableMyPics)
            *bMyPicsShouldFollow = TRUE;
        else
            *bMyPicsShouldFollow = FALSE;
    }
}

void CRedirect::DoDataExchange (CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CRedirect)
    DDX_Control (pDX, IDC_REDIR_DESC, m_csRedirDesc);
    DDX_Control (pDX, IDC_STORE_GROUP, m_cbStoreGroup);
    DDX_Control (pDX, IDC_REDIR_CHOICE, m_cmbRedirChoice);
    DDX_Control (pDX, IDC_PATHS_PLACEHOLDER, m_placeHolder);
    DDX_Control (pDX, IDC_BTNADD, m_cbAdd);
    DDX_Control (pDX, IDC_BTNREMOVE, m_cbRemove);
    DDX_Control (pDX, IDC_BTNEDIT, m_cbEdit);
    DDX_Control (pDX, IDC_LIST_ADVANCED, m_lstSecGroups);
    DDX_Control (pDX, IDC_LIST_STRSIDS, m_lstSavedStrSids);
    DDX_Control (pDX, IDC_SEL_DESC, m_csSelDesc);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRedirect, CPropertyPage)
    //{{AFX_MSG_MAP(CRedirect)
    ON_BN_CLICKED(IDC_BTNADD, OnAdd)
    ON_BN_CLICKED(IDC_BTNREMOVE, OnRemove)
    ON_BN_CLICKED(IDC_BTNEDIT, OnEdit)
    ON_MESSAGE (WM_PATH_TWEAKED, OnPathTweak)
    ON_CBN_SELCHANGE (IDC_REDIR_CHOICE, OnRedirSelChange)
    ON_NOTIFY (LVN_ITEMCHANGED, IDC_LIST_ADVANCED, OnSecGroupItemChanged)
    ON_NOTIFY (NM_DBLCLK, IDC_LIST_ADVANCED, OnSecGroupDblClk)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////
//CRedirect Message Handlers

//on clicking the Add button
void CRedirect::OnAdd ()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    FIX_THREAD_STATE_MFC_BUG();

    CSecGroupPath   dlgSecPath(this, m_cookie, (LPCTSTR) m_szFolderName);
    LV_FINDINFO     lvfi;
    int             i;
    int             itemCount;
    CError          error (this);

    if (IDOK != dlgSecPath.DoModal())
        goto OnAdd_Quit;

    //OK was pressed. The group selection dialog itself validates the data,
    //so we don't have to do it here.
    lvfi.flags = LVFI_STRING;
    lvfi.psz = (LPCTSTR)dlgSecPath.m_szSidStr;

    i = m_lstSavedStrSids.FindItem (&lvfi);

    if (-1 != i)
    {
        error.ShowMessage (IDS_SECGROUP_EXISTS,
                           (LPCTSTR) dlgSecPath.m_szGroup);
        goto OnAdd_Quit;
    }

    itemCount = m_lstSecGroups.GetItemCount();
    m_lstSecGroups.InsertItem (itemCount, (LPCTSTR) dlgSecPath.m_szGroup, 1);
    m_lstSecGroups.SetItemText (itemCount, 1, (LPCTSTR) dlgSecPath.m_szTarget);
    m_lstSavedStrSids.InsertItem (itemCount, (LPCTSTR) dlgSecPath.m_szSidStr, 1);
    //we must enable the Settings page if this is the first group being
    //added. since it would have been disabled until now
    //note: item count is the count of items before the current item was added
    if (0 == itemCount)
        m_pFileInfo->m_pSettingsPage->EnablePage ();

    DirtyPage (TRUE);

OnAdd_Quit:
    return;
}

//on clicking the Edit button
void CRedirect::OnEdit ()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    FIX_THREAD_STATE_MFC_BUG();

    CString szGroup;
    CString szSidStr;
    CString szTarget;
    int     iSel;
    CError  error(this);
    int     iFind;
    LV_FINDINFO lvfi;

    //there will be exactly one selected item
    iSel = m_lstSecGroups.GetNextItem (-1, LVNI_ALL | LVNI_SELECTED);
    ASSERT (-1 != iSel); //some item has to be selected or this button cannot be clicked

    szGroup = m_lstSecGroups.GetItemText (iSel, 0);
    szSidStr = m_lstSavedStrSids.GetItemText (iSel, 0);
    szTarget = m_lstSecGroups.GetItemText (iSel, 1);

    CSecGroupPath dlgSecPath(this,
                             m_cookie,
                             (LPCTSTR) m_szFolderName,
                             (LPCTSTR)szGroup,
                             (LPCTSTR) szSidStr,
                             (LPCTSTR) szTarget
                             );

    if (IDOK != dlgSecPath.DoModal())
        goto OnEdit_Quit;

    szGroup = dlgSecPath.m_szGroup;
    szSidStr = dlgSecPath.m_szSidStr;
    szTarget = dlgSecPath.m_szTarget;

    //OK was pressed. The sec/group selection dialog itself validates the
    //data, so we don't have to do it here.
    lvfi.flags = LVFI_STRING;
    lvfi.psz = (LPCTSTR)szSidStr;

    iFind = m_lstSavedStrSids.FindItem (&lvfi);

    //now, if we find the sid for the group in another entry (i.e. not the one
    //we are editing, then we must print an error message and abort
    //otherwise we replace the entries with the new data
    if (iFind == iSel || -1 == iFind)
    {
        m_lstSavedStrSids.SetItemText (iSel, 0, (LPCTSTR)szSidStr);
        m_lstSecGroups.SetItemText (iSel, 0, (LPCTSTR) szGroup);
        m_lstSecGroups.SetItemText (iSel, 1, (LPCTSTR) szTarget);
        DirtyPage(TRUE);
    }
    else
    {
        error.ShowMessage (IDS_SECGROUP_EXISTS, (LPCTSTR) szGroup);
    }

OnEdit_Quit:
    return;
}

//on clicking the remove button
void CRedirect::OnRemove ()
{
    int i;

    if (0 == m_lstSecGroups.GetSelectedCount())
        return; //this will never happen since the remove button gets disabled
                //if nothing is selected.

    //get the index of the selected item -- there can be only 1 selected item
    i = m_lstSecGroups.GetNextItem (-1, LVNI_ALL | LVNI_SELECTED);
    m_lstSecGroups.DeleteItem (i);
    m_lstSavedStrSids.DeleteItem (i);   //need to keep the 2 lists in sync
    //we must disable the settings page if this deletion causes the item count
    //to go down to 0.
    if (0 == m_lstSecGroups.GetItemCount())
    {
        m_pFileInfo->m_pSettingsPage->EnablePage (FALSE);
    }
    else
    {
        //if there still are some items in the list, select the previous item
        //in the list or the first one, if we just deleted the first item
        //provided nothing else is already selected.
        if (0 == m_lstSecGroups.GetSelectedCount())
            m_lstSecGroups.SetItemState ((0 == i)?0:(i-1), LVIS_SELECTED,
                                            LVIS_SELECTED);
    }

    DirtyPage(TRUE);
}

void CRedirect::OnFollowParent()
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_dwFlags |= REDIR_FOLLOW_PARENT;
    m_pFileInfo->m_pSettingsPage->EnablePage (FALSE);

    SetPropSheetContents();
}

void CRedirect::OnScaleableLocation()
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_dwFlags |= REDIR_SCALEABLE;
    if (m_lstSecGroups.GetItemCount())
        m_pFileInfo->m_pSettingsPage->EnablePage ();
    else
        m_pFileInfo->m_pSettingsPage->EnablePage(FALSE);

    SetPropSheetContents();
}

void CRedirect::OnNetworkLocation()
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_pFileInfo->m_pSettingsPage->EnablePage ();

    SetPropSheetContents();
}

BOOL CRedirect::OnInitDialog()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CPropertyPage::OnInitDialog();

    CString szText;
    CString szFormat;
    RECT    rect;
    UINT    groupWidth;
    BOOL    fFocusSet;
    UINT    i;
    UINT    parentID;
    CString szParent;
    BOOL    bPathDiscarded = FALSE;
    BOOL    bStatus;
    CRedirPref * pSettings = m_pFileInfo->m_pSettingsPage;
    HRESULT hr;

    //change the style of the advanced list control so that the full row gets
    //selected instead of just the first column. note, we cannot specify this
    //style in the resource file because it is ignored if we specify it there
    //(probably because MFC expects a lower version of IE/NT than what Win2K has
    //and therefore the definition of this extended style is not recognized
    //when the resources are compiled.
    ListView_SetExtendedListViewStyle (m_lstSecGroups.m_hWnd, LVS_EX_FULLROWSELECT);
    //set the column headers for the list control
    //this must happen before the call to InitPrivates
    //otherwise the security group membership won't be displayed
    //correctly in the advanced settings
    m_lstSecGroups.GetClientRect (&rect);
    groupWidth = rect.right / 3;
    szText.LoadString (IDS_COL_GROUP);
    m_lstSecGroups.InsertColumn (0, (LPCTSTR) szText, LVCFMT_LEFT, groupWidth);
    szText.LoadString (IDS_COL_PATH);
    m_lstSecGroups.InsertColumn (1, (LPCTSTR) szText, LVCFMT_LEFT,
                                 rect.right - groupWidth);
    //put it in report view
    m_lstSecGroups.ModifyStyle (LVS_TYPEMASK, LVS_REPORT);

    //initialize the list control that is going to be used to save the string ids
    szText.LoadString (IDS_COL_GROUP);
    m_lstSavedStrSids.ShowWindow (SW_HIDE); //this is never visible
    m_lstSavedStrSids.InsertColumn (0, (LPCTSTR) szText, LVCFMT_LEFT, 200);

    //initialize the remaining private data members
    if (!InitPrivates(&bPathDiscarded))
    {
        // We could not load the data... just quit. The error messages
        // if any, have already been displayed at this point.
        ((CPropertySheet *) GetParent())->EndDialog(IDCANCEL);
        return TRUE;
    }

    //
    // If we are here, then if the policy had basic settings, m_basicLocation
    // already has the path info.
    //
    m_pathChooser.Instantiate (m_cookie,
                               this,
                               &m_placeHolder,
                               (const CRedirPath *) &m_basicLocation
                               );


    //set the text describing the dialog.
    szFormat.LoadString (IDS_REDIR_DESC);
    szText.Format ((LPCTSTR)szFormat, m_szFolderName);
    m_csRedirDesc.SetWindowText (szText);

    //now. populate the combo box based on the settings
    for (i = m_iChoiceStart; i < IDS_REDIR_END; i++)
    {
        if (IDS_FOLLOW_PARENT == i)
        {
            //get the resource id of the parent and also verify that it this folder
            //is a special descendant
            VERIFY (IsSpecialDescendant (m_cookie, &parentID));
            szFormat.LoadString (i);
            szParent.LoadString (parentID);
            szText.Format ((LPCTSTR)szFormat, (LPCTSTR) szParent);
        }
        else
        {
            szText.LoadString (i);
        }
        m_cmbRedirChoice.AddString ((LPCTSTR)szText);
    }

    fFocusSet = SetPropSheetContents();

    if ((IDS_SCALEABLE == (m_iCurrChoice + m_iChoiceStart)) &&
        m_lstSecGroups.GetItemCount())
    {
        m_fValidFlags = TRUE;
    }

    DirtyPage (FALSE);  //this ensures that we start out with a clean page
                        //and also that the m_fSettingModified is set correctly


    //we might have to display the My Pics preferences
    //so check if we need to display the controls specific to My Pictures
    //special case
    if (IDS_MYDOCS == m_cookie)
    {
        //
        // Load the my pics section to see its current settings
        // Also, the MyPics settings on the settings page should be enabled
        // only if the current settings for both MyDocs and MyPics are don't
        // care. Because if the settings for MyDocs are not don't care and
        // those of MyPics are, then it means that someone has already explicitly
        // made that choice. So we should not change the settings.
        //
        if (SUCCEEDED(hr = m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].LoadSection()) &&
            (m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags & REDIR_DONT_CARE))
        {
            m_fEnableMyPics = (m_pFileInfo->m_dwFlags & REDIR_DONT_CARE) ? TRUE : FALSE;
            m_dwMyPicsCurr = REDIR_DONT_CARE;
        }
        else if (SUCCEEDED(hr) &&
                 m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags & REDIR_FOLLOW_PARENT)
        {
            m_dwMyPicsCurr = REDIR_FOLLOW_PARENT;
        }
        else
            m_dwMyPicsCurr = 0;
    }

    //
    // If the existing path was discarded because it could not be parsed
    // then we have to indicate that the page is Dirty so that the OnApply
    // function won't be a no-op.
    // Note: The call to DirtyPage (FALSE) above is still necessary in order
    // to ensure that the m_fSettingModified array is setup correctly.
    //
    if (bPathDiscarded)
        DirtyPage (TRUE);

    return ! fFocusSet;    //return TRUE unless you set focus to a control
}


BOOL CRedirect::InitPrivates(BOOL * pbPathDiscarded)
{
    ASSERT (m_pFileInfo);
    ASSERT (m_ppThis);
    ASSERT (m_pScope);

    int     iRestrict;
    int     index;
    BOOL    fInRedirect;
    BOOL    bStatus = TRUE;

    SetFolderStatus();

    bStatus = RetrieveRedirInfo(pbPathDiscarded);

    if (!bStatus)
        return FALSE;

    m_szFolderName = m_pFileInfo->m_szDisplayname;

    if (m_dwFlags & REDIR_DONT_CARE)
    {
        m_iCurrChoice = IDS_DONT_CARE - m_iChoiceStart;
        m_fValidFlags = FALSE;
    }
    else if (m_dwFlags & REDIR_FOLLOW_PARENT)
    {
        m_iCurrChoice = IDS_FOLLOW_PARENT - m_iChoiceStart;
        m_fValidFlags = FALSE;
    }
    else if (m_dwFlags & REDIR_SCALEABLE)
    {
        m_iCurrChoice = IDS_SCALEABLE - m_iChoiceStart;
        m_fValidFlags = FALSE;  //set false for now... oninitdialog will do the rest
    }
    else    //it has to be basic settings now
    {
        m_iCurrChoice = IDS_NETWORK - m_iChoiceStart;
        m_fValidFlags = TRUE;
    }

    return TRUE;
}

void CRedirect::SetFolderStatus (void)
{
    switch (m_cookie)
    {
    case IDS_MYPICS:
        m_iChoiceStart = IDS_CHILD_REDIR_START;
        m_iDescStart = IDS_CHILD_SELDESC_START;
        break;
    case IDS_STARTMENU:
        m_iChoiceStart = IDS_REDIR_START;
        m_iDescStart = IDS_SELDESC_START;
        break;
    default:
        m_iChoiceStart = IDS_REDIR_START;
        m_iDescStart = IDS_SELDESC_START;
        break;
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::SetPropSheetContents
//
//  Synopsis:   this functions arranges/hides/shows/displays contents
//              on the property sheet based on the state of the internal
//              variables of the object
//
//  Arguments:  none
//
//  Returns:    TRUE : if it sets focus to an item in the dialog
//              FALSE: otherwise
//
//  History:    9/30/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CRedirect::SetPropSheetContents (void)
{
    CString szFormat;
    CString szText;
    CString szParent;
    UINT    parentID;
    int     nCmdShowBasic;
    int     nCmdShowAdvanced;
    int     nCmdShowGroupBox;
    UINT    GroupTitle;
    BOOL    fFocusSet = FALSE;
    BOOL    bParam;

    //first select the choice from the combo box
    m_cmbRedirChoice.SetCurSel (m_iCurrChoice);

    //hide or show other controls based on the current choice
    switch (m_iCurrChoice + m_iChoiceStart)
    {
    case IDS_FOLLOW_PARENT:
    case IDS_DONT_CARE:
        nCmdShowBasic = SW_HIDE;
        nCmdShowAdvanced = SW_HIDE;
        nCmdShowGroupBox = SW_HIDE;
        szText.Empty();
        break;
    case IDS_SCALEABLE:
        nCmdShowBasic = SW_HIDE;
        nCmdShowAdvanced = SW_SHOW;
        nCmdShowGroupBox = SW_SHOW;
        szText.LoadString (IDS_SECGROUP_DESC);
        break;
    default:
        nCmdShowBasic = SW_SHOW;
        nCmdShowAdvanced = SW_HIDE;
        nCmdShowGroupBox = SW_SHOW;
        szText.LoadString(IDS_TARGET_DESC);
        break;
    }

    m_cbStoreGroup.SetWindowText (szText);
    m_cbStoreGroup.ShowWindow (nCmdShowGroupBox);
    //
    // Adjust the height of the description control so that it occupies the
    // max. possible space and let us have nice descriptive and verbose messages
    // and thereby minimize user confusion.
    //
    // Note: This function must be called after setting the correct state for
    // the group box because this function adjusts its height based on whether
    // the group box is visible or not.
    //
    AdjustDescriptionControlHeight ();
    // Set the description
    szText.LoadString (m_iCurrChoice + m_iDescStart);
    m_csSelDesc.SetWindowText (szText);


    m_pathChooser.ShowWindow (nCmdShowBasic);

    m_cbAdd.ShowWindow (nCmdShowAdvanced);
    m_cbRemove.ShowWindow (nCmdShowAdvanced);
    m_cbEdit.ShowWindow (nCmdShowAdvanced);
    m_lstSecGroups.ShowWindow (nCmdShowAdvanced);

    if (SW_SHOW == nCmdShowAdvanced)
    {
        //select the first item if possible
        if (m_lstSecGroups.GetItemCount())
        {
            m_lstSecGroups.SetItemState (0, LVIS_SELECTED,
                                         LVIS_SELECTED);
        }
        OnSecGroupItemChanged (NULL, NULL);
    }

    return fFocusSet;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::OnDontCare
//
//  Synopsis:   the actions that are taken when someone clicks on the
//              "This policy doesn't care about the location of this folder"
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    8/3/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::OnDontCare (void)
{
    if (m_fValidFlags)
    {
        m_dwFlags &= (REDIR_MOVE_CONTENTS | REDIR_SETACLS | REDIR_RELOCATEONREMOVE);
    }
    else
        m_dwFlags = 0;

    m_dwFlags |= REDIR_DONT_CARE;
    m_pFileInfo->m_pSettingsPage->EnablePage (FALSE);

    SetPropSheetContents();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::OnRedirSelChange
//
//  Synopsis:   the handler for the CBN_SELCHANGE notification for the combo
//              box that is used to make the choice of redirection
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    8/4/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::OnRedirSelChange (void)
{
    int iSel;

    iSel = m_cmbRedirChoice.GetCurSel();

    if (iSel == m_iCurrChoice)  //the choice has not changed
        return;

    //the choice has changed, so update m_iCurrChoice
    m_iCurrChoice = iSel;

    switch (m_iCurrChoice + m_iChoiceStart)
    {
    case IDS_FOLLOW_PARENT:
        OnFollowParent ();
        break;
    case IDS_SCALEABLE:
        OnScaleableLocation();
        break;
    case IDS_NETWORK:
        OnNetworkLocation();
        break;
    case IDS_DONT_CARE:
        OnDontCare();
        break;
    default:
        break;
    }

    SetButtonEnableState();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::DirtyPage
//
//  Synopsis:   keeps track of whether the property page is dirty (has modified
//              data) or not. If the page is dirty, it also enables/disables the
//              apply button.
//
//  Arguments:  [in] fDataModified : TRUE/FALSE value
//
//  Returns:    nothing
//
//  History:    8/25/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::DirtyPage (BOOL fDataModified)
{
    if (!fDataModified)    //this is the tricky case. fDataModified is FALSE
    {                      //only if changes have been applied, or the dialog
                           //is being created. so all settings are affected.
        //first set all the defaults
        m_fSettingModified [IDS_FOLLOW_PARENT - IDS_CHILD_REDIR_START] = TRUE;

        m_fSettingModified [IDS_NETWORK - IDS_CHILD_REDIR_START] = TRUE;

        m_fSettingModified [IDS_SCALEABLE - IDS_CHILD_REDIR_START] = TRUE;

        m_fSettingModified [IDS_DONT_CARE - IDS_CHILD_REDIR_START] = TRUE;
    }

    //now modify the value for the selected setting
    m_fSettingModified [m_iCurrChoice + m_iChoiceStart - IDS_CHILD_REDIR_START]
                    = fDataModified;

    //enable or disable the various buttons based on this.
    SetButtonEnableState ();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::SetButtonEnableState
//
//  Synopsis:   enables or disables the OK & Apply buttons based on the
//              current modified value for the selected setting
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    10/14/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::SetButtonEnableState (void)
{
    BOOL    fMod;

    fMod = m_fSettingModified [ m_iCurrChoice + m_iChoiceStart
                                - IDS_CHILD_REDIR_START];

    SetModified (fMod);

    //uncomment the following line if you want the OK button to have the
    //same state as the Apply button. Needless to add that this would be
    //highly unconventional. requires careful consideration
    //((GetParent())->GetDescendantWindow (IDOK, FALSE))->EnableWindow (fMod);
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::RetrieveRedirInfo
//
//  Synopsis:   gets the redir info. stored in the corresponding CFileInfo
//              object and stores them in the control
//
//  Arguments:  [out] pbPathDiscarded : indicates if the current path
//                       was discarded because the stored path could not
//                       be parsed and the user chose to enter a new one.
//
//  Returns:    nothing
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CRedirect::RetrieveRedirInfo (BOOL * pbPathDiscarded)
{
    vector<CString>::iterator i;
    vector<CString>::iterator j;
    int count;
    int cx;
    CString szDir;
    CString szAcct;
    BOOL    bStatus = TRUE;
    CHourglass hourglass;   //LookupAccountSid takes a little while

    m_dwFlags = m_pFileInfo->m_dwFlags;

    if (m_dwFlags & REDIR_DONT_CARE)
        goto RetrieveRedirInfo_Quit;

    if (m_dwFlags & REDIR_FOLLOW_PARENT)
        goto RetrieveRedirInfo_Quit;

    if (m_dwFlags & REDIR_SCALEABLE)
    {
        m_lstSecGroups.DeleteAllItems();
        m_lstSavedStrSids.DeleteAllItems(); //keep it in sync. with m_lstSecGroups
        for (i = m_pFileInfo->m_RedirGroups.begin(), j = m_pFileInfo->m_RedirPaths.begin(), count = 0;
             i != m_pFileInfo->m_RedirGroups.end();
             i++, j++, count++)
        {
            //display the friendly name of the group represented by the sid
            if (STATUS_SUCCESS == GetFriendlyNameFromStringSid((LPCTSTR)(*i),
                                                               szDir,
                                                               szAcct))
            {
                if (!szDir.IsEmpty())
                    szAcct = szDir + '\\' + szAcct;
            }
            else    //just display the unfriendly string if the friendly name cannot be obtained
            {
                szAcct = (*i);
                szAcct.MakeUpper();
            }
            m_lstSecGroups.InsertItem (count, (LPCTSTR)szAcct, 1);   //we don't have any images
            //adjust the width of the column if required
            if ((cx = m_lstSecGroups.GetStringWidth ((LPCTSTR)szAcct)) >
                 m_lstSecGroups.GetColumnWidth (0))
            {
                m_lstSecGroups.SetColumnWidth (0, cx);
            }

            m_lstSecGroups.SetItemText (count, 1, (LPCTSTR) (*j));
            //adjust the width of the column if required
            if ((cx = m_lstSecGroups.GetStringWidth ((LPCTSTR)(*j))) >
                m_lstSecGroups.GetColumnWidth (1))
            {
                m_lstSecGroups.SetColumnWidth (1, cx);
            }

            //store the string representation of the sid in the control
            //will be handy when the contents of the dialog are written
            //back to the data structure. This won't be visible to anyone
            //this is just a means to hide away some useful info. in the control
            m_lstSavedStrSids.InsertItem (count, (LPCTSTR)(*i), 0);
        }

        goto RetrieveRedirInfo_Quit;
    }

    //
    // If we are here, this means that the Basic settings will be used
    // so just use the first path. The load will always succeed if the
    // path is not empty.
    //
    m_basicLocation.Load ((LPCTSTR) (*(m_pFileInfo->m_RedirPaths.begin())));

RetrieveRedirInfo_Quit:
    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::OnSecGroupItemChanged
//
//  Synopsis:   handler for LVN_ITEMCHANGED sent by the list control to the
//              dialog
//
//  Arguments:  standard : refer to the docs
//
//  Returns:    nothing
//
//  History:    9/30/1998  RahulTh  created
//
//  Notes:      this notification has to be handled since some of the buttons
//              need to be activated or deactivated based on whether something
//              in the list control has been selected or not
//
//---------------------------------------------------------------------------
void CRedirect::OnSecGroupItemChanged (LPNMLISTVIEW pNMListView, LRESULT* pResult)
{
    BOOL fEnable = FALSE;

    if (m_lstSecGroups.GetSelectedCount())
        fEnable = TRUE;

    m_cbRemove.EnableWindow (fEnable);
    m_cbEdit.EnableWindow (fEnable);

    if (pResult)
        *pResult = 0;
}

//+--------------------------------------------------------------------------
//
//  Member:     OnSecGroupDblClk
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    5/5/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirect::OnSecGroupDblClk (LPNMHDR pNMHdr, LRESULT* pResult)
{
    //do not try to edit if the double click happened in an area outside
    //the list of items.
    if (-1 != m_lstSecGroups.GetNextItem (-1, LVNI_ALL | LVNI_SELECTED))
        OnEdit();

    if (pResult)
        *pResult = 0;
}

//+--------------------------------------------------------------------------
//
//  Member:     CommitChanges
//
//  Synopsis:   commits the changes made through the property sheet to
//              the ini file on the sysvol
//
//  Arguments:  [in] bMyPicsFollows : indicates if My Pics should be forced
//                    to follow My Docs. For other folders, this value
//                    is ignored
//
//  Returns:    ERROR_SUCCESS : if changes were committed
//              otherwise error codes pointing to the case of the error are returned
//
//  History:    11/8/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CRedirect::CommitChanges (BOOL bMyPicsFollows)
{
    DWORD   dwAdd;
    DWORD   dwRemove;
    BOOL    bCommitDescendants = FALSE;
    DWORD   dwError = ERROR_SUCCESS;

    //first copy over the flags to the corresponding fileinfo object
    //the other members have already been populated appropriately
    //strip off extraneous flags for REDIR_DONT_CARE and REDIR_FOLLOW_PARENT
    if (REDIR_DONT_CARE & m_dwFlags)
        m_pFileInfo->m_dwFlags = REDIR_DONT_CARE;
    else if (REDIR_FOLLOW_PARENT & m_dwFlags)
        m_pFileInfo->m_dwFlags = REDIR_FOLLOW_PARENT;
    else
        m_pFileInfo->m_dwFlags = m_dwFlags;

    if (ERROR_SUCCESS != (dwError = m_pFileInfo->SaveSection()))
        return dwError;

    //do special tweaking for Start Menu and My Docs
    if (m_dwFlags & REDIR_DONT_CARE)
    {
        dwAdd = REDIR_DONT_CARE;
        dwRemove = REDIR_FOLLOW_PARENT;
        if (IDS_MYDOCS == m_cookie)
        {
            //for my docs, change my pics only if it was supposed to follow it
            //in the first place.
            if (m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags & REDIR_FOLLOW_PARENT)
                bCommitDescendants = TRUE;
        }
        else if (IDS_STARTMENU == m_cookie)
        {
            bCommitDescendants = TRUE;  //Start Menu, Programs and Startup are always together.
        }
        //other folders do not have descendants
    }
    else    //if the folder is getting redirected
    {
        dwAdd = REDIR_FOLLOW_PARENT;
        dwRemove = REDIR_DONT_CARE;
        if (IDS_MYDOCS == m_cookie)
            bCommitDescendants = bMyPicsFollows;
        else if (IDS_STARTMENU == m_cookie)
            bCommitDescendants = TRUE;
    }

    //now that we have all the info. commit the descendants if necessary
    if (bCommitDescendants)
    {
        if (IDS_MYDOCS == m_cookie)
        {
            //clean out the group + path info. for My Pictures
            m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].DeleteAllItems();
            //modify the flags
            m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags &= ~(dwRemove);
            m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].m_dwFlags |= dwAdd;
            //commit the changes
            if (ERROR_SUCCESS != (dwError = m_pFileInfo[IDS_MYPICS - IDS_MYDOCS].SaveSection()))
                return dwError;
            m_fEnableMyPics = (REDIR_FOLLOW_PARENT == dwAdd) ? FALSE : TRUE;
            m_dwMyPicsCurr = dwAdd;
        }
        else if (IDS_STARTMENU == m_cookie)
        {
            //modify the programs flags
            m_pFileInfo[IDS_PROGRAMS - IDS_STARTMENU].m_dwFlags &= ~(dwRemove);
            m_pFileInfo[IDS_PROGRAMS - IDS_STARTMENU].m_dwFlags |= dwAdd;
            //modify the startup flags
            m_pFileInfo[IDS_STARTUP - IDS_STARTMENU].m_dwFlags &= ~(dwRemove);
            m_pFileInfo[IDS_STARTUP - IDS_STARTMENU].m_dwFlags |= dwAdd;
            //commit the changes
            if (ERROR_SUCCESS != (dwError = m_pFileInfo[IDS_PROGRAMS - IDS_STARTMENU].SaveSection()))
                return dwError;

            if (ERROR_SUCCESS != (dwError = m_pFileInfo[IDS_STARTUP - IDS_STARTMENU].SaveSection()))
                return dwError;
        }
    }

    return ERROR_SUCCESS;
}

void CRedirect::OnPathTweak (WPARAM wParam, LPARAM lParam)
{
    DirtyPage (TRUE);
}


LONG CRedirect::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_REDIRECT);

    return lResult;
}

LONG CRedirect::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_REDIRECT);

    return lResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirect::AdjustDescriptionControlHeight
//
//  Synopsis:   Resizes the control that holds the description text for the
//              chosen option such that it occupies the maximum space possible.
//              Certain options like "Not Configured" require a lot more verbose
//              description to avoid user confusion and since these options
//              don't have anything below the option selection combo box besides
//              the description, it is possible to expand the description box
//              to occupy the entire space. We do this based on whether the
//              group box underneath it is visible or not and use the 
//              co-ordinates of the group box for resizing.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    4/21/2001  RahulTh  created
//
//  Notes:      In order for this function to be effective, it must be invoked
//              after the group box is set to its correct state, i.e., visible
//              or hidden.      
//
//---------------------------------------------------------------------------
void CRedirect::AdjustDescriptionControlHeight (void)
{
    RECT    rcDesc;         // The rect. for the description control.
    RECT    rcGroupBox;     // The rect. for the group box.
    LONG    bottom;
    
    m_csSelDesc.GetWindowRect(&rcDesc);
    m_cbStoreGroup.GetWindowRect(&rcGroupBox);
    
    bottom = m_cbStoreGroup.IsWindowVisible() ? 
        rcGroupBox.top - 6 :    // if the group box is visible. Make the description window smaller.
        rcGroupBox.bottom;      // otherwise make it bigger.
    
    // Adjust the height of the description control.
    m_csSelDesc.SetWindowPos(NULL, 
                               -1, 
                               -1, 
                               rcDesc.right - rcDesc.left, 
                               bottom - rcDesc.top, 
                               SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOZORDER
                               );
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by filedep.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NODENAME                    2
#define IDS_FIRST_COL                   3
#define IDS_NAME                        3
#define IDS_TYPE                        4
#define IDS_LAST_COL                    5
#define IDS_SNAPIN_NAME					6
#define IDS_FOLDER_TYPE                 10
#define IDS_FIRST_RSOP_COL              20
#define IDS_PRECEDENCE                  20
#define IDS_REDIRECTEDPATH              21
#define IDS_GROUP                       22
#define IDS_GPO                         23
#define IDS_INSTALLATIONTYPE            24
#define IDS_EXCLUSIVE                   25
#define IDS_MOVE                        26
#define IDS_POLICYREMOVAL               27
#define IDS_LAST_RSOP_COL               28
#define IDS_FOLDER_TITLE                100
#define IDS_FOLDERBROWSE_DESC           109
#define IDS_MOVECONTENTS_TITLE          112
#define IDS_MOVECONTENTS_CONFIRM        113
#define IDS_INIFILE                     114
#define IDS_MYPICS_RELPATH              115
#define IDS_PROGRAMS_RELPATH            116
#define IDS_STARTUP_RELPATH             117
#define IDS_REDIR_DESC                  118
#define IDS_TARGET_DESC                 119
#define IDS_SECGROUP_DESC               120
#define IDS_COL_GROUP                   121
#define IDS_COL_PATH                    122
#define IDS_OBJPICK_ERROR               123
#define IDS_SID_EVERYONE                124
#define IDS_HELP_FILE                   125
#define IDS_DEFAULT_ERROR               200
#define IDS_DEFAULT_ERROR_TITLE         201
#define IDS_DEFAULT_WARNING_TITLE       202
#define IDS_NOSECURITY_INFO             203
#define IDS_INVALID_GROUPPATH           204
#define IDS_SECGROUP_EXISTS             205
#define IDS_SAVE_ERROR                  206
#define IDS_INVALID_PATH                207
#define IDS_SECTIONLOAD_ERROR           208
#define IDS_PATHTOOLONG_ERROR           209
#define IDS_PATHNOTUNC_WARNING          210
#define IDS_CHILD_REDIR_START           302
#define IDS_FOLLOW_PARENT               302
#define IDS_REDIR_START                 303
#define IDS_NETWORK                     303
#define IDS_SCALEABLE                   304
#define IDS_DONT_CARE                   305
#define IDS_REDIR_END                   306
#define IDS_CHILD_SELDESC_START         307
#define IDS_FOLLOWPARENT_DESC           307
#define IDS_SELDESC_START               308
#define IDS_NETWORK_DESC                308
#define IDS_SCALEABLE_DESC              309
#define IDS_DONTCARE_DESC               310
#define IDS_SELDESC_END                 311
#define IDI_FOLDER                      400
#define IDI_SNAPIN                      401
#define IDB_16x16                       500
#define IDB_32x32                       501
#define IDS_DIRS_START                  602
#define IDS_LEVEL1_DIRS_START           602
#define IDS_APPDATA                     602
#define IDS_DESKTOP                     603
#define IDS_MYDOCS                      604
#define IDS_STARTMENU                   605
#define IDS_LEVEL1_DIRS_END             606
#define IDS_LEVEL2_DIRS_START           606
#define IDS_MYPICS                      606
#define IDS_PROGRAMS                    607
#define IDS_LEVEL2_DIRS_END             608
#define IDS_LEVEL3_DIRS_START           608
#define IDS_STARTUP                     608
#define IDS_LEVEL3_DIRS_END             609
#define IDS_DIRS_END                    609
#define IDS_PREF_TITLE                  700
#define IDS_PREF_APPLYSECURITY          701
#define IDS_PREF_MOVE                   702
#define IDS_MYDOCS_DESTTYPE_START       801
#define IDS_HOMEDIR_PATH                801
#define IDS_DESTTYPE_START              802
#define IDS_PERUSER_PATH                802
#define IDS_SMENU_DESTTYPE_START        803
#define IDS_SPECIFIC_PATH               803
#define IDS_USERPROFILE_PATH            804
#define IDS_DESTTYPE_END                805
#define IDS_SETTINGS                    900
#define IDS_SETTING_BASIC               901
#define IDS_SETTING_MAXIMUM             902
#define IDS_NO                          903
#define IDS_YES                         904
#define IDS_ONPOLICYREMOVAL             904
#define IDS_LEAVE                       905
#define IDS_REDIRECT                    906
#define IDS_SAMPLE_USER                 907
#define IDS_SAMPLE_PATHDESC             908
#define IDS_HOMEDIR_WARNING				909
#define IDD_SECPATH                     1007
#define IDD_REDIRMETHOD                 1010
#define IDD_PATHCHOOSER                 1011
#define IDC_REDIR_ICON                  5002
#define IDC_REDIR_DESC                  5003
#define IDC_STORE_GROUP                 5004
#define IDC_REDIR_CHOICE                5032
#define IDC_SEL_DESC                    5034
#define IDC_SETTING_TITLE               5035
#define IDC_BTNADD                      5037
#define IDC_BTNEDIT                     5038
#define IDC_BTNREMOVE                   5039
#define IDC_LIST_ADVANCED               5040
#define IDC_LIST_STRSIDS                5042
#define IDC_SECPATH_DESC                5043
#define IDC_SECPATH_ICON                5044
#define IDC_SECPATH_SECGROUP            5045
#define IDC_SECPATH_TARGET              5046
#define IDC_EDIT_SECGROUP               5047
#define IDC_BROWSE_SECGROUP             5048
#define IDC_PREF_ICON                   5055
#define IDC_PREF_TITLE                  5056
#define IDC_PREF_MOVE                   5057
#define IDC_PREF_APPLYSECURITY          5058
#define IDC_PREF_CHANGEMYPICS           5061
#define IDC_PREF_LEAVEMYPICS            5062
#define IDC_PREF_MYPICS_GROUP           5063
#define IDC_PREF_ORPHAN                 5064
#define IDC_GROUP_ORPHAN                5065
#define IDC_PREF_RELOCATE               5067
#define IDC_SECPATH_PLACEHOLDER         5072
#define IDC_PATHS_PLACEHOLDER           5073
#define IDC_DESTTYPE                    5074
#define IDC_ROOT_DESC                   5075
#define IDC_ROOT_PATH                   5076
#define IDC_BROWSE                      5077
#define IDC_SAMPLE_PATH                 5078
#define IDC_GROUP                       5079
#define IDC_GPO                         5080
#define IDC_SETTING                     5081
#define IDC_PATH                        5082
#define IDD_REDIRECT                    6001
#define IDD_RSOP                        6002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1012
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         5083
#define _APS_NEXT_SYMED_VALUE           6002
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\rsopprop.h ===
#if !defined(AFX_RSOPPROP_H__3C51B0A8_A590_4188_9A66_3816BE138A7A__INCLUDED_)
#define AFX_RSOPPROP_H__3C51B0A8_A590_4188_9A66_3816BE138A7A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// rsopprop.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// rsopprop dialog

class CRSOPInfo;

class CRsopProp : public CPropertyPage
{
    DECLARE_DYNCREATE(CRsopProp)

// Construction
public:
    CRsopProp();
    ~CRsopProp();

    CRsopProp ** m_ppThis;
    CRSOPInfo * m_pInfo;

// Dialog Data
    //{{AFX_DATA(CRsopProp)
    enum { IDD = IDD_RSOP };
    CString m_szGroup;
    CString m_szGPO;
    CString m_szPath;
    CString m_szSetting;
    CString m_szFolder;
    BOOL    m_fMove;
    BOOL    m_fApplySecurity;
    int     m_iRemoval;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsopProp)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CRsopProp)
        // NOTE: the ClassWizard will add member functions here
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RSOPPROP_H__3C51B0A8_A590_4188_9A66_3816BE138A7A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\rsoputil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.cpp
//
//  Contents:   helper functions for working with the RSOP databases
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <wbemcli.h>
#include "rsoputil.h"
// Something in the build environment is causing this
// to be #defined to a version before 0x0500 and
// that causes the ConvertStringSecurityDescriptor... function
// to be undefined.
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#include "sddl.h"

//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(szData);
    hr = pInst->Put(szParam, 0, &var, 0);
    SysFreeString(var.bstrVal);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        delete szData;
        szData = NULL;
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            szData = (TCHAR *) OLEALLOC(sizeof(TCHAR) * (_tcslen(var.bstrVal) + 1));
            if (szData)
            {
                _tcscpy(szData, var.bstrVal);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (szData)
    {
        szData = "";
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        if (var.bstrVal)
        {
            szData = var.bstrVal;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    if (bstrData)
    {
        SysFreeString(bstrData);
    }
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        bstrData = SysAllocStringLen(var.bstrVal, SysStringLen(var.bstrVal));
        if (NULL == bstrData)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        fData = var.bVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        hrData = (HRESULT) var.lVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ulData = var.ulVal;
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid)
{
    TCHAR * sz = NULL;
    memset(&guid, 0, sizeof(GUID));
    HRESULT hr = GetParameter(pInst, szParam, sz);
    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromString(sz, &guid);
    }
    if (sz)
    {
        OLESAFE_DELETE(sz);
    }
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    ui = 0;
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        ui = (HRESULT) var.uiVal;
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of guids and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, GUID * &rgGuid)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgGuid = (GUID *)OLEALLOC(sizeof(GUID) * uiCount);
            if (rgGuid)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    hr = CLSIDFromString(rgData[ui], &rgGuid[ui]);
                    if (FAILED(hr))
                    {
                        return hr;
                    }
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

// array variation - gets an array of strings and a count
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR *szParam, UINT &uiCount, TCHAR ** &rgszData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt == (VT_ARRAY | VT_BSTR))
    {
        // build the array
        SAFEARRAY * parray = var.parray;
        uiCount = parray->rgsabound[0].cElements;
        if (uiCount > 0)
        {
            rgszData = (TCHAR **)OLEALLOC(sizeof(TCHAR *) * uiCount);
            if (rgszData)
            {
                BSTR * rgData = (BSTR *)parray->pvData;
                UINT ui = uiCount;
                while (ui--)
                {
                    OLESAFE_COPYSTRING(rgszData[ui], rgData[ui]);
                }
            }
            else
            {
                uiCount = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd)
{
    VARIANT var;
    HRESULT hr = S_OK;
    if (psd)
    {
        LocalFree(psd);
        psd = NULL;
    }
    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr) && var.vt != VT_NULL)
    {
        PSECURITY_DESCRIPTOR psdTemp;
        BOOL f = ConvertStringSecurityDescriptorToSecurityDescriptor(
                    var.bstrVal,
                    //(LPCTSTR)var.parray->pvData,
                    SDDL_REVISION_1,
                    &psd,
                    NULL);
        if (!f)
        {
            // it failed
            // could call GetLastError here to figure out why
            // but at the moment I don't really care
        }
        if (!IsValidSecurityDescriptor(psd))
        {
            LocalFree(psd);
            psd = NULL;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID, BSTR pLanguage,
                           LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));

    if (!lpQuery)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);


    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Save the name
    //

    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        goto Exit;
    }

    lstrcpy (*pGPOName, varGPOName.bstrVal);

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\scope.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scope.cpp
//
//  Contents:   implementation of the scope pane
//
//  Classes:    CScopePane
//
//  History:    03-14-1998   stevebl   Created
//              07-16-1998   rahulth   Added calls to IGPEInformation::PolicyChanged
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include <shlobj.h>
#include <winnetwk.h>

// Comment this line to stop trying to set the main snapin icon in the
// scope pane.
#define SET_SCOPE_ICONS 1


// Un-comment the next line to persist snap-in related data.  (This really
// shouldn't be necessary since I get all my info from my parent anyway.)
// #define PERSIST_DATA 1

///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CScopePane);

CScopePane::CScopePane()
{
    HKEY hKey;
    DWORD dwDisp;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopePane);

    m_bIsDirty = FALSE;

    m_fRSOP = FALSE;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_pIPropertySheetProvider = NULL;
    m_fLoaded = FALSE;
    m_fExtension = FALSE;
    m_pIGPEInformation = NULL;
    m_pIRSOPInformation = NULL;
}

CScopePane::~CScopePane()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopePane);
    ASSERT(m_pScope == NULL);
    ASSERT(CResultPane::lDataObjectRefCount == 0);
}
#include <msi.h>

//+--------------------------------------------------------------------------
//
//  Member:     CScopePane::CreateNestedDirectory
//
//  Synopsis:   Ensures the existance of a path.  If any directory along the
//              path doesn't exist, this routine will create it.
//
//  Arguments:  [lpDirectory]          - path to the leaf directory
//              [lpSecurityAttributes] - security attributes
//
//  Returns:    1 on success
//              0 on failure
//
//  History:    3-17-1998   stevebl     Copied from ADE
//
//  Notes:      Originally written by EricFlo
//
//---------------------------------------------------------------------------

UINT CScopePane::CreateNestedDirectory (LPTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        SetLastError(ERROR_INVALID_DATA);
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    return 0;

}

STDMETHODIMP CScopePane::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pScope));
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IPropertySheetProvider,
                        (void **)&m_pIPropertySheetProvider);

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryInterface (IID_IDisplayHelp, reinterpret_cast<void**>(&m_pDisplayHelp));
    ASSERT(hr == S_OK);

#ifdef SET_SCOPE_ICONS
    LPIMAGELIST lpScopeImage;
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(hr == S_OK);

    // Load the bitmaps from the dll
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));
    lpScopeImage->Release();
#endif
    return S_OK;
}

STDMETHODIMP CScopePane::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CResultPane>* pObject;
    CComObject<CResultPane>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    m_pResultPane = pObject;


    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CScopePane::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;
    UINT    i;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        // perform any action needed as a result of result property changes
        hr = OnProperties(param);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
        MMC_COOKIE cookie = 0;
        if (pInternal != NULL)
        {
            cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
        }
        else
        {
            // only way we could not be able to extract our own format is if we're operating as an extension
            m_fExtension = TRUE;
        }

        if (m_fRSOP)
        {
            WCHAR szBuffer[MAX_DS_PATH];
            if (m_pIRSOPInformation == NULL)
            {
                IRSOPInformation * pIRSOPInformation;
                hr = lpDataObject->QueryInterface(IID_IRSOPInformation,
                                reinterpret_cast<void**>(&pIRSOPInformation));
                if (SUCCEEDED(hr))
                {
                    m_pIRSOPInformation = pIRSOPInformation;
                    m_pIRSOPInformation->AddRef();
                    /*  extract the namespace here */
                    hr = m_pIRSOPInformation->GetNamespace(GPO_SECTION_USER, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]));
                    if (SUCCEEDED(hr))
                    {
                        m_szRSOPNamespace = szBuffer;
                    }
                    pIRSOPInformation->Release();
                }
            }
        }
        else
        {
            if (m_pIGPEInformation == NULL)
            {
                IGPEInformation * pIGPEInformation;
                hr = lpDataObject->QueryInterface(IID_IGPEInformation,
                                reinterpret_cast<void**>(&pIGPEInformation));
                if (SUCCEEDED(hr))
                {
                    GROUP_POLICY_OBJECT_TYPE gpoType;
                    hr = pIGPEInformation->GetType(&gpoType);
                    if (SUCCEEDED(hr))
                    {
                        if (gpoType == GPOTypeDS)
                        {
                            WCHAR szBuffer[MAX_PATH];
                            do
                            {
                                AFX_MANAGE_STATE (AfxGetStaticModuleState());
                                hr = pIGPEInformation->GetFileSysPath(GPO_SECTION_USER, szBuffer, MAX_PATH);
                                if (FAILED(hr))
                                    break;

                                m_pIGPEInformation = pIGPEInformation;
                                m_pIGPEInformation->AddRef();
                                m_szFileRoot = szBuffer;
                                m_szFileRoot += L"\\Documents & Settings";
                                CreateNestedDirectory (((LPOLESTR)(LPCOLESTR)(m_szFileRoot)), NULL);

                                //initialize the folder data.
                                for (i = IDS_DIRS_START; i < IDS_DIRS_END; i++)
                                {
                                    m_FolderData[GETINDEX(i)].Initialize (i,
                                                                          (LPCTSTR) m_szFileRoot);
                                }

                                ConvertOldStyleSection (m_szFileRoot);
                            } while (0);
                        }
                        else
                        {
                            // force this to fail
                            hr = E_FAIL;
                        }
                    }
                    pIGPEInformation->Release();
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            switch(event)
            {
            case MMCN_EXPAND:
                {
                    hr = OnExpand(cookie, arg, param);
                }
                break;

            case MMCN_SELECT:
                hr = OnSelect(cookie, arg, param);
                break;

            case MMCN_CONTEXTMENU:
                hr = OnContextMenu(cookie, arg, param);
                break;

            default:
                //perform the default action
                hr = S_FALSE;
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CScopePane::Destroy()
{
    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pDisplayHelp);
    SAFE_RELEASE(m_pConsole);
    SAFE_RELEASE(m_pIPropertySheetProvider);
    SAFE_RELEASE(m_pIGPEInformation);
    SAFE_RELEASE(m_pIRSOPInformation);

    return S_OK;
}

STDMETHODIMP CScopePane::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    CComObject<CDataObject>* pObject = NULL;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    if (!pObject)
        return E_UNEXPECTED;

    // Save cookie and type for delayed rendering
    pObject->SetID (m_FolderData[GETINDEX(cookie)].m_scopeID);
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStreamInit interface members

STDMETHODIMP CScopePane::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return S_OK;
}

STDMETHODIMP CScopePane::IsDirty()
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CScopePane::Load(IStream *pStm)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // UNDONE - Read data from the stream here.
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
#else
    return S_OK;
#endif
}

STDMETHODIMP CScopePane::Save(IStream *pStm, BOOL fClearDirty)
{
#ifdef PERSIST_DATA
    ASSERT(pStm);

    // UNDONE - Write data to the stream here.
    // on error, return STG_E_CANTSAVE;
#endif
    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CScopePane::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    // UNDONE - set the size of the string to be saved
    ULONG cb = 0;
    // Set the size of the string to be saved
    ULISet32(*pcbSize, cb);

    return S_OK;
}

STDMETHODIMP CScopePane::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CScopePane::OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}


HRESULT CScopePane::OnExpand(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == TRUE)    //MMC never sends arg = FALSE (for collapse)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(cookie,
                           param);
    }

    return S_OK;
}

HRESULT CScopePane::OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}

HRESULT CScopePane::OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CScopePane::OnProperties(LPARAM param)
{
    if (param == NULL)
    {
        return S_OK;
    }

    ASSERT(param != NULL);

    return S_OK;
}


void CScopePane::EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString szFullPathname;
    CString szParent;
    SCOPEDATAITEM scopeItem;
    FILETIME ftCurr;
    LONG i;
    int     cChildren = 0;
    DWORD   myDocsFlags = REDIR_DONT_CARE;
    DWORD   myPicsFlags = REDIR_DONT_CARE;

    memset(&scopeItem, 0, sizeof(SCOPEDATAITEM));

    CHourglass hourglass;   //this may take some time, so put up an hourglass

    GetSystemTimeAsFileTime (&ftCurr);

    //set the common members for the scope pane items
    scopeItem.mask = SDI_STR | SDI_PARAM | SDI_CHILDREN;
    #ifdef SET_SCOPE_ICONS
    scopeItem.mask |= SDI_IMAGE | SDI_OPENIMAGE;
    scopeItem.nImage = IMG_CLOSEDBOX;
    scopeItem.nOpenImage = IMG_OPENBOX;
    #endif
    scopeItem.relativeID = pParent;
    scopeItem.displayname = MMC_CALLBACK;

    if (m_fExtension)
    {
        switch(cookie)
        {
        case NULL:  //getting the folder
        // if we're an extension then add a root folder to hang everything off of
            if (m_fRSOP)
            {
                // make sure that nodes don't get enumerated if they contain no data
                if (FAILED(m_pResultPane->TestForRSOPData(cookie)))
                {
                    return;
                }
            }
            scopeItem.lParam = IDS_FOLDER_TITLE;    //use resource id's as cookies
            scopeItem.cChildren = 1;
            m_pScope->InsertItem(&scopeItem);
            break;
        case IDS_FOLDER_TITLE:
            for (i = IDS_LEVEL1_DIRS_START; i < IDS_LEVEL1_DIRS_END; i++)
            {
                BOOL fInsert = TRUE;
                if (m_fRSOP)
                {
                    if (FAILED(m_pResultPane->TestForRSOPData(i)))
                    {
                        fInsert = FALSE;
                    }
                }
                if (fInsert)
                {
                    scopeItem.lParam = i;
                    m_FolderData[GETINDEX(i)].Initialize(i,
                                                         (LPCTSTR) m_szFileRoot
                                                         );
                    if (i == IDS_MYDOCS && !m_fRSOP)
                    {
                        //
                        // Show the My Pictures folder only if it does not follow MyDocs.
                        // and only if there is no registry setting overriding the hiding behavior
                        // for My Pics
                        //
                        if (AlwaysShowMyPicsNode())
                        {
                            cChildren = 1;
                            m_FolderData[GETINDEX(i)].m_bHideChildren = FALSE;
                        }
                        else
                        {
                            m_FolderData[GETINDEX(IDS_MYPICS)].Initialize(IDS_MYPICS,
                                                                          (LPCTSTR) m_szFileRoot
                                                                          );
                            m_FolderData[GETINDEX(i)].LoadSection();
                            m_FolderData[GETINDEX(IDS_MYPICS)].LoadSection();
                            myDocsFlags = m_FolderData[GETINDEX(i)].m_dwFlags;
                            myPicsFlags = m_FolderData[GETINDEX(IDS_MYPICS)].m_dwFlags;
                            if (((REDIR_DONT_CARE & myDocsFlags) && (REDIR_DONT_CARE & myPicsFlags)) ||
                                ((REDIR_FOLLOW_PARENT & myPicsFlags) && (!(REDIR_DONT_CARE & myDocsFlags)))
                                )
                            {
                                cChildren = 0;
                                m_FolderData[GETINDEX(i)].m_bHideChildren = TRUE;
                            }
                            else
                            {
                                cChildren = 1;
                                m_FolderData[GETINDEX(i)].m_bHideChildren = FALSE;
                            }
                        }
                    }
                    scopeItem.cChildren = cChildren;    //only My Docs will possibly have children
                    m_pScope->InsertItem(&scopeItem);
                    m_FolderData[GETINDEX(i)].SetScopeItemID(scopeItem.ID);
                }
                if (IDS_MYDOCS == i && m_fRSOP  && SUCCEEDED(m_pResultPane->TestForRSOPData(IDS_MYPICS)))
                {
                    // In RSOP mode we put My Pictures after My Documents
                    // instead of under it.  Otherwise the results pane
                    // for My Documents would contain a folder along with
                    // the data and it would look very odd.
                    scopeItem.lParam = IDS_MYPICS;
                    scopeItem.cChildren = 0;
                    m_pScope->InsertItem(&scopeItem);
                    m_FolderData[GETINDEX(IDS_MYPICS)].Initialize (IDS_MYPICS,
                                                                   (LPCTSTR) m_szFileRoot
                                                                   );
                    m_FolderData[GETINDEX(IDS_MYPICS)].SetScopeItemID(scopeItem.ID);
                }
            }
            break;
        case IDS_MYDOCS:    //of all levels 1 folder, only MyDocs has children
            if (!m_fRSOP && !(m_FolderData[GETINDEX(IDS_MYDOCS)].m_bHideChildren))
            {
                scopeItem.lParam = IDS_MYPICS;
                scopeItem.cChildren = 0;
                m_pScope->InsertItem(&scopeItem);
                m_FolderData[GETINDEX(IDS_MYPICS)].Initialize (IDS_MYPICS,
                                                               (LPCTSTR) m_szFileRoot
                                                               );
                m_FolderData[GETINDEX(IDS_MYPICS)].SetScopeItemID(scopeItem.ID);
            }
            break;
        }
    }
}


STDMETHODIMP CScopePane::GetSnapinDescription(LPOLESTR * lpDescription)
{
    // UNDONE
    OLESAFE_COPYSTRING(*lpDescription, L"description");
    return S_OK;
}

STDMETHODIMP CScopePane::GetProvider(LPOLESTR * lpName)
{
    // UNDONE
    OLESAFE_COPYSTRING(*lpName, L"provider");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinVersion(LPOLESTR * lpVersion)
{
    // UNDONE
    OLESAFE_COPYSTRING(*lpVersion, L"version");
    return S_OK;
}

STDMETHODIMP CScopePane::GetSnapinImage(HICON * hAppIcon)
{
    // UNDONE
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetStaticFolderImage(HBITMAP * hSmallImage,
                             HBITMAP * hSmallImageOpen,
                             HBITMAP * hLargeImage,
                             COLORREF * cMask)
{
    // UNDONE
    return E_NOTIMPL;
}

STDMETHODIMP CScopePane::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DbgMsg((TEXT("CScopePane::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gpedit.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}

STDMETHODIMP CScopePane::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LONG i;
    ASSERT(pScopeDataItem != NULL);

    if (pScopeDataItem == NULL)
        return E_POINTER;

    if (IDS_FOLDER_TITLE == pScopeDataItem->lParam)
    {
        m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
    }
    else
    {
        pScopeDataItem->displayname = L"???";
        if (-1 != (i = GETINDEX(pScopeDataItem->lParam)))
            pScopeDataItem->displayname = (unsigned short*)((LPCOLESTR)(m_FolderData[i].m_szDisplayname));
    }

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CScopePane::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

// Scope item property pages:
STDMETHODIMP CScopePane::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    
    if (! pInternal)
        return S_FALSE;

    DWORD   cookie = pInternal->m_cookie;
    LONG    i;
    BOOL    fShowPage = FALSE;
    AFX_OLDPROPSHEETPAGE * pPsp;
    AFX_OLDPROPSHEETPAGE * pPspSettings;
    CFileInfo* pFileInfo;

    //it is one of the folders
    i = GETINDEX (cookie);
    pFileInfo = &(m_FolderData[i]);

    if (!pFileInfo->m_pRedirPage)   //make sure that the property page is not already up.
    {
        pFileInfo->m_pRedirPage = new CRedirect(cookie);
        pFileInfo->m_pRedirPage->m_ppThis = &(pFileInfo->m_pRedirPage);
        pFileInfo->m_pRedirPage->m_pScope = this;
        pFileInfo->m_pRedirPage->m_pFileInfo = pFileInfo;
        fShowPage = TRUE;
        pPsp = (AFX_OLDPROPSHEETPAGE *)&(pFileInfo->m_pRedirPage->m_psp);
        //create the settings page;
        pFileInfo->m_pSettingsPage = new CRedirPref();
        pFileInfo->m_pSettingsPage->m_ppThis = &(pFileInfo->m_pSettingsPage);
        pFileInfo->m_pSettingsPage->m_pFileInfo = pFileInfo;
        pPspSettings = (AFX_OLDPROPSHEETPAGE *)&(pFileInfo->m_pSettingsPage->m_psp);
    }

    if (fShowPage)  //show page if it is not already up.
    {
        hr = SetPropPageToDeleteOnClose (pPsp);
        if (SUCCEEDED (hr))
            hr = SetPropPageToDeleteOnClose (pPspSettings);

        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hProp = CreateThemedPropertySheetPage(pPsp);
            HPROPSHEETPAGE hPropSettings = CreateThemedPropertySheetPage(pPspSettings);
            if (NULL == hProp || NULL == hPropSettings )
                hr = E_UNEXPECTED;
            else
            {
                lpProvider->AddPage(hProp);
                lpProvider->AddPage (hPropSettings);
                hr = S_OK;
            }
        }
    }

    FREE_INTERNAL(pInternal);

    return hr;
}

// Scope item property pages:
STDMETHODIMP CScopePane::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    // scope panes don't have property pages in RSOP mode
    if (m_fRSOP)
    {
        return S_FALSE;
    }
    //the only property sheets we are presenting right now are those
    //for built-in folder redirection
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    
    if (! pInternal)
        return S_FALSE;
    
    MMC_COOKIE cookie = pInternal->m_cookie;
    HRESULT hr = S_FALSE;
    CError  error;

    if (CCT_SCOPE == pInternal->m_type)
    {
        if (SUCCEEDED(m_FolderData[GETINDEX(cookie)].LoadSection()))
            hr = S_OK;
        else
        {
            error.ShowConsoleMessage (m_pConsole, IDS_SECTIONLOAD_ERROR,
                                      m_FolderData[GETINDEX(cookie)].m_szDisplayname);
            hr = S_FALSE;
        }
    }

    FREE_INTERNAL(pInternal);
    return hr;
}

BOOL CScopePane::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    
    if (! pInternal)
        return bResult;

    if (pInternal->m_type == CCT_SCOPE)
        bResult = TRUE;

    FREE_INTERNAL(pInternal);

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CScopePane::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              LONG * pInsertionAllowed)
{
    //we do not have any commands on the menu.
    return S_OK;
}

STDMETHODIMP CScopePane::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    //we do not have any commands on the menu
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\secpath.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    secpath.cxx

Abstract:

    this file contains the code for the dialog that is used for associating
    security groups with paths.

Author:

    Rahul Thombre (RahulTh) 4/14/1998

Revision History:

    4/14/1998   RahulTh

    Created this module.

--*/

#include "precomp.hxx"

//
//mapping between help ids and controls ids for this dialog
//
const DWORD g_aHelpIDMap_IDD_SECPATH[] =
{
    IDC_SECPATH_ICON,       IDH_DISABLEHELP,
    IDC_SECPATH_DESC,       IDH_DISABLEHELP,
    IDC_SECPATH_SECGROUP,   IDH_DISABLEHELP,
    IDC_EDIT_SECGROUP,      IDH_EDIT_SECGROUP,
    IDC_BROWSE_SECGROUP,    IDH_BROWSE_SECGROUP,
    IDC_SECPATH_TARGET,     IDH_DISABLEHELP,
    0,                      0
};

///////////////////////////
/// Construction

CSecGroupPath::CSecGroupPath (CWnd *    pParent,
                              UINT      cookie,
                              LPCTSTR   szFolderName,
                              LPCTSTR   szGroupName /*=NULL*/,
                              LPCTSTR   szGroupSidStr /*=NULL*/,
                              LPCTSTR   szTarget /*= NULL*/)
    : CDialog(CSecGroupPath::IDD, pParent), m_redirPath (cookie), m_cookie (cookie)
{
    m_szFolderName = szFolderName;
    m_szGroup = szGroupName;
    m_szSidStr = szGroupSidStr;
    m_szTarget = szTarget;
    if (! m_szTarget.IsEmpty())
    {
        m_szTarget.TrimLeft();
        m_szTarget.TrimRight();
        m_szTarget.TrimRight(L'\\');
    }
    m_bPathValid = FALSE;
    m_iCurrType = -1;
}

/////////////////////////
///Overrides

void CSecGroupPath::DoDataExchange (CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecGroupPath)
    DDX_Control(pDX, IDC_EDIT_SECGROUP, m_EditSecGroup);
    DDX_Control(pDX, IDC_BROWSE_SECGROUP, m_btnBrowseSecGroup);
    DDX_Control(pDX, IDC_SECPATH_PLACEHOLDER, m_placeHolder);
    //}}AFX_DATA_MAP
}

/////////////////////
/// Message maps
BEGIN_MESSAGE_MAP(CSecGroupPath, CDialog)
    //{{AFX_MSG_MAP(CSecGroupPath)
    ON_BN_CLICKED (IDC_BROWSE_SECGROUP, OnBrowseGroups)
    ON_EN_UPDATE (IDC_EDIT_SECGROUP, OnSecGroupUpdate)
    ON_EN_KILLFOCUS (IDC_EDIT_SECGROUP, OnSecGroupKillFocus)
    ON_MESSAGE (WM_PATH_TWEAKED, OnPathTweak)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
    //}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CSecGroupPath::OnInitDialog ()
{
    CError  error (this);

    CDialog::OnInitDialog();

    //
    // Make sure that the supplied path is parseable into one of the known
    // types
    //
    if (! m_szTarget.IsEmpty())
        m_redirPath.Load ((LPCTSTR) m_szTarget);    // This will always succeed if m_szTarget is not empty

    m_pathChooser.Instantiate (m_cookie,
                               this,
                               &m_placeHolder,
                               (const CRedirPath *) &m_redirPath,
                               SWP_SHOWWINDOW
                               );

    m_EditSecGroup.SetWindowText (m_szGroup);
    m_EditSecGroup.SetSel (0, -1, FALSE);
    m_EditSecGroup.SetFocus();
    SetOKState();

    return FALSE;    //returning FALSE since we are setting the focus to the edit box
}

void CSecGroupPath::OnOK ()
{
    CError      error(this);
    CString     szRoot;
    CString     szSuffix;
    CRedirPath  newPath (m_cookie);
    BOOL        bStatus = TRUE;
    UINT        pathType;

    //first check if we have a valid group.
    OnSecGroupKillFocus();

    //if the target is not a UNC path, try to convert it to one.
    m_pathChooser.OnRootKillFocus();

    if (!m_fValidSid)
    {
        error.ShowMessage (IDS_NOSECURITY_INFO);
        return;
    }

    m_EditSecGroup.GetWindowText (m_szGroup);
    m_szGroup.TrimLeft();
    m_szGroup.TrimRight();

    m_szSidStr.TrimLeft();
    m_szSidStr.TrimRight();
    m_szSidStr.MakeLower();

    m_pathChooser.GetRoot (szRoot);
    pathType = m_pathChooser.GetType();

    bStatus = TRUE;
    if (m_redirPath.IsPathDifferent (pathType, (LPCTSTR)szRoot))
    {
        // The path has changed, so use the new suffix
        newPath.GenerateSuffix (szSuffix, m_cookie, pathType);
        bStatus = newPath.Load (pathType, (LPCTSTR) szRoot, (LPCTSTR) szSuffix);
        if (bStatus)
            newPath.GeneratePath (m_szTarget);
    }
    else
    {
        m_redirPath.GeneratePath (m_szTarget);
    }

    //check if all the data has been provided.
    if (! bStatus               ||
        m_szTarget == TEXT("*") ||   //this particular check is very important -- see code for CFileInfo::LoadSection to see why
        m_szGroup.IsEmpty())
    {
        error.ShowMessage (IDS_INVALID_GROUPPATH);
    }
    else if (pathType != IDS_USERPROFILE_PATH &&
             ! PathIsUNC ((LPCTSTR) m_szTarget)
             )
    {
        error.SetStyle (MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
        error.SetTitle (IDS_DEFAULT_WARNING_TITLE);
        if (IDYES == error.ShowMessage (IDS_PATHNOTUNC_WARNING))
        {
            CDialog::OnOK();
        }
    }
    else
    {
        CDialog::OnOK();
    }
}

void
CSecGroupPath::OnCancel (void)
{
    m_pathChooser.OnCancel();
    CDialog::OnCancel();
}

//browse the security groups
void CSecGroupPath::OnBrowseGroups ()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CError                  error(this);
   PCWSTR                  apwszAttribs[] =
                           {
                              L"ObjectSid"
                           };
   DWORD                   dwError = ERROR_SUCCESS;
   HRESULT                 hr;
   IDsObjectPicker       * pDsObjectPicker = NULL;
   DSOP_INIT_INFO          InitInfo;
   const ULONG             cbNumScopes = 3;
   DSOP_SCOPE_INIT_INFO    ascopes[cbNumScopes];
   IDataObject           * pdo = NULL;
   STGMEDIUM               stgmedium = {
                              TYMED_HGLOBAL,
                              NULL
                           };
   UINT                    cf = 0;
   PDS_SELECTION_LIST      pDsSelList = NULL;
   FORMATETC               formatetc = {
                              (CLIPFORMAT)cf,
                              NULL,
                              DVASPECT_CONTENT,
                              -1,
                              TYMED_HGLOBAL
                           };
   PDS_SELECTION           pDsSelection = NULL;
   BOOL                    bAllocatedStgMedium = FALSE;
   SAFEARRAY             * pVariantArr = NULL;
   PSID                    pSid = NULL;
   CString                 szDomain;
   CString                 szAcct;
   SID_NAME_USE            eUse;


   hr = CoInitialize (NULL);

   if (SUCCEEDED (hr))
   {
       hr = CoCreateInstance (CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) & pDsObjectPicker
                              );
   }

   if (FAILED(hr))
   {
      dwError = IDS_OBJPICK_ERROR;
      goto BrwsGrp_Err;
   }


   //Initialize the scopes
   ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));

   ascopes[0].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
   ascopes[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   ascopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
   ascopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_BUILTIN_GROUPS |
                                       DSOP_FILTER_UNIVERSAL_GROUPS_DL  |
                                       DSOP_FILTER_UNIVERSAL_GROUPS_SE  |
                                       DSOP_FILTER_GLOBAL_GROUPS_DL |
                                       DSOP_FILTER_GLOBAL_GROUPS_SE;
   ascopes[0].FilterFlags.Uplevel.flNativeModeOnly =
       DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
       DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;

   ascopes[1].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
   ascopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
   ascopes[1].FilterFlags.Uplevel.flBothModes =
      ascopes[0].FilterFlags.Uplevel.flBothModes;
   ascopes[1].FilterFlags.Uplevel.flNativeModeOnly =
       ascopes[0].FilterFlags.Uplevel.flNativeModeOnly;

   ascopes[2].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
   ascopes[2].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   ascopes[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS |
                                       DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

   //Populate the InitInfo structure that is used to initialize the object
   //picker.
   ZeroMemory (&InitInfo, sizeof (InitInfo));

   InitInfo.cbSize = sizeof (InitInfo);
   InitInfo.cDsScopeInfos = cbNumScopes;
   InitInfo.aDsScopeInfos = ascopes;
   InitInfo.cAttributesToFetch = 1;
   InitInfo.apwzAttributeNames = apwszAttribs;

   hr = pDsObjectPicker->Initialize (&InitInfo);

   if (FAILED (hr))
   {
      dwError = IDS_OBJPICK_ERROR;
      goto BrwsGrp_Err;
   }

   hr = pDsObjectPicker->InvokeDialog (this->m_hWnd, &pdo);

   if (FAILED(hr))
   {
      dwError = IDS_OBJPICK_ERROR;
      goto BrwsGrp_Err;
   }

   if (S_FALSE == hr)   //the user hit cancel
      goto BrwsGrp_CleanupAndQuit;

   //if we are here, the user chose, OK, so find out what group was chosen
   cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);

   if (0 == cf)
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   //set the clipformat for the formatetc structure
   formatetc.cfFormat = (CLIPFORMAT)cf;

   hr = pdo->GetData (&formatetc, &stgmedium);

   if (FAILED (hr) )
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   bAllocatedStgMedium = TRUE;

   pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);

   if (NULL == pDsSelList)
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }


   if (!pDsSelList->cItems)    //some item must have been selected
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   pDsSelection = &(pDsSelList->aDsSelection[0]);

   //we must get the ObjectSid attribute, otherwise we fail
   //so make sure that the attribute has been fetched.
   if (!pDsSelList->cFetchedAttributes ||
       (! (VT_ARRAY & pDsSelection->pvarFetchedAttributes->vt)))
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   pVariantArr = pDsSelection->pvarFetchedAttributes->parray;
   pSid = (PSID) pVariantArr->pvData;

   if (STATUS_SUCCESS != GetFriendlyNameFromSid (pSid, szDomain, szAcct, &eUse))
   {
      dwError = IDS_NOSECURITY_INFO;
      goto BrwsGrp_Err;
   }

   //store away the string representation of this sid
   if (STATUS_SUCCESS != GetStringFromSid(pSid, m_szSidStr))
       goto BrwsGrp_Err;

   m_szSidStr.MakeLower();
   if (!szDomain.IsEmpty())
       szAcct = szDomain + '\\' + szAcct;

   m_EditSecGroup.SetWindowText (szAcct);
   m_fValidSid = TRUE;

   goto BrwsGrp_CleanupAndQuit;

BrwsGrp_Err:
   error.ShowMessage (dwError);

BrwsGrp_CleanupAndQuit:
   if (pDsSelList)
      GlobalUnlock (stgmedium.hGlobal);
   if (bAllocatedStgMedium)
      ReleaseStgMedium (&stgmedium);
   if (pdo)
      pdo->Release();
   if (pDsObjectPicker)
      pDsObjectPicker->Release ();
}

void CSecGroupPath::SetOKState (void)
{
    CString szGroup;
    CString szPath;
    BOOL    bCheckPath = FALSE;

    m_EditSecGroup.GetWindowText(szGroup);
    szGroup.TrimLeft();
    szGroup.TrimRight();

    if (IDS_SPECIFIC_PATH == m_iCurrType ||
        IDS_PERUSER_PATH == m_iCurrType)
    {
        bCheckPath = TRUE;
        m_pathChooser.GetRoot (szPath);
        szPath.TrimLeft();
        szPath.TrimRight();
        szPath.TrimRight(L'\\');
    }

    if (szGroup.IsEmpty() || (bCheckPath && szPath.IsEmpty()))
        GetDescendantWindow(IDOK, FALSE)->EnableWindow(FALSE);
    else
        GetDescendantWindow(IDOK, FALSE)->EnableWindow(TRUE);
}

void CSecGroupPath::OnSecGroupUpdate()
{
    //the group in the edit box is about to change.
    //this means we can no longer trust the sid that we may have
    m_fValidSid = FALSE;
    SetOKState();
}

//we try to get a sid and domain for the group specified
//if we can't, we simply ignore the error and sit tight.
void CSecGroupPath::OnSecGroupKillFocus()
{
    BOOL    bStatus;
    CString szGroup;
    WCHAR   szWindowText[MAX_PATH];
    WCHAR   szDom[MAX_PATH];
    DWORD   dwDomLen = MAX_PATH;
    WCHAR*  szAcct;
    PSID    Sid = NULL;
    DWORD   dwSidLen = 0;
    SID_NAME_USE    eUse;
    DWORD   Status;
    CHourglass  hourglass;  //LookupAccountName takes a while
    BOOL    fDomainSupplied = FALSE;


    //if we already have a valid sid, there is nothing to worry.
    if (m_fValidSid)
        goto KillFocusEnd;

    //we don't have a valid sid, so we try to get one from the data in the
    //group box
    m_EditSecGroup.GetWindowText (szGroup);
    szGroup.TrimLeft();
    szGroup.TrimRight();

    if (szGroup.IsEmpty())
        goto KillFocusEnd;


    //get the account name from the window
    wcscpy (szWindowText, (LPCTSTR) szGroup);
    szAcct = wcsrchr (szWindowText, '\\');
    if (!szAcct)
    {
        szAcct = szWindowText;
    }
    else
    {
        *szAcct++ = 0;  //advance it so that it now points to the account
                        //and szWindowText will now refer to the supplied domain
        fDomainSupplied = TRUE;
    }

    do
    {
        bStatus = LookupAccountName (NULL, szAcct, Sid, &dwSidLen,
                                    szDom, &dwDomLen, &eUse);

        if (!bStatus)
        {
            Status = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER != Status)
                goto KillFocusEnd;  //we just ignore the error for now
            Sid = (PSID) alloca (dwSidLen);
            if (NULL == Sid)
                goto KillFocusEnd;  //we just ignore the error for now

            continue;
        }
        break;
    } while (1);

    //we have the sid if we are here
    //make sure it represents a group
    switch (eUse)
    {
    case SidTypeGroup:
    case SidTypeWellKnownGroup:
    case SidTypeAlias:
        break;
    default:
        goto KillFocusEnd;
    }

    //also make sure that if a domain was supplied, it matches what we
    //got back
    if (fDomainSupplied && (0 != lstrcmpi (szWindowText, szDom)))
        goto KillFocusEnd;

    //if we are here, then we have the sid for a group
    if (STATUS_SUCCESS != GetStringFromSid (Sid, m_szSidStr))
        goto KillFocusEnd;

    //we were finally successful in getting the sid in a string format
    m_szSidStr.MakeLower();
    szGroup = szDom;
    if (!szGroup.IsEmpty())
        szGroup += '\\';
    szGroup += szAcct;
    m_EditSecGroup.SetWindowText ((LPCTSTR) szGroup);
    m_fValidSid = TRUE;

KillFocusEnd:
    return;
}

void CSecGroupPath::OnPathTweak (WPARAM wParam, LPARAM lParam)
{
    m_bPathValid = (BOOL) wParam;
    m_iCurrType = (LONG) lParam;

    SetOKState();
}

LONG CSecGroupPath::OnHelp (WPARAM wParam, LPARAM lParam)
{
    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDMap_IDD_SECPATH);

    return lResult;
}

LONG CSecGroupPath::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDMap_IDD_SECPATH);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\snapin.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       snapin.cpp
//
//  Contents:   DLL support routines, class factory and registration
//              functions.
//
//  Classes:
//
//  Functions:
//
//  History:    2-12-1998   stevebl   comment header added
//              4-22-1998   rahulth   added CSection objects for the ini files
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "initguid.h"
#include "gpedit.h"

extern const CLSID CLSID_Snapin = {0x88E729D6,0xBDC1,0x11D1,{0xBD,0x2A,0x00,0xC0,0x4F,0xB9,0x60,0x3F}};
extern const wchar_t * szCLSID_Snapin = L"{88E729D6-BDC1-11D1-BD2A-00C04FB9603F}";

// Main NodeType GUID on numeric format
extern const GUID cNodeType = {0xE0494114,0xBDC1,0x11D1,{0xBD,0x2A,0x00,0xC0,0x4F,0xB9,0x60,0x3F}};

// Main NodeType GUID on string format
extern const wchar_t*  cszNodeType = L"{E0494114-BDC1-11D1-BD2A-00C04FB9603F}";

// RSOP GUIDs
extern const CLSID CLSID_RSOP_Snapin = {0XC40D66A0,0XE90C,0X46C6,{0XAA,0X3B,0X47,0X3E,0X38,0XC7,0X2B,0XF2}};
extern const wchar_t * szCLSID_RSOP_Snapin = L"{C40D66A0-E90C-46C6-AA3B-473E38C72BF2}";

IMalloc * g_pIMalloc;

#include "safereg.hxx"

#define BREAK_ON_FAIL_HRESULT(hr) if (FAILED(hr)) break

#define THREADING_STR   L"Apartment"

//+--------------------------------------------------------------------------
//
//  Function:   RegDeleteTree
//
//  Synopsis:   deletes a registry key and all of its children
//
//  Arguments:  [hKey]     - handle to the key's parent
//              [szSubKey] - name of the key to be deleted
//
//  Returns:    ERROR_SUCCESS
//
//  History:    3-17-1998   stevebl   Copied from ADE
//
//---------------------------------------------------------------------------

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKey(hKey, szSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    TCHAR szName[256];
    while (ERROR_SUCCESS == RegEnumKey(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKey(hKey, szSubKey);
}


HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Snapin, CUserComponentDataImpl)
        OBJECT_ENTRY(CLSID_RSOP_Snapin, CRSOPUserComponentDataImpl)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSnapinApp theApp;

HINSTANCE ghInstance;

BOOL CSnapinApp::InitInstance()
{
        ghInstance = m_hInstance;
        _Module.Init(ObjectMap, m_hInstance);
        if (FAILED(CoGetMalloc(1, &g_pIMalloc)))
            return FALSE;
        return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNT(CResultPane);
        DEBUG_VERIFY_INSTANCE_COUNT(CScopePane);

        g_pIMalloc->Release();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

const wchar_t * szUser_Namespace = L"{08114B47-BDC2-11D1-BD2A-00C04FB9603F}";
const wchar_t * szUserAppName = L"Folder Redirection Editor (Users)";
const wchar_t * szUser_RSOP_Namespace = L"{8CDE1CC8-0D3A-4B60-99EA-27EF3D7C0174}";
/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState());
	
    CSafeReg    shk;
    CSafeReg    shkCLSID;
    CSafeReg    shkServer;
    CSafeReg    shkTemp;
	WCHAR		szMUIUserAppName[MAX_PATH + 50];
	WCHAR		szModule[MAX_PATH];
	
	// Get the path to the module.
	if (0 != ::GetModuleFileName(AfxGetInstanceHandle(), szModule, MAX_PATH))
	{
		// MUI: MMC: Use the new NameStringIndirect value of MMC to display
		// a localized name for the snap-in while using MUI.
		wsprintf (szMUIUserAppName, L"@%s,-%d", szModule, IDS_SNAPIN_NAME);
	}
	else
	{
		szMUIUserAppName[0] = L'\0';
	}
		
	
    HRESULT hr = S_OK;
    do
    {
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
		
		// MUI: MMC: Use localized snap-in name for MUI.
		if (L'\0' != szMUIUserAppName[0])
		{
			hr = shk.SetValue(L"NameStringIndirect",
							  REG_SZ,
							  (CONST BYTE *) szMUIUserAppName,
							  sizeof(WCHAR) * (lstrlen(szMUIUserAppName) + 1));
		}

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        WCHAR szGUID[50];
        StringFromGUID2 (NODEID_User, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();

        // register RSOP extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_RSOP_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));

		// MUI: MMC: Use localized snap-in name for MUI.
		if (L'\0' != szMUIUserAppName[0])
		{
			hr = shk.SetValue(L"NameStringIndirect",
							  REG_SZ,
							  (CONST BYTE *) szMUIUserAppName,
							  sizeof (WCHAR) * (lstrlen(szMUIUserAppName) + 1));
		}
        
		hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_RSOP_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_RSOP_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        StringFromGUID2 (NODEID_RSOPUser, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_RSOP_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();
    } while (0);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    HKEY hkey;
    CString sz;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_Snapin));
    RegCloseKey(hkey);
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_Namespace));
    RegCloseKey(hkey);
    WCHAR szGUID[50];
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_User, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    RegDeleteValue(hkey, szCLSID_Snapin);
    RegCloseKey(hkey);

    // unregister RSOP nodes
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_RSOP_Snapin));
    RegCloseKey(hkey);
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_RSOP_Namespace));
    RegCloseKey(hkey);
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_RSOPUser, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    RegDeleteValue(hkey, szCLSID_RSOP_Snapin);
    RegCloseKey(hkey);

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RegisterInterface
//
//  Synopsis:   Add the registry entries required for an interface.
//
//  Arguments:  [pshkInterface]    - handle to CLSID\Interface key
//              [wszInterfaceGUID] - GUID of interface to add
//              [wszInterfaceName] - human-readable name of interface
//              [wszNumMethods]    - number of methods (including inherited)
//              [wszProxyCLSID]    - GUID of dll containing proxy/stubs
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//              5-09-1997   SteveBl    Modified for use with AppMgr
//
//---------------------------------------------------------------------------

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID)
{
    HRESULT     hr = S_OK;
    CSafeReg    shkIID;
    CSafeReg    shkNumMethods;
    CSafeReg    shkProxy;

    do
    {
        hr = pshkInterface->Create(wszInterfaceGUID, &shkIID);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.SetValue(NULL,
                             REG_SZ,
                             (CONST BYTE *) wszInterfaceName,
                             sizeof(WCHAR) * (lstrlen(wszInterfaceName) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"NumMethods", &shkNumMethods);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNumMethods.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)wszNumMethods,
                                sizeof(WCHAR) * (lstrlen(wszNumMethods) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"ProxyStubClsid32", &shkProxy);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkProxy.SetValue(NULL,
                               REG_SZ,
                               (CONST BYTE *)wszProxyCLSID,
                               sizeof(WCHAR) * (lstrlen(wszProxyCLSID) + 1));
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\security.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    security.cxx

Abstract:
    This file contains utility functions concerning file security, e.g.
    convertings SIDs to strings and back, getting the display name for
    a given sid or getting the sid, given the display name


Author:

    Rahul Thombre (RahulTh) 9/28/1998

Revision History:

    9/28/1998   RahulTh         Created this module.

--*/

#include "precomp.hxx"

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = wcslen (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    9/30/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    CString     SidStr;
    WCHAR*      pSidStr;
    WCHAR*      pString;
    NTSTATUS    Status;
    WCHAR*      pEnd;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    int         len;
    SID_IDENTIFIER_AUTHORITY Auth;

    SidStr = lpszSidStr;
    len = SidStr.GetLength();
    pSidStr = SidStr.GetBuffer (len);
    pString = pSidStr;

    *ppSid = NULL;
    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetFriendlyNameFromStringSid
//
//  Synopsis:   given a sid in string format, this function returns
//              the friendly name for it and the container in which
//              occurs. For more details on the string representation
//              of a sid, see ntseapi.h & ntrtl.h
//
//  Arguments:  [in] pSidStr : sid represented as a unicode string
//              [out] szDir  : the container in which the account occurs
//              [out] szAcct : the account name
//
//  Returns:    STATUS_SUCCESS : if successful
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetFriendlyNameFromStringSid (const WCHAR* pSidStr,
                                       CString& szDir,
                                       CString& szAcct
                                       )
{
    NTSTATUS    Status;
    PSID        pSid = NULL;
    WCHAR       szName[MAX_PATH];
    WCHAR       szDomain [MAX_PATH];
    DWORD       dwNameLen;
    DWORD       dwDomLen;
    SID_NAME_USE eUse;

    Status = AllocateAndInitSidFromString (pSidStr, &pSid);

    if (STATUS_SUCCESS != Status)
        goto GetFriendlyName_End;

    dwNameLen = dwDomLen = MAX_PATH;
    if (!LookupAccountSid (NULL, pSid, szName, &dwNameLen, szDomain, &dwDomLen,
                           &eUse))
        goto GetFriendlyName_Err;

    //we have got the container and the name of the account
    szDir = szDomain;
    szAcct = szName;

    Status = STATUS_SUCCESS;
    goto GetFriendlyName_End;

GetFriendlyName_Err:
    Status = GetLastError();

GetFriendlyName_End:
    if (pSid)
        FreeSid (pSid);
    return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetFriendlyNameFromSid
//
//  Synopsis:   give a pointer to a sid, this function gets the friendly name
//              of the account to which the sid belongs and its friendly name
//
//  Arguments:  [in] pSid : pointer to the SID
//              [out] szDir : the domain to which the account belongs
//              [out] szAcct : the friendly name of the account
//              [out] peUse : pointer to a sid_name_use structure that
//                            identifies the type of the account
//
//  Returns:    STATUS_SUCCESS : if successful
//              an error code otherwise
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetFriendlyNameFromSid (PSID   pSid,
                                 CString& szDir,
                                 CString& szAcct,
                                 SID_NAME_USE*  peUse)
{
    ASSERT (peUse);

    TCHAR   szName[MAX_PATH];
    TCHAR   szDomain [MAX_PATH];
    DWORD   dwNameLen;
    DWORD   dwDomLen;
    DWORD   Status = STATUS_SUCCESS;

    dwNameLen = dwDomLen = MAX_PATH;
    if (!LookupAccountSid (NULL, pSid, szName, &dwNameLen, szDomain, &dwDomLen,
                           peUse))
    {
        Status = GetLastError();
    }
    else
    {
        szDir = szDomain;
        szAcct = szName;
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetStringFromSid
//
//  Synopsis:   given a SID, this function gets its string representation
//              for more information on string representations of sids,
//              refer to ntsecapi.h & ntrtl.h
//
//  Arguments:  [in] pSid : pointer to a SID
//              [out] szStringSid : the string representation of the SID
//
//  Returns:    STATUS_SUCCESS if successful
//              an error code otherwise
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetStringFromSid (PSID pSid, CString& szStringSid)
{
    UNICODE_STRING  stringW;
    DWORD           Status;

    Status = RtlConvertSidToUnicodeString (&stringW, pSid, TRUE);

    if (STATUS_SUCCESS == Status)
    {
        szStringSid = stringW.Buffer;
    }

    RtlFreeUnicodeString (&stringW);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "safereg.hxx"


//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;
    ULONG   ulType;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszPathBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    lstrcpy(pwszPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
    }
    else if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\rsoputil.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.h
//
//  Contents:   helper functions for working with the RSOP database
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData);

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//              (Note that BSTR is a special case since the compiler can't
//              distinguish it from a TCHAR * but it's semantics are
//              different.)
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, CString &szData);
HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, GUID &guid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, unsigned int &ui);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, GUID * &rgGuid);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT &uiCount, TCHAR ** &rgszData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, PSECURITY_DESCRIPTOR &psd);

//+--------------------------------------------------------------------------
//
//  Function:   GetGPOFriendlyName
//
//  Synopsis:
//
//  Arguments:  [pIWbemServices] -
//              [lpGPOID]        -
//              [pLanguage]      -
//              [pGPOName]       -
//              [pGPOPath]       -
//
//  Returns:
//
//  Modifies:
//
//  History:    01-26-2000   stevebl   Stolen from code written by EricFlo
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                           LPTSTR lpGPOID,
                           BSTR pLanguage,
                           LPTSTR *pGPOName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\about.cpp ===
//*************************************************************
//  File name: ABOUT.CPP
//
//  Description:  About information for the Group Policy Editor
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutGPE implementation                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CAboutGPE::CAboutGPE(BOOL fRSOP) : m_smallImage( 0 ), m_largeImage( 0 )


{
    m_fRSOP = fRSOP;
    InterlockedIncrement(&g_cRefThisDll);
    m_cRef = 1;
}

CAboutGPE::~CAboutGPE()
{
    InterlockedDecrement(&g_cRefThisDll);
    if ( m_smallImage )
    {
        DeleteObject( m_smallImage );
    }
    if ( m_largeImage )
    {
        DeleteObject( m_largeImage );
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutGPE object implementation (IUnknown)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CAboutGPE::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_ISnapinAbout))
    {
        *ppv = (LPSNAPABOUT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CAboutGPE::AddRef (void)
{
    return ++m_cRef;
}

ULONG CAboutGPE::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutGPE object implementation (ISnapinAbout)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAboutGPE::GetSnapinDescription(LPOLESTR *lpDescription)
{
    LPTSTR lpBuffer;

    lpBuffer = (LPTSTR) CoTaskMemAlloc (256 * sizeof(TCHAR));

    if (lpBuffer)
    {
        LoadString (g_hInstance, m_fRSOP? IDS_RSOP_SNAPIN_DESCRIPT : IDS_SNAPIN_DESCRIPT, lpBuffer, 256);
        *lpDescription = lpBuffer;
    }

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetProvider(LPOLESTR *lpName)
{
    LPTSTR lpBuffer;

    lpBuffer = (LPTSTR) CoTaskMemAlloc (50 * sizeof(TCHAR));

    if (lpBuffer)
    {
        LoadString (g_hInstance, IDS_PROVIDER_NAME, lpBuffer, 50);
        *lpName = lpBuffer;
    }

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetSnapinVersion(LPOLESTR *lpVersion)
{
    LPTSTR lpBuffer;

    lpBuffer = (LPTSTR) CoTaskMemAlloc (50 * sizeof(TCHAR));

    if (lpBuffer)
    {
        LoadString (g_hInstance, IDS_SNAPIN_VERSION, lpBuffer, 50);
        *lpVersion = lpBuffer;
    }

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetSnapinImage(HICON *hAppIcon)
{
    *hAppIcon = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_POLICY));

    return S_OK;
}

STDMETHODIMP CAboutGPE::GetStaticFolderImage(HBITMAP *hSmallImage,
                                                  HBITMAP *hSmallImageOpen,
                                                  HBITMAP *hLargeImage,
                                                  COLORREF *cMask)
{
    if ( !m_smallImage )
    {
        m_smallImage = (HBITMAP) LoadImage (g_hInstance, MAKEINTRESOURCE(IDB_POLICY16),
                                            IMAGE_BITMAP,
                                            16, 16, LR_DEFAULTCOLOR);
    }

    if ( !m_largeImage )
    {
        m_largeImage = (HBITMAP) LoadImage (g_hInstance, MAKEINTRESOURCE(IDB_POLICY32),
                                            IMAGE_BITMAP,
                                            32, 32, LR_DEFAULTCOLOR);
    }

    *hLargeImage = m_largeImage;
    *hSmallImage = *hSmallImageOpen = m_smallImage;
    *cMask = RGB(255,0,255);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CAboutGPECF::CAboutGPECF(BOOL fRSOP)
{
    m_fRSOP = fRSOP;
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CAboutGPECF::~CAboutGPECF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CAboutGPECF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CAboutGPECF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CAboutGPECF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CAboutGPECF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CAboutGPE *pAboutGPE = new CAboutGPE(m_fRSOP); // ref count == 1

    if (!pAboutGPE)
        return E_OUTOFMEMORY;

    HRESULT hr = pAboutGPE->QueryInterface(riid, ppvObj);
    pAboutGPE->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CAboutGPECF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\about.h ===
//
// CLSID_AboutGPE
//

// {0FDE5092-AA2A-11d1-A7D4-0000F87571E3}
DEFINE_GUID(CLSID_AboutGPE, 0xfde5092, 0xaa2a, 0x11d1, 0xa7, 0xd4, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {4f637904-2cab-4f0e-8688-d3717ebd2975}
DEFINE_GUID(CLSID_RSOPAboutGPE, 0x4f637904, 0x2cab, 0x4f0e, 0x86, 0x88, 0xd3, 0x71, 0x7e, 0xbd, 0x29, 0x75);

#ifndef _ABOUT_H_
#define _ABOUT_H_


//
// CAboutGPE class
//

class CAboutGPE : public ISnapinAbout
{
protected:
    BOOL m_fRSOP;
public:
    CAboutGPE(BOOL fRSOP = FALSE);
    ~CAboutGPE();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented ISnapinAbout interface members
    //

    STDMETHODIMP         GetSnapinDescription(LPOLESTR *lpDescription);
    STDMETHODIMP         GetProvider(LPOLESTR *lpName);
    STDMETHODIMP         GetSnapinVersion(LPOLESTR *lpVersion);
    STDMETHODIMP         GetSnapinImage(HICON *hAppIcon);
    STDMETHODIMP         GetStaticFolderImage(HBITMAP *hSmallImage,
                                              HBITMAP *hSmallImageOpen,
                                              HBITMAP *hLargeImage,
                                              COLORREF *cMask);

private:

    ULONG    m_cRef;
    HBITMAP  m_smallImage;
    HBITMAP  m_largeImage;

};


//
// AboutGPE class factory
//


class CAboutGPECF : public IClassFactory
{
protected:
    ULONG m_cRef;
    BOOL  m_fRSOP;

public:
    CAboutGPECF(BOOL fRSOP = FALSE);
    ~CAboutGPECF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


#endif // _ABOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\stdafx.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       stdafx.h
//
//  Contents:   include file for standard system include files, or project
//              specific include files that are used frequently, but are
//              changed infrequently
//
//  History:    03-17-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include <afxwin.h>
#include <afxcmn.h>
#include <afxdisp.h>

#include <atlbase.h>

#include <shlobj.h>
#include <intshcut.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#ifdef DBG
//
// ATL's implementation of Release always returns 0 unless _DEBUG is
// defined. The debug version of OLE.DLL asserts Release() != 0 in certain
// circumstances.  I don't want to define _DEBUG because it brings in a
// whole lot of baggage from MMC that I don't want to deal with, but I do
// want to avoid this assertion in OLE, so on debug builds, I'll go ahead
// and define _DEBUG for the appropriate ATL header file but I'll undefine
// it again right afterward.  This is a little flakey but it is relatively
// safe and it achieves the desired goal.
//
// - SteveBl
//
#define _DEBUG
#endif
#include <atlcom.h>
#ifdef DBG
#undef _DEBUG
#endif

#include <afxwin.h>         //MFC core and standard components
#include <afxext.h>         //MFC extensions

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

const long UNINITIALIZED = -1;

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    CString             m_string;
    HSCOPEITEM          m_scopeID;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};


// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\browser.h ===
#if !defined __BROWSER_H__
#define __BROWSER_H__

#include "cproppg.h"

#define PAGETYPE_DOMAINS        0
#define PAGETYPE_SITES          1
#define PAGETYPE_COMPUTERS      2
#define PAGETYPE_ALL            3

#define ITEMTYPE_SITE           0
#define ITEMTYPE_DOMAIN         1
#define ITEMTYPE_OU             2
#define ITEMTYPE_GPO            3
#define ITEMTYPE_FOREST         4

#define CLASSNAME_OU        L"organizationalUnit"
#define CLASSNAME_DOMAIN    L"domainDNS"

typedef struct tag_MYLISTEL
{
    LPWSTR  szName;
    LPWSTR  szData;
    UINT    nType;
    BOOL    bDisabled;
} MYLISTEL;

#define BUTTONSIZE 16

#define SMALLICONSIZE   16
#define LARGEICONSIZE   32
#define INDENT          10


typedef struct tag_LOOKDATA
{
    LPWSTR     szName;
    UINT       nIndent;
    UINT       nType;
    LPWSTR     szData;
    struct tag_LOOKDATA * pSibling;
    struct tag_LOOKDATA * pParent;
    struct tag_LOOKDATA * pChild;
} LOOKDATA;

LOOKDATA * BuildDomainList(WCHAR * szServerName);
VOID FreeDomainInfo (LOOKDATA * pEntry);

class CBrowserPP : CHlprPropPage
{
    // Construction
    public:
    CBrowserPP();
    HPROPSHEETPAGE Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void ** ppActive);
    ~CBrowserPP();

    INT AddElement(MYLISTEL * pel, INT index);

public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
protected:

    // Implementation
protected:
    virtual BOOL OnInitDialog();
    void OnContextMenu(LPARAM lParam);
    void OnDoubleclickList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnDetails();
    void OnList();
    void OnLargeicons();
    void OnSmallicons();
    void OnArrangeAuto();
    void OnArrangeByname();
    void OnArrangeBytype();
    void OnDelete();
    void OnEdit();
    void OnNew();
    void OnProperties();
    void OnRefresh();
    void OnRename();
    void OnTopLineupicons();
    void OnBeginlabeleditList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnEndlabeleditList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnBegindragList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnDeleteitemList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnColumnclickList(NMHDR* pNMHDR, LRESULT* pResult);
    void OnKeyDownList(NMHDR * pNMHDR, LRESULT * pResult);
    void OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult);
    void OnComboChange();
    void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
    void RefreshDomains(void);
    void RefreshSites(void);
    void RefreshAll(void);
    void SetButtonState(void);
    LPOLESTR GetCurrentObject();
    LPOLESTR GetCurrentDomain();
    BOOL IsCurrentObjectAForest();
    BOOL FillDomainList();
    BOOL SetInitialOU();
    BOOL FillSitesList();
    BOOL AddGPOsForDomain();
    BOOL AddGPOsLinkedToObject();
    void TrimComboBox();
    BOOL AddChildContainers();
    BOOL CreateLink(LPOLESTR szObject, LPOLESTR szContainer);
    BOOL DeleteLink(LPOLESTR szObject, LPOLESTR szContainer);
    LPTSTR GetFullPath (LPTSTR lpGPO, HWND hParent);

    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND                    m_hwndDlg;
    HWND                    m_hList;
    HWND                    m_hCombo;
    HWND                    m_toolbar;
    HIMAGELIST              m_ilSmall;
    HIMAGELIST              m_ilLarge;
    void **                 m_ppActive;
    LPGPOBROWSEINFO         m_pGBI;
    DWORD                   m_dwPageType;
    WCHAR                   m_szTitle[256];
    LOOKDATA *              m_pPrevSel;
    LPTSTR                  m_szServerName;
    LPTSTR                  m_szDomainName;

    BOOL DoBackButton();
    BOOL DoNewGPO();
    BOOL DeleteGPO();
    BOOL DoRotateView();
};

#endif // __BROWSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\browser.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       browser.cpp
//
//  Contents:   implementation of the general GPO browser pane
//
//  Classes:    CBrowserPP
//
//  Functions:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This is the pane that behaves much like the standard file
//              open dialog.  The class is used for all panes that have this
//              format since they share so much functionality.  The
//              dwPageType parameter passed to CBrowserPP::Initialize is
//              used to distinguish between the different flavors.
//
//---------------------------------------------------------------------------

#include "main.h"
#include "browser.h"
#include "commctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Help ids
//

DWORD aBrowserDomainHelpIds[] =
{
    IDC_COMBO1,                   IDH_BROWSER_LOOKIN,
    IDC_LIST1,                    IDH_BROWSER_DOMAINGPO,
    IDC_DESCRIPTION,              IDH_NOCONTEXTHELP,

    0, 0
};

DWORD aBrowserSiteHelpIds[] =
{
    IDC_COMBO1,                   IDH_BROWSER_SITELIST,
    IDC_LIST1,                    IDH_BROWSER_GPOLIST,
    IDC_DESCRIPTION,              IDH_NOCONTEXTHELP,

    0, 0
};

DWORD aBrowserAllHelpIds[] =
{
    IDC_COMBO1,                   IDH_BROWSER_DOMAINLIST,
    IDC_LIST1,                    IDH_BROWSER_FULLGPOLIST,
    IDC_DESCRIPTION,              IDH_NOCONTEXTHELP,

    0, 0
};


CBrowserPP::CBrowserPP()
{
    m_ppActive = NULL;
    m_pGBI = NULL;
    m_pPrevSel = NULL;
    m_szServerName = NULL;
    m_szDomainName = NULL;
}

//+--------------------------------------------------------------------------
//
//  Function:   CopyAsFriendlyName
//
//  Synopsis:   Copies a LDAP path converting it to a friendly name by
//              removing the "LDAP://" and "XX=" and converting "," to "."
//              and removing a server name (if any)
//
//  Arguments:  [lpDest] - destination buffer
//              [lpSrc]  - source buffer
//
//  Returns:    nothing
//
//  History:    5-07-1998   stevebl   Created
//
//  Notes:      The destination buffer should be as large as the source
//              buffer to ensure safe completion.  lpDest and lpSrc may both
//              point to the same buffer.
//
//              As an example, this routine would convert the following path:
//                  LDAP://DC=foo,DC=bar
//              into this:
//                  foo.bar
//
//---------------------------------------------------------------------------

void CopyAsFriendlyName(WCHAR * lpDest, WCHAR * lpSrc)
{
    LPOLESTR lpProvider = L"LDAP://";
    DWORD dwStrLen = wcslen(lpProvider);

    // lpStopChecking marks the last spot where we can safely
    // look ahead 2 spaces for an '=' character.  Anything past
    // this and we are looking in memory we don't own.
    OLECHAR * lpStopChecking = (wcslen(lpSrc) - 2) + lpSrc;

    //
    // Skip the LDAP:// if found
    //

    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                       lpProvider, dwStrLen, lpSrc, dwStrLen) == CSTR_EQUAL)
    {
        lpSrc += dwStrLen;
    }

    //
    // Remove server name (if any)
    //
    if (lpSrc < lpStopChecking)
    {
        if (*(lpSrc+2) != L'=')
        {
            // look for a '/' character marking the end of a server name
            while (*lpSrc)
            {
                if (*lpSrc == L'/')
                {
                    lpSrc++;
                    break;
                }
                lpSrc++;
            }
        }
    }

    //
    // Parse through the name replacing all the XX= with .
    //

    while (*lpSrc)
    {
        if (lpSrc < lpStopChecking)
        {
            if (*(lpSrc+2) == L'=')
            {
                lpSrc += 3;
            }
        }

        while (*lpSrc && (*lpSrc != L','))
        {
            // remove escape sequences
            if (*lpSrc == L'\\')
            {
                lpSrc++;
                // special cases
                // make sure that '\\x' becomes '\x'
                if (*lpSrc == L'\\')
                {
                    *lpDest++ = *lpSrc++;
                }
                // make sure that '\0D' becomes '\r'
                else if (*lpSrc == L'0' && *(lpSrc+1) == L'D')
                {
                    *lpDest++ = L'\r';
                    lpSrc += 2;
                }
                // make sure that '\0A' becomes '\n'
                else if (*lpSrc == L'0' && *(lpSrc+1) == L'A')
                {
                    *lpDest++ = L'\n';
                    lpSrc += 2;
                }
            }
            else
            {
                *lpDest++ = *lpSrc++;
            }
        }

        if (*lpSrc == L',')
        {
            *lpDest++ = L'.';
            lpSrc++;
        }
    }

    *lpDest = L'\0';
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::Initialize
//
//  Synopsis:   Initializes the property page.
//
//  Arguments:  [dwPageType] - used to identify which page this is.  (See
//                              notes.)
//              [pGBI]       - pointer to the browse info structure passed
//                              by caller
//              [ppActive]   - pointer to a common variable that remembers
//                              which object was last given the focus.
//                              Needed because only the page with the focus
//                              is allowed to return data to the caller when
//                              the property sheet is dismissed.
//
//  Returns:    Handle to the newly created property page.
//
//  Modifies:
//
//  Derivation:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This class implements the following property pages:
//                  PAGETYPE_DOMAINS    - GPO's linked to domains
//                  PAGETYPE_SITES      - GPO's linked to sites
//                  PAGETYPE_ALL        - All GPO's in a selected
//
//              PAGETYPE_COMPUTERS is implemented by CCompsPP since it
//              behaves so differently.
//
//---------------------------------------------------------------------------

HPROPSHEETPAGE CBrowserPP::Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void * * ppActive)
{
    m_ppActive = ppActive;
    m_dwPageType = dwPageType;
    m_pGBI = pGBI;

    if (m_pGBI->lpInitialOU)
    {
        //
        // Get the server name
        //

        m_szServerName = ExtractServerName(m_pGBI->lpInitialOU);
        DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::Initialize extracted server name: %s"), m_szServerName));

        //
        // Get the friendly domain name
        //

        LPOLESTR pszDomain = GetDomainFromLDAPPath(m_pGBI->lpInitialOU);

        //
        // Convert LDAP to dot (DN) style
        //

        if (pszDomain)
        {
            ConvertToDotStyle (pszDomain, &m_szDomainName);
            DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::Initialize extracted domain name: %s"), m_szDomainName));
            delete [] pszDomain;
        }
    }

    DWORD dwTitle;
    switch (dwPageType)
    {
    case PAGETYPE_DOMAINS:
        dwTitle = IDS_DOMAINS;
        break;
    case PAGETYPE_SITES:
        dwTitle = IDS_SITES;
        break;
    case PAGETYPE_ALL:
    default:
        dwTitle = IDS_ALL;
        break;
    }
    LoadString(g_hInstance, dwTitle, m_szTitle, sizeof(m_szTitle) / sizeof(WCHAR));

    PROPSHEETPAGE psp;
    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_USETITLE;
    psp.pszTitle = m_szTitle;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_GPOBROWSER);
    return CreatePropertySheetPage(&psp);
}

CBrowserPP::~CBrowserPP()
{
    if (m_szServerName)
    {
        LocalFree(m_szServerName);
    }
    if (m_szDomainName)
    {
        LocalFree(m_szDomainName);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CBrowserPP message handlers

INT CBrowserPP::AddElement(MYLISTEL * pel, INT index)
{
    LV_ITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    if (-1 == index)
    {
        index = ListView_GetItemCount(m_hList);
    }
    item.iItem = index;
    item.pszText = pel->szName;

    if (pel->nType == ITEMTYPE_FOREST)
    {
        item.iImage = 10;
    }
    else if (pel->nType == ITEMTYPE_SITE)
    {
        item.iImage = 6;
    }
    else if (pel->nType == ITEMTYPE_DOMAIN)
    {
        item.iImage = 7;
    }
    else if (pel->nType == ITEMTYPE_OU)
    {
        item.iImage = 0;
    }
    else
    {
        if (pel->bDisabled)
        {
            item.iImage = 3;
        }
        else
        {
            item.iImage = 2;
        }
    }

    item.lParam = (LPARAM)pel;
    index = ListView_InsertItem(m_hList, &item);
    if (index != -1 && pel->nType == ITEMTYPE_GPO)
    {
        // check to see if we need to add the domain name
        LPOLESTR szObject = GetCurrentObject();
        LPOLESTR szDomain = GetDomainFromLDAPPath(pel->szData);
        if (szDomain && szObject)
        {
            // ignore potential differences in server name when we compare
            // the domain paths
            LPOLESTR szBuffer1 = NULL;
            LPOLESTR szBuffer2 = NULL;
            szBuffer1 = new OLECHAR[wcslen(szObject) + 1];
            szBuffer2 = new OLECHAR[wcslen(szDomain) + 1];
            if (NULL != szBuffer1 && NULL != szBuffer1)
            {
                CopyAsFriendlyName(szBuffer1, szObject);
                CopyAsFriendlyName(szBuffer2, szDomain);
                if (0 != wcscmp(szBuffer1, szBuffer2))
                {
                    // Need to add the domain name since the domain is different
                    // from the focus object.

                    // Need to convert the domain to a friendly name.
                    // Let's just do it in place so I don't have to allocate any
                    // more memory. :)
                    // We can get away with this because the string can only get smaller.
                    CopyAsFriendlyName(szDomain, szDomain);

                    memset(&item, 0, sizeof(item));
                    item.mask = LVIF_TEXT;
                    item.iItem = index;
                    item.iSubItem = 1;
                    item.pszText = szDomain;
                    ListView_SetItem(m_hList, &item);
                }
            }
            if (szBuffer1)
            {
                delete [] szBuffer1;
            }
            if (szBuffer2)
            {
                delete [] szBuffer2;
            }
        }

        if (szDomain)
            delete [] szDomain;
        if (szObject)
            delete [] szObject;
    }
    return (index);
}

#include "ntdsapi.h"

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::FillSitesList
//
//  Synopsis:   Fills the combobox with the trusted sites information.
//              The szData member of the combobox element structure is the
//              containing domain.
//
//  Returns:    TRUE - successful
//              FALSE - error
//
//  History:    05-04-1998   stevebl   created
//              05-27-1999   stevebl   now initializes to site in lpInitialOU
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::FillSitesList ()
{
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    PDS_NAME_RESULTW pSites;
    int iInitialSite = 0;
    int iIndex = -1;
    HANDLE hDs;

    DWORD dw = DsBindW(NULL, NULL, &hDs);
    if (ERROR_SUCCESS == dw)
    {
        dw = DsListSitesW(hDs, &pSites);
        if (ERROR_SUCCESS == dw)
        {
            DWORD n = 0;
            for (n = 0; n < pSites->cItems; n++)
            {
                //
                // Add the site name (if it has a name)
                //
                if (pSites->rItems[n].pName)
                {
                    LPTSTR lpFullPath, lpTempPath;
                    LOOKDATA * pdata;
                    pdata = new LOOKDATA;
                    if (pdata)
                    {
                        pdata->szName = new WCHAR[wcslen(pSites->rItems[n].pName)+1];
                        if (pdata->szName)
                        {
                            wcscpy(pdata->szName, pSites->rItems[n].pName);
                        }

                        pdata->szData = NULL;

                        lpTempPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pSites->rItems[n].pName) + 10) * sizeof(TCHAR));

                        if (lpTempPath)
                        {
                            lstrcpy (lpTempPath, TEXT("LDAP://"));
                            lstrcat (lpTempPath, pSites->rItems[n].pName);

                            lpFullPath = GetFullPath (lpTempPath, m_hwndDlg);

                            if (lpFullPath)
                            {
                                pdata->szData = new WCHAR[wcslen(lpFullPath)+1];
                                if (pdata->szData)
                                {
                                    wcscpy(pdata->szData, lpFullPath);
                                }

                                LocalFree (lpFullPath);
                            }

                            LocalFree (lpTempPath);
                        }

                        if (!pdata->szData)
                        {
                            if (pdata->szName)
                            {
                                delete [] pdata->szName;
                            }

                            delete pdata;
                            continue;
                        }

                        // try and use a friendlier name for the site
                        {
                            IADs * pADs = NULL;
                            // Get the friendly display name
                            HRESULT hr = OpenDSObject(pdata->szData, IID_IADs,
                                                      (void **)&pADs);

                            if (SUCCEEDED(hr))
                            {
                                VARIANT varName;
                                BSTR bstrNameProp;
                                VariantInit(&varName);
                                bstrNameProp = SysAllocString(SITE_NAME_PROPERTY);

                                if (bstrNameProp)
                                {
                                    hr = pADs->Get(bstrNameProp, &varName);

                                    if (SUCCEEDED(hr))
                                    {
                                        LPOLESTR sz = new OLECHAR[wcslen(varName.bstrVal) + 1];
                                        if (sz)
                                        {
                                            wcscpy(sz, varName.bstrVal);
                                            if (pdata->szName)
                                                delete [] pdata->szName;
                                            pdata->szName = sz;
                                        }
                                    }
                                    SysFreeString(bstrNameProp);
                                }
                                VariantClear(&varName);
                                pADs->Release();
                            }
                        }
                        pdata->nIndent = 0;
                        pdata->nType = ITEMTYPE_SITE;

                        iIndex = (int)SendMessage(m_hCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) (LPCTSTR) pdata);
                        if (CB_ERR == iIndex)
                        {
                            DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddSitesList: Failed to alloc memory with %d"), GetLastError()));
                        }
                        if (NULL != pdata->szData && NULL != m_pGBI->lpInitialOU)
                        {
                            if (0 == wcscmp(pdata->szData, m_pGBI->lpInitialOU))
                            {
                                iInitialSite = iIndex;
                            }
                        }
                    }
                }
            }
            DsFreeNameResultW(pSites);
        }
        DsUnBindW(&hDs);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddSitesList: DsBindW failed with 0x%x"), dw));
        ReportError(m_hwndDlg, dw, IDS_DSBINDFAILED);
    }

    if (iIndex >= 0)
    {
        SendMessage (m_hCombo, CB_SETCURSEL, iInitialSite, 0);
    }
    SetCursor(hcur);
    return TRUE;
}

PDS_DOMAIN_TRUSTS Domains;

int __cdecl CompareDomainInfo(const void * arg1, const void * arg2)
{
    WCHAR * sz1, *sz2;
    sz1 = Domains[*(ULONG *)arg1].DnsDomainName;
    sz2 = Domains[*(ULONG *)arg2].DnsDomainName;
    if (!sz1)
    {
        sz1 = Domains[*(ULONG *)arg1].NetbiosDomainName;
    }
    if (!sz2)
    {
        sz2 = Domains[*(ULONG *)arg2].NetbiosDomainName;
    }
    return _wcsicmp(sz1,sz2);
}

typedef struct tag_WORKING_LIST_EL
{
    ULONG index;
    struct tag_WORKING_LIST_EL * pNext;
} WORKING_LIST_EL;

//+--------------------------------------------------------------------------
//
//  Function:   BuildDomainList
//
//  Synopsis:   Builds a tree containing all domains that have a trust
//              relationship with the server.
//
//              Siblings within the tree are alphabetized.
//
//  Arguments:  [szServerName] - (NULL for local)
//
//  Returns:    pointer to the root node of the tree (NULL on error)
//
//  History:    10-16-1998   stevebl   Created
//
//  Notes:      Tree nodes must be freed by the caller (using delete).
//
//---------------------------------------------------------------------------

LOOKDATA * BuildDomainList(WCHAR * szServerName)
{
    ULONG DomainCount;
    OLECHAR szBuffer[128];
#if FGPO_SUPPORT
    LOOKDATA * pDomainList = new LOOKDATA;

    if (!pDomainList)
    {
        // failed to even create the Forest node!
        return NULL;
    }

    pDomainList->szData = GetPathToForest(szServerName);

    if (!pDomainList->szData)
    {
        delete pDomainList;
        return NULL;
    }

    // load the name for the forest from resources
    if (0 == LoadStringW(g_hInstance, IDS_FOREST, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])))
    {
        // failed to get the resource name
        delete pDomainList;
        return NULL;
    }
    pDomainList->szName = new OLECHAR [lstrlen(szBuffer) + 1];
    if (NULL == pDomainList->szName)
    {
        // not enough memory to create name of the forest node
        delete pDomainList;
        return NULL;
    }
    lstrcpy(pDomainList->szName, szBuffer);
    pDomainList->nIndent = 0;
    pDomainList->nType = ITEMTYPE_FOREST;
    pDomainList->pParent = NULL;
    pDomainList->pSibling = NULL;
    pDomainList->pChild = NULL;
#else
    LOOKDATA * pDomainList = NULL;
#endif

    long l = DsEnumerateDomainTrusts(szServerName,
                                     DS_DOMAIN_IN_FOREST | DS_DOMAIN_NATIVE_MODE | 
                                     DS_DOMAIN_PRIMARY   | DS_DOMAIN_TREE_ROOT,
                                     &Domains,
                                     &DomainCount);
    //
    // Some of the below code might be unnecessary since DsEnumerateTrusts will no
    // longer return domains from other forests. Shouldn't do any harm though..
    //

    if ((0 == l) && (DomainCount > 0))
    {
        // sort the list of domains alphabetically
        ULONG * rgSorted = new ULONG[DomainCount];
        if (rgSorted)
        {
            ULONG n = DomainCount;
            while (n--)
            {
                rgSorted[n] = n;
            }
            qsort(rgSorted, DomainCount, sizeof (ULONG), CompareDomainInfo);

            // Build a working list of the domains, sorted alphabetically in
            // INVERTED order.

            WORKING_LIST_EL * pWorkList = NULL;

            LOOKDATA ** rgDataMap = new LOOKDATA * [DomainCount];
            if (rgDataMap)
            {
                n = 0;
                while (n < DomainCount)
                {
                    WORKING_LIST_EL * pNew = new WORKING_LIST_EL;
                    if (pNew)
                    {
                        pNew->index = rgSorted[n];
                        pNew->pNext = pWorkList;
                        pWorkList = pNew;
                    }
                    rgDataMap[n] = NULL;
                    n++;
                }

                // Build the ordered tree of domains by removing domains from the
                // working list and inserting them into the new tree until there are
                // none left in the working list.

                // NOTE - if this routine runs out of memory it will begin
                // to drop nodes rather than AV.

                WORKING_LIST_EL ** ppWorker;

                BOOL fContinue = TRUE;
                while (pWorkList && fContinue)
                {
                    fContinue = FALSE;
                    ppWorker = &pWorkList;
                    while (*ppWorker)
                    {
                        if (NULL == Domains[(*ppWorker)->index].DnsDomainName)
                        {
                            //
                            // For now, if it doesn't have a
                            // DnsDomainName then we're going to
                            // skip it.
                            // Eventually we'll want to make sure it doesn't
                            // have a DC by calling DsGetDcName with
                            // DS_DIRECTORY_SERVICE_PREFERRED.

                            // remove it from the worker list
                            WORKING_LIST_EL * pNext = (*ppWorker)->pNext;
                            delete *ppWorker;
                            *ppWorker = pNext;
                        }
                        else
                        {
                            // Does this node have a parent?
                            ULONG flags = Domains[(*ppWorker)->index].Flags;
                            if ((0 != (flags & DS_DOMAIN_IN_FOREST)) && (0 == (flags & DS_DOMAIN_TREE_ROOT)))
                            {
                                // it has a parent has its parent been added?
                                LOOKDATA * pParent = rgDataMap[Domains[(*ppWorker)->index].ParentIndex];
                                if (pParent != NULL)
                                {
                                    // its parent has been added
                                    // insert this one in its parent's child list
                                    LOOKDATA * pData = new LOOKDATA;
                                    if (pData)
                                    {

                                        WCHAR * szName = Domains[(*ppWorker)->index].DnsDomainName;
                                        if (!szName)
                                        {
                                            szName = Domains[(*ppWorker)->index].NetbiosDomainName;
                                        }
                                        pData->szName = new WCHAR[wcslen(szName) + 1];
                                        if (pData->szName)
                                        {
                                            int cch = 0;
                                            int n=0;
                                            // count the dots in szName;
                                            while (szName[n])
                                            {
                                                if (L'.' == szName[n])
                                                {
                                                    cch++;
                                                }
                                                n++;
                                            }
                                            cch *= 3; // multiply the number of dots by 3;
                                            cch += 11; // add 10 + 1 (for the null)
                                            cch += n; // add the string size;
                                            pData->szData = new WCHAR[cch];
                                            if (pData->szData)
                                            {
                                                NameToPath(pData->szData, szName, cch);
                                                wcscpy(pData->szName, szName);
                                                pData->nIndent = pParent->nIndent+1;
                                                pData->nType = ITEMTYPE_DOMAIN;
                                                pData->pParent = pParent;
                                                pData->pSibling = pParent->pChild;
                                                pData->pChild = NULL;
                                                pParent->pChild = pData;
                                                rgDataMap[(*ppWorker)->index] = pData;
                                                // make sure we remember
                                                // that we added something
                                                // to the master list (helps
                                                // us avoid infinite loops
                                                // in case of an error)
                                                fContinue = TRUE;
                                            }
                                            else
                                            {
                                                delete [] pData->szName;
                                                delete pData;
                                            }
                                        }
                                        else
                                        {
                                            delete pData;
                                        }
                                    }
                                    // and remove it from the worker list
                                    WORKING_LIST_EL * pNext = (*ppWorker)->pNext;
                                    delete *ppWorker;
                                    *ppWorker = pNext;
                                }
                                else
                                {
                                    // skip it for now
                                    ppWorker = &((*ppWorker)->pNext);
                                }
                            }
                            else
                            {
                                // it doesn't have a parent add it just under the forest
                                // level of the list
                                LOOKDATA * pData = new LOOKDATA;
                                if (pData)
                                {
                                    WCHAR * szName = Domains[(*ppWorker)->index].DnsDomainName;
                                    if (!szName)
                                    {
                                        szName = Domains[(*ppWorker)->index].NetbiosDomainName;
                                    }
                                    pData->szName = new WCHAR[wcslen(szName) + 1];
                                    if (pData->szName)
                                    {
                                        int cch = 0;
                                        int n=0;
                                        // count the dots in szName;
                                        while (szName[n])
                                        {
                                            if (L'.' == szName[n])
                                            {
                                                cch++;
                                            }
                                            n++;
                                        }
                                        cch *= 3; // multiply the number of dots by 3;
                                        cch += 11; // add 10 + 1 for the null
                                        cch += n; // add the string size;
                                        pData->szData = new WCHAR[cch];
                                        if (pData->szData)
                                        {
                                            NameToPath(pData->szData, szName, cch);
                                            wcscpy(pData->szName, szName);
#if FGPO_SUPPORT
                                            pData->nIndent = 1;
                                            pData->nType = ITEMTYPE_DOMAIN;
                                            pData->pParent = pDomainList;
                                            pData->pSibling = pDomainList->pChild;
                                            pData->pChild = NULL;
                                            pDomainList->pChild = pData;
#else
                                            pData->nIndent = 0;
                                            pData->nType = ITEMTYPE_DOMAIN;
                                            pData->pParent = NULL;
                                            pData->pSibling = pDomainList;
                                            pData->pChild = NULL;
                                            pDomainList = pData;
#endif
                                            rgDataMap[(*ppWorker)->index] = pData;
                                            // make sure we remember
                                            // that we added something
                                            // to the master list (helps
                                            // us avoid infinite loops
                                            // in case of an error)
                                            fContinue = TRUE;
                                        }
                                        else
                                        {
                                            delete [] pData->szName;
                                            delete pData;
                                        }
                                    }
                                    else
                                    {
                                        delete pData;
                                    }
                                }
                                // and remove it from the worker list
                                WORKING_LIST_EL * pNext = (*ppWorker)->pNext;
                                delete *ppWorker;
                                *ppWorker = pNext;
                            }

                        }
                    }
                }
                delete [] rgDataMap;
            }
            delete [] rgSorted;
        }
        NetApiBufferFree(Domains);
    }
    else
    {
        if (0 != l)
        {
            DebugMsg((DM_WARNING, TEXT("DsEnumerateDomainTrustsW failed with %u"), l));
        }
    }
    return pDomainList;
}

VOID FreeDomainInfo (LOOKDATA * pEntry)
{

    if (!pEntry)
    {
        return;
    }

    if (pEntry->pChild)
    {
        FreeDomainInfo (pEntry->pChild);
    }

    if (pEntry->pSibling)
    {
        FreeDomainInfo (pEntry->pSibling);
    }

    delete [] pEntry->szName;
    delete pEntry;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::FillDomainList
//
//  Synopsis:   Fills the combobox with the trusted domain information.
//              The szData member of the combobox element structure is the
//              LDAP domain name.
//
//  Returns:    TRUE - successful
//              FALSE - error
//
//  History:    04-30-1998   stevebl   Modified from original version
//                                     written by EricFlo
//              10-20-1998   stevebl   Heavily modified to support domains
//                                     "outside the forest" and to fix a
//                                     whole passle o' bugs.
//
//  Note:       This routine also sets the focus to the domain of the object
//              passed in via the lpInitialOU member of the GPOBROWSEINFO
//              structure.
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::FillDomainList ()
{
    BOOL bResult = TRUE;
    HRESULT hr;
    DWORD dwIndex;
    BOOL fEnableBackbutton = FALSE;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    WCHAR * szBuffer1 = NULL;
    if (m_pGBI->lpInitialOU)
    {
        if (IsForest(m_pGBI->lpInitialOU))
        {
            szBuffer1 = new TCHAR[128];
            LoadStringW(g_hInstance, IDS_FOREST, szBuffer1, 128);
        }
        else
        {
            WCHAR * sz = GetDomainFromLDAPPath(m_pGBI->lpInitialOU);
            if (sz)
            {
                szBuffer1 = new WCHAR[wcslen(sz) + 1];
                if (szBuffer1)
                {
                    CopyAsFriendlyName(szBuffer1, sz);
                }
                delete [] sz;
            }
        }
    }

    LOOKDATA * pDomainList = BuildDomainList(m_szServerName);

    if (!pDomainList)
    {
        ReportError(m_hwndDlg, GetLastError(), IDS_DOMAINLIST);
    }

    // Walk the ordered tree of domains, inserting each one into the
    // dialog box

    DWORD dwInitialDomain = -1;

    // start at the head
    while (pDomainList)
    {
        WCHAR * szBuffer2 = NULL;
        // add this node
        dwIndex = (DWORD)SendMessage(m_hCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM)(LPCTSTR) pDomainList);
        szBuffer2 = new WCHAR[wcslen(pDomainList->szData) + 1];
        if (szBuffer2)
        {
            CopyAsFriendlyName(szBuffer2, pDomainList->szData);
        }
        if (NULL != szBuffer1 && NULL !=szBuffer2 && 0 ==_wcsicmp(szBuffer1, szBuffer2))
        {
            // replace the domain path with the path provided by the caller
            // (because it contains the server)

            WCHAR * sz = GetDomainFromLDAPPath(m_pGBI->lpInitialOU);
            if (sz)
            {
                DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::FillDomainList: Resetting domain path to user specified path: %s"), sz));
                delete [] pDomainList->szData;
                pDomainList->szData = sz;
            }
            dwInitialDomain = dwIndex;
            if (pDomainList->nIndent > 0)
                fEnableBackbutton = TRUE;
        }
        if (szBuffer2)
        {
            delete [] szBuffer2;
        }

        if (pDomainList->pChild)
        {
            // go to its child
            pDomainList = pDomainList->pChild;
        }
        else
        {
            if (pDomainList->pSibling)
            {
                // go to its sibling if there are no children
                pDomainList = pDomainList->pSibling;
            }
            else
            {
                // there are no children and no siblings
                // back up until we find a parent with a sibling
                // or there are no more parents (we're done)
                do
                {
                    pDomainList = pDomainList->pParent;
                    if (pDomainList)
                    {
                        if (pDomainList->pSibling)
                        {
                            pDomainList = pDomainList->pSibling;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                } while (TRUE);
            }
        }
    }
    if (szBuffer1)
    {
        delete [] szBuffer1;
    }

    if (-1 == dwInitialDomain)
    {
        // didn't find the initial domain anywhere in that list
        // Set the first entry by default
        dwInitialDomain = 0;
    }

    SendMessage (m_hCombo, CB_SETCURSEL, dwInitialDomain, 0);
    SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(fEnableBackbutton, 0));
    SetCursor(hcur);
    return bResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::SetInitialOU
//
//  Synopsis:   Adds nodes to the combobox until the initial OU specified by
//              the caller via the lpInitalOU member of the GPOBROWSEINFO
//              structure is present and gives it the focus.
//
//  Returns:    TRUE - success
//
//  History:    10-20-1998   stevebl   Created
//
//  Notes:      This routine assumes that FillDomainList() was just called.
//              It will not work properly otherwise.
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::SetInitialOU()
{
    if (!m_pGBI->lpInitialOU)
    {
        // nothing requested so nothing required
        return TRUE;
    }
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::SetInitialOU: No object selected.")));
         return FALSE;
    }

    // get the current object to see what's selected
    LOOKDATA * pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdataSelected)
    {
        // is it the same as the requested object?
        WCHAR * szSelected = NULL;
        WCHAR * szRequested = NULL;
        szSelected = new WCHAR[wcslen(pdataSelected->szData) + 1];
        if (szSelected)
        {
            CopyAsFriendlyName(szSelected, pdataSelected->szData);
        }
        szRequested = new WCHAR[wcslen(m_pGBI->lpInitialOU + 1)];
        if (NULL != szSelected && NULL != szRequested && 0 != wcscmp(szSelected, szRequested))
        {
            // it's not the same
            // try and bind to the requested object
            IADs * pADs = NULL;
            HRESULT hr = OpenDSObject(m_pGBI->lpInitialOU,
                                       IID_IADs, (void **)&pADs);
            if (SUCCEEDED(hr))
            {
                // the requested object exists and we have access permission

                // now make sure that it's a domain or OU
                BOOL fDomainOrOU = FALSE;
                VARIANT var;
                VariantInit(&var);
                BSTR bstrProperty = SysAllocString(L"objectClass");

                if (bstrProperty)
                {
                    hr = pADs->Get(bstrProperty, &var);
                    if (SUCCEEDED(hr))
                    {
                        int cElements = var.parray->rgsabound[0].cElements;
                        VARIANT * rgData = (VARIANT *)var.parray->pvData;
                        while (cElements--)
                        {
                            if (0 == _wcsicmp(L"domain", rgData[cElements].bstrVal))
                            {
                                fDomainOrOU = TRUE;
                            }
                            if (0 == _wcsicmp(L"organizationalUnit", rgData[cElements].bstrVal))
                            {
                                fDomainOrOU = TRUE;
                            }
                        }
                    }
                    SysFreeString(bstrProperty);
                }
                VariantClear(&var);
                pADs->Release();

                if (fDomainOrOU)
                {
                    LOOKDATA * pLast = NULL;
                    LOOKDATA * pNew = NULL;

                    // build a list of nodes
                    // repeat removing leaf nodes until we're down to the domain
                    // (which will be the same as the selected object)
                    IADsPathname * pADsPathname = NULL;
                    BSTR bstr;
                    hr = CoCreateInstance(CLSID_Pathname,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IADsPathname,
                                          (LPVOID*)&pADsPathname);

                    if (SUCCEEDED(hr))
                    {
                        hr = pADsPathname->Set(m_pGBI->lpInitialOU, ADS_SETTYPE_FULL);
                        if (SUCCEEDED(hr))
                        {
                            while (TRUE)
                            {
                                // add this node to the list
                                hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
                                if (FAILED(hr))
                                {
                                    break;
                                }

                                if (szRequested)
                                {
                                    delete [] szRequested;
                                }
                                szRequested = new WCHAR[wcslen(bstr) + 1];
                                if (szRequested)
                                {
                                    CopyAsFriendlyName(szRequested, bstr);
                                }
                                if (NULL != szRequested && 0 == wcscmp(szSelected, szRequested))
                                {
                                    // we're back to the first node
                                    SysFreeString(bstr);
                                    break;
                                }

                                pNew = new LOOKDATA;
                                if (!pNew)
                                {
                                    // ran out of memory
                                    SysFreeString(bstr);
                                    break;
                                }

                                pNew->szName  = new WCHAR[wcslen(szRequested) + 1];
                                if (!pNew->szName)
                                {
                                    // ran out of memory
                                    delete pNew;
                                    SysFreeString(bstr);
                                    break;
                                }
                                pNew->szData = new WCHAR[wcslen(bstr) + 1];
                                if (!pNew->szData)
                                {
                                    // ran out of memory
                                    delete [] pNew->szName;
                                    delete pNew;
                                    SysFreeString(bstr);
                                    break;
                                }
                                wcscpy(pNew->szData, bstr);
                                wcscpy(pNew->szName, szRequested);
                                SysFreeString(bstr);
                                pNew->nIndent = 0;
                                pNew->nType = ITEMTYPE_OU;
                                pNew->pParent = NULL;
                                pNew->pSibling = NULL;
                                pNew->pChild = pLast;
                                if (pLast)
                                {
                                    pLast->pParent = pNew;
                                }
                                pLast = pNew;

                                // strip off a leaf node and go again

                                hr = pADsPathname->RemoveLeafElement();
                                if (FAILED(hr))
                                {
                                    break;
                                }
                            }
                        }
                        pADsPathname->Release();
                    }

                    // At this point I should have a list of LOOKDATA nodes
                    // (in pLast).
                    // The only things left to do are to link them into the
                    // tree, set their nIndent members, add them to the combo
                    // box and set the combo box's focus to the last one.

                    if (pLast)
                    {
                        // link in the list
                        pLast->pSibling = pdataSelected->pChild;
                        pLast->pParent = pdataSelected;
                        pLast->nIndent = pdataSelected->nIndent+1;
                        pdataSelected->pChild = pLast;
                        // now walk the tree, adding entries to the combo box
                        // and updating the nIndent members
                        while (pLast)
                        {
                            iIndex = (int)SendMessage(m_hCombo, CB_INSERTSTRING, iIndex+1, (LPARAM)(LPCTSTR) pLast);

                            if (pLast->pChild)
                            {
                                pLast->pChild->nIndent = pLast->nIndent+1;
                            }
                            pLast = pLast->pChild;
                        }
                        if (iIndex != CB_ERR)
                        {
                            SendMessage(m_hCombo, CB_SETCURSEL, iIndex, 0);
                            SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(TRUE, 0));
                        }
                    }
                }
            }
        }
        if (szSelected)
        {
            delete [] szSelected;
        }
        if (szRequested)
        {
            delete [] szRequested;
        }
    }
    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::GetCurrentObject
//
//  Synopsis:   returns the LDAP path to the currently selected object
//
//  Arguments:  [] -
//
//  Returns:    NULL if no ojbect is selected else the LDAP path of the object
//
//  Modifies:
//
//  Derivation:
//
//  History:    5-05-1998   stevebl   Created
//              06-23-1999   stevebl   Added logic to give DCs names
//
//  Notes:
//              Checks to see if a domain has a named server.  If it doesn't
//              then it calls GetDCName to get it one.
//
//---------------------------------------------------------------------------

LPOLESTR CBrowserPP::GetCurrentObject()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetCurrentObject: No object selected.")));
         return NULL;
    }

    LPOLESTR sz=NULL;
    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdata)
    {
        if (pdata->szData)
        {
            if (ITEMTYPE_DOMAIN == pdata->nType)
            {
                // make sure that domains are resolved to a server
                LPTSTR szServer = ExtractServerName(pdata->szData);
                if (NULL == szServer)
                {
                    LPWSTR szTemp = GetDCName(pdata->szName, NULL, NULL, TRUE, 0);
                    if (szTemp)
                    {
                        LPWSTR szFullPath = MakeFullPath(pdata->szData, szTemp);
                        if (szFullPath)
                        {
                            LPWSTR sz = new WCHAR[wcslen(szFullPath)+1];
                            if (sz)
                            {
                                wcscpy(sz, szFullPath);
                                delete [] pdata->szData;
                                pdata->szData = sz;
                            }
                            LocalFree(szFullPath);
                        }
                        LocalFree(szTemp);
                    }
                    else
                    {
                        return NULL;
                    }
                }
                else
                {
                    LocalFree(szServer);
                }
            }
            sz = new OLECHAR[wcslen(pdata->szData) + 1];
            if (sz)
            {
                wcscpy(sz, pdata->szData);
            }
        }
    }
    return sz;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::IsCurrentObjectAForest
//
//  Synopsis:   tests to see if the currently selected object is a forest
//
//  Arguments:  [] -
//
//  Returns:    TRUE  - if it is a forest
//              FALSE - otherwise
//
//  History:    03-31-2000   stevebl   Created
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::IsCurrentObjectAForest()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::IsCurrentObjectAForest: No object selected.")));
         return FALSE;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    return (ITEMTYPE_FOREST == pdata->nType);
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::GetCurrentDomain
//
//  Synopsis:   returns the domain of the currently selecte object (if the
//              currently currently selected object is the domain then they
//              are one and the same)
//
//  Arguments:  [] -
//
//  Returns:    NULL - if no object is selected else returns LDAP path of
//              domain
//
//  History:    05-04-1998   stevebl   Created
//              06-23-1999   stevebl   Added logic to give DCs names
//
//  Notes:      Checks to see if a domain has a named server.  If it doesn't
//              then it calls GetDCName to get it one.
//
//---------------------------------------------------------------------------

LPOLESTR CBrowserPP::GetCurrentDomain()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetCurrentDomain: No object selected.")));
         return NULL;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    switch (pdata->nType)
    {
    case ITEMTYPE_DOMAIN:
        {
            if (pdata->szData)
            {
                // make sure the domain has a server
                LPTSTR szServer = ExtractServerName(pdata->szData);
                if (NULL == szServer)
                {
                    LPWSTR szTemp = GetDCName(pdata->szName, NULL, NULL, TRUE, 0);
                    if (szTemp)
                    {
                        LPWSTR szFullPath = MakeFullPath(pdata->szData, szTemp);
                        if (szFullPath)
                        {
                            LPWSTR sz = new WCHAR[wcslen(szFullPath)+1];
                            if (sz)
                            {
                                wcscpy(sz, szFullPath);
                                delete [] pdata->szData;
                                pdata->szData = sz;
                            }
                            LocalFree(szFullPath);
                        }
                        LocalFree(szTemp);
                    }
                    else
                    {
                        return NULL;
                    }
                }
                else
                {
                    LocalFree(szServer);
                }
                LPOLESTR sz = new OLECHAR[wcslen(pdata->szData)+1];
                if (sz)
                {
                    wcscpy(sz, pdata->szData);
                }
                return sz;
            }
            return NULL;
        }
    case ITEMTYPE_FOREST:
    case ITEMTYPE_SITE:
    case ITEMTYPE_OU:
        {
            return GetDomainFromLDAPPath(pdata->szData);
        }
        break;
    default:
        break;
    }
    return NULL;
}

BOOL CBrowserPP::AddGPOsLinkedToObject()
{
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPOLESTR lpObject;
    HRESULT hr;
    IADs * pADs = NULL;
    IADs * pADsGPO;
    VARIANT var;
    BSTR bstrProperty;
    BOOL fResult = FALSE;
    int index = ListView_GetItemCount(m_hList);

    //
    // Get the current object name
    //
    lpObject = GetCurrentObject();
    if (NULL == lpObject)
    {
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("CBrowserPP::AddGPOsLinkedToObject: Reading gPLink property from %s"), lpObject));

    hr = OpenDSObject(lpObject, IID_IADs, (void **)&pADs);

    delete [] lpObject;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: OpenDSObject failed with 0x%x"), hr));
        ReportError(m_hwndDlg, hr, IDS_FAILEDGPLINK);
        goto Exit;
    }

    VariantInit(&var);

    bstrProperty = SysAllocString(GPM_LINK_PROPERTY);

    if (bstrProperty)
    {
        hr = pADs->Get(bstrProperty, &var);

        if (SUCCEEDED(hr))
        {
            LPOLESTR szGPOList = var.bstrVal;
            OLECHAR * pchTemp;
            OLECHAR * pchGPO;
            VARIANT varName;
            BSTR bstrNameProp;

            if (szGPOList)
            {
                OLECHAR * szGPO = new WCHAR[wcslen(szGPOList) + 1];
                if (szGPO)
                {
                    pchTemp = szGPOList;
                    while (TRUE)
                    {
                        // Look for the [
                        while (*pchTemp && (*pchTemp != L'['))
                            pchTemp++;
                        if (!(*pchTemp))
                            break;

                        pchTemp++;

                        // Copy the GPO name
                        pchGPO = szGPO;

                        while (*pchTemp && (*pchTemp != L';'))
                            *pchGPO++ = *pchTemp++;

                        *pchGPO = L'\0';

                        // Add the object to the list view
                        MYLISTEL * pel = new MYLISTEL;
                        if (pel)
                        {

                            pel->szData = NULL;
                            pel->bDisabled = FALSE;

                            LPTSTR szFullGPOPath = GetFullPath(szGPO, m_hwndDlg);

                            if (szFullGPOPath)
                            {
                                pel->szData = new WCHAR[wcslen(szFullGPOPath) + 1];
                                if (pel->szData)
                                {
                                    wcscpy(pel->szData, szFullGPOPath);
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: Failed to allocate memory for new full gpo path")));
                                    LocalFree(szFullGPOPath);
                                    delete pel;
                                    continue;
                                }

                                LocalFree(szFullGPOPath);
                            }
                            else
                            {
                                DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: Failed to get full gpo path")));
                                delete pel;
                                continue;
                            }

                            VariantInit(&varName);

                            // get the friendly display name
                            hr = OpenDSObject(pel->szData, IID_IADs,
                                              (void **)&pADsGPO);

                            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
                            {
                                delete pel;
                                continue;
                            }

                            if (SUCCEEDED(hr))
                            {
                                bstrNameProp = SysAllocString(GPO_NAME_PROPERTY);

                                if (bstrNameProp)
                                {
                                    hr = pADsGPO->Get(bstrNameProp, &varName);
                                    SysFreeString(bstrNameProp);
                                }
                                else
                                {
                                    hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                                }

                                pADsGPO->Release();
                            }

                            if (FAILED(hr))
                            {
                                DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddGPOsLinkedToObject: Couldn't get display name for %s with 0x%x"), pel->szData, hr));
                                pel->szName = new WCHAR[200];
                                if (pel->szName)
                                {
                                    LoadString(g_hInstance, IDS_GPM_NOGPONAME, pel->szName, 200);
                                }
                                pel->bDisabled = TRUE;
                            }
                            else
                            {
                                pel->szName = new WCHAR[wcslen(varName.bstrVal) + 1];
                                if (pel->szName)
                                {
                                    wcscpy(pel->szName, varName.bstrVal);
                                }
                            }

                            VariantClear(&varName);

                            pel->nType = ITEMTYPE_GPO;

                            AddElement(pel, index);
                        }
                    }
                    delete [] szGPO;
                }
            }
        }

        SysFreeString(bstrProperty);
    }

    VariantClear(&var);

    fResult = TRUE;

Exit:
    if (pADs)
    {
        pADs->Release();
    }
    SetCursor(hcur);
    return fResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::AddGPOsForDomain
//
//  Synopsis:   Adds all the GPOs in the specified domain to the list view
//              control.   The szData member of the list element structure
//              contains the LDAP path of the GPO.
//
//              The domain is indicated by the currently selected combobox
//              element.
//
//  Returns:    TRUE - successful
//              FALSE - error
//
//  History:    04-30-1998   stevebl   Modified from original routine
//                                     written by EricFlo.
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::AddGPOsForDomain()
{
    LPTSTR lpDomain;
    LPTSTR lpGPO;
    INT iIndex;
    VARIANT var;
    VARIANT varGPO;
    ULONG ulResult;
    HRESULT hr = E_FAIL;
    IADsPathname * pADsPathname = NULL;
    IADs * pADs = NULL;
    IADsContainer * pADsContainer = NULL;
    IDispatch * pDispatch = NULL;
    IEnumVARIANT *pVar = NULL;
    BSTR bstrContainer = NULL;
    BSTR bstrCommonName = NULL;
    BSTR bstrDisplayName = NULL;
    BSTR bstrGPO = NULL;
    TCHAR szDisplayName[512];
    TCHAR szCommonName[50];
    MYLISTEL * pel;

    //
    // Test to see if we're focused on a forest
    //

    BOOL fForest = IsCurrentObjectAForest();

    //
    // Get the current domain name
    //

    lpDomain = GetCurrentDomain();

    if (!lpDomain)
    {
         DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: NULL domain name.")));
         return FALSE;
    }

    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the domain name
    //

    hr = pADsPathname->Set (lpDomain, ADS_SETTYPE_FULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    if (fForest)
    {
        //
        // Add the configuration folder to the path
        //

        hr = pADsPathname->AddLeafElement (TEXT("CN=Configuration"));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to add system folder with 0x%x"), hr));
            goto Exit;
        }
    }
    else
    {
        //
        // Add the system folder to the path
        //

        hr = pADsPathname->AddLeafElement (TEXT("CN=System"));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to add system folder with 0x%x"), hr));
            goto Exit;
        }
    }


    //
    // Add the policies container to the path
    //

    hr = pADsPathname->AddLeafElement (TEXT("CN=Policies"));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to add policies folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the container path - this is the path to the policies folder
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Release the pathname object
    //

    pADsPathname->Release();
    pADsPathname = NULL;


    //
    // Build an enumerator
    //

    hr = OpenDSObject(bstrContainer, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get gpo container interface with 0x%x for object %s"),
                     hr, bstrContainer));
            ReportError(m_hwndDlg, hr, IDS_FAILEDGPLINK);
        }
        goto Exit;
    }


    hr = ADsBuildEnumerator (pADsContainer, &pVar);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to get enumerator with 0x%x"), hr));
        goto Exit;
    }

    bstrCommonName = SysAllocString (L"cn");

    if (!bstrCommonName)
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }


    bstrDisplayName = SysAllocString (GPO_NAME_PROPERTY);

    if (!bstrDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }


    //
    // Enumerate
    //

    while (TRUE)
    {
        BOOL fNeedDisplayName = FALSE;

        VariantInit(&var);
        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to enumerator with 0x%x"), hr));
            VariantClear (&var);
            break;
        }

        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }


        //
        // If var.vt isn't VT_DISPATCH, we're finished.
        //

        if (var.vt != VT_DISPATCH)
        {
            VariantClear (&var);
            break;
        }


        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get IDispatch interface")));
            goto LoopAgain;
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this GPO.
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Get the display name
        //

        VariantInit(&varGPO);

        hr = pADs->Get(bstrDisplayName, &varGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get display name with 0x%x"),hr));
            fNeedDisplayName = TRUE;
        }
        else
        {
            wcsncpy (szDisplayName, varGPO.bstrVal, (sizeof(szDisplayName) / sizeof(szDisplayName[0])) - 1);
        }

        VariantClear (&varGPO);


        //
        // Get the common name
        //

        VariantInit(&varGPO);

        hr = pADs->Get(bstrCommonName, &varGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("AddGPOsForDomain: Failed to get common name with 0x%x"),hr));
            VariantClear (&varGPO);
            pADs->Release();
            goto LoopAgain;
        }

        lstrcpy (szCommonName, TEXT("CN="));
        lstrcat (szCommonName, varGPO.bstrVal);

        VariantClear (&varGPO);


        //
        // Clean up
        //

        pADs->Release();


        //
        // Create a pathname object so we can tack the common name
        // onto the end of the LDAP path
        //

        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (LPVOID*)&pADsPathname);


        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to create adspathname instance with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Add the LDAP path
        //

        hr = pADsPathname->Set (bstrContainer, ADS_SETTYPE_FULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to set the ldap path with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Add the GPO's common name
        //

        hr = pADsPathname->AddLeafElement (szCommonName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to add the common name with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Retreive the gpo path
        //

        hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to retreive gpo path with 0x%x"), hr));
            goto LoopAgain;
        }


        //
        // Make a copy of it
        //

        lpGPO = new WCHAR[wcslen(bstrGPO) + 1];

        if (!lpGPO)
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: Failed to alloc memory for gpo path with 0x%x"),
                     GetLastError()));
            goto LoopAgain;
        }

        wcscpy (lpGPO, bstrGPO);


        pel = new MYLISTEL;
        if (pel)
        {
            if (fNeedDisplayName)
            {
                pel->szName = new WCHAR[wcslen(lpGPO) + 1];
                if (pel->szName)
                {
                    CopyAsFriendlyName(pel->szName, lpGPO);
                }
            }
            else
            {
                pel->szName = new WCHAR[wcslen(szDisplayName) + 1];
                if (pel->szName)
                {
                    wcscpy(pel->szName, szDisplayName);
                }
            }
            pel->szData = lpGPO;
            pel->nType = ITEMTYPE_GPO;
            pel->bDisabled = FALSE;

            AddElement(pel, -1);
        }

LoopAgain:

        if (pADsPathname)
        {
            pADsPathname->Release();
            pADsPathname = NULL;
        }

        if (bstrGPO)
        {
            SysFreeString (bstrGPO);
            bstrGPO = NULL;
        }

        VariantClear (&var);
    }


    SendMessage (m_hList, LB_SETCURSEL, 0, 0);

Exit:

    if (pVar)
    {
        ADsFreeEnumerator (pVar);
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (pADsContainer)
    {
        pADsContainer->Release();
    }

    if (bstrContainer)
    {
        SysFreeString (bstrContainer);
    }

    if (bstrCommonName)
    {
        SysFreeString (bstrCommonName);
    }

    if (bstrDisplayName)
    {
        SysFreeString (bstrDisplayName);
    }

    if (lpDomain)
    {
        delete [] lpDomain;
    }

    SetCursor(hcur);

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::AddChildContainers
//
//  Synopsis:   Adds the child domains and OUs for the currently selected object
//
//  History:    05-006-1998   stevebl   Created
//
//---------------------------------------------------------------------------

BOOL CBrowserPP::AddChildContainers()
{
    LPOLESTR szObject = NULL;
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddChildContainers: No object selected.")));
         return FALSE;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdata)
    {
        if (ITEMTYPE_DOMAIN == pdata->nType)
        {
            // make sure that domains are resolved to a server
            LPTSTR szServer = ExtractServerName(pdata->szData);
            if (NULL == szServer)
            {
                BOOL bDCFound = FALSE;
                LPWSTR szTemp = GetDCName(pdata->szName, NULL, NULL, TRUE, 0);
                if (szTemp)
                {
                    LPWSTR szFullPath = MakeFullPath(pdata->szData, szTemp);
                    if (szFullPath)
                    {
                        LPWSTR sz = new WCHAR[wcslen(szFullPath)+1];
                        if (sz)
                        {
                            wcscpy(sz, szFullPath);
                            delete [] pdata->szData;
                            pdata->szData = sz;
                            bDCFound = TRUE;
                        }
                        LocalFree(szFullPath);
                    }
                    LocalFree(szTemp);
                }

                if (!bDCFound)
                {
                    DebugMsg((DM_WARNING, TEXT("CBrowserPP::AddChildContainers: Failed to get a DC name for %s"),
                              pdata->szName));
                    return FALSE;
                }
            }
            else
            {
                LocalFree(szServer);
            }
        }
        LOOKDATA * pChild = pdata->pChild;
        while (pChild)
        {
            // Add child domains this way since ADsEnumerateNext doesn't
            // seem to be giving them to us.
            if (ITEMTYPE_DOMAIN == pChild->nType)
            {
                // got something we can work with
                MYLISTEL * pel = new MYLISTEL;
                if (pel)
                {
                    memset(pel, 0, sizeof(MYLISTEL));
                    pel->szData = new OLECHAR[wcslen(pChild->szData) + 1];
                    if (pel->szData)
                    {
                        wcscpy(pel->szData, pChild->szData);
                    }
                    pel->szName = new OLECHAR[wcslen(pChild->szName) +  1];
                    if (pel->szName)
                    {
                        wcscpy(pel->szName, pChild->szName);
                    }
                    pel->bDisabled = FALSE;
                    pel->nType = ITEMTYPE_DOMAIN;
                    INT index = -1;
                    AddElement(pel, -1);
                }
                pChild = pChild->pSibling;
            }

        }
        szObject = pdata->szData;
        m_pPrevSel = pdata;
    } else {
        m_pPrevSel = NULL;
    }

    if ( ! szObject )
    {
        return FALSE;
    }

    HRESULT hr;
    IADsContainer * pADsContainer;

    hr = OpenDSObject(szObject, IID_IADsContainer, (void **)&pADsContainer);

    if (SUCCEEDED(hr))
    {
        IEnumVARIANT *pVar;
        hr = ADsBuildEnumerator(pADsContainer, &pVar);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            ULONG ulResult;

            while (SUCCEEDED(ADsEnumerateNext(pVar, 1, &var, &ulResult)))
            {
                if (0 == ulResult)
                {
                    break;
                }
                if (var.vt == VT_DISPATCH)
                {
                    // query for the IADs interface so we can get its properties
                    IADs * pDSObject;
                    hr = var.pdispVal->QueryInterface(IID_IADs, (LPVOID *)&pDSObject);
                    if (SUCCEEDED(hr))
                    {
                        BSTR bstr;
                        DWORD dwType = -1;
                        hr = pDSObject->get_Class(&bstr);
                        if (SUCCEEDED(hr))
                        {
                            if (0 == wcscmp(bstr, CLASSNAME_OU))
                            {
                                dwType = ITEMTYPE_OU;
                            }
                            else if (0 == wcscmp(bstr, CLASSNAME_DOMAIN))
                            {
                                dwType = ITEMTYPE_DOMAIN;
                            }
                            SysFreeString(bstr);
                        }
                        if (ITEMTYPE_DOMAIN == dwType || ITEMTYPE_OU == dwType)
                        {
                            // got something we can work with
                            MYLISTEL * pel = new MYLISTEL;
                            if (pel)
                            {
                                memset(pel, 0, sizeof(MYLISTEL));
                                hr = pDSObject->get_ADsPath(&bstr);
                                if (SUCCEEDED(hr))
                                {
                                    pel->szData = new OLECHAR[wcslen(bstr) + 1];
                                    if (pel->szData)
                                    {
                                        wcscpy(pel->szData, bstr);
                                    }
                                    pel->szName = new OLECHAR[wcslen(bstr) +  1];
                                    if (pel->szName)
                                    {
                                        // Need to convert to a friendly name.
                                        CopyAsFriendlyName(pel->szName, bstr);
                                    }
                                    SysFreeString(bstr);
                                }
                                pel->nType = dwType;
                                INT index = -1;
                                AddElement(pel, -1);
                            }
                        }
                        pDSObject->Release();
                    }
                }
                VariantClear(&var);
            }

            ADsFreeEnumerator(pVar);
        }

        pADsContainer->Release();
    }

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::RefreshDomains
//
//  Synopsis:   refreshes the listview for the "domains" page
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void CBrowserPP::RefreshDomains()
{
    LONG lStyle;

    ListView_DeleteAllItems(m_hList);

    lStyle = GetWindowLong (m_hList, GWL_STYLE);
    lStyle &= ~LVS_SORTASCENDING;
    SetWindowLong (m_hList, GWL_STYLE, lStyle);

    if (AddChildContainers())
    {
        AddGPOsLinkedToObject();
        EnableWindow (m_hList, TRUE);
        if (!(m_pGBI->dwFlags & GPO_BROWSE_DISABLENEW)) {
            SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(1, 0));
        }
    }
    else
    {
        EnableWindow (m_hList, FALSE);
        SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(0, 0));
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::RefreshSites
//
//  Synopsis:   refreshes the listview for the "sites" page
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void CBrowserPP::RefreshSites()
{
    LONG lStyle;

    ListView_DeleteAllItems(m_hList);

    lStyle = GetWindowLong (m_hList, GWL_STYLE);
    lStyle &= ~LVS_SORTASCENDING;
    SetWindowLong (m_hList, GWL_STYLE, lStyle);

    AddGPOsLinkedToObject();
}

//+--------------------------------------------------------------------------
//
//  Member:     CBrowserPP::RefreshAll
//
//  Synopsis:   refreshes the listview for the "all" page
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void CBrowserPP::RefreshAll()
{
    LONG lStyle;

    ListView_DeleteAllItems(m_hList);

    lStyle = GetWindowLong (m_hList, GWL_STYLE);
    lStyle |= LVS_SORTASCENDING;
    SetWindowLong (m_hList, GWL_STYLE, lStyle);

    if (AddGPOsForDomain())
    {
        EnableWindow (m_hList, TRUE);
        SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(1, 0));
    }
    else
    {
        EnableWindow (m_hList, FALSE);
        SendMessage (m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_NEWFOLDER, (LPARAM) MAKELONG(0, 0));
    }

}

void CBrowserPP::SetButtonState()
{
    if (ListView_GetNextItem (m_hList, -1, LVNI_ALL | LVNI_SELECTED) != -1)
    {
        EnableWindow (GetDlgItem(GetParent(m_hwndDlg), IDOK), TRUE);
    }
    else
    {
        EnableWindow (GetDlgItem(GetParent(m_hwndDlg), IDOK), FALSE);
    }
}

BOOL CBrowserPP::OnInitDialog()
{
    DWORD dwDescription;
    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        dwDescription = IDS_DOMAINDESCRIPTION;
        break;
    case PAGETYPE_SITES:
        dwDescription = IDS_SITEDESCRIPTION;
        break;
    case PAGETYPE_ALL:
    default:
        dwDescription = IDS_ALLDESCRIPTION;
        break;
    }
    WCHAR szDescription[MAX_PATH];  // this is a resource - size doesn't need to be dynamic
    LoadString(g_hInstance, dwDescription, szDescription, MAX_PATH);
    SetDlgItemText(m_hwndDlg, IDC_DESCRIPTION, szDescription);

    m_hList = GetDlgItem(m_hwndDlg, IDC_LIST1);
    m_ilSmall = ImageList_LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16), SMALLICONSIZE, 0, RGB(255,0,255));
    m_ilLarge = ImageList_LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32), LARGEICONSIZE, 0, RGB(255, 0 ,255));
    m_hCombo = GetDlgItem(m_hwndDlg, IDC_COMBO1);

    RECT rect;
    GetClientRect(m_hList, &rect);
    WCHAR szText[32];
    int dxScrollBar = GetSystemMetrics(SM_CXVSCROLL);
    if (PAGETYPE_ALL == m_dwPageType)
    {
        LV_COLUMN lvcol;
        memset(&lvcol, 0, sizeof(lvcol));
        lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvcol.fmt = LVCFMT_LEFT;
        lvcol.cx = (rect.right - rect.left) - dxScrollBar;
        LoadString(g_hInstance, IDS_NAMECOLUMN, szText, 32);
        lvcol.pszText = szText;
        ListView_InsertColumn(m_hList, 0, &lvcol);
    }
    else
    {
        LV_COLUMN lvcol;
        memset(&lvcol, 0, sizeof(lvcol));
        lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvcol.fmt = LVCFMT_LEFT;
        int cx = ((rect.right - rect.left) - dxScrollBar)*2/3;
        lvcol.cx = cx;
        LoadString(g_hInstance, IDS_NAMECOLUMN, szText, 32);
        lvcol.pszText = szText;
        ListView_InsertColumn(m_hList, 0, &lvcol);
        memset(&lvcol, 0, sizeof(lvcol));
        lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvcol.fmt = LVCFMT_LEFT;
        lvcol.cx = ((rect.right - rect.left) - dxScrollBar) - cx;
        LoadString(g_hInstance, IDS_DOMAINCOLUMN, szText, 32);
        lvcol.pszText = szText;
        ListView_InsertColumn(m_hList, 1, &lvcol);
    }
    ListView_SetImageList(m_hList, m_ilSmall, LVSIL_SMALL);
    ListView_SetImageList(m_hList, m_ilLarge, LVSIL_NORMAL);
    SendMessage(m_hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_LABELTIP);

    GetWindowRect(GetDlgItem(m_hwndDlg, IDC_STATIC1), &rect);
    MapWindowPoints(NULL , m_hwndDlg, (LPPOINT) &rect , 2);

    TBBUTTON rgButtons[3];
    rgButtons[0].iBitmap = 0;
    rgButtons[0].idCommand = ID_BACKBUTTON;
    rgButtons[0].fsState = 0;       // this button will be disabled by
                                    // default and only enabled when there
                                    // is something to back up to
    //rgButtons[0].fsState = PAGETYPE_ALL == m_dwPageType ? 0 : TBSTATE_ENABLED;
    rgButtons[0].fsStyle = TBSTYLE_BUTTON;
    rgButtons[0].dwData = 0;
    rgButtons[0].iString = 0;

    rgButtons[1].iBitmap = 1;
    rgButtons[1].idCommand = ID_NEWFOLDER;
    rgButtons[1].fsStyle = TBSTYLE_BUTTON;
    rgButtons[1].dwData = 0;
    rgButtons[1].iString = 0;

    if (PAGETYPE_ALL != m_dwPageType)
    {
        if (m_pGBI->dwFlags & GPO_BROWSE_DISABLENEW)
        {
            rgButtons[1].fsState = 0;
        }
        else
        {
            rgButtons[1].fsState =  TBSTATE_ENABLED;
        }
    }
    else
    {
        rgButtons[1].fsState =TBSTATE_ENABLED;
    }

    rgButtons[2].iBitmap = 2;
    rgButtons[2].idCommand = ID_ROTATEVIEW;
    rgButtons[2].fsState = TBSTATE_ENABLED ;
    rgButtons[2].fsStyle = TBSTYLE_DROPDOWN;
    rgButtons[2].dwData = 0;
    rgButtons[2].iString = 0;
    m_toolbar = CreateToolbarEx(m_hwndDlg,
                                WS_CHILD | WS_VISIBLE | CCS_NODIVIDER | CCS_NORESIZE | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS,
                                IDR_TOOLBAR1,
                                4,
                                g_hInstance,
                                IDR_TOOLBAR1,
                                rgButtons,
                                3,
                                BUTTONSIZE,
                                BUTTONSIZE,
                                BUTTONSIZE,
                                BUTTONSIZE,
                                sizeof(TBBUTTON));
    SendMessage(m_toolbar, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);
    MoveWindow(m_toolbar, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top, FALSE);

// Don't need to call Refresh in any of these because we're calling it in
// OnComboChange().

    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        FillDomainList();
        SetInitialOU();
//        RefreshDomains();
        break;
    case PAGETYPE_SITES:
        SendMessage(m_hCombo, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);
        FillSitesList();
//        RefreshSites();
        break;
    default:
    case PAGETYPE_ALL:
        SendMessage(m_hCombo, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);
        FillDomainList();
//        RefreshAll();
        break;
    }

    SetButtonState();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CBrowserPP::DoBackButton()
{
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);

    if (iIndex == CB_ERR)
    {
         DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoBackButton: No object selected.")));
         return FALSE;
    }

    LOOKDATA * pdata = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
    if (pdata)
    {
        if (pdata->pParent)
        {
            // if this item has a parent then select it
            SendMessage(m_hCombo, CB_SELECTSTRING, (WPARAM)-1,  (LPARAM) (LPCTSTR) pdata->pParent);

            // force everything to refresh
            OnComboChange();
        }
    }
    return FALSE;
}

BOOL CBrowserPP::DeleteGPO()
{
    BOOL fSucceeded = FALSE;
    BOOL fRemoveListEntry = FALSE;

    int index = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    if (-1 == index)
    {
        return FALSE;
    }

    LVITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_PARAM;
    item.iItem = index;
    ListView_GetItem(m_hList, &item);
    MYLISTEL * pel = (MYLISTEL *)item.lParam;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;
    WCHAR szBuffer[100];
    WCHAR szConfirm[MAX_FRIENDLYNAME + 100];
    WCHAR szTitle[100];


    if (pel->nType != ITEMTYPE_GPO)
    {
        goto CleanUp;
    }


    LoadString(g_hInstance, IDS_CONFIRMTITLE, szTitle, 100);
    LoadString(g_hInstance, IDS_DELETECONFIRM, szBuffer, 100);
    wsprintf (szConfirm, szBuffer, pel->szName);

    if (IDNO == MessageBox(m_hwndDlg, szConfirm, szTitle, MB_YESNO | MB_ICONEXCLAMATION))
    {
        goto CleanUp;
    }


    // If we're on any page other than the "All" page then we need to break
    // the association before we can delete the object.
    if (m_dwPageType != PAGETYPE_ALL)
    {
        // break the association
        LPOLESTR szContainer = GetCurrentObject();
        if (szContainer)
        {
            DeleteLink(pel->szData, szContainer);
            delete [] szContainer;
        }
    }

    hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CoCreateInstance failed with 0x%x\r\n"), hr));
        goto Done;
    }


    // open GPO object without opening registry data
    hr = pGPO->OpenDSGPO(pel->szData, 0);
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDDS);
        DebugMsg((DM_WARNING, TEXT("OpenDSGPO failed with 0x%x\r\n"), hr));
        goto Done;
    }

    // delete it
    hr = pGPO->Delete();
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDDELETE);
        DebugMsg((DM_WARNING, TEXT("Delete failed with 0x%x\r\n"), hr));
        goto Done;
    }
    fRemoveListEntry = TRUE;

Done:
    if (pGPO)
    {
        pGPO->Release();
    }


    // remove the list entry
    if (fRemoveListEntry)
        fSucceeded = ListView_DeleteItem(m_hList, index);
CleanUp:

    return fSucceeded;
}

BOOL CBrowserPP::DoNewGPO()
{
    BOOL fSucceeded = FALSE;
    HRESULT hr;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    BOOL fEdit = FALSE;
    MYLISTEL * pel = NULL;
    LPOLESTR szObject = GetCurrentObject();
    LPOLESTR szDomain = GetCurrentDomain();
    INT index = -1;
    int cch = 0;
    LPTSTR szFullPath = NULL;
    LPTSTR szServerName = NULL;
    DWORD dwOptions = 0;


    if (NULL == szDomain)
    {
        goto Done;
    }

    if (NULL == szObject)
    {
        goto Done;
    }


    pel = new MYLISTEL;
    if (NULL == pel)
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoNewGPO failed to allocate memory for GPO name")));
        goto Done;
    }
    pel->bDisabled = FALSE;
    pel->szData = NULL;
    pel->szName = new OLECHAR[MAX_FRIENDLYNAME];
    if (NULL == pel->szName)
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoNewGPO failed to allocate memory for GPO name")));
        goto Done;
    }

    GetNewGPODisplayName (pel->szName, MAX_FRIENDLYNAME);

    pel->nType = ITEMTYPE_GPO;

    // Create a new GPO named "New Group Policy Object"

    //
    // Create a new GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CoCreateInstance failed with 0x%x\r\n"), hr));
        goto Done;
    }

    //
    // Open the requested object without mounting the registry
    //
#if FGPO_SUPPORT
    if (IsCurrentObjectAForest())
    {
        dwOptions = GPO_OPEN_FOREST;
    }
#endif
    hr = pGPO->New(szDomain, pel->szName, dwOptions);

    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDNEW);
        DebugMsg((DM_WARNING, TEXT("Failed to create GPO object with 0x%x\r\n"), hr));
        goto Done;
    }

    // continue to try to allocate memory until either a big enough buffer is
    // created to load the GPO path or we run out of memory
    pel->szData = NULL;
    do
    {
        if (pel->szData)
        {
            delete [] pel->szData;
        }
        cch += MAX_PATH;
        pel->szData = new OLECHAR[cch];
        if (NULL == pel->szData)
        {
        }
        hr = pGPO->GetPath(pel->szData, cch);
    } while (hr == E_OUTOFMEMORY);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("Failed to get GPO object path with 0x%x\r\n"), hr));
        goto Done;

    }

    szServerName = ExtractServerName(szDomain);
    szFullPath = MakeFullPath(pel->szData, szServerName);
    if (szFullPath)
    {
        delete [] pel->szData;
        pel->szData = new OLECHAR[wcslen(szFullPath) + 1];
        if (NULL == pel->szData)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::DoNewGPO failed to allocate memory for GPO path")));
            goto Done;
        }
        wcscpy(pel->szData, szFullPath);
    }


    if (m_dwPageType != PAGETYPE_ALL)
    {
        // If we're not on the "All" page then we need to create a link.
        CreateLink(pel->szData, szObject);
    }

    // Add the entry to the list view

    index = AddElement(pel, -1);
    fSucceeded = index != -1;

    // It's been added so now we need to make sure we don't delete it below
    pel = NULL;

    // Record that we got this far
    fEdit = TRUE;

Done:
    if (pel)
    {
        if (pel->szData)
        {
            delete [] pel->szData;
        }
        if (pel->szName)
        {
            delete [] pel->szName;
        }
        delete pel;
    }
    if (pGPO)
        pGPO->Release();

    if (fEdit)
    {
        // Now trigger an edit of the entry
        SetFocus(m_hList);
        ListView_EditLabel(m_hList, index);

    }

    if (szServerName)
        LocalFree(szServerName);
    if (szFullPath)
        LocalFree(szFullPath);
    if (szDomain)
        delete [] szDomain;
    if (szObject)
        delete [] szObject;

    return fSucceeded;
}

BOOL CBrowserPP::CreateLink(LPOLESTR szObject, LPOLESTR szContainer)
{
    HRESULT hr = CreateGPOLink(szObject, szContainer, FALSE);
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    ReportError(m_hwndDlg, hr, IDS_FAILEDLINK);
    return FALSE;
}

BOOL CBrowserPP::DeleteLink(LPOLESTR szObject, LPOLESTR szContainer)
{
    HRESULT hr = DeleteGPOLink(szObject, szContainer);
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    ReportError(m_hwndDlg, hr, IDS_FAILEDUNLINK);
    return FALSE;
}

BOOL CBrowserPP::DoRotateView()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    DWORD dw =  dwStyle & LVS_TYPEMASK;
    switch (dw)
    {
    case LVS_ICON:
        dw = LVS_SMALLICON;
        break;
    case LVS_SMALLICON:
        dw = LVS_LIST;
        break;
    case LVS_REPORT:
        dw = LVS_ICON;
        break;
    case LVS_LIST:
        default:
        dw = LVS_REPORT;
        break;
    }
    dwStyle -= dwStyle & LVS_TYPEMASK;
    dwStyle += dw;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle);
    return TRUE;
}

void CBrowserPP::OnDetails()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_REPORT);
}

void CBrowserPP::OnList()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_LIST);
}

void CBrowserPP::OnLargeicons()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_ICON);

}

void CBrowserPP::OnSmallicons()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    dwStyle -= dwStyle & LVS_TYPEMASK;
    SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_SMALLICON);
}

void CBrowserPP::OnContextMenu(LPARAM lParam)
{
    int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    RECT rc;
    POINT pt;
    pt.x = ((int)(short)LOWORD(lParam));
    pt.y = ((int)(short)HIWORD(lParam));

    GetWindowRect (GetDlgItem (m_hwndDlg, IDC_LIST1), &rc);

    if (!PtInRect (&rc, pt))
    {
        if ((lParam == (LPARAM) -1) && (i >= 0))
        {
            rc.left = LVIR_SELECTBOUNDS;
            SendMessage (m_hList, LVM_GETITEMRECT, i, (LPARAM) &rc);

            pt.x = rc.left + 8;
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);

            ClientToScreen (m_hList, &pt);
        }
        else
        {
            pt.x = rc.left + ((rc.right - rc.left) / 2);
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);
        }
    }


    // get the popup menu
    HMENU hPopup;
    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_LISTMENU));
    HMENU hSubMenu = GetSubMenu(hPopup, 0);

    if (i >= 0)
    {
        // item selected

        // figure out what type it is
        LVITEM item;
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = i;
        ListView_GetItem(m_hList, &item);
        MYLISTEL * pel = (MYLISTEL *)item.lParam;

        // get rid of the view menu and separator
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        // get rid of the arrange and line-up items
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);

        // get rid of the "new" menu item
        RemoveMenu(hSubMenu, ID_NEW, MF_BYCOMMAND);
        switch (pel->nType)
        {
        case ITEMTYPE_GPO:
            if (pel->bDisabled)
            {
                // disable edit, rename, delete
                EnableMenuItem(hSubMenu, ID_EDIT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
                EnableMenuItem(hSubMenu, ID_RENAME, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
                EnableMenuItem(hSubMenu, ID_DELETE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            }
            break;
        default:
        case ITEMTYPE_FOREST:
        case ITEMTYPE_SITE:
        case ITEMTYPE_DOMAIN:
        case ITEMTYPE_OU:
            // remove the edit menu item and the separator
            RemoveMenu(hSubMenu, ID_EDIT, MF_BYCOMMAND);
            RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
            // disable rename, delete and properties
            EnableMenuItem(hSubMenu, ID_RENAME, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            EnableMenuItem(hSubMenu, ID_DELETE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            EnableMenuItem(hSubMenu, ID_PROPERTIES, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            break;
        }
    }
    else
    {
        // no item selected

        // get rid of the edit menu item
        RemoveMenu(hSubMenu, ID_EDIT, MF_BYCOMMAND);

        // get rid of the delete and rename items
        RemoveMenu(hSubMenu, ID_DELETE, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, ID_RENAME, MF_BYCOMMAND);


        if (PAGETYPE_ALL != m_dwPageType)
        {
            if (m_pGBI->dwFlags & GPO_BROWSE_DISABLENEW)
            {
                // get rid of the "new" menu item
                RemoveMenu(hSubMenu, ID_NEW, MF_BYCOMMAND);
                RemoveMenu(hSubMenu, 4, MF_BYPOSITION);
            }
        }

        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 1), MF_BYPOSITION);
        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 1), MF_BYPOSITION);


        // set view radio button
        UINT ui = ID_LIST;

        DWORD dw = GetWindowLong(m_hList, GWL_STYLE) & LVS_TYPEMASK;

        if (dw == LVS_ICON || dw == LVS_SMALLICON)
        {
            // Auto-Arrange means something in these views so we need to enable it
            EnableMenuItem(hSubMenu, ID_ARRANGE_AUTO, MF_BYCOMMAND | MF_ENABLED);
            // also need to make sure it's set correctly
            if (LVS_AUTOARRANGE == (GetWindowLong(m_hList, GWL_STYLE) & LVS_AUTOARRANGE))
                CheckMenuItem(hSubMenu, ID_ARRANGE_AUTO, MF_BYCOMMAND | MF_CHECKED);
        }
        switch (dw)
        {
        case LVS_ICON:
            ui = ID_LARGEICONS;
            break;
        case LVS_SMALLICON:
            ui = ID_SMALLICONS;
            break;
        case LVS_REPORT:
            ui = ID_DETAILS;
            break;
        case LVS_LIST:
            default:
            ui = ID_LIST;
            break;
        }
        CheckMenuRadioItem(hSubMenu, ui, ui, ui, MF_BYCOMMAND);

    }
    TrackPopupMenu(hSubMenu,
                   TPM_LEFTALIGN,
                   pt.x, pt.y,
                   0,
                   m_hwndDlg,
                   NULL);
    DestroyMenu(hPopup);
}


void CBrowserPP::OnArrangeAuto()
{
    DWORD dwStyle = GetWindowLong(m_hList, GWL_STYLE);
    if (LVS_AUTOARRANGE == (dwStyle & LVS_AUTOARRANGE))
        SetWindowLong(m_hList, GWL_STYLE, dwStyle - LVS_AUTOARRANGE);
    else
        SetWindowLong(m_hList, GWL_STYLE, dwStyle + LVS_AUTOARRANGE);
}

int CALLBACK CompareName(LPARAM lParam1, LPARAM lParam2, LPARAM lParamsort)
{
    MYLISTEL * pel1 = (MYLISTEL *)lParam1;
    MYLISTEL * pel2 = (MYLISTEL *)lParam2;
    return _wcsicmp(pel1->szName, pel2->szName);
}

int CALLBACK CompareType(LPARAM lParam1, LPARAM lParam2, LPARAM lParamsort)
{
    MYLISTEL * pel1 = (MYLISTEL *)lParam1;
    MYLISTEL * pel2 = (MYLISTEL *)lParam2;
    return pel1->nType - pel2->nType;
}

void CBrowserPP::OnArrangeByname()
{
    ListView_SortItems(m_hList, CompareName, 0);
}

void CBrowserPP::OnArrangeBytype()
{
    ListView_SortItems(m_hList, CompareType, 0);
}

void CBrowserPP::OnDelete()
{
    DeleteGPO();
}

void CBrowserPP::OnEdit()
{
    INT i;
    HRESULT hr;
    LVITEM item;
    MYLISTEL * pel;
    LPTSTR lpDomainName;
    LPOLESTR pszDomain;



    i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);

    if (i >= 0)
    {
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = i;

        ListView_GetItem(m_hList, &item);

        pel = (MYLISTEL *)item.lParam;

        if (pel->nType == ITEMTYPE_GPO)
        {
            //
            // Get the friendly domain name
            //

            pszDomain = GetDomainFromLDAPPath(pel->szData);

            if (!pszDomain)
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnEdit: Failed to get domain name")));
                return;
            }


            //
            // Convert LDAP to dot (DN) style
            //

            hr = ConvertToDotStyle (pszDomain, &lpDomainName);

            delete [] pszDomain;

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
                return;
            }


            //
            // Check if the GPO is in the same domain as GPM is focused on
            //

            if (!lstrcmpi(lpDomainName, m_szDomainName))
            {
                SpawnGPE (pel->szData, GPHintUnknown, m_szServerName, m_hwndDlg);
            }
            else
            {
                SpawnGPE (pel->szData, GPHintUnknown, NULL, m_hwndDlg);
            }


            LocalFree (lpDomainName);
        }
    }
}

void CBrowserPP::OnNew()
{
    DoNewGPO();
}

void CBrowserPP::OnProperties()
{
    INT iIndex;
    LVITEM item;
    HRESULT hr;
    LPGROUPPOLICYOBJECT pGPO;
    HPROPSHEETPAGE *hPages;
    UINT i, uPageCount;
    PROPSHEETHEADER psh;

    iIndex = ListView_GetNextItem(m_hList, -1, LVNI_ALL | LVNI_SELECTED);
    if (iIndex >= 0)
    {
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        ListView_GetItem(m_hList, &item);

        MYLISTEL * pel = (MYLISTEL *)item.lParam;
        if (pel && pel->nType == ITEMTYPE_GPO)
        {
            hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                                   CLSCTX_SERVER, IID_IGroupPolicyObject,
                                   (void**)&pGPO);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnProperties: CoCreateInstance failed with 0x%x\r\n"), hr));
                return;
            }


            //
            // Open the requested object without mounting the registry
            //

            hr = pGPO->OpenDSGPO(pel->szData, 0);

            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                hr = pGPO->OpenDSGPO(pel->szData, GPO_OPEN_READ_ONLY);
            }

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnProperties: Failed to open GPO object with 0x%x\r\n"), hr));
                ReportError(m_hwndDlg, hr, IDS_FAILEDDS);
                return;
            }


            //
            // Ask the GPO for the property sheet pages
            //

            hr = pGPO->GetPropertySheetPages (&hPages, &uPageCount);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CBrowserPP::OnProperties: Failed to query property sheet pages with 0x%x."), hr));
                pGPO->Release();
                return;
            }

            //
            // Display the property sheet
            //

            ZeroMemory (&psh, sizeof(psh));
            psh.dwSize = sizeof(psh);
            psh.dwFlags = PSH_PROPTITLE;
            psh.hwndParent = m_hwndDlg;
            psh.hInstance = g_hInstance;
            psh.pszCaption = pel->szName;
            psh.nPages = uPageCount;
            psh.phpage = hPages;

            PropertySheet (&psh);

            LocalFree (hPages);
            pGPO->Release();
        }
    }
}

void CBrowserPP::OnRefresh()
{
    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        RefreshDomains();
        break;
    case PAGETYPE_SITES:
        RefreshSites();
        break;
    default:
    case PAGETYPE_ALL:
        RefreshAll();
        break;
    }

    SetButtonState();
}

void CBrowserPP::OnRename()
{
    //
    // alow the rename only if it is possible to rename
    //

    int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
    if (i >= 0)
    {
        // item selected

        // figure out what type it is
        LVITEM item;
        memset(&item, 0, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = i;
        ListView_GetItem(m_hList, &item);
        MYLISTEL * pel = (MYLISTEL *)item.lParam;

        if ((pel) && (pel->nType == ITEMTYPE_GPO) 
            && (!(pel->bDisabled))) {
            ListView_EditLabel(m_hList, ListView_GetNextItem(m_hList, -1, LVNI_SELECTED));
        }
    }
}

void CBrowserPP::OnTopLineupicons()
{
    ListView_Arrange(m_hList, LVA_SNAPTOGRID);
}

void CBrowserPP::OnBeginlabeleditList(NMHDR* pNMHDR, LRESULT* pResult)
{
    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
    // Return FALSE to enable editing, TRUE to disable it
    MYLISTEL * pel = (MYLISTEL *)pDispInfo->item.lParam;
    *pResult = (pel->nType == ITEMTYPE_GPO) ? FALSE : TRUE;
}

void CBrowserPP::OnEndlabeleditList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = FALSE;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr;
    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;

    if (NULL == pDispInfo->item.pszText)
    {
        // user cancelled edit
        return;
    }

    if (TEXT('\0') == (*pDispInfo->item.pszText))
    {
        // user entered an empty string
        return;
    }


    MYLISTEL * pel = (MYLISTEL *)pDispInfo->item.lParam;
    if (0 ==wcscmp(pDispInfo->item.pszText, pel->szName))
    {
        // user didn't change anything
        return;
    }

    LPWSTR sz = new WCHAR[wcslen(pDispInfo->item.pszText)+1];

    if (NULL == sz)
    {
        *pResult = FALSE;
        goto Done;
        return;
    }

    hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                          CLSCTX_SERVER, IID_IGroupPolicyObject,
                          (void **)&pGPO);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CoCreateInstance failed with 0x%x\r\n"), hr));
        goto Done;
    }


    // open GPO object without opening registry data
    hr = pGPO->OpenDSGPO(pel->szData, 0);
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDDS);
        DebugMsg((DM_WARNING, TEXT("OpenDSGPO failed with 0x%x\r\n"), hr));
        goto Done;
    }

    // rename it
    hr = pGPO->SetDisplayName(pDispInfo->item.pszText);
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDSETNAME);
        DebugMsg((DM_WARNING, TEXT("SetDisplayName failed with 0x%x\r\n"), hr));
        goto Done;
    }

    // requery for the name
    hr = pGPO->GetDisplayName(sz, (wcslen(pDispInfo->item.pszText)+1));
    if (FAILED(hr))
    {
        ReportError(m_hwndDlg, hr, IDS_FAILEDSETNAME);
        DebugMsg((DM_WARNING, TEXT("GetDisplayName failed with 0x%x\r\n"), hr));
        goto Done;
    }

    delete [] pel->szName;
    pel->szName = sz;
    sz = NULL;

    // return TRUE to accept the rename, FALSE to reject it

    *pResult = TRUE;
    PostMessage (m_hwndDlg, WM_REFRESHDISPLAY, (WPARAM) pDispInfo->item.iItem, 0);

Done:
    if (sz)
    {
        delete [] sz;
    }

    if (pGPO)
    {
        pGPO->Release();
    }
}

void CBrowserPP::OnBegindragList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    *pResult = 0;
}

void CBrowserPP::OnDeleteitemList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    MYLISTEL * pel = (MYLISTEL *)pNMListView->lParam;
    if (pel)
    {
        if (pel->szName)
        {
            delete [] pel->szName;
        }
        if (pel->szData)
        {
            delete [] pel->szData;
        }
        delete pel;
    }
    *pResult = 0;
}

void CBrowserPP::OnDoubleclickList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if (pNMListView->iItem >= 0)
    {
        // item selected
        PropSheet_PressButton(GetParent(m_hwndDlg), PSBTN_OK);
    }
    *pResult = 0;
}

void CBrowserPP::OnColumnclickList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    switch (pNMListView->iSubItem)
    {
    case 0:
        ListView_SortItems(m_hList, CompareName, 0);
        break;
    case 1:
        default:
        ListView_SortItems(m_hList, CompareType, 0);
        break;
    }
    *pResult = 0;
}

void CBrowserPP::OnKeyDownList(NMHDR * pNMHDR, LRESULT * pResult)
{
    LV_KEYDOWN * pnkd = (LV_KEYDOWN *)pNMHDR;

    switch (pnkd->wVKey)
    {
        case VK_F5:
            OnRefresh();
            break;
        case VK_F2:
            OnRename();
            break;
        case VK_DELETE:
            OnDelete();
            break;

        case VK_BACK:
            DoBackButton();
            break;

        case VK_RETURN:
            OnProperties();
            break;

        default:
            break;
    }
}

void CBrowserPP::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    SetButtonState();
}

void CBrowserPP::TrimComboBox()
{
    LOOKDATA * pdataSelected = NULL;
    int iCount;

    // first check to see if something is selected
    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);
    if (iIndex != CB_ERR)
    {
        // something's selected, get a pointer to it's data
        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);

        // check if the user selected the same thing again
        if (m_pPrevSel && (m_pPrevSel == pdataSelected))
        {
            return;
        }

        // if it has a parent then enable the back button
        SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM)MAKELONG(NULL != pdataSelected->pParent, 0));
    }

    // If the child of the selected object is an OU then delete all of it's children
    // otherwise delete ALL OUs from the list.

    if (pdataSelected)
    {
        if (pdataSelected->pChild)
        {
            if (ITEMTYPE_OU == pdataSelected->pChild->nType)
            {
                // delete all of its children
                goto DeleteChildren;
            }
        }
    }

    iCount = (int)SendMessage(m_hCombo, CB_GETCOUNT, 0, 0);
    iIndex = 0;
    while (iIndex < iCount)
    {
        // find the first entry that has an OU for a child.
        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);

        if (pdataSelected)
        {
            if (pdataSelected->pChild)
            {
                if (ITEMTYPE_OU == pdataSelected->pChild->nType)
                {
                    DeleteChildren:
                        LOOKDATA * pChild = pdataSelected->pChild;
                        pdataSelected->pChild = pChild->pSibling;
                        while (pChild)
                        {
                            iIndex = (int)SendMessage(m_hCombo, CB_FINDSTRING, iIndex, (LPARAM)(LPCTSTR*)pChild);
                            if (iIndex  != CB_ERR)
                            {
                                pChild = pChild->pChild;
                                SendMessage(m_hCombo, CB_DELETESTRING, iIndex, 0);
                            }
                            else
                            {
                                pChild = NULL;
                            }
                        }
                        return;
                }
            }
        }
        iIndex++;
    }
}

void CBrowserPP::OnComboChange()
{
    switch (m_dwPageType)
    {
    case PAGETYPE_DOMAINS:
        {
            TrimComboBox();
        }
        // fall through to refresh the list view
    case PAGETYPE_SITES:
    case PAGETYPE_ALL:
    default:
        OnRefresh();
        break;
    }
}

BOOL CBrowserPP::OnSetActive()
{
    *m_ppActive = this;
    OnRefresh();
    return TRUE;
}

BOOL CBrowserPP::OnApply()
{
    if (*m_ppActive == (void *) this)
    {
        // perform the proper task on the selected item
        int i = ListView_GetNextItem(m_hList, -1, LVNI_SELECTED);
        if (i >= 0)
        {
            LVITEM item;
            memset(&item, 0, sizeof(item));
            item.mask = LVIF_PARAM;
            item.iItem = i;
            ListView_GetItem(m_hList, &item);
            MYLISTEL * pel = (MYLISTEL *)item.lParam;
            switch (pel->nType)
            {
            case ITEMTYPE_GPO:
                m_pGBI->gpoType = GPOTypeDS;
                wcsncpy(m_pGBI->lpDSPath, pel->szData, m_pGBI->dwDSPathSize);
                if (m_pGBI->lpName)
                {
                    wcsncpy(m_pGBI->lpName, pel->szName, m_pGBI->dwNameSize);
                }
                m_pGBI->gpoHint = GPHintUnknown;
                break;
            default:
            case ITEMTYPE_FOREST:
            case ITEMTYPE_SITE:
            case ITEMTYPE_DOMAIN:
                // change the focus
                {
                    LOOKDATA * pdataSelected = NULL;


                    // first make sure something is selected
                    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);
                    if (iIndex != CB_ERR)
                    {
                        // something's selected, get a pointer to it's data
                        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
                        if (pdataSelected)
                        {
                            // Now walk its children until we find a match
                            pdataSelected = pdataSelected->pChild;
                            while (pdataSelected)
                            {
                                if (0 == wcscmp(pdataSelected->szData, pel->szData))
                                {
                                    iIndex = (int)SendMessage(m_hCombo, CB_FINDSTRING, iIndex, (LPARAM) (LPCTSTR)pdataSelected);
                                    if (iIndex != CB_ERR)
                                    {
                                        SendMessage(m_hCombo, CB_SETCURSEL, iIndex, 0);
                                        // Enable the back-button
                                        SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(TRUE, 0));
                                    }
                                    break;
                                }
                                pdataSelected = pdataSelected->pSibling;
                            }
                        }
                    }
                }
                OnRefresh();
                return FALSE; // don't allow propsheet to close
            case ITEMTYPE_OU:
                // Add the new object to combobox and change the focus.
                {
                    LOOKDATA * pdataSelected = NULL;


                    // first make sure something is selected
                    int iIndex = (int)SendMessage (m_hCombo, CB_GETCURSEL, 0, 0);
                    if (iIndex != CB_ERR)
                    {
                        // something's selected, get a pointer to it's data
                        pdataSelected = (LOOKDATA *) SendMessage (m_hCombo, CB_GETITEMDATA, iIndex, 0);
                        if (pdataSelected)
                        {
                            LOOKDATA * pNew = new LOOKDATA;
                            if (pNew)
                            {
                                pNew->szName = new WCHAR[wcslen(pel->szName)+1];
                                if (pNew->szName)
                                {
                                    pNew->szData = new WCHAR[wcslen(pel->szData)+1];
                                    if (pNew->szData)
                                    {
                                        wcscpy(pNew->szName, pel->szName);
                                        wcscpy(pNew->szData, pel->szData);
                                        pNew->nIndent = pdataSelected->nIndent + 1;
                                        pNew->nType = ITEMTYPE_OU;
                                        pNew->pParent = pdataSelected;
                                        pNew->pSibling = pdataSelected->pChild;
                                        pNew->pChild = NULL;
                                        pdataSelected ->pChild = pNew;
                                        SendMessage(m_hCombo, CB_INSERTSTRING, (WPARAM) iIndex + 1, (LPARAM) (LPCTSTR) pNew);
                                        SendMessage(m_hCombo, CB_SETCURSEL, iIndex + 1, 0);
                                        // Enable the back-button
                                        SendMessage(m_toolbar, TB_ENABLEBUTTON, (WPARAM) ID_BACKBUTTON, (LPARAM) MAKELONG(TRUE, 0));
                                    }
                                    else
                                    {
                                        delete [] pNew->szName;
                                        delete pNew;
                                    }
                                }
                                else
                                {
                                    delete pNew;
                                }
                            }
                        }
                    }
                }
                OnRefresh();
                return FALSE;   // don't allow propsheet to close
            }
            return TRUE;
        }
        else
            return FALSE;       // don't allow propsheet to close
    }
    return TRUE;
}

BOOL CBrowserPP::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fReturn = FALSE;
    m_hwndDlg = hwndDlg;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            return OnInitDialog();
        }
        break;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            LRESULT lResult = 0;

            switch (pnmh->code)
            {
            case NM_KEYDOWN:
                {
                    LPNMKEY pnkd = (LPNMKEY)pnmh;

                    if (VK_F5 == pnkd->nVKey)
                    {
                        OnRefresh();
                    }
                }
                break;
            case PSN_SETACTIVE:
                OnSetActive();
                break;
            case PSN_APPLY:
                lResult = OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
                fReturn = TRUE;
                break;
            case NM_DBLCLK:
                if (IDC_LIST1 == wParam)
                {
                    OnDoubleclickList(pnmh, &lResult);
                    fReturn = TRUE;
                }
                break;
            case LVN_BEGINLABELEDIT:
                OnBeginlabeleditList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_ENDLABELEDIT:
                OnEndlabeleditList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_BEGINDRAG:
                OnBegindragList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_DELETEITEM:
                OnDeleteitemList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_COLUMNCLICK:
                OnColumnclickList(pnmh, &lResult);
                fReturn = TRUE;
                break;
            case LVN_KEYDOWN:
                OnKeyDownList(pnmh, &lResult);
                break;
            case LVN_ITEMCHANGED:
                OnItemChanged(pnmh, &lResult);
                break;
            case TBN_DROPDOWN:
                {
                    RECT r;
                    SendMessage(m_toolbar, TB_GETRECT, ((TBNOTIFY *)lParam)->iItem, (LPARAM)&r);
                    MapWindowPoints(m_toolbar, NULL, (POINT *)&r, 2);
                    HMENU hPopup;
                    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_LISTMENU));
                    
                    if ( ! hPopup )
                    {
                        break;
                    }

                    UINT ui = ID_LIST;

                    DWORD dw = GetWindowLong(m_hList, GWL_STYLE) & LVS_TYPEMASK;
                    switch (dw)
                    {
                    case LVS_ICON:
                        ui = ID_LARGEICONS;
                        break;
                    case LVS_SMALLICON:
                        ui = ID_SMALLICONS;
                        break;
                    case LVS_REPORT:
                        ui = ID_DETAILS;
                        break;
                    case LVS_LIST:
                        default:
                        ui = ID_LIST;
                        break;
                    }
                    HMENU hSubMenu = GetSubMenu(GetSubMenu(hPopup, 0), 0);
                    CheckMenuRadioItem(hSubMenu, ui, ui, ui, MF_BYCOMMAND);
                    TrackPopupMenu(hSubMenu,
                                   TPM_LEFTALIGN,
                                   r.left, r.bottom,
                                   0,
                                   m_hwndDlg,
                                   &r);
                    fReturn = TRUE;
                    DestroyMenu(hPopup);
                    break;
                }
                break;
            case TTN_GETDISPINFO:
                {
                LPNMTTDISPINFO pDI = (LPNMTTDISPINFO) lParam;
                UINT id = 0;

                if (pDI->hdr.idFrom == ID_BACKBUTTON)
                    id = IDS_TOOLTIP_BACK;
                else if (pDI->hdr.idFrom == ID_NEWFOLDER)
                    id = IDS_TOOLTIP_NEW;
                else if (pDI->hdr.idFrom == ID_ROTATEVIEW)
                    id = IDS_TOOLTIP_ROTATE;

                if (id)
                    LoadString (g_hInstance, id, pDI->szText, 80);
                else
                    pDI->szText[0] = TEXT('\0');

                fReturn = TRUE;
                }
                break;
            default:
                break;
            }
            SetWindowLongPtr(m_hwndDlg, DWLP_MSGRESULT, lResult);
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_COMBO1:
            if (CBN_SELCHANGE == HIWORD(wParam))
            {
                OnComboChange();
            }
            break;
        case ID_BACKBUTTON:
            return DoBackButton();
        case ID_NEWFOLDER:
            return DoNewGPO();
        case ID_ROTATEVIEW:
            return DoRotateView();
        case ID_DETAILS:
            OnDetails();
            fReturn = TRUE;
            break;
        case ID_LIST:
            OnList();
            fReturn = TRUE;
            break;
        case ID_LARGEICONS:
            OnLargeicons();
            fReturn = TRUE;
            break;
        case ID_SMALLICONS:
            OnSmallicons();
            fReturn = TRUE;
            break;
        case ID_ARRANGE_AUTO:
            OnArrangeAuto();
            fReturn = TRUE;
            break;
        case ID_ARRANGE_BYNAME:
            OnArrangeByname();
            fReturn = TRUE;
            break;
        case ID_ARRANGE_BYTYPE:
            OnArrangeBytype();
            fReturn = TRUE;
            break;
        case ID_DELETE:
            OnDelete();
            fReturn = TRUE;
            break;
        case ID_EDIT:
            OnEdit();
            fReturn = TRUE;
            break;
        case ID_NEW:
            OnNew();
            fReturn = TRUE;
            break;
        case ID_PROPERTIES:
            OnProperties();
            fReturn = TRUE;
            break;
        case ID_REFRESH:
            OnRefresh();
            fReturn = TRUE;
            break;
        case ID_RENAME:
            OnRename();
            fReturn = TRUE;
            break;
        case ID_TOP_LINEUPICONS:
            OnTopLineupicons();
            fReturn = TRUE;
            break;
        default:
            break;
        }
        break;

    case WM_CONTEXTMENU:
        fReturn = TRUE;
        if ((HWND)wParam != m_toolbar)
        {
            if (GetDlgItem(hwndDlg, IDC_LIST1) == (HWND)wParam)
            {
                OnContextMenu(lParam);
            }
            else
            {
                // right mouse click
                switch (m_dwPageType)
                {
                    case PAGETYPE_DOMAINS:
                        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                                (ULONG_PTR) (LPSTR) aBrowserDomainHelpIds);
                        break;

                    case PAGETYPE_SITES:
                        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                                (ULONG_PTR) (LPSTR) aBrowserSiteHelpIds);
                        break;

                    case PAGETYPE_ALL:
                        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                                (ULONG_PTR) (LPSTR) aBrowserAllHelpIds);
                        break;
                }
            }
        }
        break;

    case WM_HELP:
        // F1 help
        if (((LPHELPINFO) lParam)->iCtrlId != IDR_TOOLBAR1)
        {
            switch (m_dwPageType)
            {
                case PAGETYPE_DOMAINS:
                    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                            (ULONG_PTR) (LPSTR) aBrowserDomainHelpIds);
                    break;

                case PAGETYPE_SITES:
                    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                            (ULONG_PTR) (LPSTR) aBrowserSiteHelpIds);
                    break;

                case PAGETYPE_ALL:
                    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                            (ULONG_PTR) (LPSTR) aBrowserAllHelpIds);
                    break;
            }
        }

        fReturn = TRUE;
        break;

    case WM_DRAWITEM:
        if (IDC_COMBO1 == wParam)
        {
            DrawItem((LPDRAWITEMSTRUCT)lParam);
            fReturn = TRUE;
        }
        break;
    case WM_MEASUREITEM:
        if (IDC_COMBO1 == wParam)
        {
            MeasureItem((LPMEASUREITEMSTRUCT)lParam);
            fReturn = TRUE;
        }
        break;
    case WM_COMPAREITEM:
        if (IDC_COMBO1 == wParam)
        {
            int iReturn = CompareItem((LPCOMPAREITEMSTRUCT)lParam);
            SetWindowLongPtr(m_hwndDlg, DWLP_MSGRESULT, iReturn);
            fReturn = TRUE;
        }
        break;
    case WM_DELETEITEM:
        if (IDC_COMBO1 == wParam)
        {
            DeleteItem((LPDELETEITEMSTRUCT)lParam);
            fReturn = TRUE;
        }
        break;

    case WM_REFRESHDISPLAY:
        {
        MYLISTEL * pel;
        LVITEM item;


        ZeroMemory (&item, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = (INT) wParam;

        if (ListView_GetItem(m_hList, &item))
        {
            pel = (MYLISTEL *)item.lParam;
            ListView_SetItemText(m_hList, (INT)wParam, 0, pel->szName);
        }

        }
        break;
    default:
        break;
    }
    return fReturn;
}

void CBrowserPP::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
    // DRAWITEMSTRUCT:
    //      UINT CtlType    // type of the control
    //  UINT CtlID;         // ID of the control
    //      UINT itemID;    // index of the item
    //  UINT itemAction;
    //  UINT itemState;
    //  HWND hwndItem;
    //      HDC hDC;
    //  RECT rcItem;
    //  DWORD itemData;     // user-defined data

    if (-1 != lpDrawItemStruct->itemID)
    {
        LOOKDATA * pdata = (LOOKDATA *)lpDrawItemStruct->itemData;
        POINT pt;
        INT iIndex;

        if (pdata->nType == ITEMTYPE_FOREST)
        {
            iIndex = 10;
        }
        else if (pdata->nType == ITEMTYPE_SITE)
        {
            iIndex = 6;
        }
        else if (pdata->nType == ITEMTYPE_DOMAIN)
        {
            iIndex = 7;
        }
        else
        {
            iIndex = 0;
        }

        pt.x = lpDrawItemStruct->rcItem.left;
        BOOL fSelected = ODS_SELECTED == (ODS_SELECTED & lpDrawItemStruct->itemState);
        BOOL fComboBoxEdit = ODS_COMBOBOXEDIT != (ODS_COMBOBOXEDIT & lpDrawItemStruct->itemState);
        if (fComboBoxEdit)
            pt.x += (INDENT * pdata->nIndent);
        pt.y = lpDrawItemStruct->rcItem.top;
        ImageList_Draw(m_ilSmall, iIndex, lpDrawItemStruct->hDC, pt.x, pt.y, fSelected ? ILD_SELECTED : ILD_NORMAL);
        SIZE size;
        GetTextExtentPoint32(lpDrawItemStruct->hDC, pdata->szName, wcslen(pdata->szName), &size);
        COLORREF crBk;
        COLORREF crText;
        if (fSelected)
        {
            crBk = GetBkColor(lpDrawItemStruct->hDC);
            crText = GetTextColor(lpDrawItemStruct->hDC);
            SetBkColor(lpDrawItemStruct->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpDrawItemStruct->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        // NOTE, SMALLICONSIZE + 1 is used here to ensure it rounds UP
        // instead of down when centering the text.  (It looks better this
        // way.)
        // Adding 18 to the x coord spaces us past the icon.
        ExtTextOut(lpDrawItemStruct->hDC, pt.x + (SMALLICONSIZE + 2), pt.y + (((SMALLICONSIZE + 1) - size.cy) / 2), ETO_CLIPPED, &lpDrawItemStruct->rcItem, pdata->szName, wcslen(pdata->szName), NULL);
        if (fSelected)
        {
            SetBkColor(lpDrawItemStruct->hDC, crBk);
            SetTextColor(lpDrawItemStruct->hDC, crText);
        }
    }
}

void CBrowserPP::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
    // MEASUREITEMSTRUCT:
    //      UINT CtlType    // type of the control
    //  UINT CtlID;         // ID of the control
    //      UINT itemID;    // index of the item
    //      UINT itemWidth; // width of item in pixels
    //      UINT itemHeight;        // height of item in pixels
    //  DWORD itemData;     // user-defined data

    lpMeasureItemStruct->itemHeight = SMALLICONSIZE;
}

int CBrowserPP::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct)
{
    // COMPAREITEMSTRUCT:
    //      UINT CtlType    // type of the control
    //  UINT CtlID;         // ID of the control
    //      HWND hwndItem;  // handle of the control
    //      UINT itemID;    // index of the item
    //  DWORD itemData1;    // user-defined data
    //  UINT itemID2;       // index of the second item
    //      DWORD itemData2;        // user-defined data

    // I'm not doing any sorting.

    return 0;
}

void CBrowserPP::DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct)
{
    LOOKDATA * pdata = (LOOKDATA *)lpDeleteItemStruct->itemData;
    if (NULL != pdata)
    {
        if (NULL != pdata->szName)
        {
            delete [] pdata->szName;
        }
        if (NULL != pdata->szData)
        {
            delete [] pdata->szData;
        }
        delete pdata;
    }
}

LPTSTR CBrowserPP::GetFullPath (LPTSTR lpPath, HWND hParent)
{
    LPTSTR lpFullPath = NULL, lpDomainName = NULL;
    LPTSTR lpGPDCName;
    LPOLESTR pszDomain;
    HRESULT hr;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpPath);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath: Failed to get domain name")));
        return NULL;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath: Failed to convert domain name with 0x%x"), hr));
        return NULL;
    }


    if (!lstrcmpi(lpDomainName, m_szDomainName))
    {

        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpPath, m_szServerName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath:  Failed to build new DS object path")));
            goto Exit;
        }

    }
    else
    {

        //
        // Get the GPO DC for this domain
        //

        lpGPDCName = GetDCName (lpDomainName, NULL, hParent, TRUE, 0);

        if (!lpGPDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath:  Failed to get DC name for %s"),
                     lpDomainName));
            goto Exit;
        }


        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpPath, lpGPDCName);

        LocalFree (lpGPDCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CBrowserPP::GetFullPath:  Failed to build new DS object path")));
            goto Exit;
        }
    }


Exit:

    if (lpDomainName)
    {
        LocalFree (lpDomainName);
    }

    return lpFullPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\fde\utils.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    utils.cxx

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/8/1998

Revision History:

    4/8/1998    RahulTh

    Created this module.

--*/
#include "precomp.hxx"

BOOL IsSpecialDescendant (const long nID, UINT* parentID /*= NULL*/)
{
    BOOL fRetVal;
    int prntID = -1;

    switch (nID)
    {
    case IDS_MYPICS:
        prntID = IDS_MYDOCS;
        break;
    case IDS_PROGRAMS:
        prntID = IDS_STARTMENU;
        break;
    case IDS_STARTUP:
        prntID = IDS_PROGRAMS;
        break;
    default:
        prntID = -1;
        break;
    }

    if (fRetVal = (-1 != prntID))
    {
        if (parentID)
            *parentID = prntID;
    }

    return fRetVal;
}

//this is a helper function for ConvertOldStyleSection(...) which is used
//to convert Beta3 style ini files to Win2K style ini files.
void SplitRHS (CString& szValue, unsigned long & flags, CString& szPath)
{
    int index;

    //take some precautions
    szValue.TrimRight();
    szValue.TrimLeft();
    szPath.Empty();
    flags = 0;

    if (szValue.IsEmpty())
        return;

    //if we are here, szValue at least contains the flags
    swscanf ((LPCTSTR)szValue, TEXT("%x"), &flags);

    //check if there is a path too.
    index = szValue.Find(' ');  //we will find a space only if there is a path too.
    if (-1 != index)    //there is a path too.
    {
        szPath = szValue.Mid (index + 1);
        szPath.TrimLeft();
        szPath.TrimRight();
        ASSERT (!szPath.IsEmpty());
    }
}

//////////////////////////////////////////////////////////////////////////
// Given a full path name, this routine extracts its display name, viz.
// the part of which follows the final \. If there are no \'s in the
// full name, then it sets the display name to the full name
//////////////////////////////////////////////////////////////////////////
void ExtractDisplayName (const CString& szFullname, CString& szDisplayname)
{
    CString szName;
    szName = szFullname;
    //first get rid of any trailing spaces; this might happen in cases
    //where one is trying to create a shortcut to a network drive and
    //when resolved to a UNC path, it yields a path ending in a slash

    //reverse the string so that any trailing slashes will now be at the
    //head of the string
    szName.MakeReverse();
    //get rid of the leading slashes and spaces of the reversed string
    szName = szName.Mid ((szName.SpanIncluding(TEXT("\\ "))).GetLength());
    //reverse the string again and we will have a string without
    //any trailing '\' or ' '
    szName.MakeReverse();

    //with the trailing '\' and spaces removed, we can go about the
    //business of getting the display name

    //if \ cannot be found, ReverseFind returns -1 which gives 0 on adding
    //1, therefore szDisplayname gets the entire name if no \ is found.
    szDisplayname = szName.Mid (szName.ReverseFind('\\') + 1);
}

//+--------------------------------------------------------------------------
//
//  Function:   SplitProfileString
//
//  Synopsis:   This function takes in a string of the type key=value and
//              extracts the key and the value from it.
//
//  Arguments:  [in] szPair : the key value pair
//              [out] szKey : the key
//              [out] szValue : the value
//
//  Returns:    S_OK : if everything goes well.
//              E_FAIL: if the '=' sign cannot be found
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HRESULT SplitProfileString (CString szPair, CString& szKey, CString& szValue)
{
    int nEqPos;

    nEqPos = szPair.Find ('=');

    if (-1 == nEqPos)
        return E_FAIL;

    szKey = szPair.Left(nEqPos);
    szKey.TrimLeft();
    szKey.TrimRight();

    szValue = szPair.Mid (nEqPos + 1);
    szValue.TrimLeft();
    szValue.TrimRight();

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   ConvertOldStyleSection
//
//  Synopsis:   this function looks at an ini file and if does not have the
//              new ini file format, it reads the old redirect section and
//              transforms it into the new ini file format which supports
//              scaleability
//
//  Arguments:  [in] szGPTPath : the directory where the ini file resides
//              [in] pScope    : pointer to the scope pane
//
//  Returns:    S_OK if it was successful
//              an error code if it fails
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      This function exists primarily for backward compatibility
//              with Win2K betas. Might be okay to remove it.
//
//---------------------------------------------------------------------------
HRESULT ConvertOldStyleSection (
                                const CString& szGPTPath
                                )
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString szIniFile;
    TCHAR*  lpszSection;
    TCHAR*  szEntry;
    DWORD   cbSize = 1024;
    DWORD   cbCopied;
    CString SectionEntry;
    CString Key;
    CString Dir;
    CString Value;
    CString Path;
    CString szStartMenu;
    CString szPrograms;
    CString szStartup;
    ULONG   flags;
    DWORD   Status;
    BOOL    bStatus;
    HRESULT hr;
    const TCHAR   szEveryOne[] = TEXT("s-1-1-0");

    //derive the full path of the ini file.
    szIniFile.LoadString (IDS_INIFILE);
    szIniFile = szGPTPath + '\\' + szIniFile;

    //create an empty section
    lpszSection = new TCHAR [cbSize];
    lpszSection[0] = lpszSection[1] = '\0';


    switch (CheckIniFormat (szIniFile))
    {
    case S_OK:
        //this section has already been converted
        goto ConOldStlSec_CleanupAndQuit;

    case S_FALSE:
        break;          //has the Redirect section but not the FolderStatus
                        //section, so there is processing to do.
    case REGDB_E_KEYMISSING:
        //this means that the function has neither the FolderStatus section
        //nor the Redirect section, so we just create an empty FolderStatus
        //section to make processing simpler in future.
        //ignore any errors here because they don't really cause any harm
        //however, make sure that the file is pre-created in unicode so that
        //the WritePrivateProfile* functions don't puke in ANSI
        PrecreateUnicodeIniFile ((LPCTSTR)szIniFile);
        WritePrivateProfileSection (TEXT("FolderStatus"),
                                    lpszSection,
                                    (LPCTSTR) szIniFile);
        hr = S_OK;
        goto ConOldStlSec_CleanupAndQuit;
    }

    //this means that we need to convert the section ourselves
    //first load the redirect section
    do
    {
        cbCopied = GetPrivateProfileSection (TEXT("Redirect"),
                                             lpszSection,
                                             cbSize,
                                             (LPCTSTR) szIniFile
                                             );
        if (cbSize - 2 == cbCopied)
        {
            delete [] lpszSection;
            cbSize *= 2;
            lpszSection = new TCHAR [cbSize];
            continue;
        }

        //the section has been successfully loaded if we are here.
        break;
    } while (TRUE);

    //start the conversion process:
    for (szEntry = lpszSection; *szEntry; szEntry += (lstrlen(szEntry) + 1))
    {
        SectionEntry = szEntry;
        if (FAILED(hr = SplitProfileString (SectionEntry, Key, Value)))
            goto ConOldStlSec_CleanupAndQuit;

        SplitRHS (Value, flags, Path);
        Path.TrimLeft();
        Path.TrimRight();
        if (Path.IsEmpty())
            Path = TEXT("%USERPROFILE%") + ('\\' + Key);  //we used the relative paths for keys in the old style section
        ExtractDisplayName (Key, Dir);

        //set the new flags or modify the existing flags to reflect new behavior
        szStartMenu.LoadString (IDS_STARTMENU);
        szPrograms.LoadString (IDS_PROGRAMS);
        szStartup.LoadString (IDS_STARTUP);
        if (Dir.CompareNoCase (szStartMenu) && //it is not the start menu and
            Dir.CompareNoCase (szPrograms) &&  //it is not programs and
            Dir.CompareNoCase (szStartup))  //it is not the startup folder
        {
            flags |= REDIR_SETACLS;         //apply acls. this was the default behavior earlier, but not any more
        }
        else    //it is one of start menu/programs/startup
        {
            //move contents is not allowed for start menu and its descendants
            flags &= ~REDIR_MOVE_CONTENTS;
        }

        if ((flags & REDIR_DONT_CARE) && (flags & REDIR_FOLLOW_PARENT))
        {
            //if both flags were present, this implies they are linked together
            //in the new format, in order to express this, only follow_parent
            //is required
            flags &= ~REDIR_DONT_CARE;
        }

        Value.Format (TEXT("%x"), flags);

        bStatus = WritePrivateProfileString (TEXT("FolderStatus"),
                                             Dir,
                                             Value,
                                             (LPCTSTR)szIniFile
                                             );

        if (bStatus && (!(flags & REDIR_DONT_CARE)) && (!(flags & REDIR_FOLLOW_PARENT)))
            bStatus = WritePrivateProfileString ((LPCTSTR) Dir,
                                                 szEveryOne,
                                                 (LPCTSTR) Path,
                                                 (LPCTSTR) szIniFile
                                                 );

        if (!bStatus)
        {
            Status = GetLastError();
            hr = HRESULT_FROM_WIN32 (Status);
            goto ConOldStlSec_CleanupAndQuit;
        }
    }

ConOldStlSec_CleanupAndQuit:
    delete [] lpszSection;
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetFolderIndex
//
//  Synopsis:   given the name of a folder, this function returns its index
//              in the array of CFileInfo objects in the scope pane
//
//  Arguments:  [in] szName : name of the folder
//
//  Returns:    the index of the folder or -1 if the name is invalid
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
LONG GetFolderIndex (const CString& szName)
{
    LONG i;
    CString szBuiltinFolder;

    for (i = IDS_DIRS_START; i < IDS_DIRS_END; i++)
    {
        szBuiltinFolder.LoadString (i);
        if (szName.CompareNoCase((LPCTSTR)szBuiltinFolder))
            break;
    }

    return GETINDEX (i);
}

//+--------------------------------------------------------------------------
//
//  Function:   CheckIniFormat
//
//  Synopsis:   this function examines the sections of an ini file to see
//              if it supports the new ini file format (that allows for
//              scaleability)
//
//  Arguments:  [in] szIniFile : the full path of the ini file
//
//  Returns:    S_OK : if it finds the FolderStatus section
//              S_FALSE : if it does not find the FolderStatus section but
//                        finds the Redirect section
//              REGDB_E_KEYMISSING : if it finds neither the FolderStatus
//                                   section nor the Redirect section
//
//  History:    9/28/1998  RahulTh  created
//
//  Notes:      this function exists for backward compatibility with Win2K
//              Betas. Might be okay to get rid of this eventually.
//
//---------------------------------------------------------------------------
HRESULT CheckIniFormat (LPCTSTR szIniFile)
{
    DWORD   cbSize = 1024;
    DWORD   cbCopied;
    TCHAR*  lpszNames;
    TCHAR*  szSectionName;
    BOOL    fHasFolderStatus = FALSE;
    BOOL    fHasRedirect = FALSE;

    do
    {
        lpszNames = new TCHAR [cbSize];
        if (! lpszNames)
            return E_OUTOFMEMORY;
        
        *lpszNames = L'\0';
        cbCopied = GetPrivateProfileSectionNames (lpszNames, cbSize, szIniFile);

        if (cbSize - 2 == cbCopied) //the buffer was not enough.
        {
            delete [] lpszNames;
            cbSize *= 2;            //increase the buffer size
            continue;
        }

        break;  //if we are here, we are done.

    } while (TRUE);

    for (szSectionName = lpszNames;
         *szSectionName;
         szSectionName += (lstrlen(szSectionName) + 1))
    {
        if (0 == lstrcmpi(TEXT("FolderStatus"), szSectionName))
        {
            fHasFolderStatus = TRUE;
            continue;
        }

        if (0 == lstrcmpi (TEXT("Redirect"), szSectionName))
        {
            fHasRedirect = TRUE;
            continue;
        }
    }

    //cleanup dynamically allocated memory before quitting
    delete [] lpszNames;

    if (fHasFolderStatus)
        return S_OK;

    //if we are here, the file does not have the FolderStatus section
    if (fHasRedirect)
        return S_FALSE;

    //if we are here, then the file has neither the folder status section
    //nor the Redirect section
    return REGDB_E_KEYMISSING;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    CString StrNum;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    StrNum = szNum;
    len = StrNum.GetLength();
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = sizeof(WCHAR) * (len + 1);
    StringW.Buffer = StrNum.GetBuffer(len);

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

    return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetUNCPath
//
//  Synopsis:   this function tries to retrieve the UNC path of an item
//              given its PIDL
//
//  Arguments:  [in] lpszPath : the full path to the selected file.
//              [out] szUNC : the UNC path of the item
//
//  Returns:    NO_ERROR if the conversion was successful.
//              other error codes if not...
//
//  History:    10/1/1998  RahulTh  created
//              4/12/1999  RahulTh  added error code. changed params.
//                                  (item id list is no longer passed in)
//
//  Notes:      if this function is unsuccessful, then szUNC will contain an
//              empty string
//
//---------------------------------------------------------------------------
DWORD GetUNCPath (LPCTSTR lpszPath, CString& szUNC)
{
    TCHAR* lpszUNCName;
    UNIVERSAL_NAME_INFO* pUNCInfo;
    DWORD lBufferSize;
    DWORD retVal = NO_ERROR;

    szUNC.Empty();  //precautionary measures

    //we have a path, now we shall try to get a UNC path
    lpszUNCName = new TCHAR[MAX_PATH];
    pUNCInfo = (UNIVERSAL_NAME_INFO*)lpszUNCName;
    lBufferSize = MAX_PATH * sizeof(TCHAR);
    retVal = WNetGetUniversalName (lpszPath,
                                   UNIVERSAL_NAME_INFO_LEVEL,
                                   (LPVOID)pUNCInfo,
                                   &lBufferSize);
    if (ERROR_MORE_DATA == retVal)  //MAX_PATH was insufficient to hold the UNC path
    {
        delete [] lpszUNCName;
        lpszUNCName = new TCHAR[lBufferSize/(sizeof(TCHAR)) + 1];
        pUNCInfo = (UNIVERSAL_NAME_INFO*)lpszUNCName;
        retVal = WNetGetUniversalName (lpszPath,
                                       UNIVERSAL_NAME_INFO_LEVEL,
                                       (LPVOID)pUNCInfo,
                                       &lBufferSize);
    }

    //at this point we may or may not have a UNC path.
    //if we do, we return that, or we return whatever we already have
    if (NO_ERROR == retVal)
        szUNC = pUNCInfo->lpUniversalName;

    delete [] lpszUNCName;

    return retVal;
}

//+--------------------------------------------------------------------------
//
//  Function:   BrowseCallbackProc
//
//  Synopsis:   the callback function for SHBrowseForFolder
//
//  Arguments:  see Platform SDK
//
//  Returns:    see Platform SDK
//
//  History:    4/9/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg,
                                LPARAM lParam, LPARAM lpData
                                )
{
    CString * pszData;
    CString   szStart;
    int       index;
    LPITEMIDLIST    lpidl = NULL;
    TCHAR      lpszPath [MAX_PATH];

    pszData = (CString *) lpData;

    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        if (pszData)
        {
            szStart = *pszData;
            szStart.TrimRight();
            szStart.TrimLeft();
            if (! szStart.IsEmpty())
            {
                index = szStart.ReverseFind (L'\\');
                if (-1 != index && index > 1)
                    szStart = szStart.Left (index);
                SendMessage (hwnd, BFFM_SETSELECTION, TRUE,
                             (LPARAM)(LPCTSTR)szStart);
            }
        }
        break;
    case BFFM_SELCHANGED:
        //we need to check if we can get the full path to the selected folder.
        //e.g. if the full path exceeds MAX_PATH, we cannot obtain the path
        //from the item id list. if we cannot get the path, we should not
        //enable the OK button. So, over here, as a precaution, we first
        //disable the OK button. We will enable it only after we get the path.
        SendMessage (hwnd, BFFM_ENABLEOK, FALSE, FALSE);
        if (SHGetPathFromIDList((LPCITEMIDLIST)lParam, lpszPath))
        {
            //set the path into the data member and enable the OK button
            if (lpData)
            {
                SendMessage (hwnd, BFFM_ENABLEOK, TRUE, TRUE);
                *((CString *) lpData) = lpszPath;
            }
        }
        break;
    default:
        break;
    }

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Function:   PrecreateUnicodeIniFile
//
//  Synopsis:   The WritePrivateProfile* functions do not write in unicode
//              unless the file already exists in unicode format. Therefore,
//              this function is used to precreate a unicode file so that
//              the WritePrivateProfile* functions can preserve the unicodeness.
//
//  Arguments:  [in] lpszFilePath : the full path of the ini file.
//
//  Returns:    ERROR_SUCCESS if successful.
//              an error code otherwise.
//
//  History:    7/9/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD PrecreateUnicodeIniFile (LPCTSTR lpszFilePath)
{
    HANDLE      hFile;
    WIN32_FILE_ATTRIBUTE_DATA   fad;
    DWORD       Status = ERROR_ALREADY_EXISTS;
    DWORD       dwWritten;

    if (!GetFileAttributesEx (lpszFilePath, GetFileExInfoStandard, &fad))
    {
        if (ERROR_FILE_NOT_FOUND == (Status = GetLastError()))
        {
            hFile = CreateFile(lpszFilePath, GENERIC_WRITE, 0, NULL,
                               CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                //add the unicode marker to the beginning of the file
                //so that APIs know for sure that it is a unicode file.
                WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR),
                          &dwWritten, NULL);
                //add some unicode characters to the file.
                WriteFile(hFile, L"     \r\n", 7 * sizeof(WCHAR),
                          &dwWritten, NULL);
                CloseHandle(hFile);
                Status = ERROR_SUCCESS;
            }
            else
            {
                Status = GetLastError();
            }
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsValidPrefix
//
//  Synopsis:   Given a path, this function determines if it is a valid prefix
//
//  Arguments:  [in] pathType : the type of the path
//              [in] pwszPath : the supplied path
//
//  Returns:    TRUE: if the prefix is valid.
//              FALSE: otherwise
//
//  History:    3/14/2000  RahulTh  created
//
//  Notes:      A valid prefix is either a non-unc path or a UNC path which
//              has at least the server and the share component. It must also
//              be a non-empty path.
//
//---------------------------------------------------------------------------
BOOL IsValidPrefix (UINT pathType, LPCTSTR pwszPath)
{
    CString       szPath;
    const WCHAR * pwszProcessedPath;

    if (! pwszPath || L'\0' == *pwszPath)
        return FALSE;

    szPath = pwszPath;
    szPath.TrimLeft();
    szPath.TrimRight();
    szPath.TrimRight(L'\\');
    pwszProcessedPath = (LPCTSTR) szPath;

    if (PathIsUNC ((LPCTSTR) szPath))
    {
        // Make sure it has both the server and the share component
        if (lstrlen (pwszProcessedPath) <= 2 ||
            L'\\' != pwszProcessedPath[0] ||
            L'\\' != pwszProcessedPath[1] ||
            NULL ==  wcschr (&pwszProcessedPath[2], L'\\'))
        {
            return FALSE;
        }
    }

    //
    // If we are here, we just need to make sure that the path does not contain
    // any environment variables -- if it is not IDS_SPECIFIC_PATH
    //
    if (pathType != IDS_SPECIFIC_PATH &&
        NULL != wcschr(pwszProcessedPath, L'%'))
    {
        return FALSE;
    }

    // If we make it up to here, then the path is a valid prefix.

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Function:   AlwaysShowMyPicsNode
//
//  Synopsis:   In WindowsXP, we now show the MyPics node in the scope pane
//              only if My Pics does not follow My Docs. However, if required
//              this MyPics can always be made visible by setting a reg. value
//              under HKLM\Software\Policies\Microsoft\Windows\System called 
//              FRAlwaysShowMyPicsNode. This is a DWORD value and if set to
//              non-zero, the MyPics node will always be displayed.
//
//  Arguments:  none.
//
//  Returns:    TRUE : if the value was found in the registry and was non-zero.
//              FALSE : otherwise.
//
//  History:    4/10/2001  RahulTh  created
//
//  Notes:      Note: In case of errors, the default value of FALSE is returned.
//
//---------------------------------------------------------------------------
BOOL AlwaysShowMyPicsNode (void)
{
    BOOL    bAlwaysShowMyPics = FALSE;
    DWORD   dwValue = 0;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);
    HKEY    hKey = NULL;
    
    if (ERROR_SUCCESS != RegOpenKey (HKEY_LOCAL_MACHINE,
                                     TEXT("Software\\Policies\\Microsoft\\Windows\\System"),
                                     &hKey)
        )
    {
        return bAlwaysShowMyPics;
    }
    
    if (ERROR_SUCCESS == RegQueryValueEx (hKey,
                                          TEXT("FRAlwaysShowMyPicsNode"),
                                          NULL,
                                          &dwType,
                                          (LPBYTE)(&dwValue),
                                          &dwSize)
        )
    {
        if (REG_DWORD == dwType && dwValue)
            bAlwaysShowMyPics = TRUE;
    }
    
    RegCloseKey(hKey);
    
    return bAlwaysShowMyPics;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateThemedPropertyPage
//
//  Synopsis:   Helper function to make sure that property pages put up
//              by the snap-in are themed.
//
//  Arguments:
//
//  Returns:
//
//  History:    4/20/2001  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HPROPSHEETPAGE CreateThemedPropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\compdata.cpp ===
//*************************************************************
//  File name: COMPDATA.C
//
//  Description:  Main component of the GPE snapin
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#include "main.h"
#include <initguid.h>
#include "compdata.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentData::CComponentData()
{
    InterlockedIncrement(&g_cRefThisDll);
    m_cRef = 1;
    m_hwndFrame = NULL;
    m_bOverride = FALSE;
    m_bDirty = FALSE;
    m_bRefocusInit = FALSE;
    m_pGPO = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_hMachine = NULL;
    m_hUser = NULL;
    m_gpHint = GPHintUnknown;
    m_pDisplayName = NULL;

    m_pChoosePath = NULL;
    m_hChooseBitmap = NULL;
    m_tChooseGPOType = GPOTypeLocal;
}

CComponentData::~CComponentData()
{
    if (m_pDisplayName)
    {
        LocalFree (m_pDisplayName);
    }

    if (m_pChoosePath)
    {
        LocalFree (m_pChoosePath);
    }

    if (m_hChooseBitmap)
    {
        DeleteObject (m_hChooseBitmap);
    }

    if (m_pGPO)
    {
        m_pGPO->Release();
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }


    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IUnknown)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IComponentData)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    HBITMAP hbmp32x32;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
    hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                      reinterpret_cast<LONG_PTR *>(hbmp32x32),
                      0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreateComponent: Failed to create CSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject;
    LPGPEDATAOBJECT pGPEDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPODataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pGPEDataObject->SetType(type);
    pGPEDataObject->SetCookie(cookie);
    pGPEDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_EXPAND:
            if (arg == TRUE)
                hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
            break;

        case MMCN_PRELOAD:
            if (!m_bRefocusInit)
            {
                SCOPEDATAITEM item;

                DebugMsg((DM_VERBOSE, TEXT("CComponentData::Notify:  Received MMCN_PRELOAD event.")));
                m_bRefocusInit = TRUE;

                ZeroMemory (&item, sizeof(SCOPEDATAITEM));
                item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
                item.displayname = MMC_CALLBACK;

                if (m_pGPO)
                {
                    item.nImage = 2;
                    item.nOpenImage = 2;
                }
                else
                {
                    item.nImage = 3;
                    item.nOpenImage = 3;
                }

                item.ID = (HSCOPEITEM) arg;

                m_pScope->SetItem (&item);
            }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if (g_NameSpace[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == g_dwNameSpaceItems)
        pItem->displayname = NULL;
    else
    {
        if (((DWORD) pItem->lParam == 0) && m_pDisplayName)
            pItem->displayname = m_pDisplayName;
        else
            pItem->displayname = g_NameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObjectA, pGPEDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPODataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectB)))
    {
        pGPEDataObjectA->Release();
        return S_FALSE;
    }

    pGPEDataObjectA->GetCookie(&cookie1);
    pGPEDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPEDataObjectA->Release();
    pGPEDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IExtendPropertySheet)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage;
    HPROPSHEETPAGE *hPages;
    UINT i, uPageCount;
    TCHAR szTitle[150];



    if (IsSnapInManager(lpDataObject) == S_OK)
    {
        //
        // Create the wizard property sheet
        //

        LoadString (g_hInstance, IDS_GPE_WELCOME, szTitle, ARRAYSIZE(szTitle));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_CHOOSE_INTRO);
        psp.pfnDlgProc = ChooseInitDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pszHeaderTitle = szTitle;
        psp.pszHeaderSubTitle = NULL;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            return E_FAIL;
        }

        return (lpProvider->AddPage(hPage));
    }


    //
    // If we don't have a GPO, exit now.
    //

    if (!m_pGPO)
    {
        return E_FAIL;
    }


    //
    // Check if this is the GPO root object.  If so we'll display a
    // properties page.
    //

    if (IsGPORoot(lpDataObject) != S_OK)
    {
        return E_FAIL;
    }


    //
    // Ask the GPO for the property sheet pages
    //

    hr = m_pGPO->GetPropertySheetPages (&hPages, &uPageCount);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to query property sheet pages with 0x%x."), hr));
        return hr;
    }


    //
    // Add the pages
    //

    for (i = 0; i < uPageCount; i++)
    {
        hr = lpProvider->AddPage(hPages[i]);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to add property sheet page with 0x%x."), hr));
            return hr;
        }
    }

    LocalFree (hPages);

    return hr;
}

STDMETHODIMP CComponentData::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;

    hr = IsSnapInManager(lpDataObject);

    if (hr != S_OK)
    {
        hr = IsGPORoot(lpDataObject);

        if ((hr == S_OK) && !m_pGPO)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CComponentData::GetWatermarks(LPDATAOBJECT lpIDataObject,
                                           HBITMAP* lphWatermark,
                                           HBITMAP* lphHeader,
                                           HPALETTE* lphPalette,
                                           BOOL* pbStretch)
{
    *lphPalette = NULL;
    *lphHeader = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_HEADER));
    *lphWatermark = NULL;
    *pbStretch = TRUE;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IExtendContextMenu)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::AddMenuItems(LPDATAOBJECT piDataObject,
                                          LPCONTEXTMENUCALLBACK pCallback,
                                          LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;


    if (!m_pGPO)
    {
        DebugMsg((DM_VERBOSE, TEXT("CComponentData::AddMenuItems: No GPO available.  Exiting.")));
        return S_OK;
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        if (IsGPORoot(piDataObject) == S_OK)
        {
            LoadString (g_hInstance, IDS_DCOPTIONS, szMenuItem, 100);
            LoadString (g_hInstance, IDS_DCOPTIONSDESC, szDescription, 250);

            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_DCOPTIONS;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            item.fFlags = 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);
        }
    }


    return (hr);
}

STDMETHODIMP CComponentData::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{
    DCSELINFO SelInfo;
    INT iResult = 1;
    HKEY hKey;
    DWORD dwDisp, dwSize, dwType;

    if (lCommandID == IDM_DCOPTIONS)
    {

        //
        // Get the user's current DC preference
        //

        if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(iResult);
            RegQueryValueEx(hKey, DCOPTION_VALUE, NULL, &dwType,
                            (LPBYTE)&iResult, &dwSize);

            RegCloseKey(hKey);
        }


        //
        // Show the dialog
        //

        SelInfo.bError = FALSE;
        SelInfo.bAllowInherit = TRUE;
        SelInfo.iDefault = iResult;
        SelInfo.lpDomainName = NULL;

        iResult = (INT)DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_NODC), NULL,
                                  DCDlgProc, (LPARAM) &SelInfo);


        //
        // Save the preference if appropriate
        //

        if (iResult > 0)
        {
            if (RegCreateKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                &hKey, &dwDisp) == ERROR_SUCCESS)
            {
                RegSetValueEx (hKey, DCOPTION_VALUE, 0, REG_DWORD,
                              (LPBYTE)&iResult, sizeof(iResult));

                RegCloseKey (hKey);
            }
        }
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IPersistStreamInit)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    *pClassID = CLSID_GPESnapIn;

    return S_OK;
}

STDMETHODIMP CComponentData::IsDirty(VOID)
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
    HRESULT hr = E_FAIL;
    DWORD dwVersion;
    DWORD dwPathLen;
    ULONG nBytesRead;
    DWORD dwFlags = 0;
    LPTSTR lpPath = NULL;
    LPTSTR lpCommandLine = NULL;
    GROUP_POLICY_HINT_TYPE gpHint;
    LPOLESTR pszDomain;
    LPTSTR lpDomainName;
    LPTSTR lpDCName;
    LPTSTR lpTemp, lpHint, lpName;
    TCHAR szHint[10];
    TCHAR szComputerName[MAX_PATH];
    INT iStrLen, iTemp;


    //
    // Parameter / initialization check
    //

    if (!pStm)
        return E_FAIL;

    if (m_pGPO)
        return E_UNEXPECTED;


    //
    // Get the command line
    //

    lpCommandLine = GetCommandLine();


    //
    // Create a GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&m_pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to create a GPO object with 0x%x."), hr));
        goto Exit;
    }


    //
    // Read in the saved data version number
    //

    hr = pStm->Read(&dwVersion, sizeof(dwVersion), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read version number with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Confirm that we are working with version 2
    //

    if (dwVersion != PERSIST_DATA_VERSION)
    {
        ReportError(m_hwndFrame, 0, IDS_INVALIDMSC);
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Wrong version number (%d)."), dwVersion));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read the flags
    //

    hr = pStm->Read(&dwFlags, sizeof(dwFlags), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwFlags)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read flags with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read the hint information
    //

    hr = pStm->Read(&gpHint, sizeof(gpHint), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(gpHint)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read hint with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read in the path string length (including null terminator)
    //

    hr = pStm->Read(&dwPathLen, sizeof(dwPathLen), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwPathLen)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read path size with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read in the path if there is one
    //

    if (dwPathLen > 0)
    {

        lpPath = (LPTSTR) LocalAlloc (LPTR, dwPathLen);

        if (!lpPath)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to allocate memory with %d."),
                     GetLastError()));
            hr = E_FAIL;
            goto Exit;
        }

        hr = pStm->Read(lpPath, dwPathLen, &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != dwPathLen))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to read path with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Path is: <%s>"), lpPath));
    }


    //
    // Parse the command line
    //

    if (dwFlags & MSC_FLAG_OVERRIDE)
    {

        m_bOverride = TRUE;
        DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Command line switch override enabled.  Command line = %s"), lpCommandLine));

        lpTemp = lpCommandLine;
        iStrLen = lstrlen (CMD_LINE_START);

        do
        {
            if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              CMD_LINE_START, iStrLen,
                              lpTemp, iStrLen) == CSTR_EQUAL)
            {

                iTemp = lstrlen (CMD_LINE_HINT);
                if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                  CMD_LINE_HINT, iTemp,
                                  lpTemp, iTemp) == CSTR_EQUAL)
                {

                    //
                    // Found the hint switch
                    //

                    lpTemp += iTemp;
                    ZeroMemory (szHint, sizeof(szHint));
                    lpHint = szHint;

                    while (*lpTemp && ((*lpTemp) != TEXT(' ')))
                        *lpHint++ = *lpTemp++;

                    if (szHint[0] != TEXT('\0'))
                    {
                        gpHint = (GROUP_POLICY_HINT_TYPE) _ttoi(szHint);
                    }

                    continue;
                }


                iTemp = lstrlen (CMD_LINE_COMPUTER);
                if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                  CMD_LINE_COMPUTER, iTemp,
                                  lpTemp, iTemp) == CSTR_EQUAL)
                {

                    //
                    // Found the computer switch
                    //

                    lpTemp += iTemp + 1;
                    ZeroMemory (szComputerName, sizeof(szComputerName));
                    lpName = szComputerName;

                    while (*lpTemp && ((*lpTemp) != TEXT('\"')))
                        *lpName++ = *lpTemp++;

                    if ((*lpTemp) == TEXT('\"'))
                        lpTemp++;

                    if (szComputerName[0] != TEXT('\0'))
                    {
                        if (lpPath)
                        {
                            LocalFree (lpPath);
                        }

                        lpPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szComputerName) + 1) * sizeof(TCHAR));

                        if (lpPath)
                        {
                            lstrcpy (lpPath, szComputerName);

                            dwFlags &= ~MSC_FLAG_LOCAL_GPO;
                            dwFlags &= ~MSC_FLAG_DS_GPO;
                            dwFlags |= MSC_FLAG_REMOTE_GPO;
                        }
                    }

                    continue;
                }


                iTemp = lstrlen (CMD_LINE_GPO);
                if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                  CMD_LINE_GPO, iTemp,
                                  lpTemp, iTemp) == CSTR_EQUAL)
                {

                    //
                    // Found the gpo switch
                    //

                    lpTemp += iTemp + 1;

                    if (lpPath)
                    {
                        LocalFree (lpPath);
                    }

                    lpPath = (LPTSTR) LocalAlloc (LPTR, 512 * sizeof(TCHAR));

                    if (!lpPath)
                    {
                        lpTemp++;
                        continue;
                    }

                    dwFlags &= ~MSC_FLAG_LOCAL_GPO;
                    dwFlags &= ~MSC_FLAG_REMOTE_GPO;
                    dwFlags |= MSC_FLAG_DS_GPO;

                    lpName = lpPath;

                    while (*lpTemp && ((*lpTemp) != TEXT('\"')))
                        *lpName++ = *lpTemp++;

                    if ((*lpTemp) == TEXT('\"'))
                        lpTemp++;

                    DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Command line path is: <%s>"), lpPath));

                    continue;
                }
            }

            lpTemp++;

        } while (*lpTemp);
    }
    else if (dwFlags & MSC_FLAG_DS_GPO && dwPathLen > 0)
    {
        //
        // Get the friendly domain name
        //

        pszDomain = GetDomainFromLDAPPath(lpPath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpDomainName);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the domain controller for this domain
        //

        lpDCName = GetDCName (lpDomainName, NULL, NULL, TRUE, 0);

        LocalFree (lpDomainName);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load:  Failed to get DC name")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Make a full path
        //

        lpTemp = MakeFullPath (lpPath, lpDCName);

        LocalFree (lpDCName);

        if (!lpTemp)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Load:  Failed to make full path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Swap the relative path with the full path
        //

        LocalFree (lpPath);
        lpPath = lpTemp;

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Full Path is: <%s>"), lpPath));
    }


    //
    // Do the appropriate action
    //

    if (dwFlags & MSC_FLAG_LOCAL_GPO)
    {
        hr = m_pGPO->OpenLocalMachineGPO(TRUE);

        if (FAILED(hr))
        {
            ReportError(m_hwndFrame, hr, IDS_FAILEDLOCAL);
        }
    }
    else if (dwFlags & MSC_FLAG_REMOTE_GPO)
    {
        if (lpPath)
        {
            hr = m_pGPO->OpenRemoteMachineGPO(lpPath, TRUE);

            if (FAILED(hr))
            {
                ReportError(m_hwndFrame, hr, IDS_FAILEDREMOTE, lpPath);
            }
        }
        else
        {
            hr = E_FAIL;
            ReportError(m_hwndFrame, hr, IDS_INVALIDMSC);
        }
    }
    else
    {
        if (lpPath)
        {
            hr = m_pGPO->OpenDSGPO(lpPath, GPO_OPEN_LOAD_REGISTRY);

            if (FAILED(hr))
            {
                ReportError(m_hwndFrame, hr, IDS_FAILEDDS, lpPath);
            }
        }
        else
        {
            hr = E_FAIL;
            ReportError(m_hwndFrame, hr, IDS_INVALIDMSC);
        }
    }


    if (SUCCEEDED(hr))
    {

        ClearDirty();
        m_gpHint = gpHint;

        BuildDisplayName();
    }

Exit:

    if (FAILED(hr) && m_pGPO)
    {
        m_pGPO->Release();
        m_pGPO = NULL;
    }


    if (lpPath)
    {
        LocalFree (lpPath);
    }

    DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Leaving with 0x%x."), hr));

    return hr;
}


STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = STG_E_CANTSAVE;
    ULONG nBytesWritten;
    DWORD dwTemp;
    DWORD dwFlags;
    GROUP_POLICY_OBJECT_TYPE gpoType;
    LPTSTR lpPath = NULL;
    LPTSTR lpTemp;
    DWORD dwPathSize = 1024;


    if (!pStm)
    {
        return E_FAIL;
    }


    if (!m_pGPO)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: No GPO.  Leaving.")));
        goto Exit;
    }


    //
    // Allocate a buffer to hold the path
    //

    lpPath = (LPTSTR) LocalAlloc(LPTR, dwPathSize * sizeof(TCHAR));

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to alloc buffer for path with %d."), GetLastError()));
        goto Exit;
    }

    //
    // Determine what the flags are
    //

    dwFlags = 0;

    if (m_bOverride)
    {
        dwFlags |= MSC_FLAG_OVERRIDE;
    }

    m_pGPO->GetType (&gpoType);

    if (gpoType == GPOTypeLocal)
    {
        dwFlags |= MSC_FLAG_LOCAL_GPO;
        hr = S_OK;
    }
    else if (gpoType == GPOTypeRemote)
    {
        dwFlags |= MSC_FLAG_REMOTE_GPO;
        hr = m_pGPO->GetMachineName (lpPath, dwPathSize);
    }
    else
    {
        dwFlags |= MSC_FLAG_DS_GPO;
        hr = m_pGPO->GetPath (lpPath, dwPathSize);

        if (SUCCEEDED(hr))
        {
            lpTemp = MakeNamelessPath (lpPath);

            if (!lpTemp)
            {
                DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to get nameless path")));
                goto Exit;
            }

            DebugMsg((DM_VERBOSE, TEXT("CComponentData::Save: Nameless GPO path is:  %s"), lpTemp));

            LocalFree (lpPath);
            lpPath = lpTemp;
        }
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to get path with %d."), hr));
        goto Exit;
    }


    //
    // Save the version number
    //

    dwTemp = PERSIST_DATA_VERSION;
    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write version number with %d."), hr));
        goto Exit;
    }


    //
    // Save the flags
    //

    hr = pStm->Write(&dwFlags, sizeof(dwFlags), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwFlags)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write flags with %d."), hr));
        goto Exit;
    }


    //
    // Save the hint information
    //

    hr = pStm->Write(&m_gpHint, sizeof(m_gpHint), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(m_gpHint)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write hint with %d."), hr));
        goto Exit;
    }


    //
    // Save the path length
    //

    dwTemp = lstrlen (lpPath);

    if (dwTemp)
    {
        dwTemp = (dwTemp + 1) * sizeof (TCHAR);
    }

    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write ds path length with %d."), hr));
        goto Exit;
    }


    if (dwTemp)
    {
        //
        // Save the path
        //

        hr = pStm->Write(lpPath, dwTemp, &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != dwTemp))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::Save: Failed to write ds path with %d."), hr));
            goto Exit;
        }
    }

    if (fClearDirty)
    {
        ClearDirty();
    }

Exit:

    if (lpPath)
    {
        LocalFree (lpPath);
    }

    return hr;
}


STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    HRESULT hr = E_FAIL;
    DWORD dwSize;
    LPTSTR lpPath = NULL;
    LPTSTR lpTemp;
    GROUP_POLICY_OBJECT_TYPE gpoType;
    DWORD dwPathSize = 1024;
    DWORD dwStrLen;


    //
    // Check arguments
    //

    if (!pcbSize)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: NULL pcbSize argument")));
        goto Exit;
    }


    //
    // Allocate a buffer to hold the path
    //

    lpPath = (LPTSTR) LocalAlloc(LPTR, dwPathSize * sizeof(TCHAR));

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: Failed to alloc buffer for path with %d."), GetLastError()));
        goto Exit;
    }


    //
    // Get the path if appropriate
    //

    m_pGPO->GetType (&gpoType);

    if (gpoType == GPOTypeLocal)
    {
        hr = S_OK;
    }
    else if (gpoType == GPOTypeRemote)
    {
        hr = m_pGPO->GetMachineName (lpPath, dwPathSize);
    }
    else
    {
        hr = m_pGPO->GetPath (lpPath, dwPathSize);

        if (SUCCEEDED(hr))
        {
            lpTemp = MakeNamelessPath (lpPath);

            if (!lpTemp)
            {
                DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: Failed to get nameless path")));
                goto Exit;
            }

            LocalFree (lpPath);
            lpPath = lpTemp;
        }
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetSizeMax: Failed to get path with %d."), hr));
        goto Exit;
    }


    //
    // Set the stream size.  Version Number + Flags + Length + Unicode String + null
    //

    dwSize = 3 * sizeof(DWORD);

    dwStrLen = lstrlen(lpPath);
    if (dwStrLen)
    {
        dwSize += (dwStrLen + 1) * sizeof (TCHAR);
    }


    ULISet32(*pcbSize, dwSize);

    hr = S_OK;

Exit:

    if (lpPath)
    {
        LocalFree (lpPath);
    }

    return hr;
}

STDMETHODIMP CComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (ISnapinHelp)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gpedit.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CComponentData::InitializeNewGPO(HWND hDlg)
{
    HRESULT hr;


    DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO: Entering")));

    SetWaitCursor();

    //
    // Clean up existing GPO
    //

    if (m_pGPO)
    {
        m_pGPO->Release();
    }


    //
    // Create a new GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&m_pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO: Failed to create GPO with 0x%x."), hr));
        goto Exit;
    }


    //
    // Determine which item was selected
    //

    switch (m_tChooseGPOType)
    {
    case GPOTypeLocal:
        //
        // Open local policy
        //

        hr = m_pGPO->OpenLocalMachineGPO(TRUE);

        if (FAILED(hr))
        {
            ReportError(hDlg, hr, IDS_FAILEDLOCAL);
        }
        else
        {
            m_gpHint = GPHintMachine;
        }
        break;
    case GPOTypeRemote:
        //
        // Open remote policy
        //

        hr = m_pGPO->OpenRemoteMachineGPO (m_pChoosePath, TRUE);

        if (FAILED(hr))
        {
            ReportError(hDlg, hr, IDS_FAILEDREMOTE, m_pChoosePath);
        }
        else
        {
            m_gpHint = GPHintMachine;
        }
        break;
    case GPOTypeDS:
        {
        LPOLESTR pszDomain;
        LPTSTR lpDomainName;
        LPTSTR lpDCName;
        LPTSTR lpTemp;


        //
        // Open existing DS GPO
        //

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO: User selected %s"), m_pChoosePath));


        //
        // Get the friendly domain name
        //

        pszDomain = GetDomainFromLDAPPath(m_pChoosePath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpDomainName);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the domain controller for this domain
        //

        lpDCName = GetDCName (lpDomainName, NULL, hDlg, TRUE, 0);

        LocalFree (lpDomainName);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeNewGPO:  Failed to get DC name")));
            goto Exit;
        }


        //
        // Build the full path
        //

        lpTemp = MakeFullPath (m_pChoosePath, lpDCName);

        LocalFree (lpDCName);

        if (!lpTemp)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO:  Full ADSI path is %s"),
                 lpTemp));


        hr = m_pGPO->OpenDSGPO (lpTemp, GPO_OPEN_LOAD_REGISTRY);

        if (FAILED(hr))
        {
            ReportError(hDlg, hr, IDS_FAILEDDS, lpTemp);
        }
        else
        {
            m_gpHint = GPHintUnknown;
        }

        LocalFree (lpTemp);

        }
        break;
    default:
        hr = E_FAIL;
    }

Exit:

    ClearWaitCursor();


    if (SUCCEEDED(hr))
    {

        if (IsDlgButtonChecked (hDlg, IDC_OVERRIDE))
        {
            m_bOverride = TRUE;
        }
        else
        {
            m_bOverride = FALSE;
        }

        SetDirty();

        BuildDisplayName();
    }
    else
    {
        if (m_pGPO)
        {
            m_pGPO->Release();
            m_pGPO = NULL;
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("CComponentData::InitializeNewGPO: Leaving with 0x%x."), hr));

    return hr;
}

HRESULT CComponentData::BuildDisplayName(void)
{
    WCHAR  szDispName[50];
    WCHAR  szDisplayName[MAX_FRIENDLYNAME + MAX_PATH + 20];
    WCHAR  szFriendlyName[MAX_FRIENDLYNAME];
    WCHAR  szDCName[MAX_PATH];
    GROUP_POLICY_OBJECT_TYPE type;


    szDisplayName[0] = TEXT('\0');

    if (SUCCEEDED(m_pGPO->GetDisplayName(szFriendlyName, ARRAYSIZE(szFriendlyName))))
    {
        if (SUCCEEDED(m_pGPO->GetMachineName(szDCName, ARRAYSIZE(szDCName))))
        {
            if (SUCCEEDED(m_pGPO->GetType(&type)))
            {
                if ((szDCName[0] == TEXT('\0')) || (type != GPOTypeDS))
                {
                    LoadStringW (g_hInstance, IDS_DISPLAYNAME, szDispName, ARRAYSIZE(szDispName));
                    wsprintf (szDisplayName, szDispName, szFriendlyName);
                }
                else
                {
                    LoadStringW (g_hInstance, IDS_DISPLAYNAME2, szDispName, ARRAYSIZE(szDispName));
                    wsprintf (szDisplayName, szDispName, szFriendlyName, szDCName);
                }
            }
        }
    }

    if (szDisplayName[0] == TEXT('\0'))
    {
        LoadStringW (g_hInstance, IDS_SNAPIN_NAME, szDisplayName, ARRAYSIZE(szDisplayName));
    }

    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szDisplayName) + 1) * sizeof(TCHAR));

    if (m_pDisplayName)
    {
        lstrcpy (m_pDisplayName, szDisplayName);
    }

    return S_OK;
}



//
// Returns S_OK if this is the GPO root in the scope pane or results pane.
// S_FALSE if not.
//

HRESULT CComponentData::IsGPORoot (LPDATAOBJECT lpDataObject)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObject;
    DATA_OBJECT_TYPES type;
    MMC_COOKIE cookie;


    //
    // We can determine if this is a GPO DataObject by trying to
    // QI for the private IGPEDataObject interface.  If found,
    // it belongs to us.
    //

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPEDataObject,
                 (LPVOID *)&pGPEDataObject)))
    {

        pGPEDataObject->GetType(&type);
        pGPEDataObject->GetCookie(&cookie);

        if ((type == CCT_SCOPE) && (cookie == 0))
        {
            hr = S_OK;
        }

        pGPEDataObject->Release();
    }

    return (hr);
}

HRESULT CComponentData::IsSnapInManager (LPDATAOBJECT lpDataObject)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObject;
    DATA_OBJECT_TYPES type;


    //
    // We can determine if this is a GPO DataObject by trying to
    // QI for the private IGPEDataObject interface.  If found,
    // it belongs to us.
    //

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IGPEDataObject,
                 (LPVOID *)&pGPEDataObject)))
    {

        //
        // This is a GPO object.  Now see if is a scope pane
        // data object.  We only want to display the property
        // sheet for the scope pane.
        //

        if (SUCCEEDED(pGPEDataObject->GetType(&type)))
        {
            if (type == CCT_SNAPIN_MANAGER)
            {
                hr = S_OK;
            }
        }
        pGPEDataObject->Release();
    }

    return (hr);
}

HRESULT CComponentData::GetDefaultDomain (LPTSTR *lpDomain, HWND hDlg)
{
    LPTSTR lpUserName = NULL;
    LPTSTR lpFullUserName = NULL;
    LPTSTR lpResult = NULL;
    LPTSTR lpDCName = NULL;
    LPOLESTR lpDomainTemp = NULL;
    LPTSTR lpFullDomain = NULL;
    HRESULT hr = S_OK;


    //
    // Get the username in DN format
    //

    lpUserName = MyGetUserName (NameFullyQualifiedDN);

    if (!lpUserName) {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain:  MyGetUserName failed for DN style name with %d"),
                 GetLastError()));
        hr = E_FAIL;
        goto Exit;
    }


    lpFullUserName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpUserName) + 10) * sizeof(TCHAR));

    if (!lpFullUserName)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain:  Failed to allocate memory for full user name with %d"),
                 GetLastError()));
        hr = E_FAIL;
        goto Exit;
    }

    lstrcpy (lpFullUserName, TEXT("LDAP://"));
    lstrcat (lpFullUserName, lpUserName);


    //
    // Get the domain from the ldap path
    //

    lpDomainTemp = GetDomainFromLDAPPath(lpFullUserName);

    if (!lpDomainTemp) {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain:  Failed to get domain from ldap path")));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Get the domain controller for this domain
    //

    hr = ConvertToDotStyle (lpDomainTemp, &lpResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain: Failed to convert domain name with 0x%x"), hr));
        hr = E_FAIL;
        goto Exit;
    }

    lpDCName = GetDCName (lpResult, NULL, hDlg, TRUE, 0);

    if (!lpDCName)
    {
        DebugMsg((DM_WARNING, TEXT("CComponentData::GetDefaultDomain: Failed to query <%s> for a DC name with 0xd"),
                 lpResult, GetLastError()));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Build a fully qualified domain name to a specific DC
    //

    lpFullDomain = MakeFullPath (lpDomainTemp, lpDCName);

    if (!lpFullDomain)
    {
        hr = E_FAIL;
        goto Exit;
    }

    *lpDomain = lpFullDomain;


Exit:

    if (lpDomainTemp)
        delete [] lpDomainTemp;

    if (lpUserName)
        LocalFree (lpUserName);

    if (lpFullUserName)
        LocalFree (lpFullUserName);

    if (lpResult)
        LocalFree (lpResult);

    if (lpDCName)
        LocalFree (lpDCName);

    return hr;
}


INT_PTR CALLBACK CComponentData::ChooseInitDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CComponentData * pCD;


    switch (message)
    {
        case WM_INITDIALOG:
            {
            TCHAR szDefaultGPO[128];

            pCD = (CComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

            pCD->m_pChoosePath = NULL;
            pCD->m_tChooseGPOType = GPOTypeLocal;

            SendDlgItemMessage (hDlg, IDC_DS_GPO, BM_SETCHECK, BST_CHECKED, 0);

            if (!pCD->m_hChooseBitmap)
            {
                pCD->m_hChooseBitmap = (HBITMAP) LoadImage (g_hInstance,
                                                            MAKEINTRESOURCE(IDB_WIZARD),
                                                            IMAGE_BITMAP, 0, 0,
                                                            LR_DEFAULTCOLOR);
            }

            if (pCD->m_hChooseBitmap)
            {
                SendDlgItemMessage (hDlg, IDC_BITMAP, STM_SETIMAGE,
                                    IMAGE_BITMAP, (LPARAM) pCD->m_hChooseBitmap);
            }


            LoadString(g_hInstance, IDS_LOCAL_DISPLAY_NAME, szDefaultGPO,
                       ARRAYSIZE(szDefaultGPO));
            SetDlgItemText (hDlg, IDC_OPEN_NAME, szDefaultGPO);
            }
            break;

        case WM_COMMAND:
            {
            pCD = (CComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD) {
                break;
            }

            switch (LOWORD(wParam))
            {
                case IDC_OPEN_BROWSE:
                    {
                    LPTSTR lpDomain = NULL;
                    TCHAR szPath[512];
                    TCHAR szName[MAX_FRIENDLYNAME];
                    GPOBROWSEINFO info;

                    ZeroMemory (&info, sizeof(GPOBROWSEINFO));

                    if (!IsStandaloneComputer())
                    {
                        pCD->GetDefaultDomain (&lpDomain, hDlg);
                    }

                    info.dwSize = sizeof(GPOBROWSEINFO);
                    info.hwndOwner = hDlg;
                    info.lpInitialOU = lpDomain;
                    info.lpDSPath = szPath;
                    info.dwDSPathSize = ARRAYSIZE(szPath);
                    info.lpName = szName;
                    info.dwNameSize = ARRAYSIZE(szName);
                    if (!lpDomain)
                    {
                        info.dwFlags = GPO_BROWSE_NODSGPOS;
                    }

                    if (SUCCEEDED(BrowseForGPO(&info)))
                    {
                        if (pCD->m_pChoosePath)
                        {
                            LocalFree (pCD->m_pChoosePath);
                            pCD->m_pChoosePath = NULL;
                        }

                        pCD->m_tChooseGPOType = info.gpoType;

                        switch (pCD->m_tChooseGPOType)
                        {
                            default:
                            case GPOTypeLocal:
                                LoadString(g_hInstance, IDS_LOCAL_DISPLAY_NAME, szPath, ARRAYSIZE(szPath));
                                break;

                            case GPOTypeRemote:
                                pCD->m_pChoosePath = (LPTSTR) LocalAlloc (LPTR, (lstrlen (szName) + 1) * sizeof(TCHAR));

                                if (pCD->m_pChoosePath)
                                {
                                    lstrcpy (pCD->m_pChoosePath, szName);
                                }

                                LoadString(g_hInstance, IDS_REMOTE_DISPLAY_NAME, szPath, ARRAYSIZE(szPath));
                                lstrcat(szPath, szName);
                                break;

                            case GPOTypeDS:
                                pCD->m_pChoosePath = (LPTSTR) LocalAlloc (LPTR, (lstrlen (szPath) + 1) * sizeof(TCHAR));

                                if (pCD->m_pChoosePath)
                                {
                                    lstrcpy (pCD->m_pChoosePath, szPath);
                                }

                                lstrcpy(szPath, szName);
                                break;
                        }

                        SetDlgItemText (hDlg, IDC_OPEN_NAME, szPath);
                    }

                    if (lpDomain)
                    {
                        LocalFree (lpDomain);
                    }

                    }
                    break;
            }

            }
            break;

        case WM_REFRESHDISPLAY:
            SetFocus (GetDlgItem(hDlg, IDC_OPEN_NAME));
            break;

        case WM_NOTIFY:

            pCD = (CComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCD) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_FINISH);
                    break;

                case PSN_WIZFINISH:
                    if (FAILED(pCD->InitializeNewGPO(hDlg)))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                        return TRUE;
                    }

                    // fall through

                case PSN_RESET:

                    if (pCD->m_pChoosePath)
                    {
                        LocalFree (pCD->m_pChoosePath);
                        pCD->m_pChoosePath = NULL;
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}

HRESULT CComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot) {

        m_hRoot = hParent;

        if (!m_bRefocusInit)
        {
            SCOPEDATAITEM item;

            DebugMsg((DM_VERBOSE, TEXT("CComponentData::EnumerateScopePane:  Resetting the root node")));
            m_bRefocusInit = TRUE;

            ZeroMemory (&item, sizeof(SCOPEDATAITEM));
            item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
            item.displayname = MMC_CALLBACK;

            if (m_pGPO)
            {
                item.nImage = 2;
                item.nOpenImage = 2;
            }
            else
            {
                item.nImage = 3;
                item.nOpenImage = 3;
            }

            item.ID = hParent;

            m_pScope->SetItem (&item);
        }
    }


    if (!m_pGPO)
    {
        if (m_hRoot == hParent)
        {
            SCOPEDATAITEM item;

            DebugMsg((DM_VERBOSE, TEXT("CComponentData::EnumerateScopePane: No GPO available.  Exiting.")));

            ZeroMemory (&item, sizeof(SCOPEDATAITEM));
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 3;
            item.nOpenImage = 3;
            item.nState = 0;
            item.cChildren = 0;
            item.lParam = g_NameSpace[0].dwID;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }

        return S_OK;
    }


    if (m_hRoot == hParent)
    {
        dwIndex = 0;
    }
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD)item.lParam;
    }

    for (i = 0; i < g_dwNameSpaceItems; i++)
    {
        if (g_NameSpace[i].dwParent == dwIndex)
        {
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = g_NameSpace[i].iIcon;
            item.nOpenImage = g_NameSpace[i].iOpenIcon;
            item.nState = 0;
            item.cChildren = g_NameSpace[i].cChildren;
            item.lParam = g_NameSpace[i].dwID;
            item.relativeID =  hParent;

            if (SUCCEEDED(m_pScope->InsertItem (&item)))
            {
                if (i == 1)
                {
                    m_hMachine = item.ID;
                }
                else if (i == 2)
                {
                    m_hUser = item.ID;
                }
            }
        }
    }

    return S_OK;
}

HRESULT CComponentData::GetOptions (DWORD * pdwOptions)
{

    if (!pdwOptions)
    {
        return E_INVALIDARG;
    }


    *pdwOptions = 0;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentDataCF::CComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CComponentDataCF::~CComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CComponentData *pComponentData = new CComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\compspp.h ===
#if !defined __COMPSPP_H__
#define __COMPSPP_H__

#include "cproppg.h"

/////////////////////////////////////////////////////////////////////////////
// CCompsPP dialog

class CCompsPP:CHlprPropPage
{
// Construction
public:
    CCompsPP();
    ~CCompsPP();
    HPROPSHEETPAGE Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void ** ppActive);

    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Dialog Data
    LPCWSTR             m_szComputer;
    int                 m_iSelection;
    LPGPOBROWSEINFO     m_pGBI;
    protected:
    DWORD               m_dwPageType;
    void **             m_ppActive;

private:    //private helper functions
    void    OnBrowseComputers (HWND hwndDlg);
};

#endif // __COMPSPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\compdata.h ===
//
// Root of the name space
// {8FC0B736-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_GPERoot, 0x8fc0b736, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// Computer Configuration
// {8FC0B739-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_MachineRoot, 0x8fc0b739, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration
// {8FC0B73B-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_UserRoot, 0x8fc0b73b, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// Root of the RSOP name space
// {6f13bce5-39fd-45bc-8e9c-2002b409eba5}
//

DEFINE_GUID(NODEID_RSOPRoot, 0x6f13bce5, 0x39fd, 0x45bc, 0x8e, 0x9c, 0x20, 0x02, 0xb4, 0x09, 0xeb, 0xa5);

//
// RSOP Computer Configuration
// {e753a11a-66cc-4816-8dd8-3cbe46717fd3}
//

DEFINE_GUID(NODEID_RSOPMachineRoot, 0xe753a11a, 0x66cc, 0x4816, 0x8d, 0xd8, 0x3c, 0xbe, 0x46, 0x71, 0x7f, 0xd3);

//
// RSOP User Configuration
// {99d5b872-1ad0-4d87-acf1-82125d317653}
//
DEFINE_GUID(NODEID_RSOPUserRoot, 0x99d5b872, 0x1ad0, 0x4d87, 0xac, 0xf1, 0x82, 0x12, 0x5d, 0x31, 0x76, 0x53);

#ifndef _COMPDATA_H_
#define _COMPDATA_H_


//
// CComponentData class
//

class CComponentData:
    public IComponentData,
    public IExtendPropertySheet2,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CDataObject;
    friend class CSnapIn;

protected:
    ULONG                          m_cRef;
    HWND                           m_hwndFrame;
    BOOL                           m_bOverride;
    BOOL                           m_bDirty;
    BOOL                           m_bRefocusInit;
    LPGROUPPOLICYOBJECT            m_pGPO;
    LPCONSOLENAMESPACE             m_pScope;
    LPCONSOLE                      m_pConsole;
    HSCOPEITEM                     m_hRoot;
    HSCOPEITEM                     m_hMachine;
    HSCOPEITEM                     m_hUser;
    GROUP_POLICY_HINT_TYPE         m_gpHint;
    LPTSTR                         m_pDisplayName;
    LPTSTR                         m_pDCName;

    LPTSTR                         m_pChoosePath;
    HBITMAP                        m_hChooseBitmap;
    GROUP_POLICY_OBJECT_TYPE       m_tChooseGPOType;

public:
    CComponentData();
    ~CComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IExtendPropertySheet2 methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);
    STDMETHODIMP         GetWatermarks(LPDATAOBJECT lpIDataObject,  HBITMAP* lphWatermark,
                                       HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* pbStretch);


    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);


    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);


    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);


private:
    HRESULT InitializeNewGPO(HWND hDlg);
    HRESULT BuildDisplayName(void);
    HRESULT IsGPORoot (LPDATAOBJECT lpDataObject);
    HRESULT IsSnapInManager (LPDATAOBJECT lpDataObject);
    HRESULT GetDefaultDomain (LPTSTR *lpDomain, HWND hDlg);
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
    HRESULT GetOptions (DWORD * pdwOptions);

    void SetDirty(VOID)  { m_bDirty = TRUE; }
    void ClearDirty(VOID)  { m_bDirty = FALSE; }
    BOOL ThisIsDirty(VOID) { return m_bDirty; }

    static INT_PTR CALLBACK ChooseInitDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};



//
// ComponentData class factory
//


class CComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CComponentDataCF();
    ~CComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


//
// Save console defines
//

#define PERSIST_DATA_VERSION    3              // version number in msc file

#define MSC_FLAG_OVERRIDE       0x00000001     // allow command line switches to override msc contents
#define MSC_FLAG_LOCAL_GPO      0x00000002     // open local gpo
#define MSC_FLAG_REMOTE_GPO     0x00000004     // open remote gpo, machine name is stored in msc file
#define MSC_FLAG_DS_GPO         0x00000008     // open ds gpo, ldap path is stored in msc file


//
// Command line switches
//

#define CMD_LINE_START          TEXT("/gp")               // base to all group policy command line switches
#define CMD_LINE_HINT           TEXT("/gphint:")          // hint to which DS object (or machine) this gpo is linked to
#define CMD_LINE_GPO            TEXT("/gpobject:")        // gpo path in quotes
#define CMD_LINE_COMPUTER       TEXT("/gpcomputer:")      // computer name in quotes

#endif // _COMPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\dataobj.h ===
//
// IGPEDataobject interface id
//

// {4AE19822-BCEE-11d0-9484-080036B11A03}
DEFINE_GUID(IID_IGPEDataObject, 0x4ae19822, 0xbcee, 0x11d0, 0x94, 0x84, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);



#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
// This is a private dataobject interface for GPE.
// When the GPE snapin receives a dataobject and needs to determine
// if it came from the GPE snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IGPEDataObject
DECLARE_INTERFACE_(IGPEDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPEDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IGPEDataObject *LPGPEDATAOBJECT;



//
// CDataObject class
//

class CDataObject : public IDataObject,
                    public IGPEInformation,
                    public IGPEDataObject
{
    friend class CSnapIn;

protected:

    ULONG                  m_cRef;
    CComponentData        *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfPreloads;
    static unsigned int    m_cfNodeID;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CDataObject(CComponentData *pComponent);
    ~CDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IGPEInformation methods
    //

    STDMETHOD(GetName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetDisplayName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetRegistryKey) (DWORD dwSection, HKEY *hKey);
    STDMETHOD(GetDSPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetFileSysPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetOptions) (DWORD *dwOptions);
    STDMETHOD(GetType) (GROUP_POLICY_OBJECT_TYPE *gpoType);
    STDMETHOD(GetHint) (GROUP_POLICY_HINT_TYPE *gpHint);
    STDMETHOD(PolicyChanged) (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin);


    //
    // Implemented IGPEDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreatePreloadsData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeIDData(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\cproppg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cproppg.h
//
//  Contents:   definition for common property page functionality
//
//  Classes:    CHlprPropPage (pure virtual class)
//
//  Functions:  HlprPropPageDialogProc
//
//  History:    4-12-1994   stevebl   original dialog box helpers Created
//              4-29-1998   stevebl   Modified from dialog box helpers
//
//----------------------------------------------------------------------------

#ifndef __CPROPPG_H__
#define __CPROPPG_H__

#ifdef __cplusplus
extern "C" {
#endif

INT_PTR CALLBACK HlprPropPageDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprPropPage
//
//  Purpose:    virtual base class for wrapping Windows' dialog functionality
//
//  Interface:  ShowDialog -- analagous to the Windows DialogBox function
//              DialogProc -- pure virtual DialogProc for the dialog box
//              ~CHlprPropPage   -- destructor
//
//  History:    4-12-94   stevebl   Created
//              7-02-1997   stevebl   added CreateDlg
//
//  Notes:      This class allows a dialog box to be cleanly wrapped in
//              a c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a DialogProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprPropPage
{
public:
    virtual HPROPSHEETPAGE CreatePropertySheetPage(LPPROPSHEETPAGE lppsp);
    virtual BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprPropPage(){};
protected:
    HINSTANCE m_hInstance;
};

#endif //__cplusplus

#endif //__CPROPPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\cproppg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cproppg.cxx
//
//  Contents:
//
//  Classes:    CHlprPropPage
//
//  Functions:  DialogProc
//
//  History:    4-12-1994   stevebl   original dialog box helpers Created
//              4-29-1998   stevebl   Modified from dialog box helpers
//
//----------------------------------------------------------------------------

#include "main.h"
#include "cproppg.h"

HPROPSHEETPAGE CHlprPropPage::CreatePropertySheetPage(LPPROPSHEETPAGE lppsp)
{
    lppsp->pfnDlgProc = HlprPropPageDialogProc;
    lppsp->lParam = (LPARAM)(CHlprPropPage *) this;
    return ::CreatePropertySheetPage(lppsp);
}

//+---------------------------------------------------------------------------
//
//  Function:   DialogProc
//
//  Synopsis:   Common DialogProc used by all CHlprPropPage class objects.
//
//  Arguments:  [hwndDlg] - handle of dialog box
//              [uMsg]    - message
//              [wParam]  - first message parameter
//              [lParam]  - second message parameter
//
//  Returns:    response from the CHlprPropPage::DialogProc method
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This procedure is the DialogProc registered for all dialogs
//              created with the CHlprPropPage class.  It uses the parameter
//              passed with the WM_INITDIALOG message to identify the dialog
//              classes' "this" pointer which it then stores in the window
//              structure's GWL_USERDATA field.  All subsequent messages
//              can then be forwarded on to the correct dialog class's
//              DialogProc method by using the pointer stored in the
//              GWL_USERDATA field.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK HlprPropPageDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprPropPage * pdlg;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This message is how we identify the dialog object.

        // get a pointer to the window class object
        pdlg = (CHlprPropPage *) ((PROPSHEETPAGE *)lParam)->lParam;
        // set its USERDATA word to point to the class object
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdlg);
        break;
    default:
        // get a pointer to the window class object
        pdlg = (CHlprPropPage *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        break;
    }
    // and call its message proc method
    if (pdlg != (CHlprPropPage *) 0)
    {
        return(pdlg->DialogProc(hwndDlg, uMsg, wParam, lParam));
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\compspp.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       CompsPP.cpp
//
//  Contents:   Implementation for the "computers" property page of the GPO
//              browser.
//
//  Classes:    CCompsPP
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------


#include "main.h"
#include "CompsPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help ids
//

DWORD aBrowserComputerHelpIds[] =
{
    IDC_RADIO1,                   IDH_BROWSER_LOCALCOMPUTER,
    IDC_RADIO2,                   IDH_BROWSER_REMOTECOMPUTER,
    IDC_EDIT1,                    IDH_BROWSER_REMOTECOMPUTER,
    IDC_BUTTON1,                  IDH_BROWSER_BROWSE,

    0, 0
};


CCompsPP::CCompsPP()
{
    m_szComputer = _T("");
    m_iSelection = 0;
    m_ppActive = NULL;
    m_pGBI;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCompsPP::Initialize
//
//  Synopsis:   Initializes the property page.
//
//  Arguments:  [dwPageType] - used to identify which page this is.  (See
//                              notes.)
//              [pGBI]       - pointer to the browse info structure passed
//                              by caller
//              [ppActive]   - pointer to a common variable that remembers
//                              which object was last given the focus.
//                              Needed because only the page with the focus
//                              is allowed to return data to the caller when
//                              the property sheet is dismissed.
//
//  Returns:    Handle to the newly created property page.
//
//  Modifies:
//
//  Derivation:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This class implements the PAGETYPE_COMPUTERS page.  The
//              other pages are all implemented by CBrowserPP:
//
//                  PAGETYPE_DOMAINS    - GPO's linked to domains
//                  PAGETYPE_SITES      - GPO's linked to sites
//                  PAGETYPE_ALL        - All GPO's in a selected
//
//---------------------------------------------------------------------------
HPROPSHEETPAGE CCompsPP::Initialize(DWORD dwPageType, LPGPOBROWSEINFO pGBI, void ** ppActive)
{
    m_ppActive = ppActive;
    m_dwPageType = dwPageType;
    m_pGBI = pGBI;
    PROPSHEETPAGE psp;
    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_COMPUTERS);
    return CreatePropertySheetPage(&psp);
}

CCompsPP::~CCompsPP()
{
}

#include "objsel.h"

//+--------------------------------------------------------------------------
//
//  Member:     CCompsPP::OnBrowseComputers
//
//  Synopsis:   browses for computers in the entire directory
//
//  Arguments:  [in] hwndDlg : the handle to the window to which the computer
//                             selection dialog is made modal.
//
//  Returns:    nothing
//
//  History:    1/8/1999  RahulTh  created
//
//  Notes:      in case of errors, this function bails out silently
//
//---------------------------------------------------------------------------
void CCompsPP::OnBrowseComputers (HWND hwndDlg)
{
    HRESULT                 hr;
    IDsObjectPicker *       pDsObjectPicker = NULL;
    const ULONG             cbNumScopes = 4;    //make sure this number matches the number of scopes initialized
    DSOP_SCOPE_INIT_INFO    ascopes [cbNumScopes];
    DSOP_INIT_INFO          InitInfo;
    IDataObject *           pdo = NULL;
    STGMEDIUM               stgmedium = {
                                            TYMED_HGLOBAL,
                                            NULL
                                        };
    UINT                    cf = 0;
    FORMATETC               formatetc = {
                                            (CLIPFORMAT)cf,
                                            NULL,
                                            DVASPECT_CONTENT,
                                            -1,
                                            TYMED_HGLOBAL
                                        };
    BOOL                    bAllocatedStgMedium = FALSE;
    PDS_SELECTION_LIST      pDsSelList = NULL;
    PDS_SELECTION           pDsSelection = NULL;
    PCWSTR                  lpAttributes [] = {L"dNSHostName", 0};
    VARIANT   *             pVarAttributes;

    hr = CoInitialize (NULL);

    if (FAILED(hr))
        goto BrowseComps_Cleanup;

    hr = CoCreateInstance (CLSID_DsObjectPicker,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IDsObjectPicker,
                           (void **) & pDsObjectPicker
                           );

    if (FAILED(hr))
        goto BrowseComps_Cleanup;

    //Initialize the scopes.
    ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));

    ascopes[0].cbSize = ascopes[1].cbSize = ascopes[2].cbSize = ascopes[3].cbSize
        = sizeof (DSOP_SCOPE_INIT_INFO);

    ascopes[0].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    ascopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    ascopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;

    ascopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    ascopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;

    ascopes[2].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_WORKGROUP;
    ascopes[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    ascopes[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    ascopes[3].flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE |
                        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    ascopes[3].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    ascopes[3].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //populate the InitInfo structure that will be used to initialize the
    //object picker
    ZeroMemory (&InitInfo, sizeof (DSOP_INIT_INFO));

    InitInfo.cbSize = sizeof (DSOP_INIT_INFO);
    InitInfo.cDsScopeInfos = cbNumScopes;
    InitInfo.aDsScopeInfos = ascopes;
    InitInfo.apwzAttributeNames = lpAttributes;
    InitInfo.cAttributesToFetch = 1;

    hr = pDsObjectPicker->Initialize (&InitInfo);

    if (FAILED(hr))
        goto BrowseComps_Cleanup;

    hr = pDsObjectPicker->InvokeDialog (hwndDlg, &pdo);

    //if the computer selection dialog cannot be invoked or if the user
    //hits cancel, bail out.
    if (FAILED(hr) || S_FALSE == hr)
        goto BrowseComps_Cleanup;

   //if we are here, the user chose, OK, so find out what group was chosen
   cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);

   if (0 == cf)
       goto BrowseComps_Cleanup;

   //set the clipboard format for the FORMATETC structure
   formatetc.cfFormat = (CLIPFORMAT)cf;

   hr = pdo->GetData (&formatetc, &stgmedium);

   if (FAILED (hr))
       goto BrowseComps_Cleanup;

   bAllocatedStgMedium = TRUE;

   pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);

   //
   // Since the dialog was in single-select mode and the user was able
   // to hit OK, there should be exactly one selection.
   //
   ASSERT (1 == pDsSelList->cItems);

   pDsSelection = &(pDsSelList->aDsSelection[0]);


   pVarAttributes = pDsSelection->pvarFetchedAttributes;

   if (pVarAttributes->vt != VT_EMPTY)
   {
       //
       // Put the machine name in the edit control
       //
       SetWindowText (GetDlgItem (hwndDlg, IDC_EDIT1), pVarAttributes->bstrVal);
   }
   else
   {
       //
       // Put the machine name in the edit control
       //
       SetWindowText (GetDlgItem (hwndDlg, IDC_EDIT1), pDsSelection->pwzName);
   }


BrowseComps_Cleanup:
    if (pDsSelList)
        GlobalUnlock (pDsSelList);
    if (bAllocatedStgMedium)
        ReleaseStgMedium (&stgmedium);
    if (pdo)
        pdo->Release();
    if (pDsObjectPicker)
        pDsObjectPicker->Release();

    return;
}


BOOL CCompsPP::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // Initialize dialog data
            SendMessage(GetDlgItem(hwndDlg, IDC_RADIO1), BM_SETCHECK, TRUE, 0);
            EnableWindow (GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);
        }
        break;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
            {
            case PSN_APPLY:
                {
                    if (*m_ppActive == this)
                    {
                        if (SendMessage(GetDlgItem(hwndDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                        {
                            // local computer is selected
                            m_pGBI->gpoType = GPOTypeLocal;
                        }
                        else
                        {
                            // other computer is selected
                            m_pGBI->gpoType = GPOTypeRemote;
                            int cch = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_EDIT1));
                            LPWSTR sz = new WCHAR[cch + 1];

                            if (sz)
                            {
                                GetWindowText(GetDlgItem(hwndDlg, IDC_EDIT1), sz, cch+1);
                                wcsncpy(m_pGBI->lpName, sz, m_pGBI->dwNameSize);
                                delete [] sz;
                            }
                        }
                    }
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);   // accept changes
                }
                break;
            case PSN_SETACTIVE:
                *m_ppActive = this;
                EnableWindow (GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);
                break;
            default:
                break;
            }
        }
        break;
    case WM_COMMAND:
        if (IDC_BUTTON1 == LOWORD(wParam))
        {
           OnBrowseComputers (hwndDlg);
           return TRUE;
        }
        if (IDC_RADIO1 == LOWORD(wParam))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_BUTTON1), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT1), FALSE);
            return TRUE;
        }
        if (IDC_RADIO2 == LOWORD(wParam))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_BUTTON1), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT1), TRUE);
            SetFocus (GetDlgItem(hwndDlg, IDC_EDIT1));
            return TRUE;
        }
        break;
    case WM_ACTIVATE:
        if (WA_INACTIVE != LOWORD(wParam))
        {
            *m_ppActive = this;
        }
        break;
    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aBrowserComputerHelpIds);
        break;
    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aBrowserComputerHelpIds);
        return (TRUE);
    default:
        break;
    }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "main.h"

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPEdit[] = TEXT("GPEDIT(%x.%x) %02d:%02d:%02d:%03d ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPEditDebugLevel")

//
// Log files
//

TCHAR szLogFileName[] = TEXT("%SystemRoot%\\Debug\\UserMode\\gpedit.log");

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level appropriately
    //

#if DBG
    dwDebugLevel = DL_NORMAL | DL_LOGFILE | DL_DEBUGGER;
#else
    dwDebugLevel = DL_NORMAL | DL_LOGFILE;
#endif


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[40];
    TCHAR szDebugBuffer[4096];
    va_list marker;
    DWORD dwErrCode;
    SYSTEMTIME systime;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {

        //
        // Build the error text prefix and message
        //

        GetLocalTime (&systime);
        wsprintf (szDebugTitle, c_szGPEdit,
                  GetCurrentProcessId(), GetCurrentThreadId(),
                  systime.wHour, systime.wMinute, systime.wSecond,
                  systime.wMilliseconds);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        va_end(marker);


        //
        // Print to the debugger if appropriate
        //

        if (dwDebugLevel & DL_DEBUGGER) {
            OutputDebugString(szDebugTitle);
            OutputDebugString(szDebugBuffer);
            OutputDebugString(c_szCRLF);
        }


        //
        // Add to the log file if appropriate
        //

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;
            TCHAR szExpLogFileName[MAX_PATH+1];

            ExpandEnvironmentStrings (szLogFileName, szExpLogFileName, ARRAYSIZE(szExpLogFileName));

            hFile = CreateFile(szExpLogFileName,
                               FILE_WRITE_DATA | FILE_APPEND_DATA,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }
        }
    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\dataobj.cpp ===
#include "main.h"
#include <initguid.h>
#include "dataobj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfPreloads       = RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
unsigned int CDataObject::m_cfNodeID         = RegisterClipboardFormat(CCF_NODEID);
unsigned int CDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CDataObject::CDataObject(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CDataObject::~CDataObject()
{
    m_pcd->Release();
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGPEInformation))
    {
        *ppv = (LPGPEINFORMATION)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IGroupPolicyObject))
    {
        if (m_pcd->m_pGPO)
        {
            return (m_pcd->m_pGPO->QueryInterface (riid, ppv));
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    else if (IsEqualIID(riid, IID_IGPEDataObject))
    {
        *ppv = (LPGPEDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfPreloads)
    {
        hr = CreatePreloadsData(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;
            TCHAR szDesc[300];

            IStream *lpStream = lpMedium->pstm;

            if(lpStream)
            {
                LoadString (g_hInstance, g_NameSpace[m_cookie].iStringDescID, szDesc, ARRAYSIZE(szDesc));
                hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if (m_cookie == 0)
            {
                IStream *lpStream = lpMedium->pstm;

                if(lpStream)
                {
                    hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeID)
    {
        hr = CreateNodeIDData(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IGPEInformation)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDataObject::GetName (LPOLESTR pszName, int cchMaxLength)
{
    return m_pcd->m_pGPO->GetName(pszName, cchMaxLength);
}

STDMETHODIMP CDataObject::GetDisplayName (LPOLESTR pszName, int cchMaxLength)
{
    return m_pcd->m_pGPO->GetDisplayName(pszName, cchMaxLength);
}

STDMETHODIMP CDataObject::GetRegistryKey (DWORD dwSection, HKEY *hKey)
{
    return m_pcd->m_pGPO->GetRegistryKey(dwSection, hKey);
}

STDMETHODIMP CDataObject::GetDSPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    return m_pcd->m_pGPO->GetDSPath(dwSection, pszPath, cchMaxPath);
}

STDMETHODIMP CDataObject::GetFileSysPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    return m_pcd->m_pGPO->GetFileSysPath(dwSection, pszPath, cchMaxPath);
}

STDMETHODIMP CDataObject::GetOptions (DWORD *dwOptions)
{
    return m_pcd->GetOptions(dwOptions);
}

STDMETHODIMP CDataObject::GetType (GROUP_POLICY_OBJECT_TYPE *gpoType)
{
    return m_pcd->m_pGPO->GetType(gpoType);
}

STDMETHODIMP CDataObject::GetHint (GROUP_POLICY_HINT_TYPE *gpHint)
{
    if (!gpHint)
    {
        return E_INVALIDARG;
    }

    *gpHint = m_pcd->m_gpHint;

    return S_OK;
}

STDMETHODIMP CDataObject::PolicyChanged (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin)
{
    return m_pcd->m_pGPO->Save(bMachine, bAdd, pGuidExtension, pGuidSnapin);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[300];

    //
    // This is the display named used in the scope pane and snap-in manager
    //

    szDisplayName[0] = TEXT('\0');

    if (m_pcd->m_pGPO && m_pcd->m_pDisplayName)
    {
        lstrcpy (szDisplayName, m_pcd->m_pDisplayName);
    }
    else
    {
        LoadStringW (g_hInstance, IDS_SNAPIN_NAME, szDisplayName, ARRAYSIZE(szDisplayName));
    }

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPESnapIn, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreatePreloadsData(LPSTGMEDIUM lpMedium)
{
    BOOL bPreload = TRUE;

    return Create((LPVOID)&bPreload, sizeof(bPreload), lpMedium);
}

HRESULT CDataObject::CreateNodeIDData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];
    SNodeID * psNode;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_NameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    lpMedium->hGlobal = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, (lstrlen(szNodeType) * sizeof(TCHAR)) + sizeof(SNodeID));

    if (!lpMedium->hGlobal)
    {
        return (STG_E_MEDIUMFULL);
    }

    psNode = (SNodeID *) GlobalLock (lpMedium->hGlobal);

    psNode->cBytes = lstrlen(szNodeType) * sizeof(TCHAR);
    CopyMemory (psNode->id, szNodeType, psNode->cBytes);

    GlobalUnlock (lpMedium->hGlobal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

extern DWORD dwDebugLevel;


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DmAssert(x) if (!(x)) \
                        _DebugMsg(DM_ASSERT,TEXT("Gpedit.dll assertion ") TEXT(#x) TEXT(" failed\n"));

#define DebugMsg(x) if (dwDebugLevel != DL_NONE) \
                        _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\gpobj.cpp ===
//*************************************************************
//  File name: GPOBJ.CPP
//
//  Description:  Group Policy Object class
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************
#include "main.h"

#include "browser.h"
//
// Help ids
//

DWORD aPropertiesHelpIds[] =
{
    IDC_TITLE,                    IDH_PROP_TITLE,
    IDC_DISABLE_COMPUTER,         IDH_PROP_DISABLE_COMPUTER,
    IDC_DISABLE_USER,             IDH_PROP_DISABLE_USER,

    0, 0
};

DWORD aLinkHelpIds[] =
{
    IDC_CBDOMAIN,                 IDH_LINK_DOMAIN,
    IDC_ACTION,                   IDH_LINK_BUTTON,
    IDC_RESULTLIST,               IDH_LINK_RESULT,

    0, 0
};

DWORD aWQLFilterHelpIds[] =
{
    IDC_NONE,                     IDH_WQL_FILTER_NONE,
    IDC_THIS_FILTER,              IDH_WQL_FILTER_THIS_FILTER,
    IDC_FILTER_NAME,              IDH_WQL_FILTER_NAME,
    IDC_FILTER_BROWSE,            IDH_WQL_FILTER_BROWSE,

    0, 0
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyObject implementation                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyObject::CGroupPolicyObject()
{
    InterlockedIncrement(&g_cRefThisDll);

    m_cRef                    = 1;
    m_bInitialized            = FALSE;
    m_pADs                    = NULL;
    m_gpoType                 = GPOTypeLocal;
    m_dwFlags                 = 0;
    m_pName                   = NULL;
    m_pDisplayName            = NULL;
    m_pMachineName            = NULL;
    m_pUser                   = NULL;
    m_pMachine                = NULL;

    m_hinstDSSec              = NULL;
    m_pfnDSCreateSecurityPage = NULL;

    m_pTempFilterString       = NULL;

    m_pDSPath                 = NULL;
    m_pFileSysPath            = NULL;
}

CGroupPolicyObject::~CGroupPolicyObject()
{
    CleanUp();

    if (m_hinstDSSec)
    {
        FreeLibrary (m_hinstDSSec);
    }

    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyObject object implementation (IUnknown)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CGroupPolicyObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGroupPolicyObject) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPGROUPPOLICYOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CGroupPolicyObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CGroupPolicyObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyObject object implementation (IGroupPolicyObject)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//*************************************************************
//
//  CGroupPolicyObject::New()
//
//  Purpose:    Creates a new GPO in the DS
//
//  Parameters: pszDomainName     -   Domain to create GPO in
//              pszDisplayName    -   GPO friendly name (optional)
//              dwFlags           -   Open / creation flags
//
//  Note:       The domain passed in should be in this format:
//              LDAP://DC=domain,DC=company,DC=COM
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::New (LPOLESTR pszDomainName, LPOLESTR pszDisplayName,
                                      DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    IADsPathname * pADsPathname = NULL;
    BSTR bstrContainer = NULL;
    BSTR bstrGPC = NULL;
    LPTSTR lpResult = NULL, lpDCName = NULL;
    LPTSTR lpEnd = NULL, lpTemp = NULL, lpGPTPath = NULL;
    LPTSTR lpForest = NULL;
    DWORD dwResult;
    GUID guid;
    TCHAR szGPOName[50];
    TCHAR szTemp[100];
    TCHAR szGPOPath[2*MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    IADs *pADs = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_INFORMATION si = (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION);


    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Called on an initialized object.")));
        return STG_E_INUSE;
    }


    //
    // Check parameters
    //

    if (!pszDomainName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Null domain name")));
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, TEXT("LDAP://"),
                       7, pszDomainName, 7) != CSTR_EQUAL)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Domain name does not start with LDAP://")));
        hr = E_INVALIDARG;
        goto Exit;
    }


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Entering with:")));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Domain Name:  %s"), pszDomainName));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Flags:        0x%x"), dwFlags));

    //
    // Convert the ADSI domain name into a DNS style name
    //

    hr = ConvertToDotStyle (pszDomainName, &lpResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to convert domain name with 0x%x"), hr));
        goto Exit;
    }

    //
    // If we are working on the enterprise then we need to get the name of the
    // forest.
    //
#if FGPO_SUPPORT
    if (GPO_OPEN_FOREST == (dwFlags & GPO_OPEN_FOREST))
    {
        DWORD dwResult = QueryForForestName(NULL,
                                            lpResult,
                                            DS_PDC_REQUIRED | DS_RETURN_DNS_NAME,
                                            &lpTemp);
        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: QueryForestName failed for domain name %s with %d"),
                      lpResult, dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        int cch = 0;
        int n=0;
        // count the dots in lpTemp;
        while (lpTemp[n])
        {
            if (L'.' == lpTemp[n])
            {
                cch++;
            }
            n++;
        }
        cch *= 3; // multiply the number of dots by 3;
        cch += 11; // add 10 + 1 (for the null)
        cch += n; // add the string size;
        lpForest = (LPTSTR) LocalAlloc(LPTR, sizeof(WCHAR) * cch);
        if (!lpForest)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for forest name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        NameToPath(lpForest, lpTemp, cch);

        // substitute the forest's dot path for the domain's dot path
        LocalFree(lpResult);
        lpResult = lpTemp;
        lpTemp = NULL;

        //
        // Check to see if we have a domain path to a specific DC.
        // If we don't then the string will start "LDAP://DC=".
        // The equal sign in particular can only be there if we don't have a specific
        // DC so we'll just check for the equal sign.
        //

        if (*(pszDomainName + 9) != TEXT('='))
        {
            // we have a path to a specific DC
            // need to extract the server path and prepend it to the forest name
            lpDCName = ExtractServerName(pszDomainName);

            if (!lpDCName)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to extract server name for Forest path")));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            lpTemp = MakeFullPath(lpForest, lpDCName);

            if (!lpTemp)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to combine server name with Forest path")));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            // clean up the variables we just borrowed so they can be used later
            LocalFree(lpDCName);
            lpDCName = NULL;
            LocalFree(lpForest);
            lpForest = lpTemp;
            lpTemp = NULL;
        }

        // Substitute the path to the forest for the path to the domain
        pszDomainName = lpForest;
    }
#endif
    //
    // Check to see if we have a domain path to a specific DC.
    // If we don't then the string will start "LDAP://DC=".
    // The equal sign in particular can only be there if we don't have a specific
    // DC so we'll just check for the equal sign.
    //

    if (*(pszDomainName + 9) == TEXT('='))
    {

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomainName, &lpTemp);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the GPO DC for this domain
        //

        lpDCName = GetDCName (lpTemp, NULL, NULL, FALSE, 0);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to get DC name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Build a fully qualified domain name to a specific DC
        //

        lpTemp = MakeFullPath (pszDomainName, lpDCName);

        if (!lpTemp)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }
    else
    {

        lpDCName = ExtractServerName (pszDomainName);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to extract server name from ADSI path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        lpTemp = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pszDomainName) + 1) * sizeof(TCHAR));
        if (!lpTemp)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for true domain name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        lstrcpy (lpTemp, pszDomainName);
    }


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create adspathname instance with 0x%x"), hr));
        LocalFree (lpTemp);
        goto Exit;
    }


    //
    // Add the domain name
    //

    hr = pADsPathname->Set (lpTemp, ADS_SETTYPE_FULL);
    LocalFree (lpTemp);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }
#if FGPO_SUPPORT
    if (GPO_OPEN_FOREST != (dwFlags & GPO_OPEN_FOREST))
    {
#endif
        //
        // Add the system folder to the path unless we're on the enterprise
        //

        hr = pADsPathname->AddLeafElement (TEXT("CN=System"));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add system folder with 0x%x"), hr));
            goto Exit;
        }
#if FGPO_SUPPORT
    }
    else
    {
        //
        // We're on the enterprise so point at the Configuration folder instead
        //

        hr = pADsPathname->AddLeafElement (TEXT("CN=Configuration"));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add system folder with 0x%x"), hr));
            goto Exit;
        }
    }
#endif

    //
    // Retreive the container path - this is the path to the parent of the policies folder
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create the Policies container
    //

    hr = CreateContainer (bstrContainer, TEXT("Policies"), FALSE);
    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the gpo container with 0x%x"), hr));
            goto Exit;
        }
    }

    SysFreeString (bstrContainer);
    bstrContainer = NULL;


    //
    // Add the policies container to the path
    //

    hr = pADsPathname->AddLeafElement (TEXT("CN=Policies"));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add policies folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the container path - this is the path to the policies folder
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create a new GPO name (guid)
    //

    if (FAILED(CoCreateGuid(&guid)))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create GUID.")));
        goto Exit;
    }


    if (!StringFromGUID2 (guid, szGPOName, ARRAYSIZE(szGPOName)))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to convert GUID.")));
        goto Exit;
    }


    //
    // Create a container for this GPO
    //

    hr = CreateContainer (bstrContainer, szGPOName, TRUE);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the gpo container with 0x%x"), hr));
        goto Exit;
    }

    SysFreeString (bstrContainer);
    bstrContainer = NULL;


    //
    // Add the GPO name to the path
    //

    lstrcpy (szTemp, TEXT("CN="));
    lstrcat (szTemp, szGPOName);
    hr = pADsPathname->AddLeafElement (szTemp);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add machine folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the GPC path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrGPC);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: GPO container path is:  %s"), bstrGPC));


    //
    // Now create the machine and user containers
    //

    hr = CreateContainer (bstrGPC, MACHINE_SECTION, FALSE);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the machine container with 0x%x"), hr));
        goto Exit;
    }


    hr = CreateContainer (bstrGPC, USER_SECTION, FALSE);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the user container with 0x%x"), hr));
        goto Exit;
    }


    //
    // Prepare the file system storage on the sysvol
    //
    // Build the name
    //

    wsprintf (szGPOPath, TEXT("\\\\%s\\SysVol\\%s\\Policies\\%s"), lpDCName, lpResult, szGPOName);

    lpGPTPath = (LPTSTR) LocalAlloc(LPTR, (lstrlen(szGPOPath) + 1) * sizeof(TCHAR));

    if (!lpGPTPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for GPT path with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (lpGPTPath, szGPOPath);


    if (!CreateNestedDirectory (szGPOPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create file system directory %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: File system folder is:  %s"), szGPOPath));


    //
    // Set the security of the sysvol to match the security of the DS
    //
    // First, enable some security privilages so we can set the owner / sacl information
    //

    if (!EnableSecurityPrivs())
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to enable the security privilages with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Bind to the GPO
    //

    hr = OpenDSObject(bstrGPC, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to get gpo IADs interface with 0x%x"), hr));
        SetThreadToken(NULL, NULL);
        goto Exit;
    }


    //
    // Get the security descriptor from the DS
    //

    hr = GetSecurityDescriptor (pADs, si, &pSD);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to query the security descriptor with 0x%x"), hr));
        SetThreadToken(NULL, NULL);
        goto Exit;
    }


    //
    // Set the security information on the sysvol
    //

    dwResult = SetSysvolSecurity (szGPOPath, si, pSD);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set sysvol security for %s with %d"),
                 szGPOPath, dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        SetThreadToken(NULL, NULL);
        goto Exit;
    }


    //
    // Reset the security privilages
    //

    SetThreadToken(NULL, NULL);


    lpEnd = CheckSlash(szGPOPath);


    //
    // Set the initial version number
    //

    lstrcpy (lpEnd, TEXT("GPT.INI"));

    if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"), TEXT("0"),
                                   szGPOPath))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set initial version number for %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Create the user and machine directories
    //

    lstrcpy (lpEnd, MACHINE_SECTION);

    if (!CreateNestedDirectory (szGPOPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create machine file system directory %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (lpEnd, USER_SECTION);

    if (!CreateNestedDirectory (szGPOPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create user file system directory %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Set the GPO specific information
    //
    // Note that we use the nameless form of the sysvol path
    //

    wsprintf (szGPOPath, TEXT("\\\\%s\\SysVol\\%s\\Policies\\%s"), lpResult, lpResult, szGPOName);

    hr = SetGPOInfo (bstrGPC, pszDisplayName, szGPOPath);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set GPO information with 0x%x"), hr));
        goto Exit;
    }


    //
    // Call OpenDSGPO to do the loading work
    //

    hr = OpenDSGPO(bstrGPC, dwFlags);


Exit:

    if (lpForest)
    {
        LocalFree (lpForest);
    }

    if (lpDCName)
    {
        LocalFree (lpDCName);
    }

    if (lpResult)
    {
        LocalFree (lpResult);
    }

    if (bstrContainer)
    {
        SysFreeString (bstrContainer);
    }

    if (bstrGPC)
    {
        if (FAILED(hr))
        {
            if (FAILED(DSDelnode(bstrGPC)))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to delete GPC with 0x%x"), hr));
            }
        }

        SysFreeString (bstrGPC);
    }

    if (lpGPTPath)
    {
        if (FAILED(hr))
        {
            if (!Delnode(lpGPTPath))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to delete GPT with %d"),
                         GetLastError()));
            }
        }
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (pADs)
    {
        pADs->Release();
    }

    if (pSD)
    {
        LocalFree (pSD);
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Leaving with a status of  0x%x"), hr));

    return hr;
}


//*************************************************************
//
//  OpenDSGPO()
//
//  Purpose:    Opens a DS Group Policy Object
//
//  Parameters: pszPath - Path to the GPO to open
//              dwFlags - Open / creation flags
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::OpenDSGPO (LPOLESTR pszPath, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    VARIANT var;
    IADsPathname * pADsPathname = NULL;
    IADsObjectOptions *pOptions = NULL;
    BSTR bstrProperty;
    BSTR bstrGPOName = NULL;
    BSTR bstrContainer;
    BSTR bstrDCName;
    TCHAR szPath[2*MAX_PATH];
    TCHAR szKeyName[100];
    LPTSTR lpTemp;
    LPTSTR lpEnd;
    LPTSTR pszFullPath = NULL;
    DWORD dwResult;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    DFS_INFO_101 Info101;
    LPTSTR lpDCName = NULL;
    LPOLESTR pszDomain;
    UINT uiSize;
    TCHAR szFormat[10];
    LPTSTR lpNames[2];



    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Called on an uninitialized object.")));
        return STG_E_INUSE;
    }


    //
    // Check parameters
    //

    if (!pszPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: NULL GPO name")));
        return E_INVALIDARG;
    }


    if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, TEXT("LDAP://"),
                       7, pszPath, 7) != CSTR_EQUAL)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: %s does not start with LDAP://"), pszPath));
        hr = E_INVALIDARG;
        goto Exit;
    }


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Entering with:")));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: GPO Path:  %s"), pszPath));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Flags:  %d"), dwFlags));


    //
    // Save the flags
    //

    m_dwFlags = dwFlags;


    //
    // Retreive the server name if defined
    //

    lpDCName = ExtractServerName (pszPath);

    if (lpDCName)
    {
        pszFullPath = pszPath;
    }
    else
    {
        //
        // Get the domain name
        //

        pszDomain = GetDomainFromLDAPPath(pszPath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpTemp);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the GPO DC for this domain
        //

        lpDCName = GetDCName (lpTemp, NULL, NULL, FALSE, 0);

        LocalFree (lpTemp);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get DC name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        //  Make the fully qualified path
        //

        pszFullPath = MakeFullPath (pszPath, lpDCName);

        if (!pszFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to make full GPO path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Using server %s"), lpDCName));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Using fully qualifed pathname of %s"), pszFullPath));


    //
    // Save the DC name
    //

    m_pMachineName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpDCName) + 1) * sizeof(TCHAR));

    if (!m_pMachineName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for machine name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pMachineName, lpDCName);


    //
    // Save the DS path
    //

    m_pDSPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pszFullPath) + 2) * sizeof(TCHAR));

    if (!m_pDSPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for ds path")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pDSPath, pszFullPath);


    //
    // Bind to the DS object.  Note we hold on to this bind until
    // the object goes away.  This way other ADSI calls will go to
    // the same DC.
    //

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Binding to the object")));

    hr = OpenDSObject(m_pDSPath, IID_IADs, (void **)&m_pADs);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: OpenDSObject failed with 0x%x"), hr));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Bound successfully.")));

    //
    // Check if the user has write permission to the GPO
    //

    if (!(m_dwFlags & GPO_OPEN_READ_ONLY))
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Checking for write access")));

        hr = CheckDSWriteAccess ((LPUNKNOWN)m_pADs, TEXT("versionNumber"));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: CheckDSWriteAccess failed with 0x%x"), hr));
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Write access granted")));
    }

    //
    // Query for the file system path
    //

    bstrProperty = SysAllocString (GPT_PATH_PROPERTY);

    if (!bstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    VariantInit(&var);

    hr = m_pADs->Get(bstrProperty, &var);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to query GPT path with 0x%x"), hr));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        goto Exit;
    }


    m_pFileSysPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(var.bstrVal) + 2) * sizeof(TCHAR));

    if (!m_pFileSysPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for gpt path")));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pFileSysPath, var.bstrVal);

    SysFreeString (bstrProperty);
    VariantClear (&var);


    //
    // Query for the display name
    //

    bstrProperty = SysAllocString (GPO_NAME_PROPERTY);

    if (!bstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    VariantInit(&var);

    hr = m_pADs->Get(bstrProperty, &var);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to query for display name with 0x%x"), hr));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        goto Exit;
    }

    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(var.bstrVal) + 1) * sizeof(TCHAR));

    if (!m_pDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for display name")));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pDisplayName, var.bstrVal);

    SysFreeString (bstrProperty);
    VariantClear (&var);


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the domain name
    //

    hr = pADsPathname->Set (m_pDSPath, ADS_SETTYPE_FULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retrieve the GPO name
    //

    hr = pADsPathname->GetElement (0, &bstrGPOName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to retreive GPO name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Make a copy of the GPO name
    //

    m_pName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(bstrGPOName) + 1 - 3) * sizeof(TCHAR));

    if (!m_pName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for gpo name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pName, (bstrGPOName + 3));


    //
    // Set the ADSI preferred DC.
    //

    hr = m_pADs->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);

    if (SUCCEEDED(hr))
    {
        //
        // Get the domain name
        //

        pszDomain = GetDomainFromLDAPPath(pszPath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpTemp);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Build a variant containing the domain and dc names
        //

        VariantInit(&var);

        lpNames[0] = lpTemp;
        lpNames[1] = lpDCName;

        hr = ADsBuildVarArrayStr (lpNames, 2, &var);

        LocalFree (lpTemp);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Set the DC name
        //

        hr = pOptions->SetOption(ADS_PRIVATE_OPTION_SPECIFIC_SERVER, var);

        VariantClear (&var);

        if (FAILED(hr))
        {

            //
            // TODO:  Remove this block after lab03 RI's -- or -- remove post whistler beta2
            //

            if (hr == E_ADS_BAD_PARAMETER)
            {
                //
                // Set the DC name the old way
                //

                VariantInit(&var);
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString (lpDCName);

                if (var.bstrVal)
                {
                    hr = pOptions->SetOption(ADS_PRIVATE_OPTION_SPECIFIC_SERVER, var);
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate bstr DCName string")));
                }

                VariantClear (&var);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to set private DC name with 0x%x"), hr));
            }
        }

        pOptions->Release();
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get DS object options interface with 0x%x"), hr));
    }


    //
    // Ask the MUP to read/write to this DC's sysvol.
    // We first have to get attributes for the nameless path. This causes the MUP's
    // cache to be initialize if it isn't already.  Then we can tell
    // the MUP which server to use.
    //

    if (!GetFileAttributesEx (m_pFileSysPath, GetFileExInfoStandard, &fad))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: GetFileAttributes for %s FAILED with %d."), m_pFileSysPath, GetLastError()));
    }


    //
    // Now we need to take the full path and trim it down to just
    // domain name \ share
    //

    lstrcpy (szPath, m_pFileSysPath);

    if ((szPath[0] != TEXT('\\')) || (szPath[1] != TEXT('\\')))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Sysvol path doesn't start with \\\\")));
        goto Exit;
    }


    lpTemp = szPath + 2;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
        lpTemp++;

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to find slash between domain name and share")));
        goto Exit;
    }

    lpTemp++;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
        lpTemp++;

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to find slash between share and directory")));
        goto Exit;
    }

    *lpTemp = TEXT('\0');

    Info101.State = DFS_STORAGE_STATE_ACTIVE;
    dwResult = NetDfsSetClientInfo (szPath, lpDCName,
                                    L"SysVol", 101, (LPBYTE)&Info101);

    if (dwResult != NERR_Success)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to set %s as the active sysvol with %d"),
                 lpDCName, dwResult));
    }


    //
    // Now load the registry information
    //

    if (m_dwFlags & GPO_OPEN_LOAD_REGISTRY)
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Loading registry files")));

        lstrcpy (szPath, m_pFileSysPath);
        lpEnd = CheckSlash (szPath);

        //
        // Initialize the user registry (HKCU)
        //

        m_pUser = new CRegistryHive();

        if (!m_pUser)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to create User registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        lstrcpy (lpEnd, USER_SECTION);
        lstrcat (lpEnd, TEXT("\\Registry.pol"));

        lstrcpy (szKeyName, m_pName);
        lstrcat (szKeyName, USER_SECTION);

        hr = m_pUser->Initialize (szPath, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: User registry failed to initialize")));
            goto Exit;
        }


        //
        // Initialize the machine registry (HKLM)
        //

        m_pMachine = new CRegistryHive();

        if (!m_pMachine)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to create machine registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        lstrcpy (lpEnd, MACHINE_SECTION);
        lstrcat (lpEnd, TEXT("\\Registry.pol"));

        lstrcpy (szKeyName, m_pName);
        lstrcat (szKeyName, MACHINE_SECTION);

        hr = m_pMachine->Initialize (szPath, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeGPT: machine registry failed to initialize")));
            goto Exit;
        }
    }


    //
    // Success
    //

    hr = S_OK;

Exit:

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (bstrGPOName)
    {
        SysFreeString (bstrGPOName);
    }

    if (lpDCName)
    {
        LocalFree (lpDCName);
    }

    if (pszFullPath != pszPath)
    {
        LocalFree (pszFullPath);
    }

    if (SUCCEEDED(hr))
    {
        m_gpoType      = GPOTypeDS;
        m_bInitialized = TRUE;
    } else {
        CleanUp();
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Leaving with a status of  0x%x"), hr));

    return hr;
}


//*************************************************************
//
//  OpenLocalMachineGPO()
//
//  Purpose:    Opens this machines GPO
//
//  Parameters: dwFlags - load flags
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::OpenLocalMachineGPO (DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szKeyName[100];
    LPTSTR lpEnd;
    TCHAR szPath[MAX_PATH];
    TCHAR szFuncVersion[10];
    UINT uRet = 0;


    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Called on an uninitialized object.")));
        return STG_E_INUSE;
    }


    //
    // Save the flags
    //

    m_dwFlags = dwFlags;


    //
    // Get the path to the local GPO
    //

    ExpandEnvironmentStrings (LOCAL_GPO_DIRECTORY, szBuffer, ARRAYSIZE(szBuffer));


    //
    // Save the file system path
    //

    m_pFileSysPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) + 1) * sizeof(TCHAR));

    if (!m_pFileSysPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to allocate memory for gpt path")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pFileSysPath, szBuffer);


    //
    // Create the directory
    //

    uRet = CreateSecureDirectory (szBuffer);
    if (!uRet)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create file system directory %s with %d"),
                 szBuffer, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN);


    //
    // Check if the user has write access to the directory
    //

    if (!(m_dwFlags & GPO_OPEN_READ_ONLY))
    {
        hr = CheckFSWriteAccess (szBuffer);

        if (FAILED(hr))
        {
            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: User does not have write access to this GPO (access denied).")));
                goto Exit;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: CheckFSWriteAccess failed with 0x%x"), hr));
            }
        }
    }

    if ( uRet != ERROR_ALREADY_EXISTS )
    {
        lstrcpy( szPath, m_pFileSysPath );
        lpEnd = CheckSlash(szPath);
        lstrcpy( lpEnd, TEXT("gpt.ini") );

        wsprintf( szFuncVersion, TEXT("%d"), GPO_FUNCTIONALITY_VERSION );
        if (!WritePrivateProfileString (TEXT("General"), TEXT("gPCFunctionalityVersion"),
                                        szFuncVersion, szPath))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to write functionality version with 0x%x"), hr));
            goto Exit;
        }
    }

    lpEnd = CheckSlash(szBuffer);


    //
    // Create the user and machine directories
    //

    lstrcpy (lpEnd, MACHINE_SECTION);
    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create machine subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (lpEnd, USER_SECTION);
    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create user subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Load the GPO name
    //

    LoadString (g_hInstance, IDS_LOCAL_NAME, szBuffer, ARRAYSIZE(szBuffer));

    m_pName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) + 2) * sizeof(TCHAR));

    if (!m_pName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pName, szBuffer);


    //
    // Load the display name
    //

    LoadString (g_hInstance, IDS_LOCAL_DISPLAY_NAME, szBuffer, ARRAYSIZE(szBuffer));

    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) + 2) * sizeof(TCHAR));

    if (!m_pDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to allocate memory for display name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pDisplayName, szBuffer);


    //
    // Now load the registry information
    //

    if (m_dwFlags & GPO_OPEN_LOAD_REGISTRY)
    {
        lstrcpy (szBuffer, m_pFileSysPath);
        lpEnd = CheckSlash (szBuffer);


        //
        // Initialize the user registry (HKCU)
        //

        m_pUser = new CRegistryHive();

        if (!m_pUser)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create User registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        lstrcpy (lpEnd, USER_SECTION);
        lstrcat (lpEnd, TEXT("\\Registry.pol"));

        lstrcpy (szKeyName, m_pName);
        lstrcat (szKeyName, USER_SECTION);

        hr = m_pUser->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: User registry failed to initialize")));
            goto Exit;
        }


        //
        // Initialize the machine registry (HKLM)
        //

        m_pMachine = new CRegistryHive();

        if (!m_pMachine)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create machine registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        lstrcpy (lpEnd, MACHINE_SECTION);
        lstrcat (lpEnd, TEXT("\\Registry.pol"));

        lstrcpy (szKeyName, m_pName);
        lstrcat (szKeyName, MACHINE_SECTION);

        hr = m_pMachine->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeGPT: machine registry failed to initialize")));
            goto Exit;
        }
    }

    //
    // Success
    //

    hr = S_OK;

Exit:

    if (SUCCEEDED(hr))
    {
        m_gpoType      = GPOTypeLocal;
        m_bInitialized = TRUE;
    } else {
        CleanUp();
    }

    return hr;
}


//*************************************************************
//
//  OpenRemoteMachineGPO()
//
//  Purpose:    Opens a remote machines GPO
//              dwFlags - load flags
//
//  Parameters: pszComputerName - name of computer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::OpenRemoteMachineGPO (LPOLESTR pszComputerName,
                                                       DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szComputerName[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szKeyName[100];
    LPTSTR lpEnd;
    TCHAR szPath[MAX_PATH];
    TCHAR szFuncVersion[10];
    UINT uRet = 0;


    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Called on an uninitialized object.")));
        return STG_E_INUSE;
    }

    //
    // Check parameters
    //

    if (!pszComputerName)
        return E_INVALIDARG;


    //
    // Save the flags
    //

    m_dwFlags = dwFlags;


    //
    // Parse the computer name
    //

    if ((pszComputerName[0] == TEXT('\\')) && (pszComputerName[1] == TEXT('\\')))
    {
        lstrcpy(szComputerName, pszComputerName+2);
    }
    else
    {
        lstrcpy(szComputerName, pszComputerName);
    }


    //
    // Save the machine name
    //

    m_pMachineName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szComputerName) + 1) * sizeof(TCHAR));

    if (!m_pMachineName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for machine name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pMachineName, szComputerName);


    //
    // Get the path to the local GPO
    //

    wsprintf (szBuffer, REMOTE_GPO_DIRECTORY, szComputerName);


    //
    // Save the file system path
    //

    m_pFileSysPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) + 1) * sizeof(TCHAR));

    if (!m_pFileSysPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for gpt path")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pFileSysPath, szBuffer);


    //
    // Create the directory
    //

    uRet = CreateSecureDirectory (szBuffer);
    if (!uRet)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create file system directory %s with %d"),
                 szBuffer, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN);


    //
    // Check if the user has write access to the directory
    //

    if (!(m_dwFlags & GPO_OPEN_READ_ONLY))
    {
        hr = CheckFSWriteAccess (szBuffer);

        if (FAILED(hr))
        {
            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: User does not have write access to this GPO (access denied).")));
                goto Exit;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: CheckFSWriteAccess failed with 0x%x"), hr));
            }
        }
    }

    if ( uRet != ERROR_ALREADY_EXISTS )
    {
        lstrcpy( szPath, m_pFileSysPath );
        lpEnd = CheckSlash(szPath);
        lstrcpy( lpEnd, TEXT("gpt.ini") );

        wsprintf( szFuncVersion, TEXT("%d"), GPO_FUNCTIONALITY_VERSION );
        if (!WritePrivateProfileString (TEXT("General"), TEXT("gPCFunctionalityVersion"),
                                        szFuncVersion, szPath))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to write functionality version with 0x%x"), hr));
            goto Exit;
        }
    }

    lpEnd = CheckSlash(szBuffer);


    //
    // Create the user and machine directories
    //

    lstrcpy (lpEnd, MACHINE_SECTION);
    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create machine subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    lstrcpy (lpEnd, USER_SECTION);
    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create user subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }



    //
    // Load the GPO name
    //

    m_pName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szComputerName) + 2) * sizeof(TCHAR));

    if (!m_pName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pName, szComputerName);


    //
    // Load the display name
    //

    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szComputerName) + 2) * sizeof(TCHAR));

    if (!m_pDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for display name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpy (m_pDisplayName, szComputerName);


    //
    // Now load the registry information
    //

    if (m_dwFlags & GPO_OPEN_LOAD_REGISTRY)
    {
        lstrcpy (szBuffer, m_pFileSysPath);
        lpEnd = CheckSlash (szBuffer);


        //
        // Initialize the user registry (HKCU)
        //

        m_pUser = new CRegistryHive();

        if (!m_pUser)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create User registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        lstrcpy (lpEnd, USER_SECTION);
        lstrcat (lpEnd, TEXT("\\Registry.pol"));

        lstrcpy (szKeyName, m_pName);
        lstrcat (szKeyName, USER_SECTION);

        hr = m_pUser->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: User registry failed to initialize")));
            goto Exit;
        }


        //
        // Initialize the machine registry (HKLM)
        //

        m_pMachine = new CRegistryHive();

        if (!m_pMachine)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create machine registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        lstrcpy (lpEnd, MACHINE_SECTION);
        lstrcat (lpEnd, TEXT("\\Registry.pol"));

        lstrcpy (szKeyName, m_pName);
        lstrcat (szKeyName, MACHINE_SECTION);

        hr = m_pMachine->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeGPT: machine registry failed to initialize")));
            goto Exit;
        }
    }

    //
    // Success
    //

    hr = S_OK;

Exit:

    if (SUCCEEDED(hr))
    {
        m_gpoType      = GPOTypeRemote;
        m_bInitialized = TRUE;
    } else {
        CleanUp();
    }

    return hr;

}


//*************************************************************
//
//  Save()
//
//  Purpose:    Saves the registry information and bumps the
//              version number
//
//  Parameters: none
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::Save (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin)
{
    HRESULT hr;
    TCHAR szPath[2*MAX_PATH];
    TCHAR szVersion[25];
    ULONG ulVersion, ulOriginal;
    USHORT uMachine, uUser;
    BSTR bstrName;
    VARIANT var;
    GUID RegistryGuid = REGISTRY_EXTENSION_GUID;
    BOOL bEmpty;


    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::Save: Entering with bMachine = %d and bAdd = %d"),
              bMachine, bAdd));

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }

    if ( pGuidExtension == 0 || pGuidSnapin == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: One of the guids is null")));
        return ERROR_INVALID_PARAMETER;
    }

    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Called on a READ ONLY GPO")));
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    //
    // Save registry settings
    //

    if (!CompareGuid (pGuidExtension, &RegistryGuid))
    {
        if (bMachine)
        {
            if (m_pMachine)
            {
                hr = m_pMachine->Save();

                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to save the machine registry with 0x%x"), hr));
                    return hr;
                }

                hr = m_pMachine->IsRegistryEmpty(&bEmpty);

                if (SUCCEEDED(hr) && bEmpty)
                {
                    bAdd = FALSE;
                }
                else
                {
                    bAdd = TRUE;
                }
            }
        }
        else
        {
            if (m_pUser)
            {
                hr = m_pUser->Save();

                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to save the user registry with 0x%x"), hr));
                    return hr;
                }

                hr = m_pUser->IsRegistryEmpty(&bEmpty);

                if (SUCCEEDED(hr) && bEmpty)
                {
                    bAdd = FALSE;
                }
                else
                {
                    bAdd = TRUE;
                }
            }
        }
    }


    XPtrST<TCHAR> xValueIn;
    hr = GetProperty( bMachine ? GPO_MACHEXTENSION_NAMES
                               : GPO_USEREXTENSION_NAMES,
                      xValueIn );
    if ( FAILED(hr) )
    {
       DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to GetProperty with 0x%x"), hr));
       return hr;
    }

    CGuidList guidList;

    hr = guidList.UnMarshallGuids( xValueIn.GetPointer() );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to unmarshall guids with 0x%x"), hr));
        return hr;
    }

    hr = guidList.Update( bAdd, pGuidExtension, pGuidSnapin );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to update with 0x%x"), hr));
        return hr;
    }

    if ( guidList.GuidsChanged() )
    {
        XPtrST<TCHAR> xValueOut;

        hr = guidList.MarshallGuids( xValueOut );
        if ( FAILED(hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to marshall guids with 0x%x"), hr));
            return hr;
        }

        hr = SetProperty( bMachine ? GPO_MACHEXTENSION_NAMES
                                   : GPO_USEREXTENSION_NAMES,
                          xValueOut.GetPointer() );
        if ( FAILED(hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to set property guids with 0x%x"), hr));
            return hr;
        }
    }

    //
    // Get the current version number
    //

    lstrcpy (szPath, m_pFileSysPath);
    lstrcat (szPath, TEXT("\\GPT.INI"));

    if (m_gpoType == GPOTypeDS)
    {

        bstrName = SysAllocString (GPO_VERSION_PROPERTY);

        if (!bstrName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to allocate memory")));
            return ERROR_OUTOFMEMORY;
        }

        VariantInit(&var);
        hr = m_pADs->Get(bstrName, &var);

        if (SUCCEEDED(hr))
        {
            ulOriginal = var.lVal;
        }

        SysFreeString (bstrName);
        VariantClear (&var);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to get ds version number with 0x%x"), hr));
            return hr;
        }
    }
    else
    {
        ulOriginal = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szPath);
    }


    //
    // Separate the user and machine version numbers
    //

    uUser = (USHORT) HIWORD(ulOriginal);
    uMachine = (USHORT) LOWORD(ulOriginal);


    //
    // Increment the version number
    //

    if (bMachine)
    {
        uMachine = uMachine + 1;

        if (uMachine == 0)
            uMachine++;
    }
    else
    {
        uUser = uUser + 1;

        if (uUser == 0)
            uUser++;
    }


    //
    // Put the version number back together
    //

    ulVersion = (ULONG) MAKELONG (uMachine, uUser);


    //
    // Update version number in the GPT
    //

    wsprintf (szVersion, TEXT("%d"), ulVersion);
    if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"),
                                   szVersion, szPath))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to write sysvol version number with %d"),
                 GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Put the original version number in szVersion in case
    // we need to roll backwards below
    //

    wsprintf (szVersion, TEXT("%d"), ulOriginal);


    //
    // Set the version number in the GPC
    //

    if (m_gpoType == GPOTypeDS)
    {
        bstrName = SysAllocString (GPO_VERSION_PROPERTY);

        if (bstrName)
        {
            VariantInit(&var);
            var.vt = VT_I4;
            var.lVal = ulVersion;

            hr = m_pADs->Put(bstrName, var);

            VariantClear (&var);
            SysFreeString (bstrName);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to allocate memory")));
            hr = ERROR_OUTOFMEMORY;
        }


        if (SUCCEEDED(hr))
        {
            //
            // Commit the changes
            //

            hr = m_pADs->SetInfo();

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to commit version number update with 0x%x"), hr));
                if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"),
                                                szVersion, szPath))
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to reset the sysvol version number with %d"),
                             GetLastError()));
                }
            }

        } else {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to update version number with 0x%x"), hr));
            if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"), szVersion, szPath))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to reset the sysvol version number with %d"),
                         GetLastError()));
            }

        }
    }


    //
    // If we are editing the local group policy object, then call
    // RefreshGroupPolicy() so that the end user can see the results
    // immediately.
    //

    if (m_gpoType == GPOTypeLocal)
    {
        RefreshGroupPolicy (bMachine);
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::Save: Leaving with 0x%x"), hr));

    return hr;
}

//*************************************************************
//
//  Delete()
//
//  Purpose:    Deletes this Group Policy Object
//
//  Parameters: none
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::Delete (void)
{
    HRESULT hr;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Delete: Delete called on a READ ONLY GPO")));
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    //
    // Unmount the registry information
    //

    if (m_pUser)
    {
        m_pUser->Release();
        m_pUser = NULL;
    }

    if (m_pMachine)
    {
        m_pMachine->Release();
        m_pMachine = NULL;
    }


    //
    // Clean out the DS stuff
    //

    if (m_gpoType == GPOTypeDS)
    {
        hr = DSDelnode (m_pDSPath);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Delete: Failed to delete DS storage with 0x%x"), hr));
            goto Exit;
        }
    }


    //
    // Delete the file system stuff
    //

    if (Delnode (m_pFileSysPath))
    {
        hr = S_OK;
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Delete: Failed to delete file system storage with %d"),
                GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
    }


    if (SUCCEEDED(hr))
    {
        CleanUp();
    }


Exit:

    return hr;
}


//*************************************************************
//
//  GetName()
//
//  Purpose:    Gets the unique GPO name
//
//  Parameters: pszName is a pointer to a buffer which receives the name
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetName (LPOLESTR pszName, int cchMaxLength)
{

    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    //
    // Save the name
    //

    if ((lstrlen (m_pName) + 1) <= cchMaxLength)
    {
        lstrcpy (pszName, m_pName);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//*************************************************************
//
//  GetDisplayName()
//
//  Purpose:    Gets the friendly name for this GPO
//
//  Parameters: pszName is a pointer to a buffer which receives the name
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetDisplayName (LPOLESTR pszName, int cchMaxLength)
{

    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    if ((lstrlen (m_pDisplayName) + 1) <= cchMaxLength)
    {
        lstrcpy (pszName, m_pDisplayName);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+--------------------------------------------------------------------------
//
//  Member:     CGroupPolicyObject::SetDisplayName
//
//  Synopsis:   changes the friendly display name for a group policy object
//
//  Arguments:  [pszName] - new name (can be NULL to clear name)
//
//  Returns:    S_OK - success
//
//  Modifies:
//
//  Derivation:
//
//  History:    05-002-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

STDMETHODIMP CGroupPolicyObject::SetDisplayName (LPOLESTR lpDisplayName)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName;
    VARIANT var;
    LPOLESTR lpNewName;
    LPTSTR lpPath, lpEnd;
    DWORD dwSize;


    //
    // Check parameters
    //

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    if (m_gpoType != GPOTypeDS)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayName: Called for a non DS GPO")));
        hr = E_INVALIDARG;
        goto Exit;
    }


    if (!lpDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayName: NULL display name")));
        hr = E_INVALIDARG;
        goto Exit;
    }


    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayName: Called for a READ ONLY GPO")));
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }


    //
    // Call the internal method to set the display name
    //

    hr = SetDisplayNameI (m_pADs, lpDisplayName, m_pFileSysPath, TRUE);


Exit:

    return hr;
}

//*************************************************************
//
//  GetPath()
//
//  Purpose:    Returns the path to the GPO
//
//              If the GPO is in the DS, this is an DN path
//              If the GPO is machine based, it is a file system path
//
//  Parameters: pszPath is a pointer to a buffer which receives the path
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetPath (LPOLESTR pszPath, int cchMaxLength)
{
    LPTSTR lpTemp;

    //
    // Check parameters
    //

    if (!pszPath || (cchMaxLength <= 0))
        return E_INVALIDARG;

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    if (m_gpoType == GPOTypeDS)
    {
        lpTemp = MakeNamelessPath (m_pDSPath);

        if (lpTemp)
        {
            if ((lstrlen (lpTemp) + 1) <= cchMaxLength)
            {
                lstrcpy (pszPath, lpTemp);
                LocalFree (lpTemp);
                return S_OK;
            }

            LocalFree (lpTemp);
        }
    }
    else
    {
        if ((lstrlen (m_pFileSysPath) + 1) <= cchMaxLength)
        {
            lstrcpy (pszPath, m_pFileSysPath);
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}


//*************************************************************
//
//  GetDSPath()
//
//  Purpose:    Returns a DS path to the requested section
//
//  Parameters: dwSection identifies root vs user vs machine
//              pszPath is a pointer to a buffer which receives the path
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetDSPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    HRESULT hr = E_FAIL;
    BSTR bstrPath = NULL;
    TCHAR szTemp[100];
    IADsPathname * pADsPathname = NULL;


    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    //
    // Check parameters
    //

    if (!pszPath || (cchMaxPath <= 0))
        return E_INVALIDARG;


    if ((dwSection != GPO_SECTION_ROOT) &&
        (dwSection != GPO_SECTION_USER) &&
        (dwSection != GPO_SECTION_MACHINE))
        return E_INVALIDARG;


    //
    // If this is a local or remote machine GPO, then the
    // caller gets an empty string back.
    //

    if (m_gpoType != GPOTypeDS)
    {
        *pszPath = TEXT('\0');
        hr = S_OK;
        goto Exit;
    }


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the GPO name
    //

    hr = pADsPathname->Set (m_pDSPath, ADS_SETTYPE_FULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the appropriate subcontainer
    //

    if (dwSection != GPO_SECTION_ROOT)
    {
        lstrcpy (szTemp, TEXT("CN="));
        if (dwSection == GPO_SECTION_USER)
            lstrcat (szTemp, USER_SECTION);
        else
            lstrcat (szTemp, MACHINE_SECTION);

        hr = pADsPathname->AddLeafElement (szTemp);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to add subcontainer with 0x%x"), hr));
            goto Exit;
        }
    }


    hr = pADsPathname->Retrieve (ADS_FORMAT_X500_NO_SERVER, &bstrPath);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    if ((lstrlen(bstrPath) + 1) <= cchMaxPath)
    {
        lstrcpy (pszPath, bstrPath);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    SysFreeString (bstrPath);


Exit:

    if (pADsPathname)
    {
        pADsPathname->Release();
    }


    return hr;
}


//*************************************************************
//
//  GetFileSysPath()
//
//  Purpose:    Returns the file system path to the requested section
//
//  Parameters: dwSection identifies user vs machine
//              pszPath is a pointer to a buffer which receives the path
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetFileSysPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    TCHAR szPath[2*MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check parameters
    //

    if (!pszPath || (cchMaxPath <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    lstrcpy (szPath, m_pFileSysPath);

    if (dwSection != GPO_SECTION_ROOT)
    {
        if (dwSection == GPO_SECTION_USER)
        {
            lpEnd = CheckSlash (szPath);
            lstrcpy (lpEnd, USER_SECTION);
        }
        else if (dwSection == GPO_SECTION_MACHINE)
        {
            lpEnd = CheckSlash (szPath);
            lstrcpy (lpEnd, MACHINE_SECTION);
        }
        else
        {
            return E_INVALIDARG;
        }
    }


    if ((lstrlen(szPath) + 1) <= cchMaxPath)
    {
       lstrcpy (pszPath, szPath);
       return S_OK;
    }

    return E_OUTOFMEMORY;
}

//*************************************************************
//
//  GetRegistryKey()
//
//  Purpose:    Returns the requested registry key
//
//  Parameters: dwSection identifies user vs machine
//              hKey receives the opened registry key
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetRegistryKey (DWORD dwSection, HKEY *hKey)
{
    HRESULT hr = E_FAIL;

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    switch (dwSection)
    {
        case GPO_SECTION_USER:
            if (m_pUser)
            {
                hr = m_pUser->GetHKey(hKey);
            }
            break;

        case GPO_SECTION_MACHINE:
            if (m_pMachine)
            {
                hr = m_pMachine->GetHKey(hKey);
            }
            break;
    }

    return (hr);
}

//*************************************************************
//
//  GetOptions()
//
//  Purpose:    Gets the GPO options
//
//  Parameters: dwOptions receives the options
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetOptions (DWORD * dwOptions)
{
    HRESULT hr;


    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }


    //
    // Check argument
    //

    if (!dwOptions)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Received a NULL ptr.")));
        return E_INVALIDARG;
    }


    //
    // If this is a DS GPO, the options are stored as a property on the
    // GPC.  If this a machine GPO, they are in the gpt.ini file.
    //

    if (m_gpoType == GPOTypeDS)
    {
        VARIANT var;
        BSTR bstrProperty;

        //
        // Query for the options
        //

        bstrProperty = SysAllocString (GPO_OPTIONS_PROPERTY);

        if (bstrProperty)
        {
            VariantInit(&var);

            hr = m_pADs->Get(bstrProperty, &var);

            if (SUCCEEDED(hr))
            {
                *dwOptions = var.lVal;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Failed to query for options with 0x%x"), hr));
            }

            VariantClear (&var);
            SysFreeString (bstrProperty);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Failed to allocate memory")));
            hr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        TCHAR szPath[2*MAX_PATH];
        LPTSTR lpEnd;


        //
        // Get the file system path
        //

        hr = GetPath (szPath, ARRAYSIZE(szPath));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Failed to get path with 0x%x"), hr));
            return hr;
        }


        //
        // Tack on gpt.ini
        //

        lpEnd = CheckSlash (szPath);
        lstrcpy (lpEnd, TEXT("GPT.INI"));


        //
        // Get the options
        //

        *dwOptions = GetPrivateProfileInt (TEXT("General"), TEXT("Options"),
                                           0, szPath);

        hr = S_OK;
    }


    return hr;
}

//*************************************************************
//
//  SetOptions()
//
//  Purpose:    Sets the GPO options
//
//  Parameters: dwOptions is the new options
//              dwMask states which options should be set
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::SetOptions (DWORD dwOptions, DWORD dwMask)
{
    HRESULT hr;
    DWORD dwResult = 0, dwOriginal;


    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }

    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Called for a READ ONLY GPO")));
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    //
    // Query for the current options
    //

    hr = GetOptions (&dwResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to get previous options with 0x%x"), hr));
        return hr;
    }


    //
    // Save the original options so we can compare later
    //

    dwOriginal = dwResult;


    //
    // Check for the machine disabled option
    //

    if (dwMask & GPO_OPTION_DISABLE_MACHINE)
    {
        if (dwOptions & GPO_OPTION_DISABLE_MACHINE)
        {
            dwResult |= GPO_OPTION_DISABLE_MACHINE;
        }
        else
        {
            dwResult &= ~GPO_OPTION_DISABLE_MACHINE;
        }
    }


    //
    // Check for the user disabled option
    //

    if (dwMask & GPO_OPTION_DISABLE_USER)
    {
        if (dwOptions & GPO_OPTION_DISABLE_USER)
        {
            dwResult |= GPO_OPTION_DISABLE_USER;
        }
        else
        {
            dwResult &= ~GPO_OPTION_DISABLE_USER;
        }
    }


    //
    // If something changed, set the options back in the GPO
    //

    if (dwResult != dwOriginal)
    {

        //
        // Set the options in the DS or gpt.ini as appropriate
        //

        if (m_gpoType == GPOTypeDS)
        {
            VARIANT var;
            BSTR bstrName;

            bstrName = SysAllocString (GPO_OPTIONS_PROPERTY);

            if (bstrName)
            {
                VariantInit(&var);
                var.vt = VT_I4;
                var.lVal = dwResult;

                hr = m_pADs->Put(bstrName, var);

                VariantClear (&var);
                SysFreeString (bstrName);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to allocate memory")));
                hr = ERROR_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                hr = m_pADs->SetInfo();
            }

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to set options with 0x%x"), hr));
            }
        }
        else
        {
            TCHAR szPath[2*MAX_PATH];
            TCHAR szOptions[20];
            LPTSTR lpEnd;


            //
            // Get the file system path
            //

            hr = GetPath (szPath, ARRAYSIZE(szPath));

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to get path with 0x%x"), hr));
                return hr;
            }


            //
            // Tack on gpt.ini
            //

            lpEnd = CheckSlash (szPath);
            lstrcpy (lpEnd, TEXT("GPT.INI"));


            //
            // Convert the options to string format
            //

            _itot (dwResult, szOptions, 10);


            //
            // Set the options
            //

            if (!WritePrivateProfileString (TEXT("General"), TEXT("Options"),
                                            szOptions, szPath))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to set options with 0x%x"), hr));
                return hr;
            }


            //
            // If this is the local GPO, trigger a policy refresh if appropriate
            //

            if (m_gpoType == GPOTypeLocal)
            {
                RefreshGroupPolicy (TRUE);
                RefreshGroupPolicy (FALSE);
            }

            hr = S_OK;

        }
    }
    else
    {
        hr = S_OK;
    }


    return hr;
}

//*************************************************************
//
//  GetType()
//
//  Purpose:    Gets the GPO type
//
//  Parameters: gpoType receives the type
//
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetType (GROUP_POLICY_OBJECT_TYPE *gpoType)
{

    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetType: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }


    //
    // Check argument
    //

    if (!gpoType)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetType: Received a NULL ptr.")));
        return E_INVALIDARG;
    }


    //
    // Store type
    //

    *gpoType = m_gpoType;

    return S_OK;
}

//*************************************************************
//
//  GetMachineName()
//
//  Purpose:    Gets the machine name of the remote GPO
//
//  Parameters: pszName is a pointer to a buffer which receives the name
//              cchMaxLength is the max size of the buffer
//
//  Note:       This method returns the name passed to OpenRemoteMachineGPO
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetMachineName (LPOLESTR pszName, int cchMaxLength)
{
    HRESULT hr = S_OK;

    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    if (m_pMachineName)
    {
        //
        // Save the name
        //

        if ((lstrlen (m_pMachineName) + 1) <= cchMaxLength)
        {
            lstrcpy (pszName, m_pMachineName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *pszName = TEXT('\0');
    }

    return hr;
}

BOOL
EnableWMIFilters( LPWSTR );

//*************************************************************
//
//  GetPropertySheetPages()
//
//  Purpose:    Returns an array of property sheet pages for
//              the callee to use.  The callee needs to free
//              the buffer with LocalFree when finished.
//
//  Parameters: hPages receives a pointer to an array of page handles
//              uPageCount receives the number of pages in hPages
//
//  Return:     S_OK if successful
//
//*************************************************************


STDMETHODIMP CGroupPolicyObject::GetPropertySheetPages (HPROPSHEETPAGE **hPages,
                                                        UINT *uPageCount)
{
    HPROPSHEETPAGE hTempPages[4];
    HPROPSHEETPAGE *lpPages;
    PROPSHEETPAGE psp;
    UINT i, uTempPageCount = 0;
    HRESULT hr;


    //
    // Create the General property sheet
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPERTIES);
    psp.pfnDlgProc = PropertiesDlgProc;
    psp.lParam = (LPARAM) this;

    hTempPages[uTempPageCount] = CreatePropertySheetPage(&psp);

    if (!hTempPages[uTempPageCount])
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create property sheet page with %d."),
                 GetLastError()));
        return E_FAIL;
    }

    uTempPageCount++;


    //
    // If this is a DS GPO, then create the links, DS security, and WMI filter pages
    //

    if (m_gpoType == GPOTypeDS)
    {
        // Create the search for links page
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_GPE_LINKS);
        psp.pfnDlgProc = GPELinksDlgProc;
        psp.lParam = (LPARAM) this;

        hTempPages[uTempPageCount] = CreatePropertySheetPage(&psp);

        if (!hTempPages[uTempPageCount])
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            // destroy the previous prop page
            DestroyPropertySheetPage(hTempPages[uTempPageCount - 1]);
            return E_FAIL;
        }

        uTempPageCount++;

        //
        // Load DSSec.dll
        //

        if (!m_hinstDSSec)
        {
            m_hinstDSSec = LoadLibrary (TEXT("dssec.dll"));
        }

        if (m_hinstDSSec)
        {

            if (!m_pfnDSCreateSecurityPage)
            {
                m_pfnDSCreateSecurityPage = (PFNDSCREATESECPAGE) GetProcAddress (
                                                    m_hinstDSSec, "DSCreateSecurityPage");
            }

            if (m_pfnDSCreateSecurityPage)
            {

                //
                // Call DSCreateSecurityPage
                //

                hr = m_pfnDSCreateSecurityPage (m_pDSPath, L"groupPolicyContainer",
                                                DSSI_IS_ROOT | ((m_dwFlags & GPO_OPEN_READ_ONLY) ? DSSI_READ_ONLY : 0),
                                                &hTempPages[uTempPageCount],
                                                ReadSecurityDescriptor,
                                                WriteSecurityDescriptor, (LPARAM)this);

                if (SUCCEEDED(hr))
                {
                    uTempPageCount++;
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create DS security page with 0x%x."), hr));
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to get function entry point with %d."), GetLastError()));
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to load dssec.dll with %d."), GetLastError()));
        }

        if ( EnableWMIFilters( m_pDSPath ) )
        {
            // Create the WQL filter page
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = 0;
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_WQLFILTER);
            psp.pfnDlgProc = WQLFilterDlgProc;
            psp.lParam = (LPARAM) this;

            hTempPages[uTempPageCount] = CreatePropertySheetPage(&psp);

            if (!hTempPages[uTempPageCount])
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create property sheet page with %d."),
                         GetLastError()));

                for (i=0; i < uTempPageCount; i++)
                {
                    DestroyPropertySheetPage(hTempPages[i]);
                }
                return E_FAIL;
            }

            uTempPageCount++;
        }
    }



    //
    // Save the results
    //

    lpPages = (HPROPSHEETPAGE *)LocalAlloc (LPTR, sizeof(HPROPSHEETPAGE) * uTempPageCount);

    if (!lpPages)
    {
        for (i=0; i < uTempPageCount; i++)
        {
            DestroyPropertySheetPage(hTempPages[i]);
        }

        return E_OUTOFMEMORY;
    }


    for (i=0; i < uTempPageCount; i++)
    {
        lpPages[i] = hTempPages[i];
    }

    *hPages = lpPages;
    *uPageCount = uTempPageCount;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal methods                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGroupPolicyObject::CreateContainer (LPOLESTR lpParent,
                                                  LPOLESTR lpCommonName,
                                                  BOOL bGPC)
{
    HRESULT hr = E_FAIL;
    VARIANT var;
    IADs * pADs = NULL;
    IADsContainer * pADsContainer = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrProvider = NULL;
    BSTR bstrName = NULL;
    TCHAR szTemp[MAX_PATH];

    // test to see if the container already exists
    {
        szTemp[0] = 0;
        // scan lpParent to find the first instance of "CN="
        LPTSTR lpSub = StrStr(lpParent, TEXT("CN="));
        // insert CN=lpCommonName at that point
        if (lpSub)
        {
            lstrcpyn(szTemp, lpParent, ((int)(lpSub - lpParent)) + 1);
            lstrcat(szTemp, TEXT("CN="));
            lstrcat(szTemp, lpCommonName);
            lstrcat(szTemp, TEXT(","));
            lstrcat(szTemp, lpSub);
        }
        hr = OpenDSObject(szTemp, IID_IADsContainer, (void **)&pADsContainer);

        if (SUCCEEDED(hr))
        {
            hr = ERROR_OBJECT_ALREADY_EXISTS;
            goto Exit;
        }
    }

    //
    // Bind to the parent object so we can create the container
    //

    hr = OpenDSObject(lpParent, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to get gpo container interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create the container (either GPC or normal container)
    //

    lstrcpy (szTemp, TEXT("CN="));
    lstrcat (szTemp, lpCommonName);
    hr = pADsContainer->Create ((bGPC ? TEXT("groupPolicyContainer") : TEXT("container")),
                                szTemp, &pDispatch);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to create container with 0x%x"), hr));
        goto Exit;
    }


    //
    // Query for the IADs interface so we can set the CN name and
    // commit the changes
    //

    hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: QI for IADs failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the common name (aka "cn")
    //

    bstrName = SysAllocString (L"cn");

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString (lpCommonName);

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to put common name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Call SetInfo to commit the changes
    //

    hr = pADs->SetInfo();


Exit:


    if (pDispatch)
    {
        pDispatch->Release();
    }

    if (pADs)
    {
        pADs->Release();
    }

    if (pADsContainer)
    {
        pADsContainer->Release();
    }


    return hr;
}

STDMETHODIMP CGroupPolicyObject::SetDisplayNameI (IADs * pADs, LPOLESTR lpDisplayName,
                                                  LPOLESTR lpGPTPath, BOOL bUpdateDisplayVar)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName;
    VARIANT var;
    LPOLESTR lpNewName;
    LPTSTR lpPath, lpEnd;
    DWORD dwSize;


    //
    // Make a copy of the display name and limit it to MAX_FRIENDLYNAME characters
    //

    dwSize = lstrlen(lpDisplayName);

    if (dwSize > (MAX_FRIENDLYNAME - 1))
    {
        dwSize = (MAX_FRIENDLYNAME - 1);
    }

    lpNewName = (LPOLESTR) LocalAlloc (LPTR, (dwSize + 2) * sizeof(OLECHAR));

    if (!lpNewName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to allocate memory for display name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpyn (lpNewName, lpDisplayName, (dwSize + 1));


    //
    // Set the display name
    //

    bstrName = SysAllocString (GPO_NAME_PROPERTY);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to allocate memory")));
        LocalFree (lpNewName);
        return ERROR_OUTOFMEMORY;
    }

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString (lpNewName);

    if (var.bstrVal)
    {
        hr = pADs->Put(bstrName, var);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }

    SysFreeString (bstrName);
    VariantClear (&var);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to put display name with 0x%x"), hr));
        LocalFree (lpNewName);
        goto Exit;
    }


    //
    // Commit the changes
    //

    hr = pADs->SetInfo();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to commit changes with 0x%x"), hr));
        LocalFree (lpNewName);
        goto Exit;
    }


    //
    // Put the display name in the gpt.ini file also
    //

    lpPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpGPTPath) + 10) * sizeof(TCHAR));

    if (lpPath)
    {
        lstrcpy(lpPath, lpGPTPath);
        lpEnd = CheckSlash(lpPath);
        lstrcpy(lpEnd, TEXT("gpt.ini"));

        if (!WritePrivateProfileString (TEXT("General"), GPO_NAME_PROPERTY,
                                        lpNewName, lpPath))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to write display name to gpt.ini with 0x%x"), hr));
        }

        LocalFree (lpPath);
    }


    //
    // Update the member variable if appropriate
    //

    if (bUpdateDisplayVar)
    {
        //
        // Update the display name variable
        //

        if (m_pDisplayName)
        {
            LocalFree (m_pDisplayName);
            m_pDisplayName = NULL;
        }

        m_pDisplayName = lpNewName;
    }
    else
    {
        LocalFree (lpNewName);
    }


Exit:

    return hr;
}

STDMETHODIMP CGroupPolicyObject::SetGPOInfo (LPOLESTR lpGPO,
                                             LPOLESTR lpDisplayName,
                                             LPOLESTR lpGPTPath)
{
    HRESULT hr = E_FAIL;
    IADs * pADs = NULL;
    BSTR bstrName;
    VARIANT var;
    TCHAR szDefaultName[MAX_FRIENDLYNAME];


    //
    // Bind to the GPO container
    //

    hr = OpenDSObject(lpGPO, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to get gpo interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the display name
    //

    GetNewGPODisplayName (szDefaultName, ARRAYSIZE(szDefaultName));

    hr = SetDisplayNameI (pADs, (lpDisplayName ? lpDisplayName : szDefaultName),
                          lpGPTPath, FALSE);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set display name")));
        goto Exit;
    }


    //
    // Set the GPT location
    //

    bstrName = SysAllocString (GPT_PATH_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString (lpGPTPath);

        if (var.bstrVal)
        {
            hr = pADs->Put(bstrName, var);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
            hr = ERROR_OUTOFMEMORY;
        }

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to save GPT path with 0x%x"), hr));
        goto Exit;
    }



    //
    // Set the version number
    //

    bstrName = SysAllocString (GPO_VERSION_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = 0;

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set version number with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the functionality version number
    //

    bstrName = SysAllocString (GPO_FUNCTION_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = GPO_FUNCTIONALITY_VERSION;

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set functionality version number with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the options
    //

    bstrName = SysAllocString (GPO_OPTIONS_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = 0;

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set options with 0x%x"), hr));
        goto Exit;
    }


    //
    // Commit the changes
    //

    hr = pADs->SetInfo();


Exit:

    if (pADs)
    {
        pADs->Release();
    }


    return hr;
}

STDMETHODIMP CGroupPolicyObject::CheckFSWriteAccess (LPOLESTR lpLocalGPO)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpEnd;
    HRESULT hr;


    lstrcpy (szBuffer, lpLocalGPO);
    lpEnd = CheckSlash (szBuffer);
    lstrcpy (lpEnd, TEXT("gpt.ini"));

    if (!WritePrivateProfileString (TEXT("General"), TEXT("AccessCheck"),
                                   TEXT("test"), szBuffer))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        WritePrivateProfileString (TEXT("General"), TEXT("AccessCheck"),
                                   NULL, szBuffer);
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CGroupPolicyObject::GetSecurityDescriptor (IADs *pADs,
                                                        SECURITY_INFORMATION si,
                                                        PSECURITY_DESCRIPTOR *pSD)
{
    HRESULT hr;
    VARIANT var;
    LPWSTR pszSDProperty = L"nTSecurityDescriptor";
    IDirectoryObject *pDsObject = NULL;
    IADsObjectOptions *pOptions = NULL;
    PADS_ATTR_INFO pSDAttributeInfo = NULL;
    DWORD dwAttributesReturned;


    //
    // Retreive the DS Object interface
    //

    hr = pADs->QueryInterface(IID_IDirectoryObject, (void**)&pDsObject);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to get gpo DS object interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the DS Object Options interface
    //

    hr = pADs->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to get DS object options interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the SECURITY_INFORMATION mask
    //

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = si;

    hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);

    VariantClear (&var);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to set ADSI security options with 0x%x"), hr));
        goto Exit;
    }


    //
    // Read the security descriptor
    //

    hr = pDsObject->GetObjectAttributes(&pszSDProperty, 1, &pSDAttributeInfo,
                                        &dwAttributesReturned);

    if (SUCCEEDED(hr) && !pSDAttributeInfo)
    {
        hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege
    }

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to get DS object attributes with 0x%x"), hr));
        goto Exit;
    }


    //
    // Duplicate the security descriptor
    //

    *pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);

    if (!*pSD)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to allocate memory with 0x%x"), hr));
        goto Exit;
    }

    CopyMemory(*pSD, pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue,
               pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);


Exit:

    if (pSDAttributeInfo)
    {
        FreeADsMem(pSDAttributeInfo);
    }

    if (pOptions)
    {
        pOptions->Release();
    }

    if (pDsObject)
    {
        pDsObject->Release();
    }

    return hr;
}

BOOL CGroupPolicyObject::EnableSecurityPrivs(void)
{
    BOOL bResult;
    HANDLE hToken;
    HANDLE hNewToken;
    BYTE buffer[sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES)];
    PTOKEN_PRIVILEGES pPrivileges = (PTOKEN_PRIVILEGES)buffer;


    //
    // Get a token and enable the Security and Take Ownership
    // privileges, if possible.
    //

    bResult = OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, TRUE, &hToken);

    if (!bResult)
    {
        bResult = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);
    }

    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableSecurityPrivs: Failed to get both thread and process token with %d"),
                GetLastError()));
        return FALSE;
    }


    bResult = DuplicateTokenEx(hToken,
                               TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               NULL,                   // PSECURITY_ATTRIBUTES
                               SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                               TokenImpersonation,     // TokenType
                               &hNewToken);            // Duplicate token

    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableSecurityPrivs: Failed to duplicate the token with %d"),
                GetLastError()));
        CloseHandle(hToken);
        return FALSE;
    }


    //
    // PRIVILEGE_SET contains 1 LUID_AND_ATTRIBUTES already, so
    // this is enough for 2 LUID_AND_ATTRIBUTES (2 privileges).
    //

    CloseHandle(hToken);
    hToken = hNewToken;

    pPrivileges->PrivilegeCount = 2;
    pPrivileges->Privileges[0].Luid = RtlConvertUlongToLuid(SE_SECURITY_PRIVILEGE);
    pPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    pPrivileges->Privileges[1].Luid = RtlConvertUlongToLuid(SE_TAKE_OWNERSHIP_PRIVILEGE);
    pPrivileges->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    bResult = AdjustTokenPrivileges(hToken,     // TokenHandle
                                    FALSE,      // DisableAllPrivileges
                                    pPrivileges,// NewState
                                    0,          // BufferLength
                                    NULL,       // PreviousState
                                    NULL);      // ReturnLength


    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableSecurityPrivs: Failed to AdjustTokenPrivileges with %d"),
                GetLastError()));
        CloseHandle(hToken);
        return FALSE;
    }


    //
    // Set the new thread token
    //

    SetThreadToken(NULL, hToken);

    CloseHandle(hToken);

    return TRUE;
}

DWORD CGroupPolicyObject::EnableInheritance (PACL pAcl)
{
    WORD wIndex;
    DWORD dwResult = ERROR_SUCCESS;
    ACE_HEADER *pAceHeader;


    if (pAcl)
    {
        //
        // Loop through the ACL looking at each ACE entry
        //

        for (wIndex = 0; wIndex < pAcl->AceCount; wIndex++)
        {

            if (!GetAce (pAcl, (DWORD)wIndex, (LPVOID *)&pAceHeader))
            {
                dwResult = GetLastError();
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableInheritance: GetAce failed with %d"),
                         dwResult));
                goto Exit;
            }


            //
            // Turn on the inheritance flags
            //

            pAceHeader->AceFlags |= (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
        }
    }

Exit:

    return dwResult;
}

//
// This method will convert a DS ACL into a file system ACL
//

DWORD CGroupPolicyObject::MapSecurityRights (PACL pAcl)
{
    WORD wIndex;
    DWORD dwResult = ERROR_SUCCESS;
    ACE_HEADER *pAceHeader;
    PACCESS_ALLOWED_ACE pAce;
    PACCESS_ALLOWED_OBJECT_ACE pObjectAce;
    ACCESS_MASK AccessMask;

#if DBG
    PSID pSid;
    TCHAR szName[150], szDomain[100];
    DWORD dwName, dwDomain;
    SID_NAME_USE SidUse;
#endif



    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: ACL contains %d ACEs"), pAcl->AceCount));


    //
    // Loop through the ACL looking at each ACE entry
    //

    for (wIndex = 0; wIndex < pAcl->AceCount; wIndex++)
    {

        if (!GetAce (pAcl, (DWORD)wIndex, (LPVOID *)&pAceHeader))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::MapSecurityRights: GetAce failed with %d"),
                     dwResult));
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: ==================")));


        switch (pAceHeader->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
                {
                pAce = (PACCESS_ALLOWED_ACE) pAceHeader;
#if DBG
                pSid = (PSID) &pAce->SidStart;
                dwName = ARRAYSIZE(szName);
                dwDomain = ARRAYSIZE(szDomain);

                if (LookupAccountSid (NULL, pSid, szName, &dwName, szDomain,
                                      &dwDomain, &SidUse))
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Normal ACE entry for:  Name = %s  Domain = %s"),
                             szName, szDomain));
                }
#endif

                AccessMask = pAce->Mask;
                pAce->Mask &= STANDARD_RIGHTS_ALL;


                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: DS access mask is 0x%x"),
                          AccessMask));

                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Corresponding sysvol permissions follow:")));


                //
                // Read
                //

                if ((AccessMask & ACTRL_DS_READ_PROP) &&
                    (AccessMask & ACTRL_DS_LIST))
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting Read permission")));

                    pAce->Mask |= (SYNCHRONIZE | FILE_LIST_DIRECTORY |
                                            FILE_READ_ATTRIBUTES | FILE_READ_EA |
                                            FILE_READ_DATA | FILE_EXECUTE);
                }


                //
                // Write
                //

                if (AccessMask & ACTRL_DS_WRITE_PROP)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting Write permission")));

                    pAce->Mask |= (SYNCHRONIZE | FILE_WRITE_DATA |
                                            FILE_APPEND_DATA | FILE_WRITE_EA |
                                            FILE_WRITE_ATTRIBUTES | FILE_ADD_FILE |
                                            FILE_ADD_SUBDIRECTORY);
                }


                //
                // Misc
                //

                if (AccessMask & ACTRL_DS_CREATE_CHILD)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting directory creation permission")));

                    pAce->Mask |= (FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE);
                }

                if (AccessMask & ACTRL_DS_DELETE_CHILD)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting directory delete permission")));

                    pAce->Mask |= FILE_DELETE_CHILD;
                }


                //
                // Inheritance
                //

                pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);

                }
                break;


            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Clearing access mask in DS object ACE entry")));
                pObjectAce = (PACCESS_ALLOWED_OBJECT_ACE) pAceHeader;
                pObjectAce->Mask = 0;
                break;

            default:
                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Unknown ACE type 0x%x"), pAceHeader->AceType));
                break;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: ==================")));
    }

Exit:

    return dwResult;
}


//
// This method will convert a DS security access list into a
// file system security access list and actually set the security
//

DWORD CGroupPolicyObject::SetSysvolSecurity (LPTSTR lpFileSysPath, SECURITY_INFORMATION si,
                                             PSECURITY_DESCRIPTOR pSD)
{
    PACL pSacl = NULL, pDacl = NULL;
    PSID psidOwner = NULL, psidGroup = NULL;
    BOOL bAclPresent, bDefaulted;
    DWORD dwResult;


    //
    // Get the DACL
    //

    if (si & DACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorDacl (pSD, &bAclPresent, &pDacl, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorDacl failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Get the SACL
    //

    if (si & SACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorSacl (pSD, &bAclPresent, &pSacl, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorSacl failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Get the owner
    //

    if (si & OWNER_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorOwner (pSD, &psidOwner, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorOwner failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Get the group
    //

    if (si & GROUP_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorGroup (pSD, &psidGroup, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorGroup failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Convert the DS access control lists into file system
    // access control lists
    //

    if (pDacl)
    {
        dwResult = MapSecurityRights (pDacl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: MapSecurityRights for the DACL failed with %d"),
                     dwResult));
            goto Exit;
        }
    }

    if (pSacl)
    {
        dwResult = MapSecurityRights (pSacl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: MapSecurityRights for the SACL failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Switch to using the PROTECTED_DACL_SECURITY_INFORMATION and
    // PROTECTED_SACL_SECURITY_INFORMATION flags so that this subdirectory
    // does not inherit settings from it's parent (aka: "protect" it)
    //

    if (si & DACL_SECURITY_INFORMATION)
    {
        si |= PROTECTED_DACL_SECURITY_INFORMATION;
    }

    if (si & SACL_SECURITY_INFORMATION)
    {
        si |= PROTECTED_SACL_SECURITY_INFORMATION;
    }


    //
    // Set the access control information for the file system portion
    //

    dwResult = SetNamedSecurityInfo(lpFileSysPath, SE_FILE_OBJECT, si, psidOwner,
                                 psidGroup, pDacl, pSacl);


Exit:


    return dwResult;
}

HRESULT WINAPI CGroupPolicyObject::ReadSecurityDescriptor (LPCWSTR lpGPOPath,
                                                           SECURITY_INFORMATION si,
                                                           PSECURITY_DESCRIPTOR *pSD,
                                                           LPARAM lpContext)
{
    CGroupPolicyObject * pGPO;
    HRESULT hr;


    //
    // Convert lpContext into a pGPO
    //

    pGPO = (CGroupPolicyObject*)lpContext;

    if (!pGPO)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::ReadSecurityDescriptor: GPO interface pointer is NULL")));
        return E_FAIL;
    }


    hr = pGPO->GetSecurityDescriptor (pGPO->m_pADs, si, pSD);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::ReadSecurityDescriptor: GetSecurityDescriptor returned 0x%x"), hr));
    }

    return (hr);
}

HRESULT WINAPI CGroupPolicyObject::WriteSecurityDescriptor (LPCWSTR lpGPOPath,
                                                            SECURITY_INFORMATION si,
                                                            PSECURITY_DESCRIPTOR pSD,
                                                            LPARAM lpContext)
{
    CGroupPolicyObject * pGPO;
    IDirectoryObject *pDsObject = NULL;
    IADsObjectOptions *pOptions = NULL;
    DWORD dwResult = ERROR_SUCCESS;
    HRESULT hr;
    VARIANT var;
    ADSVALUE attributeValue;
    ADS_ATTR_INFO attributeInfo;
    DWORD dwAttributesModified;
    DWORD dwSDLength;
    PSECURITY_DESCRIPTOR psd = NULL, pSDOrg = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
    DWORD dwRevision;
    PACL pAcl;
    BOOL bPresent, bDefault;


    //
    // Convert lpContext into a pGPO
    //

    pGPO = (CGroupPolicyObject*)lpContext;

    if (!pGPO)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: GPO interface pointer is NULL")));
        return E_FAIL;
    }


    //
    // Get the original security descriptor from the DS
    //

    hr = pGPO->GetSecurityDescriptor (pGPO->m_pADs, si, &pSDOrg);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to query the security descriptor with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the DS Object interface
    //

    hr = pGPO->m_pADs->QueryInterface(IID_IDirectoryObject, (void**)&pDsObject);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get DS object interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the DS Object Options interface
    //

    hr = pGPO->m_pADs->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get DS object options interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the SECURITY_INFORMATION mask
    //

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = si;

    hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);

    VariantClear (&var);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get DS object options interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Need the total size of the security descriptor
    //

    dwSDLength = GetSecurityDescriptorLength(pSD);


    //
    // If necessary, make a self-relative copy of the security descriptor
    //

    if (!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision))
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get security descriptor control with %d"),
                 dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }


    if (!(sdControl & SE_SELF_RELATIVE))
    {
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

        if (!psd)
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to allocate memory for new SD with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        if (!MakeSelfRelativeSD(pSD, psd, &dwSDLength))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: MakeSelfRelativeSD failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        //
        // Point to the self-relative copy
        //

        pSD = psd;
    }


    //
    // By default, the general page will set things up so the inheritance
    // is for the root container only.  We really want the inheritance to
    // be for the root and all sub-containers, so run through the
    // DACL and SACL and set the new inheritance flags
    //

    if (si & DACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefault))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: GetSecurityDescriptorDacl failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        dwResult = pGPO->EnableInheritance (pAcl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: EnableInheritance failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }
    }


    if (si & SACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefault))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: GetSecurityDescriptorSacl failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        dwResult = pGPO->EnableInheritance (pAcl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: EnableInheritance failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }
    }


    //
    // Set the DS security
    //

    attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeValue.SecurityDescriptor.dwLength = dwSDLength;
    attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSD;

    attributeInfo.pszAttrName = L"nTSecurityDescriptor";
    attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
    attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeInfo.pADsValues = &attributeValue;
    attributeInfo.dwNumValues = 1;

    hr = pDsObject->SetObjectAttributes(&attributeInfo, 1, &dwAttributesModified);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to set DS security with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the sysvol security
    //

    dwResult = pGPO->SetSysvolSecurity (pGPO->m_pFileSysPath, si, pSD);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to set the security for the file system portion <%s> with %d"),
                 pGPO->m_pFileSysPath, dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);


        //
        // Restore the orignal DS security
        //

        attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        attributeValue.SecurityDescriptor.dwLength = GetSecurityDescriptorLength(pSDOrg);
        attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSDOrg;

        attributeInfo.pszAttrName = L"nTSecurityDescriptor";
        attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
        attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        attributeInfo.pADsValues = &attributeValue;
        attributeInfo.dwNumValues = 1;

        if (FAILED(pDsObject->SetObjectAttributes(&attributeInfo, 1, &dwAttributesModified)))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to restore DS security")));
        }

        goto Exit;
    }


Exit:

    if (pDsObject)
    {
        pDsObject->Release();
    }

    if (pOptions)
    {
        pOptions->Release();
    }

    if (psd)
    {
        LocalFree(psd);
    }

    if (pSDOrg)
    {
        LocalFree(pSDOrg);
    }

    return (hr);
}

STDMETHODIMP CGroupPolicyObject::CleanUp (void)
{

    if (m_pUser)
    {
        m_pUser->Release();
        m_pUser = NULL;
    }

    if (m_pMachine)
    {
        m_pMachine->Release();
        m_pMachine = NULL;
    }

    if (m_pName)
    {
        LocalFree (m_pName);
        m_pName = NULL;
    }

    if (m_pDisplayName)
    {
        LocalFree (m_pDisplayName);
        m_pDisplayName = NULL;
    }

    if (m_pDSPath)
    {
        LocalFree (m_pDSPath);
        m_pDSPath = NULL;
    }

    if (m_pFileSysPath)
    {
        LocalFree (m_pFileSysPath);
        m_pFileSysPath = NULL;
    }

    if (m_pMachineName)
    {
        LocalFree (m_pMachineName);
        m_pMachineName = NULL;
    }

    if (m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }

    m_gpoType = GPOTypeLocal;
    m_bInitialized = FALSE;

    return S_OK;
}

STDMETHODIMP CGroupPolicyObject::RefreshGroupPolicy (BOOL bMachine)
{
    HINSTANCE hInstUserEnv;
    PFNREFRESHPOLICY pfnRefreshPolicy;


    //
    // Load the function we need
    //

    hInstUserEnv = LoadLibrary (TEXT("userenv.dll"));

    if (!hInstUserEnv) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::RefreshGroupPolicy:  Failed to load userenv with %d."),
                 GetLastError()));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    pfnRefreshPolicy = (PFNREFRESHPOLICY)GetProcAddress (hInstUserEnv,
                                                         "RefreshPolicy");

    if (!pfnRefreshPolicy) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::RefreshGroupPolicy:  Failed to find RefreshPolicy with %d."),
                 GetLastError()));
        FreeLibrary (hInstUserEnv);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Refresh policy
    //

    pfnRefreshPolicy (bMachine);


    //
    // Clean up
    //

    FreeLibrary (hInstUserEnv);

    return S_OK;
}

BSTR
ParseDomainName( LPWSTR szDomain )
{
    BSTR bstrDomain = 0;

    if ( szDomain )
    {
        WCHAR szXDomain[MAX_PATH*2];
        DWORD dwSize = MAX_PATH*2;

        if ( TranslateName( szDomain,
                            NameUnknown,
                            NameCanonical,
                            szXDomain,
                            &dwSize ) )
        {
            LPWSTR szTemp = wcschr( szXDomain, L'/' );

            if ( szTemp )
            {
                *szTemp = 0;
            }

            bstrDomain = SysAllocString( szXDomain );
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("ParseDomainName: *** %s ***"), bstrDomain ? bstrDomain : L"" ));

    return bstrDomain;
}

BSTR
ParseDomainName2( LPWSTR szDSObject )
{
    BSTR bstrDomain = 0;

    if ( !szDSObject )
    {
        return bstrDomain;
    }

    if ( CompareString( LOCALE_USER_DEFAULT,
                        NORM_IGNORECASE,
                        szDSObject,
                        7,
                        L"LDAP://",
                        7 ) == CSTR_EQUAL )
    {
        szDSObject += 7;
    }

    if ( *szDSObject )
    {
        WCHAR szXDomain[MAX_PATH*2];
        DWORD dwSize = MAX_PATH*2;

        if ( TranslateName( szDSObject,
                            NameUnknown,
                            NameCanonical,
                            szXDomain,
                            &dwSize ) )
        {
            LPWSTR szTemp = wcschr( szXDomain, L'/' );

            if ( szTemp )
            {
                *szTemp = 0;
            }

            bstrDomain = SysAllocString( szXDomain );
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("ParseDomainName2: *** %s ***"), bstrDomain ? bstrDomain : L"" ));

    return bstrDomain;
}

INT_PTR CALLBACK CGroupPolicyObject::WQLFilterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGroupPolicyObject* pGPO;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            HRESULT hr;
            BSTR bstrName;
            VARIANT var;
            LPTSTR lpDisplayName;

            pGPO = (CGroupPolicyObject*) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGPO);


            //
            // Set the defaults
            //

            pGPO->m_pTempFilterString = NULL;
            CheckDlgButton (hDlg, IDC_NONE, BST_CHECKED);
            EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), FALSE);

            if (pGPO->m_dwFlags & GPO_OPEN_READ_ONLY)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_NONE), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_THIS_FILTER), FALSE);
            }


            //
            // Query for the filter
            //

            bstrName = SysAllocString (GPO_WQLFILTER_PROPERTY);

            if (!bstrName)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory")));
                break;
            }

            VariantInit(&var);

            hr = pGPO->m_pADs->Get(bstrName, &var);


            //
            // If we find a filter, initialize the UI and save the filter string in the
            // temporary buffer
            //

            if (SUCCEEDED(hr))
            {
                //
                // Check if we found a null filter (defined as one space character)
                //

                if (*var.bstrVal != TEXT(' '))
                {
                    pGPO->m_pTempFilterString = new TCHAR [lstrlen(var.bstrVal) + 1];

                    if (!pGPO->m_pTempFilterString)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory for filter")));
                        SysFreeString (bstrName);
                        VariantClear (&var);
                        break;
                    }

                    lstrcpy (pGPO->m_pTempFilterString, var.bstrVal);

                    lpDisplayName = GetWMIFilterDisplayName (hDlg, pGPO->m_pTempFilterString, TRUE, FALSE);

                    if (lpDisplayName)
                    {
                        SetDlgItemText (hDlg, IDC_FILTER_NAME, lpDisplayName);
                        delete [] lpDisplayName;

                        CheckDlgButton (hDlg, IDC_NONE, BST_UNCHECKED);
                        CheckDlgButton (hDlg, IDC_THIS_FILTER, BST_CHECKED);
                        EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), TRUE);

                        if (!(pGPO->m_dwFlags & GPO_OPEN_READ_ONLY))
                        {
                            EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), TRUE);
                        }
                    }
                }
            }
            else
            {
                if (hr != E_ADS_PROPERTY_NOT_FOUND)
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to query filter with 0x%x"), hr));
                }
            }


            SysFreeString (bstrName);
            VariantClear (&var);

            break;
        }

        case WM_COMMAND:
        {
            pGPO = (CGroupPolicyObject *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPO) {
                break;
            }

            if (LOWORD(wParam) == IDC_FILTER_BROWSE)
            {
                LPTSTR lpDisplayName = NULL, lpFilter = NULL;
                WCHAR   szDomain[2*MAX_PATH];
                HRESULT hr = pGPO->GetPath( szDomain, ARRAYSIZE( szDomain ) );
                if ( FAILED( hr ) )
                {
                    break;
                }

                BSTR bstrDomain = ParseDomainName2( szDomain );

                if (!GetWMIFilter(FALSE, hDlg, TRUE, &lpDisplayName, &(pGPO->m_pTempFilterString), bstrDomain ))
                {
                    SysFreeString( bstrDomain );
                    break;
                }

                SysFreeString( bstrDomain );

                if (!(pGPO->m_pTempFilterString)) {
                    SetDlgItemText (hDlg, IDC_FILTER_NAME, TEXT(""));

                    EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), FALSE);
                    EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), FALSE);
                    CheckDlgButton (hDlg, IDC_NONE, BST_CHECKED);
                    CheckDlgButton (hDlg, IDC_THIS_FILTER, BST_UNCHECKED);

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                }
                else {
                    SetDlgItemText (hDlg, IDC_FILTER_NAME, lpDisplayName);
                    delete [] lpDisplayName;

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                }
            }

            if (LOWORD(wParam) == IDC_NONE)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), FALSE);

                if (pGPO->m_pTempFilterString)
                {
                    delete [] pGPO->m_pTempFilterString;
                    pGPO->m_pTempFilterString = NULL;
                }
            }
            else if (LOWORD(wParam) == IDC_THIS_FILTER)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), TRUE);
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), TRUE);
            }

            break;
        }

        case WM_NOTIFY:
        {
            pGPO = (CGroupPolicyObject *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPO) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    HRESULT hr;
                    BSTR bstrName;
                    VARIANT var;


                    //
                    // Save the current WQL filter
                    //

                    bstrName = SysAllocString (GPO_WQLFILTER_PROPERTY);

                    if (!bstrName)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory")));
                        break;
                    }

                    VariantInit(&var);
                    var.vt = VT_BSTR;
                    var.bstrVal = SysAllocString (pGPO->m_pTempFilterString ? pGPO->m_pTempFilterString : TEXT(" "));

                    if (var.bstrVal)
                    {
                        hr = pGPO->m_pADs->Put(bstrName, var);
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory")));
                        SysFreeString (bstrName);
                        break;
                    }

                    SysFreeString (bstrName);
                    VariantClear (&var);


                    if (FAILED(hr))
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to put display name with 0x%x"), hr));
                        break;
                    }


                    //
                    // Commit the changes
                    //

                    hr = pGPO->m_pADs->SetInfo();

                    if (FAILED(hr))
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to commit changes with 0x%x"), hr));
                        break;
                    }


                    //
                    // Free the filter string if appropriate
                    //

                    if (((PSHNOTIFY *)lParam)->lParam)
                    {
                        if (pGPO->m_pTempFilterString)
                        {
                            delete [] pGPO->m_pTempFilterString;
                            pGPO->m_pTempFilterString = NULL;
                        }
                    }

                    break;
                }

                case PSN_RESET:
                {
                    if (pGPO->m_pTempFilterString)
                    {
                        delete [] pGPO->m_pTempFilterString;
                        pGPO->m_pTempFilterString = NULL;
                    }
                    break;
                }
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aWQLFilterHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aWQLFilterHelpIds);
            return (TRUE);


        default:
            break;
    }

    return FALSE;
}

#define MAX_BUTTON_LEN 64
//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CGroupPolicyObject::GPELinksDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    GLPARAM * pglp = NULL;
    switch (message)
    {
        case WM_INITDIALOG:
        {
            LV_COLUMN lvc = {LVCF_WIDTH};
            RECT rc;
            HWND hList = GetDlgItem(hDlg, IDC_RESULTLIST);

            // Allocate the per dialog structure
            pglp = (GLPARAM*)LocalAlloc (LPTR, sizeof(GLPARAM));
            if (pglp)
            {
                pglp->pGPO = (CGroupPolicyObject*) (((LPPROPSHEETPAGE)lParam)->lParam);
                SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pglp);
                pglp->pGPO->FillDomainList (GetDlgItem(hDlg, IDC_CBDOMAIN));
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: Failed to LocalAlloc in WM_INITDIALOG")));
            }

            // Set the Columns, in the list view
            if (IsWindow(hList))
            {
                SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_LABELTIP,
                            LVS_EX_LABELTIP);

                GetClientRect(hList, &rc);
                lvc.cx = (rc.right - rc.left);
                ListView_InsertColumn(hList, 0, &lvc);
            }

            // Show icon in the corner
            Animate_Open(GetDlgItem(hDlg, IDAC_FIND), MAKEINTRESOURCE(IDA_FIND));
            break;
        }

        case WM_COMMAND:
        {
            pglp = (GLPARAM *) GetWindowLongPtr (hDlg, DWLP_USER);
            if (!pglp)
            {
                break;
            }

            if ((IDC_CBDOMAIN == LOWORD(wParam)) && ((CBN_SELCHANGE == HIWORD(wParam)) || (CBN_SELENDOK == HIWORD(wParam))))
            {
                // Clear the list view
                pglp->fAbort = TRUE;
                SendDlgItemMessage(hDlg, IDC_RESULTLIST, LVM_DELETEALLITEMS, 0, 0L);
                break;
            }

            // If the IDC_ACTION was clicked then do search
            if ((IDC_ACTION == LOWORD(wParam)) && (BN_CLICKED == HIWORD(wParam)))
            {
                // If we are have been asked to start a search, create the thread to do so
                if (!pglp->fFinding)
                {
                    HANDLE hThread = NULL;
                    DWORD dwThreadId = 0;
                    GLTHREADPARAM  * pgltp = NULL;
                    int nCurSel = 0;

                    // Make sure something has been selected in the  combo box
                    nCurSel = (int)SendDlgItemMessage (hDlg, IDC_CBDOMAIN, CB_GETCURSEL, 0, 0L);
                    if (CB_ERR == nCurSel)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: There was no Domain selected in the combo box. Exiting.")));
                        break;
                    }

                    // Allocate the Thread Param structure
                    pgltp = (GLTHREADPARAM*)LocalAlloc (LPTR, sizeof(GLTHREADPARAM));
                    if (!pgltp)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: Failed to LocalAlloc Thread Param structure")));
                        break;
                    }

                    pgltp->hDlg = hDlg;
                    pgltp->pGPO = pglp->pGPO;
                    pgltp->pfAbort = &pglp->fAbort;

                    pgltp->pszLDAPName = (LPOLESTR)SendDlgItemMessage (hDlg, IDC_CBDOMAIN, CB_GETITEMDATA, nCurSel, 0L);

                    if (!pgltp->pszLDAPName)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: The LDAP name buffer was NULL.")));
                        LocalFree(pgltp);
                        break;
                    }

                    pgltp->pszLDAPName = MakeFullPath (pgltp->pszLDAPName, pglp->pGPO->m_pMachineName);

                    // Unset the abort flag
                    pglp->fAbort = FALSE;

                    // Clear the list view
                    SendDlgItemMessage(hDlg, IDC_RESULTLIST, LVM_DELETEALLITEMS, 0, 0L);

                    // Fire off the thread to fill the list view
                    hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)GLThreadFunc, pgltp, 0, &dwThreadId);
                    if (!hThread)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: Could not create the search thread.")));
                        LocalFree(pgltp);
                        break;
                    }
                    CloseHandle (hThread);

                    // Change the text on the button to "Stop"
                    SendMessage (hDlg, PDM_CHANGEBUTTONTEXT, 0, 0L);
                }
                else
                {
                    // The user wants to stop the search
                    pglp->fAbort = TRUE;
                }
            }
            break;
        }

        case PDM_CHANGEBUTTONTEXT:
        {
            TCHAR szButtonText[MAX_BUTTON_LEN] = {0};

            pglp = (GLPARAM *) GetWindowLongPtr (hDlg, DWLP_USER);
            if (!pglp)
            {
                break;
            }

            if (!pglp->fFinding)
                Animate_Play(GetDlgItem(hDlg, IDAC_FIND), 0, -1, -1);
            else
                Animate_Stop(GetDlgItem(hDlg, IDAC_FIND));


            // Set the button to show appropriate text
            LoadString (g_hInstance, pglp->fFinding ? IDS_FINDNOW: IDS_STOP, szButtonText, ARRAYSIZE(szButtonText));
            SetDlgItemText (hDlg, IDC_ACTION, szButtonText);

            // Flip the toggle
            pglp->fFinding = !pglp->fFinding;
            break;
        }

        case WM_NOTIFY:
        {
            pglp = (GLPARAM *) GetWindowLongPtr (hDlg, DWLP_USER);
            if (!pglp)
            {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {

                // In case thr user wants to cancel, bail from the thread
                case PSN_QUERYCANCEL:
                    pglp->fAbort = TRUE;
                    break;

                // In case thr user wants to close the prop sheet, bail from the thread
                case PSN_APPLY:
                case PSN_RESET:
                {
                    int nCount = 0;


                    PSHNOTIFY * pNotify = (PSHNOTIFY *) lParam;

                    // User just hit the Apply button don't destroy everything.
                    if (!pNotify->lParam)
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                        return TRUE;
                    }

                    pglp->fAbort = TRUE;

                    // When the dialog is going away, delete all the data that was stored with each CB item in
                    // FillDomainList() are freed
                    if (IsWindow(GetDlgItem(hDlg, IDC_CBDOMAIN)))
                    {
                        nCount = (int) SendDlgItemMessage(hDlg, IDC_CBDOMAIN, CB_GETCOUNT, 0, 0L);
                        for (int nIndex = 0; nIndex < nCount; nIndex++)
                        {
                            LPOLESTR pszStr;
                            pszStr = (LPOLESTR)SendDlgItemMessage(hDlg, IDC_CBDOMAIN, CB_GETITEMDATA, nIndex, 0L);
                            if (pszStr)
                                delete [] pszStr;
                        }
                    }

                    // Free the per dialog structure
                    LocalFree (pglp);
                    SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) NULL);
                    Animate_Close(GetDlgItem(hDlg, IDAC_FIND));
                    break;
                }
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aLinkHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aLinkHelpIds);
            return (TRUE);


        default:
            break;
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// The thread that will look call the recursive find function. This function will clean up
// the param structure that has been passed in
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CGroupPolicyObject::GLThreadFunc(GLTHREADPARAM  * pgltp)
{
    LPTSTR lpGPO;
    DWORD dwRet;
    HINSTANCE hInstance = LoadLibrary(TEXT("GPEdit.dll"));
    HRESULT hr;


    //
    // Initialize COM
    //

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        return 0L;
    }


    //
    // Make sure we have a thread param structure
    //

    if (pgltp)
    {

        pgltp->pGPO->AddRef();

        lpGPO = MakeNamelessPath (pgltp->pGPO->m_pDSPath);

        if (lpGPO)
        {
            //
            // Check if the user wants to abort. Otherwise make recursive call
            //

            if (!*(pgltp->pfAbort))
            {
                dwRet = pgltp->pGPO->FindLinkInDomain(pgltp, lpGPO);
            }

            if ((!*(pgltp->pfAbort)) && dwRet)
            {
                pgltp->pGPO->FindLinkInSite(pgltp, lpGPO);
            }

            if (IsWindow(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST)))
            {
                ListView_SetItemState(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), 0, LVIS_SELECTED |LVIS_FOCUSED, LVIS_SELECTED |LVIS_FOCUSED);
            }

            //
            // Switch the button text, change the cursor, and free the param that the
            // dialog proc allocated and sent to us
            //

            SendMessage(pgltp->hDlg, PDM_CHANGEBUTTONTEXT, 0, 0L);

            LocalFree (lpGPO);
        }
        pgltp->pGPO->Release();

        LocalFree(pgltp->pszLDAPName);
        LocalFree(pgltp);
    }


    //
    // Uninitialize COM
    //
    CoUninitialize();

    FreeLibraryAndExitThread(hInstance, 0);
    return 0L;
}


DWORD WINAPI CGroupPolicyObject::FindLinkInSite(GLTHREADPARAM  * pgltp, LPTSTR lpGPO)
{
    IADsContainer * pADsContainer = NULL;
    HRESULT hr;
    IEnumVARIANT *pVar = NULL;
    IADs * pADs = NULL;
    VARIANT var;
    ULONG ulResult;
    IDispatch * pDispatch = NULL;
    BSTR bstrClassName;
    BSTR bstrSite = NULL;
    IADsPathname * pADsPathname = NULL;


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the gpo name
    //

    hr = pADsPathname->Set (pgltp->pszLDAPName, ADS_SETTYPE_FULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the configuration folder to the path
    //

    hr = pADsPathname->AddLeafElement (TEXT("CN=Configuration"));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to add configuration folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the sites container to the path
    //

    hr = pADsPathname->AddLeafElement (TEXT("CN=Sites"));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to add sites folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the container path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrSite);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to retreive site path with 0x%x"), hr));
        goto Exit;
    }


    // Create Enumerator
    hr = OpenDSObject(bstrSite, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("FindLinkInSite: Failed to get gpo container interface with 0x%x for object %s"),
                 hr, bstrSite));
        goto Exit;
    }

    // Build the enumerator
    hr = ADsBuildEnumerator (pADsContainer, &pVar);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("FindLinkInSite: Failed to get enumerator with 0x%x"), hr));
        goto Exit;
    }

    //
    // Enumerate
    //
    while (TRUE)
    {
        TCHAR lpSite[] = TEXT("site");
        DWORD dwStrLen = lstrlen (lpSite);

        // Check if the user wants to abort. Before proceeding

        if (*(pgltp->pfAbort))
        {
            break;
        }

        VariantInit(&var);

        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }


        if ((FAILED(hr)) || (var.vt != VT_DISPATCH))
        {
            DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to enumerator with 0x%x or we didn't get the IDispatch"), hr));
            VariantClear (&var);
            break;
        }


        if (*(pgltp->pfAbort))
        {
            VariantClear (&var);
            break;
        }

        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            VariantClear (&var);
            goto Exit;
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this object
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            VariantClear (&var);
            goto Exit;
        }

        //
        // Get the relative and class names
        //

        hr = pADs->get_Class (&bstrClassName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get class name with 0x%x"), hr));
            pADs->Release();
            VariantClear (&var);
            goto Exit;
        }


        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           lpSite, dwStrLen, bstrClassName, dwStrLen) == CSTR_EQUAL)
        {

            VARIANT varLink;
            BSTR bstrLinkProp;

            VariantInit(&varLink);
            bstrLinkProp = SysAllocString(GPM_LINK_PROPERTY);

            if (bstrLinkProp)
            {
                // Now get the Name property
                hr = pADs->Get(bstrLinkProp, &varLink);

                // Create the new LDAP:// string and call FindLinkInDomain() recursively
                if (SUCCEEDED(hr) && wcsstr(varLink.bstrVal, lpGPO))
                {
                    VARIANT varName;
                    BSTR bstrNameProp;

                    VariantInit(&varName);
                    bstrNameProp = SysAllocString(GPM_NAME_PROPERTY);

                    if (bstrNameProp)
                    {
                        // Now get the Name property
                        hr = pADs->Get(bstrNameProp, &varName);

                        if (SUCCEEDED(hr))
                        {
                            LV_ITEM lvi = {LVIF_TEXT};
                            LPTSTR pszTemp = MakeNamelessPath(bstrSite);

                            if (pszTemp)
                            {
                                ULONG ulLen = wcslen(pszTemp) + 2 + wcslen(varName.bstrVal);
                                LPOLESTR pszTranslated = new OLECHAR[ulLen];

                                if (pszTranslated)
                                {
                                    // Move pointer over the lDAP:// string and insert the rest into the listview
                                    pszTemp += wcslen(TEXT("LDAP://"));

                                    lvi.iItem = 0x7FFFFFFF;
                                    if (TranslateName(pszTemp, NameFullyQualifiedDN, NameCanonical, pszTranslated, &ulLen))
                                    {
                                        wcscat(pszTranslated, TEXT("/"));
                                        wcscat(pszTranslated, varName.bstrVal);
                                        lvi.pszText = pszTranslated;
                                        ListView_InsertItem(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), &lvi);
                                    }
                                    delete [] pszTranslated;
                                }

                                LocalFree (pszTemp);
                            }
                        }
                        SysFreeString (bstrNameProp);
                    }
                    VariantClear (&varName);
                }

                SysFreeString (bstrLinkProp);
            }
            VariantClear (&varLink);
        }

        pADs->Release();
        SysFreeString (bstrClassName);
    }

Exit:
    if (pADsContainer)
        pADsContainer->Release();

    if (pADsPathname)
        pADsPathname->Release();

    if (bstrSite)
        SysFreeString (bstrSite);

    return 1L;
}


//////////////////////////////////////////////////////////////////////////////
// Recursive call that will look through all domains and OUs for our GUID
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CGroupPolicyObject::FindLinkInDomain(GLTHREADPARAM  * pgltp, LPTSTR lpGPO)
{
    IADs * pADs = NULL;
    IADsContainer * pADsContainer = NULL;
    HRESULT hr;
    IEnumVARIANT *pVar = NULL;
    VARIANT var;
    ULONG ulResult;
    BSTR bstrClassName;
    IDispatch * pDispatch = NULL;
    DWORD dwResult = 1;


    // Check if the user wants to abort. Before proceeding
    if (*(pgltp->pfAbort))
    {
        return 0;
    }

    // Bind to Object
    hr = OpenDSObject(pgltp->pszLDAPName, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        BSTR bstrLinkProp;
        VariantInit(&var);
        bstrLinkProp = SysAllocString(GPM_LINK_PROPERTY);

        if (bstrLinkProp)
        {
            // Now get the link property
            hr = pADs->Get(bstrLinkProp, &var);

            // Check if out GUID is in there.
            if (SUCCEEDED(hr) && StrStrI(var.bstrVal, lpGPO))
            {
                LV_ITEM lvi = {LVIF_TEXT};

                //
                // Check if this is a forest path
                //

                if (IsForest(pgltp->pszLDAPName))
                {
                    TCHAR szForest[50] = {0};

                    LoadString (g_hInstance, IDS_FOREST, szForest, ARRAYSIZE(szForest));
                    lvi.iItem = 0x7FFFFFFF;
                    lvi.pszText = szForest;
                    ListView_InsertItem(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), &lvi);
                }
                else
                {
                    LPTSTR pszTemp = MakeNamelessPath(pgltp->pszLDAPName);

                    if (pszTemp)
                    {
                        ULONG ulLen = wcslen(pszTemp) + 2;
                        LPOLESTR pszTranslated = new OLECHAR[ulLen];

                        if (pszTranslated)
                        {
                            // Move pointer over the lDAP:// string and insert the rest into the listview
                            pszTemp += wcslen(TEXT("LDAP://"));

                            lvi.iItem = 0x7FFFFFFF;
                            if (TranslateName(pszTemp, NameFullyQualifiedDN, NameCanonical, pszTranslated, &ulLen))
                            {
                                lvi.pszText = pszTranslated;
                                ListView_InsertItem(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), &lvi);
                            }
                            delete [] pszTranslated;
                        }

                        LocalFree (pszTemp);
                    }
                }
            }

            // Cleanup
            SysFreeString(bstrLinkProp);
        }
        VariantClear(&var);
        pADs->Release();
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("FindLinkInDomain: Failed to get IID_IADs. hr: 0x%x, for %s"),hr, pgltp->pszLDAPName));
        ReportError(pgltp->hDlg, hr, IDS_DSBINDFAILED);
        dwResult = 0;
        goto Exit;

    }


    // Check if the user wants to abort. Before proceeding
    if (*(pgltp->pfAbort))
    {
        dwResult = 0;
        goto Exit;
    }

    // Create Enumerator
    hr = OpenDSObject(pgltp->pszLDAPName, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("FindLinkInDomain: Failed to get gpo container interface with 0x%x for object %s"),
                 hr, pgltp->pszLDAPName));
        dwResult = 0;
        goto Exit;
    }

    hr = ADsBuildEnumerator (pADsContainer, &pVar);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("FindLinkInDomain: Failed to get enumerator with 0x%x"), hr));
        dwResult = 0;
        goto Exit;
    }

    //
    // Enumerate
    //
    while (TRUE)
    {
        TCHAR lpOU[] = TEXT("organizationalUnit");
        DWORD dwStrLen = lstrlen (lpOU);

        // Check if the user wants to abort. Before proceeding

        if (*(pgltp->pfAbort))
        {
            break;
        }

        VariantInit(&var);

        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }

        if ((FAILED(hr)) || (var.vt != VT_DISPATCH))
        {
            VariantClear (&var);
            break;
        }


        if (*(pgltp->pfAbort))
        {
            VariantClear (&var);
            break;
        }

        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            VariantClear (&var);
            dwResult = 0;
            goto Exit;
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this object
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            VariantClear (&var);
            dwResult = 0;
            goto Exit;
        }

        //
        // Get the relative and class names
        //

        hr = pADs->get_Class (&bstrClassName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get class name with 0x%x"), hr));
            pADs->Release();
            VariantClear (&var);
            dwResult = 0;
            goto Exit;
        }


        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           lpOU, dwStrLen, bstrClassName, dwStrLen) == CSTR_EQUAL)
        {
            VARIANT varName;
            BSTR bstrNameProp;

            VariantInit(&varName);
            bstrNameProp = SysAllocString(GPM_NAME_PROPERTY);

            if (bstrNameProp)
            {
                // Now get the Name property
                hr = pADs->Get(bstrNameProp, &varName);

                // Create the new LDAP:// string and call FindLinkInDomain() recursively
                if (SUCCEEDED(hr))
                {
                    GLTHREADPARAM  gltp = *pgltp;
                    IADsPathname * pADsPathname;
                    LPOLESTR pszNewName = new OLECHAR[wcslen(varName.bstrVal) + 10];
                    BSTR bstr;


                    //
                    // Build the new element name
                    //

                    if (!pszNewName)
                    {
                        dwResult = 0;
                        goto Exit;
                    }

                    wcscpy(pszNewName, TEXT("OU="));
                    wcscat(pszNewName, varName.bstrVal);


                    //
                    // Create a pathname object we can work with
                    //

                    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                          IID_IADsPathname, (LPVOID*)&pADsPathname);


                    if (FAILED(hr))
                    {
                        delete [] pszNewName;
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Set the current name
                    //

                    hr = pADsPathname->Set (pgltp->pszLDAPName, ADS_SETTYPE_FULL);

                    if (FAILED(hr))
                    {
                        delete [] pszNewName;
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Check for escape characters
                    //

                    hr = pADsPathname->GetEscapedElement (0, pszNewName, &bstr);

                    delete [] pszNewName;

                    if (FAILED(hr))
                    {
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Add the new element
                    //

                    hr = pADsPathname->AddLeafElement (bstr);

                    SysFreeString (bstr);

                    if (FAILED(hr))
                    {
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Get the new path
                    //

                    hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
                    pADsPathname->Release();

                    if (FAILED(hr))
                    {
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Recurse
                    //

                    gltp.pszLDAPName = bstr;
                    if (FindLinkInDomain(&gltp, lpGPO) == 0)
                    {
                        dwResult = 0;
                        goto Exit;
                    }

                    SysFreeString (bstr);

                }
                SysFreeString (bstrNameProp);
            }
            VariantClear (&varName);
        }

        pADs->Release();
        SysFreeString (bstrClassName);
    }

Exit:
    if (pADsContainer)
        pADsContainer->Release();

    return dwResult;
}

//////////////////////////////////////////////////////////////////////////////
// Fill the combobox with available domains
//////////////////////////////////////////////////////////////////////////////

BOOL CGroupPolicyObject::FillDomainList (HWND hWndCombo)
{
    HRESULT hr;
    DWORD dwIndex = 0;
    LPOLESTR pszDomain;
    LPTSTR lpTemp;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // get the ordered tree of domains
    LOOKDATA * pDomainList = BuildDomainList(NULL);
    LOOKDATA *pRemember = pDomainList;

    // now walk the tree, adding elements to the dialog box

    int nCBIndex;

    // start at the head
    while (pDomainList)
    {

        // add the LDAP path for the doman in this node
        //SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM)(LPCTSTR) pDomainList->szData);
        nCBIndex = (int)SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM)(LPCTSTR) pDomainList->szName);
        SendMessage(hWndCombo, CB_SETITEMDATA, (WPARAM) nCBIndex, (LPARAM)(LPCTSTR) pDomainList->szData);

        if (pDomainList->pChild)
        {
            // go to its child
            pDomainList = pDomainList->pChild;
        }
        else
        {
            if (pDomainList->pSibling)
            {
                // go to its sibling if there are no children
                pDomainList = pDomainList->pSibling;
            }
            else
            {
                // there are no children and no siblings
                // back up until we find a parent with a sibling
                // or there are no more parents (we're done)
                do
                {
                    pDomainList = pDomainList->pParent;
                    if (pDomainList)
                    {
                        if (pDomainList->pSibling)
                        {
                            pDomainList = pDomainList->pSibling;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                } while (TRUE);
            }
        }
    }

    FreeDomainInfo (pRemember);


    //
    // Select the current domain in the combobox
    //

    pszDomain = GetDomainFromLDAPPath(m_pDSPath);

    if (pszDomain)
    {

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpTemp);

        if (SUCCEEDED(hr))
        {
            dwIndex = (DWORD) SendMessage (hWndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1,
                                          (LONG_PTR)lpTemp);

            if (dwIndex == CB_ERR)
            {
                dwIndex = 0;
            }

            LocalFree (lpTemp);
        }

        delete [] pszDomain;
    }


    SendMessage (hWndCombo, CB_SETCURSEL, (WPARAM)dwIndex, 0);
    SetCursor(hcur);

    return TRUE;
}


INT_PTR CALLBACK CGroupPolicyObject::PropertiesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGroupPolicyObject * pGPO;
    static BOOL bDirty;
    static BOOL bDisableWarningIssued;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            DWORD dwTemp;
            LPTSTR lpEnd;
            TCHAR szBuffer[2*MAX_PATH];
            TCHAR szDate[100];
            TCHAR szTime[100];
            TCHAR szFormat[80];
            TCHAR szVersion[100];
            WIN32_FILE_ATTRIBUTE_DATA fad;
            FILETIME filetime, CreateTime, ChangeTime;
            SYSTEMTIME systime;
            LPTSTR lpResult;
            LPOLESTR pszDomain;
            ULONG ulVersion = 0;
            USHORT uMachine, uUser;
            VARIANT var;
            BSTR bstrName;
            LPTSTR lpDisplayName;
            WORD wDosDate, wDosTime;



            pGPO = (CGroupPolicyObject *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGPO);


            //
            // Initialize
            //

            if ((pGPO->m_pMachineName) && (pGPO->m_gpoType == GPOTypeDS))
            {
                lpDisplayName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pGPO->m_pDisplayName) +
                                                            lstrlen(pGPO->m_pMachineName) +
                                                            5) * sizeof(TCHAR));

                if (lpDisplayName)
                {
                    LoadString (g_hInstance, IDS_NAMEFORMAT, szFormat, ARRAYSIZE(szFormat));
                    wsprintf (lpDisplayName, szFormat, pGPO->m_pDisplayName, pGPO->m_pMachineName);

                    SetDlgItemText (hDlg, IDC_TITLE, lpDisplayName);
                    LocalFree (lpDisplayName);
                }
            }
            else
            {
                SetDlgItemText (hDlg, IDC_TITLE, pGPO->m_pDisplayName);
            }


            if (pGPO->m_gpoType == GPOTypeDS)
            {
                if (IsForest(pGPO->m_pDSPath))
                {
                    LoadString (g_hInstance, IDS_FORESTHEADING, szBuffer, ARRAYSIZE(szBuffer));
                    SetDlgItemText (hDlg, IDC_DOMAIN_HEADING, szBuffer);
                }

                pszDomain = GetDomainFromLDAPPath(pGPO->m_pDSPath);

                if (pszDomain)
                {
                    if (SUCCEEDED(ConvertToDotStyle (pszDomain, &lpResult)))
                    {
                        SetDlgItemText (hDlg, IDC_DOMAIN, lpResult);
                        LocalFree (lpResult);
                    }

                    delete [] pszDomain;
                }

                SetDlgItemText (hDlg, IDC_UNIQUE_NAME, pGPO->m_pName);
            }
            else
            {
                LoadString (g_hInstance, IDS_NOTAPPLICABLE, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText (hDlg, IDC_DOMAIN, szBuffer);
                SetDlgItemText (hDlg, IDC_UNIQUE_NAME, szBuffer);
            }


            if (SUCCEEDED(pGPO->GetOptions(&dwTemp)))
            {
                if (dwTemp & GPO_OPTION_DISABLE_MACHINE)
                {
                    CheckDlgButton (hDlg, IDC_DISABLE_COMPUTER, BST_CHECKED);
                }

                if (dwTemp & GPO_OPTION_DISABLE_USER)
                {
                    CheckDlgButton (hDlg, IDC_DISABLE_USER, BST_CHECKED);
                }
            }

            lstrcpy (szBuffer, pGPO->m_pFileSysPath);
            lpEnd = CheckSlash (szBuffer);
            lstrcpy (lpEnd, TEXT("gpt.ini"));

            if (pGPO->m_gpoType == GPOTypeDS)
            {
                VariantInit(&var);
                bstrName = SysAllocString (GPO_VERSION_PROPERTY);

                if (bstrName)
                {
                    if (SUCCEEDED(pGPO->m_pADs->Get(bstrName, &var)))
                    {
                        ulVersion = var.lVal;
                    }

                    SysFreeString (bstrName);
                }

                VariantClear (&var);
            }
            else
            {
                ulVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szBuffer);
            }

            uMachine = (USHORT) LOWORD(ulVersion);
            uUser = (USHORT) HIWORD(ulVersion);

            LoadString (g_hInstance, IDS_REVISIONFORMAT, szFormat, ARRAYSIZE(szFormat));
            wsprintf (szVersion, szFormat, uMachine, uUser);

            SetDlgItemText (hDlg, IDC_REVISION, szVersion);


            //
            // Get the date / time info
            //

            CreateTime.dwLowDateTime = 0;
            CreateTime.dwHighDateTime = 0;
            ChangeTime.dwLowDateTime = 0;
            ChangeTime.dwHighDateTime = 0;


            if (pGPO->m_gpoType == GPOTypeDS)
            {
                //
                // Get the creation time
                //

                VariantInit(&var);
                bstrName = SysAllocString (TEXT("whenCreated"));

                if (bstrName)
                {
                    if (SUCCEEDED(pGPO->m_pADs->Get(bstrName, &var)))
                    {
                        if (VariantTimeToDosDateTime (var.date, &wDosDate, &wDosTime))
                        {
                            DosDateTimeToFileTime (wDosDate, wDosTime, &CreateTime);
                        }
                    }

                    SysFreeString (bstrName);
                }

                VariantClear (&var);


                //
                // Get the last write time
                //

                VariantInit(&var);
                bstrName = SysAllocString (TEXT("whenChanged"));

                if (bstrName)
                {
                    if (SUCCEEDED(pGPO->m_pADs->Get(bstrName, &var)))
                    {
                        if (VariantTimeToDosDateTime (var.date, &wDosDate, &wDosTime))
                        {
                            DosDateTimeToFileTime (wDosDate, wDosTime, &ChangeTime);
                        }
                    }

                    SysFreeString (bstrName);
                }

                VariantClear (&var);
            }
            else
            {
                //
                // Get the time info from the gpt.ini file
                //

                if (GetFileAttributesEx (szBuffer, GetFileExInfoStandard, &fad))
                {

                    CreateTime.dwLowDateTime = fad.ftCreationTime.dwLowDateTime;
                    CreateTime.dwHighDateTime = fad.ftCreationTime.dwHighDateTime;

                    ChangeTime.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
                    ChangeTime.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
                }
            }



            //
            // Format & display the date / time information
            //

            FileTimeToLocalFileTime (&CreateTime, &filetime);
            FileTimeToSystemTime (&filetime, &systime);
            GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                           NULL, szDate, ARRAYSIZE (szDate));

            GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                           NULL, szTime, ARRAYSIZE (szTime));

            LoadString (g_hInstance, IDS_DATETIMEFORMAT, szFormat, ARRAYSIZE(szFormat));
            wsprintf (szBuffer, szFormat, szDate, szTime);
            SetDlgItemText (hDlg, IDC_CREATE_DATE, szBuffer);


            FileTimeToLocalFileTime (&ChangeTime, &filetime);
            FileTimeToSystemTime (&filetime, &systime);
            GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                           NULL, szDate, ARRAYSIZE (szDate));

            GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                           NULL, szTime, ARRAYSIZE (szTime));

            wsprintf (szBuffer, szFormat, szDate, szTime);
            SetDlgItemText (hDlg, IDC_MODIFIED_DATE, szBuffer);



            if (pGPO->m_dwFlags & GPO_OPEN_READ_ONLY)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_DISABLE_COMPUTER), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_DISABLE_USER), FALSE);
            }

            bDirty = FALSE;
            bDisableWarningIssued = FALSE;
            break;
        }

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                if ((LOWORD(wParam) == IDC_DISABLE_COMPUTER) ||
                    (LOWORD(wParam) == IDC_DISABLE_USER))
                {
                    if (!bDisableWarningIssued)
                    {
                        if (IsDlgButtonChecked (hDlg, LOWORD(wParam)) == BST_CHECKED)
                        {
                            TCHAR szMessage[200];
                            TCHAR szTitle[100];

                            bDisableWarningIssued = TRUE;

                            LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                            LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                            if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                        MB_ICONWARNING | MB_DEFBUTTON2) == IDNO) {

                                CheckDlgButton (hDlg, LOWORD(wParam), BST_UNCHECKED);
                                break;
                            }
                        }
                    }
                }

                if (!bDirty)
                {
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                    bDirty = TRUE;
                }
            }
            break;

        case WM_NOTIFY:

            pGPO = (CGroupPolicyObject *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPO) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    if (bDirty)
                    {
                        DWORD dwTemp = 0;
                        HRESULT hr;


                        //
                        // Set the disable flags in the GPO
                        //

                        if (IsDlgButtonChecked (hDlg, IDC_DISABLE_COMPUTER) == BST_CHECKED)
                        {
                            dwTemp |= GPO_OPTION_DISABLE_MACHINE;
                        }

                        if (IsDlgButtonChecked (hDlg, IDC_DISABLE_USER) == BST_CHECKED)
                        {
                            dwTemp |= GPO_OPTION_DISABLE_USER;
                        }

                        hr = pGPO->SetOptions (dwTemp, (GPO_OPTION_DISABLE_MACHINE | GPO_OPTION_DISABLE_USER));

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDPROPERTIES);
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                            return TRUE;
                        }

                        bDirty = FALSE;
                    }
                }
                // fall through...

                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aPropertiesHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aPropertiesHelpIds);
            return (TRUE);
    }

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyObjectCF::CGroupPolicyObjectCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CGroupPolicyObjectCF::~CGroupPolicyObjectCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CGroupPolicyObjectCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CGroupPolicyObjectCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CGroupPolicyObjectCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CGroupPolicyObjectCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CGroupPolicyObject *pGroupPolicyObject = new CGroupPolicyObject(); // ref count == 1

    if (!pGroupPolicyObject)
        return E_OUTOFMEMORY;

    HRESULT hr = pGroupPolicyObject->QueryInterface(riid, ppvObj);
    pGroupPolicyObject->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CGroupPolicyObjectCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


//*************************************************************
//
//  CGroupPolicyObject::GetProperty
//
//  Purpose:    Retrieves a property from DS or from gpt.ini
//
//  Parameters: pszProp   - Property to get
//              xValueIn  - Value returned here
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT  CGroupPolicyObject::GetProperty( TCHAR *pszProp, XPtrST<TCHAR>& xValueIn )
{
    HRESULT hr = E_FAIL;

    if ( m_gpoType == GPOTypeDS )
    {
        VARIANT var;
        BSTR bstrProperty;

        VariantInit( &var );
        bstrProperty = SysAllocString( pszProp );

        if ( bstrProperty == NULL )
            return E_OUTOFMEMORY;

        hr = m_pADs->Get( bstrProperty, &var );

        if ( SUCCEEDED(hr) )
        {
            TCHAR *pszValue = new TCHAR[lstrlen(var.bstrVal) + 1];
            if ( pszValue == 0 )
                hr = E_OUTOFMEMORY;
            else
            {
                lstrcpy( pszValue, var.bstrVal );
                xValueIn.Set( pszValue );

                hr = S_OK;
            }
        } else if ( hr == E_ADS_PROPERTY_NOT_FOUND )
        {
            //
            // Property has not be written out before
            //

            hr = S_OK;
        }

        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetProperty: Failed with errorcode 0x%x"), hr));
        }

        SysFreeString( bstrProperty );
        VariantClear( &var );

        return hr;
    }
    else
    {
        TCHAR szPath[2*MAX_PATH];

        //
        // Get the file system path
        //

        hr = GetPath (szPath, ARRAYSIZE(szPath));
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetProperty: Failed with errorcode 0x%x"), hr));
        }

        LPTSTR lpEnd = CheckSlash (szPath);
        lstrcpy (lpEnd, TEXT("GPT.INI"));

        XPtrST<TCHAR> xszValue( new TCHAR[2*MAX_PATH] );
        if ( xszValue.GetPointer() == NULL )
            return E_OUTOFMEMORY;

        DWORD dwSize = (2*MAX_PATH);
        DWORD dwCount = GetPrivateProfileString( TEXT("General"),
                                                 pszProp,
                                                 TEXT(""),
                                                 xszValue.GetPointer(),
                                                 dwSize,
                                                 szPath );
        while ( dwCount == dwSize - 1 )
        {
            //
            // Value has been truncated, so retry with larger buffer
            //

            dwSize *= 2;
            delete xszValue.Acquire();
            xszValue.Set( new TCHAR[dwSize] );

            if ( xszValue.GetPointer() == NULL )
                return E_OUTOFMEMORY;

            dwCount = GetPrivateProfileString( TEXT("General"),
                                               pszProp,
                                               TEXT(""),
                                               xszValue.GetPointer(),
                                               dwSize,
                                               szPath );
        }

        xValueIn.Set( xszValue.Acquire() );

        return S_OK;
    }
}


//*************************************************************
//
//  CGroupPolicyObject::SetProperty
//
//  Purpose:    Writes a property to DS or to gpt.ini
//
//  Parameters: pszProp      - Property to set
//              pszPropValue - Property value
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT  CGroupPolicyObject::SetProperty( TCHAR *pszProp, TCHAR *pszPropValue )
{
    HRESULT hr = E_FAIL;

    if ( m_gpoType == GPOTypeDS )
    {
        VARIANT var;

        VariantInit( &var );

        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString( pszPropValue );
        if ( var.bstrVal == 0 )
            return E_OUTOFMEMORY;

        BSTR bstrProperty = SysAllocString( pszProp );
        if ( bstrProperty == 0 )
        {
            VariantClear( &var );
            return E_OUTOFMEMORY;
        }

        hr = m_pADs->Put( bstrProperty, var );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetProperty: Failed with errorcode 0x%x"), hr));
            return hr;
        }

        SysFreeString( bstrProperty );
        VariantClear( &var );

        return S_OK;
    }
    else
    {
        TCHAR szPath[2*MAX_PATH];

        //
        // Get the file system path
        //

        hr = GetPath (szPath, ARRAYSIZE(szPath));
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetProperty: Failed with errorcode 0x%x"), hr));
        }

        LPTSTR lpEnd = CheckSlash (szPath);
        lstrcpy (lpEnd, TEXT("GPT.INI"));

        BOOL bOk  = WritePrivateProfileString( TEXT("General"),
                                               pszProp,
                                               pszPropValue,
                                               szPath );
        if ( bOk )
            hr = S_OK;
        else
            hr = GetLastError();

        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\events.cpp ===
//*************************************************************
//  File name: Events.CPP
//
//  Description:  Event log entries for RSOP
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//*************************************************************
#include "main.h"
#include "rsoputil.h"

EVENTLOGENTRY   ExceptionEventEntries[] = 
                {
                    {1036, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1037, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1038, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1039, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1040, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1041, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL},
                    {1085, {0}, TEXT("Application"), TEXT("userenv"), NULL, NULL}
            };

DWORD           dwExceptionEventEntriesSize = 7;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CEvents implementation                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

                     
                     
CEvents::CEvents(void)
{
    InterlockedIncrement(&g_cRefThisDll);

    m_pEventEntries = NULL;
}

CEvents::~CEvents()
{
    if (m_pEventEntries)
    {
        FreeData (m_pEventEntries);
    }

    InterlockedDecrement(&g_cRefThisDll);
}

BOOL CEvents::AddEntry(LPTSTR lpEventLogName, LPTSTR lpEventSourceName, LPTSTR lpText,
                       DWORD dwEventID, FILETIME *ftTime)
{
    DWORD dwSize;
    LPEVENTLOGENTRY lpItem, lpTemp, pPrev;


    //
    // Check if this entry exists already
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        if (dwEventID == lpTemp->dwEventID)
        {
            if (!lstrcmpi(lpEventLogName, lpTemp->lpEventLogName))
            {
                if (!lstrcmpi(lpEventSourceName, lpTemp->lpEventSourceName))
                {
                    if (ftTime->dwLowDateTime == lpTemp->ftEventTime.dwLowDateTime)
                    {
                        if (ftTime->dwHighDateTime == lpTemp->ftEventTime.dwHighDateTime)
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (EVENTLOGENTRY);

    dwSize += ((lstrlen(lpEventLogName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpEventSourceName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpText) + 1) * sizeof(TCHAR));


    //
    // Allocate space for it
    //

    lpItem = (LPEVENTLOGENTRY) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CEvents::AddEntry: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    lpItem->lpEventLogName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(EVENTLOGENTRY));
    lstrcpy (lpItem->lpEventLogName, lpEventLogName);

    lpItem->lpEventSourceName = lpItem->lpEventLogName + lstrlen (lpItem->lpEventLogName) + 1;
    lstrcpy (lpItem->lpEventSourceName, lpEventSourceName);

    lpItem->lpText = lpItem->lpEventSourceName + lstrlen (lpItem->lpEventSourceName) + 1;
    lstrcpy (lpItem->lpText, lpText);

    lpItem->dwEventID = dwEventID;

    CopyMemory ((LPBYTE)&lpItem->ftEventTime, ftTime, sizeof(FILETIME));


    //
    // Add item to the link list
    //

    if (m_pEventEntries)
    {

        if (CompareFileTime(ftTime, &m_pEventEntries->ftEventTime) < 0)
        {
            lpItem->pNext = m_pEventEntries;
            m_pEventEntries = lpItem;
        }
        else
        {
            pPrev = m_pEventEntries;
            lpTemp = m_pEventEntries->pNext;

            while (lpTemp)
            {
                if (lpTemp->pNext)
                {
                    if ((CompareFileTime(ftTime, &lpTemp->ftEventTime) >= 0) &&
                        (CompareFileTime(ftTime, &lpTemp->pNext->ftEventTime) <= 0))
                    {
                        lpItem->pNext = lpTemp->pNext;
                        lpTemp->pNext = lpItem;
                        break;
                    }
                }

                pPrev = lpTemp;
                lpTemp = lpTemp->pNext;
            }

            if (!lpTemp)
            {
                pPrev->pNext = lpItem;
            }
        }
    }
    else
    {
        m_pEventEntries = lpItem;
    }

    return TRUE;
}

VOID CEvents::FreeData(LPEVENTLOGENTRY lpList)
{
    LPEVENTLOGENTRY lpTemp;


    do {
        lpTemp = lpList->pNext;
        LocalFree (lpList);
        lpList = lpTemp;

    } while (lpTemp);
}


STDMETHODIMP CEvents::SecondsSince1970ToFileTime(DWORD dwSecondsSince1970,
                                                 FILETIME *pftTime)
{
    //  Seconds since the start of 1970 -> 64 bit Time value

    LARGE_INTEGER liTime;

    RtlSecondsSince1970ToTime(dwSecondsSince1970, &liTime);

    //
    //  The time is in UTC
    //

    pftTime->dwLowDateTime  = liTime.LowPart;
    pftTime->dwHighDateTime = liTime.HighPart;

    return S_OK;
}

LPTSTR * CEvents::BuildStringArray(LPTSTR lpStrings, DWORD *dwStringCount)
{
    DWORD dwCount = 0;
    LPTSTR lpTemp, *lpResult;


    if (!lpStrings || !(*lpStrings))
    {
        return NULL;
    }


    //
    // Find out how many strings there are
    //

    lpTemp = lpStrings;

    while (*lpTemp)
    {
        dwCount++;
        lpTemp = lpTemp + lstrlen(lpTemp) + 1;
    }

    *dwStringCount = dwCount;


    //
    // Allocate a new array to hold the pointers
    //

    lpResult = (LPTSTR *) LocalAlloc (LPTR, dwCount * sizeof(LPTSTR));

    if (!lpResult)
    {
        return NULL;
    }


    //
    // Save the pointers
    //

    lpTemp = lpStrings;
    dwCount = 0;

    while (*lpTemp)
    {
        lpResult[dwCount] = lpTemp;
        dwCount++;
        lpTemp = lpTemp + lstrlen(lpTemp) + 1;
    }


    return lpResult;
}

LPTSTR CEvents::BuildMessage(LPTSTR lpMsg, LPTSTR *lpStrings, DWORD dwStringCount,
                             HMODULE hParamFile)
{
    LPTSTR lpFullMsg = NULL;
    LPTSTR lpSrcIndex;
    LPTSTR lpTemp, lpNum;
    TCHAR cChar, cTemp;
    TCHAR cCharStr[2] = {0,0};
    DWORD dwCharCount = 1, dwTemp;
    BOOL bAdd;
    TCHAR szNumStr[10];
    DWORD dwIndex;
    LPTSTR lpParamMsg;

    if ( !lpMsg || (dwStringCount && !lpStrings) )
    {
        return 0;
    }

    lpFullMsg = (LPTSTR) LocalAlloc (LPTR, dwCharCount * sizeof(TCHAR));

    if (!lpFullMsg)
    {
        return NULL;
    }


    lpSrcIndex = lpMsg;

    while (*lpSrcIndex)
    {
        bAdd = TRUE;
        cChar = *lpSrcIndex;


        if (cChar == TEXT('%'))
        {
            cTemp = *(lpSrcIndex + 1);

            if (ISDIGIT (cTemp))
            {

                if (dwStringCount == 0)
                {
                    goto LoopAgain;
                }

                //
                // Found a replaceable parameter from the passed in strings
                //

                lpNum = lpSrcIndex + 1;


                //
                // Pull the string index off
                //

                ZeroMemory (szNumStr, sizeof(szNumStr));

                while (ISDIGIT(*lpNum))
                {
                    cCharStr[0] = *lpNum;
                    lstrcat (szNumStr, cCharStr);

                    if (lstrlen (szNumStr) == (ARRAYSIZE(szNumStr) - 2))
                    {
                        goto LoopAgain;
                    }

                    lpNum++;
                }

                //
                // Convert the string index to a dword
                //

                dwIndex = 0;
                StringToNum(szNumStr, (UINT *)&dwIndex);


                //
                // Subtrack 1 to make it zero based
                //

                if (dwIndex)
                {
                    dwIndex--;
                }

                if (dwIndex > dwStringCount)
                {
                    goto LoopAgain;
                }


                //
                // Add the string to the buffer
                //

                dwTemp = lstrlen (lpStrings[dwIndex]) + dwCharCount;
                lpTemp = (LPTSTR) LocalReAlloc (lpFullMsg,  dwTemp * sizeof(TCHAR),
                                                LMEM_MOVEABLE | LMEM_ZEROINIT);

                if (!lpTemp)
                {
                    LocalFree (lpFullMsg);
                    lpFullMsg = NULL;
                    goto Exit;
                }

                dwCharCount = dwTemp;
                lpFullMsg = lpTemp;

                lstrcat (lpFullMsg, lpStrings[dwIndex]);

                lpSrcIndex = lpNum - 1;

                bAdd = FALSE;
            }
            else if (cTemp == TEXT('%'))
            {

                cTemp = *(lpSrcIndex + 2);

                if (cTemp == TEXT('%'))
                {
                    //
                    // Found a replacable parameter from the parameter file
                    //

                    lpNum = lpSrcIndex + 3;


                    //
                    // Pull the string index off
                    //

                    ZeroMemory (szNumStr, sizeof(szNumStr));

                    while (ISDIGIT(*lpNum))
                    {
                        cCharStr[0] = *lpNum;
                        lstrcat (szNumStr, cCharStr);

                        if (lstrlen (szNumStr) == (ARRAYSIZE(szNumStr) - 2))
                        {
                            goto LoopAgain;
                        }

                        lpNum++;
                    }


                    //
                    // Convert the string index to a dword
                    //

                    dwIndex = 0;
                    StringToNum(szNumStr, (UINT *)&dwIndex);


                    //
                    // Subtrack 1 to make it zero based
                    //

                    if (dwIndex)
                    {
                        dwIndex--;
                    }

                    if (dwIndex > dwStringCount)
                    {
                        goto LoopAgain;
                    }


                    //
                    // Convert the string number to a dword
                    //

                    StringToNum(lpStrings[dwIndex], (UINT *)&dwIndex);


                    lpParamMsg = NULL;
                    if (hParamFile)
                    {
                        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE |
                                       FORMAT_MESSAGE_IGNORE_INSERTS, (LPCVOID) hParamFile,
                                       dwIndex, 0, (LPTSTR)&lpParamMsg, 1, NULL);
                    }
                    else
                    {
                        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                                       FORMAT_MESSAGE_IGNORE_INSERTS, NULL,
                                       dwIndex, 0, (LPTSTR)&lpParamMsg, 1, NULL);
                    }

                    if (lpParamMsg)
                    {

                        lpTemp = lpParamMsg + lstrlen(lpParamMsg) - 2;

                        *lpTemp = TEXT('\0');

                        //
                        // Add the string to the buffer
                        //

                        dwTemp = lstrlen (lpParamMsg) + dwCharCount;
                        lpTemp = (LPTSTR) LocalReAlloc (lpFullMsg,  dwTemp * sizeof(TCHAR),
                                                        LMEM_MOVEABLE | LMEM_ZEROINIT);

                        if (!lpTemp)
                        {
                            LocalFree (lpFullMsg);
                            lpFullMsg = NULL;
                            goto Exit;
                        }

                        dwCharCount = dwTemp;
                        lpFullMsg = lpTemp;

                        lstrcat (lpFullMsg, lpParamMsg);

                        lpSrcIndex = lpNum - 1;

                        bAdd = FALSE;

                        LocalFree (lpParamMsg);
                    }
                }
            }
        }


LoopAgain:

        if (bAdd)
        {
            //
            // Add this character to the buffer
            //

            dwCharCount++;
            lpTemp = (LPTSTR) LocalReAlloc (lpFullMsg,  dwCharCount * sizeof(TCHAR),
                                            LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (!lpTemp)
            {
                LocalFree (lpFullMsg);
                lpFullMsg = NULL;
                goto Exit;
            }

            lpFullMsg = lpTemp;

            cCharStr[0] = cChar;
            lstrcat (lpFullMsg, cCharStr);
        }

        lpSrcIndex++;
    }

Exit:

    return lpFullMsg;
}

STDMETHODIMP CEvents::SaveEventLogEntry (PEVENTLOGRECORD pEntry,
                                         LPTSTR lpEventLogName,
                                         LPTSTR lpEventSourceName,
                                         FILETIME *ftEntry)
{
    LPTSTR lpRegKey = NULL;
    HKEY hKey = NULL;
    TCHAR szEventFile[MAX_PATH];
    TCHAR szExpEventFile[MAX_PATH];
    TCHAR szParamFile[MAX_PATH] = {0};
    TCHAR szExpParamFile[MAX_PATH] = {0};
    HRESULT hr = S_OK;
    DWORD dwType, dwSize;
    HMODULE hEventFile = NULL;
    HMODULE hParamFile = NULL;
    LPTSTR lpMsg, *lpStrings, lpFullMsg;
    LPBYTE lpData;
    DWORD dwStringCount;


    lpRegKey = new TCHAR [(lstrlen(lpEventLogName) + lstrlen(lpEventSourceName) + 60)];

    if (!lpRegKey)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to alloc memory for key name")));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    wsprintf (lpRegKey, TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\%s\\%s"), lpEventLogName, lpEventSourceName);

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, lpRegKey, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to open reg key for %s"), lpRegKey));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }


    dwSize = sizeof(szEventFile);
    if (RegQueryValueEx (hKey, TEXT("EventMessageFile"), NULL, &dwType, (LPBYTE) szEventFile,
                     &dwSize) != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to query dll pathname for %s"), lpRegKey));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }


    ExpandEnvironmentStrings (szEventFile, szExpEventFile, ARRAYSIZE(szExpEventFile));


    dwSize = sizeof(szParamFile);
    if (RegQueryValueEx (hKey, TEXT("ParameterMessageFile"), NULL, &dwType, (LPBYTE) szParamFile,
                     &dwSize) == ERROR_SUCCESS)
    {
        ExpandEnvironmentStrings (szParamFile, szExpParamFile, ARRAYSIZE(szExpParamFile));
    }


    hEventFile = LoadLibraryEx (szExpEventFile, NULL, LOAD_LIBRARY_AS_DATAFILE);

    if (!hEventFile)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEventLogEntry: Failed to loadlibrary dll %s with %d"), szExpEventFile, GetLastError()));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }


    if (szExpParamFile[0] != TEXT('\0'))
    {
        if (!StrStrI(szExpParamFile, TEXT("kernel32")))
        {
            hParamFile = LoadLibraryEx (szExpParamFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
        }
    }


    lpData = (LPBYTE)((LPBYTE)pEntry + pEntry->StringOffset);
    lpStrings = BuildStringArray((LPTSTR) lpData, &dwStringCount);
    lpMsg = NULL;

    if (FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_IGNORE_INSERTS, (LPCVOID) hEventFile,
                       pEntry->EventID, 0, (LPTSTR)&lpMsg, 1, NULL))
    {
        lpFullMsg = BuildMessage(lpMsg, lpStrings, dwStringCount, hParamFile);

        if (lpFullMsg)
        {
            AddEntry(lpEventLogName, lpEventSourceName, lpFullMsg, pEntry->EventID, ftEntry);
            LocalFree (lpFullMsg);
        }

        LocalFree (lpMsg);
    }

    if (lpStrings)
    {
        LocalFree (lpStrings);
    }

Exit:

    if (hEventFile)
    {
        FreeLibrary (hEventFile);
    }

    if (hParamFile)
    {
        FreeLibrary (hParamFile);
    }

    if (hKey)
    {
        RegCloseKey (hKey);
    }

    if (lpRegKey)
    {
        delete [] lpRegKey;
    }

    return S_OK;
}


STDMETHODIMP CEvents::ParseEventLogRecords (PEVENTLOGRECORD lpEntries,
                                            DWORD dwEntriesSize,
                                            LPTSTR lpEventLogName,
                                            LPTSTR lpEventSourceName,
                                            DWORD dwEventID,
                                            FILETIME * pBeginTime,
                                            FILETIME * pEndTime)
{
    PEVENTLOGRECORD pEntry = lpEntries;
    FILETIME ftEntry;
    LONG lResult;
    LPTSTR lpSource;
    TCHAR szCurrentTime[100];
    DWORD dwTotal = 0;


    while (dwTotal < dwEntriesSize)
    {
        if (pEntry->EventType != EVENTLOG_INFORMATION_TYPE)
        {
            SecondsSince1970ToFileTime (pEntry->TimeWritten, &ftEntry);

            lpSource = (LPTSTR)(((LPBYTE)pEntry) + sizeof(EVENTLOGRECORD));

//          DebugMsg((DM_VERBOSE, TEXT("CEvents::ParseEventLogRecords: Found %s at %s"),
//                    lpSource, ConvertTimeToDisplayTime (NULL, &ftEntry, szCurrentTime)));

            if ((CompareFileTime (&ftEntry, pBeginTime) >= 0) &&
                (CompareFileTime (&ftEntry, pEndTime) <= 0))
            {
                if (!lstrcmpi(lpSource, lpEventSourceName))
                {
                    //
                    // The dwEventID parameter is optional.  If it is non-zero, then
                    // we're looking for a specific event message.  If it is zero,
                    // consider the id to be a wildcard and grab all the events that
                    // the remaining criteria.
                    //

                    if (dwEventID)
                    {
                        if (dwEventID == pEntry->EventID)
                        {
                            SaveEventLogEntry (pEntry, lpEventLogName, lpEventSourceName, &ftEntry);
                        }
                    }
                    else
                    {
                        SaveEventLogEntry (pEntry, lpEventLogName, lpEventSourceName, &ftEntry);
                    }
                }
            }
        }

        dwTotal += pEntry->Length;
        pEntry = (PEVENTLOGRECORD)(((LPBYTE)pEntry) + pEntry->Length);
    }

    return S_OK;
}

STDMETHODIMP CEvents::QueryForEventLogEntries (LPTSTR lpComputerName,
                                               LPTSTR lpEventLogName,
                                               LPTSTR lpEventSourceName,
                                               DWORD  dwEventID,
                                               SYSTEMTIME * pBeginTime,
                                               SYSTEMTIME * pEndTime)
{
    LPTSTR lpServerName, lpTemp = lpComputerName;
    HANDLE hLog;
    ULONG ulSize;
    TCHAR szBuffer[300];
    LPBYTE lpEntries;
    DWORD  dwEntriesBufferSize = 4096;
    DWORD dwBytesRead, dwBytesNeeded;
    FILETIME ftBeginTime, ftEndTime;
    TCHAR szBeginTime[100];
    TCHAR szEndTime[100];


    DebugMsg((DM_VERBOSE, TEXT("CEvents::QueryForEventLogEntries: Entering for %s,%s between %s and %s"),
              lpEventLogName, lpEventSourceName,
              ConvertTimeToDisplayTime (pBeginTime, NULL, szBeginTime),
              ConvertTimeToDisplayTime (pEndTime, NULL, szEndTime)));

    //
    // Check if this is the local machine
    //

    if (!lstrcmpi(lpComputerName, TEXT(".")))
    {
        ulSize = ARRAYSIZE(szBuffer);
        if ( !GetComputerNameEx (ComputerNameNetBIOS, szBuffer, &ulSize) )
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: GetComputerNameEx() failed.")));
            return HRESULT_FROM_WIN32(GetLastError());
        }
        
        lpTemp = szBuffer;
    }

    lpServerName = new TCHAR [lstrlen(lpTemp) + 3];

    if (!lpServerName)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to alloc memory for server name")));
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpy (lpServerName, TEXT("\\\\"));
    lstrcat (lpServerName, lpTemp);


    //
    // Open the event log
    //

    hLog = OpenEventLog (lpServerName, lpEventLogName);

    if (!hLog)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to open event log on %s with %d"),
                  lpServerName, GetLastError()));
    }
    
    delete [] lpServerName;

    if (!hLog)
        return HRESULT_FROM_WIN32(GetLastError());

    //
    // Allocate a buffer to read the entries into
    //

    lpEntries = (LPBYTE) LocalAlloc (LPTR, dwEntriesBufferSize);

    if (!lpEntries)
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to alloc memory for server name")));
        CloseEventLog (hLog);
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    SystemTimeToFileTime (pBeginTime, &ftBeginTime);
    SystemTimeToFileTime (pEndTime, &ftEndTime);

    while (TRUE)
    {
        ZeroMemory (lpEntries, dwEntriesBufferSize);

        if (ReadEventLog (hLog, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ, 0, lpEntries, dwEntriesBufferSize,
                           &dwBytesRead, &dwBytesNeeded))
        {
            ParseEventLogRecords ((PEVENTLOGRECORD) lpEntries, dwBytesRead, lpEventLogName, lpEventSourceName, dwEventID, &ftBeginTime, &ftEndTime);
        }
        else
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                dwEntriesBufferSize = dwBytesNeeded;

                LocalFree (lpEntries);

                lpEntries = (LPBYTE) LocalAlloc (LPTR, dwEntriesBufferSize);

                if (!lpEntries)
                {
                    DebugMsg((DM_WARNING, TEXT("CEvents::QueryForEventLogEntries: Failed to alloc memory")));
                    CloseEventLog (hLog);
                    return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
            else
            {
                break;
            }
        }
    }


    LocalFree (lpEntries);

    CloseEventLog (hLog);

    DebugMsg((DM_VERBOSE, TEXT("CEvents::QueryForEventLogEntries: Leaving ===")));

    return S_OK;
}

STDMETHODIMP CEvents::GetEventLogEntryText (LPOLESTR pszEventSource,
                                            LPOLESTR pszEventLogName,
                                            LPOLESTR pszEventTime,
                                            DWORD dwEventID,
                                            LPOLESTR *ppszText)
{
    XBStr xbstrWbemTime = pszEventTime;
    SYSTEMTIME EventTime;
    FILETIME ftLower, ftUpper;
    ULARGE_INTEGER ulTime;
    LPEVENTLOGENTRY lpTemp;
    LPOLESTR lpMsg = NULL, lpTempMsg;
    ULONG ulSize;
    TCHAR szLowerTime[100];
    TCHAR szUpperTime[100];



    if (!ppszText)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }


    WbemTimeToSystemTime(xbstrWbemTime, EventTime);


    //
    // Subtrack 1 second to EventTime to get the lower end of the range
    //

    SystemTimeToFileTime (&EventTime, &ftLower);


    ulTime.LowPart = ftLower.dwLowDateTime;
    ulTime.HighPart = ftLower.dwHighDateTime;

    ulTime.QuadPart = ulTime.QuadPart - (10000000 * 1);  // 1 second

    ftLower.dwLowDateTime = ulTime.LowPart;
    ftLower.dwHighDateTime = ulTime.HighPart;


    //
    // Add 2 seconds to determine the upper bounds
    //

    ulTime.QuadPart = ulTime.QuadPart + (10000000 * 2);  // 2 second

    ftUpper.dwLowDateTime = ulTime.LowPart;
    ftUpper.dwHighDateTime = ulTime.HighPart;


    DebugMsg((DM_VERBOSE, TEXT("CEvents::GetEventLogEntryText: Entering for %s,%s,%d between %s and %s"),
              pszEventLogName, pszEventSource, dwEventID,
              ConvertTimeToDisplayTime (NULL, &ftLower, szLowerTime),
              ConvertTimeToDisplayTime (NULL, &ftUpper, szUpperTime)));


    //
    // Loop through the entries looking for matches
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        if (lpTemp->dwEventID == dwEventID)
        {
            if (!lstrcmpi(lpTemp->lpEventLogName, pszEventLogName))
            {
                if (!lstrcmpi(lpTemp->lpEventSourceName, pszEventSource))
                {
                    if ((CompareFileTime (&lpTemp->ftEventTime, &ftLower) >= 0) &&
                        (CompareFileTime (&lpTemp->ftEventTime, &ftUpper) <= 0))
                    {
                        if (lpMsg)
                        {
                            ulSize = lstrlen(lpMsg);
                            ulSize += lstrlen(lpTemp->lpText) + 3;

                            lpTempMsg = (LPOLESTR) CoTaskMemRealloc (lpMsg, ulSize * sizeof(TCHAR));

                            if (!lpTempMsg)
                            {
                                CoTaskMemFree (lpMsg);
                                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                            }

                            lpMsg = lpTempMsg;

                            lstrcat (lpMsg, TEXT("\r\n"));
                            lstrcat (lpMsg, lpTemp->lpText);
                        }
                        else
                        {
                            lpMsg = (LPOLESTR) CoTaskMemAlloc ((lstrlen(lpTemp->lpText) + 1) * sizeof(TCHAR));

                            if (!lpMsg)
                            {
                                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                            }

                            lstrcpy (lpMsg, lpTemp->lpText);
                        }
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    if (!lpMsg)
    {
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    *ppszText = lpMsg;

    return S_OK;
}

BOOL CEvents::IsEntryInEventSourceList (LPEVENTLOGENTRY lpEntry, LPSOURCEENTRY lpEventSources)
{
    LPSOURCEENTRY lpTemp;


    if (!lpEventSources)
    {
        return FALSE;
    }

    lpTemp = lpEventSources;

    while (lpTemp)
    {
        if (!lstrcmpi(lpTemp->lpEventLogName, lpEntry->lpEventLogName))
        {
            if (!lstrcmpi(lpTemp->lpEventSourceName, lpEntry->lpEventSourceName))
            {
                return TRUE;
            }
        }

        lpTemp = lpTemp->pNext;
    }

    return FALSE;
}

BOOL CEvents::IsEntryInExceptionList (LPEVENTLOGENTRY lpEntry)
{
    LPEVENTLOGENTRY lpTemp;
    DWORD           i;

    for (i = 0; i < dwExceptionEventEntriesSize; i++) {
        lpTemp = ExceptionEventEntries+i;
        if (!lstrcmpi(lpTemp->lpEventLogName, lpEntry->lpEventLogName))
        {
            if (!lstrcmpi(lpTemp->lpEventSourceName, lpEntry->lpEventSourceName))
            {
                if (LOWORD(lpTemp->dwEventID) == LOWORD(lpEntry->dwEventID)) {
                    DebugMsg((DM_VERBOSE, TEXT("Skipping event id")));
                    DebugMsg((DM_VERBOSE, TEXT("Event Log:    %s"), lpEntry->lpEventLogName));
                    DebugMsg((DM_VERBOSE, TEXT("Event Source: %s"), lpEntry->lpEventSourceName));
                    DebugMsg((DM_VERBOSE, TEXT("Event ID:     %d"), LOWORD(lpEntry->dwEventID)));

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

STDMETHODIMP CEvents::GetCSEEntries(SYSTEMTIME * pBeginTime, SYSTEMTIME * pEndTime,
                                    LPSOURCEENTRY lpEventSources, LPOLESTR *ppszText, 
                                    BOOL bGPCore)
{
    LPEVENTLOGENTRY lpTemp;
    FILETIME ftBeginTime, ftEndTime;
    LPOLESTR lpMsg = NULL, lpTempMsg;
    ULONG ulSize;


    SystemTimeToFileTime (pBeginTime, &ftBeginTime);
    SystemTimeToFileTime (pEndTime, &ftEndTime);


    //
    // Loop through the entries looking for matches
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        if ((CompareFileTime (&lpTemp->ftEventTime, &ftBeginTime) >= 0) &&
            (CompareFileTime (&lpTemp->ftEventTime, &ftEndTime) <= 0))
        {
            if (IsEntryInEventSourceList (lpTemp, lpEventSources))
            {
                if ((bGPCore) || (!IsEntryInExceptionList(lpTemp))) {
                    if (lpMsg)
                    {
                        ulSize = lstrlen(lpMsg);
                        ulSize += lstrlen(lpTemp->lpText) + 3;

                        lpTempMsg = (LPOLESTR) CoTaskMemRealloc (lpMsg, ulSize * sizeof(TCHAR));

                        if (!lpTempMsg)
                        {
                            CoTaskMemFree (lpMsg);
                            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        }

                        lpMsg = lpTempMsg;

                        lstrcat (lpMsg, TEXT("\r\n"));
                        lstrcat (lpMsg, lpTemp->lpText);
                    }
                    else
                    {
                        lpMsg = (LPOLESTR) CoTaskMemAlloc ((lstrlen(lpTemp->lpText) + 1) * sizeof(TCHAR));

                        if (!lpMsg)
                        {
                            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        }

                        lstrcpy (lpMsg, lpTemp->lpText);
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }

    if (!lpMsg)
    {
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    *ppszText = lpMsg;

    return S_OK;
}

STDMETHODIMP CEvents::DumpDebugInfo (void)
{
    LPEVENTLOGENTRY lpTemp;
    FILETIME ftLocal;
    SYSTEMTIME systime;
    TCHAR szDateTime[100];


    lpTemp = m_pEventEntries;

    if (lpTemp)
    {
        DebugMsg((DM_VERBOSE, TEXT(" ")));
        DebugMsg((DM_VERBOSE, TEXT("Event log entries:")));
    }

    while (lpTemp)
    {
        ConvertTimeToDisplayTime (NULL, &lpTemp->ftEventTime, szDateTime);

        DebugMsg((DM_VERBOSE, TEXT(" ")));
        DebugMsg((DM_VERBOSE, TEXT("Event Time:   %s"), szDateTime));
        DebugMsg((DM_VERBOSE, TEXT("Event Log:    %s"), lpTemp->lpEventLogName));
        DebugMsg((DM_VERBOSE, TEXT("Event Source: %s"), lpTemp->lpEventSourceName));
        DebugMsg((DM_VERBOSE, TEXT("Event ID:     %d"), LOWORD(lpTemp->dwEventID)));
        DebugMsg((DM_VERBOSE, TEXT("Message:      %s"), lpTemp->lpText));

        lpTemp = lpTemp->pNext;
    }


    return S_OK;
}

LPTSTR CEvents::ConvertTimeToDisplayTime (SYSTEMTIME *pSysTime, FILETIME *pFileTime, LPTSTR szBuffer)
{
    FILETIME ftTime, ftLocal;
    SYSTEMTIME systime;


    if (pSysTime)
    {
        SystemTimeToFileTime (pSysTime, &ftTime);
    }
    else
    {
        CopyMemory (&ftTime, pFileTime, sizeof(FILETIME));
    }

    FileTimeToLocalFileTime (&ftTime, &ftLocal);

    FileTimeToSystemTime (&ftLocal, &systime);

    wsprintf (szBuffer, TEXT("%d/%d/%d  %02d:%02d:%02d:%03d"), systime.wMonth, systime.wDay, systime.wYear,
              systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds);

    return szBuffer;
}

STDMETHODIMP CEvents::AddSourceEntry (LPTSTR lpEventLogName,
                                      LPTSTR lpEventSourceName,
                                      LPSOURCEENTRY *lpList)
{
    LPSOURCEENTRY lpItem;
    DWORD dwSize;


    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (SOURCEENTRY);

    dwSize += ((lstrlen(lpEventLogName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpEventSourceName) + 1) * sizeof(TCHAR));


    //
    // Allocate space for it
    //

    lpItem = (LPSOURCEENTRY) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CEvents::AddSourceEntry: Failed to allocate memory with %d"),
                 GetLastError()));
        return E_FAIL;
    }


    //
    // Fill in item
    //

    lpItem->lpEventLogName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(SOURCEENTRY));
    lstrcpy (lpItem->lpEventLogName, lpEventLogName);

    lpItem->lpEventSourceName = lpItem->lpEventLogName + lstrlen (lpItem->lpEventLogName) + 1;
    lstrcpy (lpItem->lpEventSourceName, lpEventSourceName);


    //
    // Add it to the list
    //

    if (*lpList)
    {
        lpItem->pNext = *lpList;
    }

    *lpList = lpItem;

    return S_OK;
}

VOID CEvents::FreeSourceData(LPSOURCEENTRY lpList)
{
    LPSOURCEENTRY lpTemp;


    if (lpList)
    {
        do {
            lpTemp = lpList->pNext;
            LocalFree (lpList);
            lpList = lpTemp;

        } while (lpTemp);
    }
}

STDMETHODIMP CEvents::SaveEntriesToStream (IStream *pStm)
{
    HRESULT hr;
    DWORD dwCount = 0;
    LPEVENTLOGENTRY lpTemp;
    ULONG nBytesWritten;



    //
    // First count how many entries are in the link list
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {
        dwCount++;
        lpTemp = lpTemp->pNext;
    }


    //
    // Save the count to the stream
    //

    hr = pStm->Write(&dwCount, sizeof(dwCount), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwCount)))
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to write entry count with %d."), hr));
        hr = E_FAIL;
        goto Exit;
    }



    //
    // Now loop through each item saving each field in the node
    //

    lpTemp = m_pEventEntries;

    while (lpTemp)
    {

        //
        // Save the event id
        //

        hr = pStm->Write(&lpTemp->dwEventID, sizeof(DWORD), &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != sizeof(DWORD)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to write event id with %d."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Save the event time
        //

        hr = pStm->Write(&lpTemp->ftEventTime, sizeof(FILETIME), &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != sizeof(FILETIME)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to write file time with %d."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Save the event log name
        //

        hr = SaveString (pStm, lpTemp->lpEventLogName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to save event log name with %d."), hr));
            goto Exit;
        }


        //
        // Save the event source name
        //

        hr = SaveString (pStm, lpTemp->lpEventSourceName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to save event source name with %d."), hr));
            goto Exit;
        }


        //
        // Save the event text
        //

        hr = SaveString (pStm, lpTemp->lpText);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::SaveEntriesToStream: Failed to save event text with %d."), hr));
            goto Exit;
        }


        lpTemp = lpTemp->pNext;
    }

Exit:

    return hr;
}

STDMETHODIMP CEvents::LoadEntriesFromStream (IStream *pStm)
{
    HRESULT hr;
    DWORD dwCount = 0, dwIndex, dwEventID;
    LPEVENTLOGENTRY lpTemp;
    ULONG nBytesRead;
    FILETIME ftEventTime;
    LPTSTR lpEventLogName = NULL;
    LPTSTR lpEventSourceName = NULL;
    LPTSTR lpText = NULL;


    //
    // Read in the entry count
    //

    hr = pStm->Read(&dwCount, sizeof(dwCount), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwCount)))
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read event count with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Loop through the items
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {

        //
        // Read in the event id
        //

        hr = pStm->Read(&dwEventID, sizeof(dwEventID), &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != sizeof(dwEventID)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read event id with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Read in the event time
        //

        hr = pStm->Read(&ftEventTime, sizeof(FILETIME), &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != sizeof(FILETIME)))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read event time with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Read the event log name
        //

        hr = ReadString (pStm, &lpEventLogName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read the event log name with 0x%x."), hr));
            goto Exit;
        }


        //
        // Read the event source name
        //

        hr = ReadString (pStm, &lpEventSourceName);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read the event source name with 0x%x."), hr));
            goto Exit;
        }


        //
        // Read the event text
        //

        hr = ReadString (pStm, &lpText);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to read the event text with 0x%x."), hr));
            goto Exit;
        }


        //
        // Add this entry to the link list
        //

        if (!AddEntry (lpEventLogName, lpEventSourceName, lpText, dwEventID, &ftEventTime))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::LoadEntriesFromStream: Failed to add the entry.")));
            hr = E_FAIL;
            goto Exit;
        }


        //
        // Clean up for next item
        //

        delete [] lpEventLogName;
        lpEventLogName = NULL;

        delete [] lpEventSourceName;
        lpEventSourceName = NULL;

        delete [] lpText;
        lpText = NULL;
    }


Exit:

    if (lpEventLogName)
    {
        delete [] lpEventLogName;
    }

    if (lpEventSourceName)
    {
        delete [] lpEventSourceName;
    }

    if (lpText)
    {
        delete [] lpText;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\gpmgr.cpp ===
//*************************************************************
//  File name: GPMGR.C
//
//  Description:  Group Policy Manager - property sheet extension
//                for DS Admin
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#include "main.h"

unsigned int CGroupPolicyMgr::m_cfDSObjectName  = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
unsigned int CGroupPolicyMgr::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);

//
// Snapin manager's CLSID
//

const CLSID CLSID_NodeInit = {0x43136EB5,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


//
// CheckMark string
//

TCHAR szCheckMark[]   = TEXT("a");  // In the Marlett font, "a" becomes a check mark
TCHAR szNoCheckMark[] = TEXT("");


//
// Help ids
//

DWORD aGroupPolicyMgrHelpIds[] =
{
    IDC_GPM_DCNAME,               IDH_GPMGR_DCNAME,
    IDC_GPM_LIST,                 IDH_GPMGR_LIST,
    IDC_GPM_UP,                   IDH_GPMGR_UP,
    IDC_GPM_DOWN,                 IDH_GPMGR_DOWN,
    IDC_GPM_ADD,                  IDH_GPMGR_ADD,
    IDC_GPM_EDIT,                 IDH_GPMGR_EDIT,
    IDC_GPM_DELETE,               IDH_GPMGR_DELETE,
    IDC_GPM_PROPERTIES,           IDH_GPMGR_PROPERTIES,
    IDC_GPM_BLOCK,                IDH_GPMGR_BLOCK,
    IDC_GPM_NEW,                  IDH_GPMGR_NEW,
    IDC_GPM_OPTIONS,              IDH_GPMGR_OPTIONS,

    IDC_GPM_TITLE,                -1,
    IDC_GPM_ICON,                 -1,
    IDC_GPM_LINE1,                -1,
    IDC_GPM_PRIORITY,             -1,
    IDC_GPM_LINE2,                -1,

    0, 0
};

DWORD aLinkOptionsHelpIds[] =
{
    IDC_GPM_NOOVERRIDE,           IDH_GPMGR_NOOVERRIDE,
    IDC_GPM_DISABLED,             IDH_GPMGR_DISABLED,
    0, 0
};

DWORD aRemoveGPOHelpIds[] =
{
    IDC_REMOVE_LIST,              IDH_REMOVE_LIST,
    IDC_REMOVE_DS,                IDH_REMOVE_DS,
    0, 0
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyMgr::CGroupPolicyMgr()
{
    InterlockedIncrement(&g_cRefThisDll);
    m_cRef = 1;

    m_lpDSObject = NULL;
    m_lpGPODCName = NULL;
    m_lpDSADCName = NULL;
    m_lpDomainName = NULL;
    m_hDefaultFont = NULL;
    m_hMarlettFont = NULL;
    m_bReadOnly = FALSE;
    m_bDirty = FALSE;
    m_gpHint = GPHintUnknown;
}

CGroupPolicyMgr::~CGroupPolicyMgr()
{
    if (m_hMarlettFont)
    {
        DeleteObject (m_hMarlettFont);
    }

    if (m_lpDSObject)
    {
        LocalFree (m_lpDSObject);
    }

    if (m_lpGPODCName)
    {
        LocalFree (m_lpGPODCName);
    }

    if (m_lpDSADCName)
    {
        LocalFree (m_lpDSADCName);
    }

    if (m_lpDomainName)
    {
        LocalFree (m_lpDomainName);
    }


    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation (IUnknown)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CGroupPolicyMgr::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) ||IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CGroupPolicyMgr::AddRef (void)
{
    return ++m_cRef;
}

ULONG CGroupPolicyMgr::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation (ISnapinHelp)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGroupPolicyMgr::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gpedit.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyMgr object implementation (IExtendPropertySheet)              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGroupPolicyMgr::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage;
    FORMATETC fm;
    STGMEDIUM medium;
    LPDSOBJECTNAMES lpNames;
    LPTSTR lpTemp;


    //
    // Ask DS admin for the ldap path to the selected object
    //

    ZeroMemory (&fm, sizeof(fm));
    fm.cfFormat = (WORD)m_cfDSObjectName;
    fm.tymed = TYMED_HGLOBAL;

    ZeroMemory (&medium, sizeof(medium));
    medium.tymed = TYMED_HGLOBAL;

    medium.hGlobal = GlobalAlloc (GMEM_MOVEABLE | GMEM_NODISCARD, 512);

    if (medium.hGlobal)
    {
        hr = lpDataObject->GetData(&fm, &medium);

        if (SUCCEEDED(hr))
        {
            lpNames = (LPDSOBJECTNAMES) GlobalLock (medium.hGlobal);


            lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetName);

            if (m_lpDSObject)
            {
                LocalFree (m_lpDSObject);
            }

            m_lpDSObject = (LPTSTR) LocalAlloc (LPTR, (lstrlen (lpTemp) + 1) * sizeof(TCHAR));

            if (m_lpDSObject)
            {
                lstrcpy (m_lpDSObject, lpTemp);
                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreatePropertyPages: LDAP path from DS Admin %s"), m_lpDSObject));

                //
                // Now look at the object type to get a hint type
                //

                m_gpHint = GPHintUnknown;

                if (lpNames->aObjects[0].offsetClass) {
                    lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetClass);

                    if (lstrcmpi (lpTemp, TEXT("domainDNS")) == 0)
                    {
                        m_gpHint = GPHintDomain;
                    }
                    else if (lstrcmpi (lpTemp, TEXT("organizationalUnit")) == 0)
                    {
                        m_gpHint = GPHintOrganizationalUnit;
                    }
                    else if (lstrcmpi (lpTemp, TEXT("site")) == 0)
                    {
                        m_gpHint = GPHintSite;
                    }

                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreatePropertyPages: m_gpHint = %d"), m_gpHint));
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreatePropertyPages: No objectclass defined.")));
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            GlobalUnlock (medium.hGlobal);
        }
#if FGPO_SUPPORT
        else
        {
            //  ToDo:  remove this code after the dstree snapin supports
            //  dsobjectnames on its root node
            //
            // if we're supposed to be on the forest then we can just fudge it
            //

            fm.cfFormat = (WORD)m_cfNodeTypeString;

            if (SUCCEEDED(lpDataObject->GetDataHere(&fm, &medium)))
            {
                lpTemp = (LPWSTR) GlobalLock (medium.hGlobal);

                if (lstrcmpi(lpTemp, TEXT("{4c06495e-a241-11d0-b09b-00c04fd8dca6}")))   // DSTree snapin's root node
                {
                    // croft up our own forest path

                    lpTemp =  GetPathToForest(NULL);

                    if (lpTemp)
                    {
                        m_lpDSObject = (LPTSTR) LocalAlloc(LPTR, (lstrlen(lpTemp) + 1) * sizeof(TCHAR));

                        if (m_lpDSObject)
                        {
                            lstrcpy (m_lpDSObject, lpTemp);
                            m_gpHint = GPHintForest;
                            hr = S_OK;
                        }

                        delete [] lpTemp;
                    }
                }

                GlobalUnlock (medium.hGlobal);
            }
        }
#endif

        GlobalFree (medium.hGlobal);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Add the GPM property sheet page
    //

    if (SUCCEEDED(hr))
    {
        ZeroMemory (&psp, sizeof(psp));
        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_USECALLBACK;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE (IDD_GPMANAGER);
        psp.pfnDlgProc = GPMDlgProc;
        psp.lParam = (LPARAM) this;
        psp.pfnCallback = PropSheetPageCallback;

        hPage = CreatePropertySheetPage(&psp);

        if (hPage)
        {
            hr = lpProvider->AddPage(hPage);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::CreatePropertyPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            hr = E_FAIL;
        }
    }

    return (hr);
}

STDMETHODIMP CGroupPolicyMgr::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

UINT CALLBACK CGroupPolicyMgr::PropSheetPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CGroupPolicyMgr * pGPM;

    pGPM = (CGroupPolicyMgr *) ppsp->lParam;

    if (uMsg == PSPCB_ADDREF)
    {
        pGPM->AddRef();
    }
    else if (uMsg == PSPCB_RELEASE)
    {
        pGPM->Release();
    }

    return 1;
}

INT_PTR CALLBACK CGroupPolicyMgr::GPMDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGroupPolicyMgr * pGPM;
    static BOOL bDisableWarningIssued;

    switch (message)
    {
        case WM_INITDIALOG:
            pGPM = (CGroupPolicyMgr *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGPM);

            SetWaitCursor();
            bDisableWarningIssued = FALSE;

            EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), FALSE);

            if (!pGPM->OnInitDialog(hDlg))
            {
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_LIST), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_NEW), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_ADD), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_BLOCK), FALSE);
            }

            if (pGPM->m_bReadOnly)
            {
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_NEW), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_ADD), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_BLOCK), FALSE);
            }

#if FGPO_SUPPORT
            if (pGPM->m_gpHint == GPHintForest)
#else
            if (pGPM->m_gpHint == GPHintSite)
#endif
            {
                EnableWindow (GetDlgItem (hDlg, IDC_GPM_BLOCK), FALSE);
            }

            ClearWaitCursor();
            break;

        case WM_COMMAND:
            pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPM) {
                break;
            }

            if ((LOWORD(wParam) == IDC_GPM_ADD) || (LOWORD(wParam) == IDM_GPM_ADD))
            {
                TCHAR szPath[512];
                TCHAR szName[MAX_FRIENDLYNAME];
                TCHAR szTitle[100];
                LPTSTR lpNamelessPath;
                GPOBROWSEINFO stGBI;
                IADs * pADs;
                HRESULT hr;
                BOOL bReadOnly = FALSE;

                LoadString (g_hInstance, IDS_GPM_ADDTITLE, szTitle, ARRAYSIZE(szTitle));

                ZeroMemory(&stGBI, sizeof(GPOBROWSEINFO));
                stGBI.dwSize = sizeof(GPOBROWSEINFO);
                stGBI.dwFlags = GPO_BROWSE_NOCOMPUTERS | GPO_BROWSE_DISABLENEW;
                stGBI.hwndOwner = hDlg;
                stGBI.lpTitle = szTitle;
                stGBI.lpInitialOU = pGPM->m_lpDSObject;
                stGBI.lpDSPath = szPath;
                stGBI.dwDSPathSize = ARRAYSIZE(szPath);
                stGBI.lpName = szName;
                stGBI.dwNameSize = ARRAYSIZE(szName);

                if (SUCCEEDED(BrowseForGPO(&stGBI)))
                {

                    //
                    // Check if the user has write access to the select GPO
                    //

                    lpNamelessPath = MakeNamelessPath (szPath);

                    if (lpNamelessPath)
                    {
                        hr = OpenDSObject(szPath, IID_IADs, (void **)&pADs);

                        if (SUCCEEDED(hr)) {

                            if (FAILED(CheckDSWriteAccess((LPUNKNOWN) pADs, GPO_VERSION_PROPERTY)))
                            {
                                bReadOnly = TRUE;
                            }

                            pADs->Release();
                        }

                        //
                        // Read the policy value for the GPO link
                        //

                        HKEY hKey;
                        DWORD dwSize, dwType;
                        BOOL bDisabledLink = FALSE;


                        //
                        // Check if there is a user preference or policy that
                        // any new GPOs should be created with a disabled link
                        // by default
                        //

                        if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                                          KEY_READ, &hKey) == ERROR_SUCCESS)
                        {

                            dwSize = sizeof(bDisabledLink);
                            RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                                             (LPBYTE) &bDisabledLink, &dwSize);

                            RegCloseKey (hKey);
                        }

                        if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                                          KEY_READ, &hKey) == ERROR_SUCCESS)
                        {

                            dwSize = sizeof(bDisabledLink);
                            RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                                             (LPBYTE) &bDisabledLink, &dwSize);

                            RegCloseKey (hKey);
                        }


                        if (pGPM->AddGPOToList (GetDlgItem(hDlg, IDC_GPM_LIST),
                                                szName, lpNamelessPath, (bDisabledLink ? GPO_FLAG_DISABLE : 0), FALSE,
                                                pGPM->IsGPODisabled (lpNamelessPath), bReadOnly))
                        {
                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                            SetFocus (GetDlgItem(hDlg, IDC_GPM_LIST));
                            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                        }

                        LocalFree (lpNamelessPath);
                    }
                }
            }

            if ((LOWORD(wParam) == IDC_GPM_DELETE) || (LOWORD(wParam) == IDM_GPM_DELETE))
            {
                INT iIndex, iNext;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
                LVITEM item;


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1, LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    HRESULT hr;
                    LPGPOITEM lpGPO, lpTemp;
                    LPGROUPPOLICYOBJECT pGPO;
                    TCHAR szMessageFmt[100];
                    LPTSTR lpMessage;
                    TCHAR szTitle[100];
                    INT iResult;
                    LPTSTR lpDSPath;
                    LPTSTR lpFullPath;


                    //
                    // The GPO item pointer
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpGPO = (LPGPOITEM) item.lParam;
                    if ( !lpGPO )
                    {
                        break;
                    }

                    lpGPO->bLocked = TRUE;

                    //
                    // Offer the user a choice of Remove actions
                    //

                    iResult = (INT)DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_REMOVE_GPO),
                                        hDlg, RemoveGPODlgProc, (LPARAM) lpGPO);

                    if ((iResult == -1) || (iResult == 0))
                    {
                        SetFocus (hLV);
                        lpGPO->bLocked = FALSE;
                        break;
                    }

                    iNext = ListView_GetNextItem (hLV, iIndex, LVNI_ALL);

                    if (iNext > 0)
                    {
                        iNext--;
                    }
                    else
                    {
                        iNext = 0;
                    }

                    if (iResult == 1)
                    {
                        IADs * pADs;

                        //
                        // Bind to the DS object to make sure it's still reachable
                        //

                        hr = OpenDSObject(pGPM->m_lpDSObject, IID_IADs, (void **)&pADs);

                        if (SUCCEEDED(hr))
                        {
                            pADs->Release();
                            ListView_DeleteItem (hLV, iIndex);
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to get IADs interface with 0x%x"), hr));
                            ReportError(hDlg, hr, IDS_FAILEDGPINFO);
                            lpGPO->bLocked = FALSE;
                            break;
                        }
                    }
                    else if (iResult == 2)
                    {
                        //
                        // Confirm the delete operation
                        //

                        LoadString (g_hInstance, IDS_DELETECONFIRM, szMessageFmt, ARRAYSIZE(szMessageFmt));

                        lpMessage = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szMessageFmt) +
                                           lstrlen(lpGPO->lpDisplayName) + 1) * sizeof(TCHAR));

                        if (!lpMessage)
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to allocate memory with %d."),
                                     GetLastError()));
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        wsprintf (lpMessage, szMessageFmt, lpGPO->lpDisplayName);
                        LoadString (g_hInstance, IDS_CONFIRMTITLE, szTitle, ARRAYSIZE(szTitle));

                        if (MessageBox (hDlg, lpMessage, szTitle,
                                        MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
                        {
                            LocalFree (lpMessage);
                            SetFocus (hLV);
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        LocalFree (lpMessage);
                        SetWaitCursor ();

                        lpDSPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpGPO->lpDSPath) + 1) * sizeof(TCHAR));

                        if (!lpDSPath)
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to allocate memory with %d."),
                                     GetLastError()));
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        lstrcpy (lpDSPath, lpGPO->lpDSPath);


                        //
                        // Create a new GPO object to work with
                        //

                        hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                                               CLSCTX_SERVER, IID_IGroupPolicyObject,
                                               (void**)&pGPO);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to create GPO object with 0x%x."), hr));
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }


                        lpFullPath = pGPM->GetFullGPOPath (lpGPO->lpDSPath, hDlg);

                        if (!lpFullPath)
                        {
                            pGPO->Release();
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }


                        //
                        // Open the requested object without mounting the registry
                        //

                        hr = pGPO->OpenDSGPO(lpFullPath, 0);

                        LocalFree (lpFullPath);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to open GPO object with 0x%x."), hr));
                            ReportError(hDlg, hr, IDS_FAILEDGPODELETE, lpGPO->lpDisplayName);
                            pGPO->Release();
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }


                        //
                        // Delete the object
                        //

                        hr = pGPO->Delete();

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GPMDlgProc: Failed to delete GPO object with 0x%x."), hr));
                            ReportError(hDlg, hr, IDS_FAILEDGPODELETE, lpGPO->lpDisplayName);
                            pGPO->Release();
                            LocalFree (lpDSPath);
                            SetFocus (hLV);
                            ClearWaitCursor ();
                            lpGPO->bLocked = FALSE;
                            break;
                        }

                        pGPO->Release();

                        //
                        // Delete all the entries of this item in the listview
                        //

                        iIndex = (ListView_GetItemCount (hLV) - 1);

                        while (iIndex >= 0)
                        {
                            item.mask = LVIF_PARAM;
                            item.iItem = iIndex;
                            item.iSubItem = 0;

                            if (!ListView_GetItem (hLV, &item))
                            {
                                lpGPO->bLocked = FALSE;
                                break;
                            }

                            lpTemp = (LPGPOITEM) item.lParam;

                            if (lpTemp)
                            {
                                if (!lstrcmpi(lpTemp->lpDSPath, lpDSPath))
                                {
                                    if (iNext == iIndex)
                                    {
                                        iNext--;
                                    }

                                    ListView_DeleteItem (hLV, iIndex);
                                }
                            }

                            iIndex--;
                        }

                        LocalFree (lpDSPath);

                        ClearWaitCursor ();
                    }

                    if (iNext < 0)
                    {
                        iNext = 0;
                    }

                    //
                    // Select the next item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iNext;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iNext, (LPARAM) &item);

                    pGPM->m_bDirty = TRUE;

                    if (!pGPM->Save(hDlg))
                    {
                        pGPM->RefreshGPM (hDlg, FALSE);
                    }

                    SendMessage (GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                    SetFocus (hLV);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    lpGPO->bLocked = FALSE;
                }
            }

            if (LOWORD(wParam) == IDC_GPM_UP)
            {
                INT iSrc, iDest, iSrcImage, iDestImage;
                LPGPOITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
                LVITEM item;

                ListView_EditLabel (hLV, -1);

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc - 1;

                    //
                    // Get the current lpGPOItem pointers
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPGPOITEM) item.lParam;
                    iSrcImage = item.iImage;


                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPGPOITEM) item.lParam;
                    iDestImage = item.iImage;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iImage = iDestImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iImage = iSrcImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);
                    SendMessage (hLV, LVM_ENSUREVISIBLE, iDest, (LPARAM) FALSE);

                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iDest, iSrc);

                    pGPM->m_bDirty = TRUE;
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);

                    SetFocus (hLV);
                }
            }


            if (LOWORD(wParam) == IDC_GPM_DOWN)
            {
                INT iSrc, iDest, iSrcImage, iDestImage;
                LPGPOITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
                LVITEM item;

                ListView_EditLabel (hLV, -1);

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc + 1;

                    //
                    // Get the current lpGPOItem pointers
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPGPOITEM) item.lParam;
                    iSrcImage = item.iImage;

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPGPOITEM) item.lParam;
                    iDestImage = item.iImage;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iSrc;
                    item.iImage = iDestImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM | LVIF_IMAGE;
                    item.iItem = iDest;
                    item.iImage = iSrcImage;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);
                    SendMessage (hLV, LVM_ENSUREVISIBLE, iDest, (LPARAM) FALSE);

                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iSrc, iDest);

                    pGPM->m_bDirty = TRUE;
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);


                    SetFocus (hLV);
                }
            }

            if (LOWORD(wParam) == IDM_GPM_NOOVERRIDE)
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        lpItem->bLocked = TRUE;

                        if (lpItem->dwOptions & GPO_FLAG_FORCE)
                            lpItem->dwOptions &= ~GPO_FLAG_FORCE;
                        else
                            lpItem->dwOptions |= GPO_FLAG_FORCE;

                        ListView_RedrawItems (hLV, iIndex, iIndex);
                        UpdateWindow (hLV);

                        pGPM->m_bDirty = TRUE;
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (hLV);
                        lpItem->bLocked = FALSE;
                    }
                }
            }

            if (LOWORD(wParam) == IDM_GPM_DISABLED)
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        if (lpItem->dwOptions & GPO_FLAG_DISABLE)
                            lpItem->dwOptions &= ~GPO_FLAG_DISABLE;
                        else
                        {
                            if (bDisableWarningIssued)
                            {
                                lpItem->dwOptions |= GPO_FLAG_DISABLE;
                            }
                            else
                            {
                                TCHAR szMessage[200];
                                TCHAR szTitle[100];

                                bDisableWarningIssued = TRUE;

                                LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                                LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                                if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                            MB_ICONWARNING | MB_DEFBUTTON2) == IDYES) {

                                    lpItem->dwOptions |= GPO_FLAG_DISABLE;
                                }
                            }
                        }

                        ListView_RedrawItems (hLV, iIndex, iIndex);
                        UpdateWindow (hLV);

                        pGPM->m_bDirty = TRUE;
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (hLV);
                    }
                }
            }

            if ((LOWORD(wParam) == IDC_GPM_EDIT) || (LOWORD(wParam) == IDM_GPM_EDIT))
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        lpItem->bLocked = TRUE;
                        pGPM->StartGPE (lpItem->lpDSPath, hDlg);
                        lpItem->bLocked = FALSE;
                        SetFocus (hLV);
                    }
                }
            }

            if ((LOWORD(wParam) == IDC_GPM_NEW) || (LOWORD(wParam) == IDM_GPM_NEW))
            {
                SetWaitCursor();
                pGPM->OnNew (hDlg);
                ClearWaitCursor();
            }

            if (LOWORD(wParam) == IDC_GPM_OPTIONS)
            {
                INT iIndex;
                LPGPOITEM lpItem;
                LVITEM item;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);


                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (ListView_GetItem (hLV, &item))
                    {
                        lpItem = (LPGPOITEM) item.lParam;
                        lpItem->bLocked = TRUE;

                        if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_GPM_LINK_OPTIONS),
                                            hDlg, LinkOptionsDlgProc, (LPARAM) lpItem))
                        {
                            ListView_RedrawItems (hLV, iIndex, iIndex);
                            UpdateWindow (hLV);

                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        }

                        lpItem->bLocked = FALSE;
                        SetFocus (hLV);
                    }
                }
            }


            if (LOWORD(wParam) == IDM_GPM_RENAME)
            {
                INT iIndex;
                HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);

                //
                // Enumerate through the selected items
                //

                iIndex = ListView_GetNextItem (hLV, -1,
                                               LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {
                    ListView_EditLabel (hLV, iIndex);
                }
            }


            if ((LOWORD(wParam) == IDC_GPM_PROPERTIES) || (LOWORD(wParam) == IDM_GPM_PROPERTIES))
            {
                pGPM->OnProperties (hDlg);
            }

            if (LOWORD(wParam) == IDM_GPM_REFRESH)
            {
                pGPM->RefreshGPM (hDlg, FALSE);
            }

            if (LOWORD(wParam) == IDC_GPM_BLOCK)
            {
                pGPM->m_bDirty = TRUE;
                SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
            }

            break;

        case WM_NOTIFY:

            pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPM) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case NM_CUSTOMDRAW:
                {
                    LPNMLVCUSTOMDRAW  lplvcd = (LPNMLVCUSTOMDRAW)lParam;

                    SelectObject(lplvcd->nmcd.hdc, pGPM->m_hDefaultFont);

                    if ((lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT) ||
                        (lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, CDRF_NOTIFYSUBITEMDRAW);
                        return TRUE;
                    }

                    if ((lplvcd->nmcd.dwDrawStage == (CDDS_SUBITEM | CDDS_ITEMPREPAINT)) &&
                        (lplvcd->iSubItem > 0))
                    {
                        SelectObject(lplvcd->nmcd.hdc, pGPM->m_hMarlettFont);
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                        return TRUE;
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }


                case LVN_GETDISPINFO:
                    {
                        NMLVDISPINFO * lpDispInfo = (NMLVDISPINFO *) lParam;
                        LPGPOITEM lpItem = (LPGPOITEM)lpDispInfo->item.lParam;

                        if (lpDispInfo->item.iSubItem == 0)
                        {
                            lpDispInfo->item.pszText = lpItem->lpDisplayName;
                        }
                        else
                        {
                            lpDispInfo->item.pszText = szNoCheckMark;

                            if ((lpDispInfo->item.iSubItem == 1) &&
                                (lpItem->dwOptions & GPO_FLAG_FORCE))
                            {
                                lpDispInfo->item.pszText = szCheckMark;
                            }

                            if ((lpDispInfo->item.iSubItem == 2) &&
                                (lpItem->dwOptions & GPO_FLAG_DISABLE))
                            {
                                lpDispInfo->item.pszText = szCheckMark;
                            }
                        }
                    }
                    break;

                case LVN_DELETEITEM:
                    {
                    NMLISTVIEW * pLVInfo = (NMLISTVIEW *) lParam;

                    if (pLVInfo->lParam)
                    {
                        LocalFree ((LPTSTR)pLVInfo->lParam);
                    }

                    }
                    break;

                case LVN_ITEMCHANGED:
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    break;

                case LVN_ITEMACTIVATE:
                    {
                    LPNMITEMACTIVATE pItem = (LPNMITEMACTIVATE) lParam;
                    LPGPOITEM lpItem;
                    LVITEM item;
                    HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);

                    if (pItem->uKeyFlags != 0)
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM;
                    item.iItem = pItem->iItem;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPGPOITEM) item.lParam;

                    if (!lpItem)
                    {
                        break;
                    }


                    if (pItem->iSubItem == 0)
                    {
                        if (!lpItem->bReadOnly)
                        {
                            pGPM->StartGPE (lpItem->lpDSPath, hDlg);
                        }
                    }
                    else if (pItem->iSubItem == 1)
                    {
                        if (!pGPM->m_bReadOnly)
                        {
                            if (lpItem->dwOptions & GPO_FLAG_FORCE)
                                lpItem->dwOptions &= ~GPO_FLAG_FORCE;
                            else
                                lpItem->dwOptions |= GPO_FLAG_FORCE;

                            ListView_RedrawItems (hLV, pItem->iItem, pItem->iItem);
                            UpdateWindow (hLV);

                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        }
                    }
                    else if (pItem->iSubItem == 2)
                    {
                        if (!pGPM->m_bReadOnly)
                        {
                            lpItem = (LPGPOITEM) item.lParam;

                            if (lpItem->dwOptions & GPO_FLAG_DISABLE)
                            {
                                lpItem->dwOptions &= ~GPO_FLAG_DISABLE;
                            }
                            else
                            {
                                if (bDisableWarningIssued)
                                {
                                    lpItem->dwOptions |= GPO_FLAG_DISABLE;
                                }
                                else
                                {
                                    TCHAR szMessage[200];
                                    TCHAR szTitle[100];

                                    bDisableWarningIssued = TRUE;

                                    LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                                    LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                                    if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                                MB_ICONWARNING | MB_DEFBUTTON2) == IDYES) {

                                        lpItem->dwOptions |= GPO_FLAG_DISABLE;
                                    }
                                }
                            }

                            ListView_RedrawItems (hLV, pItem->iItem, pItem->iItem);
                            UpdateWindow (hLV);

                            pGPM->m_bDirty = TRUE;
                            SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        }
                    }

                    }
                    break;

                case LVN_BEGINLABELEDIT:
                    {
                    NMLVDISPINFO * pInfo = (NMLVDISPINFO *) lParam;
                    LPGPOITEM lpItem;

                    if (pInfo)
                    {
                        lpItem = (LPGPOITEM) pInfo->item.lParam;

                        if (lpItem)
                        {
                            if (lpItem->bReadOnly)
                            {
                                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 1);
                                return TRUE;
                            }
                            else
                            {
                                HWND hEdit;

                                hEdit = ListView_GetEditControl(GetDlgItem(hDlg, IDC_GPM_LIST));

                                if (hEdit)
                                {
                                    SetWindowText (hEdit, lpItem->lpGPOName);
                                }
                            }
                        }
                    }
                    }
                    break;

                case LVN_ENDLABELEDIT:
                    {
                    NMLVDISPINFO * pInfo = (NMLVDISPINFO *) lParam;
                    LPGROUPPOLICYOBJECT pGPO;
                    LPGPOITEM lpItem, lpTemp;
                    LV_ITEM item;
                    HRESULT hr;
                    DWORD dwSize;
                    LPTSTR lpFullPath;
                    TCHAR szDisplayName[MAX_FRIENDLYNAME];

                    if (pInfo->item.pszText && (*pInfo->item.pszText))
                    {
                        //
                        // Get the LPGPOITEM pointer
                        //

                        lpItem = (LPGPOITEM) pInfo->item.lParam;

                        if (!lpItem)
                        {
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  NULL lpGPOItem pointer")));
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        if ( lpItem->bLocked )
                        {
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        //
                        // Create a GPO object to work with
                        //

                        hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL,
                                              CLSCTX_SERVER, IID_IGroupPolicyObject,
                                              (void **)&pGPO);

                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  CoCreateInstance failed with 0x%x"), hr));
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        lpFullPath = pGPM->GetFullGPOPath (lpItem->lpDSPath, hDlg);

                        if (!lpFullPath)
                        {
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }


                        //
                        // Open GPO object without opening registry data
                        //

                        hr = pGPO->OpenDSGPO(lpFullPath, 0);

                        LocalFree (lpFullPath);

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDDS);
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  OpenDSGPO failed with 0x%x"), hr));
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }


                        //
                        // Rename it
                        //

                        hr = pGPO->SetDisplayName(pInfo->item.pszText);

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDSETNAME);
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  SetDisplayName failed with 0x%x"), hr));
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }


                        //
                        // Query for the display name again in case its been truncated
                        //

                        hr = pGPO->GetDisplayName(szDisplayName, ARRAYSIZE(szDisplayName));

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDSETNAME);
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  GetDisplayName failed with 0x%x"), hr));
                            pGPO->Release();
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 0);
                            return TRUE;
                        }

                        pGPO->Release();


                        //
                        // Update the name in the LPGPOITEM structure
                        //

                       lpTemp = pGPM->CreateEntry (szDisplayName, lpItem->lpDSPath,
                                                   lpItem->dwOptions, lpItem->dwDisabled,
                                                   lpItem->bReadOnly);

                        if (!lpTemp) {
                            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::GPMDlgProc:  Failed to create replacement entry.")));
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 1);
                            return TRUE;
                        }

                        ZeroMemory (&item, sizeof(item));
                        item.mask = LVIF_PARAM;
                        item.iItem = pInfo->item.iItem;
                        item.lParam = (LPARAM)lpTemp;

                        ListView_SetItem (GetDlgItem (hDlg, IDC_GPM_LIST), &item);

                        LocalFree (lpItem);

                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, 1);
                    }
                    }
                    return TRUE;

                case LVN_KEYDOWN:
                    {
                    LPNMLVKEYDOWN pKey = (LPNMLVKEYDOWN) lParam;

                    if (pKey->wVKey == VK_DELETE)
                    {
                        if (!pGPM->m_bReadOnly)
                        {
                            PostMessage (hDlg, WM_COMMAND, IDC_GPM_DELETE, 0);
                        }
                    }

                    if (pKey->wVKey == VK_F5)
                    {
                        PostMessage (hDlg, WM_COMMAND, IDM_GPM_REFRESH, 0);
                    }

                    if (pKey->wVKey == VK_RETURN)
                    {
                        PostMessage (hDlg, WM_COMMAND, IDM_GPM_PROPERTIES, 0);
                    }

                    if (pKey->wVKey == VK_F2)
                    {
                        HWND hLV;
                        int i;
                        LPGPOITEM lpItem;
                        LV_ITEM item;

                        //
                        // Allow the rename only if it is possible to rename
                        //

                        
                        //
                        // Get the selected item (if any)
                        //

                        hLV = GetDlgItem (hDlg, IDC_GPM_LIST);

                        i = ListView_GetNextItem(GetDlgItem (hDlg, IDC_GPM_LIST), -1, LVNI_SELECTED);

                        if (i >= 0)
                        {
                            //
                            // Get the lpGPOItem structure pointer
                            //

                            ZeroMemory(&item, sizeof(item));

                            item.mask = LVIF_PARAM;
                            item.iItem = i;
                            ListView_GetItem(hLV, &item);

                            lpItem = (LPGPOITEM)item.lParam;

                            if ( (lpItem) &&  (!(lpItem->bReadOnly)) ) {
                                PostMessage (hDlg, WM_COMMAND, IDM_GPM_RENAME, 0);
                            }
                        }
                    }

                    }
                    break;

                case PSN_APPLY:
                    {
                    PSHNOTIFY * pNotify = (PSHNOTIFY *) lParam;

                    if (!pGPM->Save(hDlg))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        return TRUE;
                    }
                    }


                // fall through...

                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_REFRESHDISPLAY:
            {
            INT iIndex, iCount;
            LPGPOITEM lpItem = NULL;
            HWND hLV = GetDlgItem(hDlg, IDC_GPM_LIST);
            LVITEM item;

            pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

            iIndex = ListView_GetNextItem (hLV, -1,
                                           LVNI_ALL | LVNI_SELECTED);

            if (iIndex != -1)
            {
                item.mask = LVIF_PARAM;
                item.iItem = iIndex;
                item.iSubItem = 0;

                if (!ListView_GetItem (hLV, &item))
                {
                    break;
                }

                lpItem = (LPGPOITEM) item.lParam;
            }


            if (pGPM && (!pGPM->m_bReadOnly))
            {
                if (iIndex != -1)
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), TRUE);
                    if (lpItem && !lpItem->bReadOnly)
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), TRUE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
                    }
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), TRUE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), TRUE);

                    iCount = ListView_GetItemCount(hLV);

                    if (iIndex > 0)
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), TRUE);
                    else
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);

                    if (iIndex < (iCount - 1))
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), TRUE);
                    else
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
                }
                else
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_DELETE), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_UP), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_DOWN), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_OPTIONS), FALSE);
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), FALSE);
                }
            }
            else
            {
                if (lpItem)
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), TRUE);

                    if (!lpItem->bReadOnly)
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), TRUE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_GPM_EDIT), FALSE);
                    }
                }
                else
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_GPM_PROPERTIES), FALSE);
                }
            }
            }
            break;

        case WM_CONTEXTMENU:
            if (GetDlgItem(hDlg, IDC_GPM_LIST) == (HWND)wParam)
            {
                pGPM = (CGroupPolicyMgr *) GetWindowLongPtr (hDlg, DWLP_USER);

                if (pGPM)
                {
                    pGPM->OnContextMenu(hDlg, lParam);
                }
            }
            else
            {
                // right mouse click
                WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPSTR) aGroupPolicyMgrHelpIds);
            }
            return TRUE;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aGroupPolicyMgrHelpIds);
            break;
    }

    return FALSE;
}

void CGroupPolicyMgr::OnContextMenu(HWND hDlg, LPARAM lParam)
{
    LPGPOITEM lpItem;
    LV_ITEM item;
    HMENU hPopup;
    HWND hLV;
    int i;
    RECT rc;
    POINT pt;


    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);


    //
    // Figure out where to place the context menu
    //

    pt.x = ((int)(short)LOWORD(lParam));
    pt.y = ((int)(short)HIWORD(lParam));

    GetWindowRect (hLV, &rc);

    if (!PtInRect (&rc, pt))
    {
        if ((lParam == (LPARAM) -1) && (i >= 0))
        {
            rc.left = LVIR_SELECTBOUNDS;
            SendMessage (hLV, LVM_GETITEMRECT, i, (LPARAM) &rc);

            pt.x = rc.left + 8;
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);

            ClientToScreen (hLV, &pt);
        }
        else
        {
            pt.x = rc.left + ((rc.right - rc.left) / 2);
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);
        }
    }


    //
    // Load the context menu
    //

    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_GPM_CONTEXTMENU));

    if (!hPopup) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnContextMenu: LoadMenu failed with error %d"), GetLastError()));
        return;
    }

    HMENU hSubMenu = GetSubMenu(hPopup, 0);


    //
    // If there is an item selected, then set the checkmarks appropriately
    //

    if (i >= 0)
    {
        //
        // Get the lpGPOItem structure pointer
        //

        ZeroMemory(&item, sizeof(item));

        item.mask = LVIF_PARAM;
        item.iItem = i;
        ListView_GetItem(hLV, &item);

        lpItem = (LPGPOITEM)item.lParam;

        if (!lpItem)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnContextMenu: Failed to get lpGPOItem pointer")));
            return;
        }


        //
        // Check the menu items
        //

        if (lpItem->dwOptions & GPO_FLAG_DISABLE)
        {
            CheckMenuRadioItem(hSubMenu, IDM_GPM_DISABLED, IDM_GPM_DISABLED,
                               IDM_GPM_DISABLED, MF_BYCOMMAND);
        }

        if (lpItem->dwOptions & GPO_FLAG_FORCE)
        {
            CheckMenuRadioItem(hSubMenu, IDM_GPM_NOOVERRIDE, IDM_GPM_NOOVERRIDE,
                               IDM_GPM_NOOVERRIDE, MF_BYCOMMAND);
        }

        RemoveMenu(hSubMenu, 9, MF_BYPOSITION);
        RemoveMenu(hSubMenu, IDM_GPM_REFRESH, MF_BYCOMMAND);

        //
        // Gray out Edit / Rename if read only
        //

        if (lpItem->bReadOnly)
        {
            EnableMenuItem (hSubMenu, IDM_GPM_EDIT, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem (hSubMenu, IDM_GPM_RENAME, MF_BYCOMMAND | MF_GRAYED);
        }
    }
    else
    {
        //
        // No item selected, remove some of the items on the
        // context menu
        //

        RemoveMenu(hSubMenu, IDM_GPM_NOOVERRIDE, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_DISABLED, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, 0, MF_BYPOSITION);
        RemoveMenu(hSubMenu, IDM_GPM_EDIT, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_DELETE, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_RENAME, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, IDM_GPM_PROPERTIES, MF_BYCOMMAND);
        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 1), MF_BYPOSITION);
        RemoveMenu(hSubMenu, (GetMenuItemCount(hSubMenu) - 2), MF_BYPOSITION);
    }


    //
    // Gray out some menu items in read only mode
    //

    if (m_bReadOnly)
    {
        EnableMenuItem (hSubMenu, IDM_GPM_NEW, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_ADD, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_DELETE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_NOOVERRIDE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hSubMenu, IDM_GPM_DISABLED, MF_BYCOMMAND | MF_GRAYED);
    }

    //
    // Display the menu
    //

    TrackPopupMenu(hSubMenu, TPM_LEFTALIGN, pt.x, pt.y, 0, hDlg, NULL);

    DestroyMenu(hPopup);
}

void CGroupPolicyMgr::OnProperties(HWND hDlg)
{
    INT iIndex;
    LVITEM item;
    HWND hLV;
    HRESULT hr;
    LPGPOITEM pItem;
    LPGROUPPOLICYOBJECT pGPO;
    HPROPSHEETPAGE *hPages;
    UINT i, uPageCount;
    PROPSHEETHEADER psh;
    LPTSTR lpTemp;


    //
    // Get the selected item
    //

    hLV = GetDlgItem (hDlg, IDC_GPM_LIST);

    iIndex = ListView_GetNextItem(hLV, -1, LVNI_ALL | LVNI_SELECTED);

    if (iIndex >= 0)
    {

        SetWaitCursor();

        //
        // Get the lpGPOItem pointer
        //

        ZeroMemory(&item, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        ListView_GetItem(hLV, &item);

        pItem = (LPGPOITEM)item.lParam;

        if (!pItem)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: Failed to get lpGPOItem pointer")));
            ClearWaitCursor();
            return;
        }

        pItem->bLocked = TRUE;

        hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                               CLSCTX_SERVER, IID_IGroupPolicyObject,
                               (void**)&pGPO);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: CoCreateInstance failed with 0x%x"), hr));
            pItem->bLocked = FALSE;
            ClearWaitCursor();
            return;
        }

        lpTemp = GetFullGPOPath (pItem->lpDSPath, hDlg);

        if (!lpTemp)
        {
            ClearWaitCursor();
            pItem->bLocked = FALSE;
            ReportError(hDlg, hr, IDS_FAILEDDS);
            return;
        }


        //
        // Open the requested object without mounting the registry
        //

        hr = pGPO->OpenDSGPO(lpTemp, pItem->bReadOnly ? GPO_OPEN_READ_ONLY : 0);

        LocalFree (lpTemp);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: Failed to open GPO object with 0x%x"), hr));
            pItem->bLocked = FALSE;
            ClearWaitCursor();
            ReportError(hDlg, hr, IDS_FAILEDDS);
            return;
        }


        //
        // Ask the GPO for the property sheet pages
        //

        hr = pGPO->GetPropertySheetPages (&hPages, &uPageCount);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnProperties: Failed to query property sheet pages with 0x%x."), hr));
            pGPO->Release();
            pItem->bLocked = FALSE;
            ClearWaitCursor();
            return;
        }

        //
        // Display the property sheet
        //

        ZeroMemory (&psh, sizeof(psh));
        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE;
        psh.hwndParent = hDlg;
        psh.hInstance = g_hInstance;
        psh.pszCaption = pItem->lpDisplayName;
        psh.nPages = uPageCount;
        psh.phpage = hPages;

        PropertySheet (&psh);

        LocalFree (hPages);
        pGPO->Release();

        CheckIconStatus (hLV, pItem);
        pItem->bLocked = FALSE;
        ClearWaitCursor();
    }
}

void CGroupPolicyMgr::OnNew(HWND hDlg)
{
    HRESULT hr;
    HWND hLV;
    INT iIndex;
    LPGROUPPOLICYOBJECT pGPO = NULL;
    TCHAR szName[256];
    TCHAR szGPOPath[MAX_PATH];
    LPOLESTR lpDomain = NULL;
    HKEY hKey;
    DWORD dwSize, dwType;
    BOOL bDisabledLink = FALSE;


    //
    // Check if there is a user preference or policy that
    // any new GPOs should be created with a disabled link
    // by default
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bDisabledLink);
        RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisabledLink, &dwSize);

        RegCloseKey (hKey);
    }

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bDisabledLink);
        RegQueryValueEx (hKey, NEW_LINKS_DISABLED_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisabledLink, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Get the domain name
    //

    lpDomain = GetDomainFromLDAPPath(m_lpDSObject);

    if (!lpDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to get the domain name")));
        goto Exit;
    }


    //
    // Create a new GPO object to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create a new GPO without mounting the registry
    //

    GetNewGPODisplayName (szName, ARRAYSIZE(szName));

#if FGPO_SUPPORT
    hr = pGPO->New(lpDomain, szName, (m_gpHint == GPHintForest) ? GPO_OPEN_FOREST : 0);
#else
    hr = pGPO->New(lpDomain, szName, 0);
#endif

    if (FAILED(hr))
    {
        ReportError(hDlg, hr, IDS_FAILEDNEW);
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to create GPO object with 0x%x"), hr));
        goto Exit;
    }


    hr = pGPO->GetPath(szGPOPath, ARRAYSIZE(szGPOPath));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to get GPO object path with 0x%x"), hr));
        pGPO->Delete();
        goto Exit;
    }


    //
    // Add the GPO to the list view
    //

    hLV = GetDlgItem (hDlg, IDC_GPM_LIST);

    if (!AddGPOToList (hLV, szName, szGPOPath,
                      (bDisabledLink ? GPO_FLAG_DISABLE : 0), FALSE, FALSE, FALSE))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnNew:  Failed to add the GPO to the listview")));
        pGPO->Delete();
        goto Exit;
    }

    m_bDirty = TRUE;

    Save(hDlg);
    SendMessage (GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);

    iIndex = ListView_GetItemCount(hLV) - 1;


    //
    // Now trigger an edit of the entry
    //

    SetFocus(hLV);
    ListView_EnsureVisible (hLV, iIndex, FALSE);
    ListView_EditLabel(hLV, iIndex);


Exit:

    if (lpDomain)
    {
        delete [] lpDomain;
    }

    if (pGPO)
    {
        pGPO->Release();
    }
}

BOOL CGroupPolicyMgr::RefreshGPM (HWND hDlg, BOOL bInitial)
{
    HRESULT hr;
    BOOL bResult = FALSE;
    TCHAR szHeaderName[50];
    TCHAR szBuffer1[100];
    TCHAR szBuffer2[MAX_FRIENDLYNAME];
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    LV_COLUMN col;
    RECT rc;
    INT iTotal = 0, iCurrent, iMaxVisibleItems, iSize;
    IADs * pADs;
    VARIANT var;
    BSTR bstrProperty;


    //
    // Prep work
    //

    SetWaitCursor();
    SendMessage (hLV, WM_SETREDRAW, 0, 0);
    ListView_DeleteAllItems(hLV);
    CheckDlgButton (hDlg, IDC_GPM_BLOCK, BST_UNCHECKED);


    //
    // Insert Columns
    //

    if (bInitial)
    {
        GetClientRect (hLV, &rc);
        LoadString(g_hInstance, IDS_GPM_NAME, szHeaderName, ARRAYSIZE(szHeaderName));
        col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
        col.fmt = LVCFMT_LEFT;
        iCurrent = (int)(rc.right * .65);
        iTotal += iCurrent;
        col.cx = iCurrent;
        col.pszText = szHeaderName;
        col.iSubItem = 0;

        ListView_InsertColumn (hLV, 0, &col);

        LoadString(g_hInstance, IDS_GPM_NOOVERRIDE, szHeaderName, ARRAYSIZE(szHeaderName));
        iCurrent = (int)(rc.right * .20);
        iTotal += iCurrent;
        col.cx = iCurrent;
        col.fmt = LVCFMT_CENTER;
        col.iSubItem = 1;
        ListView_InsertColumn (hLV, 1, &col);


        LoadString(g_hInstance, IDS_GPM_DISABLED, szHeaderName, ARRAYSIZE(szHeaderName));
        col.iSubItem = 2;
        col.cx = rc.right - iTotal;
        col.fmt = LVCFMT_CENTER;
        ListView_InsertColumn (hLV, 2, &col);
    }


    //
    // Set the DC name
    //

    if (bInitial)
    {
        LoadString (g_hInstance, IDS_GPM_DCNAME, szBuffer1, ARRAYSIZE(szBuffer1));
        wsprintf (szBuffer2, szBuffer1, m_lpGPODCName);
        SetDlgItemText (hDlg, IDC_GPM_DCNAME, szBuffer2);
    }


    //
    // Bind to the object and get the friendly name
    //

    hr = OpenDSObject(m_lpDSObject, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: %s does not exist on the server."), m_lpDSObject));

            DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_NODSOBJECT),
                 hDlg, NoDSObjectDlgProc, (LPARAM) this);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: OpenDSObject failed with 0x%x"), hr));
            ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
        }
        goto Exit;
    }

    if (bInitial)
    {
#if FGPO_SUPPORT
        if (m_gpHint != GPHintForest)
        {
#endif
            VariantInit(&var);
            bstrProperty = SysAllocString (GPM_NAME_PROPERTY);

            if (!bstrProperty)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: Failed to allocate memory with %d"), GetLastError()));
                ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
                VariantClear (&var);
                pADs->Release();
                goto Exit;
            }


            hr = pADs->Get(bstrProperty, &var);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::RefreshGPM: Failed to query for display name with 0x%x"), hr));
                ReportError(hDlg, hr, IDS_FAILEDGPQUERY, hr);
                SysFreeString (bstrProperty);
                VariantClear (&var);
                pADs->Release();
                goto Exit;
            }

            LoadString (g_hInstance, IDS_GPM_DESCRIPTION, szBuffer1, ARRAYSIZE(szBuffer1));
            wsprintf (szBuffer2, szBuffer1, var.bstrVal);

            SysFreeString (bstrProperty);
            VariantClear (&var);
#if FGPO_SUPPORT
        }
        else
        {
            LoadString (g_hInstance, IDS_GPM_FORESTDESC, szBuffer2, ARRAYSIZE(szBuffer2));
        }
#endif

        SetDlgItemText (hDlg, IDC_GPM_TITLE, szBuffer2);


        //
        // Check if the user has write access to gPLink
        //

        hr = CheckDSWriteAccess ((LPUNKNOWN)pADs, TEXT("gPLink"));

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::RefreshGPM: User has read only access to the gPLink property.")));
            m_bReadOnly = TRUE;
        }
    }


    //
    // Get the options for this DS object
    //

    VariantInit(&var);
    bstrProperty = SysAllocString (GPM_OPTIONS_PROPERTY);

    if (bstrProperty)
    {
        hr = pADs->Get(bstrProperty, &var);

        if (SUCCEEDED(hr))
        {
            if (var.lVal & GPC_BLOCK_POLICY)
            {
                CheckDlgButton (hDlg, IDC_GPM_BLOCK, BST_CHECKED);
            }
        }

        SysFreeString (bstrProperty);
    }

    VariantClear (&var);


    //
    // Get the GPOs linked to this object
    //

    VariantInit(&var);
    bstrProperty = SysAllocString (GPM_LINK_PROPERTY);

    if (bstrProperty)
    {
        hr = pADs->Get(bstrProperty, &var);

        if (SUCCEEDED(hr))
        {
            AddGPOs (hDlg, var.bstrVal);
        }

        SysFreeString (bstrProperty);
    }

    VariantClear (&var);


    pADs->Release();


    //
    // Get the max number of visible items and the total number
    // of items in the listview
    //

    if (bInitial)
    {
        iMaxVisibleItems = ListView_GetCountPerPage (hLV);
        iTotal = ListView_GetItemCount(hLV);


        //
        // If the number of items in the listview is greater than
        // the max visible items, then we need to make the first
        // column smaller by the width of a vertical scroll bar so
        // that the horizontal scroll bar doesn't appear
        //

        if (iTotal > iMaxVisibleItems) {
            iSize = ListView_GetColumnWidth (hLV, 0);
            iSize -= GetSystemMetrics(SM_CYHSCROLL);
            ListView_SetColumnWidth (hLV, 0, iSize);
        }
    }

    PropSheet_UnChanged (GetParent(hDlg), hDlg);

    //
    // Success
    //

    bResult = TRUE;

Exit:

    SendMessage (hLV, WM_SETREDRAW, 1, 0);
    ClearWaitCursor();

    return bResult;
}

BOOL CGroupPolicyMgr::OnInitDialog (HWND hDlg)
{
    BOOL bResult = FALSE;
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    LOGFONT lf;
    HICON hIcon;
    HIMAGELIST hImageList;
    HRESULT hr;
    LPOLESTR pszDomain;
    LPTSTR lpTemp;


    //
    // Retreive the name of the DC DSAdmin is using
    //

    m_lpDSADCName = ExtractServerName (m_lpDSObject);

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OnInitDialog:  DS Admin is focused on DC %s"),
             m_lpDSADCName));


    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(m_lpDSObject);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OnInitDialog: Failed to get domain name")));
        return FALSE;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &m_lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
    }


    //
    // Get the GPO DC for this domain
    //

    m_lpGPODCName = GetDCName (m_lpDomainName, m_lpDSADCName, hDlg, TRUE, VALIDATE_INHERIT_DC);

    if (!m_lpGPODCName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OnInitDialog:  Failed to get DC name for %s"),
                 m_lpDomainName));
        return FALSE;
    }


    //
    // Switch to using the GPO domain controller for this DS object
    //

    lpTemp = MakeFullPath (m_lpDSObject, m_lpGPODCName);

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OnInitDialog:  Failed to build new DS object path")));
        return FALSE;
    }

    LocalFree (m_lpDSObject);
    m_lpDSObject = lpTemp;


    //
    // Create the Marlett font based upon the currently selected font
    //

    m_hDefaultFont = (HFONT) SendMessage (hLV, WM_GETFONT, 0, 0);

    GetObject (m_hDefaultFont, sizeof(lf), &lf);

    lf.lfHeight += (LONG)(lf.lfHeight * .20);
    lf.lfCharSet = SYMBOL_CHARSET;
    lf.lfPitchAndFamily = FF_DECORATIVE | DEFAULT_PITCH;
    lstrcpy (lf.lfFaceName, TEXT("Marlett"));

    m_hMarlettFont = CreateFontIndirect (&lf);


    //
    // Set extended LV styles
    //

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


    //
    // Create the imagelist
    //

    hImageList = ImageList_Create (16, 16, ILC_MASK, 3, 3);

    if (!hImageList)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnInitDialog: Failed to create the image list")));
        return FALSE;
    }

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_POLICY),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    ImageList_AddIcon (hImageList, hIcon);

    DestroyIcon (hIcon);

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_POLICY2),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    ImageList_AddIcon (hImageList, hIcon);

    DestroyIcon (hIcon);

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_POLICY3),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    ImageList_AddIcon (hImageList, hIcon);

    DestroyIcon (hIcon);


    //
    // Associate the imagelist with the listview.
    // The listview will free this when the
    // control is destroyed.
    //

    SendMessage (hLV, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM) hImageList);


    //
    // Refresh GPM
    //

    if (!RefreshGPM(hDlg, TRUE))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::OnInitDialog: Failed to refresh GPM")));
        return FALSE;
    }


    return TRUE;

}

BOOL CGroupPolicyMgr::Save (HWND hDlg)
{
    HRESULT hr;
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    IADs * pADs;
    VARIANT var;
    BSTR bstrName;
    LVITEM item;
    LPGPOITEM lpItem;
    TCHAR szOptions[12];
    LPTSTR lpTemp, lpResult = NULL;
    DWORD dwStrLen, dwOptions;
    TCHAR szEmpty [] = TEXT(" ");
    INT iIndex = -1;


    if (m_bReadOnly)
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::Save: User only has read access, so no changes will be saved.")));
        return TRUE;
    }



    if (!m_bDirty)
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::Save: Nothing has changed (dirty flag is FALSE), so no changes will be saved.")));
        return TRUE;
    }

    //
    // Enumerate through the selected items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex, LVNI_ALL)) != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpItem = (LPGPOITEM) item.lParam;

        _itot(lpItem->dwOptions, szOptions, 10);


        //         [    ldap path                  ;   options             ]   0

        dwStrLen = 1 + lstrlen(lpItem->lpDSPath) + 1 + lstrlen(szOptions) + 1 + 1;

        if (lpResult)
        {
            dwStrLen += lstrlen(lpResult);
        }

        dwStrLen *= sizeof(TCHAR);

        lpTemp = (LPTSTR) LocalAlloc (LPTR, dwStrLen);

        if (!lpTemp)
        {
            continue;
        }


        lstrcpy (lpTemp, TEXT("["));
        lstrcat (lpTemp, lpItem->lpDSPath);
        lstrcat (lpTemp, TEXT(";"));
        lstrcat (lpTemp, szOptions);
        lstrcat (lpTemp, TEXT("]"));

        if (lpResult)
        {
            lstrcat (lpTemp, lpResult);
            LocalFree (lpResult);
        }

        lpResult = lpTemp;
    }


    if (!lpResult)
    {
        lpResult = szEmpty;
    }


    //
    // Bind to the DS object
    //

    hr = OpenDSObject(m_lpDSObject, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to get gpo interface with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        return FALSE;
    }


    //
    // Set the link property
    //

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString (lpResult);

    if (!var.bstrVal)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to allocate memory with %d"), GetLastError()));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        VariantClear (&var);
        pADs->Release();
        return FALSE;
    }


    bstrName = SysAllocString (GPM_LINK_PROPERTY);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to allocate memory with %d"), GetLastError()));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        VariantClear (&var);
        pADs->Release();
        return FALSE;
    }


    hr = pADs->Put(bstrName, var);

    SysFreeString (bstrName);
    VariantClear (&var);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to put link property with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        pADs->Release();
        return FALSE;
    }


    dwOptions = 0;

    if (IsDlgButtonChecked (hDlg, IDC_GPM_BLOCK) == BST_CHECKED)
    {
        dwOptions |= GPC_BLOCK_POLICY;
    }


    //
    // Set the options
    //

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = dwOptions;

    bstrName = SysAllocString (GPM_OPTIONS_PROPERTY);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to allocate memory with %d"), GetLastError()));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        VariantClear (&var);
        pADs->Release();
        return FALSE;
    }

    hr = pADs->Put(bstrName, var);

    SysFreeString (bstrName);
    VariantClear (&var);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to set options with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        pADs->Release();
        return FALSE;
    }


    //
    // Commit the changes
    //

    hr = pADs->SetInfo();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::Save: Failed to commit changes with 0x%x"), hr));
        ReportError(hDlg, hr, IDS_FAILEDGPINFO);
        pADs->Release();
        return FALSE;
    }

    if (lpResult != szEmpty)
    {
        LocalFree (lpResult);
    }

    pADs->Release();

    m_bDirty = FALSE;

    return TRUE;
}


BOOL CGroupPolicyMgr::AddGPOs (HWND hDlg, LPTSTR lpGPOList)
{
    HRESULT hr;
    TCHAR szGPO[512];
    TCHAR szOptions[20];
    TCHAR szDisplayName[MAX_PATH];
    DWORD dwOptions;
    LPTSTR lpTemp, lpGPO, lpNamedGPO;
    HWND hLV = GetDlgItem (hDlg, IDC_GPM_LIST);
    IADs * pADs;
    VARIANT var;
    BSTR bstrProperty;
    DWORD dwDisabled;
    BOOL bReadOnly;


    if (!lpGPOList)
    {
        return TRUE;
    }

    lpTemp = lpGPOList;

    while (TRUE)
    {
        szDisplayName[0] = TEXT('\0');
        dwDisabled = 0;
        bReadOnly = FALSE;


        //
        // Look for the [
        //

        while (*lpTemp && (*lpTemp != TEXT('[')))
            lpTemp++;

        if (!(*lpTemp))
            goto Exit;

        lpTemp++;

        //
        // Copy the GPO name
        //

        lpGPO = szGPO;

        while (*lpTemp && (*lpTemp != TEXT(';')))
            *lpGPO++ = *lpTemp++;

        *lpGPO = TEXT('\0');

        if (!(*lpTemp))
            goto Exit;

        lpTemp++;


        //
        // Get the options
        //

        lpGPO = szOptions;

        while (*lpTemp && (*lpTemp != TEXT(']')))
            *lpGPO++ = *lpTemp++;

        *lpGPO = TEXT('\0');
        dwOptions = _ttoi (szOptions);

        if (!(*lpTemp))
            goto Exit;

        lpTemp++;


        //
        // Convert the nameless path into a named path
        //

        lpNamedGPO = GetFullGPOPath (szGPO, hDlg);

        if (lpNamedGPO)
        {

            //
            // Get the friendly display name and GPO options
            //

            hr = OpenDSObject(lpNamedGPO, IID_IADs, (void **)&pADs);

            if (SUCCEEDED(hr)) {

                VariantInit(&var);
                bstrProperty = SysAllocString (GPO_NAME_PROPERTY);

                if (bstrProperty)
                {
                    hr = pADs->Get(bstrProperty, &var);

                    if (SUCCEEDED(hr))
                    {
                        lstrcpyn (szDisplayName, var.bstrVal, ARRAYSIZE(szDisplayName));
                    }

                    SysFreeString (bstrProperty);
                }

                VariantClear (&var);


                //
                // Query for the options
                //

                VariantInit(&var);
                bstrProperty = SysAllocString (GPO_OPTIONS_PROPERTY);

                if (bstrProperty)
                {
                    hr = pADs->Get(bstrProperty, &var);

                    if (SUCCEEDED(hr))
                    {
                        dwDisabled = var.lVal;
                    }

                    SysFreeString (bstrProperty);
                }
                VariantClear (&var);


                if (FAILED(CheckDSWriteAccess((LPUNKNOWN) pADs, GPO_VERSION_PROPERTY)))
                {
                    bReadOnly = TRUE;
                }

                pADs->Release();
            }
            else
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::AddGPOs: Skipping link to deleted object.  %s"), lpNamedGPO));
                    LocalFree (lpNamedGPO);
                    continue;
                }

                DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::AddGPOs: OpenDSObject failed with 0x%x"), hr));
            }

            LocalFree (lpNamedGPO);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyMgr::AddGPOs: Failed to get the full domain name for %s"), szGPO));
        }


        if (szDisplayName[0] == TEXT('\0'))
        {
            LoadString (g_hInstance, IDS_GPM_NOGPONAME, szDisplayName, ARRAYSIZE(szDisplayName));
            dwDisabled = (GPO_OPTION_DISABLE_USER | GPO_OPTION_DISABLE_MACHINE);
            bReadOnly = TRUE;
        }


        AddGPOToList (hLV, szDisplayName, szGPO, dwOptions, TRUE, dwDisabled, bReadOnly);
    }

Exit:

    return TRUE;
}

LPGPOITEM CGroupPolicyMgr::CreateEntry (LPTSTR szName, LPTSTR szGPO, DWORD dwOptions,
                                    DWORD dwDisabled, BOOL bReadOnly)
{
    LPGPOITEM lpItem;
    DWORD dwSize;
    TCHAR szFormat[20];
    LPTSTR lpResult, lpName = szName, lpFullName = NULL;
    LPOLESTR pszDomain;


    //
    // Check if the GPO is in this domain
    //

    pszDomain = GetDomainFromLDAPPath(szGPO);

    if (pszDomain)
    {
        if (SUCCEEDED(ConvertToDotStyle (pszDomain, &lpResult)))
        {
            if (lstrcmpi(lpResult, m_lpDomainName) != 0)
            {
                LoadString (g_hInstance, IDS_GPM_DOMAINNAME, szFormat,
                            ARRAYSIZE(szFormat));

                lpFullName = (LPTSTR) LocalAlloc (LPTR, (lstrlen (szName) +
                                                  lstrlen (szFormat) +
                                                  lstrlen (lpResult)) * sizeof(TCHAR));
                if (lpFullName)
                {
                    wsprintf (lpFullName, szFormat, szName, lpResult);
                    lpName = lpFullName;
                }
            }

            LocalFree (lpResult);
        }

        delete [] pszDomain;
    }


    //
    // Calculate the size needed and fill in the structure
    //

    dwSize = sizeof(GPOITEM);
    dwSize += ((lstrlen(lpName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(szName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(szGPO) + 1) * sizeof(TCHAR));

    lpItem = (LPGPOITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem)
    {
        if (lpFullName)
        {
            LocalFree (lpFullName);
        }

        return NULL;
    }


    lpItem->lpDisplayName = (LPTSTR) (((LPBYTE)lpItem) + sizeof(GPOITEM));
    lstrcpy (lpItem->lpDisplayName, lpName);

    lpItem->lpGPOName = lpItem->lpDisplayName + lstrlen (lpItem->lpDisplayName) + 1;
    lstrcpy (lpItem->lpGPOName, szName);


    lpItem->lpDSPath = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
    lstrcpy (lpItem->lpDSPath, szGPO);

    lpItem->dwOptions = dwOptions;
    lpItem->dwDisabled = dwDisabled;
    lpItem->bReadOnly = bReadOnly;
    lpItem->bLocked = FALSE;

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: Adding  %s"), lpName));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: GPO Name  %s"), szName));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: DS Path  %s"), szGPO));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: Options  %d"), dwOptions));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: Disabled  %d"), dwDisabled));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyMgr::CreateEntry: ReadOnly  %d"), bReadOnly));

    if (lpFullName)
    {
        LocalFree (lpFullName);
    }


    return lpItem;
}

BOOL CGroupPolicyMgr::AddGPOToList (HWND hLV, LPTSTR szName, LPTSTR szGPO,
                                    DWORD dwOptions, BOOL bHighest,
                                    DWORD dwDisabled, BOOL bReadOnly)
{
    LPGPOITEM lpItem;
    LV_ITEM item;
    INT iItem;


    //
    // Create the link list entry
    //

    lpItem = CreateEntry (szName, szGPO, dwOptions, dwDisabled, bReadOnly);

    if (!lpItem)
    {
        return FALSE;
    }


    //
    // Add the item
    //

    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    item.iItem = (bHighest ? 0 : ListView_GetItemCount(hLV));
    item.iSubItem = 0;
    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam = (LPARAM) lpItem;

    if ((dwDisabled & GPO_OPTION_DISABLE_USER) && (dwDisabled & GPO_OPTION_DISABLE_MACHINE))
    {
        item.iImage = 1;
    }
    else if (dwDisabled == 0)
    {
        item.iImage = 0;
    }
    else
    {
        item.iImage = 2;
    }

    iItem = ListView_InsertItem (hLV, &item);


    //
    // Select the item
    //

    item.mask = LVIF_STATE;
    item.iItem = iItem;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);


    return TRUE;
}

INT_PTR CALLBACK CGroupPolicyMgr::RemoveGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            LPGPOITEM lpGPO = (LPGPOITEM)lParam;
            TCHAR szBuffer[200];
            LPTSTR lpTitle;
            HICON hIcon;

            hIcon = LoadIcon (NULL, IDI_QUESTION);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_QUESTION, STM_SETICON, (WPARAM) hIcon, 0);
            }

            GetDlgItemText (hDlg, IDC_REMOVE_TITLE, szBuffer, ARRAYSIZE(szBuffer));

            lpTitle = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) +
                                           lstrlen(lpGPO->lpDisplayName) + 1) * sizeof(TCHAR));

            if (lpTitle)
            {
                wsprintf (lpTitle, szBuffer, lpGPO->lpDisplayName);
                SetDlgItemText (hDlg, IDC_REMOVE_TITLE, lpTitle);

                LocalFree (lpTitle);
            }

            CheckDlgButton (hDlg, IDC_REMOVE_LIST, BST_CHECKED);

            if (lpGPO->bReadOnly)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_REMOVE_DS), FALSE);
            }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    if (IsDlgButtonChecked (hDlg, IDC_REMOVE_LIST) == BST_CHECKED)
                    {
                        EndDialog (hDlg, 1);
                    }
                    else
                    {
                        EndDialog (hDlg, 2);
                    }
                    return TRUE;

                case IDCANCEL:
                    EndDialog (hDlg, 0);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aRemoveGPOHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aRemoveGPOHelpIds);
            return (TRUE);
    }

    return FALSE;
}

INT_PTR CALLBACK CGroupPolicyMgr::LinkOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            LPGPOITEM lpItem = (LPGPOITEM) lParam;
            TCHAR szBuffer[50];
            LPTSTR lpTitle;

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpItem);

            GetWindowText (hDlg, szBuffer, ARRAYSIZE(szBuffer));

            lpTitle = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) +
                                           lstrlen(lpItem->lpDisplayName) + 1) * sizeof(TCHAR));

            if (lpTitle)
            {
                wsprintf (lpTitle, szBuffer, lpItem->lpDisplayName);
                SetWindowText (hDlg, lpTitle);

                LocalFree (lpTitle);
            }

            if (lpItem->dwOptions & GPO_FLAG_DISABLE)
            {
                CheckDlgButton (hDlg, IDC_GPM_DISABLED, BST_CHECKED);
            }

            if (lpItem->dwOptions & GPO_FLAG_FORCE)
            {
                CheckDlgButton (hDlg, IDC_GPM_NOOVERRIDE, BST_CHECKED);
            }

            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_GPM_DISABLED:
                    {
                    if ((HIWORD(wParam) == BN_CLICKED) &&
                        (IsDlgButtonChecked (hDlg, IDC_GPM_DISABLED) == BST_CHECKED))
                    {
                        TCHAR szMessage[200];
                        TCHAR szTitle[100];

                        LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                        LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                        if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                    MB_ICONWARNING | MB_DEFBUTTON2) == IDNO) {

                            CheckDlgButton (hDlg, IDC_GPM_DISABLED, BST_UNCHECKED);
                        }
                    }
                    }
                    break;

                case IDOK:
                    {
                    LPGPOITEM lpItem;
                    DWORD dwTemp = 0;

                    lpItem = (LPGPOITEM) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (IsDlgButtonChecked (hDlg, IDC_GPM_DISABLED) == BST_CHECKED)
                    {
                        dwTemp |= GPO_FLAG_DISABLE;
                    }

                    if (IsDlgButtonChecked (hDlg, IDC_GPM_NOOVERRIDE) == BST_CHECKED)
                    {
                        dwTemp |= GPO_FLAG_FORCE;
                    }

                    if (dwTemp != lpItem->dwOptions)
                    {
                        lpItem->dwOptions = dwTemp;
                        EndDialog (hDlg, 1);
                    }
                    else
                    {
                        EndDialog (hDlg, 0);
                    }
                    }
                    return TRUE;

                case IDCANCEL:
                    EndDialog (hDlg, 0);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aLinkOptionsHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aLinkOptionsHelpIds);
            return (TRUE);
    }

    return FALSE;
}


INT_PTR CALLBACK CGroupPolicyMgr::NoDSObjectDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            CGroupPolicyMgr *pGPM = (CGroupPolicyMgr *)lParam;
            TCHAR szBuffer[100];
            TCHAR szTitle[300];
            LPTSTR lpMsg, lpMsgEx;
            INT iSize;
            HWND hMsg = GetDlgItem (hDlg, IDC_NODSOBJECT_TEXT);
            HICON hIcon;

            hIcon = LoadIcon (NULL, IDI_ERROR);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_NODSOBJECT_ICON, STM_SETICON, (WPARAM) hIcon, 0);
            }

            GetWindowText (hDlg, szBuffer, ARRAYSIZE(szBuffer));
            wsprintf (szTitle, szBuffer, pGPM->m_lpGPODCName);
            SetWindowText (hDlg, szTitle);

            iSize = 600;

            iSize += lstrlen(pGPM->m_lpGPODCName);
            iSize += lstrlen(pGPM->m_lpDSADCName);
            iSize++;

            lpMsg = (LPTSTR) LocalAlloc(LPTR, iSize * sizeof(TCHAR));

            if (lpMsg)
            {
                lpMsgEx = (LPTSTR) LocalAlloc(LPTR, iSize * sizeof(TCHAR));

                if (lpMsgEx)
                {
                    LoadString (g_hInstance, IDS_NODSOBJECT_MSG, lpMsg, iSize);
                    wsprintf (lpMsgEx, lpMsg, pGPM->m_lpGPODCName, pGPM->m_lpDSADCName);
                    SetWindowText (hMsg, lpMsgEx);
                    LocalFree (lpMsgEx);
                }

                LocalFree (lpMsg);
            }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hDlg, 1);
                    return TRUE;

                case IDHELP:
                    WinExec("hh.exe spconcepts.chm::/sag_spTShoot.htm", SW_SHOWNORMAL);
                    break;
            }
            break;
    }

    return FALSE;
}

DWORD CGroupPolicyMgr::IsGPODisabled(LPTSTR lpGPO)
{
    HRESULT hr;
    LPTSTR lpTemp;
    DWORD dwOptions = 0;
    LPGROUPPOLICYOBJECT pGPO = NULL;


    //
    // Create a GroupPolicyObject to work with
    //

    hr = CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                           CLSCTX_SERVER, IID_IGroupPolicyObject,
                           (void**)&pGPO);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("IsGPODisabled: Failed to create GPO object with 0x%x."), hr));
        return 0;
    }

    lpTemp = GetFullGPOPath (lpGPO, NULL);

    if (!lpTemp)
    {
        pGPO->Release();
        return 0;
    }


    //
    // Open the requested object without mounting the registry
    //

    hr = pGPO->OpenDSGPO(lpTemp, GPO_OPEN_READ_ONLY);

    LocalFree (lpTemp);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("IsGPODisabled: Failed to open GPO object with 0x%x."), hr));
        pGPO->Release();
        return 0;
    }


    //
    // Get the options
    //

    hr = pGPO->GetOptions(&dwOptions);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("IsGPODisabled: Failed to get GPO options with 0x%x."), hr));
        pGPO->Release();
        return 0;
    }

    pGPO->Release();

    return dwOptions;
}

void CGroupPolicyMgr::CheckIconStatus (HWND hLV, LPGPOITEM lpGPO)
{
    LPGPOITEM lpItem;
    LV_ITEM item;
    INT iIndex = -1;
    DWORD dwDisabled;



    //
    // Check if the GPO disabled
    //

    dwDisabled = IsGPODisabled(lpGPO->lpDSPath);


    //
    // If the status hasn't changed, exit now
    //

    if (dwDisabled == lpGPO->dwDisabled)
    {
        return;
    }


    //
    // Enumerate through the items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex, LVNI_ALL)) != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpItem = (LPGPOITEM) item.lParam;


        //
        // If the item has a path to the GPO in question,
        // update the icon
        //

        if (!lstrcmpi (lpItem->lpDSPath, lpGPO->lpDSPath))
        {
            //
            // Update the icon if appropriate
            //

            item.mask = LVIF_IMAGE;
            item.iItem = iIndex;
            item.iSubItem = 0;

            if ((dwDisabled & GPO_OPTION_DISABLE_USER) && (dwDisabled & GPO_OPTION_DISABLE_MACHINE))
            {
                item.iImage = 1;
            }
            else if (dwDisabled == 0)
            {
                item.iImage = 0;
            }
            else
            {
                item.iImage = 2;
            }

            SendMessage (hLV, LVM_SETITEM, 0, (LPARAM) &item);
            ListView_RedrawItems (hLV, iIndex, iIndex);
        }
    }

    lpGPO->dwDisabled = dwDisabled;
}

LPTSTR CGroupPolicyMgr::GetFullGPOPath (LPTSTR lpGPO, HWND hParent)
{
    LPTSTR lpFullPath = NULL, lpDomainName = NULL;
    LPTSTR lpGPODCName;
    LPOLESTR pszDomain;
    HRESULT hr;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpGPO);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath: Failed to get domain name")));
        return NULL;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
        return NULL;
    }


    if (!lstrcmpi(lpDomainName, m_lpDomainName))
    {

        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, m_lpGPODCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath:  Failed to build new DS object path")));
            goto Exit;
        }

    }
    else
    {

        //
        // Get the GPO DC for this domain
        //

        lpGPODCName = GetDCName (lpDomainName, NULL, hParent, TRUE, 0);

        if (!lpGPODCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath:  Failed to get DC name for %s"),
                     lpDomainName));
            goto Exit;
        }


        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, lpGPODCName);

        LocalFree (lpGPODCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetFullGPOPath:  Failed to build new DS object path")));
            goto Exit;
        }
    }


Exit:

    if (lpDomainName)
    {
        LocalFree (lpDomainName);
    }

    return lpFullPath;
}

BOOL CGroupPolicyMgr::StartGPE (LPTSTR lpGPO, HWND hParent)
{
    LPTSTR lpDomainName;
    LPOLESTR pszDomain;
    HRESULT hr;
    BOOL bResult;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpGPO);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::StartGPE: Failed to get domain name")));
        return FALSE;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
        return FALSE;
    }


    //
    // Check if the GPO is in the same domain as GPM is focused on
    //

    if (!lstrcmpi(lpDomainName, m_lpDomainName))
    {
        bResult = SpawnGPE (lpGPO, m_gpHint, m_lpGPODCName, hParent);
    }
    else
    {
        bResult = SpawnGPE (lpGPO, m_gpHint, NULL, hParent);
    }


    LocalFree (lpDomainName);

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyMgrCF::CGroupPolicyMgrCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CGroupPolicyMgrCF::~CGroupPolicyMgrCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CGroupPolicyMgrCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CGroupPolicyMgrCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CGroupPolicyMgrCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CGroupPolicyMgrCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CGroupPolicyMgr *pComponentData = new CGroupPolicyMgr(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CGroupPolicyMgrCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\gpobj.h ===
class CGroupPolicyObject;

typedef struct _GLPARAM
{
    BOOL fFinding;
    BOOL fAbort;
    CGroupPolicyObject * pGPO;
} GLPARAM;

typedef struct _GLTHREADPARAM
{
    HWND hDlg;
    BOOL * pfAbort;
    CGroupPolicyObject * pGPO;
    LPOLESTR pszLDAPName;
} GLTHREADPARAM;

#define PDM_CHANGEBUTTONTEXT    (WM_USER + 1000)

//
// CGroupPolicyObject class
//
class CGroupPolicyObject : public IGroupPolicyObject
{
public:
    CGroupPolicyObject();
    ~CGroupPolicyObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IGroupPolicyObject methods
    //

    STDMETHOD(New) (LPOLESTR pszDomainName, LPOLESTR pszDisplayName, DWORD dwFlags);
    STDMETHOD(OpenDSGPO) (LPOLESTR pszPath, DWORD dwFlags);
    STDMETHOD(OpenLocalMachineGPO) (DWORD dwFlags);
    STDMETHOD(OpenRemoteMachineGPO) (LPOLESTR pszCompterName, DWORD dwFlags);
    STDMETHOD(Save) (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin );
    STDMETHOD(Delete) (void);
    STDMETHOD(GetName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetDisplayName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(SetDisplayName) (LPOLESTR pszName);
    STDMETHOD(GetPath) (LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetDSPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetFileSysPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetRegistryKey) (DWORD dwSection, HKEY *hKey);
    STDMETHOD(GetOptions) (DWORD *dwOptions);
    STDMETHOD(SetOptions) (DWORD dwOptions, DWORD dwMask);
    STDMETHOD(GetType) (GROUP_POLICY_OBJECT_TYPE *gpoType);
    STDMETHOD(GetMachineName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetPropertySheetPages) (HPROPSHEETPAGE **hPages, UINT *uPageCount);


    //
    // Internal methods
    //

    STDMETHOD(CreateContainer) (LPOLESTR lpParent, LPOLESTR lpCommonName, BOOL bGPC);
    STDMETHOD(SetDisplayNameI) (IADs * pADs, LPOLESTR lpDisplayName,
                                LPOLESTR lpGPTPath, BOOL bUpdateDisplayVar);
    STDMETHOD(SetGPOInfo) (LPOLESTR lpGPO, LPOLESTR lpDisplayName, LPOLESTR lpGPTPath);
    STDMETHOD(CheckFSWriteAccess) (LPOLESTR lpLocalGPO);
    STDMETHOD(GetSecurityDescriptor) (IADs *pADs, SECURITY_INFORMATION si,
                                      PSECURITY_DESCRIPTOR *pSD);
    BOOL EnableSecurityPrivs(void);
    DWORD EnableInheritance (PACL pAcl);
    DWORD MapSecurityRights (PACL pAcl);
    DWORD SetSysvolSecurity (LPTSTR lpFileSysPath, SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(CleanUp) (void);
    STDMETHOD(RefreshGroupPolicy) (BOOL bMachine);

    static HRESULT WINAPI ReadSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR *pSD, LPARAM lpContext);
    static HRESULT WINAPI WriteSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, LPARAM lpContext);
    static INT_PTR CALLBACK WQLFilterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PropertiesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK GPELinksDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static DWORD WINAPI GLThreadFunc(GLTHREADPARAM  * pgltp);
    DWORD WINAPI FindLinkInDomain(GLTHREADPARAM  * pgltp, LPTSTR lpGPO);
    DWORD WINAPI FindLinkInSite(GLTHREADPARAM  * pgltp, LPTSTR lpGPO);
    BOOL FillDomainList (HWND hWndCombo);

private:

    HRESULT GetProperty( TCHAR *pszProp, XPtrST<TCHAR>& xValueIn );
    HRESULT SetProperty( TCHAR *pszProp, TCHAR *pszPropValue );

    ULONG                       m_cRef;
    BOOL                        m_bInitialized;
    IADs                       *m_pADs;
    GROUP_POLICY_OBJECT_TYPE    m_gpoType;
    DWORD                       m_dwFlags;
    LPOLESTR                    m_pName;
    LPOLESTR                    m_pDisplayName;
    LPOLESTR                    m_pMachineName;
    CRegistryHive              *m_pUser;
    CRegistryHive              *m_pMachine;

    HINSTANCE                   m_hinstDSSec;
    PFNDSCREATESECPAGE          m_pfnDSCreateSecurityPage;

    LPTSTR                      m_pTempFilterString;

public:

    LPOLESTR                    m_pDSPath;
    LPOLESTR                    m_pFileSysPath;
};


//
// GroupPolicyObject class factory
//


class CGroupPolicyObjectCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CGroupPolicyObjectCF();
    ~CGroupPolicyObjectCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};



//
// Strings
//

#define GPO_VERSION_PROPERTY     L"versionNumber"
#define GPT_PATH_PROPERTY        L"gPCFileSysPath"
#define GPO_NAME_PROPERTY        L"displayName"
#define GPO_OPTIONS_PROPERTY     L"flags"
#define GPO_FUNCTION_PROPERTY    L"gPCFunctionalityVersion"
#define GPO_WQLFILTER_PROPERTY   L"gPCWQLFilter"

#define GPO_USEREXTENSION_NAMES  L"gPCUserExtensionNames"
#define GPO_MACHEXTENSION_NAMES  L"gPCMachineExtensionNames"


#define LOCAL_GPO_DIRECTORY      TEXT("%SystemRoot%\\System32\\GroupPolicy")
#define REMOTE_GPO_DIRECTORY     TEXT("\\\\%s\\ADMIN$\\System32\\GroupPolicy")

#define SITE_NAME_PROPERTY       L"name"
#define DOMAIN_NAME_PROPERTY     L"name"

//
// Functionality version
//

#define GPO_FUNCTIONALITY_VERSION  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\events.h ===
//
// Event log entry
//

typedef struct tagEVENTLOGENTRY {
    DWORD    dwEventID;
    FILETIME ftEventTime;
    LPTSTR   lpEventLogName;
    LPTSTR   lpEventSourceName;
    LPTSTR   lpText;
    struct tagEVENTLOGENTRY * pNext;
} EVENTLOGENTRY, *LPEVENTLOGENTRY;


//
// Source name entry
//

typedef struct tagSOURCEENTRY {
    LPTSTR   lpEventLogName;
    LPTSTR   lpEventSourceName;
    struct tagSOURCEENTRY * pNext;
} SOURCEENTRY, *LPSOURCEENTRY;


//
// CEvents class
//

class CEvents
{
private:

    LPEVENTLOGENTRY   m_pEventEntries;

public:
    CEvents();
    ~CEvents();

    BOOL AddEntry(LPTSTR lpEventLogName, LPTSTR lpEventSourceName, LPTSTR lpText,
                  DWORD dwEventID, FILETIME *ftTime);

    VOID FreeData(LPEVENTLOGENTRY lpList);

    STDMETHODIMP SecondsSince1970ToFileTime(DWORD dwSecondsSince1970,
                                            FILETIME *pftTime);

    LPTSTR BuildMessage(LPTSTR lpMsg, LPTSTR *lpStrings, DWORD dwStringCount,
                        HMODULE hParamFile);

    STDMETHODIMP SaveEventLogEntry (PEVENTLOGRECORD pEntry,
                                    LPTSTR lpEventLogName,
                                    LPTSTR lpEventSourceName,
                                    FILETIME *ftEntry);

    LPTSTR * BuildStringArray(LPTSTR lpStrings, DWORD *dwStringCount);

    STDMETHODIMP ParseEventLogRecords (PEVENTLOGRECORD lpEntries,
                                       DWORD dwEntriesSize,
                                       LPTSTR lpEventLogName,
                                       LPTSTR lpEventSourceName,
                                       DWORD  dwEventID,
                                       FILETIME * pBeginTime,
                                       FILETIME * pEndTime);

    STDMETHODIMP QueryForEventLogEntries (LPTSTR lpComputerName,
                                          LPTSTR lpEventLogName,
                                          LPTSTR lpEventSourceName,
                                          DWORD dwEventID,
                                          SYSTEMTIME * pBeginTime,
                                          SYSTEMTIME * pEndTime);

    STDMETHODIMP GetEventLogEntryText(LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                      LPOLESTR pszEventTime, DWORD dwEventID, LPOLESTR *ppszText);

    BOOL IsEntryInEventSourceList (LPEVENTLOGENTRY lpEntry, LPSOURCEENTRY lpEventSources);

    BOOL IsEntryInExceptionList (LPEVENTLOGENTRY lpEntry);

    STDMETHODIMP GetCSEEntries(SYSTEMTIME * pBeginTime, SYSTEMTIME * pEndTime,
                               LPSOURCEENTRY lpEventSources, LPOLESTR *ppszText, BOOL bGpCore);

    STDMETHODIMP DumpDebugInfo (void);

    LPTSTR ConvertTimeToDisplayTime (SYSTEMTIME *pSysTime, FILETIME *pFileTime, LPTSTR szBuffer);

    STDMETHODIMP AddSourceEntry (LPTSTR lpEventLogName,
                                 LPTSTR lpEventSourceName,
                                 LPSOURCEENTRY *lpList);

    VOID FreeSourceData(LPSOURCEENTRY lpList);

    STDMETHODIMP SaveEntriesToStream (IStream *pStm);

    STDMETHODIMP LoadEntriesFromStream (IStream *pStm);

};

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\gpedit.cpp ===
#include "main.h"
#include <initguid.h>
#include "about.h"
#include <gpedit.h>

//
// Global variables for this DLL
//

LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;
DWORD g_dwNameSpaceItems;
CRITICAL_SECTION g_DCCS;
TCHAR g_szDisplayProperties[150] = {0};


//
// Group Policy Manager's snapin GUID
// {D70A2BEA-A63E-11d1-A7D4-0000F87571E3}
//

DEFINE_GUID(CLSID_GPMSnapIn, 0xd70a2bea, 0xa63e, 0x11d1, 0xa7, 0xd4, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// RSOP Context Menu GUID for planning mode
// {63E23168-BFF7-4E87-A246-EF024425E4EC}
//

DEFINE_GUID(CLSID_RSOP_CMenu, 0x63E23168, 0xBFF7, 0x4E87, 0xA2, 0x46, 0xEF, 0x02, 0x44, 0x25, 0xE4, 0xEC);

//
// DS Admin's snapin ID
//

const TCHAR szDSAdmin[] = TEXT("{E355E538-1C2E-11D0-8C37-00C04FD8FE93}");


//
// Nodes the GPM extends in DS Admin
//

const LPTSTR szDSAdminNodes[] =
   {
   TEXT("{19195a5b-6da0-11d0-afd3-00c04fd930c9}"),   // Domain
   TEXT("{bf967aa5-0de6-11d0-a285-00aa003049e2}"),   // Organizational unit
   };


//
// Site Manager's snapin ID
//

const TCHAR szSiteMgr[] = TEXT("{D967F824-9968-11D0-B936-00C04FD8D5B0}");


//
// Nodes the GPM extends in DS Admin
//

const LPTSTR szSiteMgrNodes[] =
   {
   TEXT("{bf967ab3-0de6-11d0-a285-00aa003049e2}")  // Site
   };


const LPTSTR szDSTreeSnapinNodes[] =
   {
   TEXT("{4c06495e-a241-11d0-b09b-00c04fd8dca6}") // Forest
   };


const LPTSTR szDSAdminRsopTargetNodes[] = 
   {
    
   TEXT("{bf967aba-0de6-11d0-a285-00aa003049e2}"), // user
   TEXT("{bf967a86-0de6-11d0-a285-00aa003049e2}")  // comp
   };



//
// Help topic commands
//

const TCHAR g_szGPERoot[]    = TEXT("gpedit.chm::/gpe_default.htm");
const TCHAR g_szUser[]       = TEXT("gpedit.chm::/user.htm");
const TCHAR g_szMachine[]    = TEXT("gpedit.chm::/machine.htm");
const TCHAR g_szWindows[]    = TEXT("gpedit.chm::/windows.htm");
const TCHAR g_szSoftware[]   = TEXT("gpedit.chm::/software.htm");

//
// Result pane items for the nodes with no result pane items
//

RESULTITEM g_Undefined[] =
{
    { 1, 1, 0, 0, {0} }
};


//
// Namespace (scope) items
//

NAMESPACEITEM g_NameSpace[] =
{
  { 0, -1, 2, 2, IDS_SNAPIN_NAME, IDS_SNAPIN_DESCRIPT,           2, {0}, 0, g_Undefined, &NODEID_GPERoot,           g_szGPERoot  },  // GPE Root
  { 1,  0, 4, 4, IDS_MACHINE,     IDS_MACHINE_DESC,              2, {0}, 0, g_Undefined, &NODEID_MachineRoot,       g_szMachine  },  // Computer Configuration
  { 2,  0, 5, 5, IDS_USER,        IDS_USER_DESC,                 2, {0}, 0, g_Undefined, &NODEID_UserRoot,          g_szUser     },  // User Configuration

  { 3,  1, 0, 1, IDS_SWSETTINGS,  IDS_C_SWSETTINGS_DESC,         0, {0}, 0, g_Undefined, &NODEID_MachineSWSettings, g_szSoftware },  // Computer Configuration\Software Settings
  { 4,  1, 0, 1, IDS_WINSETTINGS, IDS_C_WINSETTINGS_DESC,        0, {0}, 0, g_Undefined, &NODEID_Machine,           g_szWindows  },  // Computer Configuration\Windows Settings

  { 5,  2, 0, 1, IDS_SWSETTINGS,  IDS_U_SWSETTINGS_DESC,         0, {0}, 0, g_Undefined, &NODEID_UserSWSettings,    g_szSoftware },  // User Configuration\Software Settings
  { 6,  2, 0, 1, IDS_WINSETTINGS, IDS_U_WINSETTINGS_DESC,        0, {0}, 0, g_Undefined, &NODEID_User,              g_szWindows  },  // User Configuration\Windows Settings
};

NAMESPACEITEM g_RsopNameSpace[] =
{
  { 0, -1, 2, 2, IDS_RSOP_SNAPIN_NAME, IDS_RSOP_SNAPIN_DESCRIPT, 2, {0}, 0, g_Undefined, &NODEID_RSOPRoot,      g_szGPERoot  },  // GPE Root
  { 1,  0, 4, 4, IDS_MACHINE,          IDS_MACHINE_DESC,         2, {0}, 0, g_Undefined, &NODEID_RSOPMachineRoot,       g_szMachine  },  // Computer Configuration
  { 2,  0, 5, 5, IDS_USER,             IDS_USER_DESC,            2, {0}, 0, g_Undefined, &NODEID_RSOPUserRoot,          g_szUser     },  // User Configuration

  { 3,  1, 0, 1, IDS_SWSETTINGS,       IDS_C_SWSETTINGS_DESC,    0, {0}, 0, g_Undefined, &NODEID_RSOPMachineSWSettings, g_szSoftware },  // Computer Configuration\Software Settings
  { 4,  1, 0, 1, IDS_WINSETTINGS,      IDS_C_WINSETTINGS_DESC,   0, {0}, 0, g_Undefined, &NODEID_RSOPMachine,           g_szWindows  },  // Computer Configuration\Windows Settings

  { 5,  2, 0, 1, IDS_SWSETTINGS,       IDS_U_SWSETTINGS_DESC,    0, {0}, 0, g_Undefined, &NODEID_RSOPUserSWSettings,    g_szSoftware },  // User Configuration\Software Settings
  { 6,  2, 0, 1, IDS_WINSETTINGS,      IDS_U_WINSETTINGS_DESC,   0, {0}, 0, g_Undefined, &NODEID_RSOPUser,              g_szWindows  },  // User Configuration\Windows Settings
};



BOOL InitNameSpace()
{
    DWORD dwIndex;

    g_dwNameSpaceItems = ARRAYSIZE(g_NameSpace);

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if (g_NameSpace[dwIndex].iStringID)
        {
            LoadString (g_hInstance, g_NameSpace[dwIndex].iStringID,
                        g_NameSpace[dwIndex].szDisplayName,
                        MAX_DISPLAYNAME_SIZE);
        }
    }

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if (g_RsopNameSpace[dwIndex].iStringID)
        {
            LoadString (g_hInstance, g_RsopNameSpace[dwIndex].iStringID,
                        g_RsopNameSpace[dwIndex].szDisplayName,
                        MAX_DISPLAYNAME_SIZE);
        }
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    WORD wVersionRequested;
    WSADATA wsaData;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitNameSpace();
       InitializeCriticalSection(&g_DCCS);
       InitDebugSupport();
       LoadString (hInstance, IDS_DISPLAYPROPERTIES, g_szDisplayProperties, ARRAYSIZE(g_szDisplayProperties));

         
       wVersionRequested = MAKEWORD( 2, 2 );
         
       // we need to call WSAStartup to do gethostbyname
       // Error is handled gracefully. Safe to ignore the error
       WSAStartup( wVersionRequested, &wsaData );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
       WSACleanup( );
       FreeDCSelections();
       DeleteCriticalSection(&g_DCCS);
    }
    
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;


    if (IsEqualCLSID (rclsid, CLSID_GPESnapIn)) {

        CComponentDataCF *pComponentDataCF = new CComponentDataCF();   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_GroupPolicyObject)) {

        CGroupPolicyObjectCF *pGroupPolicyObjectCF = new CGroupPolicyObjectCF();   // ref == 1

        if (!pGroupPolicyObjectCF)
            return E_OUTOFMEMORY;

        hr = pGroupPolicyObjectCF->QueryInterface(riid, ppv);

        pGroupPolicyObjectCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_GPMSnapIn)) {

        CGroupPolicyMgrCF *pGroupPolicyMgrCF = new CGroupPolicyMgrCF();   // ref == 1

        if (!pGroupPolicyMgrCF)
            return E_OUTOFMEMORY;

        hr = pGroupPolicyMgrCF->QueryInterface(riid, ppv);

        pGroupPolicyMgrCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPSnapIn)) {

        CRSOPComponentDataCF *pRSOPComponentDataCF = new CRSOPComponentDataCF();   // ref == 1

        if (!pRSOPComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pRSOPComponentDataCF->QueryInterface(riid, ppv);

        pRSOPComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_AboutGPE)) {

        CAboutGPECF *pAboutGPECF = new CAboutGPECF();   // ref == 1

        if (!pAboutGPECF)
            return E_OUTOFMEMORY;

        hr = pAboutGPECF->QueryInterface(riid, ppv);

        pAboutGPECF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPAboutGPE)) {

        CAboutGPECF *pAboutGPECF = new CAboutGPECF(TRUE);   // ref == 1

        if (!pAboutGPECF)
            return E_OUTOFMEMORY;

        hr = pAboutGPECF->QueryInterface(riid, ppv);

        pAboutGPECF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOP_CMenu)) {

        CRSOPCMenuCF *pRSOPCMenuCF = new CRSOPCMenuCF();   // ref == 1 

        if (!pRSOPCMenuCF)
            return E_OUTOFMEMORY;

        hr = pRSOPCMenuCF->QueryInterface(riid, ppv);

        pRSOPCMenuCF->Release();     // release initial ref

        return hr;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

const TCHAR szDLLLocation[] = TEXT("%SystemRoot%\\System32\\GPEdit.dll");
const TCHAR szThreadingModel[] = TEXT("Apartment");
const TCHAR szSnapInNameIndirect[] = TEXT("@gpedit.dll,-1");
const TCHAR szRsopSnapInNameIndirect[] = TEXT("@gpedit.dll,-4");
const TCHAR szViewDescript [] = TEXT("MMCViewExt 1.0 Object");
const TCHAR szViewGUID [] = TEXT("{B708457E-DB61-4C55-A92F-0D4B5E9B1224}");
const TCHAR szDefRsopMscLocation [] = TEXT("%systemroot%\\system32\\rsop.msc");

STDAPI DllRegisterServer(void)
{
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szSnapInKey[50];
    TCHAR szRsopSnapInKey[50];
    TCHAR szRsopSnapInName[100];
    TCHAR szRsopName[100];
    TCHAR szRsopGUID[50];
    TCHAR szName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwIndex;
    LONG lResult;
    HKEY hKey;
    INT i;


    //
    // Register GPE SnapIn in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_GPESnapIn, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_SNAPIN_NAME, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    //
    // Register RSOP SnapIn in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_RSOPSnapIn, szRsopSnapInKey, 50);
    LoadString (g_hInstance, IDS_RSOP_SNAPIN_NAME, szRsopSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szRsopSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szRsopSnapInName,
                   (lstrlen(szRsopSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szRsopSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register GPO in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_GroupPolicyObject, szGUID, 50);
    LoadString (g_hInstance, IDS_GPO_NAME, szName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szGUID);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName,
                   (lstrlen(szName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szGUID);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register AboutGPE in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_AboutGPE, szGUID, 50);
    LoadString (g_hInstance, IDS_ABOUT_NAME, szName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szGUID);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName,
                   (lstrlen(szName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szGUID);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    //
    // Register RSOPAboutGPE in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_RSOPAboutGPE, szGUID, 50);
    LoadString (g_hInstance, IDS_ABOUT_NAME, szName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szGUID);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName,
                   (lstrlen(szName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szGUID);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register GPE SnapIn with MMC
    //

    StringFromGUID2 (CLSID_GPESnapIn, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_SNAPIN_NAME, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szSnapInNameIndirect,
                   (lstrlen(szSnapInNameIndirect) + 1) * sizeof(TCHAR));

    StringFromGUID2 (CLSID_AboutGPE, szGUID, 50);
    RegSetValueEx (hKey, TEXT("About"), 0, REG_SZ, (LPBYTE) szGUID,
                   (lstrlen(szGUID) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                  szSnapInKey, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\StandAlone"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register RSOP SnapIn with MMC
    //

    StringFromGUID2 (CLSID_RSOPSnapIn, szRsopSnapInKey, 50);
    LoadString (g_hInstance, IDS_RSOP_SNAPIN_NAME, szRsopSnapInName, 100);
    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szRsopSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szRsopSnapInName,
                   (lstrlen(szRsopSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szRsopSnapInNameIndirect,
                   (lstrlen(szRsopSnapInNameIndirect) + 1) * sizeof(TCHAR));

    StringFromGUID2 (CLSID_RSOPAboutGPE, szGUID, 50);
    RegSetValueEx (hKey, TEXT("About"), 0, REG_SZ, (LPBYTE) szGUID,
                   (lstrlen(szGUID) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_RsopNameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                  szRsopSnapInKey, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\StandAlone"), szRsopSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register in the NodeTypes key and register for the view extension
    //

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\View"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                       (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

        RegCloseKey (hKey);

        StringFromGUID2 (*g_RsopNameSpace[dwIndex].pNodeID, szGUID, 50);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\View"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                       (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

        RegCloseKey (hKey);
    }


    //
    // Register GPM SnapIn in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_GPMSnapIn, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_GPM_SNAPIN_NAME, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register GPMSnapIn with MMC
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szSnapInNameIndirect,
                   (lstrlen(szSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register as a DS admin property sheet extension
    //

    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        lstrcpy (szGUID, szDSAdminNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), szDSAdmin, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register as a site mgr property sheet extension
    //

    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        lstrcpy (szGUID, szSiteMgrNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), szSiteMgr, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register RSOP Context Menu in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_RSOP_CMenu, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_RSOP_CMENU_NAME, szSnapInName, 100);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    wsprintf (szSubKey, TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register RSOP Context Menu with MMC.
    // !!!!! Check whether this is necessary
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szSnapInNameIndirect,
                   (lstrlen(szSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register as a DS admin task menu extension
    //

    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        lstrcpy (szGUID, szDSAdminNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), szDSAdmin, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register as a DS admin rsop target task menu extension
    //

    for (i=0; i < ARRAYSIZE(szDSAdminRsopTargetNodes); i++)
    {
        lstrcpy (szGUID, szDSAdminRsopTargetNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), szDSAdmin, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register as a site mgr task menu extension
    //

    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        lstrcpy (szGUID, szSiteMgrNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), szSiteMgr, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }

    //
    // Mark the authormode rsop.msc as read only
    //

    TCHAR  szRsopMscFileName[MAX_PATH+1];

    if (ExpandEnvironmentStrings(szDefRsopMscLocation, szRsopMscFileName, MAX_PATH+1)) {
        SetFileAttributes(szRsopMscFileName, FILE_ATTRIBUTE_READONLY);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DllRegisterServer: ExpandEnvironmentStrings failed with error %d"), GetLastError()));
    }

#if FGPO_SUPPORT

    // register as a DSTree snapin property sheet extension
    for (i=0; i < ARRAYSIZE(szDSTreeSnapinNodes); i++)
    {
        lstrcpy (szGUID, szDSTreeSnapinNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), szSiteMgr, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


#else

    for (i=0; i < ARRAYSIZE(szDSTreeSnapinNodes); i++)
    {
        lstrcpy (szGUID, szDSTreeSnapinNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), szGUID);

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }

#endif

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    TCHAR szSnapInKey[50];
    DWORD dwIndex;
    LONG lResult;
    INT i;
    HKEY hKey;

    //
    // Unregister GPE
    //

    StringFromGUID2 (CLSID_GPESnapIn, szSnapInKey, 50);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szSnapInKey, 50);
        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szSnapInKey);
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }

    //
    // Unregister RSOP
    //

    StringFromGUID2 (CLSID_RSOPSnapIn, szSnapInKey, 50);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_RsopNameSpace[dwIndex].pNodeID, szSnapInKey, 50); // undone
        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szSnapInKey);
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }


    //
    // Unregister GPO
    //

    StringFromGUID2 (CLSID_GroupPolicyObject, szSnapInKey, 50);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);


    //
    // Unregister AboutGPE
    //

    StringFromGUID2 (CLSID_AboutGPE, szSnapInKey, 50);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);


    //
    // Unregister RSOPAboutGPE
    //

    StringFromGUID2 (CLSID_RSOPAboutGPE, szSnapInKey, 50);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);


    //
    // Unregister GPM
    //

    StringFromGUID2 (CLSID_GPMSnapIn, szSnapInKey, 50);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        lstrcpy (szGUID, szDSAdminNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), szGUID);

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }


    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        lstrcpy (szGUID, szSiteMgrNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), szGUID);

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }

    //
    // Unregister rsop context menu
    //


    StringFromGUID2 (CLSID_RSOP_CMenu, szSnapInKey, 50);
    wsprintf (szSubKey, TEXT("CLSID\\%s"), szSnapInKey);
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // from ds admin nodes
    //

    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        lstrcpy (szGUID, szDSAdminNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), szGUID);

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }


    for (i=0; i < ARRAYSIZE(szDSAdminRsopTargetNodes); i++)
    {
        lstrcpy (szGUID, szDSAdminRsopTargetNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), szGUID);

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }
    
    //
    // from sites node
    //

    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        lstrcpy (szGUID, szSiteMgrNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), szGUID);

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }



    for (i=0; i < ARRAYSIZE(szDSTreeSnapinNodes); i++)
    {
        lstrcpy (szGUID, szDSTreeSnapinNodes[i]);

        wsprintf (szSubKey, TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), szGUID);

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\gpmgr.h ===
//
// Structures
//

typedef struct _GPOITEM
{
    DWORD   dwOptions;
    LPTSTR  lpDisplayName;
    LPTSTR  lpGPOName;
    LPTSTR  lpDSPath;
    DWORD   dwDisabled;   // see GPO_OPTION_DISABLE_* flags in gpedit.h
    BOOL    bReadOnly;
    BOOL    bLocked;
} GPOITEM, *LPGPOITEM;

typedef struct _ADDGPOITEM
{
    LPTSTR  lpDSName;
    BOOL    bSpawn;
    LPTSTR  lpName;
    LPTSTR  lpPath;
    LPTSTR  lpImport;
} ADDGPOITEM, *LPADDGPOITEM;


//
// CGroupPolicyMgr class
//

class CGroupPolicyMgr:
    public IExtendPropertySheet,
    public ISnapinHelp
{

protected:
    UINT                        m_cRef;
    LPTSTR                      m_lpDSObject;
    LPTSTR                      m_lpGPODCName;
    LPTSTR                      m_lpDSADCName;
    LPTSTR                      m_lpDomainName;
    HFONT                       m_hDefaultFont;
    HFONT                       m_hMarlettFont;
    BOOL                        m_bReadOnly;
    BOOL                        m_bDirty;
    GROUP_POLICY_HINT_TYPE      m_gpHint;

    static unsigned int         m_cfDSObjectName;
    static unsigned int         m_cfNodeTypeString;

public:
    CGroupPolicyMgr();
    ~CGroupPolicyMgr();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);

private:

    static UINT CALLBACK PropSheetPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    static INT_PTR CALLBACK GPMDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void OnContextMenu(HWND hDlg, LPARAM lParam);
    void OnProperties(HWND hDlg);
    void OnNew(HWND hDlg);
    BOOL RefreshGPM (HWND hDlg, BOOL bInitial);
    BOOL OnInitDialog (HWND hDlg);
    BOOL Save (HWND hDlg);
    BOOL AddGPOs (HWND hDlg, LPTSTR lpGPOList);
    LPGPOITEM CreateEntry (LPTSTR szName, LPTSTR szGPO, DWORD dwOptions,
                           DWORD dwDisabled, BOOL bReadOnly);
    BOOL AddGPOToList (HWND hLV, LPTSTR szName, LPTSTR szGPO, DWORD dwOptions, BOOL bHighest, DWORD dwDisabled, BOOL bReadOnly);
    static BOOL CALLBACK AddGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RemoveGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK DeleteGPODlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK LinkOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK NoDSObjectDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    DWORD IsGPODisabled(LPTSTR lpGPO);
    void CheckIconStatus (HWND hLV, LPGPOITEM lpGPO);
    LPTSTR GetFullGPOPath (LPTSTR lpGPO, HWND hParent);
    BOOL StartGPE (LPTSTR lpGPO, HWND hParent);
};



//
// ComponentData class factory
//


class CGroupPolicyMgrCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CGroupPolicyMgrCF();
    ~CGroupPolicyMgrCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


//
// Strings
//

#define GPM_NAME_PROPERTY      L"name"
#define GPM_OPTIONS_PROPERTY   L"gPOptions"
#define GPM_LINK_PROPERTY      L"gPLink"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\registry.h ===
//
// RegistryHive class
//

class CRegistryHive:
    public IUnknown
{

protected:
    ULONG                m_cRef;
    HKEY                 m_hKey;
    LPTSTR               m_lpFileName;
    LPTSTR               m_lpKeyName;
    LPTSTR               m_lpEventName;
    HANDLE               m_hEvent;

public:
    CRegistryHive();
    ~CRegistryHive();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented Internal methods
    //

    STDMETHODIMP         Initialize(LPTSTR lpFileName, LPTSTR lpKeyName);
    STDMETHODIMP         GetHKey(HKEY *hKey);
    STDMETHODIMP         Save(VOID);
    STDMETHODIMP         ExportKey(HKEY hKey, HANDLE hFile, LPWSTR lpKeyName);
    STDMETHODIMP         WriteValue(HANDLE hFile, LPWSTR lpKeyName,
                                    LPWSTR lpValueName, DWORD dwType,
                                    DWORD dwDataLength, LPBYTE lpData);
    STDMETHODIMP         Load(VOID);
    STDMETHODIMP         IsRegistryEmpty(BOOL *bEmpty);
};


//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1

//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


//
// Max keyname size
//

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\main.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <tchar.h>
#define SECURITY_WIN32
#include <security.h>
#include <lm.h>
#include <lmdfs.h>
#include <ole2.h>
#include <iads.h>
#include <iadsp.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <dsrole.h>
#include <mmc.h>
#include <accctrl.h>
#include <aclapi.h>
#include <winsock2.h>
#include <richedit.h>
#include <gpedit.h>
#ifndef RC_INVOKED
#include <wbemcli.h>
#include <ntdsapi.h>
#endif
#define _USERENV_NO_LINK_APIS_ 1
#include <userenv.h>
#include <userenvp.h>
#include <dssec.h>

class CSnapIn;

#include "structs.h"
#include "registry.h"
#include "compdata.h"
#include "snapin.h"
#include "events.h"
#include "rsoproot.h"
#include "rsopsnap.h"
#include "about.h"
#include "dataobj.h"
#include "rsopdobj.h"
#include "gpmgr.h"
#include "smartptr.h"
#include "guidlist.h"
#include "gpobj.h"
#include "debug.h"
#include "util.h"
#include "sid.h"

//
// Resource ids
//

#define IDS_SNAPIN_NAME           1
#define IDS_SNAPIN_EXT_NAME       2
#define IDS_GPM_SNAPIN_NAME       3
#define IDS_RSOP_SNAPIN_NAME      4
#define IDS_DCOPTIONS             5
#define IDS_DCOPTIONSDESC         6
#define IDS_UNKNOWNREASON         7
#define IDS_DISPLAYNAME2          8
#define IDS_DISPLAYNAME           9
#define IDS_NOTAPPLICABLE        10
#define IDS_DATETIMEFORMAT       11
#define IDS_REVISIONFORMAT       12
#define IDS_NAMEFORMAT           13
#define IDS_NONE                 14
#define IDS_NOTSPECIFIED         15
#define IDS_ARCHIVEDATA          16
#define IDS_ARCHIVEDATADESC      17
#define IDS_ARCHIVEDATATAG       18
#define IDS_ARCHIVEDATA_CAPTION  19
#define IDS_ARCHIVEDATA_MESSAGE  20
#define IDS_DIAGNOSTIC           21
#define IDS_PLANNING             22
#define IDS_VERSION              23
#define IDS_VERSIONFORMAT        24
#define IDS_WMIFILTERFAILED      25
#define IDS_DISABLEDGPO          26
#define IDS_GPM_FORESTDESC       27
#define IDS_NAME                 28
#define IDS_MACHINE              29
#define IDS_USER                 30
#define IDS_SERVERAPPS           31
#define IDS_DEVICES              32
#define IDS_WINSETTINGS          33
#define IDS_SWSETTINGS           34
#define IDS_COMPUTERTITLE        35
#define IDS_UNTITLED             36
#define IDS_LOCAL_NAME           37
#define IDS_LOCAL_DISPLAY_NAME   38
#define IDS_REMOTE_DISPLAY_NAME  39

#define IDS_GPM_NAME             40
#define IDS_GPM_NOOVERRIDE       41
#define IDS_GPM_DISABLED         42
#define IDS_GPM_DESCRIPTION      43
#define IDS_GPM_NOGPONAME        44
#define IDS_GPM_ADDTITLE         45
#define IDS_GPM_DCNAME           46
#define IDS_GPM_DOMAINNAME       47
#define IDS_APPLIED              48
#define IDS_SECURITYDENIED       49
#define IDS_SNAPIN_DESCRIPT      50
#define IDS_PROVIDER_NAME        51
#define IDS_SNAPIN_VERSION       52
#define IDS_ABOUT_NAME           53
#define IDS_RSOP_SNAPIN_DESCRIPT 54
#define IDS_RSOP_ABOUT_NAME      55
#define IDS_RSOP_DETAILS         56
#define IDS_RSOP_SETTINGS        57
#define IDS_INVALIDMSC           58
#define IDS_ACCESSDENIED         59
#define IDS_FILTERING            60
#define IDS_SOM                  61
#define IDS_DISABLEDLINK         62
#define IDS_RSOP_DISPLAYNAME1    63
#define IDS_RSOP_DISPLAYNAME2    64
#define IDS_RSOP_FINISH_P0       65
#define IDS_RSOP_FINISH_P1       66
#define IDS_RSOP_FINISH_P2       67
#define IDS_RSOP_FINISH_P3       68
#define IDS_RSOP_FINISH_P4       69
#define IDS_RSOP_FINISH_P5       70
#define IDS_RSOP_FINISH_P6       71
#define IDS_RSOP_FINISH_P7       72
#define IDS_RSOP_FINISH_P8       73
#define IDS_RSOP_FINISH_P9       74
#define IDS_RSOP_FINISH_P10      75

#define IDS_BROWSE_USER_OU_TITLE 76
#define IDS_BROWSE_USER_OU_CAPTION 77
#define IDS_BROWSE_COMPUTER_OU_TITLE 78
#define IDS_BROWSE_COMPUTER_OU_CAPTION 79
#define IDS_RSOP_GPOLIST_MACHINE 80
#define IDS_RSOP_GPOLIST_USER    81

#define IDS_TITLE_WELCOME        82
#define IDS_TITLE_CHOOSEMODE     83
#define IDS_SUBTITLE_CHOOSEMODE  84
#define IDS_TITLE_GETCOMP        85
#define IDS_SUBTITLE_GETCOMP     86
//#define IDS_TITLE_GETUSER       305
#define IDS_SUBTITLE_GETUSER     87
#define IDS_TITLE_FINISHED       88
#define IDS_SUBTITLE_FINISHED    89
#define IDS_TITLE_GETTARGET      90
#define IDS_SUBTITLE_GETTARGET   91
#define IDS_TITLE_GETDC          92
#define IDS_SUBTITLE_GETDC       93
#define IDS_TITLE_ALTDIRS        94
#define IDS_SUBTITLE_ALTDIRS     95
#define IDS_TITLE_USERSECGRPS    96
#define IDS_SUBTITLE_USERSECGRPS 97
#define IDS_TITLE_COMPSECGRPS    98
#define IDS_SUBTITLE_COMPSECGRPS 99

#define IDS_GPO_NAME            100
#define IDS_ACCESSDENIED2       101
#define IDS_FAILEDLOCAL         102
#define IDS_FAILEDREMOTE        103
#define IDS_FAILEDDS            104
#define IDS_FAILEDNEW           105
#define IDS_FAILEDDELETE        106
#define IDS_FAILEDLINK          107
#define IDS_FAILEDUNLINK        108
#define IDS_FAILEDSETNAME       109
#define IDS_FAILEDGPLINK        110

#define IDS_FAILEDGPINFO        115
#define IDS_FAILEDGPQUERY       116
#define IDS_FAILEDGPODELETE     117
#define IDS_SPAWNGPEFAILED      118
#define IDS_NODC                119
#define IDS_NODSDC              120
#define IDS_DELETECONFIRM       121
#define IDS_CONFIRMTITLE        122
#define IDS_CONFIRMDISABLE      123
#define IDS_CONFIRMTITLE2       124

#define IDS_NODC_ERROR_TEXT     130
#define IDS_NODC_ERROR_TITLE    131
#define IDS_NODC_OPTIONS_TEXT   132
#define IDS_NODC_OPTIONS_TITLE  133

#define IDS_EXECFAILED_USER     136
#define IDS_EXECFAILED_COMPUTER 137
#define IDS_NOUSER2             138
#define IDS_NOCOMPUTER2         139
#define IDS_NODSOBJECT_MSG      140
#define IDS_BADUSERSOM          141
#define IDS_BADCOMPUTERSOM      142
#define IDS_NOUSER              143
#define IDS_NOCOMPUTER          144
#define IDS_NOUSERCONTAINER     145
#define IDS_NOCOMPUTERCONTAINER 146
#define IDS_EXECFAILED          147
#define IDS_CONNECTSERVERFAILED 148
#define IDS_RSOPLOGGINGDISABLED 149
#define IDS_RSOPLOGGINGTITLE    150

#define IDS_CAPTION             151
#define IDS_OPENBUTTON          152
#define IDS_DOMAINS             153
#define IDS_SITES               154
#define IDS_COMPUTERS           155
#define IDS_ALL                 156
#define IDS_NEWGPO              157

#define IDS_NAMECOLUMN          160
#define IDS_DOMAINCOLUMN        161
#define IDS_ALLDESCRIPTION      162
#define IDS_DOMAINDESCRIPTION   163
#define IDS_SITEDESCRIPTION     164
#define IDS_TOOLTIP_BACK        165
#define IDS_TOOLTIP_NEW         166
#define IDS_TOOLTIP_ROTATE      167
#define IDS_STOP                169
#define IDS_FINDNOW             170
#define IDS_FOREST              171
#define IDS_FORESTHEADING       172

#define IDS_TITLE_WQLUSER       180
#define IDS_SUBTITLE_WQL        181
#define IDS_TITLE_WQLCOMP       182

#define IDS_RSOP_FINISH_P11     190
#define IDS_RSOP_FINISH_P12     191
#define IDS_RSOP_FINISH_P13     192
#define IDS_YES                 193
#define IDS_NO                  194
#define IDS_NORSOPDC            195
#define IDS_DSBINDFAILED        196
#define IDS_DOMAINLIST          197
#define IDS_FAILEDPROPERTIES    198
#define IDS_NODATA              199
#define IDS_DCMISSINGRSOP       200

#define IDS_COMPONENT_NAME      225
#define IDS_STATUS              226
#define IDS_SUCCESS             227
#define IDS_FAILED              228
#define IDS_PENDING             229
#define IDS_SUCCESSMSG          230
#define IDS_FAILEDMSG1          231
#define IDS_PENDINGMSG          232
#define IDS_LOGGINGFAILED       233
#define IDS_OVERRIDE            234
#define IDS_WARNING             235
#define IDS_CSE_NA              236
#define IDS_SUCCESS2            237
#define IDS_FAILED2             238
#define IDS_SYNC_REQUIRED       239

#define IDS_ERRORFILTER         240
#define IDS_FAILEDMSG2          241

#define IDS_DISPLAYPROPERTIES   250
#define IDS_MACHINE_DESC        251
#define IDS_USER_DESC           252
#define IDS_U_SWSETTINGS_DESC   253
#define IDS_U_WINSETTINGS_DESC  254
#define IDS_C_SWSETTINGS_DESC   255
#define IDS_C_WINSETTINGS_DESC  256
#define IDS_CSEFAILURE_DESC     257
#define IDS_CSEFAILURE2_DESC    258

#define IDS_GPE_WELCOME         270
#define IDS_MISSINGFILTER       271
#define IDS_WMIFILTERMISSING    272

#define IDS_ADDITIONALINFO      275
#define IDS_GPCOREFAIL          276
#define IDS_LEGACYCSE           277
#define IDS_LEGACYCSE1          278
#define IDS_ENUMUSERSFAILED     279
#define IDS_DOWNLEVELCOMPUTER   280
#define IDS_PLEASEWAIT          281
#define IDS_RSOP_FINISH_P14     282
#define IDS_RSOP_FINISH_P15     283
#define IDS_RSOP_PLANNING       284
#define IDS_RSOP_CMENU_NAME     285
#define IDS_RSOP_LOGGING        286

#define IDS_BLOCKEDSOM          287
#define IDS_SKIPWQLFILTER       289
#define IDS_NONESELECTED        290
#define IDS_GPCORE_LOGGINGFAIL  291

#define IDS_RSOP_FINISH_P16	    292
#define IDS_LOOPBACK_REPLACE	293
#define IDS_LOOPBACK_MERGE	    294

#define IDS_EXECFAILED_BOTH     295
#define IDS_EXECFAILED_TIMEDOUT 296
#define IDS_PLEASEWAIT1         297
#define IDS_DEFDC_DOWNLEVEL     298
#define IDS_DEFDC_CONNECTFAILED 299
#define IDS_WMIFILTERFORCEDNONE 300
#define IDS_RSOPWMIQRYFMT       301
#define IDS_RSOPDELNAMESPACE    302
#define IDS_RSOPDELNS_TITLE     303
#define IDS_INVALID_NAMESPACE   304

#define IDS_TITLE_GETUSER       305


#define IDS_LARGEFONTNAME       306
#define IDS_LARGEFONTSIZE       307
#define IDS_SMALLFONTNAME       308
#define IDS_SMALLFONTSIZE       309


//
// Icons
//

#define IDI_POLICY                1
#define IDI_POLICY2               2
#define IDI_POLICY3               3
#define IDA_FIND                  4




//
// Bitmaps
//

#define IDB_16x16                 101
#define IDB_32x32                 102
#define IDB_WIZARD                103
#define IDB_POLICY16              104
#define IDB_POLICY32              105
#define IDB_HEADER                106


//
// Menu items
//

#define IDM_DCOPTIONS             1
#define IDM_ARCHIVEDATA           2

#define IDM_GPM_CONTEXTMENU      10
#define IDM_GPM_NOOVERRIDE       11
#define IDM_GPM_DISABLED         12
#define IDM_GPM_NEW              13
#define IDM_GPM_ADD              14
#define IDM_GPM_EDIT             15
#define IDM_GPM_DELETE           16
#define IDM_GPM_RENAME           17
#define IDM_GPM_REFRESH          18
#define IDM_GPM_PROPERTIES       19

#define IDM_GPOLIST_CONTEXTMENU  30
#define IDM_GPOLIST_EDIT         31
#define IDM_GPOLIST_SECURITY     32


//
// Error dialog defines
//

#define IDD_ERROR               200
#define IDC_ERRORTEXT           201
#define IDC_DETAILSBORDER       202
#define IDC_DETAILSTEXT         203
#define IDC_ERROR_ICON          204


//
// Properties dialog defines
//

#define IDD_PROPERTIES          500
#define IDC_TITLE               501
#define IDC_DISABLE_TEXT        502
#define IDC_DISABLE_COMPUTER    503
#define IDC_DISABLE_USER        504
#define IDC_CREATE_DATE         505
#define IDC_MODIFIED_DATE       506
#define IDC_REVISION            507
#define IDC_DOMAIN              508
#define IDC_UNIQUE_NAME         509
#define IDC_DOMAIN_HEADING      510

#define IDD_GPE_LINKS           550
#define IDC_RESULTLIST          551
#define IDI_FIND                552
#define IDC_CBDOMAIN            553
#define IDC_ACTION              554
#define IDAC_FIND               555

#define IDD_WQLFILTER           560
#define IDC_NONE                561
#define IDC_THIS_FILTER         562
#define IDC_FILTER_NAME         563
#define IDC_FILTER_BROWSE       564

//
// Choose dialog defines
//

#define IDD_CHOOSE_INTRO        900
#define IDC_BITMAP              901
#define IDC_DS_GPO              902
#define IDC_MACHINE_GPO         903
#define IDC_CAPTION             904

#define IDD_CHOOSE_DS           925
#define IDC_OPEN                926
#define IDC_OPEN_TITLE          927
#define IDC_OPEN_NAME           928
#define IDC_OPEN_BROWSE         929
#define IDC_NEW                 930
#define IDC_NEW_TITLE           931
#define IDC_NEW_NAME            932
#define IDC_NEW_TITLE2          933
#define IDC_NEW_DOMAIN          934
#define IDC_COPY_FROM           935
#define IDC_COPY_NAME           936
#define IDC_COPY_BROWSE         937
#define IDC_OVERRIDE            938
#define IDC_SPAWN               939

#define IDD_CHOOSE_MACHINE      950
#define IDC_LOCAL               951
#define IDC_REMOTE              952
#define IDC_NAME                953
#define IDC_BROWSE              954

#define IDD_ADD_GPO             975



//
// Browse dialog defines
//

#define IDC_STATIC                -1
#define IDD_BROWSEGPO             1000
#define IDC_BROWSE_LIST           1001
#define IDC_DOMAIN_LIST           1002
#define IDC_BROWSE_DELETE         1003

#define IDD_BROWSE2_DIALOG        1202
#define IDD_PROPPAGE_GPOBROWSER   1203
#define IDR_MAINFRAME             1228
#define IDR_TOOLBAR1              1229
#define IDR_LISTMENU              1234
#define IDD_PROPPAGE_COMPUTERS    1237

#define IDC_BUTTON1               1300
#define IDC_LIST1                 1301
#define IDC_COMBO1                1302
#define IDC_RADIO1                1304
#define IDC_RADIO2                1305
#define IDC_EDIT1                 1306
#define IDC_STATIC1               1307
#define IDC_DESCRIPTION           1308

#define ID_BACKBUTTON             32771
#define ID_NEWFOLDER              32772
#define ID_ROTATEVIEW             32773
#define ID_DETAILSVIEW            32774
#define ID_SMALLICONS             32776
#define ID_LIST                   32780
#define ID_DETAILS                32781
#define ID_LARGEICONS             32782
#define ID_TOP_FOO                32783
#define ID_NEW                    32783
#define ID_EDIT                   32784
#define ID_DELETE                 32788
#define ID_RENAME                 32789
#define ID_REFRESH                32790
#define ID_PROPERTIES             32792
#define ID_TOP_LINEUPICONS        32794
#define ID_ARRANGE_BYNAME         32795
#define ID_ARRANGE_BYTYPE         32796
#define ID_ARRANGE_AUTO           32797


//
// Group Policy Manager dialog defines
//

#define IDD_GPMANAGER            1025
#define IDC_GPM_TITLE            1026
#define IDC_GPM_DCNAME           1027
#define IDC_GPM_LIST             1028
#define IDC_GPM_UP               1029
#define IDC_GPM_DOWN             1030
#define IDC_GPM_ADD              1031
#define IDC_GPM_EDIT             1032
#define IDC_GPM_DELETE           1033
#define IDC_GPM_PROPERTIES       1034
#define IDC_GPM_BLOCK            1035
#define IDC_GPM_NEW              1036
#define IDC_GPM_OPTIONS          1037
#define IDC_GPM_ICON             1038
#define IDC_GPM_LINE1            1039
#define IDD_GPM_LINK_OPTIONS     1040
#define IDC_GPM_NOOVERRIDE       1041
#define IDC_GPM_DISABLED         1042
#define IDC_GPM_PRIORITY         1043
#define IDC_GPM_LINE2            1044

//
// Remove GPO dialog defines
//

#define IDD_REMOVE_GPO           1050
#define IDC_REMOVE_TITLE         1051
#define IDC_REMOVE_LIST          1052
#define IDC_REMOVE_DS            1053
#define IDC_QUESTION             1054


//
// No DC dialog
//

#define IDD_NODC                 1060
#define IDC_NODC_TEXT            1061
#define IDC_NODC_ERROR           1062
#define IDC_NODC_PDC             1063
#define IDC_NODC_INHERIT         1064
#define IDC_NODC_ANYDC           1065


//
// Missing DS object dialog
//

#define IDD_NODSOBJECT           1070
#define IDC_NODSOBJECT_ICON      1071
#define IDC_NODSOBJECT_TEXT      1072


//
// RSOP welcome dialog
//

#define IDD_RSOP_WELCOME                1090

//
// RSOP choose mode dialog (diag vs planning)
//

#define IDD_RSOP_CHOOSEMODE             1091



#define IDD_RSOP_WQLUSER                1088
#define IDD_RSOP_WQLCOMP                1089

#define IDD_RSOP_GETCOMP                1092
#define IDD_RSOP_GETUSER                1093
#define IDD_RSOP_GETTARGET              1094
#define IDD_RSOP_GETDC                  1095
#define IDD_RSOP_ALTDIRS                1096
#define IDD_RSOP_ALTUSERSEC             1097
#define IDD_RSOP_ALTCOMPSEC             1098
#define IDD_RSOP_FINISHED               1099
//#define IDD_RSOP_FINISHED2              1105
//#define IDD_RSOP_FINISHED3              1106

#define IDD_RSOP_GPOLIST                1100
#define IDD_CHOOSEDC                    1101
#define IDD_RSOP_QUERY                  1102
#define IDD_RSOP_ERRORS                 1103
#define IDD_RSOP_BROWSEDC               1104
#define IDD_RSOP_FINISHED2              1105
#define IDD_RSOP_FINISHED3              1106

#define IDC_RSOP_BIG_BOLD1              1107


#define IDD_BROWSE2_DIALOG              1202
#define IDD_PROPPAGE_GPOBROWSER         1203
#define IDR_MAINFRAME                   1228
#define IDR_TOOLBAR1                    1229
#define IDR_LISTMENU                    1234
#define IDD_PROPPAGE_COMPUTERS          1237
#define IDC_BUTTON1                     1300
#define IDC_BUTTON2                     1310
#define IDC_COMBO1                      1302
#define IDC_BUTTON3                     1302
#define IDC_COMBO2                      1303
#define IDC_RADIO1                      1304
#define IDC_RADIO2                      1305
#define IDC_EDIT1                       1306
#define IDC_STATIC1                     1307
#define IDC_EDIT2                       1307
#define IDC_DESCRIPTION                 1308
#define IDC_EDIT3                       1308
#define IDC_PROGRESS1                   1401
#define IDC_DC                          1402
#define IDC_LIST2                       1403
#define IDC_CHECK1                      1404
#define IDC_RADIO3                      1405
#define IDC_RADIO4                      1406
#define IDC_BROWSE1                     1407
#define IDC_BROWSE2                     1408
#define IDC_BROWSE3                     1409
#define IDC_BROWSE4                     1410
#define IDC_EDIT4                       1411
#define IDC_EDIT5                       1412
#define IDC_EDIT6                       1413
#define IDC_CHECK2                      1414
#define IDC_CHECK3                      1415

#define IDD_RSOP_STATUSMSC              1416

//
// Help file
//

#define HELP_FILE   TEXT("gpedit.hlp")


//
// Help IDs
//

#define IDH_NOCONTEXTHELP          -1L
#define IDH_GPMGR_DCNAME            2
#define IDH_GPMGR_LIST              3
#define IDH_GPMGR_UP                4
#define IDH_GPMGR_DOWN              5
#define IDH_GPMGR_ADD               6
#define IDH_GPMGR_EDIT              7
#define IDH_GPMGR_DELETE            8
#define IDH_GPMGR_PROPERTIES        9
#define IDH_GPMGR_BLOCK            10
#define IDH_GPMGR_NEW              11
#define IDH_GPMGR_OPTIONS          12

#define IDH_GPMGR_NOOVERRIDE       13
#define IDH_GPMGR_DISABLED         14

#define IDH_PROP_TITLE             15
#define IDH_PROP_DISABLE_COMPUTER  17
#define IDH_PROP_DISABLE_USER      23

#define IDH_BROWSE_LIST            25
#define IDH_BROWSE_DOMAINS         26

#define IDH_REMOVE_LIST            36
#define IDH_REMOVE_DS              37

#define IDH_LINK_DOMAIN            40
#define IDH_LINK_BUTTON            41
#define IDH_LINK_RESULT            42

#define IDH_DC_PDC                 43
#define IDH_DC_INHERIT             44
#define IDH_DC_ANYDC               45

#define IDH_NODSOBJECT             47

#define IDH_BROWSER_LOOKIN         75
#define IDH_BROWSER_DOMAINGPO      76
#define IDH_BROWSER_SITELIST       77
#define IDH_BROWSER_GPOLIST        78
#define IDH_BROWSER_DOMAINLIST     79
#define IDH_BROWSER_FULLGPOLIST    80
#define IDH_BROWSER_LOCALCOMPUTER  81
#define IDH_BROWSER_REMOTECOMPUTER 82
#define IDH_BROWSER_BROWSE         83

#define IDH_RSOPLOGGINGDISABLED    90

#define IDH_WQL_FILTER_NONE        100
#define IDH_WQL_FILTER_THIS_FILTER 101
#define IDH_WQL_FILTER_NAME        102
#define IDH_WQL_FILTER_BROWSE      103

#define IDH_RSOP_BANNER            200
#define IDH_RSOP_CONTAINERLIST     201

#define IDH_RSOP_GPOLIST           205
#define IDH_RSOP_APPLIEDGPOS       206
#define IDH_RSOP_GPOSOM            207
#define IDH_RSOP_REVISION          208
#define IDH_RSOP_SECURITY          209
#define IDH_RSOP_EDIT              210

#define IDH_RSOP_QUERYLIST         215

#define IDH_RSOP_COMPONENTLIST     220
#define IDH_RSOP_COMPONENTDETAILS  221
#define IDH_RSOP_SAVEAS            222

#define IDH_RSOP_BROWSEDC          225


//
// Private window message used to refresh the button states
//

#define WM_REFRESHDISPLAY  (WM_USER + 532)
#define WM_BUILDWQLLIST    (WM_USER + 533)
#define WM_INITRSOP        (WM_USER + 534)

//
// Strings
//

#define USER_SECTION                TEXT("User")
#define MACHINE_SECTION             TEXT("Machine")
#define COMPUTER_SECTION            TEXT("Computer")

#define GPE_KEY                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Editor")
#define GPE_POLICIES_KEY            TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Editor")
#define DCOPTION_VALUE              TEXT("DCOption")
#define NEW_LINKS_DISABLED_VALUE    TEXT("NewGPOLinksDisabled")
#define GPO_DISPLAY_NAME_VALUE      TEXT("GPODisplayName")

//
// Global variables
//

extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;
extern DWORD g_dwNameSpaceItems;
extern NAMESPACEITEM g_NameSpace[];
extern NAMESPACEITEM g_RsopNameSpace[];
extern CRITICAL_SECTION g_DCCS;
extern TCHAR g_szDisplayProperties[];


//
// DC selection dialog
//

typedef struct _DCSELINFO
{
    BOOL    bError;
    BOOL    bAllowInherit;
    INT     iDefault;
    LPTSTR  lpDomainName;
} DCSELINFO, *LPDCSELINFO;

INT_PTR CALLBACK DCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define MAX_FRIENDLYNAME 256


#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL         0x10000000
#endif


//
// Define to manage if FOREST GPO support is enabled or disabled.
//
// If this feature is re-enabled, 2 changes need to be made to gpedit.h
//
// 1)  Add the GPO_OPEN_FOREST flag for the IGPO interface
//       #define GPO_OPEN_FOREST             0x00000004  // Open the GPO on the forest
//
// 2)  Add GPHintForest entry to the GROUP_POLICY_HINT_TYPE enumerated type
//

#define FGPO_SUPPORT 0

#define MAX_ALIGNMENT_SIZE 8

#define ALIGN_SIZE_TO_NEXTPTR( offset )   \
                    ( ((DWORD)offset + (MAX_ALIGNMENT_SIZE-1) ) & (~(MAX_ALIGNMENT_SIZE - 1) ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\guidlist.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        guidlist.cpp
//
// Contents:    Classes for marshalling, unmarshalling Guids
//
// History:     24-Oct-98       SitaramR    Created
//
//---------------------------------------------------------------------------

#include "main.h"



//*************************************************************
//
//  CGuidList::CGuidList, ~CGuidList
//
//  Purpose:    Constructor, destructor
//
//*************************************************************

CGuidList::CGuidList()
    : m_pExtGuidList(0),
      m_bGuidsChanged(FALSE)
{
}


CGuidList::~CGuidList()
{
    FreeGuidList( m_pExtGuidList );
}


void FreeGuidList( GUIDELEM *pGuidList )
{
    while ( pGuidList )
    {
        //
        // Free snapin guids
        //
        GUIDELEM *pTemp;
        GUIDELEM *pGuidSnp = pGuidList->pSnapinGuids;

        while ( pGuidSnp )
        {
            pTemp = pGuidSnp->pNext;
            delete pGuidSnp;
            pGuidSnp = pTemp;
        }

        pTemp = pGuidList->pNext;
        delete pGuidList;
        pGuidList = pTemp;
    }
}


//*************************************************************
//
//  CGuidList::UnMarshallGuids
//
//  Purpose:    Converts string representation of guids to list
//              of guids.
//
//  Parameters: pszGuids  - String to convert
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::UnMarshallGuids( TCHAR *pszGuids )
{
    //
    // Format is [{ext guid1}{snapin guid1}..{snapin guidn}][{ext guid2}...]...\0
    // Both extension and snapin guids are in ascending order.
    //

    TCHAR *pchCur = pszGuids;

    XGuidElem xGuidElem;
    GUIDELEM *pGuidExtTail = 0;

    if ( pszGuids == 0 || lstrcmpi( pszGuids, TEXT(" ") ) == 0 )
    {
        //
        // Empty property case, so nothing to unmarshall
        //

        m_pExtGuidList = 0;
        return S_OK;
    }

    //
    // Outer loop over extensions
    //

    while ( *pchCur )
    {
        if ( *pchCur == TEXT('[') )
            pchCur++;
        else
            return E_FAIL;

        GUID guidExt;
        if ( ValidateGuid( pchCur ) )
            StringToGuid( pchCur, &guidExt );
        else
            return E_FAIL;

        GUIDELEM *pGuidExt = new GUIDELEM;
        if ( pGuidExt == 0 )
            return E_OUTOFMEMORY;

        pGuidExt->guid = guidExt;
        pGuidExt->pSnapinGuids = 0;
        pGuidExt->pNext = 0;

        //
        // Append to end of list
        //

        if ( pGuidExtTail == 0 )
            xGuidElem.Set( pGuidExt );
        else
            pGuidExtTail->pNext = pGuidExt;

        pGuidExtTail = pGuidExt;

        //
        // Move past '{', then skip until next '{
        //

        pchCur++;

        while ( *pchCur && *pchCur != TEXT('{') )
            pchCur++;

        if ( !(*pchCur) )
            return E_FAIL;

        //
        // Inner loop over snapin guids
        //

        GUIDELEM *pGuidSnapinTail = 0;

        while ( *pchCur != TEXT(']') )
        {
            GUID guidSnp;

            if ( ValidateGuid( pchCur ) )
                StringToGuid( pchCur, &guidSnp );
            else
                return E_FAIL;

            GUIDELEM *pGuidSnapin = new GUIDELEM;
            if ( pGuidSnapin == 0 )
                return E_OUTOFMEMORY;

            pGuidSnapin->guid = guidSnp;
            pGuidSnapin->pSnapinGuids = 0;
            pGuidSnapin->pNext = 0;

            //
            // Append to end of list
            //

            if ( pGuidSnapinTail == 0 )
                pGuidExtTail->pSnapinGuids = pGuidSnapin;
            else
                pGuidSnapinTail->pNext = pGuidSnapin;

            pGuidSnapinTail = pGuidSnapin;

            while ( *pchCur && *pchCur != TEXT('}') )
                pchCur++;

            if ( !(*pchCur) )
                return E_FAIL;

            pchCur++;

            if ( *pchCur != TEXT('{') && *pchCur != TEXT(']') )
                return E_FAIL;
        } // inner while

        *pchCur++;

    } // outer while

    m_pExtGuidList = xGuidElem.Acquire();

    return S_OK;
}



//*************************************************************
//
//  CGuidList::MarshallGuids
//
//  Purpose:    Converts list of guids to string representation
//
//  Parameters: xValueOut  - String representation returned here
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::MarshallGuids( XPtrST<TCHAR>& xValueOut )
{
    //
    // Get count of guids to allocate sufficient space up front
    //

    DWORD dwCount = 1;

    GUIDELEM *pGuidExt = m_pExtGuidList;
    while ( pGuidExt )
    {
        dwCount++;

        GUIDELEM *pGuidSnapin = pGuidExt->pSnapinGuids;
        while ( pGuidSnapin )
        {
            dwCount++;
            pGuidSnapin = pGuidSnapin->pNext;
        }

        pGuidExt = pGuidExt->pNext;
    }

    LONG lSize = dwCount * (GUID_LENGTH + 6);

    TCHAR *pszValue = new TCHAR[lSize];
    if ( pszValue == 0 )
        return E_OUTOFMEMORY;

    xValueOut.Set( pszValue );

    TCHAR *pchCur = pszValue;

    //
    // Actual marshalling
    //
    if ( m_pExtGuidList == 0 )
    {
        //
        // Adsi doesn't commit null strings, so use ' ' instead
        //

        lstrcpy( pchCur, TEXT(" ") );
        return S_OK;
    }

    pGuidExt = m_pExtGuidList;
    while ( pGuidExt )
    {
        DmAssert( lSize > GUID_LENGTH * 2 + (pchCur-pszValue) );

        *pchCur = TEXT('[');
        pchCur++;

        GuidToString( &pGuidExt->guid, pchCur );
        pchCur += GUID_LENGTH;

        GUIDELEM *pGuidSnp = pGuidExt->pSnapinGuids;
        while ( pGuidSnp )
        {
            DmAssert( lSize > GUID_LENGTH + (pchCur-pszValue) );

            GuidToString( &pGuidSnp->guid, pchCur );
            pchCur += GUID_LENGTH;

            pGuidSnp = pGuidSnp->pNext;
        }

        *pchCur = TEXT(']');

        pchCur++;

        pGuidExt = pGuidExt->pNext;
    }

    *pchCur = 0;

    return S_OK;
}



//*************************************************************
//
//  CGuidList::Update
//
//  Purpose:    Updates in memory list with guid info
//
//  Parameters: bAdd           - Add or delete
//              pGuidExtension - Extension's guid
//              pGuidSnapin    - Snapin's guid
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::Update( BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin )
{
    HRESULT hr = E_FAIL;
    GUIDELEM *pTrailPtr = NULL;
    GUIDELEM *pCurPtr = m_pExtGuidList;

    while ( pCurPtr != NULL )
    {
        if ( *pGuidExtension == pCurPtr->guid )
        {
            hr = UpdateSnapinGuid( bAdd, pCurPtr, pGuidSnapin );
            if ( FAILED(hr) )
                return hr;

            if ( pCurPtr->pSnapinGuids == NULL )
            {
                //
                // Remove extension from list
                //

                if ( pTrailPtr == NULL )
                    m_pExtGuidList = pCurPtr->pNext;
                else
                    pTrailPtr->pNext = pCurPtr->pNext;

                delete pCurPtr;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else if ( CompareGuid( pGuidExtension, &pCurPtr->guid ) < 0 )
        {
            //
            // Since guids are in ascending order,
            // pGuidExtension is not in list, add if necessary
            //

            if ( bAdd )
            {
                GUIDELEM *pGuidExt = new GUIDELEM;
                if ( pGuidExt == 0 )
                    return E_OUTOFMEMORY;

                pGuidExt->pSnapinGuids = new GUIDELEM;
                if ( pGuidExt->pSnapinGuids == 0 )
                {
                    delete pGuidExt;
                    return E_OUTOFMEMORY;
                }

                pGuidExt->guid = *pGuidExtension;
                pGuidExt->pNext = pCurPtr;

                pGuidExt->pSnapinGuids->guid = *pGuidSnapin;
                pGuidExt->pSnapinGuids->pSnapinGuids = 0;
                pGuidExt->pSnapinGuids->pNext = 0;

                if ( pTrailPtr == 0)
                    m_pExtGuidList = pGuidExt;
                else
                    pTrailPtr->pNext = pGuidExt;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else // compareguid
        {
            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;
        }
    } // while


    //
    // End of list or null list, add guid at end if necessary
    //
    if ( bAdd )
    {
        GUIDELEM *pGuidExt = new GUIDELEM;
        if ( pGuidExt == 0 )
            return E_OUTOFMEMORY;

        pGuidExt->pSnapinGuids = new GUIDELEM;
        if ( pGuidExt->pSnapinGuids == 0 )
        {
            delete pGuidExt;
            return E_OUTOFMEMORY;
        }

        pGuidExt->guid = *pGuidExtension;
        pGuidExt->pNext = 0;

        pGuidExt->pSnapinGuids->guid = *pGuidSnapin;
        pGuidExt->pSnapinGuids->pSnapinGuids = 0;
        pGuidExt->pSnapinGuids->pNext = 0;

        if ( pTrailPtr == 0)
            m_pExtGuidList = pGuidExt;
        else
            pTrailPtr->pNext = pGuidExt;

        m_bGuidsChanged = TRUE;
    }

    return S_OK;
}



//*************************************************************
//
//  CGuidList::UpdateSnapinGuid
//
//  Purpose:    Updates snapin list with guid info
//
//  Parameters: bAdd           - Add or delete
//              pExtGuid       - Extension's guid ptr
//              pGuidSnapin    - Snapin's guid
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::UpdateSnapinGuid( BOOL bAdd, GUIDELEM *pExtGuid,
                                     GUID *pGuidSnapin )
{
    GUIDELEM *pTrailPtr = 0;
    GUIDELEM *pCurPtr = pExtGuid->pSnapinGuids;

    while ( pCurPtr != NULL )
    {
        if ( *pGuidSnapin == pCurPtr->guid )
        {
            if ( !bAdd )
            {
                if ( pTrailPtr == NULL )
                    pExtGuid->pSnapinGuids = pCurPtr->pNext;
                else
                    pTrailPtr->pNext = pCurPtr->pNext;

                delete pCurPtr;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else if ( CompareGuid( pGuidSnapin, &pCurPtr->guid ) < 0 )
        {
            //
            // Since guids are in ascending order,
            // pGuidSnapin is not in list, add if necessary
            //

            if ( bAdd )
            {
                GUIDELEM *pGuidSnp = new GUIDELEM;
                if ( pGuidSnp == 0 )
                    return E_OUTOFMEMORY;

                pGuidSnp->guid = *pGuidSnapin;
                pGuidSnp->pSnapinGuids = 0;
                pGuidSnp->pNext = pCurPtr;

                if ( pTrailPtr == NULL )
                    pExtGuid->pSnapinGuids = pGuidSnp;
                else
                    pTrailPtr->pNext = pGuidSnp;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else
        {
            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;
        }
    } // while

    //
    // End of list or null list, add guid at end if necessary
    //
    if ( bAdd )
    {
        GUIDELEM *pGuidSnp = new GUIDELEM;
        if ( pGuidSnp == 0 )
            return E_OUTOFMEMORY;

        pGuidSnp->guid = *pGuidSnapin;
        pGuidSnp->pSnapinGuids = 0;
        pGuidSnp->pNext = 0;

        if ( pTrailPtr == 0 )
            pExtGuid->pSnapinGuids = pGuidSnp;
        else
            pTrailPtr->pNext = pGuidSnp;

        m_bGuidsChanged = TRUE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsopdobj.cpp ===
#include "main.h"
#include <initguid.h>
#include "dataobj.h"
#include "rsopdobj.h"


unsigned int CRSOPDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CRSOPDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CRSOPDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CRSOPDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CRSOPDataObject::m_cfPreloads       = RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
unsigned int CRSOPDataObject::m_cfNodeID         = RegisterClipboardFormat(CCF_NODEID);
unsigned int CRSOPDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CRSOPDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject implementation                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CRSOPDataObject::CRSOPDataObject(CRSOPComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CRSOPDataObject::~CRSOPDataObject()
{
    m_pcd->Release();
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (IUnknown)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CRSOPDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IRSOPInformation))
    {
        *ppv = (LPRSOPINFORMATION)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IRSOPDataObject))
    {
        *ppv = (LPRSOPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CRSOPDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CRSOPDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (IDataObject)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfPreloads)
    {
        hr = CreatePreloadsData(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;
            TCHAR szDesc[300];

            IStream *lpStream = lpMedium->pstm;

            if(lpStream)
            {
                LoadString (g_hInstance, g_RsopNameSpace[m_cookie].iStringDescID, szDesc, ARRAYSIZE(szDesc));
                hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);

                if (SUCCEEDED(hr))
                {
                    if ((m_cookie == 0) && (m_pcd->m_bComputerCSEError || m_pcd->m_bUserCSEError))
                    {
                        LoadString (g_hInstance, IDS_CSEFAILURE2_DESC, szDesc, ARRAYSIZE(szDesc));
                        hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
                    }

                    if (((m_cookie == 1) && m_pcd->m_bComputerCSEError) ||
                        ((m_cookie == 2) && m_pcd->m_bUserCSEError))
                    {
                        LoadString (g_hInstance, IDS_CSEFAILURE_DESC, szDesc, ARRAYSIZE(szDesc));
                        hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
                    }
                }
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if ((m_cookie == 0) || (m_cookie == 1) || (m_cookie == 2))
            {
                IStream *lpStream = lpMedium->pstm;

                if(lpStream)
                {
                    hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CRSOPDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeID)
    {
        hr = CreateNodeIDData(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (IROSPInformation)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CRSOPDataObject::GetNamespace (DWORD dwSection, LPOLESTR pszName, int cchMaxLength)
{
    return m_pcd->GetNamespace(dwSection, pszName, cchMaxLength);
}

STDMETHODIMP CRSOPDataObject::GetFlags (DWORD * pdwFlags)
{
    return m_pcd->GetFlags(pdwFlags);
}

STDMETHODIMP CRSOPDataObject::GetEventLogEntryText (LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                                    LPOLESTR pszEventTime, DWORD dwEventID,
                                                     LPOLESTR *ppszText)
{
    return m_pcd->GetEventLogEntryText(pszEventSource, pszEventLogName, pszEventTime, dwEventID, ppszText);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (Internal functions)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CRSOPDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CRSOPDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_RsopNameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_RsopNameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CRSOPDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_RsopNameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_RsopNameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CRSOPDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[300];

    //
    // This is the display named used in the scope pane and snap-in manager
    //

    szDisplayName[0] = TEXT('\0');

    if (m_pcd->m_pDisplayName)
    //if (m_pcd->m_pGPO && m_pcd->m_pDisplayName)
    {
        lstrcpy (szDisplayName, m_pcd->m_pDisplayName);
    }
    else
    {
        LoadStringW (g_hInstance, IDS_RSOP_SNAPIN_NAME, szDisplayName, ARRAYSIZE(szDisplayName));
    }

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CRSOPDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPESnapIn, sizeof(CLSID), lpMedium);
}

HRESULT CRSOPDataObject::CreatePreloadsData(LPSTGMEDIUM lpMedium)
{
    BOOL bPreload = TRUE;

    return Create((LPVOID)&bPreload, sizeof(bPreload), lpMedium);
}

HRESULT CRSOPDataObject::CreateNodeIDData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];
    SNodeID * psNode;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_RsopNameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_RsopNameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    lpMedium->hGlobal = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, (lstrlen(szNodeType) * sizeof(TCHAR)) + sizeof(SNodeID));

    if (!lpMedium->hGlobal)
    {
        return (STG_E_MEDIUMFULL);
    }

    psNode = (SNodeID *) GlobalLock (lpMedium->hGlobal);

    psNode->cBytes = lstrlen(szNodeType) * sizeof(TCHAR);
    CopyMemory (psNode->id, szNodeType, psNode->cBytes);

    GlobalUnlock (lpMedium->hGlobal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\guidlist.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        guidlist.h
//
// Contents:    Classes for marshalling, unmarshalling Guids
//
// History:     24-Oct-98       SitaramR    Created
//
//---------------------------------------------------------------------------

#pragma once

typedef struct _GUIDELEM
{
    GUID                guid;           // Extension guid
    struct _GUIDELEM *  pSnapinGuids;   // List of snapin guids
    struct _GUIDELEM *  pNext;          // Singly linked list ptr
} GUIDELEM, *LPGUIDELEM;

void FreeGuidList( LPGUIDELEM pGuidList );

class CGuidList
{

public:
    CGuidList();
    ~CGuidList();

    HRESULT MarshallGuids( XPtrST<TCHAR> & xValueOut );
    HRESULT UnMarshallGuids( TCHAR *pszGuids );

    HRESULT Update( BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin );
    BOOL GuidsChanged()        { return m_bGuidsChanged; }

private:
    HRESULT UpdateSnapinGuid( BOOL bAdd, GUIDELEM *pCurPtr, GUID *pGuidSnapin );

    GUIDELEM *  m_pExtGuidList;
    BOOL        m_bGuidsChanged;
};



//*************************************************************
//
//  XGuidElem
//
//  Purpose:    Smart pointer for GUIDELEM list
//
//*************************************************************

class XGuidElem
{

public:
    XGuidElem()
       : m_pGuidList(0)
    {
    }

    ~XGuidElem()
    {
        FreeGuidList( m_pGuidList );
    }

    void Set( GUIDELEM *pGuidList )
    {
        m_pGuidList = pGuidList;
    }

    GUIDELEM *Acquire()
    {
        GUIDELEM *pTemp = m_pGuidList;
        m_pGuidList = 0;
        
        return pTemp;
    }


private:
    GUIDELEM *m_pGuidList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsopdobj.h ===
//
// IRSOPDataObject interface id
//

// {4AE19823-BCEE-11d0-9484-080036B11A03}
DEFINE_GUID(IID_IRSOPDataObject, 0x4ae19823, 0xbcee, 0x11d0, 0x94, 0x84, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);



#ifndef _RSOPDOBJ_H_
#define _RSOPDOBJ_H_

//
// This is a private dataobject interface for GPE.
// When the GPE snapin receives a dataobject and needs to determine
// if it came from the GPE snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IRSOPDataObject
DECLARE_INTERFACE_(IRSOPDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IRSOPDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IRSOPDataObject *LPRSOPDATAOBJECT;



//
// CRSOPDataObject class
//

class CRSOPDataObject : public IDataObject,
                    public IRSOPInformation,
                    public IRSOPDataObject
{
    friend class CSnapIn;

protected:

    ULONG                  m_cRef;
    CRSOPComponentData    *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfPreloads;
    static unsigned int    m_cfNodeID;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CRSOPDataObject(CRSOPComponentData *pComponent);
    ~CRSOPDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IRSOPInformation methods
    //

    STDMETHOD(GetNamespace) (DWORD dwSection, LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetFlags) (DWORD * pdwFlags);
    STDMETHOD(GetEventLogEntryText) (LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                     LPOLESTR pszEventTime, DWORD dwEventID, LPOLESTR *ppszText);


    //
    // Implemented IRSOPDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreatePreloadsData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeIDData(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _RSOPDOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\newbrows.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       newbrows.cpp
//
//  Contents:   implementation of the new GPO browser
//
//  Functions:  BrowseForGPO
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "browser.h"
#include "compspp.h"

int CALLBACK PSCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam);

//+--------------------------------------------------------------------------
//
//  Function:   BrowseForGPO
//
//  Synopsis:   the GPO browser
//
//  Arguments:  [lpBrowseInfo] - structure that defines the behavior of the
//                                browser and contains the results
//
//  Returns:    S_OK - success
//
//  Modifies:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT BrowseForGPO(LPGPOBROWSEINFO lpBrowseInfo)
{
    LPOLESTR szCaption;
    if (NULL != lpBrowseInfo->lpTitle)
    {
        szCaption = lpBrowseInfo->lpTitle;
    }
    else
    {
        szCaption = new OLECHAR[256];
        if (szCaption)
        {
            LoadString(g_hInstance, IDS_CAPTION, szCaption, 256);
        }
    }

    // bind to lpBrowseInfo->lpInitialOU and see if it is a site
    BOOL fSite = FALSE;

    IADs * pADs = NULL;
    HRESULT hr = OpenDSObject(lpBrowseInfo->lpInitialOU, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        VARIANT var;
        VariantInit(&var);
        BSTR bstrProperty = SysAllocString(L"objectClass");

        if (bstrProperty)
        {
            hr = pADs->Get(bstrProperty, &var);
            if (SUCCEEDED(hr))
            {
                int cElements = var.parray->rgsabound[0].cElements;
                VARIANT * rgData = (VARIANT *)var.parray->pvData;
                while (cElements--)
                {
                    if (0 == _wcsicmp(L"site", rgData[cElements].bstrVal))
                    {
                        fSite = TRUE;
                    }
                }
            }
            SysFreeString(bstrProperty);
        }
        VariantClear(&var);
        pADs->Release();
    }

    HPROPSHEETPAGE hpage[4];
    int nPage = 0;
    int nStartPage = 0;

    void * pActive;

    CBrowserPP ppDomains;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NODSGPOS))
        hpage[nPage++]= ppDomains.Initialize(PAGETYPE_DOMAINS, lpBrowseInfo, &pActive);
    CBrowserPP ppSites;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NODSGPOS))
    {
        if (fSite)
        {
            nStartPage = nPage;
        }
        hpage[nPage++]= ppSites.Initialize(PAGETYPE_SITES, lpBrowseInfo, &pActive);
    }
    CCompsPP ppComputers;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NOCOMPUTERS))
        hpage[nPage++]= ppComputers.Initialize(PAGETYPE_COMPUTERS, lpBrowseInfo, &pActive);
    CBrowserPP ppAll;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NODSGPOS))
    {
        if (lpBrowseInfo->dwFlags & GPO_BROWSE_INITTOALL)
        {
            nStartPage = nPage;
        }
        hpage[nPage++]= ppAll.Initialize(PAGETYPE_ALL, lpBrowseInfo, &pActive);
    }

    PROPSHEETHEADER psh;
    memset(&psh, 0, sizeof(psh));
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_NOAPPLYNOW | ((lpBrowseInfo->dwFlags & GPO_BROWSE_OPENBUTTON) ? PSH_USECALLBACK : 0);
    psh.hwndParent = lpBrowseInfo->hwndOwner;
    psh.pszCaption = szCaption;
    psh.nPages = nPage;
    psh.phpage = hpage;
    psh.pfnCallback = PSCallback;
    psh.nStartPage = nStartPage;

    int iReturn = (int)PropertySheet(&psh);


    if (szCaption && (szCaption != lpBrowseInfo->lpTitle))
    {
        delete [] szCaption;
    }

    if (IDOK == iReturn)
    {
        return S_OK;
    }
    else
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
}

//+--------------------------------------------------------------------------
//
//  Function:   PSCallback
//
//  Synopsis:   Callback function called by Windows during property sheet
//              initialization (among others).
//
//  Arguments:  [hwndDlg] - handle to the property sheet
//              [uMsg]    - message ID
//              [lParam]  - additional message specific info
//
//  Returns:    0
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This is used to change the text of the OK button
//
//---------------------------------------------------------------------------

int CALLBACK PSCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    if (uMsg == PSCB_INITIALIZED)
    {
        TCHAR szOpen[64];

        LoadString(g_hInstance, IDS_OPENBUTTON, szOpen, ARRAYSIZE(szOpen));
        SetDlgItemText(hwndDlg, IDOK, szOpen);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\registry.cpp ===
#include "main.h"

const WCHAR g_cOpenBracket = L'[';
const WCHAR g_cCloseBracket = L']';
const WCHAR g_cSemiColon = L';';

#define TEMP_LOCATION    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Objects")
#define REG_EVENT_NAME   TEXT("Group Policy registry event name for ")

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRegistryHive object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRegistryHive::CRegistryHive()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hKey = NULL;
    m_hEvent = NULL;
    m_lpFileName = m_lpKeyName = m_lpEventName = NULL;
}

CRegistryHive::~CRegistryHive()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRegistryHive object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CRegistryHive::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPUNKNOWN)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CRegistryHive::AddRef (void)
{
    return ++m_cRef;
}

ULONG CRegistryHive::Release (void)
{
    if (--m_cRef == 0) {

        if (m_hKey)
        {
            RegCloseKey (m_hKey);

            if (m_lpKeyName)
            {
                BOOL bCleanRegistry = TRUE;


                //
                // We need to decide if the registry keys can be deleted or if
                // they are in use by another copy of GPE.  To do this, close
                // the event we created during initialization and then try to
                // open the event again.  If the event is successfully opened,
                // then another process is using the same registry key and it
                // should not be deleted.
                //

                if (m_hEvent && m_lpEventName)
                {
                    CloseHandle (m_hEvent);

                    m_hEvent = OpenEvent (SYNCHRONIZE, FALSE, m_lpEventName);

                    if (m_hEvent)
                    {
                        bCleanRegistry = FALSE;
                    }
                }


                if (bCleanRegistry)
                {
                    RegDelnode (HKEY_CURRENT_USER, m_lpKeyName);
                    RegDeleteKey (HKEY_CURRENT_USER, TEMP_LOCATION);
                }
            }
        }

        if (m_lpKeyName)
        {
            LocalFree (m_lpKeyName);
        }

        if (m_lpFileName)
        {
            LocalFree (m_lpFileName);
        }

        if (m_lpEventName)
        {
            LocalFree (m_lpEventName);
        }

        if (m_hEvent)
        {
            CloseHandle (m_hEvent);
        }

        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRegistryHive object implementation (Public functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryHive::Initialize(LPTSTR lpFileName, LPTSTR lpKeyName)
{
    TCHAR szBuffer[300];
    INT i;
    LONG lResult;
    DWORD dwDisp;
    HRESULT hr;


    //
    // Check for null pointer
    //

    if (!lpFileName || !(*lpFileName))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Null filename")));
        return E_INVALIDARG;
    }


    //
    // Make sure this object hasn't been initialized already
    //

    if (m_hKey || m_lpFileName || m_lpKeyName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Object already initialized")));
        return (E_UNEXPECTED);
    }


    //
    // Find a temporary registry key to work with
    //

    lstrcpy (szBuffer, TEMP_LOCATION);
    lstrcat (szBuffer, TEXT("\\"));
    lstrcat (szBuffer, lpKeyName);

    lResult = RegCreateKeyEx (HKEY_CURRENT_USER, szBuffer, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                              NULL, &m_hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to open registry key with %d"), lResult));
        return (HRESULT_FROM_WIN32(lResult));
    }


    //
    // Store the keyname
    //

    m_lpKeyName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) + 1) * sizeof(TCHAR));

    if (!m_lpKeyName)
    {
        RegCloseKey (m_hKey);
        m_hKey = NULL;
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to allocate memory for KeyName")));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    lstrcpy (m_lpKeyName, szBuffer);


    //
    // Store the filename
    //

    m_lpFileName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpFileName) + 1) * sizeof(TCHAR));

    if (!m_lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to allocate memory for filename")));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    lstrcpy (m_lpFileName, lpFileName);


    //
    // Store the event name
    //

    lstrcpy (szBuffer, REG_EVENT_NAME);
    lstrcat (szBuffer, lpKeyName);

    m_lpEventName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szBuffer) + 1) * sizeof(TCHAR));

    if (!m_lpEventName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to allocate memory for filename")));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    lstrcpy (m_lpEventName, szBuffer);


    //
    // Load the file if it exists
    //

    hr =  Load();

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Create the registry event
    //

    m_hEvent = CreateEvent (NULL, FALSE, FALSE, m_lpEventName);

    if (!m_hEvent)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to create registry event with %d"),
                 GetLastError()));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    return (S_OK);
}

STDMETHODIMP CRegistryHive::GetHKey(HKEY *hKey)
{
    HRESULT hr = E_FAIL;

    *hKey = NULL;

    if (m_hKey)
    {
        if (DuplicateHandle (GetCurrentProcess(),
                              (HANDLE)m_hKey,
                              GetCurrentProcess(),
                              (LPHANDLE) hKey, 0,
                              TRUE, DUPLICATE_SAME_ACCESS))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

STDMETHODIMP CRegistryHive::Save(VOID)
{
    HANDLE hFile;
    HRESULT hr;
    DWORD dwTemp, dwBytesWritten;
    LPWSTR lpKeyName;


    //
    // Check parameters
    //

    if (!m_hKey || !m_lpFileName || !m_lpKeyName)
    {
        return E_INVALIDARG;
    }


    //
    // Allocate a buffer to hold the keyname
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Create the output file
    //

    hFile = CreateFile (m_lpFileName, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LocalFree (lpKeyName);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Write the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    dwTemp = REGFILE_SIGNATURE;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Save: Failed to write signature with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    dwTemp = REGISTRY_FILE_VERSION;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Save: Failed to write version number with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Exports the values / keys
    //

    hr = ExportKey (m_hKey, hFile, lpKeyName);


Exit:

    //
    // Finished
    //

    CloseHandle (hFile);
    LocalFree (lpKeyName);

    return hr;
}


STDMETHODIMP CRegistryHive::ExportKey(HKEY hKey, HANDLE hFile, LPWSTR lpKeyName)
{
    HRESULT hr = S_OK;
    DWORD dwBytesWritten, dwNameSize, dwDataSize, dwKeySize;
    DWORD dwIndex, dwTemp1, dwTemp2, dwType, dwKeyCount = 0;
    LONG  lResult;
    HKEY  hSubKey;
    LPWSTR lpValueName = NULL;
    LPWSTR lpSubKeyName = NULL;
    LPBYTE lpValueData = NULL;
    LPWSTR lpEnd;



    //
    // Gather information about this key
    //

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeyCount, &dwKeySize, NULL,
                               NULL, &dwNameSize, &dwDataSize, NULL, NULL);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to query registry key information with %d"),
                 lResult));
        return HRESULT_FROM_WIN32(lResult);
    }


    //
    // Allocate buffers to work with
    //

    lpValueName = (LPWSTR) LocalAlloc (LPTR, (dwNameSize + 1) * sizeof(WCHAR));

    if (!lpValueName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to alloc memory with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    lpValueData = (LPBYTE) LocalAlloc (LPTR, dwDataSize);

    if (!lpValueData)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to alloc memory with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Enumerate the values and write them to the file
    //

    dwIndex = 0;

    while (TRUE)
    {
        dwTemp1 = dwNameSize + 1;
        dwTemp2 = dwDataSize;
        *lpValueName = L'\0';

        lResult = RegEnumValueW (hKey, dwIndex, lpValueName, &dwTemp1, NULL,
                                 &dwType, lpValueData, &dwTemp2);

        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: RegEnumValue failed with %d"),
                     lResult));
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        hr = WriteValue(hFile, lpKeyName, lpValueName, dwType, dwTemp2, lpValueData);

        if (hr != S_OK)
            goto Exit;

        dwIndex++;
    }


    //
    // If dwIndex is 0, this is an empty key.  We need to special case this
    // so the empty key is entered into the registry file when there are
    // no subkeys under it.
    //

    if ((dwIndex == 0) && (dwKeyCount == 0) && (*lpKeyName))
    {
        hr = WriteValue(hFile, lpKeyName, lpValueName, REG_NONE, 0, lpValueData);

        if (hr != S_OK)
            goto Exit;
    }


    LocalFree (lpValueName);
    lpValueName = NULL;

    LocalFree (lpValueData);
    lpValueData = NULL;


    //
    // Now process the sub keys
    //

    lpSubKeyName = (LPWSTR) LocalAlloc (LPTR, (dwKeySize + 1) * sizeof(WCHAR));

    if (!lpSubKeyName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to alloc memory with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    dwIndex = 0;

    if (*lpKeyName)
        lpEnd = CheckSlash (lpKeyName);
    else
        lpEnd = lpKeyName;

    while (TRUE)
    {
        dwTemp1 = dwKeySize + 1;
        lResult = RegEnumKeyEx (hKey, dwIndex, lpSubKeyName, &dwTemp1,
                                NULL, NULL, NULL, NULL);

        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: RegEnumKeyEx failed with %d"),
                     lResult));
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        lstrcpy (lpEnd, lpSubKeyName);

        lResult = RegOpenKeyEx (hKey, lpSubKeyName, 0, KEY_READ, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            hr = ExportKey (hSubKey, hFile, lpKeyName);
            RegCloseKey (hSubKey);

            if (hr != S_OK)
                break;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: RegOpenKeyEx failed with %d"),
                     lResult));
        }

        dwIndex++;
    }


Exit:

    if (lpValueName)
        LocalFree (lpValueName);

    if (lpValueData)
        LocalFree (lpValueData);

    if (lpSubKeyName)
        LocalFree (lpSubKeyName);

    return hr;

}

STDMETHODIMP CRegistryHive::WriteValue(HANDLE hFile, LPWSTR lpKeyName,
                                       LPWSTR lpValueName, DWORD dwType,
                                       DWORD dwDataLength, LPBYTE lpData)
{
    HRESULT hr = S_OK;
    DWORD dwBytesWritten;
    DWORD dwTemp;


    //
    // Write the entry to the text file.
    //
    // Format:
    //
    // [keyname;valuename;type;datalength;data]
    //

    // open bracket
    if (!WriteFile (hFile, &g_cOpenBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write open bracket with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // key name
    dwTemp = (lstrlen (lpKeyName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpKeyName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write key name with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // value name
    dwTemp = (lstrlen (lpValueName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpValueName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write value name with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // type
    if (!WriteFile (hFile, &dwType, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write data type with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // data length
    if (!WriteFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write data type with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // data
    if (!WriteFile (hFile, lpData, dwDataLength, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwDataLength)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write data with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // close bracket
    if (!WriteFile (hFile, &g_cCloseBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write close bracket with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CRegistryHive::WriteValue:  Successfully wrote: %s\\%s"),
             lpKeyName, lpValueName));


Exit:

    return hr;
}


STDMETHODIMP CRegistryHive::Load(VOID)
{
    HANDLE hFile;
    HRESULT hr = S_OK;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength, dwDisp;
    LPWSTR lpKeyName, lpValueName, lpTemp;
    LPBYTE lpData;
    WCHAR  chTemp;
    HKEY hSubKey;
    LONG lResult;


    //
    // Check parameters
    //

    if (!m_hKey || !m_lpFileName || !m_lpKeyName)
    {
        return E_INVALIDARG;
    }


    //
    // Open the registry file
    //

    hFile = CreateFile (m_lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            return S_OK;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: CreateFile failed for <%s> with %d"),
                     m_lpFileName, GetLastError()));
            return (HRESULT_FROM_WIN32(GetLastError()));
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to allocate memory with %d"),
                 GetLastError()));
        CloseHandle (hFile);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to allocate memory with %d"),
                 GetLastError()));
        LocalFree (lpKeyName);
        CloseHandle (hFile);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read signature with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Invalid file signature")));
        hr = E_FAIL;
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read version number with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Invalid file version")));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read first character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            goto Exit;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            goto Exit;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read keyname character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;

        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read first character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            goto Exit;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            goto Exit;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read valuename character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read first character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            goto Exit;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            goto Exit;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read type with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to skip semicolon with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to data length with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to skip semicolon with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to allocate memory for data with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read data with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to skip closing bracket with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        if (chTemp != L']')
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Expected to find ], but found %c"),
                     chTemp));
            hr = E_FAIL;
            goto Exit;
        }



        //
        // Save registry value
        //

        lResult = RegCreateKeyEx (m_hKey, lpKeyName, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_WRITE, NULL, &hSubKey, &dwDisp);

        if (lResult == ERROR_SUCCESS)
        {

            if ((dwType == REG_NONE) && (dwDataLength == 0) &&
                (*lpValueName == L'\0'))
            {
                lResult = ERROR_SUCCESS;
            }
            else
            {
                lResult = RegSetValueEx (hSubKey, lpValueName, 0, dwType,
                                         lpData, dwDataLength);
            }

            RegCloseKey (hSubKey);

            if (lResult != ERROR_SUCCESS)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to set value <%s> with %d"),
                         lpValueName, lResult));
                hr = HRESULT_FROM_WIN32(lResult);
                LocalFree (lpData);
                goto Exit;
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to open key <%s> with %d"),
                     lpKeyName, lResult));
            hr = HRESULT_FROM_WIN32(lResult);
            LocalFree (lpData);
            goto Exit;
        }

        LocalFree (lpData);

    }

Exit:

    //
    // Finished
    //

    CloseHandle (hFile);
    LocalFree (lpKeyName);
    LocalFree (lpValueName);

    return hr;
}


STDMETHODIMP CRegistryHive::IsRegistryEmpty(BOOL *bEmpty)
{
    HRESULT hr = ERROR_SUCCESS;
    DWORD dwKeys, dwValues;
    LONG lResult;

    if (!m_hKey)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::IsRegistryEmpty: registry key not open yet")));
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }


    lResult = RegQueryInfoKey(m_hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL, &dwValues,
                              NULL, NULL, NULL, NULL);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::IsRegistryEmpty: RegQueryInfoKey failed with %d"),
                  lResult));
        return HRESULT_FROM_WIN32(lResult);
    }

    if ((dwKeys == 0) && (dwValues == 0))
    {
        *bEmpty = TRUE;
        DebugMsg((DM_VERBOSE, TEXT("CRegistryHive::IsRegistryEmpty: registry key is empty")));
    }
    else
    {
        *bEmpty = FALSE;
        DebugMsg((DM_VERBOSE, TEXT("CRegistryHive::IsRegistryEmpty: registry key is not empty.  Keys = %d, Values = %d"),
                 dwKeys, dwValues));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\snapins\gpedit\rsoproot.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoproot.h
//
//  Contents:   Definitions for the RSOP Snap-In classes
//
//  Classes:    CRSOPComponentData - Root RSOP snap-in node
//              CRSOPComponentDataCF - class factory for RSOPComponentData
//
//  Functions:
//
//  History:    09-13-1999   stevebl   Created
//
//---------------------------------------------------------------------------


//
// RSOP gpo list data structure
//

typedef struct tagGPOLISTITEM {
    LPTSTR  lpGPOName;
    LPTSTR  lpDSPath;
    LPTSTR  lpSOM;
    LPTSTR  lpUnescapedSOM;
    LPTSTR  lpFiltering;
    LPBYTE  pSD;
    DWORD   dwVersion;
    BOOL    bApplied;
    struct tagGPOLISTITEM * pNext;
} GPOLISTITEM, *LPGPOLISTITEM;


//
// RSOP CSE data structure
//

typedef struct tagCSEITEM {
    LPTSTR lpName;
    LPTSTR lpGUID;
    DWORD  dwStatus;
    ULONG  ulLoggingStatus;
    SYSTEMTIME BeginTime;
    SYSTEMTIME EndTime;
    LPSOURCEENTRY lpEventSources;
    struct tagCSEITEM *pNext;
} CSEITEM, *LPCSEITEM;

//
// Enumerator for tracking loopback mode
//
typedef enum tagLoopbackMode
{
	LoopbackNone,
	LoopbackReplace,
	LoopbackMerge
} LOOPBACKMODE;

//
// CRSOPComponentData class
//
class CRSOPComponentData:
    public IComponentData,
    public IExtendPropertySheet2,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CRSOPDataObject;
    friend class CRSOPSnapIn;

protected:
    ULONG                          m_cRef;
    HWND                           m_hwndFrame;
    BOOL                           m_bOverride;
    BOOL                           m_bDirty;
    BOOL                           m_bRefocusInit;
    BOOL                           m_bArchiveData;
    BOOL                           m_bViewIsArchivedData;
    TCHAR                          m_szArchivedDataGuid[50];
    LPCONSOLENAMESPACE             m_pScope;
    LPCONSOLE                      m_pConsole;
    HSCOPEITEM                     m_hRoot;
    HSCOPEITEM                     m_hMachine;
    HSCOPEITEM                     m_hUser;

    // properties that identify the RSOP data namespace
    LPTSTR                         m_pDisplayName;
    BOOL                           m_bDiagnostic;
    LPTSTR                         m_szNamespace;
    BOOL                           m_bInitialized;

    // properties used by the wizard to determine the RSOP data namespace
    LPTSTR                         m_szComputerName;
    LPTSTR                         m_szComputerDNName;
    LPTSTR                         m_szComputerSOM;
    LPTSTR                         m_szDefaultComputerSOM;
    SAFEARRAY *                    m_saComputerSecurityGroups;
    DWORD     *                    m_saComputerSecurityGroupsAttr;
    SAFEARRAY *                    m_saDefaultComputerSecurityGroups;
    DWORD     *                    m_saDefaultComputerSecurityGroupsAttr;
    SAFEARRAY *                    m_saComputerWQLFilters;
    SAFEARRAY *                    m_saComputerWQLFilterNames;
    SAFEARRAY *                    m_saDefaultComputerWQLFilters;
    SAFEARRAY *                    m_saDefaultComputerWQLFilterNames;
    BOOL                           m_bSkipComputerWQLFilter;
    BOOL                           m_bSkipUserWQLFilter;
    IDirectoryObject *             m_pComputerObject;
    BOOL                           m_bNoComputerData;  // only used in diagnostic mode
    BOOL                           m_bComputerDeniedAccess;

    LPTSTR                         m_szSite;
    LPTSTR                         m_szDC;
    BOOL                           m_bSlowLink;
	LOOPBACKMODE				   m_loopbackMode;

    LPTSTR                         m_szUserName;
    LPTSTR                         m_szUserDNName;
    LPTSTR                         m_szUserDisplayName;  // only used in diagnostic mode
    LPTSTR                         m_szUserSOM;
    LPTSTR                         m_szDefaultUserSOM;
    SAFEARRAY *                    m_saUserSecurityGroups;
    DWORD     *                    m_saUserSecurityGroupsAttr;
    SAFEARRAY *                    m_saDefaultUserSecurityGroups;
    DWORD     *                    m_saDefaultUserSecurityGroupsAttr;
    SAFEARRAY *                    m_saUserWQLFilters;
    SAFEARRAY *                    m_saUserWQLFilterNames;
    SAFEARRAY *                    m_saDefaultUserWQLFilters;
    SAFEARRAY *                    m_saDefaultUserWQLFilterNames;
    IDirectoryObject *             m_pUserObject;
    BOOL                           m_bNoUserData;  // only used in diagnostic mode
    BOOL                           m_bUserDeniedAccess;

    DWORD                          m_dwSkippedFrom;

    HBITMAP                        m_hChooseBitmap;

    // GPO List data
    LPGPOLISTITEM                  m_pUserGPOList;
    LPGPOLISTITEM                  m_pComputerGPOList;

    // CSE list data
    LPCSEITEM                      m_pUserCSEList;
    LPCSEITEM                      m_pComputerCSEList;
    BOOL                           m_bUserCSEError;
    BOOL                           m_bComputerCSEError;
    BOOL                           m_bUserGPCoreError;
    BOOL                           m_bComputerGPCoreError;
    HMODULE                        m_hRichEdit;

    // cmd line args to the msc file
    LPTSTR                         m_szUserSOMPref;
    LPTSTR                         m_szComputerSOMPref;
    LPTSTR                         m_szUserNamePref;
    LPTSTR                         m_szComputerNamePref;
    LPTSTR                         m_szSitePref;
    LPTSTR                         m_szDCPref;
    
    DWORD                          m_dwLoadFlags;

    // Event log data
    CEvents *                      m_pEvents;

    IStream *                      m_pStm;

public:
    CRSOPComponentData();
    ~CRSOPComponentData();
    VOID FreeUserData (VOID);
    VOID FreeComputerData (VOID);


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IExtendPropertySheet2 methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);
    STDMETHODIMP         GetWatermarks(LPDATAOBJECT lpIDataObject,  HBITMAP* lphWatermark,
                                       HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* pbStretch);



    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);


    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);

    STDMETHODIMP         CopyFileToMSC (LPTSTR lpFileName, IStream *pStm);
    STDMETHODIMP         InitializeRSOPFromArchivedData(IStream *pStm);
    STDMETHODIMP         CreateNameSpace (LPTSTR lpNameSpace, LPTSTR lpParentNameSpace);
    STDMETHODIMP         CopyMSCToFile (IStream *pStm, LPTSTR *lpMofFileName);
    STDMETHODIMP         BuildDisplayName (void);

    //
    // Helpers for IRSOPInformation
    //
    STDMETHODIMP         GetNamespace(DWORD dwSection, LPOLESTR pszNamespace, INT ccMaxLength);
    STDMETHODIMP         GetFlags(DWORD * pdwFlags);
    STDMETHODIMP         GetEventLogEntryText(LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                              LPOLESTR pszEventTime, DWORD dwEventID, LPOLESTR *ppszText);

    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);

    VOID AddSiteToDlg (HWND hDlg, LPWSTR szSitePath);
    VOID InitializeSitesInfo (HWND hDlg);
    BOOL IsComputerRSoPEnabled(LPTSTR lpDCName);
    VOID InitializeDCInfo (HWND hDlg);
    VOID AddDefaultGroups (HWND hLB);
    VOID GetPrimaryGroup (HWND hLB, IDirectoryObject * pDSObj);
    HRESULT BuildMembershipList (HWND hLB, IDirectoryObject * pDSObj, SAFEARRAY ** psaSecGrp, DWORD ** pdwSecGrpAttr);
    HRESULT SaveSecurityGroups (HWND hLB, SAFEARRAY ** psaSecGrp, DWORD ** pdwSecGrpAttr);
    VOID FillListFromSafeArraySecurityGroup (HWND hLB, SAFEARRAY * psa, DWORD *psaSecGrpAttr);
    VOID FillListFromSafeArrays (HWND hLB, SAFEARRAY * psaNames, SAFEARRAY * psaData);
    HRESULT ExtractWQLFilters (LPTSTR lpNameSpace, SAFEARRAY **psaNamesArg, SAFEARRAY **psaDataArg);
    VOID BuildWQLFilterList (HWND hLB, BOOL bUser, SAFEARRAY **psaNames, SAFEARRAY **psaData);
    VOID SaveWQLFilters (HWND hLB, SAFEARRAY **psaNamesArg, SAFEARRAY **psaDataArg);
    BOOL CompareSafeArrays(SAFEARRAY *psa1, SAFEARRAY *psa2);
    LPTSTR GetDefaultSOM (LPTSTR lpDNName);
    LPTSTR GetDomainFromSOM (LPTSTR lpSOM);
    HRESULT TestSOM (LPTSTR lpSOM, HWND hDlg);
    HRESULT FillUserList (HWND hList, BOOL *bCurrentUserFound);
    void FillResultsList (HWND hLV);
    void InitializeResultsList (HWND hLV);
    BOOL TestAndValidateComputer(HWND hDlg);
    VOID EscapeString (LPTSTR *lpString);
    static INT CALLBACK DsBrowseCallback (HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
    void OnSecurity(HWND hDlg);
    void OnEdit(HWND hDlg);
    void OnContextMenu(HWND hDlg, LPARAM lParam);
    void OnRefreshDisplay(HWND hDlg);
    BOOL AddGPOListNode(LPTSTR lpGPOName, LPTSTR lpDSPath, LPTSTR lpSOM, LPTSTR lpFiltering,
                        DWORD dwVersion, BOOL bFiltering, LPBYTE pSD, DWORD dwSDSize,
                        LPGPOLISTITEM *lpList);
    VOID FreeGPOListData(LPGPOLISTITEM lpList);
    void BuildGPOList (LPGPOLISTITEM * lpList, LPTSTR lpNamespace);
    void BuildGPOLists (void);
    void PrepGPOList(HWND hList, BOOL bSOM, BOOL bFiltering,
                     BOOL bVersion, DWORD dwCount);
    void FillGPOList(HWND hDlg, DWORD dwListID, LPGPOLISTITEM lpList,
                     BOOL bSOM, BOOL bFiltering, BOOL bVersion, BOOL bInitial);
    void InitializeErrorsDialog(HWND hDlg, LPCSEITEM lpList);
    void OnSaveAs (HWND hDlg);
    void RefreshErrorInfo (HWND hDlg);
    BOOL AddCSENode(LPTSTR lpName, LPTSTR lpGUID, DWORD dwStatus,
                    ULONG ulLoggingStatus, SYSTEMTIME *pBeginTime, SYSTEMTIME *pEndTime,
                    LPCSEITEM *lpList, BOOL *bCSEError, BOOL *bGPCoreError, LPSOURCEENTRY lpSources);
    VOID FreeCSEData(LPCSEITEM lpList);
    void QueryRSoPPolicySettingStatusInstances (LPTSTR lpNamespace);
    void GetEventLogSources (IWbemServices * pNamespace,
                             LPTSTR lpCSEGUID, LPTSTR lpComputerName,
                             SYSTEMTIME *BeginTime, SYSTEMTIME *EndTime,
                             LPSOURCEENTRY *lpSources);
    void BuildCSEList (LPCSEITEM * lpList, LPTSTR lpNamespace, BOOL *bCSEError, BOOL *bGPCoreError);
    VOID BuildCSELists (void);

    LPTSTR    GetUserSOM() { return m_szUserSOM; };
    LPTSTR    GetComputerSOM() {return m_szComputerSOM; };
    LPTSTR    GetUserName() { return m_szUserName; };
    LPTSTR    GetComputerName() {return m_szComputerName; };

    HRESULT SetupFonts();
    HFONT m_BigBoldFont;
    HFONT m_BoldFont;

private:

    void SetDirty(VOID)  { m_bDirty = TRUE; }
    void ClearDirty(VOID)  { m_bDirty = FALSE; }
    BOOL ThisIsDirty(VOID) { return m_bDirty; }

    HRESULT DeleteRSOPData(LPTSTR lpNameSpace);
    HRESULT GenerateRSOPDataEx(HWND hDlg, LPTSTR *lpNameSpace);
    HRESULT GenerateRSOPData(HWND hDlg, LPTSTR *lpNameSpace, BOOL bSkipCSEs, BOOL bLimitData, BOOL bUser, BOOL bForceCreate, ULONG *pulErrorInfo);
    HRESULT InitializeRSOP(HWND hDlg);
    HRESULT InitializeRSOPFromMSC(DWORD dwFlags);
    HRESULT IsNode (LPDATAOBJECT lpDataObject, MMC_COOKIE cookie);
    HRESULT IsSnapInManager (LPDATAOBJECT lpDataObject);
    HRESULT EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
    HRESULT SetupPropertyPages(DWORD dwFlags, LPPROPERTYSHEETCALLBACK lpProvider,
                                LONG_PTR handle, LPDATAOBJECT lpDataObject);


    static INT_PTR CALLBACK RSOPWelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPChooseModeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetTargetDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPAltDirsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPAltUserSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPAltCompSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPWQLUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPWQLCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPFinishedDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPFinished2DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPChooseDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGPOListMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGPOListUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPErrorsMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPErrorsUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK QueryDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK BrowseDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK InitRsopDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static HRESULT WINAPI ReadSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR *pSD, LPARAM lpContext);
    static HRESULT WINAPI WriteSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, LPARAM lpContext);
};

//
// class factory
//

class CRSOPComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CRSOPComponentDataCF();
    ~CRSOPComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


//
// IWbemObjectSink implementation
//

class CCreateSessionSink : public IWbemObjectSink
{
protected:
    ULONG m_cRef;
    HWND  m_hProgress;
    DWORD  m_dwThread;
    HRESULT m_hrSuccess;
    BSTR    m_pNameSpace;
    ULONG   m_ulErrorInfo;
    BOOL    m_bSendQuitMessage;

public:
    CCreateSessionSink(HWND hProgress, DWORD dwThread);
    ~CCreateSessionSink();

    STDMETHODIMP SendQuitMessage (BOOL bSendQuitMessage);
    STDMETHODIMP GetResult (HRESULT *hSuccess);
    STDMETHODIMP GetNamespace (BSTR *pNamespace);
    STDMETHODIMP GetErrorInfo (ULONG *pulErrorInfo);

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IWbemObjectSink methods
    STDMETHODIMP Indicate(LONG lObjectCount, IWbemClassObject **apObjArray);
    STDMETHODIMP SetStatus(LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject *pObjParam);
};



//
// AboutGPE class factory
//


class CRSOPCMenuCF : public IClassFactory
{
protected:
    LONG  m_cRef;

public:
    CRSOPCMenuCF();
    ~CRSOPCMenuCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


#define RSOP_LAUNCH_PLANNING    1
#define RSOP_LAUNCH_LOGGING     2


//
// Group Policy Hint types
//

typedef enum _RSOP_POLICY_HINT_TYPE {
    RSOPHintUnknown = 0,                      // No link information available
    RSOPHintMachine,                          // a machine
    RSOPHintUser,                             // a user
    RSOPHintSite,                             // a site
    RSOPHintDomain,                           // a domain
    RSOPHintOrganizationalUnit,               // a organizational unit
} RSOP_POLICY_HINT_TYPE, *PRSOP_POLICY_HINT_TYPE;


class CRSOPCMenu : public IExtendContextMenu
{
protected:
    LONG                    m_cRef;
    LPWSTR                  m_lpDSObject;
    LPWSTR                  m_szDomain;
    LPWSTR                  m_szDN;
    RSOP