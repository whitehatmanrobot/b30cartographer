ODCALLTYPE IMimeSecurity_EncodeMessage_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMimeSecurity_EncodeMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeMessage_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMimeSecurity_DecodeMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_EncodeStream_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPSTREAM lpstmIn,
    /* [in] */ LPSTREAM lpstmOut);


void __RPC_STUB IMimeSecurity_EncodeStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeStream_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPSTREAM lpstmIn,
    /* [in] */ LPSTREAM lpstmOut);


void __RPC_STUB IMimeSecurity_DecodeStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_EncodeBlob_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPBLOB pIn,
    /* [out] */ LPBLOB pOut);


void __RPC_STUB IMimeSecurity_EncodeBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeBlob_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPBLOB pIn,
    /* [out] */ LPBLOB pOut);


void __RPC_STUB IMimeSecurity_DecodeBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeDetachedStream_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPSTREAM lpstmIn,
    /* [in] */ const LPSTREAM lpstmSig,
    /* [in] */ LPSTREAM lpstmOut);


void __RPC_STUB IMimeSecurity_DecodeDetachedStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DecodeDetachedBlob_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
    /* [in] */ const LPBLOB pData,
    /* [in] */ const LPBLOB pSig,
    /* [out] */ LPBLOB pOut);


void __RPC_STUB IMimeSecurity_DecodeDetachedBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_InitNew_Proxy(
    IMimeSecurity __RPC_FAR * This);


void __RPC_STUB IMimeSecurity_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_CheckInit_Proxy(
    IMimeSecurity __RPC_FAR * This);


void __RPC_STUB IMimeSecurity_CheckInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_AddCertificateToStore_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ HCAPICERTSTORE hc,
    /* [in] */ PCX509CERT pCert,
    /* [in] */ const BOOL fReplace,
    /* [in] */ const BOOL fAllowDups);


void __RPC_STUB IMimeSecurity_AddCertificateToStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_OpenSystemStore_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ LPCTSTR szProtocol,
    /* [ref][out] */ HCAPICERTSTORE __RPC_FAR *pc);


void __RPC_STUB IMimeSecurity_OpenSystemStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_CloseCertificateStore_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ HCAPICERTSTORE hc);


void __RPC_STUB IMimeSecurity_CloseCertificateStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertsFromThumbprints_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ THUMBBLOB __RPC_FAR *const rgThumbprint,
    /* [out][in] */ X509CERTRESULT __RPC_FAR *const pResults);


void __RPC_STUB IMimeSecurity_GetCertsFromThumbprints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_EnumCertificates_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ HCAPICERTSTORE hc,
    /* [in] */ DWORD dwUsage,
    /* [in] */ PCX509CERT pPrev,
    /* [retval][out] */ PCX509CERT __RPC_FAR *ppCert);


void __RPC_STUB IMimeSecurity_EnumCertificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertificateName_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [in] */ const CERTNAMETYPE cn,
    /* [retval][out] */ LPSTR __RPC_FAR *ppszName);


void __RPC_STUB IMimeSecurity_GetCertificateName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertificateThumbprint_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [retval][out] */ THUMBBLOB __RPC_FAR *const pPrint);


void __RPC_STUB IMimeSecurity_GetCertificateThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_DuplicateCertificate_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [retval][out] */ PCX509CERT __RPC_FAR *ppDupCert);


void __RPC_STUB IMimeSecurity_DuplicateCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_FreeCertificate_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [unique][in] */ const PCX509CERT pc);


void __RPC_STUB IMimeSecurity_FreeCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetMessageType_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [unique][in] */ const LPSTREAM lpstmIn,
    /* [retval][out] */ SECURETYPE __RPC_FAR *pst);


void __RPC_STUB IMimeSecurity_GetMessageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_VerifyTimeValidity_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert);


void __RPC_STUB IMimeSecurity_VerifyTimeValidity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurity_GetCertData_Proxy(
    IMimeSecurity __RPC_FAR * This,
    /* [in] */ const PCX509CERT pX509Cert,
    /* [in] */ const CERTDATAID dataid,
    /* [ref][out] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeSecurity_GetCertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeSecurity_INTERFACE_DEFINED__ */


#ifndef __IMimeSecurityOptions_INTERFACE_DEFINED__
#define __IMimeSecurityOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeSecurityOptions
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][ref][helpstring][uuid] */


typedef /* [unique] */ IMimeSecurityOptions __RPC_FAR *LPMIMESECURITYOPTIONS;

typedef /* [unique] */ const IMimeSecurityOptions __RPC_FAR *LPCMIMESECURITYOPTIONS;


EXTERN_C const IID IID_IMimeSecurityOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F4-C19B-11d0-85EB-00C04FD85AB4")
    IMimeSecurityOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddChainForSenderOnCertificateInclusion( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE IncludeRecipientCertificates( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE AddChainForRecipientsOnCertificateInclusion( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsDecodedMessage( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE IncludeSendersCertificate( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSecurity(
            /* [out] */ SECURETYPE __RPC_FAR *__RPC_FAR *rgtype,
            /* [out] */ SECURESTATE __RPC_FAR *__RPC_FAR *rgstate,
            /* [out] */ ULONG __RPC_FAR *pcTypes) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetHashAlgId(
            /* [retval][out] */ ALG_ID __RPC_FAR *aid) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetEncryptionAlgId(
            /* [retval][out] */ ALG_ID __RPC_FAR *aid) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSendersThumbprints(
            /* [out] */ THUMBBLOB __RPC_FAR *__RPC_FAR *prgPrints,
            /* [out] */ DWORD __RPC_FAR *pCount) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeSecurityOptionsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeSecurityOptions __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddChainForSenderOnCertificateInclusion )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncludeRecipientCertificates )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddChainForRecipientsOnCertificateInclusion )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDecodedMessage )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncludeSendersCertificate )(
            IMimeSecurityOptions __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecurity )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [out] */ SECURETYPE __RPC_FAR *__RPC_FAR *rgtype,
            /* [out] */ SECURESTATE __RPC_FAR *__RPC_FAR *rgstate,
            /* [out] */ ULONG __RPC_FAR *pcTypes);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHashAlgId )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [retval][out] */ ALG_ID __RPC_FAR *aid);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEncryptionAlgId )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [retval][out] */ ALG_ID __RPC_FAR *aid);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSendersThumbprints )(
            IMimeSecurityOptions __RPC_FAR * This,
            /* [out] */ THUMBBLOB __RPC_FAR *__RPC_FAR *prgPrints,
            /* [out] */ DWORD __RPC_FAR *pCount);

        END_INTERFACE
    } IMimeSecurityOptionsVtbl;

    interface IMimeSecurityOptions
    {
        CONST_VTBL struct IMimeSecurityOptionsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeSecurityOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeSecurityOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeSecurityOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeSecurityOptions_AddChainForSenderOnCertificateInclusion(This)	\
    (This)->lpVtbl -> AddChainForSenderOnCertificateInclusion(This)

#define IMimeSecurityOptions_IncludeRecipientCertificates(This)	\
    (This)->lpVtbl -> IncludeRecipientCertificates(This)

#define IMimeSecurityOptions_AddChainForRecipientsOnCertificateInclusion(This)	\
    (This)->lpVtbl -> AddChainForRecipientsOnCertificateInclusion(This)

#define IMimeSecurityOptions_IsDecodedMessage(This)	\
    (This)->lpVtbl -> IsDecodedMessage(This)

#define IMimeSecurityOptions_IncludeSendersCertificate(This)	\
    (This)->lpVtbl -> IncludeSendersCertificate(This)

#define IMimeSecurityOptions_GetSecurity(This,rgtype,rgstate,pcTypes)	\
    (This)->lpVtbl -> GetSecurity(This,rgtype,rgstate,pcTypes)

#define IMimeSecurityOptions_GetHashAlgId(This,aid)	\
    (This)->lpVtbl -> GetHashAlgId(This,aid)

#define IMimeSecurityOptions_GetEncryptionAlgId(This,aid)	\
    (This)->lpVtbl -> GetEncryptionAlgId(This,aid)

#define IMimeSecurityOptions_GetSendersThumbprints(This,prgPrints,pCount)	\
    (This)->lpVtbl -> GetSendersThumbprints(This,prgPrints,pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_AddChainForSenderOnCertificateInclusion_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_AddChainForSenderOnCertificateInclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_IncludeRecipientCertificates_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_IncludeRecipientCertificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_AddChainForRecipientsOnCertificateInclusion_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_AddChainForRecipientsOnCertificateInclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_IsDecodedMessage_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_IsDecodedMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_IncludeSendersCertificate_Proxy(
    IMimeSecurityOptions __RPC_FAR * This);


void __RPC_STUB IMimeSecurityOptions_IncludeSendersCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetSecurity_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [out] */ SECURETYPE __RPC_FAR *__RPC_FAR *rgtype,
    /* [out] */ SECURESTATE __RPC_FAR *__RPC_FAR *rgstate,
    /* [out] */ ULONG __RPC_FAR *pcTypes);


void __RPC_STUB IMimeSecurityOptions_GetSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetHashAlgId_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [retval][out] */ ALG_ID __RPC_FAR *aid);


void __RPC_STUB IMimeSecurityOptions_GetHashAlgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetEncryptionAlgId_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [retval][out] */ ALG_ID __RPC_FAR *aid);


void __RPC_STUB IMimeSecurityOptions_GetEncryptionAlgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityOptions_GetSendersThumbprints_Proxy(
    IMimeSecurityOptions __RPC_FAR * This,
    /* [out] */ THUMBBLOB __RPC_FAR *__RPC_FAR *prgPrints,
    /* [out] */ DWORD __RPC_FAR *pCount);


void __RPC_STUB IMimeSecurityOptions_GetSendersThumbprints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeSecurityOptions_INTERFACE_DEFINED__ */


#ifndef __IMimeSecurityInfo_INTERFACE_DEFINED__
#define __IMimeSecurityInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeSecurityInfo
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][unique][helpstring][uuid] */


typedef /* [unique] */ IMimeSecurityInfo __RPC_FAR *LPMIMESECURITYINFO;

typedef /* [unique] */ const IMimeSecurityInfo __RPC_FAR *LPCMIMESECURITYINFO;

typedef struct  tagSECUREINFO
    {
    SECURETYPE stMsgEnhancement;
    SECURESTATE ssSign;
    SECURESTATE ssEncrypt;
    ALG_ID aidHash;
    ALG_ID aidEncryption;
    PCX509CERT pSendersCert;
    BOOL fTrustedCert;
    BOOL fCertWithMsg;
    }	SECUREINFO;

typedef struct tagSECUREINFO __RPC_FAR *PSECUREINFO;

typedef const SECUREINFO __RPC_FAR *PCSECUREINFO;


EXTERN_C const IID IID_IMimeSecurityInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F3-C19B-11d0-85EB-00C04FD85AB4")
    IMimeSecurityInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetDefaults(
            /* [in] */ IMimeSecurityOptions __RPC_FAR *pOptSet) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetDefaultsFromSI(
            /* [in] */ const SMIMEINFO __RPC_FAR *const psi) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsNew( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE DefaultsBeenSet( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetOption(
            /* [in] */ const ULONG ulOptionId,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOption(
            /* [in] */ const ULONG ulOptionId,
            /* [ref][out] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetSecurityType(
            /* [in] */ const SECURETYPE flag,
            /* [in] */ const SECURESTATE state) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSecurityState(
            /* [in] */ const SECURECLASS type,
            /* [out] */ SECURESTATE __RPC_FAR *pState) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDecodedInfo(
            /* [ref][out] */ SECUREINFO __RPC_FAR *const pInfo) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeSecurityInfoVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeSecurityInfo __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaults )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ IMimeSecurityOptions __RPC_FAR *pOptSet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultsFromSI )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const SMIMEINFO __RPC_FAR *const psi);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsNew )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefaultsBeenSet )(
            IMimeSecurityInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const ULONG ulOptionId,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const ULONG ulOptionId,
            /* [ref][out] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecurityType )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const SECURETYPE flag,
            /* [in] */ const SECURESTATE state);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecurityState )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [in] */ const SECURECLASS type,
            /* [out] */ SECURESTATE __RPC_FAR *pState);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDecodedInfo )(
            IMimeSecurityInfo __RPC_FAR * This,
            /* [ref][out] */ SECUREINFO __RPC_FAR *const pInfo);

        END_INTERFACE
    } IMimeSecurityInfoVtbl;

    interface IMimeSecurityInfo
    {
        CONST_VTBL struct IMimeSecurityInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeSecurityInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeSecurityInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeSecurityInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeSecurityInfo_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IMimeSecurityInfo_SetDefaults(This,pOptSet)	\
    (This)->lpVtbl -> SetDefaults(This,pOptSet)

#define IMimeSecurityInfo_SetDefaultsFromSI(This,psi)	\
    (This)->lpVtbl -> SetDefaultsFromSI(This,psi)

#define IMimeSecurityInfo_IsNew(This)	\
    (This)->lpVtbl -> IsNew(This)

#define IMimeSecurityInfo_DefaultsBeenSet(This)	\
    (This)->lpVtbl -> DefaultsBeenSet(This)

#define IMimeSecurityInfo_SetOption(This,ulOptionId,pValue)	\
    (This)->lpVtbl -> SetOption(This,ulOptionId,pValue)

#define IMimeSecurityInfo_GetOption(This,ulOptionId,pValue)	\
    (This)->lpVtbl -> GetOption(This,ulOptionId,pValue)

#define IMimeSecurityInfo_SetSecurityType(This,flag,state)	\
    (This)->lpVtbl -> SetSecurityType(This,flag,state)

#define IMimeSecurityInfo_GetSecurityState(This,type,pState)	\
    (This)->lpVtbl -> GetSecurityState(This,type,pState)

#define IMimeSecurityInfo_GetDecodedInfo(This,pInfo)	\
    (This)->lpVtbl -> GetDecodedInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_InitNew_Proxy(
    IMimeSecurityInfo __RPC_FAR * This);


void __RPC_STUB IMimeSecurityInfo_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetDefaults_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ IMimeSecurityOptions __RPC_FAR *pOptSet);


void __RPC_STUB IMimeSecurityInfo_SetDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetDefaultsFromSI_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const SMIMEINFO __RPC_FAR *const psi);


void __RPC_STUB IMimeSecurityInfo_SetDefaultsFromSI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_IsNew_Proxy(
    IMimeSecurityInfo __RPC_FAR * This);


void __RPC_STUB IMimeSecurityInfo_IsNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_DefaultsBeenSet_Proxy(
    IMimeSecurityInfo __RPC_FAR * This);


void __RPC_STUB IMimeSecurityInfo_DefaultsBeenSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetOption_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const ULONG ulOptionId,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeSecurityInfo_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_GetOption_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const ULONG ulOptionId,
    /* [ref][out] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeSecurityInfo_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_SetSecurityType_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const SECURETYPE flag,
    /* [in] */ const SECURESTATE state);


void __RPC_STUB IMimeSecurityInfo_SetSecurityType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_GetSecurityState_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [in] */ const SECURECLASS type,
    /* [out] */ SECURESTATE __RPC_FAR *pState);


void __RPC_STUB IMimeSecurityInfo_GetSecurityState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeSecurityInfo_GetDecodedInfo_Proxy(
    IMimeSecurityInfo __RPC_FAR * This,
    /* [ref][out] */ SECUREINFO __RPC_FAR *const pInfo);


void __RPC_STUB IMimeSecurityInfo_GetDecodedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeSecurityInfo_INTERFACE_DEFINED__ */


#ifndef __IMimeHeaderTable_INTERFACE_DEFINED__
#define __IMimeHeaderTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeHeaderTable
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef struct  tagFINDHEADER
    {
    LPCSTR pszHeader;
    DWORD dwReserved;
    }	FINDHEADER;

typedef struct tagFINDHEADER __RPC_FAR *LPFINDHEADER;

typedef struct  tagHEADERROWINFO
    {
    DWORD dwRowNumber;
    ULONG cboffStart;
    ULONG cboffColon;
    ULONG cboffEnd;
    }	HEADERROWINFO;

typedef struct tagHEADERROWINFO __RPC_FAR *LPHEADERROWINFO;

typedef
enum tagHEADERTABLEFLAGS
    {	HTF_NAMEINDATA	= 0x1,
	HTF_ENUMHANDLESONLY	= 0x2
    }	HEADERTABLEFLAGS;


EXTERN_C const IID IID_IMimeHeaderTable;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A202-C19B-11d0-85EB-00C04FD85AB4")
    IMimeHeaderTable : public IPersistStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindFirstRow(
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindNextRow(
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountRows(
            /* [in] */ LPCSTR pszHeader,
            /* [out] */ ULONG __RPC_FAR *pcRows) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendRow(
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData,
            /* [out] */ LPHHEADERROW phRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteRow(
            /* [in] */ HHEADERROW hRow) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetRowData(
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPSTR __RPC_FAR *ppszData,
            /* [out] */ ULONG __RPC_FAR *pcchData) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetRowData(
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetRowInfo(
            /* [in] */ HHEADERROW hRow,
            /* [out][in] */ LPHEADERROWINFO pInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetRowNumber(
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwRowNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumRows(
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeHeaderTable __RPC_FAR *__RPC_FAR *ppTable) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeHeaderTableVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeHeaderTable __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeHeaderTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeHeaderTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPFINDHEADER pFindHeader,
            /* [out] */ LPHHEADERROW phRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountRows )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPCSTR pszHeader,
            /* [out] */ ULONG __RPC_FAR *pcRows);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData,
            /* [out] */ LPHHEADERROW phRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteRow )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowData )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPSTR __RPC_FAR *ppszData,
            /* [out] */ ULONG __RPC_FAR *pcchData);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowData )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCSTR pszData,
            /* [in] */ ULONG cchData);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowInfo )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [out][in] */ LPHEADERROWINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowNumber )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ HHEADERROW hRow,
            /* [in] */ DWORD dwRowNumber);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRows )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ LPCSTR pszHeader,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [out] */ IMimeHeaderTable __RPC_FAR *__RPC_FAR *ppTable);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeHeaderTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        END_INTERFACE
    } IMimeHeaderTableVtbl;

    interface IMimeHeaderTable
    {
        CONST_VTBL struct IMimeHeaderTableVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeHeaderTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeHeaderTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeHeaderTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeHeaderTable_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeHeaderTable_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeHeaderTable_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeHeaderTable_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeHeaderTable_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)


#define IMimeHeaderTable_FindFirstRow(This,pFindHeader,phRow)	\
    (This)->lpVtbl -> FindFirstRow(This,pFindHeader,phRow)

#define IMimeHeaderTable_FindNextRow(This,pFindHeader,phRow)	\
    (This)->lpVtbl -> FindNextRow(This,pFindHeader,phRow)

#define IMimeHeaderTable_CountRows(This,pszHeader,pcRows)	\
    (This)->lpVtbl -> CountRows(This,pszHeader,pcRows)

#define IMimeHeaderTable_AppendRow(This,pszHeader,dwFlags,pszData,cchData,phRow)	\
    (This)->lpVtbl -> AppendRow(This,pszHeader,dwFlags,pszData,cchData,phRow)

#define IMimeHeaderTable_DeleteRow(This,hRow)	\
    (This)->lpVtbl -> DeleteRow(This,hRow)

#define IMimeHeaderTable_GetRowData(This,hRow,dwFlags,ppszData,pcchData)	\
    (This)->lpVtbl -> GetRowData(This,hRow,dwFlags,ppszData,pcchData)

#define IMimeHeaderTable_SetRowData(This,hRow,dwFlags,pszData,cchData)	\
    (This)->lpVtbl -> SetRowData(This,hRow,dwFlags,pszData,cchData)

#define IMimeHeaderTable_GetRowInfo(This,hRow,pInfo)	\
    (This)->lpVtbl -> GetRowInfo(This,hRow,pInfo)

#define IMimeHeaderTable_SetRowNumber(This,hRow,dwRowNumber)	\
    (This)->lpVtbl -> SetRowNumber(This,hRow,dwRowNumber)

#define IMimeHeaderTable_EnumRows(This,pszHeader,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumRows(This,pszHeader,dwFlags,ppEnum)

#define IMimeHeaderTable_Clone(This,ppTable)	\
    (This)->lpVtbl -> Clone(This,ppTable)

#define IMimeHeaderTable_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeHeaderTable_FindFirstRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPFINDHEADER pFindHeader,
    /* [out] */ LPHHEADERROW phRow);


void __RPC_STUB IMimeHeaderTable_FindFirstRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_FindNextRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPFINDHEADER pFindHeader,
    /* [out] */ LPHHEADERROW phRow);


void __RPC_STUB IMimeHeaderTable_FindNextRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_CountRows_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPCSTR pszHeader,
    /* [out] */ ULONG __RPC_FAR *pcRows);


void __RPC_STUB IMimeHeaderTable_CountRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_AppendRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPCSTR pszHeader,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCSTR pszData,
    /* [in] */ ULONG cchData,
    /* [out] */ LPHHEADERROW phRow);


void __RPC_STUB IMimeHeaderTable_AppendRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_DeleteRow_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow);


void __RPC_STUB IMimeHeaderTable_DeleteRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_GetRowData_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LPSTR __RPC_FAR *ppszData,
    /* [out] */ ULONG __RPC_FAR *pcchData);


void __RPC_STUB IMimeHeaderTable_GetRowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_SetRowData_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCSTR pszData,
    /* [in] */ ULONG cchData);


void __RPC_STUB IMimeHeaderTable_SetRowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_GetRowInfo_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [out][in] */ LPHEADERROWINFO pInfo);


void __RPC_STUB IMimeHeaderTable_GetRowInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_SetRowNumber_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ HHEADERROW hRow,
    /* [in] */ DWORD dwRowNumber);


void __RPC_STUB IMimeHeaderTable_SetRowNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_EnumRows_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ LPCSTR pszHeader,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeHeaderTable_EnumRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_Clone_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [out] */ IMimeHeaderTable __RPC_FAR *__RPC_FAR *ppTable);


void __RPC_STUB IMimeHeaderTable_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeHeaderTable_BindToObject_Proxy(
    IMimeHeaderTable __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimeHeaderTable_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeHeaderTable_INTERFACE_DEFINED__ */


#ifndef __IMimePropertySchema_INTERFACE_DEFINED__
#define __IMimePropertySchema_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimePropertySchema
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimePropertySchema __RPC_FAR *LPMIMEPROPERTYSCHEMA;

typedef
enum tagMIMEPROPFLAGS
    {	MPF_INETCSET	= 0x1,
	MPF_RFC1522	= 0x2,
	MPF_ADDRESS	= 0x4,
	MPF_HASPARAMS	= 0x8,
	MPF_MIME	= 0x10,
	MPF_READONLY	= 0x20
    }	MIMEPROPFLAGS;


EXTERN_C const IID IID_IMimePropertySchema;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A20A-C19B-11d0-85EB-00C04FD85AB4")
    IMimePropertySchema : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterProperty(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber,
            /* [out] */ LPDWORD pdwPropId) = 0;

        virtual HRESULT STDMETHODCALLTYPE ModifyProperty(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetPropertyId(
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwPropId) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetPropertyName(
            /* [in] */ DWORD dwPropId,
            /* [out] */ LPSTR __RPC_FAR *ppszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE RegisterAddressType(
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwAdrType) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimePropertySchemaVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimePropertySchema __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimePropertySchema __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterProperty )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber,
            /* [out] */ LPDWORD pdwPropId);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyProperty )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwRowNumber);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyId )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwPropId);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyName )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ DWORD dwPropId,
            /* [out] */ LPSTR __RPC_FAR *ppszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterAddressType )(
            IMimePropertySchema __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPDWORD pdwAdrType);

        END_INTERFACE
    } IMimePropertySchemaVtbl;

    interface IMimePropertySchema
    {
        CONST_VTBL struct IMimePropertySchemaVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimePropertySchema_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimePropertySchema_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimePropertySchema_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimePropertySchema_RegisterProperty(This,pszName,dwFlags,dwRowNumber,pdwPropId)	\
    (This)->lpVtbl -> RegisterProperty(This,pszName,dwFlags,dwRowNumber,pdwPropId)

#define IMimePropertySchema_ModifyProperty(This,pszName,dwFlags,dwRowNumber)	\
    (This)->lpVtbl -> ModifyProperty(This,pszName,dwFlags,dwRowNumber)

#define IMimePropertySchema_GetPropertyId(This,pszName,pdwPropId)	\
    (This)->lpVtbl -> GetPropertyId(This,pszName,pdwPropId)

#define IMimePropertySchema_GetPropertyName(This,dwPropId,ppszName)	\
    (This)->lpVtbl -> GetPropertyName(This,dwPropId,ppszName)

#define IMimePropertySchema_RegisterAddressType(This,pszName,pdwAdrType)	\
    (This)->lpVtbl -> RegisterAddressType(This,pszName,pdwAdrType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimePropertySchema_RegisterProperty_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRowNumber,
    /* [out] */ LPDWORD pdwPropId);


void __RPC_STUB IMimePropertySchema_RegisterProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_ModifyProperty_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRowNumber);


void __RPC_STUB IMimePropertySchema_ModifyProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_GetPropertyId_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ LPDWORD pdwPropId);


void __RPC_STUB IMimePropertySchema_GetPropertyId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_GetPropertyName_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ DWORD dwPropId,
    /* [out] */ LPSTR __RPC_FAR *ppszName);


void __RPC_STUB IMimePropertySchema_GetPropertyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySchema_RegisterAddressType_Proxy(
    IMimePropertySchema __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ LPDWORD pdwAdrType);


void __RPC_STUB IMimePropertySchema_RegisterAddressType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimePropertySchema_INTERFACE_DEFINED__ */


#ifndef __IMimePropertySet_INTERFACE_DEFINED__
#define __IMimePropertySet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimePropertySet
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimePropertySet __RPC_FAR *LPMIMEPROPERTYSET;

typedef
enum tagPROPDATAFLAGS
    {	PDF_ENCODED	= 0x1,
	PDF_NAMEINDATA	= 0x2,
	PDF_HEADERFORMAT	= 0x4 | PDF_ENCODED,
	PDF_NOCOMMENTS	= 0x8
    }	PROPDATAFLAGS;

typedef
enum tagENUMPROPFLAGS
    {	EPF_NONAME	= 0x1
    }	ENUMPROPFLAGS;

typedef struct  tagMIMEPARAMINFO
    {
    LPSTR pszName;
    LPSTR pszData;
    }	MIMEPARAMINFO;

typedef struct tagMIMEPARAMINFO __RPC_FAR *LPMIMEPARAMINFO;

typedef
enum tagPROPINFOMASK
    {	PIM_CHARSET	= 0x1,
	PIM_ENCODINGTYPE	= 0x2,
	PIM_ROWNUMBER	= 0x4,
	PIM_FLAGS	= 0x8,
	PIM_PROPID	= 0x10,
	PIM_VALUES	= 0x20
    }	PROPINFOMASK;

typedef struct  tagMIMEPROPINFO
    {
    DWORD dwMask;
    HCHARSET hCharset;
    ENCODINGTYPE ietEncoding;
    DWORD dwRowNumber;
    DWORD dwFlags;
    DWORD dwPropId;
    DWORD cValues;
    }	MIMEPROPINFO;

typedef struct tagMIMEPROPINFO __RPC_FAR *LPMIMEPROPINFO;


EXTERN_C const IID IID_IMimePropertySet;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A204-C19B-11d0-85EB-00C04FD85AB4")
    IMimePropertySet : public IPersistStreamInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropInfo(
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ LPMIMEPROPINFO pInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetPropInfo(
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPMIMEPROPINFO pInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteProp(
            /* [in] */ LPCSTR pszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE CopyProps(
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet) = 0;

        virtual HRESULT STDMETHODCALLTYPE MoveProps(
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteExcept(
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE QueryProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCharset(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetParameters(
            /* [in] */ LPCSTR pszName,
            /* [out] */ ULONG __RPC_FAR *pcParams,
            /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsContentType(
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetOption(
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOption(
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumProps(
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimePropertySetVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimePropertySet __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimePropertySet __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimePropertySet __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimePropertySet __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropInfo )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropInfo )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyProps )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveProps )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteExcept )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryProp )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParameters )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ ULONG __RPC_FAR *pcParams,
            /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimePropertySet __RPC_FAR * This,
            /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumProps )(
            IMimePropertySet __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);

        END_INTERFACE
    } IMimePropertySetVtbl;

    interface IMimePropertySet
    {
        CONST_VTBL struct IMimePropertySetVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimePropertySet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimePropertySet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimePropertySet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimePropertySet_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimePropertySet_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimePropertySet_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimePropertySet_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimePropertySet_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimePropertySet_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimePropertySet_GetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> GetPropInfo(This,pszName,pInfo)

#define IMimePropertySet_SetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> SetPropInfo(This,pszName,pInfo)

#define IMimePropertySet_GetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetProp(This,pszName,dwFlags,pValue)

#define IMimePropertySet_SetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetProp(This,pszName,dwFlags,pValue)

#define IMimePropertySet_AppendProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> AppendProp(This,pszName,dwFlags,pValue)

#define IMimePropertySet_DeleteProp(This,pszName)	\
    (This)->lpVtbl -> DeleteProp(This,pszName)

#define IMimePropertySet_CopyProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> CopyProps(This,cNames,prgszName,pPropertySet)

#define IMimePropertySet_MoveProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> MoveProps(This,cNames,prgszName,pPropertySet)

#define IMimePropertySet_DeleteExcept(This,cNames,prgszName)	\
    (This)->lpVtbl -> DeleteExcept(This,cNames,prgszName)

#define IMimePropertySet_QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimePropertySet_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimePropertySet_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimePropertySet_GetParameters(This,pszName,pcParams,pprgParam)	\
    (This)->lpVtbl -> GetParameters(This,pszName,pcParams,pprgParam)

#define IMimePropertySet_IsContentType(This,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,pszPriType,pszSubType)

#define IMimePropertySet_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#define IMimePropertySet_Clone(This,ppPropertySet)	\
    (This)->lpVtbl -> Clone(This,ppPropertySet)

#define IMimePropertySet_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimePropertySet_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)

#define IMimePropertySet_EnumProps(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumProps(This,dwFlags,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimePropertySet_GetPropInfo_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ LPMIMEPROPINFO pInfo);


void __RPC_STUB IMimePropertySet_GetPropInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetPropInfo_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPMIMEPROPINFO pInfo);


void __RPC_STUB IMimePropertySet_SetPropInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_AppendProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_AppendProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_DeleteProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName);


void __RPC_STUB IMimePropertySet_DeleteProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_CopyProps_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ ULONG cNames,
    /* [in] */ LPCSTR __RPC_FAR *prgszName,
    /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);


void __RPC_STUB IMimePropertySet_CopyProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_MoveProps_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ ULONG cNames,
    /* [in] */ LPCSTR __RPC_FAR *prgszName,
    /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);


void __RPC_STUB IMimePropertySet_MoveProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_DeleteExcept_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ ULONG cNames,
    /* [in] */ LPCSTR __RPC_FAR *prgszName);


void __RPC_STUB IMimePropertySet_DeleteExcept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_QueryProp_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszCriteria,
    /* [in] */ boolean fSubString,
    /* [in] */ boolean fCaseSensitive);


void __RPC_STUB IMimePropertySet_QueryProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetCharset_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimePropertySet_GetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetCharset_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ CSETAPPLYTYPE applytype);


void __RPC_STUB IMimePropertySet_SetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetParameters_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ ULONG __RPC_FAR *pcParams,
    /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam);


void __RPC_STUB IMimePropertySet_GetParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_IsContentType_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ LPCSTR pszPriType,
    /* [in] */ LPCSTR pszSubType);


void __RPC_STUB IMimePropertySet_IsContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_BindToObject_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimePropertySet_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_Clone_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet);


void __RPC_STUB IMimePropertySet_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_SetOption_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_GetOption_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimePropertySet_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimePropertySet_EnumProps_Proxy(
    IMimePropertySet __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimePropertySet_EnumProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimePropertySet_INTERFACE_DEFINED__ */


#ifndef __IMimeAddressInfo_INTERFACE_DEFINED__
#define __IMimeAddressInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeAddressInfo
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeAddressInfo __RPC_FAR *LPMIMEADDRESSINFO;

typedef DWORD IADDRESSTYPE;

#define	IAT_UNKNOWN	( 0 )

#define	IAT_FROM	( 0x1 )

#define	IAT_SENDER	( 0x2 )

#define	IAT_TO	( 0x4 )

#define	IAT_CC	( 0x8 )

#define	IAT_BCC	( 0x10 )

#define	IAT_REPLYTO	( 0x20 )

#define	IAT_RETURNPATH	( 0x40 )

#define	IAT_RETRCPTTO	( 0x80 )

#define	IAT_RR	( 0x100 )

#define	IAT_APPARTO	( 0x200 )


EXTERN_C const IID IID_IMimeAddressInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EF-C19B-11d0-85EB-00C04FD85AB4")
    IMimeAddressInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetId(
            /* [out] */ LPDWORD pdwId) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetType(
            /* [out] */ LPDWORD pdwAdrType) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetType(
            /* [in] */ DWORD dwAdrType) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetAddress(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddress(
            /* [out] */ LPSTR __RPC_FAR *pszFriendly,
            /* [out] */ LPSTR __RPC_FAR *ppszEmail) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertState(
            /* [out] */ CERTSTATE __RPC_FAR *pcertstate) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCertState(
            /* [in] */ CERTSTATE certstate) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetThumbprint(
            /* [in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetThumbprint(
            /* [unique][out][in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType) = 0;

        virtual HRESULT STDMETHODCALLTYPE CopyTo(
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress,
            /* [in] */ boolean fIncludeType) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCharset(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeAddressInfoVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeAddressInfo __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeAddressInfo __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPDWORD pdwId);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPDWORD pdwAdrType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAddress )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddress )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *pszFriendly,
            /* [out] */ LPSTR __RPC_FAR *ppszEmail);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertState )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ CERTSTATE __RPC_FAR *pcertstate);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCertState )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ CERTSTATE certstate);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThumbprint )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThumbprint )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [unique][out][in] */ LPBLOB pThumbPrint,
            /* [in] */ DWORD dwType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress,
            /* [in] */ boolean fIncludeType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeAddressInfo __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )(
            IMimeAddressInfo __RPC_FAR * This);

        END_INTERFACE
    } IMimeAddressInfoVtbl;

    interface IMimeAddressInfo
    {
        CONST_VTBL struct IMimeAddressInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeAddressInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeAddressInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeAddressInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeAddressInfo_GetId(This,pdwId)	\
    (This)->lpVtbl -> GetId(This,pdwId)

#define IMimeAddressInfo_GetType(This,pdwAdrType)	\
    (This)->lpVtbl -> GetType(This,pdwAdrType)

#define IMimeAddressInfo_SetType(This,dwAdrType)	\
    (This)->lpVtbl -> SetType(This,dwAdrType)

#define IMimeAddressInfo_SetAddress(This,ietEncoding,pszFriendly,pszEmail)	\
    (This)->lpVtbl -> SetAddress(This,ietEncoding,pszFriendly,pszEmail)

#define IMimeAddressInfo_GetAddress(This,pszFriendly,ppszEmail)	\
    (This)->lpVtbl -> GetAddress(This,pszFriendly,ppszEmail)

#define IMimeAddressInfo_GetCertState(This,pcertstate)	\
    (This)->lpVtbl -> GetCertState(This,pcertstate)

#define IMimeAddressInfo_SetCertState(This,certstate)	\
    (This)->lpVtbl -> SetCertState(This,certstate)

#define IMimeAddressInfo_SetThumbprint(This,pThumbPrint,dwType)	\
    (This)->lpVtbl -> SetThumbprint(This,pThumbPrint,dwType)

#define IMimeAddressInfo_GetThumbprint(This,pThumbPrint,dwType)	\
    (This)->lpVtbl -> GetThumbprint(This,pThumbPrint,dwType)

#define IMimeAddressInfo_CopyTo(This,pAddress,fIncludeType)	\
    (This)->lpVtbl -> CopyTo(This,pAddress,fIncludeType)

#define IMimeAddressInfo_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeAddressInfo_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeAddressInfo_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetId_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPDWORD pdwId);


void __RPC_STUB IMimeAddressInfo_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetType_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPDWORD pdwAdrType);


void __RPC_STUB IMimeAddressInfo_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetType_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType);


void __RPC_STUB IMimeAddressInfo_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetAddress_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszFriendly,
    /* [in] */ LPCSTR pszEmail);


void __RPC_STUB IMimeAddressInfo_SetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetAddress_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *pszFriendly,
    /* [out] */ LPSTR __RPC_FAR *ppszEmail);


void __RPC_STUB IMimeAddressInfo_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetCertState_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ CERTSTATE __RPC_FAR *pcertstate);


void __RPC_STUB IMimeAddressInfo_GetCertState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetCertState_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ CERTSTATE certstate);


void __RPC_STUB IMimeAddressInfo_SetCertState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetThumbprint_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ LPBLOB pThumbPrint,
    /* [in] */ DWORD dwType);


void __RPC_STUB IMimeAddressInfo_SetThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetThumbprint_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [unique][out][in] */ LPBLOB pThumbPrint,
    /* [in] */ DWORD dwType);


void __RPC_STUB IMimeAddressInfo_GetThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_CopyTo_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress,
    /* [in] */ boolean fIncludeType);


void __RPC_STUB IMimeAddressInfo_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_SetCharset_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ CSETAPPLYTYPE applytype);


void __RPC_STUB IMimeAddressInfo_SetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_GetCharset_Proxy(
    IMimeAddressInfo __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeAddressInfo_GetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressInfo_Delete_Proxy(
    IMimeAddressInfo __RPC_FAR * This);


void __RPC_STUB IMimeAddressInfo_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeAddressInfo_INTERFACE_DEFINED__ */


#ifndef __IMimeAddressTable_INTERFACE_DEFINED__
#define __IMimeAddressTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeAddressTable
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeAddressTable __RPC_FAR *LPMIMEADDRESSTABLE;

#define	IAT_ALL	( ( DWORD  )0xffffffff )

#define	IAT_KNOWN	( ( DWORD  )(IAT_FROM | IAT_TO | IAT_CC | IAT_BCC | IAT_REPLYTO | IAT_SENDER) )

#define	IAT_RECIPS	( ( DWORD  )(IAT_TO | IAT_CC | IAT_BCC) )

typedef
enum tagADDRESSFORMAT
    {	AFT_DISPLAY_FRIENDLY	= 0,
	AFT_DISPLAY_EMAIL	= AFT_DISPLAY_FRIENDLY + 1,
	AFT_DISPLAY_BOTH	= AFT_DISPLAY_EMAIL + 1,
	AFT_RFC822_DECODED	= AFT_DISPLAY_BOTH + 1,
	AFT_RFC822_ENCODED	= AFT_RFC822_DECODED + 1,
	AFT_RFC822_TRANSMIT	= AFT_RFC822_ENCODED + 1
    }	ADDRESSFORMAT;

typedef struct  tagADDRESSLIST
    {
    ULONG cAddresses;
    IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress;
    }	ADDRESSLIST;

typedef struct tagADDRESSLIST __RPC_FAR *LPADDRESSLIST;


EXTERN_C const IID IID_IMimeAddressTable;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EE-C19B-11d0-85EB-00C04FD85AB4")
    IMimeAddressTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSender(
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ ULONG __RPC_FAR *pcAddresses) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteTypes(
            /* [in] */ DWORD dwAdrTypes) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendBasic(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendNew(
            /* [in] */ DWORD dwAdrType,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendAs(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendList(
            /* [in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE AppendRfc822(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetFormat(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE ParseRfc822(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr,
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeAddressTableVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeAddressTable __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeAddressTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSender )(
            IMimeAddressTable __RPC_FAR * This,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ ULONG __RPC_FAR *pcAddresses);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTypes )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )(
            IMimeAddressTable __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendBasic )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFriendly,
            /* [in] */ LPCSTR pszEmail);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendNew )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendAs )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendList )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendRfc822 )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseRfc822 )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszRfc822Adr,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeAddressTable __RPC_FAR * This,
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeAddressTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        END_INTERFACE
    } IMimeAddressTableVtbl;

    interface IMimeAddressTable
    {
        CONST_VTBL struct IMimeAddressTableVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeAddressTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeAddressTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeAddressTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeAddressTable_GetSender(This,ppAddress)	\
    (This)->lpVtbl -> GetSender(This,ppAddress)

#define IMimeAddressTable_CountTypes(This,dwAdrTypes,pcAddresses)	\
    (This)->lpVtbl -> CountTypes(This,dwAdrTypes,pcAddresses)

#define IMimeAddressTable_EnumTypes(This,dwAdrTypes,ppEnum)	\
    (This)->lpVtbl -> EnumTypes(This,dwAdrTypes,ppEnum)

#define IMimeAddressTable_GetTypes(This,dwAdrTypes,pList)	\
    (This)->lpVtbl -> GetTypes(This,dwAdrTypes,pList)

#define IMimeAddressTable_DeleteTypes(This,dwAdrTypes)	\
    (This)->lpVtbl -> DeleteTypes(This,dwAdrTypes)

#define IMimeAddressTable_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#define IMimeAddressTable_AppendBasic(This,dwAdrType,ietEncoding,pszFriendly,pszEmail)	\
    (This)->lpVtbl -> AppendBasic(This,dwAdrType,ietEncoding,pszFriendly,pszEmail)

#define IMimeAddressTable_AppendNew(This,dwAdrType,ppAddress)	\
    (This)->lpVtbl -> AppendNew(This,dwAdrType,ppAddress)

#define IMimeAddressTable_AppendAs(This,dwAdrType,pAddress)	\
    (This)->lpVtbl -> AppendAs(This,dwAdrType,pAddress)

#define IMimeAddressTable_AppendList(This,pList)	\
    (This)->lpVtbl -> AppendList(This,pList)

#define IMimeAddressTable_AppendRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr)	\
    (This)->lpVtbl -> AppendRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr)

#define IMimeAddressTable_GetFormat(This,dwAdrType,format,ppszAddress)	\
    (This)->lpVtbl -> GetFormat(This,dwAdrType,format,ppszAddress)

#define IMimeAddressTable_ParseRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr,pList)	\
    (This)->lpVtbl -> ParseRfc822(This,dwAdrType,ietEncoding,pszRfc822Adr,pList)

#define IMimeAddressTable_Clone(This,ppTable)	\
    (This)->lpVtbl -> Clone(This,ppTable)

#define IMimeAddressTable_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeAddressTable_GetSender_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB IMimeAddressTable_GetSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_CountTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out] */ ULONG __RPC_FAR *pcAddresses);


void __RPC_STUB IMimeAddressTable_CountTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_EnumTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeAddressTable_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_GetTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAddressTable_GetTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_DeleteTypes_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes);


void __RPC_STUB IMimeAddressTable_DeleteTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_DeleteAll_Proxy(
    IMimeAddressTable __RPC_FAR * This);


void __RPC_STUB IMimeAddressTable_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendBasic_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszFriendly,
    /* [in] */ LPCSTR pszEmail);


void __RPC_STUB IMimeAddressTable_AppendBasic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendNew_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB IMimeAddressTable_AppendNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendAs_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ IMimeAddressInfo __RPC_FAR *pAddress);


void __RPC_STUB IMimeAddressTable_AppendAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendList_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAddressTable_AppendList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_AppendRfc822_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszRfc822Adr);


void __RPC_STUB IMimeAddressTable_AppendRfc822_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_GetFormat_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ADDRESSFORMAT format,
    /* [out] */ LPSTR __RPC_FAR *ppszAddress);


void __RPC_STUB IMimeAddressTable_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_ParseRfc822_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszRfc822Adr,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAddressTable_ParseRfc822_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_Clone_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);


void __RPC_STUB IMimeAddressTable_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAddressTable_BindToObject_Proxy(
    IMimeAddressTable __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimeAddressTable_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeAddressTable_INTERFACE_DEFINED__ */


#ifndef __IMimeWebDocument_INTERFACE_DEFINED__
#define __IMimeWebDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeWebDocument
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */



EXTERN_C const IID IID_IMimeWebDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EC-C19B-11d0-85EB-00C04FD85AB4")
    IMimeWebDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetURL(
            /* [out] */ LPSTR __RPC_FAR *ppszURL) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToStorage(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *ppvObject) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeWebDocumentVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeWebDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeWebDocument __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeWebDocument __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )(
            IMimeWebDocument __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *ppszURL);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToStorage )(
            IMimeWebDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *ppvObject);

        END_INTERFACE
    } IMimeWebDocumentVtbl;

    interface IMimeWebDocument
    {
        CONST_VTBL struct IMimeWebDocumentVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeWebDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeWebDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeWebDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeWebDocument_GetURL(This,ppszURL)	\
    (This)->lpVtbl -> GetURL(This,ppszURL)

#define IMimeWebDocument_BindToStorage(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToStorage(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeWebDocument_GetURL_Proxy(
    IMimeWebDocument __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *ppszURL);


void __RPC_STUB IMimeWebDocument_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeWebDocument_BindToStorage_Proxy(
    IMimeWebDocument __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *ppvObject);


void __RPC_STUB IMimeWebDocument_BindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeWebDocument_INTERFACE_DEFINED__ */


#ifndef __IMimeBody_INTERFACE_DEFINED__
#define __IMimeBody_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeBody
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeBody __RPC_FAR *LPMIMEBODY;

typedef struct  tagBODYOFFSETS
    {
    DWORD cbBoundaryStart;
    DWORD cbHeaderStart;
    DWORD cbBodyStart;
    DWORD cbBodyEnd;
    }	BODYOFFSETS;

typedef struct tagBODYOFFSETS __RPC_FAR *LPBODYOFFSETS;

typedef
enum tagIMSGBODYTYPE
    {	IBT_SECURE	= 0,
	IBT_ATTACHMENT	= IBT_SECURE + 1,
	IBT_EMPTY	= IBT_ATTACHMENT + 1
    }	IMSGBODYTYPE;

typedef struct  tagTRANSMITINFO
    {
    ENCODINGTYPE ietCurrent;
    ENCODINGTYPE ietOption;
    ENCODINGTYPE ietXmitMime;
    ENCODINGTYPE ietXmit822;
    ULONG cbLongestLine;
    ULONG cExtended;
    ULONG ulPercentExt;
    ULONG cbSize;
    ULONG cLines;
    }	TRANSMITINFO;

typedef struct tagTRANSMITINFO __RPC_FAR *LPTRANSMITINFO;


EXTERN_C const IID IID_IMimeBody;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F8-C19B-11d0-85EB-00C04FD85AB4")
    IMimeBody : public IMimePropertySet
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsType(
            /* [in] */ IMSGBODYTYPE bodytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetDisplayName(
            /* [in] */ LPCSTR pszDisplay) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDisplayName(
            /* [out] */ LPSTR __RPC_FAR *ppszDisplay) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOffsets(
            /* [out] */ LPBODYOFFSETS pOffsets) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCurrentEncoding(
            /* [out] */ ENCODINGTYPE __RPC_FAR *pietEncoding) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCurrentEncoding(
            /* [in] */ ENCODINGTYPE ietEncoding) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetEstimatedSize(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ ULONG __RPC_FAR *pcbSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDataHere(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ IStream __RPC_FAR *pStream) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetData(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetData(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pvObject) = 0;

        virtual HRESULT STDMETHODCALLTYPE EmptyData( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE CopyTo(
            /* [in] */ IMimeBody __RPC_FAR *pBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTransmitInfo(
            /* [out][in] */ LPTRANSMITINFO pTransmitInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE SaveToFile(
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFilePath) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetHandle(
            /* [out] */ LPHBODY phBody) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeBodyVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeBody __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropInfo )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropInfo )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPMIMEPROPINFO pInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyProps )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveProps )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName,
            /* [in] */ IMimePropertySet __RPC_FAR *pPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteExcept )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ULONG cNames,
            /* [in] */ LPCSTR __RPC_FAR *prgszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryProp )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParameters )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ ULONG __RPC_FAR *pcParams,
            /* [out] */ LPMIMEPARAMINFO __RPC_FAR *pprgParam);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ IMimePropertySet __RPC_FAR *__RPC_FAR *ppPropertySet);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumProps )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsType )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ IMSGBODYTYPE bodytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDisplayName )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ LPCSTR pszDisplay);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *ppszDisplay);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOffsets )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPBODYOFFSETS pOffsets);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentEncoding )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ ENCODINGTYPE __RPC_FAR *pietEncoding);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrentEncoding )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEstimatedSize )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ ULONG __RPC_FAR *pcbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataHere )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ IStream __RPC_FAR *pStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetData )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyData )(
            IMimeBody __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ IMimeBody __RPC_FAR *pBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransmitInfo )(
            IMimeBody __RPC_FAR * This,
            /* [out][in] */ LPTRANSMITINFO pTransmitInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToFile )(
            IMimeBody __RPC_FAR * This,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ LPCSTR pszFilePath);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHandle )(
            IMimeBody __RPC_FAR * This,
            /* [out] */ LPHBODY phBody);

        END_INTERFACE
    } IMimeBodyVtbl;

    interface IMimeBody
    {
        CONST_VTBL struct IMimeBodyVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeBody_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeBody_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeBody_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeBody_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeBody_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeBody_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeBody_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeBody_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimeBody_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimeBody_GetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> GetPropInfo(This,pszName,pInfo)

#define IMimeBody_SetPropInfo(This,pszName,pInfo)	\
    (This)->lpVtbl -> SetPropInfo(This,pszName,pInfo)

#define IMimeBody_GetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetProp(This,pszName,dwFlags,pValue)

#define IMimeBody_SetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetProp(This,pszName,dwFlags,pValue)

#define IMimeBody_AppendProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> AppendProp(This,pszName,dwFlags,pValue)

#define IMimeBody_DeleteProp(This,pszName)	\
    (This)->lpVtbl -> DeleteProp(This,pszName)

#define IMimeBody_CopyProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> CopyProps(This,cNames,prgszName,pPropertySet)

#define IMimeBody_MoveProps(This,cNames,prgszName,pPropertySet)	\
    (This)->lpVtbl -> MoveProps(This,cNames,prgszName,pPropertySet)

#define IMimeBody_DeleteExcept(This,cNames,prgszName)	\
    (This)->lpVtbl -> DeleteExcept(This,cNames,prgszName)

#define IMimeBody_QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeBody_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeBody_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeBody_GetParameters(This,pszName,pcParams,pprgParam)	\
    (This)->lpVtbl -> GetParameters(This,pszName,pcParams,pprgParam)

#define IMimeBody_IsContentType(This,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,pszPriType,pszSubType)

#define IMimeBody_BindToObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,riid,ppvObject)

#define IMimeBody_Clone(This,ppPropertySet)	\
    (This)->lpVtbl -> Clone(This,ppPropertySet)

#define IMimeBody_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimeBody_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)

#define IMimeBody_EnumProps(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumProps(This,dwFlags,ppEnum)


#define IMimeBody_IsType(This,bodytype)	\
    (This)->lpVtbl -> IsType(This,bodytype)

#define IMimeBody_SetDisplayName(This,pszDisplay)	\
    (This)->lpVtbl -> SetDisplayName(This,pszDisplay)

#define IMimeBody_GetDisplayName(This,ppszDisplay)	\
    (This)->lpVtbl -> GetDisplayName(This,ppszDisplay)

#define IMimeBody_GetOffsets(This,pOffsets)	\
    (This)->lpVtbl -> GetOffsets(This,pOffsets)

#define IMimeBody_GetCurrentEncoding(This,pietEncoding)	\
    (This)->lpVtbl -> GetCurrentEncoding(This,pietEncoding)

#define IMimeBody_SetCurrentEncoding(This,ietEncoding)	\
    (This)->lpVtbl -> SetCurrentEncoding(This,ietEncoding)

#define IMimeBody_GetEstimatedSize(This,ietEncoding,pcbSize)	\
    (This)->lpVtbl -> GetEstimatedSize(This,ietEncoding,pcbSize)

#define IMimeBody_GetDataHere(This,ietEncoding,pStream)	\
    (This)->lpVtbl -> GetDataHere(This,ietEncoding,pStream)

#define IMimeBody_GetData(This,ietEncoding,ppStream)	\
    (This)->lpVtbl -> GetData(This,ietEncoding,ppStream)

#define IMimeBody_SetData(This,ietEncoding,pszPriType,pszSubType,riid,pvObject)	\
    (This)->lpVtbl -> SetData(This,ietEncoding,pszPriType,pszSubType,riid,pvObject)

#define IMimeBody_EmptyData(This)	\
    (This)->lpVtbl -> EmptyData(This)

#define IMimeBody_CopyTo(This,pBody)	\
    (This)->lpVtbl -> CopyTo(This,pBody)

#define IMimeBody_GetTransmitInfo(This,pTransmitInfo)	\
    (This)->lpVtbl -> GetTransmitInfo(This,pTransmitInfo)

#define IMimeBody_SaveToFile(This,ietEncoding,pszFilePath)	\
    (This)->lpVtbl -> SaveToFile(This,ietEncoding,pszFilePath)

#define IMimeBody_GetHandle(This,phBody)	\
    (This)->lpVtbl -> GetHandle(This,phBody)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeBody_IsType_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ IMSGBODYTYPE bodytype);


void __RPC_STUB IMimeBody_IsType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SetDisplayName_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ LPCSTR pszDisplay);


void __RPC_STUB IMimeBody_SetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetDisplayName_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *ppszDisplay);


void __RPC_STUB IMimeBody_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetOffsets_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ LPBODYOFFSETS pOffsets);


void __RPC_STUB IMimeBody_GetOffsets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetCurrentEncoding_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ ENCODINGTYPE __RPC_FAR *pietEncoding);


void __RPC_STUB IMimeBody_GetCurrentEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SetCurrentEncoding_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding);


void __RPC_STUB IMimeBody_SetCurrentEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetEstimatedSize_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [out] */ ULONG __RPC_FAR *pcbSize);


void __RPC_STUB IMimeBody_GetEstimatedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetDataHere_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IMimeBody_GetDataHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetData_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IMimeBody_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SetData_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszPriType,
    /* [in] */ LPCSTR pszSubType,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pvObject);


void __RPC_STUB IMimeBody_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_EmptyData_Proxy(
    IMimeBody __RPC_FAR * This);


void __RPC_STUB IMimeBody_EmptyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_CopyTo_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ IMimeBody __RPC_FAR *pBody);


void __RPC_STUB IMimeBody_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetTransmitInfo_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out][in] */ LPTRANSMITINFO pTransmitInfo);


void __RPC_STUB IMimeBody_GetTransmitInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_SaveToFile_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ LPCSTR pszFilePath);


void __RPC_STUB IMimeBody_SaveToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeBody_GetHandle_Proxy(
    IMimeBody __RPC_FAR * This,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeBody_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeBody_INTERFACE_DEFINED__ */


#ifndef __IMimeMessageTree_INTERFACE_DEFINED__
#define __IMimeMessageTree_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeMessageTree
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeMessageTree __RPC_FAR *LPMIMEMESSAGETREE;

#define	HBODY_ROOT	( ( HBODY  )0xffffffff )

typedef
enum tagBODYLOCATION
    {	IBL_ROOT	= 0,
	IBL_PARENT	= IBL_ROOT + 1,
	IBL_FIRST	= IBL_PARENT + 1,
	IBL_LAST	= IBL_FIRST + 1,
	IBL_NEXT	= IBL_LAST + 1,
	IBL_PREVIOUS	= IBL_NEXT + 1
    }	BODYLOCATION;

typedef
enum tagBODYDELETEFLAGS
    {	DELETE_PROMOTE_CHILDREN	= 0x1
    }	BODYDELETEFLAGS;

typedef struct  tagFINDBODY
    {
    LPSTR pszPriType;
    LPSTR pszSubType;
    DWORD dwReserved;
    }	FINDBODY;

typedef struct tagFINDBODY __RPC_FAR *LPFINDBODY;


EXTERN_C const IID IID_IMimeMessageTree;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A206-C19B-11d0-85EB-00C04FD85AB4")
    IMimeMessageTree : public IPersistStreamInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateRootMoniker(
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetMessageSource(
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [in] */ boolean fCommitIfDirty) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetMessageSize(
            /* [out] */ ULONG __RPC_FAR *pcbSize,
            /* [in] */ boolean fCommitIfDirty) = 0;

        virtual HRESULT STDMETHODCALLTYPE LoadOffsetTable(
            /* [in] */ IStream __RPC_FAR *pStream) = 0;

        virtual HRESULT STDMETHODCALLTYPE SaveOffsetTable(
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ boolean fCommitIfDirty) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetFlags(
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE HandsOffStorage( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE BindToObject(
            /* [in] */ HBODY hBody,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

        virtual HRESULT STDMETHODCALLTYPE InsertBody(
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetBody(
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteBody(
            /* [in] */ HBODY hBody,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE MoveBody(
            /* [in] */ HBODY hBody,
            /* [in] */ BODYLOCATION location) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountBodies(
            /* [in] */ HBODY hParent,
            /* [in] */ boolean fRecurse,
            /* [out] */ ULONG __RPC_FAR *pcBodies) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindFirst(
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindNext(
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE ResolveURL(
            /* [in] */ HBODY hRelated,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE ToMultipart(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszSubType,
            /* [out] */ LPHBODY phMultipart) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetBodyOffsets(
            /* [in] */ HBODY hBody,
            /* [out][in] */ LPBODYOFFSETS pOffsets) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetCharset(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsBodyType(
            /* [in] */ HBODY hBody,
            /* [in] */ IMSGBODYTYPE bodytype) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsContentType(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType) = 0;

        virtual HRESULT STDMETHODCALLTYPE QueryBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteBodyProp(
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetOption(
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetOption(
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeMessageTreeVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeMessageTree __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRootMoniker )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSource )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSize )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadOffsetTable )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveOffsetTable )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffStorage )(
            IMimeMessageTree __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveBody )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ BODYLOCATION location);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountBodies )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hParent,
            /* [in] */ boolean fRecurse,
            /* [out] */ ULONG __RPC_FAR *pcBodies);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirst )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNext )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResolveURL )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hRelated,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToMultipart )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszSubType,
            /* [out] */ LPHBODY phMultipart);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyOffsets )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [out][in] */ LPBODYOFFSETS pOffsets);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeMessageTree __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsBodyType )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ IMSGBODYTYPE bodytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBodyProp )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeMessageTree __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        END_INTERFACE
    } IMimeMessageTreeVtbl;

    interface IMimeMessageTree
    {
        CONST_VTBL struct IMimeMessageTreeVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeMessageTree_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeMessageTree_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeMessageTree_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeMessageTree_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeMessageTree_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeMessageTree_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeMessageTree_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeMessageTree_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimeMessageTree_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimeMessageTree_CreateRootMoniker(This,pStream,ppMoniker)	\
    (This)->lpVtbl -> CreateRootMoniker(This,pStream,ppMoniker)

#define IMimeMessageTree_GetMessageSource(This,ppStream,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSource(This,ppStream,fCommitIfDirty)

#define IMimeMessageTree_GetMessageSize(This,pcbSize,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSize(This,pcbSize,fCommitIfDirty)

#define IMimeMessageTree_LoadOffsetTable(This,pStream)	\
    (This)->lpVtbl -> LoadOffsetTable(This,pStream)

#define IMimeMessageTree_SaveOffsetTable(This,pStream,fCommitIfDirty)	\
    (This)->lpVtbl -> SaveOffsetTable(This,pStream,fCommitIfDirty)

#define IMimeMessageTree_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IMimeMessageTree_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IMimeMessageTree_HandsOffStorage(This)	\
    (This)->lpVtbl -> HandsOffStorage(This)

#define IMimeMessageTree_BindToObject(This,hBody,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,hBody,riid,ppvObject)

#define IMimeMessageTree_InsertBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> InsertBody(This,location,hPivot,phBody)

#define IMimeMessageTree_GetBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> GetBody(This,location,hPivot,phBody)

#define IMimeMessageTree_DeleteBody(This,hBody,dwFlags)	\
    (This)->lpVtbl -> DeleteBody(This,hBody,dwFlags)

#define IMimeMessageTree_MoveBody(This,hBody,location)	\
    (This)->lpVtbl -> MoveBody(This,hBody,location)

#define IMimeMessageTree_CountBodies(This,hParent,fRecurse,pcBodies)	\
    (This)->lpVtbl -> CountBodies(This,hParent,fRecurse,pcBodies)

#define IMimeMessageTree_FindFirst(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindFirst(This,pFindBody,phBody)

#define IMimeMessageTree_FindNext(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindNext(This,pFindBody,phBody)

#define IMimeMessageTree_ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)	\
    (This)->lpVtbl -> ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)

#define IMimeMessageTree_ToMultipart(This,hBody,pszSubType,phMultipart)	\
    (This)->lpVtbl -> ToMultipart(This,hBody,pszSubType,phMultipart)

#define IMimeMessageTree_GetBodyOffsets(This,hBody,pOffsets)	\
    (This)->lpVtbl -> GetBodyOffsets(This,hBody,pOffsets)

#define IMimeMessageTree_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeMessageTree_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeMessageTree_IsBodyType(This,hBody,bodytype)	\
    (This)->lpVtbl -> IsBodyType(This,hBody,bodytype)

#define IMimeMessageTree_IsContentType(This,hBody,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,hBody,pszPriType,pszSubType)

#define IMimeMessageTree_QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeMessageTree_GetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessageTree_SetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessageTree_DeleteBodyProp(This,hBody,pszName)	\
    (This)->lpVtbl -> DeleteBodyProp(This,hBody,pszName)

#define IMimeMessageTree_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimeMessageTree_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeMessageTree_CreateRootMoniker_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker);


void __RPC_STUB IMimeMessageTree_CreateRootMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetMessageSource_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
    /* [in] */ boolean fCommitIfDirty);


void __RPC_STUB IMimeMessageTree_GetMessageSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetMessageSize_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcbSize,
    /* [in] */ boolean fCommitIfDirty);


void __RPC_STUB IMimeMessageTree_GetMessageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_LoadOffsetTable_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IMimeMessageTree_LoadOffsetTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SaveOffsetTable_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ boolean fCommitIfDirty);


void __RPC_STUB IMimeMessageTree_SaveOffsetTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetFlags_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IMimeMessageTree_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_Commit_Proxy(
    IMimeMessageTree __RPC_FAR * This);


void __RPC_STUB IMimeMessageTree_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_HandsOffStorage_Proxy(
    IMimeMessageTree __RPC_FAR * This);


void __RPC_STUB IMimeMessageTree_HandsOffStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_BindToObject_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IMimeMessageTree_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_InsertBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ BODYLOCATION location,
    /* [in] */ HBODY hPivot,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_InsertBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ BODYLOCATION location,
    /* [in] */ HBODY hPivot,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_GetBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_DeleteBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMimeMessageTree_DeleteBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_MoveBody_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ BODYLOCATION location);


void __RPC_STUB IMimeMessageTree_MoveBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_CountBodies_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hParent,
    /* [in] */ boolean fRecurse,
    /* [out] */ ULONG __RPC_FAR *pcBodies);


void __RPC_STUB IMimeMessageTree_CountBodies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_FindFirst_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out][in] */ LPFINDBODY pFindBody,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_FindFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_FindNext_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out][in] */ LPFINDBODY pFindBody,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_FindNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_ResolveURL_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hRelated,
    /* [in] */ LPCSTR pszBase,
    /* [in] */ LPCSTR pszURL,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessageTree_ResolveURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_ToMultipart_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszSubType,
    /* [out] */ LPHBODY phMultipart);


void __RPC_STUB IMimeMessageTree_ToMultipart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetBodyOffsets_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [out][in] */ LPBODYOFFSETS pOffsets);


void __RPC_STUB IMimeMessageTree_GetBodyOffsets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetCharset_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeMessageTree_GetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SetCharset_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ CSETAPPLYTYPE applytype);


void __RPC_STUB IMimeMessageTree_SetCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_IsBodyType_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ IMSGBODYTYPE bodytype);


void __RPC_STUB IMimeMessageTree_IsBodyType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_IsContentType_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszPriType,
    /* [in] */ LPCSTR pszSubType);


void __RPC_STUB IMimeMessageTree_IsContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_QueryBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszCriteria,
    /* [in] */ boolean fSubString,
    /* [in] */ boolean fCaseSensitive);


void __RPC_STUB IMimeMessageTree_QueryBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_GetBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SetBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_SetBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_DeleteBodyProp_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ HBODY hBody,
    /* [in] */ LPCSTR pszName);


void __RPC_STUB IMimeMessageTree_DeleteBodyProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_SetOption_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageTree_GetOption_Proxy(
    IMimeMessageTree __RPC_FAR * This,
    /* [in] */ TYPEDID oid,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessageTree_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeMessageTree_INTERFACE_DEFINED__ */


#ifndef __IMimeMessage_INTERFACE_DEFINED__
#define __IMimeMessage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeMessage
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeMessage __RPC_FAR *LPMIMEMESSAGE;

typedef
enum tagIMSGFLAGS
    {	IMF_ATTACHMENTS	= 0x1,
	IMF_MULTIPART	= 0x2,
	IMF_SUBMULTIPART	= 0x4,
	IMF_MIME	= 0x8,
	IMF_HTML	= 0x10,
	IMF_PLAIN	= 0x20,
	IMF_PARTIAL	= 0x40,
	IMF_SIGNED	= 0x80,
	IMF_ENCRYPTED	= 0x100,
	IMF_TNEF	= 0x200,
	IMF_MHTML	= 0x400,
	IMF_SECURE	= 0x800,
	IMF_TEXT	= 0x1000
    }	IMSGFLAGS;

typedef
enum tagIMSGPRIORITY
    {	IMSG_PRI_LOW	= 5,
	IMSG_PRI_NORMAL	= 3,
	IMSG_PRI_HIGH	= 1
    }	IMSGPRIORITY;

typedef DWORD TEXTTYPE;

typedef LPDWORD LPTEXTTYPE;

#define	TXT_PLAIN	( 0x1 )

#define	TXT_HTML	( 0x2 )

#define	URL_ATTACH_INTO_MIXED	( 0x1 )

#define	URL_ATTACH_GENERATE_CID	( 0x2 )

#define	URL_RESOLVE_MARK	( 0x1 )

#define	SET_TEXT_RELATED	( 0x1 )


EXTERN_C const IID IID_IMimeMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A208-C19B-11d0-85EB-00C04FD85AB4")
    IMimeMessage : public IMimeMessageTree
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteProp(
            /* [in] */ LPCSTR pszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE QueryProp(
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTextBody(
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetTextBody(
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ HBODY hAlternative,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE AttachObject(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pvObject,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE AttachFile(
            /* [in] */ LPCSTR pszFilePath,
            /* [in] */ IStream __RPC_FAR *pstmFile,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE AttachURL(
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IStream __RPC_FAR *pstmURL,
            /* [out] */ LPSTR __RPC_FAR *ppszCID,
            /* [out] */ LPHBODY phBody) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAttachments(
            /* [out] */ ULONG __RPC_FAR *pcAttach,
            /* [out] */ LPHBODY __RPC_FAR *pprghAttach) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSender(
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddressTable(
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddressTypes(
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAddressFormat(
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress) = 0;

        virtual HRESULT STDMETHODCALLTYPE SplitMessage(
            /* [in] */ ULONG cbMaxPart,
            /* [out] */ IMimeMessageParts __RPC_FAR *__RPC_FAR *ppParts) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetRootMoniker(
            /* [out] */ LPMONIKER __RPC_FAR *ppmk) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeMessageVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeMessage __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRootMoniker )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppMoniker);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSource )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageSize )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadOffsetTable )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveOffsetTable )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ boolean fCommitIfDirty);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffStorage )(
            IMimeMessage __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindToObject )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ BODYLOCATION location,
            /* [in] */ HBODY hPivot,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ BODYLOCATION location);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountBodies )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hParent,
            /* [in] */ boolean fRecurse,
            /* [out] */ ULONG __RPC_FAR *pcBodies);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirst )(
            IMimeMessage __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNext )(
            IMimeMessage __RPC_FAR * This,
            /* [out][in] */ LPFINDBODY pFindBody,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResolveURL )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hRelated,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToMultipart )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszSubType,
            /* [out] */ LPHBODY phMultipart);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyOffsets )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [out][in] */ LPBODYOFFSETS pOffsets);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharset )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCharset )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ CSETAPPLYTYPE applytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsBodyType )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ IMSGBODYTYPE bodytype);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsContentType )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszPriType,
            /* [in] */ LPCSTR pszSubType);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBodyProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ HBODY hBody,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TYPEDID oid,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPPROPVARIANT pValue);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryProp )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszCriteria,
            /* [in] */ boolean fSubString,
            /* [in] */ boolean fCaseSensitive);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTextBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextBody )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ TEXTTYPE dwTxtType,
            /* [in] */ ENCODINGTYPE ietEncoding,
            /* [in] */ HBODY hAlternative,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachObject )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pvObject,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachFile )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszFilePath,
            /* [in] */ IStream __RPC_FAR *pstmFile,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachURL )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ LPCSTR pszBase,
            /* [in] */ LPCSTR pszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IStream __RPC_FAR *pstmURL,
            /* [out] */ LPSTR __RPC_FAR *ppszCID,
            /* [out] */ LPHBODY phBody);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttachments )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcAttach,
            /* [out] */ LPHBODY __RPC_FAR *pprghAttach);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSender )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddressTable )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddressTypes )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ DWORD dwAdrTypes,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddressFormat )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ DWORD dwAdrType,
            /* [in] */ ADDRESSFORMAT format,
            /* [out] */ LPSTR __RPC_FAR *ppszAddress);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SplitMessage )(
            IMimeMessage __RPC_FAR * This,
            /* [in] */ ULONG cbMaxPart,
            /* [out] */ IMimeMessageParts __RPC_FAR *__RPC_FAR *ppParts);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootMoniker )(
            IMimeMessage __RPC_FAR * This,
            /* [out] */ LPMONIKER __RPC_FAR *ppmk);

        END_INTERFACE
    } IMimeMessageVtbl;

    interface IMimeMessage
    {
        CONST_VTBL struct IMimeMessageVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeMessage_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMimeMessage_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMimeMessage_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMimeMessage_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMimeMessage_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IMimeMessage_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#define IMimeMessage_CreateRootMoniker(This,pStream,ppMoniker)	\
    (This)->lpVtbl -> CreateRootMoniker(This,pStream,ppMoniker)

#define IMimeMessage_GetMessageSource(This,ppStream,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSource(This,ppStream,fCommitIfDirty)

#define IMimeMessage_GetMessageSize(This,pcbSize,fCommitIfDirty)	\
    (This)->lpVtbl -> GetMessageSize(This,pcbSize,fCommitIfDirty)

#define IMimeMessage_LoadOffsetTable(This,pStream)	\
    (This)->lpVtbl -> LoadOffsetTable(This,pStream)

#define IMimeMessage_SaveOffsetTable(This,pStream,fCommitIfDirty)	\
    (This)->lpVtbl -> SaveOffsetTable(This,pStream,fCommitIfDirty)

#define IMimeMessage_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IMimeMessage_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IMimeMessage_HandsOffStorage(This)	\
    (This)->lpVtbl -> HandsOffStorage(This)

#define IMimeMessage_BindToObject(This,hBody,riid,ppvObject)	\
    (This)->lpVtbl -> BindToObject(This,hBody,riid,ppvObject)

#define IMimeMessage_InsertBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> InsertBody(This,location,hPivot,phBody)

#define IMimeMessage_GetBody(This,location,hPivot,phBody)	\
    (This)->lpVtbl -> GetBody(This,location,hPivot,phBody)

#define IMimeMessage_DeleteBody(This,hBody,dwFlags)	\
    (This)->lpVtbl -> DeleteBody(This,hBody,dwFlags)

#define IMimeMessage_MoveBody(This,hBody,location)	\
    (This)->lpVtbl -> MoveBody(This,hBody,location)

#define IMimeMessage_CountBodies(This,hParent,fRecurse,pcBodies)	\
    (This)->lpVtbl -> CountBodies(This,hParent,fRecurse,pcBodies)

#define IMimeMessage_FindFirst(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindFirst(This,pFindBody,phBody)

#define IMimeMessage_FindNext(This,pFindBody,phBody)	\
    (This)->lpVtbl -> FindNext(This,pFindBody,phBody)

#define IMimeMessage_ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)	\
    (This)->lpVtbl -> ResolveURL(This,hRelated,pszBase,pszURL,dwFlags,phBody)

#define IMimeMessage_ToMultipart(This,hBody,pszSubType,phMultipart)	\
    (This)->lpVtbl -> ToMultipart(This,hBody,pszSubType,phMultipart)

#define IMimeMessage_GetBodyOffsets(This,hBody,pOffsets)	\
    (This)->lpVtbl -> GetBodyOffsets(This,hBody,pOffsets)

#define IMimeMessage_GetCharset(This,phCharset)	\
    (This)->lpVtbl -> GetCharset(This,phCharset)

#define IMimeMessage_SetCharset(This,hCharset,applytype)	\
    (This)->lpVtbl -> SetCharset(This,hCharset,applytype)

#define IMimeMessage_IsBodyType(This,hBody,bodytype)	\
    (This)->lpVtbl -> IsBodyType(This,hBody,bodytype)

#define IMimeMessage_IsContentType(This,hBody,pszPriType,pszSubType)	\
    (This)->lpVtbl -> IsContentType(This,hBody,pszPriType,pszSubType)

#define IMimeMessage_QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryBodyProp(This,hBody,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeMessage_GetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessage_SetBodyProp(This,hBody,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetBodyProp(This,hBody,pszName,dwFlags,pValue)

#define IMimeMessage_DeleteBodyProp(This,hBody,pszName)	\
    (This)->lpVtbl -> DeleteBodyProp(This,hBody,pszName)

#define IMimeMessage_SetOption(This,oid,pValue)	\
    (This)->lpVtbl -> SetOption(This,oid,pValue)

#define IMimeMessage_GetOption(This,oid,pValue)	\
    (This)->lpVtbl -> GetOption(This,oid,pValue)


#define IMimeMessage_GetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> GetProp(This,pszName,dwFlags,pValue)

#define IMimeMessage_SetProp(This,pszName,dwFlags,pValue)	\
    (This)->lpVtbl -> SetProp(This,pszName,dwFlags,pValue)

#define IMimeMessage_DeleteProp(This,pszName)	\
    (This)->lpVtbl -> DeleteProp(This,pszName)

#define IMimeMessage_QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)	\
    (This)->lpVtbl -> QueryProp(This,pszName,pszCriteria,fSubString,fCaseSensitive)

#define IMimeMessage_GetTextBody(This,dwTxtType,ietEncoding,ppStream,phBody)	\
    (This)->lpVtbl -> GetTextBody(This,dwTxtType,ietEncoding,ppStream,phBody)

#define IMimeMessage_SetTextBody(This,dwTxtType,ietEncoding,hAlternative,pStream,phBody)	\
    (This)->lpVtbl -> SetTextBody(This,dwTxtType,ietEncoding,hAlternative,pStream,phBody)

#define IMimeMessage_AttachObject(This,riid,pvObject,phBody)	\
    (This)->lpVtbl -> AttachObject(This,riid,pvObject,phBody)

#define IMimeMessage_AttachFile(This,pszFilePath,pstmFile,phBody)	\
    (This)->lpVtbl -> AttachFile(This,pszFilePath,pstmFile,phBody)

#define IMimeMessage_AttachURL(This,pszBase,pszURL,dwFlags,pstmURL,ppszCID,phBody)	\
    (This)->lpVtbl -> AttachURL(This,pszBase,pszURL,dwFlags,pstmURL,ppszCID,phBody)

#define IMimeMessage_GetAttachments(This,pcAttach,pprghAttach)	\
    (This)->lpVtbl -> GetAttachments(This,pcAttach,pprghAttach)

#define IMimeMessage_GetSender(This,ppAddress)	\
    (This)->lpVtbl -> GetSender(This,ppAddress)

#define IMimeMessage_GetAddressTable(This,ppTable)	\
    (This)->lpVtbl -> GetAddressTable(This,ppTable)

#define IMimeMessage_GetAddressTypes(This,dwAdrTypes,pList)	\
    (This)->lpVtbl -> GetAddressTypes(This,dwAdrTypes,pList)

#define IMimeMessage_GetAddressFormat(This,dwAdrType,format,ppszAddress)	\
    (This)->lpVtbl -> GetAddressFormat(This,dwAdrType,format,ppszAddress)

#define IMimeMessage_SplitMessage(This,cbMaxPart,ppParts)	\
    (This)->lpVtbl -> SplitMessage(This,cbMaxPart,ppParts)

#define IMimeMessage_GetRootMoniker(This,ppmk)	\
    (This)->lpVtbl -> GetRootMoniker(This,ppmk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeMessage_GetProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessage_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_SetProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPPROPVARIANT pValue);


void __RPC_STUB IMimeMessage_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_DeleteProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName);


void __RPC_STUB IMimeMessage_DeleteProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_QueryProp_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszCriteria,
    /* [in] */ boolean fSubString,
    /* [in] */ boolean fCaseSensitive);


void __RPC_STUB IMimeMessage_QueryProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetTextBody_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ TEXTTYPE dwTxtType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_GetTextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_SetTextBody_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ TEXTTYPE dwTxtType,
    /* [in] */ ENCODINGTYPE ietEncoding,
    /* [in] */ HBODY hAlternative,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_SetTextBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_AttachObject_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ void __RPC_FAR *pvObject,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_AttachObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_AttachFile_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszFilePath,
    /* [in] */ IStream __RPC_FAR *pstmFile,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_AttachFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_AttachURL_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ LPCSTR pszBase,
    /* [in] */ LPCSTR pszURL,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IStream __RPC_FAR *pstmURL,
    /* [out] */ LPSTR __RPC_FAR *ppszCID,
    /* [out] */ LPHBODY phBody);


void __RPC_STUB IMimeMessage_AttachURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAttachments_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcAttach,
    /* [out] */ LPHBODY __RPC_FAR *pprghAttach);


void __RPC_STUB IMimeMessage_GetAttachments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetSender_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *ppAddress);


void __RPC_STUB IMimeMessage_GetSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAddressTable_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ IMimeAddressTable __RPC_FAR *__RPC_FAR *ppTable);


void __RPC_STUB IMimeMessage_GetAddressTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAddressTypes_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ DWORD dwAdrTypes,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeMessage_GetAddressTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetAddressFormat_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ DWORD dwAdrType,
    /* [in] */ ADDRESSFORMAT format,
    /* [out] */ LPSTR __RPC_FAR *ppszAddress);


void __RPC_STUB IMimeMessage_GetAddressFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_SplitMessage_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [in] */ ULONG cbMaxPart,
    /* [out] */ IMimeMessageParts __RPC_FAR *__RPC_FAR *ppParts);


void __RPC_STUB IMimeMessage_SplitMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessage_GetRootMoniker_Proxy(
    IMimeMessage __RPC_FAR * This,
    /* [out] */ LPMONIKER __RPC_FAR *ppmk);


void __RPC_STUB IMimeMessage_GetRootMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeMessage_INTERFACE_DEFINED__ */


#ifndef __IMimeMessageParts_INTERFACE_DEFINED__
#define __IMimeMessageParts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeMessageParts
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeMessageParts __RPC_FAR *LPMIMEMESSAGEPARTS;


EXTERN_C const IID IID_IMimeMessageParts;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1FA-C19B-11d0-85EB-00C04FD85AB4")
    IMimeMessageParts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CombineParts(
            /* [out] */ IMimeMessage __RPC_FAR *__RPC_FAR *ppMessage) = 0;

        virtual HRESULT STDMETHODCALLTYPE AddPart(
            /* [in] */ IMimeMessage __RPC_FAR *pMessage) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetMaxParts(
            /* [in] */ ULONG cParts) = 0;

        virtual HRESULT STDMETHODCALLTYPE CountParts(
            /* [out] */ ULONG __RPC_FAR *pcParts) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumParts(
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeMessagePartsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeMessageParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeMessageParts __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeMessageParts __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CombineParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [out] */ IMimeMessage __RPC_FAR *__RPC_FAR *ppMessage);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPart )(
            IMimeMessageParts __RPC_FAR * This,
            /* [in] */ IMimeMessage __RPC_FAR *pMessage);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [in] */ ULONG cParts);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CountParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcParts);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumParts )(
            IMimeMessageParts __RPC_FAR * This,
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);

        END_INTERFACE
    } IMimeMessagePartsVtbl;

    interface IMimeMessageParts
    {
        CONST_VTBL struct IMimeMessagePartsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeMessageParts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeMessageParts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeMessageParts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeMessageParts_CombineParts(This,ppMessage)	\
    (This)->lpVtbl -> CombineParts(This,ppMessage)

#define IMimeMessageParts_AddPart(This,pMessage)	\
    (This)->lpVtbl -> AddPart(This,pMessage)

#define IMimeMessageParts_SetMaxParts(This,cParts)	\
    (This)->lpVtbl -> SetMaxParts(This,cParts)

#define IMimeMessageParts_CountParts(This,pcParts)	\
    (This)->lpVtbl -> CountParts(This,pcParts)

#define IMimeMessageParts_EnumParts(This,ppEnum)	\
    (This)->lpVtbl -> EnumParts(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeMessageParts_CombineParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [out] */ IMimeMessage __RPC_FAR *__RPC_FAR *ppMessage);


void __RPC_STUB IMimeMessageParts_CombineParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_AddPart_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [in] */ IMimeMessage __RPC_FAR *pMessage);


void __RPC_STUB IMimeMessageParts_AddPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_SetMaxParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [in] */ ULONG cParts);


void __RPC_STUB IMimeMessageParts_SetMaxParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_CountParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcParts);


void __RPC_STUB IMimeMessageParts_CountParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeMessageParts_EnumParts_Proxy(
    IMimeMessageParts __RPC_FAR * This,
    /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeMessageParts_EnumParts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeMessageParts_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumHeaderRows_INTERFACE_DEFINED__
#define __IMimeEnumHeaderRows_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumHeaderRows
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumHeaderRows __RPC_FAR *LPMIMEENUMHEADERROWS;

typedef struct  tagENUMHEADERROW
    {
    HHEADERROW hRow;
    LPSTR pszHeader;
    LPSTR pszData;
    ULONG cchData;
    DWORD dwReserved;
    }	ENUMHEADERROW;

typedef struct tagENUMHEADERROW __RPC_FAR *LPENUMHEADERROW;


EXTERN_C const IID IID_IMimeEnumHeaderRows;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F0-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumHeaderRows : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMHEADERROW prgRow,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumHeaderRowsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumHeaderRows __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumHeaderRows __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMHEADERROW prgRow,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumHeaderRows __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumHeaderRows __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumHeaderRowsVtbl;

    interface IMimeEnumHeaderRows
    {
        CONST_VTBL struct IMimeEnumHeaderRowsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumHeaderRows_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumHeaderRows_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumHeaderRows_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumHeaderRows_Next(This,cFetch,prgRow,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgRow,pcFetched)

#define IMimeEnumHeaderRows_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumHeaderRows_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumHeaderRows_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumHeaderRows_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Next_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ LPENUMHEADERROW prgRow,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumHeaderRows_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Skip_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumHeaderRows_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Reset_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This);


void __RPC_STUB IMimeEnumHeaderRows_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Clone_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [out] */ IMimeEnumHeaderRows __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumHeaderRows_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumHeaderRows_Count_Proxy(
    IMimeEnumHeaderRows __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumHeaderRows_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumHeaderRows_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumProperties_INTERFACE_DEFINED__
#define __IMimeEnumProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumProperties
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumProperties __RPC_FAR *LPMIMEENUMPROPERTIES;

typedef struct  tagENUMPROPERTY
    {
    LPSTR pszName;
    HHEADERROW hRow;
    DWORD dwPropId;
    }	ENUMPROPERTY;

typedef struct tagENUMPROPERTY __RPC_FAR *LPENUMPROPERTY;


EXTERN_C const IID IID_IMimeEnumProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A20B-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMPROPERTY prgProp,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumPropertiesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumProperties __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumProperties __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ LPENUMPROPERTY prgProp,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumProperties __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumProperties __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumPropertiesVtbl;

    interface IMimeEnumProperties
    {
        CONST_VTBL struct IMimeEnumPropertiesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumProperties_Next(This,cFetch,prgProp,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgProp,pcFetched)

#define IMimeEnumProperties_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumProperties_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumProperties_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumProperties_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Next_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ LPENUMPROPERTY prgProp,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumProperties_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Skip_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumProperties_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Reset_Proxy(
    IMimeEnumProperties __RPC_FAR * This);


void __RPC_STUB IMimeEnumProperties_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Clone_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [out] */ IMimeEnumProperties __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumProperties_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumProperties_Count_Proxy(
    IMimeEnumProperties __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumProperties_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumProperties_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumAddressTypes_INTERFACE_DEFINED__
#define __IMimeEnumAddressTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumAddressTypes
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumAddressTypes __RPC_FAR *LPMIMEENUMADDRESSTYPES;


EXTERN_C const IID IID_IMimeEnumAddressTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1EB-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumAddressTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumAddressTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumAddressTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumAddressTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumAddressTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumAddressTypes __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumAddressTypesVtbl;

    interface IMimeEnumAddressTypes
    {
        CONST_VTBL struct IMimeEnumAddressTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumAddressTypes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumAddressTypes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumAddressTypes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumAddressTypes_Next(This,cFetch,prgpAddress,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgpAddress,pcFetched)

#define IMimeEnumAddressTypes_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumAddressTypes_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumAddressTypes_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumAddressTypes_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Next_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ IMimeAddressInfo __RPC_FAR *__RPC_FAR *prgpAddress,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumAddressTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Skip_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumAddressTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Reset_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This);


void __RPC_STUB IMimeEnumAddressTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Clone_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [out] */ IMimeEnumAddressTypes __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumAddressTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumAddressTypes_Count_Proxy(
    IMimeEnumAddressTypes __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumAddressTypes_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumAddressTypes_INTERFACE_DEFINED__ */


#ifndef __IMimeEnumMessageParts_INTERFACE_DEFINED__
#define __IMimeEnumMessageParts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeEnumMessageParts
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeEnumMessageParts __RPC_FAR *LPMIMEENUMMESSAGEPARTS;


EXTERN_C const IID IID_IMimeEnumMessageParts;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F2-C19B-11d0-85EB-00C04FD85AB4")
    IMimeEnumMessageParts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeMessage __RPC_FAR *__RPC_FAR *prgpMessage,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ ULONG cItems) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum) = 0;

        virtual HRESULT STDMETHODCALLTYPE Count(
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeEnumMessagePartsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeEnumMessageParts __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeEnumMessageParts __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [in] */ ULONG cFetch,
            /* [out][in] */ IMimeMessage __RPC_FAR *__RPC_FAR *prgpMessage,
            /* [out] */ ULONG __RPC_FAR *pcFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [in] */ ULONG cItems);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IMimeEnumMessageParts __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )(
            IMimeEnumMessageParts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);

        END_INTERFACE
    } IMimeEnumMessagePartsVtbl;

    interface IMimeEnumMessageParts
    {
        CONST_VTBL struct IMimeEnumMessagePartsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeEnumMessageParts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeEnumMessageParts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeEnumMessageParts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeEnumMessageParts_Next(This,cFetch,prgpMessage,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,prgpMessage,pcFetched)

#define IMimeEnumMessageParts_Skip(This,cItems)	\
    (This)->lpVtbl -> Skip(This,cItems)

#define IMimeEnumMessageParts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMimeEnumMessageParts_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IMimeEnumMessageParts_Count(This,pcItems)	\
    (This)->lpVtbl -> Count(This,pcItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Next_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [in] */ ULONG cFetch,
    /* [out][in] */ IMimeMessage __RPC_FAR *__RPC_FAR *prgpMessage,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IMimeEnumMessageParts_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Skip_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [in] */ ULONG cItems);


void __RPC_STUB IMimeEnumMessageParts_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Reset_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This);


void __RPC_STUB IMimeEnumMessageParts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Clone_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [out] */ IMimeEnumMessageParts __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IMimeEnumMessageParts_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeEnumMessageParts_Count_Proxy(
    IMimeEnumMessageParts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IMimeEnumMessageParts_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeEnumMessageParts_INTERFACE_DEFINED__ */


#ifndef __IMimeAllocator_INTERFACE_DEFINED__
#define __IMimeAllocator_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeAllocator
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeAllocator __RPC_FAR *LPMIMEALLOCATOR;


EXTERN_C const IID IID_IMimeAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1FC-C19B-11d0-85EB-00C04FD85AB4")
    IMimeAllocator : public IMalloc
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FreeParamInfoArray(
            /* [in] */ ULONG cParams,
            /* [in] */ LPMIMEPARAMINFO prgParam,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeAddressList(
            /* [out][in] */ LPADDRESSLIST pList) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReleaseObjects(
            /* [in] */ ULONG cObjects,
            /* [in] */ IUnknown __RPC_FAR *__RPC_FAR *prgpUnknown,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeEnumHeaderRowArray(
            /* [in] */ ULONG cRows,
            /* [in] */ LPENUMHEADERROW prgRow,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeEnumPropertyArray(
            /* [in] */ ULONG cProps,
            /* [in] */ LPENUMPROPERTY prgProp,
            /* [in] */ boolean fFreeArray) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeThumbprint(
            /* [in] */ THUMBBLOB __RPC_FAR *pthumbprint) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeSMIMEINFO(
            /* [in] */ SMIMEINFO __RPC_FAR *psi) = 0;

        virtual HRESULT STDMETHODCALLTYPE PropVariantClear(
            /* [in] */ LPPROPVARIANT pProp) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeAllocatorVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeAllocator __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeAllocator __RPC_FAR * This);

        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Alloc )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cb);

        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Realloc )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb);

        void ( STDMETHODCALLTYPE __RPC_FAR *Free )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetSize )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);

        int ( STDMETHODCALLTYPE __RPC_FAR *DidAlloc )(
            IMimeAllocator __RPC_FAR * This,
            void __RPC_FAR *pv);

        void ( STDMETHODCALLTYPE __RPC_FAR *HeapMinimize )(
            IMimeAllocator __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeParamInfoArray )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cParams,
            /* [in] */ LPMIMEPARAMINFO prgParam,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeAddressList )(
            IMimeAllocator __RPC_FAR * This,
            /* [out][in] */ LPADDRESSLIST pList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseObjects )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cObjects,
            /* [in] */ IUnknown __RPC_FAR *__RPC_FAR *prgpUnknown,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeEnumHeaderRowArray )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cRows,
            /* [in] */ LPENUMHEADERROW prgRow,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeEnumPropertyArray )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ ULONG cProps,
            /* [in] */ LPENUMPROPERTY prgProp,
            /* [in] */ boolean fFreeArray);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeThumbprint )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ THUMBBLOB __RPC_FAR *pthumbprint);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeSMIMEINFO )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ SMIMEINFO __RPC_FAR *psi);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PropVariantClear )(
            IMimeAllocator __RPC_FAR * This,
            /* [in] */ LPPROPVARIANT pProp);

        END_INTERFACE
    } IMimeAllocatorVtbl;

    interface IMimeAllocator
    {
        CONST_VTBL struct IMimeAllocatorVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeAllocator_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#define IMimeAllocator_Realloc(This,pv,cb)	\
    (This)->lpVtbl -> Realloc(This,pv,cb)

#define IMimeAllocator_Free(This,pv)	\
    (This)->lpVtbl -> Free(This,pv)

#define IMimeAllocator_GetSize(This,pv)	\
    (This)->lpVtbl -> GetSize(This,pv)

#define IMimeAllocator_DidAlloc(This,pv)	\
    (This)->lpVtbl -> DidAlloc(This,pv)

#define IMimeAllocator_HeapMinimize(This)	\
    (This)->lpVtbl -> HeapMinimize(This)


#define IMimeAllocator_FreeParamInfoArray(This,cParams,prgParam,fFreeArray)	\
    (This)->lpVtbl -> FreeParamInfoArray(This,cParams,prgParam,fFreeArray)

#define IMimeAllocator_FreeAddressList(This,pList)	\
    (This)->lpVtbl -> FreeAddressList(This,pList)

#define IMimeAllocator_ReleaseObjects(This,cObjects,prgpUnknown,fFreeArray)	\
    (This)->lpVtbl -> ReleaseObjects(This,cObjects,prgpUnknown,fFreeArray)

#define IMimeAllocator_FreeEnumHeaderRowArray(This,cRows,prgRow,fFreeArray)	\
    (This)->lpVtbl -> FreeEnumHeaderRowArray(This,cRows,prgRow,fFreeArray)

#define IMimeAllocator_FreeEnumPropertyArray(This,cProps,prgProp,fFreeArray)	\
    (This)->lpVtbl -> FreeEnumPropertyArray(This,cProps,prgProp,fFreeArray)

#define IMimeAllocator_FreeThumbprint(This,pthumbprint)	\
    (This)->lpVtbl -> FreeThumbprint(This,pthumbprint)

#define IMimeAllocator_FreeSMIMEINFO(This,psi)	\
    (This)->lpVtbl -> FreeSMIMEINFO(This,psi)

#define IMimeAllocator_PropVariantClear(This,pProp)	\
    (This)->lpVtbl -> PropVariantClear(This,pProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeParamInfoArray_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cParams,
    /* [in] */ LPMIMEPARAMINFO prgParam,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_FreeParamInfoArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeAddressList_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [out][in] */ LPADDRESSLIST pList);


void __RPC_STUB IMimeAllocator_FreeAddressList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_ReleaseObjects_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cObjects,
    /* [in] */ IUnknown __RPC_FAR *__RPC_FAR *prgpUnknown,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_ReleaseObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeEnumHeaderRowArray_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cRows,
    /* [in] */ LPENUMHEADERROW prgRow,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_FreeEnumHeaderRowArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeEnumPropertyArray_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ ULONG cProps,
    /* [in] */ LPENUMPROPERTY prgProp,
    /* [in] */ boolean fFreeArray);


void __RPC_STUB IMimeAllocator_FreeEnumPropertyArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeThumbprint_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ THUMBBLOB __RPC_FAR *pthumbprint);


void __RPC_STUB IMimeAllocator_FreeThumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_FreeSMIMEINFO_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ SMIMEINFO __RPC_FAR *psi);


void __RPC_STUB IMimeAllocator_FreeSMIMEINFO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeAllocator_PropVariantClear_Proxy(
    IMimeAllocator __RPC_FAR * This,
    /* [in] */ LPPROPVARIANT pProp);


void __RPC_STUB IMimeAllocator_PropVariantClear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeAllocator_INTERFACE_DEFINED__ */

#endif /* __MIMEOLE_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\fcache.h ===
/*++

	FCACHE.H

	This file defines the interface for the file handle cache !

--*/


#ifndef	_FCACHE_H_
#define	_FCACHE_H_

#include	"smartptr.h"

#ifdef	_USE_RWNH_
#include	"rwnew.h"
#else
#include	"rw.h"
#endif


class	CFileCacheKey	{
public: 
	DWORD		m_cbPathLength ;
	LPCSTR		m_lpstrPath ;
	CFileCacheKey( LPCSTR	lpstr, DWORD	cb ) : 
		m_lpstrPath( lpstr ), m_cbPathLength( cb ) {}
} ;

#define	FILECACHE_MAX_PATH	768

class	CFileCacheObject : public	CRefCount	{
private : 

	char							m_szPath[FILECACHE_MAX_PATH] ;

	CFileCacheKey					m_key ;

	HANDLE							m_hTokenOpeningUser ;
	HANDLE							m_hFile ;
	BY_HANDLE_FILE_INFORMATION		m_FileInfo ;

	PSECURITY_DESCRIPTOR			m_pSecDesc ;
	DWORD							m_cbDesc ;

#ifndef	_USE_RWNH_
	class	CShareLock&  			m_Lock ;
#else
	class	CShareLockNH			m_Lock ;
#endif

	//
	//	These constructors are private as we only want
	//	to have one possible construction method in the public space !
	//
	CFileCacheObject() ;
	CFileCacheObject( CFileCacheObject& ) ;

public : 

	//
	//	Create a CFileCacheObject object - we only save the path for
	//	future reference !
	//
	CFileCacheObject(
			CFileCacheKey&	key,
			class	CFileCacheObjectConstructor&	constructor
			) ;	

	//	
	//	Close our file handle and everything !
	//
	~CFileCacheObject() ;

	//
	//	This file actually attempt to open the file
	//
	BOOL
	Init(	
			CFileCacheObjectConstructor&	constructor
			) ;

	CFileCacheKey&	
	GetKey()	{
		return	m_key ;
	}

	int
	MatchKey( 
			CFileCacheKey&	key
			)	{
		return	key.m_cbPathLength == m_key.m_cbPathLength &&
				memcmp( key.m_lpstrPath, m_key.m_lpstrPath, m_key.m_cbPathLength ) == 0 ;
	}

	void	
	ExclusiveLock()	{
		m_Lock.ExclusiveLock() ;
	}

	void
	ExclusiveUnlock()	{
		m_Lock.ExclusiveUnlock() ;
	}

	void
	ShareLock()	{
		m_Lock.ShareLock() ;
	}

	void
	ShareUnlock()	{
		m_Lock.ShareUnlock() ;
	}

	BOOL
	AccessCheck(
			HANDLE	hToken,
			BOOL	fHoldTokens
			) ;

	//
	//	The following are the publicly available functions 
	//	for using the cached file handle data - 
	//

	HANDLE
	GetFileHandle() {
		return	m_hFile ;
	}

	//
	//
	//
	BOOL
	QuerySize(	LPDWORD	lpcbFileSizeLow, 
				LPDWORD	lpcbFileSizeHigh 
				)	{
		*lpcbFileSizeLow = m_FileInfo.nFileSizeLow ;
		*lpcbFileSizeHigh = m_FileInfo.nFileSizeHigh ;
		return	TRUE ;

	}
} ;	

typedef	CRefPtr< CFileCacheObject >	PCACHEFILE ;

class	CFileCache	{
public : 

	//
	//	Destructor must be virtual as the actual File Cache will be
	//	derived from this but accessed through the CFIleCache interface
	//	only !
	//
	virtual	~CFileCache()	{}

	//
	// If this returns true than we should have a valid file ready to go !
	//
	virtual	BOOL
	CreateFile(
		LPCSTR	lpstrName,
		DWORD	cbTotalPath,
		HANDLE	hOpeningUser, 
		HANDLE&	hFile, 
		PCACHEFILE&	pcacheFile,
		BOOL	fCachingDesired 
		) = 0 ;

	//
	//	This function is used by users who can use PreComputePathHash - 
	//	This allows some optimization as it reduces the cost of computing
	//	hash values for file names significantly if the caller can 
	//	provide a portion of the hash value !!!
	//
	virtual	BOOL
	CreateFileWithPrecomputedHash(
		LPCSTR	lpstrName,
		DWORD	cbTotalPath,
		DWORD	cbPreComputePathLength,
		DWORD	dwHashPrecompute,
		HANDLE	hOpeningUser, 
		HANDLE&	hFile, 
		PCACHEFILE&	pcacheFile,
		BOOL	fCachingDesired 
		) = 0 ;

	//
	//	Close a file handle retrieved from the cache !
	//
	virtual	BOOL
	CloseHandle(
		PCACHEFILE&	pcacheFile
		) = 0 ;

	//
	//	Create an instance of a file cache !
	//
	static	CFileCache*
	CreateFileCache(	
		DWORD	MaxHandles = 5000,
		BOOL	fHoldTokens = TRUE
		) ;

	//
	//	This function is used to Compute a portion of the hash value for 
	//	a path that will be reused several times. This allows the caller 
	//	to speed up cache searches significantly, if they can compute this
	//	value frequently !
	//
	virtual	DWORD	
	PreComputePathHash(
		LPCSTR	lpstrPath, 
		DWORD	cbPath
		) = 0 ;
	
} ;


BOOL
FileCacheInit() ;

BOOL
FileCacheTerm() ;


#endif // _FCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\fhash.inl ===
//
//	FHash.inl
//
//	This file contains the template implementation of the class TFHash.
//


//---------------------------------------------
template< class Data, class Key >
TFHash< Data, Key >::TFHash( ) : m_cBuckets( 0 ), m_cActiveBuckets( 0 ),
	m_cNumAlloced( 0 ), m_cIncrement( 0 ), m_ppBucket( 0 ), m_pfnHash( 0 ), m_load( 0 ), 
	m_pFreeStack( 0 ), m_cFreeStack( 0 ) {
//
//	Very basic constructor
//

}


//---------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::Init( 
								int cInitial, 
								int cIncrement, 
								DWORD (*pfnHash)(const Key&), 
								int load, 
								int	cMaxBucketCache 
								) {
//
//	The initialization function will allocate the initial array of Bucket pointers
//	and set the member variables.   The user can specify the following :
//
//	cInitial - the initial size of the hash table (this is rounded to the nearest power of 2.)
//	cIncrement - the amount the hash table should grow on each growth
//	pfnHash() - The function which computes the hash values for the key.
//	load - the number of elements we should have on average in each collision chain.
//

    //
    // Compute nearest power of 2
    //

	m_cMaxFreeStack = cMaxBucketCache ;

    int	power = cInitial ;
    while( power & (power-1) )
        power = power & (power-1) ;
    power<<= 1 ;

    cInitial = power;
	m_load = load ;
	m_pfnHash = pfnHash ;

    //
    // Number of ActiveBuckets is initially half that of the number of buckets.
    //

    m_cActiveBuckets = power/2  ;
    m_cBuckets = power ;
    m_cInserts = m_cActiveBuckets * m_load ;
    m_cIncrement = m_cActiveBuckets / 4;
	m_cNumAlloced = cInitial + 5 * m_cIncrement ;

	//
	// Allocate bucket pointers and zero initialize
	//

	m_ppBucket = new CBucket*[m_cNumAlloced] ;

    if( m_ppBucket ) {
	    ZeroMemory( m_ppBucket, m_cNumAlloced * sizeof( CBucket*) ) ;
	    Assert( IsValid( FALSE ) ) ;
	    return  TRUE ;
	}
	return	FALSE ;
}

//------------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::IsValid( BOOL fCheckHash ) {
//
//	This function checks that all member variables are consistent and correct.
//	Do not call this function until AFTER calling the Init() function.
//

	if( m_cBuckets <= 0 ||
		m_cActiveBuckets <= 0 ||
		m_cNumAlloced <= 0 ||
		m_cIncrement <= 0 ||
		m_load <= 0 )
		return	FALSE ;

	if( m_cActiveBuckets < (m_cBuckets / 2) || m_cActiveBuckets > m_cBuckets )
		return	FALSE ;

	if( m_cActiveBuckets > m_cNumAlloced )
		return	FALSE ;

	if( m_cInserts > (m_load * m_cActiveBuckets) )
		return	FALSE ;

	if( m_ppBucket == 0 )
		return	FALSE ;

	if( fCheckHash ) {
		//
		// Examine every bucket chain to ensure that elements are in correct slots.
		//
		for( int i=0; i<m_cNumAlloced; i++ ) {

			if( i>=m_cActiveBuckets ) {
				if( m_ppBucket[i] != 0 ) {
					return	FALSE ;
				}
			}	else	{
				for( CBucket *p = m_ppBucket[i]; p != 0; p = p->m_pNext ) {
					if( ComputeIndex( m_pfnHash( p->m_data.GetKey() ) ) != unsigned(i) ) {
						return	FALSE ;
					}
				}
			}
		}
	}
	return	TRUE ;
}


//-------------------------------------------------
template< class Data, class Key >
TFHash< Data, Key >::~TFHash() {
//
//	The destructor discards any memory we have allocated.
//
	Clear();
}


//-------------------------------------------------
template< class Data, class Key >
void	TFHash< Data, Key >::Clear() {
//
//	Discards any memory we have allocated - after this, you must
//  call Init() again!
//
	if( m_ppBucket ) {
		Assert( IsValid( TRUE ) ) ;

		for( int i=0; i<m_cNumAlloced; i++ ) {
			CBucket *p, *pNext ;
			for( p = m_ppBucket[i], pNext = p ? p->m_pNext : 0;
					p!=0; p=pNext, pNext= p ? p->m_pNext : 0 ) {
				delete	p ;
				DWORDLONG*	pdwl = (DWORDLONG*)((void*)p) ;
				delete[]	pdwl ;
			}
		}
		delete[] m_ppBucket;
	}
	for( CFreeElement*	p = m_pFreeStack; 
				p != 0; 
				p = m_pFreeStack ) {

		m_pFreeStack = p->m_pNext ;
		
		DWORDLONG*	pdwl = (DWORDLONG*)((void*)p) ;
		delete[]	pdwl ;
		m_cFreeStack -- ;
	}	
	_ASSERT( m_cFreeStack == 0 && m_pFreeStack == 0 ) ;
	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
	m_pFreeStack = 0;
	m_cFreeStack = 0;
}


//-------------------------------------------------
template< class Data, class Key >
DWORD	TFHash<Data, Key>::ComputeIndex( DWORD dw ) {
//
//	This function tells us where we should store elements.  To do this we mod with
//	m_cBuckets.  Since we only have m_cActiveBuckets in reality, we check the result
//	of the mod and subtract m_cBuckets over 2 if necessary.
//
	DWORD	dwTemp = dw % m_cBuckets ;
	return	(dwTemp >= (unsigned)m_cActiveBuckets) ? dwTemp - (m_cBuckets/2) : dwTemp ;
}


#if 0 
//-------------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::Insert( Data& d ) {
//
//	This function will Insert an element into the Hash table.  We will
//	actually make a copy of the element using the Copy COnstructor Data::Data( Data& )
//	when we do so.
//
	Assert( IsValid( FALSE ) ) ;

	//
	//	Do we have some free memory in our cache !?
	//

	CFreeElement*	pTemp = m_pFreeStack ;
	if( m_pFreeStack != 0 ) {
		m_pFreeStack = m_pFreeStack->m_pNext ;
		m_cFreeStack -- ;
	}

	CBucket*	pNew = new( pTemp )	CBucket( d ) ;
	if( pNew == 0 ) {
		return	FALSE ;
	}

	//
	// First check whether it is time to grow the hash table.
	//
	if( InterlockedDecrement( &m_cInserts ) == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			CBucket** pTemp = new CBucket*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				if( pNew ) { delete pNew; pNew = NULL; }
				return	FALSE ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( CBucket*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( CBucket* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			CBucket**	ppNext = &m_ppBucket[ iCurrent ] ;
			CBucket*	p = *ppNext ;
			while( p ) {

				int	index = ComputeIndex( m_pfnHash( p->m_data.GetKey() ) ) ;
				CBucket*	pNext = p->m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &p->m_pNext ;
				}
				p = pNext ;
			}
		}
	}

	//
	//	Finally, insert into the Hash Table.
	//
	DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	Assert( index < unsigned(m_cActiveBuckets) ) ;

#if 0
	CBucket*	pNew = new	CBucket( d ) ;
#endif

	Assert( pNew );
	pNew->m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = pNew ;

	Assert( IsValid( FALSE ) ) ;

	return	TRUE ;
}
#endif

template< class Data, class Key >
BOOL	TFHash< Data, Key >::Insert( Data& d ) {

	if( InsertData( d ) ) 
		return	TRUE ;
	return	FALSE ;
}

//-------------------------------------------------
template< class Data, class Key >
Data*	TFHash< Data, Key >::InsertDataHash( 
								DWORD	dwHash,
								Data&	d 
								) {
//
//	This function will Insert an element into the Hash table.  We will
//	actually make a copy of the element using the Copy COnstructor Data::Data( Data& )
//	when we do so.
//
	Assert( IsValid( FALSE ) ) ;


	//
	//	Do we have some free memory in our cache !?
	//

	CFreeElement*	pTemp = m_pFreeStack ;
	if( m_pFreeStack != 0 ) {
		m_pFreeStack = m_pFreeStack->m_pNext ;
		m_cFreeStack -- ;
	}

	CBucket*	pNew = new( pTemp )	CBucket( d ) ;
	if( pNew == 0 ) {
		return	FALSE ;
	}

	//
	// First check whether it is time to grow the hash table.
	//
	if( InterlockedDecrement( &m_cInserts ) == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			CBucket** pTemp = new CBucket*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				//
				//	bugbug ... need to handles this error better !?
				//
				if( pNew ) { 
					delete pNew; 
					pNew = NULL; 
				}
				return	FALSE ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( CBucket*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( CBucket* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			CBucket**	ppNext = &m_ppBucket[ iCurrent ] ;
			CBucket*	p = *ppNext ;
			while( p ) {

				int	index = ComputeIndex( m_pfnHash( p->m_data.GetKey() ) ) ;
				CBucket*	pNext = p->m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &p->m_pNext ;
				}
				p = pNext ;
			}
		}
	}

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	Assert( dwHash == m_pfnHash( d.GetKey() ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	Assert( index < unsigned(m_cActiveBuckets) ) ;

	Assert( pNew );
	pNew->m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = pNew ;

	Assert( IsValid( FALSE ) ) ;

	return	&pNew->m_data;
}




//-------------------------------------------------
template< class Data, class Key >
inline	Data*	
TFHash< Data, Key >::InsertData( Data& d ) {
//
//	This function will Insert an element into the Hash table.  We will
//	actually make a copy of the element using the Copy COnstructor Data::Data( Data& )
//	when we do so.
//
	Assert( IsValid( FALSE ) ) ;

	return	InsertDataHash(	m_pfnHash( d.GetKey() ), d ) ;
}


//-----------------------------------------------
template< class Data, class Key >
BOOL	
TFHash< Data, Key >::Search( Key& k, Data &dOut ) {
//
//	Search for an element in the hash table.
//	We will return TRUE if found, FALSE otherwise.
//	If we return false the dOut return parameter is untouched.
//

	const	Data*	pData = SearchKey( k ) ;
	if( pData ) {
		dOut = *pData ;
		return	TRUE ;
	}
	return	FALSE ;
}

//-----------------------------------------------
template< class Data, class Key >
Data*	
TFHash< Data, Key >::SearchKeyHash( 
									DWORD	dwHash, 
									Key& k 
									) {
//
//	Search for an element in the hash table.
//	We will return TRUE if found, FALSE otherwise.
//	If we return false the dOut return parameter is untouched.
//

	Assert( IsValid( FALSE ) ) ;
	Assert( dwHash == (m_pfnHash)(k) ) ;

	DWORD	index = ComputeIndex(	dwHash ) ;
	CBucket*	p = m_ppBucket[index] ;
	while( p ) {
		if( p->m_data.MatchKey( k ) )
			break ;
		p = p->m_pNext ;
	}
	if( p ) {
		return	&p->m_data ;
	}
	return	0 ;
}



//-----------------------------------------------
template< class Data, class Key >
inline	Data*	
TFHash< Data, Key >::SearchKey( Key& k ) {
//
//	Search for an element in the hash table.
//	We will return TRUE if found, FALSE otherwise.
//	If we return false the dOut return parameter is untouched.
//

	Assert( IsValid( FALSE ) ) ;

	return	SearchKeyHash( m_pfnHash( k ), k ) ;
}



//-----------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::Delete( Key k ) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	return	DeleteData( k, 0 ) ;
}



//-----------------------------------------------
template< class Data, class Key >
BOOL	TFHash< Data, Key >::DeleteData(	Key& k,
											Data*	pd
											) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	Assert( IsValid( FALSE ) ) ;

	DWORD	dwHash = (m_pfnHash)( k ) ;

	DWORD	index = ComputeIndex( dwHash ) ;
	CBucket**	ppNext = &m_ppBucket[index] ;
	CBucket*	p = *ppNext ;

	while( p ) {
		if( p->m_data.MatchKey( k ) )
			break ;
		ppNext = &p->m_pNext ;
		p = *ppNext ;
	}
	if( p ) {
		//
		//	If we were given a pointer to a data block, than the client
		//	wants us to check to make sure that we are deleting the correct
		//	instance !!
		//
		if( !pd || pd == &p->m_data ) {
			*ppNext = p->m_pNext ;


			//
			//	Call our do-nothing delete operator - we need to do more 
			//	work to manage the free'd memory !
			//
			delete	p ;

			//
			//	Now in debug versions zap that memory to make sure nobody tries
			//	to use it !!
			//
#ifdef	DEBUG
			FillMemory( p, sizeof( *p ), 0xCC ) ;
#endif
			//
			//	Okay, put that piece of free memory on a little queue we 
			//	maintain if we haven't saved up too much already !
			//
			if( m_cFreeStack < m_cMaxFreeStack ) {
				CFreeElement*	pFree = (CFreeElement*)((void*)p) ;

				pFree->m_pNext = m_pFreeStack ;
				m_pFreeStack = pFree ;
				m_cFreeStack ++ ;


			}	else	{
				//
				//	otherwise - release this memory to the system !
				//
				DWORDLONG*	pdwl = (DWORDLONG*)((void*)p) ;

				::delete[]	pdwl ;

			}

			//
			//	Finally - since we removed something from the hash table 
			//	increment the number of inserts so that we don't keep splitting
			//	the table unnecessarily !
			//
			InterlockedIncrement( &m_cInserts ) ;

			Assert( IsValid( FALSE ) ) ;
			return	TRUE ;
		}
	}
	Assert( IsValid( FALSE ) ) ;
	return	FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\fhash.h ===
//
//	FHash.h
//
//	This file contains a template class for a hash table.
//	The template has two arguments, the type of the Data Elements and the
//	type of the Key.
//
//	The Data type must support the following :
//
//	class Data {
//		Data() ;
//		Data( Data & ) ;
//		~Data() ;
//		Key&	GetKey() ;
//		int		MatchKey() ;	/* NOTE : MatchKey returns non-zero on equality
//	} ;
//
//	The Key class has no requirements.
//	
//

#ifndef	_FHASH_H_
#define	_FHASH_H_

//#include	"..\assert\assert.h"

#ifndef	Assert
#define	Assert	_ASSERT
#endif


//------------------------------------------------------------
template< class Data, class Key >
class	TFHash	{
//
//	This class defines a Hash table which can grow dynamically to
//	accomodate insertions into the table.  The table only grows, and
//	does not shrink.
//
private :

	struct	CFreeElement	{
		struct	CFreeElement*	m_pNext ;
	} ;

	//
	// The CBucket structure defines the elements within the hash table.
	//	
	struct	CBucket	{
		Data		m_data ;
		CBucket*	m_pNext ;

		CBucket( Data& d ) : m_data( d ), m_pNext( 0 ) {
		}

		CBucket( ) : m_pNext( 0 ) {
		}

		void*	operator	new( size_t size, void*	pv )	{
			if( pv != 0 ) {
				return	pv ;
			}	
			//
			//	Get memory which is DWORDLONG aligned !
			//
			return	(void*) ::new	DWORDLONG[ (size + sizeof( DWORDLONG ) - 1) / sizeof( DWORDLONG ) ] ;
		}

		void	operator	delete( void *	pv )	{}

#if _MSC_VER >= 1200
        void    operator    delete( void * p, void *pv ) {}
#endif

	private :
		CBucket( CBucket& ) {}

	} ;

	//
	//	Linked list of free memory we've cached to avoid always going
	//	through C runtimes for allocations !
	//
	CFreeElement*	m_pFreeStack ;

	//
	//	Number of Free Blocks we've cached on the stack
	//
	int		m_cFreeStack ;

	//	
	//	Maximum number of Free Blocks we should cache !
	//
	int		m_cMaxFreeStack ;

	int		m_cBuckets ;		// Number of Buckets used in index computation
	int		m_cActiveBuckets ;	// Number of Buckets we are actually using
								// Assert( m_cBuckets >= m_cActiveBuckets ) always true.
	int		m_cNumAlloced ;		// Number of Buckets we have allocated
								// Assert( m_cNumAlloced >= m_cActiveBuckets ) must
								// always be true.
	int		m_cIncrement ;		// The amount we should grow the hash table when we
								// decide to grow it.
	int		m_load ;			// The number of CBuckets we should allow in each
								// collision chain (on average).
	long	m_cInserts ;		// A counter that we use to determine when to grow the
								// hash table.

	DWORD	(* m_pfnHash)( const Key& k ) ;	// The function we use to compute hash values.
										// (Provided by the Caller of Init())

	CBucket**	m_ppBucket ;	// An array of pointer to buckets.

	DWORD	ComputeIndex( DWORD dw ) ;	// The function we use to compute the
								// position of an element in the hash table given its
								// Hash Value.
public :
	TFHash( ) ;
	~TFHash( ) ;

	BOOL	Init(	int	cInitial,
					int cIncrement,
					DWORD (* pfnHash)( const Key& ),
					int load = 2,
					int cMaxFreeStack = 128
					) ;

	//
	//	Check that the hash table is in a valid state
	//	if fCheckHash == TRUE we will walk all the buckets and check that
	//	the data hashes to the correct value !
	//
	BOOL	IsValid( BOOL fCheckHash = FALSE ) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	InsertDataHash(	DWORD	dw,
							Data&	d
							) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	InsertData(	Data&	d ) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	SearchKeyHash(	DWORD	dw,
							Key& k
							) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	SearchKey(	Key& k ) ;

	//
	//	Search for a given Key in the Hash Table and delete the
	//	data if present.  if pd != 0 then we will check that the key
	//	we find is actually within the CBucket object which pd lies within.
	//
	BOOL	DeleteData(	Key& k,	
						Data*	pd = 0	
						) ;

	//	
	//	Insert the given block of data into the hash table.
	//	We will make a copy of the Data Object and store it in one
	//	of our bucket objects.
	//
	BOOL	Insert( Data&	d	) ;

	//	
	//	Find the given key in the table and copy the Data object into
	//	the out parameter 'd'
	//
	BOOL	Search( Key& k,
					Data &d
					) ;

	//
	//	Delete the key and associated data from the table.
	//
	BOOL	Delete( Key k ) ;

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	void	Clear( ) ;

} ;

#include	"fhash.inl"

#endif // _FHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\fdlhash.inl ===
/*++

	fdlhash.inl

	This file contains the template implementation of the class TFDLHash

--*/



#ifdef	METER
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
long
TFDLHash< Data, KEYREF, s_Offset >::BucketDepth(
									DWORD	index
									) {
/*++

Routine Description :

	computes how deep the specified bucket is !
	
Arguments :

	index - the hash bucket thats changed length !

Return Value :

	Depth of the bucket !
	
--*/

	_ASSERT( IsValid( FALSE ) ) ;

	long	l = 0 ;
	ITER	i = m_pBucket[index] ;
	while( !i.AtEnd() ) {
		i.Next() ;
		l ++ ;
	}
	return	l ;
}

template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset	
			>
void
TFDLHash< Data, KEYREF, s_Offset >::MaxBucket(
									DWORD	index
									) {
/*++

Routine Description :

	Sets our statistics for what the deepest bucket is !
	
Arguments :

	index - the hash bucket that was touched !

Return Value :

	None.
	
--*/

	if( m_pStat )	{
		long l = BucketDepth( index ) ;
		m_pStat->m_cHashCounters[CHashStats::DEEPBUCKET] =
				max( m_pStat->m_cHashCounters[CHashStats::DEEPBUCKET], l ) ;
	}
}

template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::AverageBucket() {
/*++

Routine Description :

	Sets out statistics for what the average bucket depth is !
	
Arguments :

	index - the hash bucket that was touched !

Return Value :

	None.
	
--*/

	if( m_pStat )	{
		BOOL	fReMax = (m_pStat->m_cHashCounters[CHashStats::INSERTS] % 1000) == 0 ;
		if( fReMax ) {
			m_pStat->m_cHashCounters[CHashStats::DEEPBUCKET] = 0 ;
		}

		if( (m_pStat->m_cHashCounters[CHashStats::INSERTS] % 200) == 0 ) {

			long	l = m_pStat->m_cHashCounters[CHashStats::HASHITEMS] ;
			long	cNonEmpty = 0 ;
			for( int i=0; i < m_cActiveBuckets ; i++ ) {
				if( !m_pBucket[i].IsEmpty() )	{
					cNonEmpty ++ ;
					if( fReMax )
						MaxBucket( DWORD(i) ) ;
				}
			}
			m_pStat->m_cHashCounters[CHashStats::AVERAGEBUCKET] =
						l / cNonEmpty ;
			m_pStat->m_cHashCounters[CHashStats::EMPTYBUCKET] = m_cActiveBuckets - cNonEmpty ;
		}
	}
}



template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::AverageSearch(
									BOOL	fHit,
									long	depthSearch
									) {
/*++

Routine Description :

	Computes the average Search depth !
	
Arguments :

	depthSearch - how long the search went !

Return Value :

	none

--*/

	if( m_pStat )	{
	
		if( (m_pStat->m_cHashCounters[CHashStats::SEARCHHITS] % 500) == 0 ) {
			m_pStat->m_cHashCounters[CHashStats::DEEPSEARCH] = 0 ;
		}

	
		if( depthSearch != 0 ) {
			long	searches = m_pStat->m_cHashCounters[CHashStats::SEARCHHITS] ;
			searches = min( searches, 100 ) ;	// Average over the last 100 hits !
				__int64	sum = m_pStat->m_cHashCounters[CHashStats::AVERAGESEARCH] *
							(searches) ;
			__int64 average = (sum + ((__int64)depthSearch)) / ((__int64)searches+1) ;

			m_pStat->m_cHashCounters[CHashStats::AVERAGESEARCH] = (long)average ;
		}

		if( fHit )	{
			INCREMENTSTAT( SEARCHHITS ) ;
			ADDSTAT( SEARCHCOST, depthSearch ) ;
		}	else	{
			ADDSTAT( SEARCHCOSTMISS, depthSearch ) ;
		}

		m_pStat->m_cHashCounters[CHashStats::DEEPSEARCH] =
			max( m_pStat->m_cHashCounters[CHashStats::DEEPSEARCH], depthSearch ) ;
	}
}
#endif	// METER




//---------------------------------------------
template<	class Data,
			class KEYREF,		/* This is the type used to point or reference items in the cache*/
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
TFDLHash< Data, KEYREF, s_Offset	>::TFDLHash( ) :
	m_cBuckets( 0 ),
	m_cActiveBuckets( 0 ),
	m_cNumAlloced( 0 ),
	m_cIncrement( 0 ),
	m_pBucket( 0 ),
	m_pfnHash( 0 ),
	m_pGetKey( 0 ),
	m_pMatchKey( 0 ),	
	m_load( 0 )	{
//
//	Very basic constructor
//

}

//---------------------------------------------
template<	class	Data,
			class	KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL	
TFDLHash< Data, KEYREF, s_Offset >::Init(
							int cInitial,
							int cIncrement,
							int load,
							PFNHASH		pfnHash,
							GETKEY		pGetKey,
							MATCHKEY	pMatchKey,
							PFNREHASH	pfnReHash,
							CHashStats*	pStats
							) {
/*++

Routine Description :

	Initialize the hash table

Arguments :

	pNext - A pointer to Member with class Data where we can hold
		our bucket pointers !
	cInitial - Initial size of the hash table
	cIncrement - Amount to grow the hash table by !
	pfnHash - Hash Function -
	load - Average bucket length before growing the table !

Return Value :

	TRUE if successfull FALSE otherwise

--*/

#ifdef	METER
	m_pStat = pStats ;
#endif

	m_pGetKey = pGetKey ;
	m_pMatchKey = pMatchKey ;

    //
    // Compute nearest power of 2
    //

    int	power = cInitial ;
    while( power & (power-1) )
        power = power & (power-1) ;
    power<<= 1 ;

    cInitial = power;
	m_load = load ;
	m_pfnHash = pfnHash ;
	m_pfnReHash = pfnReHash ;

    //
    // Number of ActiveBuckets is initially half that of the number of buckets.
    //

    m_cActiveBuckets = power/2  ;
    m_cBuckets = power ;
    m_cInserts = m_cActiveBuckets * m_load ;
    m_cIncrement = m_cActiveBuckets / 4;
	m_cNumAlloced = cInitial + 5 * m_cIncrement ;

	//
	// Allocate bucket pointers and zero initialize
	//

	m_pBucket = new DLIST[m_cNumAlloced] ;

	SETSTAT( ALLOCBUCKETS, m_cNumAlloced ) ;
	SETSTAT( ACTIVEBUCKETS, m_cActiveBuckets ) ;
	SETSTAT( SPLITINSERTS, m_cInserts ) ;

    if( m_pBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;
	    return  TRUE ;
	}
	return	FALSE ;
}



//------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL	
TFDLHash< Data, KEYREF, s_Offset >::IsValidBucket( int	i )		{
/*++

Routine Description :

	Chech that the hash bucket is valid !

Arguments :

	i - the bucket to check !

Return Value :

	TRUE if successfull FALSE otherwise

--*/

	if( i>=m_cActiveBuckets ) {
		if( !m_pBucket[i].IsEmpty() ) {
			_ASSERT(1==0) ;
			return	FALSE ;
		}
	}	else	{
		ITER	iterNext = m_pBucket[i] ;
		if( !iterNext.AtEnd() )
			iterNext.Next() ;
		for( ITER	iter = m_pBucket[i]; !iter.AtEnd(); iter.Next()) {
			Data	*p = iter.Current() ;
			KEYREF	keyref = (p->*m_pGetKey)();
			DWORD	dwHash = m_pfnHash( keyref ) ;
			DWORD	index = ComputeIndex(dwHash) ;
			if( index != unsigned(i) ) {
				_ASSERT(1==0);
				return	FALSE ;
			}
			if( fOrdered ) {
				if( !iterNext.AtEnd() ) {
					Data	*pNext = iterNext.Current() ;
					KEYREF	keyrefNext = (pNext->*m_pGetKey)() ;
					int	iCompare = (*m_pMatchKey)( keyref, keyrefNext ) ;
					_ASSERT( iCompare < 0 ) ;
					if( iCompare >= 0 )
						return	FALSE ;
					iterNext.Next() ;
				}
			}
		}
	}
	return	TRUE ;
}



//------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL	
TFDLHash< Data, KEYREF, s_Offset >::IsValid( BOOL fCheckHash ) {
/*++

Routine Description :

	Check that the hash table is valid

Arguments :

	fCheckHash - verify that all the buckets contain the correct hash values !

Return Value :

	TRUE if successfull FALSE otherwise

--*/

	//
	//	This function checks that all member variables are consistent and correct.
	//	Do not call this function until AFTER calling the Init() function.
	//

	if( m_cBuckets <= 0 ||
		m_cActiveBuckets <= 0 ||
		m_cNumAlloced <= 0 ||
		m_cIncrement <= 0 ||
		m_load <= 0 )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_cActiveBuckets < (m_cBuckets / 2) || m_cActiveBuckets > m_cBuckets )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_cActiveBuckets > m_cNumAlloced )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_cInserts > (m_load * m_cActiveBuckets) )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( m_pBucket == 0 )	{
		_ASSERT(1==0) ;
		return	FALSE ;
	}

	if( fCheckHash ) {
		//
		// Examine every bucket chain to ensure that elements are in correct slots.
		//
		for( int i=0; i<m_cNumAlloced; i++ ) {

			if( i>=m_cActiveBuckets ) {
				if( !m_pBucket[i].IsEmpty() ) {
					_ASSERT(1==0) ;
					return	FALSE ;
				}
			}	else	{
				for( ITER	iter = m_pBucket[i]; !iter.AtEnd(); iter.Next() ) {
					Data	*p = iter.Current() ;
					KEYREF	keyref = (p->*m_pGetKey)();
					DWORD	dwHash = m_pfnHash( keyref ) ;
					DWORD	index = ComputeIndex(dwHash) ;
					if( index != unsigned(i) ) {
						_ASSERT(1==0);
						return	FALSE ;
					}
				}
			}
			_ASSERT( IsValidBucket( i ) ) ;
		}
	}
	return	TRUE ;
}



//-------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
TFDLHash< Data, KEYREF, s_Offset >::~TFDLHash() {
/*++

Routine Description :

	Destroy the hash table !

Arguments :

	None

Return Value :

	None

--*/
	//
	//	The destructor discards any memory we have allocated.
	//
	Clear();
}


//-------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::Clear() {
/*++

Routine Description :

	Delete all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !

Arguments :
	
	None.

Return Value :

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_pBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		for( int i=0; i<m_cNumAlloced; i++ ) {
			for( ITER iter=m_pBucket[i]; !iter.AtEnd(); ) {
				Data*	p = iter.RemoveItem() ;
				delete	p ;
			}
		}
		delete[] m_pBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_pBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}


//-------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::Empty() {
/*++

Routine Description :

	Remove all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !
	This is just like Clear() but it does do a "delete".

Arguments :
	
	None.

Return Value :

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_pBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		delete[] m_pBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}

//-------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
DWORD
TFDLHash<	Data, KEYREF, s_Offset >::ComputeIndex( DWORD dw ) {
/*++

Routine Description :

	Compute which bucket an element should be in

	This function tells us where we should store elements.  To do this we mod with
	m_cBuckets.  Since we only have m_cActiveBuckets in reality, we check the result
	of the mod and subtract m_cBuckets over 2 if necessary.

Arguments :

	dw - the hash value of the entry we are adding to the table

Return Value :

	Index to the bucket to use !

--*/

	DWORD	dwTemp = dw % m_cBuckets ;
	return	(dwTemp >= (unsigned)m_cActiveBuckets) ? dwTemp - (m_cBuckets/2) : dwTemp ;
}


//-----------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::SearchKeyHash(
									DWORD	dwHash,
									KEYREF	k,
									Data*	&pd
									) {
/*++

Routine Description :

	Search for an element in the Hash Table,
	
Arguments :

	dwHash - the hash value of the entry we are adding to the table
	k - reference to the key we are to compare against

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( dwHash == (m_pfnHash)(k) ) ;

	INCREMENTSTAT( SEARCHES ) ;

#ifdef	METER
	long	lSearchDepth = 0 ;
#endif

	pd = 0 ;
	DWORD	index = ComputeIndex(	dwHash ) ;
	ITER	i = m_pBucket[index] ;
	Data*	p = 0 ;
	while( !i.AtEnd() ) {
#ifdef	METER
		lSearchDepth ++ ;
#endif
		p = i.Current() ;
		int	iSign = (*m_pMatchKey)( (p->*m_pGetKey)(), k ) ;
		if( iSign == 0 ) {
			pd = p ;
			break ;
		}	else	if( fOrdered && iSign > 0 ) {
			break ;
		}
		i.Next() ;
	}
#ifdef	METER
	AverageSearch( pd != 0, lSearchDepth ) ;
#endif	
}

//-----------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::ITER
TFDLHash< Data, KEYREF, s_Offset, fOrdered >::SearchKeyHashIter(
									DWORD	dwHash,
									KEYREF	k,
									Data*	&pd
									) {
/*++

Routine Description :

	Search for an element in the Hash Table,
	
Arguments :

	dwHash - the hash value of the entry we are adding to the table
	k - reference to the key we are to compare against

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( dwHash == (m_pfnHash)(k) ) ;

	INCREMENTSTAT( SEARCHES ) ;

#ifdef	METER
	long	lSearchDepth = 0 ;
#endif

	pd = 0 ;
	DWORD	index = ComputeIndex(	dwHash ) ;
	ITER	i = m_pBucket[index] ;
	Data*	p = 0 ;
	while( !i.AtEnd() ) {
#ifdef	METER
		lSearchDepth ++ ;
#endif
		p = i.Current() ;
		int	iSign = (*m_pMatchKey)( (p->*m_pGetKey)(), k ) ;
		if( iSign == 0 ) {
			pd = p ;
			break ;
		}	else	if( fOrdered && iSign > 0 ) {
			break ;
		}
		i.Next() ;
	}
#ifdef	METER
	AverageSearch( pd != 0, lSearchDepth ) ;
#endif
	return	i ;
}

//-------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL
TFDLHash< Data, KEYREF, s_Offset >::InsertDataHashIter(
								ITER&	iter,
								DWORD	dwHash,
								KEYREF	k,
								Data*	pd
								) {
/*++

Routine Description :

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments :

	dw - the hash value of the entry we are adding to the table
	pd - Pointer to the item we are adding to the table !

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( INSERTS ) ;

#if	defined(DEBUG) || defined( METER )
	KEYREF	keyref = (pd->*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;
	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;
	_ASSERT( iter.GetHead() == &m_pBucket[index] ) ;
#endif

		//
		//	This is no longer smaller than the current guy - so insert in front
		//
	iter.InsertBefore( pd ) ;

#if	defined(DEBUG) || defined( METER )
	_ASSERT( IsValidBucket( index ) ) ;

	//
	//	Update our statistics !
	//
	//MAXBUCKET( index ) ;
#endif

	INCREMENTSTAT( HASHITEMS ) ;
	//AVERAGEBUCKET() ;
		
	_ASSERT( IsValid( FALSE ) ) ;


	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {
		Split() ;
	}

	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	return	TRUE ;
}




template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL
TFDLHash< Data, KEYREF, s_Offset >::Split( ) {
/*++

Routine Description :

	This function grows the hash table so that our average bucket depth remains constant !

Arguments :

	None.
	
Return Value :

	Index to the bucket to use !

--*/



	_ASSERT( IsValid( TRUE ) ) ;

	INCREMENTSTAT( SPLITS ) ;

	//
	// Check whether we need to reallocate the array of Bucket pointers.
	//
	if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {

		INCREMENTSTAT( REALLOCS ) ;

		DLIST*	pTemp = new DLIST[m_cNumAlloced + 10 * m_cIncrement ] ;

		if( pTemp == 0 ) {
			//
			//	bugbug ... need to handles this error better !?
			//
			return	FALSE ;
		}	else	{

			for( int i=0; i<m_cNumAlloced; i++ ) {
				pTemp[i].Join( m_pBucket[i] ) ;
			}
			delete[]	m_pBucket ;
			m_cNumAlloced += 10 * m_cIncrement ;
			m_pBucket = pTemp ;

			SETSTAT( ALLOCBUCKETS, m_cNumAlloced ) ;
		}
	}

	_ASSERT( IsValid( TRUE ) ) ;

	//
	// Okay grow the array by m_cIncrement.
	//
	m_cActiveBuckets += m_cIncrement ;
	if( m_cActiveBuckets > m_cBuckets )
		m_cBuckets *= 2 ;		
	m_cInserts = m_cIncrement * m_load ;

	SETSTAT( ACTIVEBUCKETS, m_cActiveBuckets ) ;

	//
	// Now do some rehashing of elements.
	//

	for( int	i = -m_cIncrement; i < 0; i++ ) {
		int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
		ITER	iter = m_pBucket[iCurrent] ;
		while( !iter.AtEnd() ) {
			Data*	p = iter.Current() ;
			int	index = ComputeIndex( ReHash( p ) ) ;
			if( index != iCurrent ) {
				Data*	pTemp = iter.RemoveItem() ;
				_ASSERT( pTemp == p ) ;
				m_pBucket[index].PushBack( p ) ;
			}	else	{
				iter.Next() ;
			}
		}
		_ASSERT( IsValidBucket( iCurrent ) ) ;
	}
	_ASSERT( IsValid( TRUE ) ) ;
	return	TRUE ;
}


//-------------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
BOOL
TFDLHash< Data, KEYREF, s_Offset >::InsertDataHash(
								DWORD	dwHash,
								KEYREF	k,
								Data*	pd
								) {
/*++

Routine Description :

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments :

	dw - the hash value of the entry we are adding to the table
	pd - Pointer to the item we are adding to the table !

Return Value :

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( INSERTS ) ;

	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {
		if( !Split() )	{
			return	FALSE ;
		}
	}

	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	KEYREF	keyref = (pd->*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;

	if( !fOrdered ) {
		m_pBucket[index].PushFront( pd ) ;
	}	else	{
		//
		//	Build the hash  buckets in order !
		//
		ITER	iter = m_pBucket[index] ;		
		Data*	p = 0 ;
		while( !iter.AtEnd() ) {
			p = iter.Current() ;
			int	i = (*m_pMatchKey)( (p->*m_pGetKey)(), k ) ;
			_ASSERT( i != 0 ) ;
			if( i > 0 )
				break ;
			iter.Next() ;
		}
		//
		//	This is no longer smaller than the current guy - so insert in front
		//
		iter.InsertBefore( pd ) ;
	}
	_ASSERT( IsValidBucket( index ) ) ;

	//
	//	Update our statistics !
	//
	//MAXBUCKET( index ) ;
	INCREMENTSTAT( HASHITEMS ) ;
	//AVERAGEBUCKET() ;
		
	_ASSERT( IsValid( FALSE ) ) ;

	return	TRUE ;
}

//-----------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::Delete(	Data*	pd	) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( DELETES ) ;

	if( pd ) {
		DECREMENTSTAT(HASHITEMS) ;
		m_cInserts ++ ;
		DLIST::Remove( pd ) ;
	}

	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	_ASSERT( IsValid( FALSE ) ) ;
}


template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::NotifyOfRemoval(	) {
//
//	Notify us that an item has been removed from the hash table !
//

	_ASSERT( IsValid( FALSE ) ) ;

	INCREMENTSTAT( DELETES ) ;
	DECREMENTSTAT( HASHITEMS ) ;
	m_cInserts ++ ;
	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	_ASSERT( IsValid( FALSE ) ) ;
}




//-----------------------------------------------
template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
void
TFDLHash< Data, KEYREF, s_Offset >::DeleteData(	KEYREF	k,
											Data*	pd
											) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	_ASSERT( IsValid( FALSE ) ) ;

	if( !pd ) {
		pd = SearchKey( k ) ;
	}
	if( pd ) {

		INCREMENTSTAT(DELETES) ;
		DECREMENTSTAT(HASHITEMS) ;

		_ASSERT( (*m_pMatchKey)( pd->GetKey(), k ) ) ;
		_ASSERT( SearchKey( k ) == pd ) ;
		m_cInserts ++ ;
		DLIST::Remove( pd ) ;
	}
	SETSTAT( SPLITINSERTS, m_cInserts ) ;

	_ASSERT( IsValid( FALSE ) ) ;
}

template<	class Data,
			class KEYREF,
			Data::PFNDLIST	s_Offset,
			BOOL	fOrdered
			>
DWORD
TFDLHash< Data, KEYREF, s_Offset >::ComputeHash(	KEYREF	k	)	{

	return	m_pfnHash( k ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\gibmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for a Gibraltar Service.
    
    Since gibraltar service startup is a common operation, this source
    code will be shared with all services.

    To do this, you only need to set certain #defines to your specific service.

    See %MSNROOT%\apps\mail\[pop3,smtp]\server\main.cxx for examples.

    FILE HISTORY:
        KeithMo     07-Mar-1993     Created.
        rkamicar    20-Dec-1995     Modified for sharing
*/

//
//  Private globals.
//

DEFINE_TSVC_INFO_INTERFACE();
DECLARE_DEBUG_PRINTS_OBJECT( );
DECLARE_DEBUG_VARIABLE( );

#define INITIALIZE_IPC          0x00000001
#define INITIALIZE_SOCKETS      0x00000002
#define INITIALIZE_ACCESS       0x00000004
#define INITIALIZE_SERVICE      0x00000008
#define INITIALIZE_CONNECTIONS  0x00000010
#define INITIALIZE_DISCOVERY    0x00000020

DWORD GlobalInitializeStatus = 0;
BOOL ServiceBooted = FALSE;

//
//  Global startup named event
//
HANDLE          ghStartupEvent = INVALID_HANDLE_VALUE;

//
//
// Shared TCPSVCS.EXE data
//

PTCPSVCS_GLOBAL_DATA pTcpsvcsGlobalData;

//
//  Private prototypes.
//

APIERR InitializeService( LPVOID pContext );
APIERR TerminateService( LPVOID pContext );

//+---------------------------------------------------------------------------
//
//  Function:
//
//      DllEntryPoint
//
//  Synopsis:
//  Arguments:
//  Returns:
//      See Win32 SDK
//
//  History:
//
//      Richard Kamicar     (rkamicar)              5 January 1996
//
//  Notes:
//
//      If we find we need this per service, we can move it out of here..
//
//----------------------------------------------------------------------------
BOOL WINAPI
DllEntryPoint(HINSTANCE hInst, DWORD dwReason, LPVOID lpvContext)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // To help performance, cancel thread attach and detach notifications
        //
        DisableThreadLibraryCalls((HMODULE) hInst);

        break;

    case DLL_PROCESS_DETACH:

         if( ghStartupEvent != INVALID_HANDLE_VALUE ) 
         {
            _VERIFY( CloseHandle( ghStartupEvent ) );
         }

        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

BOOL WINAPI DllMain (HANDLE hInst, ULONG dwReason, LPVOID lpvReserve)
{
  return DllEntryPoint((HINSTANCE) hInst, dwReason, lpvReserve);
}

//
//  Public functions.
//

/*******************************************************************

    NAME:       ServiceEntry

    SYNOPSIS:   This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    ENTRY:      cArgs - Number of command line arguments to this service.

                pArgs - Pointers to the command line arguments.

                pGlobalData - Points to global data shared amongst all
                    services that live in TCPSVCS.EXE.

    EXIT:       Does not return until service is stopped.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        KeithMo     07-Jan-1994 Modified for use as a DLL.

********************************************************************/
VOID ServiceEntry( DWORD                cArgs,
                   LPWSTR               pArgs[],
                   PTCPSVCS_GLOBAL_DATA pGlobalData )
{
    APIERR err = NO_ERROR;

    InitAsyncTrace();
    TraceQuietEnter( "ServiceEntry");

    //
    //  Save the global data pointer.
    //

    pTcpsvcsGlobalData = pGlobalData;

    //
    //  Initialize the service status structure.
    //

    DebugTrace( 0, "new TSVC_INFO( %s)", XXX_SERVICE_NAME);

    g_pTsvcInfo = new TSVC_INFO( XXX_SERVICE_NAME,
                                 XXX_MODULE_NAME,
                                 XXX_PARAMETERS_KEY_A,
                                 XXX_ANONYMOUS_SECRET_W,
                                 XXX_ROOT_SECRET_W,
                                 XXX_INET,
                                 InitializeService,
                                 TerminateService );

    //
    //  If we couldn't allocate memory for the service info struct, then the
    //  machine is really hosed -- we can't even log..
    //
    if (!g_pTsvcInfo || !g_pTsvcInfo->IsValid())
    {
        FatalTrace( 0, "new TSVC_INFO( %s) failed: %x",
            XXX_SERVICE_NAME, g_pTsvcInfo);
        if (g_pTsvcInfo != NULL) 
        {
            delete g_pTsvcInfo;
            g_pTsvcInfo = NULL;
        }
        goto out;
    }
    //
    // save the global pointer for rpc thread
    //
    g_pTsvcInfo->SetTcpsvcsGlobalData( pTcpsvcsGlobalData);
    //
    //  This blocks until the service is shutdown
    //
    err = g_pTsvcInfo->StartServiceOperation( SERVICE_CTRL_HANDLER() );

    delete g_pTsvcInfo;
    g_pTsvcInfo = NULL;

out:    
    TermAsyncTrace( );

}   // ServiceEntry

//
//  Private functions.
//


/*******************************************************************

    NAME:       InitializeService

    SYNOPSIS:   Initializes the various W3 Service components.

    EXIT:       If successful, then every component has been
                successfully initialized.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    status code.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
APIERR
InitializeService( LPVOID pContext )
{
    APIERR err;
    LPTSVC_INFO ptsi = (LPTSVC_INFO ) pContext;

    TraceFunctEnter("InitializeService");

    //
    //  Create a startup named event. If this already exists, refuse to boot !
    //
    HANDLE hEvent = CreateEvent( NULL, FALSE, FALSE, XXX_NAMED_EVENT);
    if( !hEvent || GetLastError() != 0 ) 
    {

        if( hEvent) 
        {
            _VERIFY( CloseHandle( hEvent ) );
        }

        g_pTsvcInfo->LogEvent(
                XXX_BOOT_ERROR,
                0,
                (const CHAR **)NULL,
                ERROR_SERVICE_ALREADY_RUNNING
                );

        return ERROR_SERVICE_ALREADY_RUNNING ;
    }

    //  set the global startup event. this is closed when our DLL_PROCESS_DETACH
    ghStartupEvent = hEvent;
    ServiceBooted  = TRUE;

    g_pTsvcInfo->LogEvent(
                XXX_EVENT_SERVICE_STARTED,
                0,
                (const CHAR **)NULL,
                0
                );

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.  Globals should be
    //  initialized first, then the event logger.  After
    //  the event logger is initialized, the other components
    //  may be initialized in any order with one exception.
    //  InitializeSockets must be the last initialization
    //  routine called.  It kicks off the main socket connection
    //  thread.
    //

     if(( err = InitializeGlobals()))
     {
        FatalTrace( 0, "InitializeGlobals failed, err=%d.", err); 
        TraceFunctLeave();
        return err;
     }

    if( (err = ptsi->InitializeIpc( (UCHAR *) "ncacn_np",
                                     (UCHAR *) XXX_NAMED_PIPE,
                                     XXX_ServerIfHandle)) != NO_ERROR)
    {
        FatalTrace( 0, "InitializeIpc failed, err=%d.", err); 
        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_IPC;

    if((err = g_pTsvcInfo->InitializeDiscovery( NULL)))
    {
        FatalTrace( 0, "InitializeDiscovery failed, err=%d.", err); 
        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_DISCOVERY;

    if((err = InitializeSockets()))
    {
        FatalTrace( 0, "InitializeSockets failed, err=%d.", err); 
        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_SOCKETS;
 
    //
    //  InitializeConnection
    //

    if ( !g_pTsvcInfo->InitializeConnections(
                                        &XXX_OnConnect,
                                        &XXX_OnConnectEx,
                                        &XXX_Completion,
                                        XXX_SECURE_PORT,
                                        0 ))
    {

        err = GetLastError();
        g_pTsvcInfo->LogEvent(
                    XXX_EVENT_CANNOT_INITIALIZE_WINSOCK,
                    0,
                    (const CHAR **)NULL,
                    err
                    );

        ErrorTrace(0,"InitializeConnections failed, error %d",err );
        return err;
    }

     GlobalInitializeStatus |= INITIALIZE_CONNECTIONS;

    //
    //  Success!
    //

    TraceFunctLeave();
    
    return NO_ERROR;

}   // InitializeService

/*******************************************************************

    NAME:       TerminateService

    SYNOPSIS:   Terminates the various W3 Service components.

    EXIT:       If successful, then every component has been
                successfully terminated.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
APIERR TerminateService( LPVOID pContext )
{
    LPTSVC_INFO ptsi = (LPTSVC_INFO ) pContext;
    DWORD err;

    TraceFunctEnter("TerminateService");

    if(!ServiceBooted)
    {
        return NO_ERROR;    
    }

    ServiceBooted = FALSE;

    _ASSERT(ptsi == g_pTsvcInfo);
    
    //
    //  Components should be terminated in reverse
    //  initialization order.
    //

    //
    // must happen after CleanupConnections so no new conns accepted
    //
    if ( GlobalInitializeStatus & INITIALIZE_CONNECTIONS)
    {
        g_pTsvcInfo->CleanupConnections();
    }

    if (XXX_g_Config != NULL)
    {
        XXX_g_Config->DisconnectAllConnections();
    }
    
    if ( GlobalInitializeStatus & INITIALIZE_SOCKETS) 
    {
        TerminateSockets();
    }

    if ( GlobalInitializeStatus & INITIALIZE_DISCOVERY) 
    {
        if ( (err = ptsi->TerminateDiscovery()) != NO_ERROR)
        {
            ErrorTrace(0, "TerminateDiscovery() failed. Error = %u", err);
        }
    }

    if ( GlobalInitializeStatus & INITIALIZE_IPC)
    {
        if ( (err = ptsi->CleanupIpc( XXX_ServerIfHandle)) != NO_ERROR)
        {
            ErrorTrace(0, "CleanupIpc() failed. Error = %u", err);
        }
    }

    TerminateGlobals();

    g_pTsvcInfo->LogEvent(
                XXX_EVENT_SERVICE_STOPPED,
                0,
                (const CHAR **)NULL,
                0
                );

    TraceFunctLeave();
    return NO_ERROR;

}  // TerminateService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\esh.cpp ===
// esh.cpp: implementation of the CEventScriptHandler class.
//
//////////////////////////////////////////////////////////////////////

//#include "stdafx.h"
#include <esh.h>
#include <scripto.h>
#include <pbag.h>
#include <stags.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEventScriptHandler::CEventScriptHandler()
{
	m_cNamedProps = 0;
	m_pScripto = NULL;
	m_pBag = new CPropBag;
	VariantInit(&m_varErrorResponse);
	VariantInit(&m_varScriptResponse);
}

CEventScriptHandler::~CEventScriptHandler()

{
	if( m_pBag != NULL )
		m_pBag->Release();

	if( m_pScripto != NULL )
		m_pScripto->Release();
}

STDMETHODIMP CEventScriptHandler::SetScript(BSTR bstrFileName)
{
	HRESULT hr = NOERROR;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	CStreamFile* pstmFile = NULL;

	if( bstrFileName == NULL )
		return E_POINTER;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

	hFile = CreateFileW(bstrFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
		OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if( hFile == INVALID_HANDLE_VALUE )
	{
		hr = HRGetLastError();
		goto exit;
	}

	pstmFile = new CStreamFile(hFile,TRUE);
	if( pstmFile == NULL )
	{
		CloseHandle(hFile);
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	hr = SetScript((IStream*)pstmFile);

exit:
	if( pstmFile != NULL )
		pstmFile->Release();

	return hr;
}

STDMETHODIMP CEventScriptHandler::SetScript(IStream * pstmScript)
{
	HRESULT hr = NOERROR;
    VARIANT var;
	IUnknown* pUnk = NULL;

	if( pstmScript == NULL )
		return E_POINTER;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

	hr = pstmScript->QueryInterface(IID_IUnknown,(void**)&pUnk);
	if(FAILED(hr))
		goto exit;

    // put the script stream into the bag
    V_VT(&var) = VT_UNKNOWN;
	V_UNKNOWN(&var) = (IUnknown*)pUnk;
    hr = m_pBag->Write(wszScriptTextProp, &var);
    VariantClear(&var);
exit:
	return hr;
}

STDMETHODIMP CEventScriptHandler::AddGlobalVariable(BSTR bstrName, VARIANT varVariable)
{
	HRESULT hr = NOERROR;
    WCHAR wszBagProp[64] = {0};
    VARIANT var;

	if( bstrName == NULL )
		return E_POINTER;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

    VariantInit(&var);
	m_cNamedProps++;

	// add the name
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = SysAllocString(bstrName);
	wsprintfW(wszBagProp, L"%ls%ld", wszNamedPropIDPrefix, m_cNamedProps);
	hr = m_pBag->Write(wszBagProp, &var);
	VariantClear(&var);
	if(FAILED(hr))
		goto exit;

	// add the value
	wsprintfW(wszBagProp, L"%ls%ld", wszNamedUnkPtrPrefix, m_cNamedProps);
	hr = m_pBag->Write(wszBagProp, &varVariable);
	if(FAILED(hr))
		goto exit;

	// not a NamedSource (for connection points)
	V_VT(&var) = VT_BOOL;
	V_BOOL(&var) = VARIANT_FALSE;
	wsprintfW(wszBagProp, L"%ls%ld", wszNamedSourcesPrefix, m_cNamedProps);
	hr = m_pBag->Write(wszBagProp, &var);
	if(FAILED(hr))
		goto exit;

exit:
	return hr;
}

STDMETHODIMP CEventScriptHandler::AddConnectionPoint(BSTR bstrName, IConnectionPointContainer * pContainer)
{
	HRESULT hr = NOERROR;
    WCHAR wszBagProp[64] = {0};
    VARIANT var;

	if( bstrName == NULL || pContainer == NULL )
		return E_POINTER;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

    VariantInit(&var);
	m_cNamedProps++;

	// add the name
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = SysAllocString(bstrName);
	wsprintfW(wszBagProp, L"%ls%ld", wszNamedPropIDPrefix, m_cNamedProps);
	hr = m_pBag->Write(wszBagProp, &var);
	VariantClear(&var);
	if(FAILED(hr))
		goto exit;

	// add the value as IUnknown*
	V_VT(&var) = VT_UNKNOWN;
	hr = pContainer->QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&var));
	if(FAILED(hr))
		goto exit;
	wsprintfW(wszBagProp, L"%ls%ld", wszNamedUnkPtrPrefix, m_cNamedProps);
	hr = m_pBag->Write(wszBagProp, &var);
	VariantClear(&var);
	if(FAILED(hr))
		goto exit;

	// the object is a NamedSource, so we will connect to
	// script functions that look like <Object>_xxx
	V_VT(&var) = VT_BOOL;
	V_BOOL(&var) = VARIANT_TRUE;
	wsprintfW(wszBagProp, L"%ls%ld", wszNamedSourcesPrefix, m_cNamedProps);
	hr = m_pBag->Write(wszBagProp, &var);
	if(FAILED(hr))
		goto exit;

exit:
	return hr;
}

STDMETHODIMP CEventScriptHandler::ASPSyntax(BOOL fIsASPSyntax)
{
	HRESULT hr = NOERROR;
    VARIANT var;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fIsASPSyntax ? VARIANT_TRUE : VARIANT_FALSE ;
    hr = m_pBag->Write(wszASPSyntaxProp, &var);

	return hr;
}

STDMETHODIMP CEventScriptHandler::AllowCreateObject(BOOL fCreateObjectAllowed)
{
	HRESULT hr = NOERROR;
    VARIANT var;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fCreateObjectAllowed ? VARIANT_TRUE : VARIANT_FALSE ;
    hr = m_pBag->Write(wszEnableCreateObjects, &var);

	return hr;
}

STDMETHODIMP CEventScriptHandler::MaxExecutionTime(DWORD dwMaxExecutionTime)
{
	HRESULT hr = NOERROR;
    VARIANT var;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

    V_VT(&var) = VT_UI4;
    V_UI4(&var) = dwMaxExecutionTime;
    hr = m_pBag->Write(wszMaxExecutionTimeProp, &var);

	return hr;
}

STDMETHODIMP CEventScriptHandler::StartScript()
{
	HRESULT hr = NOERROR;
    VARIANT var;

	if( m_pBag == NULL )
		return E_OUTOFMEMORY;

	if( m_pScripto != NULL )
		return RestartScript();

	// write the number of named props to pBag
    V_VT(&var) = VT_UI4;
    V_UI4(&var) = m_cNamedProps;
    hr = m_pBag->Write(wszNumNamedPropsProp, &var);
	if(FAILED(hr))
		goto exit;

	// create the scripto object
	hr = CoCreateInstance(CLSID_Scripto, NULL, CLSCTX_INPROC_SERVER, IID_IScripto, (void**)&m_pScripto);
	if(FAILED(hr))
		goto exit;

	// init the script
	hr = m_pScripto->InitScript(m_pBag);
	if( FAILED(hr) )
	{
		VariantClear(&m_varErrorResponse);
	    m_pBag->Read(wszErrorResponse, &m_varErrorResponse, NULL);
	}
	else
	{
		VariantClear(&m_varScriptResponse);
	    m_pBag->Read(wszScriptResponse, &m_varScriptResponse, NULL);
	}

exit:
	return hr;
}

STDMETHODIMP CEventScriptHandler::RestartScript()
{
	HRESULT hr = NOERROR;

	if( m_pScripto == NULL )
		return E_OUTOFMEMORY;

	if( !m_fScriptStopped )
		StopScript();

	hr = m_pScripto->ReInitScript(NULL);

	return hr;
}

STDMETHODIMP CEventScriptHandler::StopScript()
{
	HRESULT hr = NOERROR;

	if( m_pScripto == NULL )
		return E_OUTOFMEMORY;

	hr = m_pScripto->DeActivateScript(FALSE);
	m_fScriptStopped = TRUE;

	return hr;
}

STDMETHODIMP CEventScriptHandler::ExecuteConnectionPoint(IConnectionPoint* pConnectionPoint, DISPID dispid)
{
	HRESULT hr = NOERROR;
    IEnumConnections* pConnections = NULL;
    CONNECTDATA ConnectData = {0};
    LPDISPATCH pConnection = NULL;
    DWORD cConnections = 0;
    DISPPARAMS NoArgs = {NULL, NULL, 0, 0};
    bool fGotOne = false;

	if( pConnectionPoint == NULL )
		return E_POINTER;

	if( m_pScripto == NULL )
		return E_OUTOFMEMORY;

    // find out if the script has any connections for this event
    hr = pConnectionPoint->EnumConnections(&pConnections);
    if(hr == S_FALSE)
    {
        // No connection points.
        hr = DISP_E_UNKNOWNNAME;
		goto exit;
    }
	else if( FAILED(hr) )
		goto exit;

	hr = pConnections->Reset();
	if( FAILED(hr) )
		goto exit;

    // loop through each connection and execute its associated code
    do
    {
        hr = pConnections->Next(1, &ConnectData, &cConnections);
        if(SUCCEEDED(hr))
        {
			if(cConnections)
			{
				hr = ConnectData.pUnk->QueryInterface(IID_IDispatch, (void**)&pConnection);
				if(SUCCEEDED(hr))
				{
					// try to invoke - this may fail non-fatally
					hr = pConnection->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &NoArgs, NULL, NULL, NULL);
					if(hr != DISP_E_UNKNOWNNAME)
					{
						// we at least got one connection point
						fGotOne = true;

						if( FAILED(hr) )
						{
							// event execution failed
							VariantClear(&m_varErrorResponse);
							m_pBag->Read(wszErrorResponse, &m_varErrorResponse, NULL);
							m_pScripto->Abort();
						}
						else
						{
							VariantClear(&m_varScriptResponse);
							m_pBag->Read(wszScriptResponse, &m_varScriptResponse, NULL);
							m_pScripto->Complete();
						}
					}  

					pConnection->Release();
					pConnection = NULL;
				}
				
				ConnectData.pUnk->Release();
				ConnectData.pUnk = NULL;
			}
			else
			{
				// means we are done - no more connections
				// if we got at least one to work then we consider it
				// a success
				hr = fGotOne ? S_OK : DISP_E_UNKNOWNNAME;
			}
		}
    }
	while(SUCCEEDED(hr) && cConnections);

	// tell scripto whether we are happy campers or not
	if(SUCCEEDED(hr))
	{
		m_pScripto->Complete();
	}
	else
	{
		m_pScripto->Abort();
	}

	// must leave scripto in the deactived state so that it can be
	// called again on another thread
	m_pScripto->DeActivateScript(false);

exit:
	if( pConnections )
		pConnections->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\iiis.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Sun Nov 16 14:28:38 1997
 */
/* Compiler settings for iis.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __iiis_h__
#define __iiis_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IISMimeType_FWD_DEFINED__
#define __IISMimeType_FWD_DEFINED__
typedef interface IISMimeType IISMimeType;
#endif 	/* __IISMimeType_FWD_DEFINED__ */


#ifndef __MimeMap_FWD_DEFINED__
#define __MimeMap_FWD_DEFINED__

#ifdef __cplusplus
typedef class MimeMap MimeMap;
#else
typedef struct MimeMap MimeMap;
#endif /* __cplusplus */

#endif 	/* __MimeMap_FWD_DEFINED__ */


#ifndef __IISIPSecurity_FWD_DEFINED__
#define __IISIPSecurity_FWD_DEFINED__
typedef interface IISIPSecurity IISIPSecurity;
#endif 	/* __IISIPSecurity_FWD_DEFINED__ */


#ifndef __IPSecurity_FWD_DEFINED__
#define __IPSecurity_FWD_DEFINED__

#ifdef __cplusplus
typedef class IPSecurity IPSecurity;
#else
typedef struct IPSecurity IPSecurity;
#endif /* __cplusplus */

#endif 	/* __IPSecurity_FWD_DEFINED__ */


#ifndef __IISNamespace_FWD_DEFINED__
#define __IISNamespace_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISNamespace IISNamespace;
#else
typedef struct IISNamespace IISNamespace;
#endif /* __cplusplus */

#endif 	/* __IISNamespace_FWD_DEFINED__ */


#ifndef __IISProvider_FWD_DEFINED__
#define __IISProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISProvider IISProvider;
#else
typedef struct IISProvider IISProvider;
#endif /* __cplusplus */

#endif 	/* __IISProvider_FWD_DEFINED__ */


#ifndef __IISDsCrMap_FWD_DEFINED__
#define __IISDsCrMap_FWD_DEFINED__
typedef interface IISDsCrMap IISDsCrMap;
#endif 	/* __IISDsCrMap_FWD_DEFINED__ */


#ifndef __IISApp_FWD_DEFINED__
#define __IISApp_FWD_DEFINED__
typedef interface IISApp IISApp;
#endif 	/* __IISApp_FWD_DEFINED__ */


#ifndef __IISComputer_FWD_DEFINED__
#define __IISComputer_FWD_DEFINED__
typedef interface IISComputer IISComputer;
#endif 	/* __IISComputer_FWD_DEFINED__ */


#ifndef __IISBaseObject_FWD_DEFINED__
#define __IISBaseObject_FWD_DEFINED__
typedef interface IISBaseObject IISBaseObject;
#endif 	/* __IISBaseObject_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __IISOle_LIBRARY_DEFINED__
#define __IISOle_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: IISOle
 * at Sun Nov 16 14:28:38 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_IISOle;

#ifndef __IISMimeType_INTERFACE_DEFINED__
#define __IISMimeType_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISMimeType
 * at Sun Nov 16 14:28:38 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISMimeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9036B027-A780-11d0-9B3D-0080C710EF95")
    IISMimeType : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MimeType( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MimeType( 
            /* [in] */ BSTR bstrMimeType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Extension( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Extension( 
            /* [in] */ BSTR bstrExtension) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISMimeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISMimeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISMimeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISMimeType __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MimeType )( 
            IISMimeType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MimeType )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ BSTR bstrMimeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Extension )( 
            IISMimeType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Extension )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ BSTR bstrExtension);
        
        END_INTERFACE
    } IISMimeTypeVtbl;

    interface IISMimeType
    {
        CONST_VTBL struct IISMimeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISMimeType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISMimeType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISMimeType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISMimeType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISMimeType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISMimeType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISMimeType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISMimeType_get_MimeType(This,retval)	\
    (This)->lpVtbl -> get_MimeType(This,retval)

#define IISMimeType_put_MimeType(This,bstrMimeType)	\
    (This)->lpVtbl -> put_MimeType(This,bstrMimeType)

#define IISMimeType_get_Extension(This,retval)	\
    (This)->lpVtbl -> get_Extension(This,retval)

#define IISMimeType_put_Extension(This,bstrExtension)	\
    (This)->lpVtbl -> put_Extension(This,bstrExtension)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISMimeType_get_MimeType_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IISMimeType_get_MimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISMimeType_put_MimeType_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [in] */ BSTR bstrMimeType);


void __RPC_STUB IISMimeType_put_MimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISMimeType_get_Extension_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IISMimeType_get_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISMimeType_put_Extension_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [in] */ BSTR bstrExtension);


void __RPC_STUB IISMimeType_put_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISMimeType_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MimeMap;

#ifdef __cplusplus

class DECLSPEC_UUID("9036B028-A780-11d0-9B3D-0080C710EF95")
MimeMap;
#endif

#ifndef __IISIPSecurity_INTERFACE_DEFINED__
#define __IISIPSecurity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISIPSecurity
 * at Sun Nov 16 14:28:38 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISIPSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3287521-BBA3-11d0-9BDC-00A0C922E703")
    IISIPSecurity : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IPDeny( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IPDeny( 
            /* [in] */ VARIANT vIPDeny) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IPGrant( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IPGrant( 
            /* [in] */ VARIANT vIPGrant) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainDeny( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DomainDeny( 
            /* [in] */ VARIANT vDomainDeny) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainGrant( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DomainGrant( 
            /* [in] */ VARIANT vDomainGrant) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GrantByDefault( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GrantByDefault( 
            /* [in] */ VARIANT_BOOL fGrantByDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISIPSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISIPSecurity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISIPSecurity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISIPSecurity __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IPDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IPDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vIPDeny);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IPGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IPGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vIPGrant);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DomainDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vDomainDeny);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DomainGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vDomainGrant);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrantByDefault )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GrantByDefault )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fGrantByDefault);
        
        END_INTERFACE
    } IISIPSecurityVtbl;

    interface IISIPSecurity
    {
        CONST_VTBL struct IISIPSecurityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISIPSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISIPSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISIPSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISIPSecurity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISIPSecurity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISIPSecurity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISIPSecurity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISIPSecurity_get_IPDeny(This,retval)	\
    (This)->lpVtbl -> get_IPDeny(This,retval)

#define IISIPSecurity_put_IPDeny(This,vIPDeny)	\
    (This)->lpVtbl -> put_IPDeny(This,vIPDeny)

#define IISIPSecurity_get_IPGrant(This,retval)	\
    (This)->lpVtbl -> get_IPGrant(This,retval)

#define IISIPSecurity_put_IPGrant(This,vIPGrant)	\
    (This)->lpVtbl -> put_IPGrant(This,vIPGrant)

#define IISIPSecurity_get_DomainDeny(This,retval)	\
    (This)->lpVtbl -> get_DomainDeny(This,retval)

#define IISIPSecurity_put_DomainDeny(This,vDomainDeny)	\
    (This)->lpVtbl -> put_DomainDeny(This,vDomainDeny)

#define IISIPSecurity_get_DomainGrant(This,retval)	\
    (This)->lpVtbl -> get_DomainGrant(This,retval)

#define IISIPSecurity_put_DomainGrant(This,vDomainGrant)	\
    (This)->lpVtbl -> put_DomainGrant(This,vDomainGrant)

#define IISIPSecurity_get_GrantByDefault(This,retval)	\
    (This)->lpVtbl -> get_GrantByDefault(This,retval)

#define IISIPSecurity_put_GrantByDefault(This,fGrantByDefault)	\
    (This)->lpVtbl -> put_GrantByDefault(This,fGrantByDefault)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_IPDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_IPDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_IPDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vIPDeny);


void __RPC_STUB IISIPSecurity_put_IPDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_IPGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_IPGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_IPGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vIPGrant);


void __RPC_STUB IISIPSecurity_put_IPGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_DomainDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_DomainDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_DomainDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vDomainDeny);


void __RPC_STUB IISIPSecurity_put_DomainDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_DomainGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_DomainGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_DomainGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vDomainGrant);


void __RPC_STUB IISIPSecurity_put_DomainGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_GrantByDefault_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_GrantByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_GrantByDefault_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fGrantByDefault);


void __RPC_STUB IISIPSecurity_put_GrantByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISIPSecurity_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_IPSecurity;

#ifdef __cplusplus

class DECLSPEC_UUID("F3287520-BBA3-11d0-9BDC-00A0C922E703")
IPSecurity;
#endif

EXTERN_C const CLSID CLSID_IISNamespace;

#ifdef __cplusplus

class DECLSPEC_UUID("d6bfa35e-89f2-11d0-8527-00c04fd8d503")
IISNamespace;
#endif

EXTERN_C const CLSID CLSID_IISProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("d88966de-89f2-11d0-8527-00c04fd8d503")
IISProvider;
#endif

#ifndef __IISDsCrMap_INTERFACE_DEFINED__
#define __IISDsCrMap_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISDsCrMap
 * at Sun Nov 16 14:28:38 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISDsCrMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("edcd6a60-b053-11d0-a62f-00a0c922e752")
    IISDsCrMap : public IADs
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateMapping( 
            /* [in] */ VARIANT vCert,
            /* [in] */ BSTR bstrNtAcct,
            /* [in] */ BSTR bstrNtPwd,
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMapping( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [out] */ VARIANT __RPC_FAR *pvCert,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtAcct,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtPwd,
            /* [out] */ VARIANT __RPC_FAR *pbstrName,
            /* [out] */ VARIANT __RPC_FAR *plEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteMapping( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ LONG lEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPwd( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrPwd) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAcct( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrAcct) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDsCrMapVtbl
    {
        BEGIN_INTERFACE
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *ppvObj,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISDsCrMap __RPC_FAR * This,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *pctinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ unsigned UINT itinfo,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *pptinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ signed char __RPC_FAR *__RPC_FAR *rgszNames,
            /* [in][idldescattr] */ unsigned UINT cNames,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ signed long __RPC_FAR *rgdispid,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ signed long dispidMember,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [in][idldescattr] */ unsigned short wFlags,
            /* [in][idldescattr] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out][idldescattr] */ VARIANT __RPC_FAR *pvarResult,
            /* [out][idldescattr] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *puArgErr,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GUID )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ADsPath )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schema )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInfo )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEx )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutEx )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ signed long lnControlCode,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoEx )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ VARIANT vProperties,
            /* [in][idldescattr] */ signed long lnReserved,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateMapping )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ VARIANT vCert,
            /* [in] */ BSTR bstrNtAcct,
            /* [in] */ BSTR bstrNtPwd,
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMapping )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [out] */ VARIANT __RPC_FAR *pvCert,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtAcct,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtPwd,
            /* [out] */ VARIANT __RPC_FAR *pbstrName,
            /* [out] */ VARIANT __RPC_FAR *plEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMapping )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnabled )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ LONG lEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPwd )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrPwd);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAcct )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrAcct);
        
        END_INTERFACE
    } IISDsCrMapVtbl;

    interface IISDsCrMap
    {
        CONST_VTBL struct IISDsCrMapVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDsCrMap_QueryInterface(This,riid,ppvObj,retval)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObj,retval)

#define IISDsCrMap_AddRef(This,retval)	\
    (This)->lpVtbl -> AddRef(This,retval)

#define IISDsCrMap_Release(This,retval)	\
    (This)->lpVtbl -> Release(This,retval)

#define IISDsCrMap_GetTypeInfoCount(This,pctinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo,retval)

#define IISDsCrMap_GetTypeInfo(This,itinfo,lcid,pptinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo,retval)

#define IISDsCrMap_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)

#define IISDsCrMap_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)

#define IISDsCrMap_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IISDsCrMap_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IISDsCrMap_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IISDsCrMap_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IISDsCrMap_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IISDsCrMap_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IISDsCrMap_GetInfo(This,retval)	\
    (This)->lpVtbl -> GetInfo(This,retval)

#define IISDsCrMap_SetInfo(This,retval)	\
    (This)->lpVtbl -> SetInfo(This,retval)

#define IISDsCrMap_Get(This,bstrName,retval)	\
    (This)->lpVtbl -> Get(This,bstrName,retval)

#define IISDsCrMap_Put(This,bstrName,vProp,retval)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp,retval)

#define IISDsCrMap_GetEx(This,bstrName,retval)	\
    (This)->lpVtbl -> GetEx(This,bstrName,retval)

#define IISDsCrMap_PutEx(This,lnControlCode,bstrName,vProp,retval)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp,retval)

#define IISDsCrMap_GetInfoEx(This,vProperties,lnReserved,retval)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved,retval)


#define IISDsCrMap_CreateMapping(This,vCert,bstrNtAcct,bstrNtPwd,bstrName,lEnabled)	\
    (This)->lpVtbl -> CreateMapping(This,vCert,bstrNtAcct,bstrNtPwd,bstrName,lEnabled)

#define IISDsCrMap_GetMapping(This,lMethod,vKey,pvCert,pbstrNtAcct,pbstrNtPwd,pbstrName,plEnabled)	\
    (This)->lpVtbl -> GetMapping(This,lMethod,vKey,pvCert,pbstrNtAcct,pbstrNtPwd,pbstrName,plEnabled)

#define IISDsCrMap_DeleteMapping(This,lMethod,vKey)	\
    (This)->lpVtbl -> DeleteMapping(This,lMethod,vKey)

#define IISDsCrMap_SetEnabled(This,lMethod,vKey,lEnabled)	\
    (This)->lpVtbl -> SetEnabled(This,lMethod,vKey,lEnabled)

#define IISDsCrMap_SetName(This,lMethod,vKey,bstrName)	\
    (This)->lpVtbl -> SetName(This,lMethod,vKey,bstrName)

#define IISDsCrMap_SetPwd(This,lMethod,vKey,bstrPwd)	\
    (This)->lpVtbl -> SetPwd(This,lMethod,vKey,bstrPwd)

#define IISDsCrMap_SetAcct(This,lMethod,vKey,bstrAcct)	\
    (This)->lpVtbl -> SetAcct(This,lMethod,vKey,bstrAcct)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_CreateMapping_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ VARIANT vCert,
    /* [in] */ BSTR bstrNtAcct,
    /* [in] */ BSTR bstrNtPwd,
    /* [in] */ BSTR bstrName,
    /* [in] */ LONG lEnabled);


void __RPC_STUB IISDsCrMap_CreateMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_GetMapping_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [out] */ VARIANT __RPC_FAR *pvCert,
    /* [out] */ VARIANT __RPC_FAR *pbstrNtAcct,
    /* [out] */ VARIANT __RPC_FAR *pbstrNtPwd,
    /* [out] */ VARIANT __RPC_FAR *pbstrName,
    /* [out] */ VARIANT __RPC_FAR *plEnabled);


void __RPC_STUB IISDsCrMap_GetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_DeleteMapping_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey);


void __RPC_STUB IISDsCrMap_DeleteMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetEnabled_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ LONG lEnabled);


void __RPC_STUB IISDsCrMap_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetName_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IISDsCrMap_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetPwd_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ BSTR bstrPwd);


void __RPC_STUB IISDsCrMap_SetPwd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetAcct_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ BSTR bstrAcct);


void __RPC_STUB IISDsCrMap_SetAcct_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISDsCrMap_INTERFACE_DEFINED__ */


#ifndef __IISApp_INTERFACE_DEFINED__
#define __IISApp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISApp
 * at Sun Nov 16 14:28:38 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46FBBB80-0192-11d1-9C39-00A0C922E703")
    IISApp : public IADs
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppCreate( 
            /* [in] */ VARIANT_BOOL bSetInProcFlag) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDelete( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDeleteRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppUnLoad( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppUnLoadRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDisable( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDisableRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppEnable( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppEnableRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppGetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISAppVtbl
    {
        BEGIN_INTERFACE
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *ppvObj,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISApp __RPC_FAR * This,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *pctinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ unsigned UINT itinfo,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *pptinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ signed char __RPC_FAR *__RPC_FAR *rgszNames,
            /* [in][idldescattr] */ unsigned UINT cNames,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ signed long __RPC_FAR *rgdispid,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ signed long dispidMember,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [in][idldescattr] */ unsigned short wFlags,
            /* [in][idldescattr] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out][idldescattr] */ VARIANT __RPC_FAR *pvarResult,
            /* [out][idldescattr] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *puArgErr,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GUID )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ADsPath )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schema )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInfo )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEx )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutEx )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ signed long lnControlCode,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoEx )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ VARIANT vProperties,
            /* [in][idldescattr] */ signed long lnReserved,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppCreate )( 
            IISApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bSetInProcFlag);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDelete )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDeleteRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppUnLoad )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppUnLoadRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDisable )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDisableRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppEnable )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppEnableRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppGetStatus )( 
            IISApp __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        END_INTERFACE
    } IISAppVtbl;

    interface IISApp
    {
        CONST_VTBL struct IISAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISApp_QueryInterface(This,riid,ppvObj,retval)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObj,retval)

#define IISApp_AddRef(This,retval)	\
    (This)->lpVtbl -> AddRef(This,retval)

#define IISApp_Release(This,retval)	\
    (This)->lpVtbl -> Release(This,retval)

#define IISApp_GetTypeInfoCount(This,pctinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo,retval)

#define IISApp_GetTypeInfo(This,itinfo,lcid,pptinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo,retval)

#define IISApp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)

#define IISApp_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)

#define IISApp_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IISApp_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IISApp_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IISApp_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IISApp_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IISApp_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IISApp_GetInfo(This,retval)	\
    (This)->lpVtbl -> GetInfo(This,retval)

#define IISApp_SetInfo(This,retval)	\
    (This)->lpVtbl -> SetInfo(This,retval)

#define IISApp_Get(This,bstrName,retval)	\
    (This)->lpVtbl -> Get(This,bstrName,retval)

#define IISApp_Put(This,bstrName,vProp,retval)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp,retval)

#define IISApp_GetEx(This,bstrName,retval)	\
    (This)->lpVtbl -> GetEx(This,bstrName,retval)

#define IISApp_PutEx(This,lnControlCode,bstrName,vProp,retval)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp,retval)

#define IISApp_GetInfoEx(This,vProperties,lnReserved,retval)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved,retval)


#define IISApp_AppCreate(This,bSetInProcFlag)	\
    (This)->lpVtbl -> AppCreate(This,bSetInProcFlag)

#define IISApp_AppDelete(This)	\
    (This)->lpVtbl -> AppDelete(This)

#define IISApp_AppDeleteRecursive(This)	\
    (This)->lpVtbl -> AppDeleteRecursive(This)

#define IISApp_AppUnLoad(This)	\
    (This)->lpVtbl -> AppUnLoad(This)

#define IISApp_AppUnLoadRecursive(This)	\
    (This)->lpVtbl -> AppUnLoadRecursive(This)

#define IISApp_AppDisable(This)	\
    (This)->lpVtbl -> AppDisable(This)

#define IISApp_AppDisableRecursive(This)	\
    (This)->lpVtbl -> AppDisableRecursive(This)

#define IISApp_AppEnable(This)	\
    (This)->lpVtbl -> AppEnable(This)

#define IISApp_AppEnableRecursive(This)	\
    (This)->lpVtbl -> AppEnableRecursive(This)

#define IISApp_AppGetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> AppGetStatus(This,pdwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppCreate_Proxy( 
    IISApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bSetInProcFlag);


void __RPC_STUB IISApp_AppCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDelete_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDeleteRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDeleteRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppUnLoad_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppUnLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppUnLoadRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppUnLoadRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDisable_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDisableRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDisableRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppEnable_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppEnableRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppEnableRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppGetStatus_Proxy( 
    IISApp __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IISApp_AppGetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISApp_INTERFACE_DEFINED__ */


#ifndef __IISComputer_INTERFACE_DEFINED__
#define __IISComputer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISComputer
 * at Sun Nov 16 14:28:38 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISComputer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF87A2E0-078B-11d1-9C3D-00A0C922E703")
    IISComputer : public IADs
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Backup( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Restore( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EnumBackups( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lIndex,
            /* [out] */ VARIANT __RPC_FAR *pvVersion,
            /* [out] */ VARIANT __RPC_FAR *pvLocations,
            /* [out] */ VARIANT __RPC_FAR *pvDate) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteBackup( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISComputerVtbl
    {
        BEGIN_INTERFACE
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *ppvObj,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISComputer __RPC_FAR * This,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *pctinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ unsigned UINT itinfo,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *pptinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ signed char __RPC_FAR *__RPC_FAR *rgszNames,
            /* [in][idldescattr] */ unsigned UINT cNames,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ signed long __RPC_FAR *rgdispid,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ signed long dispidMember,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [in][idldescattr] */ unsigned short wFlags,
            /* [in][idldescattr] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out][idldescattr] */ VARIANT __RPC_FAR *pvarResult,
            /* [out][idldescattr] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *puArgErr,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GUID )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ADsPath )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schema )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInfo )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEx )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutEx )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ signed long lnControlCode,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoEx )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ VARIANT vProperties,
            /* [in][idldescattr] */ signed long lnReserved,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Backup )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Restore )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumBackups )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lIndex,
            /* [out] */ VARIANT __RPC_FAR *pvVersion,
            /* [out] */ VARIANT __RPC_FAR *pvLocations,
            /* [out] */ VARIANT __RPC_FAR *pvDate);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBackup )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion);
        
        END_INTERFACE
    } IISComputerVtbl;

    interface IISComputer
    {
        CONST_VTBL struct IISComputerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISComputer_QueryInterface(This,riid,ppvObj,retval)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObj,retval)

#define IISComputer_AddRef(This,retval)	\
    (This)->lpVtbl -> AddRef(This,retval)

#define IISComputer_Release(This,retval)	\
    (This)->lpVtbl -> Release(This,retval)

#define IISComputer_GetTypeInfoCount(This,pctinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo,retval)

#define IISComputer_GetTypeInfo(This,itinfo,lcid,pptinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo,retval)

#define IISComputer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)

#define IISComputer_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)

#define IISComputer_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IISComputer_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IISComputer_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IISComputer_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IISComputer_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IISComputer_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IISComputer_GetInfo(This,retval)	\
    (This)->lpVtbl -> GetInfo(This,retval)

#define IISComputer_SetInfo(This,retval)	\
    (This)->lpVtbl -> SetInfo(This,retval)

#define IISComputer_Get(This,bstrName,retval)	\
    (This)->lpVtbl -> Get(This,bstrName,retval)

#define IISComputer_Put(This,bstrName,vProp,retval)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp,retval)

#define IISComputer_GetEx(This,bstrName,retval)	\
    (This)->lpVtbl -> GetEx(This,bstrName,retval)

#define IISComputer_PutEx(This,lnControlCode,bstrName,vProp,retval)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp,retval)

#define IISComputer_GetInfoEx(This,vProperties,lnReserved,retval)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved,retval)


#define IISComputer_Backup(This,bstrLocation,lVersion,lFlags)	\
    (This)->lpVtbl -> Backup(This,bstrLocation,lVersion,lFlags)

#define IISComputer_Restore(This,bstrLocation,lVersion,lFlags)	\
    (This)->lpVtbl -> Restore(This,bstrLocation,lVersion,lFlags)

#define IISComputer_EnumBackups(This,bstrLocation,lIndex,pvVersion,pvLocations,pvDate)	\
    (This)->lpVtbl -> EnumBackups(This,bstrLocation,lIndex,pvVersion,pvLocations,pvDate)

#define IISComputer_DeleteBackup(This,bstrLocation,lVersion)	\
    (This)->lpVtbl -> DeleteBackup(This,bstrLocation,lVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_Backup_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lVersion,
    /* [in] */ LONG lFlags);


void __RPC_STUB IISComputer_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_Restore_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lVersion,
    /* [in] */ LONG lFlags);


void __RPC_STUB IISComputer_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_EnumBackups_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lIndex,
    /* [out] */ VARIANT __RPC_FAR *pvVersion,
    /* [out] */ VARIANT __RPC_FAR *pvLocations,
    /* [out] */ VARIANT __RPC_FAR *pvDate);


void __RPC_STUB IISComputer_EnumBackups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_DeleteBackup_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lVersion);


void __RPC_STUB IISComputer_DeleteBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISComputer_INTERFACE_DEFINED__ */


#ifndef __IISBaseObject_INTERFACE_DEFINED__
#define __IISBaseObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISBaseObject
 * at Sun Nov 16 14:28:38 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B42E390-0E96-11d1-9C3F-00A0C922E703")
    IISBaseObject : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetDataPaths( 
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lnAttribute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPaths) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISBaseObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataPaths )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lnAttribute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPaths);
        
        END_INTERFACE
    } IISBaseObjectVtbl;

    interface IISBaseObject
    {
        CONST_VTBL struct IISBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISBaseObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISBaseObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISBaseObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISBaseObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISBaseObject_GetDataPaths(This,bstrName,lnAttribute,pvPaths)	\
    (This)->lpVtbl -> GetDataPaths(This,bstrName,lnAttribute,pvPaths)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISBaseObject_GetDataPaths_Proxy( 
    IISBaseObject __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ LONG lnAttribute,
    /* [retval][out] */ VARIANT __RPC_FAR *pvPaths);


void __RPC_STUB IISBaseObject_GetDataPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISBaseObject_INTERFACE_DEFINED__ */

#endif /* __IISOle_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\hashimp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

hashimp.h

Abstract : 

	This file contains the inline functions required to implement
	the hash tables defined in hashmap.h


--*/

#ifndef	_HASHIMP_H_
#define	_HASHIMP_H_

inline
IStringKey::IStringKey(	
					LPBYTE	pbKey,	
					DWORD	cbKey ) :	
	m_lpbKey( pbKey ), 
	m_cbKey( cbKey )	{
}


inline	LPBYTE	
IStringKey::Serialize(	
					LPBYTE	pbPtr 
					)	const	{
	PDATA	pData = (PDATA)pbPtr ;
	pData->cb = (WORD)m_cbKey ;
	CopyMemory( pData->Data, m_lpbKey, m_cbKey ) ;
	return	pData->Data + m_cbKey ;
}


inline	LPBYTE	
IStringKey::Restore(	
					LPBYTE	pbPtr,	
					DWORD	&cbOut	
					)	{
	PDATA	pData = (PDATA)pbPtr ;
	if( m_cbKey < pData->cb ) {
		cbOut = pData->cb ;
		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		return	 0 ;
	}
	cbOut = m_cbKey = pData->cb ;
	CopyMemory( m_lpbKey, pData->Data, m_cbKey ) ;
	return	pData->Data + m_cbKey ;
}


inline	DWORD	
IStringKey::Size() const	{
	return	sizeof( SerializedString ) - sizeof( BYTE ) + m_cbKey ;
}


inline	BOOL	
IStringKey::Verify(	
					LPBYTE	pbContainer,
					LPBYTE	pbPtr,	
					DWORD	cb 
					)	const	{
	PDATA	pData = (PDATA)pbPtr ;
	if( pData->cb > cb ) {
		return	FALSE ;
	}
	return	TRUE ;
}


inline	DWORD	
IStringKey::Hash( )	const	{

	return	CHashMap::CRCHash( m_lpbKey, m_cbKey ) ;

}


inline	BOOL	
IStringKey::CompareKeys( 
					LPBYTE	pbPtr 
					)	const	{
	PDATA	pData = PDATA( pbPtr ) ;
	return pData->cb == m_cbKey && !memcmp( pData->Data, m_lpbKey, m_cbKey ) ;
}


inline	LPBYTE	
IStringKey::EntryData(	
					LPBYTE	pbPtr,	
					DWORD	&cbOut 
					)	const	{
	PDATA	pData = PDATA( pbPtr ) ;
	return	pData->Data + pData->cb ;
}


#endif	// _HASHIMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\heapdet.h ===
//////////////////////////////////////////////////////
// 
// HeapDet.h - Copyright 1995, Don Box 
//
// Simple IMallocSpy to track allocation byte count
//

#ifndef _HEAPDET_H
#define _HEAPDET_H


class	CoHeapDetective : public IMallocSpy
{									  
public:
	CoHeapDetective();
	virtual ~CoHeapDetective();
	SIZE_T GetBytesAlloced() const;

#ifdef	_HEAPDET_INTERNAL_
	__declspec( dllexport ) 
#else
	__declspec( dllimport ) 
#endif
	static	class	CoHeapDetective*		
	GetDetective() ;

private:
	// paramters to cache between pre/post phases

	static	HMODULE	g_HeapdetLib ;
	static	long	g_cLibRefs ;

	//
	//	Number of References on this instance
	//
	long m_cRefs ;

	SIZE_T m_cbLastAlloc;
	void *m_pvLastRealloc; 

	// total heap usage
	SIZE_T m_dwBytesAlloced;

	// output device for tracing
	HANDLE m_hTraceOutput;

	// helper function to send simple trace message to debug window
	void Trace(SIZE_T cb, PVOID pv, LPCTSTR szAction, BOOL bSuccess);

	// simple alloc header to track allocation size
	struct ArenaHeader
	{
		enum { SIGNATURE = 0x1BADABBAL };

		struct	ArenaHeader*	m_pNext ;
		struct	ArenaHeader*	m_pPrev ;

		SIZE_T m_dwAllocSize;  // the user's idea of size
		DWORD m_dwSignature;  // always 0x1BADABBA when good
	};

	ArenaHeader	m_list ;

	// helper function to write a valid arena header at ptr
	void SetArenaHeader(void *ptr, SIZE_T dwAllocSize);

	// helper function to verify and return the prepended 
	// header (or null if failure)
	ArenaHeader *GetHeader(void *ptr);

public: 
	// IUnknown methods
  	STDMETHODIMP QueryInterface(REFIID riid, void**ppv);
  	STDMETHODIMP_(ULONG) AddRef();
  	STDMETHODIMP_(ULONG) Release();

	// IMallocSpy methods
  	STDMETHODIMP_(SIZE_T) PreAlloc(SIZE_T cbRequest);
  	STDMETHODIMP_(void*) PostAlloc(void *pActual);
  
  	STDMETHODIMP_(void*) PreFree(void *pRequest, BOOL fSpyed);
  	STDMETHODIMP_(void)  PostFree(BOOL fSpyed);
  
  	STDMETHODIMP_(SIZE_T) PreRealloc(void *pRequest,	SIZE_T cbRequest, 
  																void **ppNewRequest, BOOL fSpyed);
  	STDMETHODIMP_(void*) PostRealloc(void *pActual, BOOL fSpyed);
  
  	STDMETHODIMP_(void*) PreGetSize(void *pRequest, BOOL fSpyed);
  	STDMETHODIMP_(SIZE_T) PostGetSize(SIZE_T cbActual, BOOL fSpyed);
  
  	STDMETHODIMP_(void*) PreDidAlloc(void *pRequest, BOOL fSpyed);
  	STDMETHODIMP_(int)   PostDidAlloc(void *pRequest, BOOL fSpyed, int fActual);
  
  	STDMETHODIMP_(void)  PreHeapMinimize(void);
  	STDMETHODIMP_(void)  PostHeapMinimize(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\hashmap.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    hashmap.h

Abstract:

    This module contains class declarations/definitions for

        CHashMap
        CMsgArtMap
        CHistory


    **** Schedule ****

    Hash function                   Free (ripped out from INN code)

    Core Hash Engine:               2 weeks
        Initialization/Setup
        Collision resolution
            Double hashing/
                linear probing


        Insertion
        Page Splitting
        Search
        Deletion
        Directory setup

    Article Mapping                 1 week
        Leaf Page Setup
        Leaf Page Compaction
        Recovery
        Statistics


    History                         1 week
        Leaf Page Setup
        Insertion
        Crawler/Expiration/Deletion
        Statistics

    Unit Testing                    2 weeks
        Get a large set of msg ids
        Write an app to
            try out hash fn and make sure distribution is acceptable
            test page splitting and directory growing operations
            test compaction code
            test multithreaded operations
            get raw speed of table lookup (lookup/sec)
            detect map file corruption
            rebuilding of map file
            test history crawler delete and compaction operations

    Misc design stuff
        At startup, figure out the system page size
        Regkey for size of mapping file
        Add collision info to statistics
        Backup history file


    **** Hash algorithm ****

    Overview:

    The hashing mechanism is made up of 2 structures: the directory,
    and the leaf pages.  The directory is made up of 2**n entries,
    where n is the first n bits of a hash value.  Each directory
    entry points to a leaf page.  (A leaf page can be pointed to by
    more than one entry).

    A leaf page contains up to x entries.  When the page is about to be
    full (determined by number of entries or by space remaining), the
    page is split into two.  After the page is split, the directory pointers
    will also have to be modified to account for the new page.

    This scheme ensures that we take at most 2 page faults for each search.


    Implementation details:

    The leaf page can accomodate up to 128 entries. The last m=7 bits
    of the hash value is used to hash into the list.  We will use
    linear probing with p=1 to resolve collisions.

    The leaf page has fields called HashPrefix and PageDepth.  The HashPrefix
    contains the first PageDepth bits of a hash value which this page
    represents.  PageDepth <= n.  If PageDepth < n, then that means that
    more than one entry points to it.

    If PageDepth == n and we need to split the page, then this would
    necessitate rebuilding the directory structure so the condition
    PageDepth <= n will still be true after the split.

    We are using the first page of the mapping file as a reserved page.
    Here, we will store statistics information etc.


    **** Recovery strategy ****

    Detection:

        The first page of the map file will be reserved.  This will contain
        timestamps and statistics.  There will be an entry to indicate
        whether a clean shutdown took place.  If during startup, this
        flag indicates otherwise, we need to do a possible rebuild.

        ** We can also think of putting something in the registry
        to indicate this.  Maybe we'll do both. **

        There will be a LastWrite timestamp in this page.  After each flush,
        the timestamp will be updated. This will give us an indication on
        when the last complete write took place.

    Rebuilding the mapping file:

        There are three levels of map file rebuilding.  This can be
        specified by the operator.

        Level 1 rebuild

            Using the timestamp, find all the articles file time stamps
            which were created after this and add them to the lookup table.

        Level 2 rebuild

            A cursory rebuild assumes that all the XOver files in each
            newsgroup is valid.  The rebuilding will involve going over
            each XOver file (about 10000 of them), and rebuild the table
            with xover entries.

        Level 3 rebuild

            The more extensive rebuild involves going through each and every
            article in every newsgroup.  This will probably involve at least
            a million files and would substantially take longer to do.

        How do we know if we need to upgrade to a higher level?

            Well, the hash table will know how many article entries it
            has and there should be some way of figuring out how many
            articles are stored in the disk.  If they don't match, then
            it's time to upgrade.


    **** Registry Keys ****

        MappingFileSize     DWORD       Size of mapping files
        HashFileName        REG_SZ      Name of hash files
        InitialPageDepth    DWORD       Initial depth of leaf nodes
        Did they existed ?


Author:

    Johnson Apacible (JohnsonA)     07-Sept-1995

Revision History:

	Alex Wetmore (awetmore)			27-Aug-1996
	    - seperated from nntp server
		- removed dependencies for this include file on others...

--*/

#ifndef _HASHMAP_
#define _HASHMAP_

#include	"smartptr.h"

#ifdef	_USE_RWNH_
#include	"rwnew.h"
typedef	class	CShareLockNH	_RWLOCK ;
#else
#include	"rw.h"
typedef	class	CShareLock		_RWLOCK ;
#endif

//
// type declarations
//
typedef DWORD HASH_VALUE;

//
// manifest constants for hash stuff
//
#define   	KB							1024
#define     HASH_PAGE_SIZE              (4 * KB)
#define     NUM_PAGES_PER_IO            64

#define     MAX_MSGID_LEN               255
#define     MIN_HASH_FILE_SIZE          ((1+(1<<NUM_TOP_DIR_BITS)) *  HASH_PAGE_SIZE)

#define     LEAF_ENTRY_BITS             7
#define     MAX_LEAF_ENTRIES            (1 << LEAF_ENTRY_BITS)
#define     LEAF_ENTRY_MASK             (MAX_LEAF_ENTRIES - 1)
#define     MAX_XPOST_GROUPS            255

//
// Num of entries, bytes, and size of fragments to trigger page split.
//
#define     LEAF_ENTRYCOUNT_THRESHOLD   MAX_LEAF_ENTRIES
//#define     LEAF_ENTRYCOUNT_THRESHOLD   (MAX_LEAF_ENTRIES * 7 / 8)
#define     LEAF_SPACE_THRESHOLD        300
#define     FRAG_THRESHOLD              400

#define     DEF_DEPTH_INCREMENT         2
#define		DEF_PAGE_RESERVE			4
#define     DEF_PAGE_INCREMENT          32
#define     NUM_PAGE_LOCKS              256
#define		NUM_TOP_DIR_BITS			9
#define		MAX_NUM_TOP_DIR_BITS		10

//
// MASK and SIGNATURES
//
#define     DELETE_SIGNATURE            0xCCCC
#define     OFFSET_FLAG_DELETED         0x8000
#define     OFFSET_VALUE_MASK           0x7fff

#define     ART_HEAD_SIGNATURE          0xaaaaaaaa
#define     HIST_HEAD_SIGNATURE         0xbbbbbbbb
#define     XOVER_HEAD_SIGNATURE        0xcccccccc

#define     DEF_HEAD_SIGNATURE          0xdefa1234
#define     CACHE_INFO_SIGNATURE        0xbeef0205
#define     GROUP_LINK_MASK             0x80000000

//
// history map stuff (should be reg settable)
//
#define     DEF_EXPIRE_INTERVAL         (3 * SEC_PER_WEEK) // 1 week
#define     DEF_CRAWLER_WAKEUP_TIME     (30)               // 30 secs
#define     MIN_MAXPAGES_TO_CRAWL       (4)

//
//
// what fraction of total pages to crawl.  1/128 means
// we could cover all the pages in 2 hours.  This is
// expressed in terms of shifts.  7 right shift is 128
//
#define     FRACTION_TO_CRAWL_SHFT      7

//
// Indicates that the space used for this entry has been reclaimed
//
#define     ENTRY_DEL_RECLAIMED         ((WORD)0xffff)

//
// Get pointer given the offset and base
//
#define     GET_ENTRY( _base, _offset ) \
                ((PCHAR)(_base) + (_offset))

//
// See if we need to update the stats in the header page
//
#define     UPDATE_HEADER_STATS( ) { \
            if ( (m_nInsertions + m_nDeletions) >= STAT_FLUSH_THRESHOLD ) { \
                FlushHeaderStats( ); \
            } \
}

//
// Current hash table valid version numbers
//
// Significant Versions:
// 000  - old table
// 300  - Removed duplicates from the xover table
// 310  - Remove xposting from article table
//      - add articleid/groupid coding into xover table
// 320  - Change XOVER table to hold offsets into articles
// 330  - Change hash table to use two tier directory
// 340	- Change Xover Table to remove most data and place in index files !
// 350  - Change the number of top level directories used to 512 !
//
#define     HASH_VERSION_NUMBER_MCIS10	0x340
#define		HASH_VERSION_NUMBER			0x350

//
// Disable auto alignments
//
#pragma pack(1)

//
// doubly linked list
//
typedef struct _HASH_LIST_ENTRY {

    WORD    Flink;
    WORD    Blink;

} HASH_LIST_ENTRY, *PHASH_LIST_ENTRY;

//
// Entry headers - this is the structure of each hash entry header
//
typedef struct _ENTRYHEADER {

    //
    // hash value
    // *** Must be first entry ***
    //

    DWORD   HashValue;

    //
    // Size of this entry
    // *** Must be second entry ***
    //

    WORD    EntrySize;

#ifdef _WIN64
	//
	// Alignment word. This makes data align-8 instead of align-2, without
	// it the compiler would look at the type "BYTE" figure align-1 is good
	// enough and then place it right after EntrySize at an align-2 slot.  With
	// this word we cause the slot to be 8 bytes into the struct and hence align-8.
	// Data will hold larger objects and hence must be aligned better.
	//
	WORD	Reserved;
#endif

	//
	//	Member variable for var length data
	//
	BYTE	Data[1] ;

} ENTRYHEADER, *PENTRYHEADER;

//
// headers for deleted entries
//
typedef struct _DELENTRYHEADER {

    //
    // doubly linked list
    //

    HASH_LIST_ENTRY Link;

    //
    // Size of this entry
    //

    WORD    EntrySize;

    //
    // ???
    //

    WORD    Reserved;

} DELENTRYHEADER, *PDELENTRYHEADER;

//
// Handle for caching entry information
//
typedef struct _HASH_CACHE_INFO {

    //
    // Signature to verify this structure
    //

    DWORD       Signature;

    //
    // Cache of hash and msg id length
    //

    HASH_VALUE  HashValue;
    DWORD       MsgIdLen;

} HASH_CACHE_INFO, *PHASH_CACHE_INFO;

//
// This is the structure for the head page.
//
typedef struct _HASH_RESERVED_PAGE {

    //
    // Signature to identify the hash file
    //

    DWORD   Signature;

    //
    // Version number of the hash table
    //

    DWORD   VersionNumber;

    //
    // Has this file been initialized?
    //

    BOOL    Initialized;

    //
    // Is this file active
    //

    BOOL    TableActive;

    //
    // Number of pages that are being used including the reserved page
    //

    DWORD   NumPages;

    //
    // Max dir depth of the directory
    //

    DWORD   DirDepth;

    //
    // Statistics
    //

    DWORD   InsertionCount;
    DWORD   DeletionCount;
    DWORD   SearchCount;
    DWORD   PageSplits;
    DWORD   DirExpansions;
    DWORD   TableExpansions;
    DWORD   DupInserts;

} HASH_RESERVED_PAGE, *PHASH_RESERVED_PAGE;

//
// This is the structure of each entry in the leaf pages of the hash table.
//
typedef struct _MAP_PAGE {

    //
    // Prefix of hash values currently mapped into this page
    //

    DWORD   HashPrefix;

    //
    // Number of bits of the hash value that is mapped to this page
    //

    BYTE    PageDepth;

    //
    // Number of active indices in the page (includes deletes)
    //

    BYTE    EntryCount;

    //
    // Number of real entries in this page
    //

    BYTE    ActualCount;

    //
    // Flags
    //

    BYTE    Flags;

    //
    // Location to add new entry
    //

    WORD    ReservedWord;
    WORD    NextFree;

    //
    // Location of the page ending
    //

    WORD    LastFree;

    //
    // Number of bytes left by deleted entries
    //

    WORD    FragmentedBytes;

    //
    // Reserved, can be used for anything.  !QWA
    //

    WORD    Reserved1;
    WORD    Reserved2;
    WORD    Reserved3;
    WORD    Reserved4;

    //
    // List of deleted entries
    //

    HASH_LIST_ENTRY  DeleteList;

    //
    // Offset of entry from beginning of page.  Deleted entries
    // will have the high bit set.
    //

    WORD    Offset[MAX_LEAF_ENTRIES];

    //
    // Start of Entries
    //

    DWORD   StartEntries;

} MAP_PAGE, *PMAP_PAGE;

//
// Page header flags
//

#define PAGE_FLAG_SPLIT_IN_PROGRESS     (WORD)0x0001

//
// XOVER FLAGS
//
#define XOVER_MAP_PRIMARY       ((BYTE)0x01)

#pragma pack()

class CDirectory;
class PageEntry;
class	CPageCache ;





typedef	CRefPtr< CPageCache >	CCACHEPTR ;

//
//	Helper class for managing all of the locks that must be manipulated
//	to access something within the Hash Tables.
//
//	There are two principal locks that must almost always be held :
//
//		A Lock on the directory which references a hash table page
//		(this can be either exclusive or shared)
//		A CDirectory object contains and manages this lock.
//
//		A Lock on the page which contains the hash table page -
//		A PageEntry structure contains and manages this lock.
//
//	What we do is co-ordinate the use of these two locks, whenever
//	hash table data is accessed we keep track of both the Directory
//	that refers to the hash page and the hash table page containing the
//	data. (through pointers to these objects).  When we are created
//	we always have NULL pointers, and we accumulate these pointers
//	as CHashMap
//
//
class	CPageLock	{
private:

	friend	class	CPageCache	;
	friend	class	CDirectory ;
	friend	class	CHashMap ;

	//
	//	Copy constructor is private - because we don't want people making copies !!
	//
	CPageLock( CPageLock& ) ;
	CPageLock&	operator=( CPageLock& ) ;

	//
	//	The PageEntry object which has read our page into memory, and which
	//	has the critical section guaranteeing exclusive access to the page
	//
	PageEntry*		m_pPage ;

	//
	//	The directory we used to lookup the page - we have grabbed
	//	the directory either exclusively, or shared - The caller must
	//	keep track of which and use the appropriate API's
	//
	CDirectory*		m_pDirectory ;

	//
	//	Used to figure out whether we got the page shared or exclusive !
	//
	BOOL			m_fPageShared ;

	//
	//	Secondary page - used when we are doing page splits !
	//
	PageEntry*		m_pPageSecondary ;

#ifdef	DEBUG
	//
	//	This is used in debug builds to make sure the caller is using
	//	the correct API's and keeping track of shared/exclusive usage
	//	correctly !
	//
	BOOL			m_fExclusive ;
#endif

	//
	//	Only public members are constructor and destructor -
	//	everything else is used by our friends - CHashMap only !
	//
public :

	//
	//	Initialize to a NULL state
	//
	inline	CPageLock() ;

#ifdef	DEBUG
	//
	//	In debug builds - _ASSERT check that all our members
	//	are set to NULL before we are destroyed - as we release locks
	//	we will set these to NULL !
	//
	inline	~CPageLock() ;
#endif

private :
	//
	//	Lock a specific directory for shared access, and
	//	remember what directory we grabbed so we can release it later !
	//
	inline	void	AcquireDirectoryShared( CDirectory*	pDirectory	) ;

	//
	//	Lock a specific directory for EXCLUSIVE access, and remember what
	//	directory we grabbed so we can release it later !
	//
	inline	void	AcquireDirectoryExclusive(	CDirectory*	pDirectory ) ;

	//
	//	Release the directory !
	//
	inline	void	ReleaseDirectoryExclusive() ;

	//
	//	Release a ShareLock from the directory !
	//
	public:	void	ReleaseDirectoryShared() ;

	//
	//	Lock a page - and remember who we locked for later release !
	//
	private:	inline	PMAP_PAGE	AcquirePageShared(
							PageEntry	*page,
							HANDLE		hFile,
							DWORD		PageNumber,
							BOOL		fDropDirectory
							) ;
	inline	PMAP_PAGE	AcquirePageExclusive(
							PageEntry	*page,
							HANDLE		hFile,
							DWORD		PageNumber,
							BOOL		fDropDirectory
							) ;
	//
	//	Lock the secondary page Exclusive !
	//
	inline	BOOL	AddPageExclusive(
							PageEntry*	page,
							HANDLE		hFile,
							DWORD		PageNumber
							) ;

	//
	//	Release all of our locks - we were holding a shared lock before !
	//
	inline	void	ReleaseAllShared(	PMAP_PAGE	page ) ;

	//
	//	Release all of our locks - we had an exclusive lock on the directory !
	//
	inline	void	ReleaseAllExclusive(	PMAP_PAGE	page	) ;

	//
	//	Check that all of the members are legally setup !
	//
	BOOL		IsValid() ;


} ;

typedef	CPageLock	HPAGELOCK ;

extern DWORD LeafMask[];

//
// Size of our directory view
//

#define DIR_VIEW_SIZE       (64 * KB)

//
// Number of entries per view
//

#define DIR_VIEW_ENTRIES    (16 * KB)
#define DIR_VIEW_SHIFT      14
#define DIR_VIEW_MASK       0x00003fff


//
// Number of inserts and deletes before stats are flushed
//

#define STAT_FLUSH_THRESHOLD    16

DWORD
WINAPI
CrawlerThread(
        LPVOID Context
        );


//
//	This is a protototype for the function pointer the hash tables
//	can call in case of critical errors.
//	This function is called when the hash table gets an error from
//	the O.S. which will seriously affect the usablility of the hash table.
//	For instance, if we fail to allocate more memory when expanding a
//	directory, the hash table will most likely to start to fail the
//	majority of attempts to insert new items.
//	This is probably non recoverable, and the function would be called
//	with fRecoverable set to FALSE.
//	If the hash table fails due to a more temporary condition, ie. out
//	of disk space, then the function will be called with fRecoverable
//	set to TRUE.
//	This function pointer is registered on the call to the hash tables
//	Initialize() function.
//
typedef	void	(* HASH_FAILURE_PFN)(	LPVOID	lpv,
										BOOL	fRecoverable	) ;

//
//	This interface defines the interface used by both Key's and Entry's
//	to save and restore their data into the hash table.
//
class	ISerialize	{
	public :
		//
		//	Save the data into a serialized form, and return a pointer
		//	to where the next block of data can be placed !
		//	This can be called IFF IsDataSet() == TRUE
		//
		virtual	LPBYTE	Serialize(	LPBYTE	pbPtr )	const = 0 ;

		//
		//	Restore data from a serialized block of data !
		//	This can be called IF IsDataSet() == TRUE  || IsDataSet() == FALSE
		//
		//	If the return value is NULL the call failed, and cbOut contains
		//	the number of bytes required to hold the data in unserialized form !
		//
		virtual	LPBYTE	Restore(	LPBYTE	pbPtr,
									DWORD	&cbOut
									) = 0 ;

		//
		//	Return the number of bytes required to serialize the object !
		//	This can be called IFF IsDataSet() == TRUE
		//
		virtual	DWORD	Size( ) const = 0 ;

		//
		//	This function verifies that the serialized block of data is valid !
		//	This can be called IF IsDataSet() == TRUE || IsDataSet() == FALSE
		//
		//	NOTE : pbContainer - will point to the start of the entire block
		//	of data containing both serialized Key and Data blocks !
		//
		virtual	BOOL	Verify(	LPBYTE	pbContainer,
								LPBYTE	pbPtr,
								DWORD	cb
								) const = 0 ;
} ;


//
//	This interface defines the extra interface members a Key must support
//	in order to be used by the hash tables
//
class	IKeyInterface : public ISerialize	{
	protected :
		//
		//	Default parameter for EntryData() when we wish to discard
		//	the size output !
		//
		static	DWORD	cbJunk ;
	public:
		//
		//	Compute the hash value of this key !
		//	this must be called IFF IsDataSet() == TRUE !
		//
		virtual	DWORD	Hash() const	= 0 ;

		//
		//	Compare a Key to a Serialized Key this must
		//	be called IFF IsDataSet() == TRUE
		//
		virtual	BOOL	CompareKeys( LPBYTE	pbPtr ) const = 0 ;

		//
		//	Given some serialized Key Data find the Start of
		//	the serialized Entry Data.  The resulting pointer
		//	must be suitable to be passed to an Entry object's
		//	Restore() method.
		//
		virtual	LPBYTE	EntryData(	LPBYTE pbPtr,
									DWORD&	cbKeyOut = IKeyInterface::cbJunk
									)	const = 0 ;


} ;

class	IStringKey	:	public	IKeyInterface	{
	private :
		//
		//	Pointer to the String We are concerned with !
		//
		LPBYTE	m_lpbKey ;
		//
		//	Number of bytes available !
		//
		DWORD	m_cbKey ;

		//
		//	The structure we serialize to.
		//
		struct	SerializedString	{
			WORD	cb ;
			BYTE	Data[1] ;
		} ;

		typedef	SerializedString*	PDATA ;

	public :
		//
		//	Construct a Key object !
		//
		IStringKey(	LPBYTE	pbKey = 0,
					DWORD	cbKey = 0
					) ;

		//
		//	Required by ISerialize Interface - save key data into memory
		//
		LPBYTE
		Serialize(	LPBYTE	pbPtr )	const ;

		//
		//	Required by ISerialize Interface - restore key data from buffer
		//
		LPBYTE
		Restore(	LPBYTE	pbPtr,	DWORD	&cbOut	)	;

		//
		//	Return the number of bytes required by Serialize()
		//
		DWORD
		Size() const ;

		//
		//	Check that a serialized version of the data looks legal !
		//
		BOOL
		Verify(	LPBYTE	pbContainer,
				LPBYTE	pbPtr,
				DWORD	cb
				)	const ;

		//
		//	Compute the hash value of the key
		//
		DWORD
		Hash( )	const	;

		//
		//	Compare the Key contained in an instance to a serialized one !
		//
		BOOL
		CompareKeys( LPBYTE	pbPtr )	const	;

		//
		//	Get a pointer to where the Entry should have been serialized
		//	following the Key
		//
		LPBYTE
		EntryData( LPBYTE	pbPtr,	DWORD	&cbOut )	const;

} ;

//
//	Interface to be used to access the reserved words within the hash table
//
class	IEnumInterface	{
public :

	//
	//	This interface is passed to the GetFirstMapEntry, GetNextMapEntry routines !
	//	This function is called to determine if there is anything on this
	//	page we wish to deal with !!
	//
	virtual	BOOL
	ExaminePage(	PMAP_PAGE	page ) = 0 ;

	//
	//	This function is called to determine if we wish to examine an
	//	a particular entry within a page !!
	//
	//
	virtual	BOOL
	ExamineEntry(	PMAP_PAGE	page,	LPBYTE	pbPtr ) = 0 ;

} ;


//
// an entry in the hash table
//
// this is an interface used for writing to data in the hashmaps.
// to store data in the hashmap a class must derive from this that
// implements all of the methods
//
//	NOTE : This interface handles the serialization of keys and puts them
//	automagically as the first element of the structure.  This is laid out
//	as specified by _KEY_ENTRY below !
//
typedef struct _KEY_ENTRY {
	// length of key
	WORD KeyLen;
	BYTE Key[1];
} KEY_ENTRY, *PKEY_ENTRY;

//
//	CHashEntry is an old interface used by the hash tables.
//	we define a
//
//
//
class CHashEntry : public ISerialize
{
    public:

		LPBYTE
		Serialize( LPBYTE pbPtr )	const	{

			SerializeToPointer( pbPtr ) ;
			return	pbPtr ;
		}

		LPBYTE
		Restore( LPBYTE pbPtr, DWORD&	cbOut ) {

			cbOut = 0 ;
			RestoreFromPointer( pbPtr ) ;
			return	pbPtr ;
		}

		DWORD
		Size( )	const {

			return	GetEntrySize() ;

		}

		BOOL
		Verify( LPBYTE	pbContainer, LPBYTE	pbPtr, DWORD	cbData )	const	{

			return Verify( pbContainer, (DWORD)(pbPtr-pbContainer), pbPtr) ;
		}

		//
		// take data and store it into a pointer.  no more then
		// CHashEntry::GetEntrySize() bytes should be stored here
		//
	    virtual void SerializeToPointer(LPBYTE pbPtr) const=0;
		//
		// unserialize data at pbPtr into this class
		//
	    virtual void RestoreFromPointer(LPBYTE pbPtr)=0;
		//
		// the number of bytes required to store the data in this
		// hash entry
		//
	    virtual DWORD GetEntrySize() const=0;
		//
		// make sure that data is valid in its marshalled format
		//
		virtual BOOL Verify(LPBYTE pKey, DWORD cKey, LPBYTE pbPtr) const = 0;
};


class CHashWalkContext
{
	private:
		//
		// variables needed for GetFirstMapEntry/GetNextMapEntry
		//
		// buffer containing the data in the current page
		BYTE m_pPageBuf[HASH_PAGE_SIZE];
		// the current page that we are examining
		DWORD m_iCurrentPage;
		// the current entry in the current page
		DWORD m_iPageEntry;

	friend class CHashMap;
};

//
// Flags returned from VerifyHashMapFile in *pdwErrorFlags.  anything that fits
// in the mask 0x0000ffff is a fatal error (so the hashmap is invalid)
//
// invalid directory link
#define HASH_FLAG_BAD_LINK             0x00000001
// invalid hash file signature
#define HASH_FLAG_BAD_SIGNATURE        0x00000002
// invalid hash file size
#define HASH_FLAG_BAD_SIZE             0x00000004
// corrupt page prefix
#define HASH_FLAG_PAGE_PREFIX_CORRUPT  0x00000008
// file init flag not set
#define HASH_FLAG_NOT_INIT             0x00000010
// page entry count doesn't match number of page entries
#define HASH_FLAG_BAD_ENTRY_COUNT      0x00000020
// invalid page count
#define HASH_FLAG_BAD_PAGE_COUNT       0x00000040
// bad directory depth
#define HASH_FLAG_BAD_DIR_DEPTH        0x00000080
// invalid entry size or offset
#define HASH_FLAG_ENTRY_BAD_SIZE       0x00000100
// invalid entry hash value
#define HASH_FLAG_ENTRY_BAD_HASH       0x00000200
// Verify() function on entry data failed
#define HASH_FLAG_ENTRY_BAD_DATA       0x00000400

//
// hash file couldn't be found
//
#define HASH_FLAG_NO_FILE              0x00010000
//
// If this is set, then no rebuilding is to take place
// because of a fatal error.
//
#define HASH_FLAG_ABORT_SCAN           0x00020000

//
// flags that can be passed into the verify functions to specify how
// strict they should be (more flags means longer checks and slower
// runs).
//
//

// build a directory and check it for integrity.  this is also done in
// Initialize, so it is not needed in general
#define HASH_VFLAG_FILE_CHECK_DIRECTORY		0x00000001
// do basic checks for for valid offsets, page lengths, and hash values
// for each entry (this needs to be there for anything to get checked in
// pages)
#define HASH_VFLAG_PAGE_BASIC_CHECKS		0x00010000
// call the CHashEntry::Verify method to check the data of each entry
#define HASH_VFLAG_PAGE_VERIFY_DATA			0x00020000
// check for overlapping entries
#define HASH_VFLAG_PAGE_CHECK_OVERLAP		0x00040000

#define HASH_VFLAG_ALL 						0xffffffff



//
// These flags indicate that the file is corrupt and should
// be rebuilt.
//
#define HASH_FLAGS_CORRUPT             0x0000ffff

//
//
//
// CHashMap - pure virtual base class for NNTP hash table
//
// The algorithm we are using is similar to the Extendible Hashing
// Technique specified in "Extendible Hashing - A Fast Access Method for
// Dynamic Files" ACM Transaction on Database, 1979 by Fagin,
// Nievergelt, et.al.  This algorithm guarantees at most 2 page faults
// to locate a given key.
//
class CHashMap {

public:

    CHashMap();
    virtual ~CHashMap( );

	//
	// verify that a hash file isn't corrupted (fsck/chkdsk for hashmap
	// files).  this should be called before init
	//
	static BOOL VerifyHashFile(
				LPCSTR HashFileName,
				DWORD Signature,
				DWORD dwCheckFlags,
				DWORD *pdwErrorFlags,
				IKeyInterface*	pIKey,
				ISerialize	*pHashEntry);

	//
	//	Initialize the hash table but specify what cache to use !
	//
	BOOL	Initialize(
                IN LPCSTR HashFileName,
                IN DWORD Signature,
                IN DWORD MinimumFileSize,
				IN DWORD Fraction,
				IN CCACHEPTR	pCache,
				IN DWORD dwCheckFlags = HASH_VFLAG_PAGE_BASIC_CHECKS,
				IN HASH_FAILURE_PFN	HashFailurePfn = 0,
				IN LPVOID	lpvFailureCallback = 0,
				IN BOOL	fNoBuffering = FALSE
                );
    //
    // Initialize the hash table
	// this needs to be called before the hash table is used.
    //
    BOOL Initialize(
                IN LPCSTR HashFileName,
                IN DWORD Signature,
                IN DWORD MinimumFileSize,
				IN DWORD cPageEntry = 256,
				IN DWORD cNumLocks = 64,
				IN DWORD dwCheckFlags = HASH_VFLAG_PAGE_BASIC_CHECKS,
				IN HASH_FAILURE_PFN	HashFailurePfn = 0,
				IN LPVOID	lpvFailureCallback = 0,
				IN BOOL	fNoBuffering = FALSE
                );

	//
	// Lookup an entry
	//
	// helper functions for some of the non-obvious uses of this are below
	//
	BOOL LookupMapEntry(	const	IKeyInterface*	pIKey,
							ISerialize*		pHashEntry,
							BOOL			bDelete = FALSE,
							BOOL			fDirtyOnly = FALSE
							);

    //
    // Delete an entry
    //
    BOOL DeleteMapEntry(	const	IKeyInterface*	pIKey,
							BOOL	fDirtyOnly = FALSE ) {
		return LookupMapEntry(pIKey, 0, TRUE, fDirtyOnly);
	}

	//
	// Lookup and Delete and entry in one step
	//
	BOOL LookupAndDelete(	const	IKeyInterface*	pIKey,
							ISerialize	*pHashEntry) {
		return LookupMapEntry(pIKey, pHashEntry, TRUE);
	}

	//
	// See if the entry is here
	//
	BOOL Contains(	const	IKeyInterface*	pIKey ) {
		return LookupMapEntry(pIKey, 0, FALSE);
	}

	//
	// Insert or update a map entry
	//
	BOOL InsertOrUpdateMapEntry(const	IKeyInterface*	pIKey,
								const	ISerialize*		pHashEntry,
								BOOL bUpdate = FALSE,
                                BOOL fDirtyOnly = FALSE);

    //
	// Insert new entry
	//
	BOOL InsertMapEntry(const	IKeyInterface*	pIKey,
						const	ISerialize*		pHashEntry,
                        BOOL    fDirtyOnly = FALSE) {
		return InsertOrUpdateMapEntry(pIKey, pHashEntry, FALSE, fDirtyOnly);
	}

	//
	// Update Map Entry
	//
	BOOL UpdateMapEntry(const	IKeyInterface*	pIKey,
						const	ISerialize*		pHashEntry) {
		return InsertOrUpdateMapEntry(pIKey, pHashEntry, TRUE);
	}

	//
    // returns the current number of entries in the hash table
    //
    DWORD GetEntryCount() const { return(m_nEntries); }

	//
	// see if the hash table is active
	//
	inline BOOL IsActive() { return	m_active; }

	//
	// methods for walking the entries in the hashtable.  order should be
	// considered random.
	//
	BOOL
	GetFirstMapEntry(	IKeyInterface*	pIKey,
						DWORD&			cbKeyRequried,
						ISerialize*		pHashEntry,
						DWORD&			cbEntryRequried,
						CHashWalkContext *pHashWalkContext,
						IEnumInterface*	pEnum
						);

	//
	//	Get the next entry
	//
	BOOL
	GetNextMapEntry(	IKeyInterface*	pIKey,
						DWORD&			cbKeyRequried,
						ISerialize*		pHashEntry,
						DWORD&			cbEntryRequried,
						CHashWalkContext *pHashWalkContext,
						IEnumInterface	*pEnum
						);

	//
	//	Get the next entry in the next page
	//
	BOOL
	GetNextPageEntry(	IKeyInterface*	pIKey,
						DWORD&			cbKeyRequried,
						ISerialize*		pHashEntry,
						DWORD&			cbEntryRequried,
						CHashWalkContext *pHashWalkContext,
						IEnumInterface	*pEnum
						);


	//
	// make a backup copy of the hashmap suitable
	//
	BOOL MakeBackup(LPCSTR pszBackupFilename);

    //
    // CRCHash function (which is the default, but can be overridden by
	// overriding the Hash method below)
    //
    static DWORD CRCHash(IN const BYTE * Key, IN DWORD KeyLength);
	static void CRCInit(void);

protected :

    //
    // Close the hash table
    //
    virtual VOID Shutdown(BOOL	fLocksHeld = FALSE);

private:

	//
	//	Create the initial set of directory objects !!!
	//
	DWORD
	InitializeDirectories(
			WORD	cBitDepth
			) ;


	//
	// verify that the page structure is valid
	//
	static BOOL VerifyPage(	PMAP_PAGE Page,
							DWORD dwCheckFile,
							DWORD *pdwErrorFlags,
							IKeyInterface*	pIKey,
							ISerialize	*pHashEntry
							);

    //
    // Allocates and initialize the directory
    //

    DWORD I_BuildDirectory( BOOL SetupHashFile = TRUE );

    //
    // Cleans up the mapping
    //

    VOID I_DestroyPageMapping( VOID );

    //
    // Additional work that needs to be done by the derived class
    // for an entry during an insertion
    //
    virtual	VOID I_DoAuxInsertEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    )	{}

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //

    virtual VOID I_DoAuxDeleteEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    ) {}

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a page split
    //

    virtual VOID I_DoAuxPageSplit(
                    IN PMAP_PAGE OldPage,
                    IN PMAP_PAGE NewPage,
                    IN PVOID NewEntry
                    ) {}

    //
    // Find next available slot for an entry
    //

    DWORD I_FindNextAvail(
                    IN HASH_VALUE HashValue,
                    IN PMAP_PAGE MapPage
                    );

    //
    // Initializes a brand new hash file
    //

    DWORD I_InitializeHashFile( VOID );

    //
    // Initialize a new leaf
    //

    VOID I_InitializePage(
                IN PMAP_PAGE MapPage,
                IN DWORD HashPrefix,
                IN DWORD PageDepth
                );

    //
    // link the deleted entry to the delete list
    //

    VOID I_LinkDeletedEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD Offset
                    );


	//
	//	When re-loading a hash table, we need to increase our directory
	//	depth on the fly without grabbing any locks etc...
	//
	BOOL I_SetDirectoryDepthAndPointers(
					IN	PMAP_PAGE	MapPage,
					IN	DWORD	PageNum
					) ;

    //
    // Set up links for the given page
    //

    BOOL I_SetDirectoryPointers(
					IN HPAGELOCK&	hLock,
                    IN PMAP_PAGE MapPage,
                    IN DWORD PageNumber,
                    IN DWORD MaxDirEntries
                    );

    //
    // Open the hash file and set up file mappings
    //

    DWORD I_SetupHashFile( IN BOOL &NewTable );

	//
	//	Find a page we can use within the hash table.
	//
	DWORD	I_AllocatePageInFile(WORD Depth) ;

    //
    // loads/unloads the correct page view
    //

	inline
    PDWORD LoadDirectoryPointerShared(
        DWORD HashValue,
		HPAGELOCK&	hLock
        );

	inline
    PDWORD LoadDirectoryPointerExclusive(
        DWORD HashValue,
		HPAGELOCK&	hLock
        );

    //
    // Compare if reserved pages are same
    //
    BOOL CompareReservedPage( HASH_RESERVED_PAGE* page1, HASH_RESERVED_PAGE* page2 );

    //
    // Current depth of directory
    //

    WORD m_dirDepth;

	//
	// Number of bits we use to select a CDirectory object !
	//

	WORD m_TopDirDepth ;

    //
    // Initial depth of leaves
    //

    WORD m_initialPageDepth;

    //
    // Maximum number of entries per leaf page before we split
    //

    WORD m_pageEntryThreshold;

    //
    // Maximum number of bytes used before we split
    //

    WORD m_pageMemThreshold;

    //
    // Name of the hash file
    //

    CHAR m_hashFileName[MAX_PATH];

    //
    // handle to the hash file
    //

    HANDLE m_hFile;

	//
	//	Do we want to let NT do buffering of this file !
	//

	BOOL	m_fNoBuffering ;

    //
    // pages allocated
    //

    DWORD m_maxPages;

	//
	//	Long that we use to synchronize FlushHeaderStats() call -
	//	whoever InterlockExchange's and gets a 0 back should go
	//	ahead and assume they have the lock !
	//

	long	m_UpdateLock ;

	//
	//	Critical section for managing allocation of new pages
	//
	CRITICAL_SECTION	m_PageAllocator ;

	//
	//	Boolean to indicate whether we've had a critical
	//	failure in allocating memory, and will be unable
	//	to recover simply !
	//	ie.  If we fail a VirtualAlloc() call, then we set this to
	//	TRUE, as we will probably not recover.  However, if we have
	//	run out of Disk Space, we leave this as FALSE as we will
	//	probably be able to recover.
	//
	BOOL	m_fCriticalFailure ;

	//
	//	A pointer of a function to call in case of severe failures
	//	which will crimp the hash tables functionality.
	//
	HASH_FAILURE_PFN	m_HashFailurePfn ;

	//
	//	An opaque LPVOID we will pass to the m_HashFailurePfn when
	//	we call it.
	//
	LPVOID	m_lpvHashFailureCallback ;

    //
    // handle to file mapping
    //

    HANDLE m_hFileMapping;

    //
    // pointer to the reserved page
    //

    PHASH_RESERVED_PAGE m_headPage;

#if 0
    //
    // pointer to the hash file
    //

    //PMAP_PAGE m_hashPages;

	LPVOID	m_lpvBuffers ;
#endif


    //
    // Handle to the directory mapping
    //

    HANDLE m_hDirMap;

    //
    // Locks the directory
    //
	_RWLOCK	*m_dirLock;


	//
	//	Top level directory
	//

	// DWORD	*m_pTopDirectory ;

	//
	//	Array of CDirectory objects - used to find out what hash
	//	table pages have the data we want !
	//

	CDirectory	*m_pDirectory[(1<< MAX_NUM_TOP_DIR_BITS)] ;

	//
	//	Pointer to the Cache which holds all of our pages
	//
	CCACHEPTR	m_pPageCache ;

	//
	//	A power of 2 fraction which indicates what
	//	purportion of the cache pages we can occupy !
	//
	DWORD		m_Fraction ;

    //
    // Head page signature
    //

    DWORD m_HeadPageSignature;

    //
    // whether the hash table is active or not
    //

    BOOL m_active;

	//
	// methods for GetFirstMapEntry/GetNextMapEntry
	//
	BOOL LoadWalkPage(CHashWalkContext *pHashWalkContext);

	//
	// the flags to pass into VerifyPage when loading pages (0 disables
	// calling VerifyPage)
	//
	DWORD m_dwPageCheckFlags;

	//
	// Set to TRUE if we successfully returned from Initialize().  If this
	// occurs then on shutdown we should be able to save the Directory
	// structure
	//
	BOOL m_fCleanInitialize;

protected:

    //
    // Hash function
    //
    virtual DWORD Hash(IN LPBYTE Key, IN DWORD KeyLength);

    //
    // acquire directory lock
    //
    VOID AcquireBackupLockShared( );
    VOID AcquireBackupLockExclusive( );

    //
    // acquires the lock for the given directory entry index
    // returns a handle to the actual lock
    //

    PMAP_PAGE	AcquireLockSetShared(
					IN DWORD DirEntry,
					OUT HPAGELOCK&	lock,
					BOOL	fDropDirectory = FALSE
					);

    PMAP_PAGE	AcquireLockSetExclusive(
					IN DWORD DirEntry,
					OUT HPAGELOCK&	lock,
					BOOL	fDropDirectory = FALSE
					);

	//
	//	Add a secondary page to the pagelock !
	//
    BOOL		AddLockSetExclusive(
					IN DWORD DirEntry,
					OUT HPAGELOCK&	lock
					);


	BOOL
	AddPageExclusive(
                IN DWORD	PageNum,
                OUT HPAGELOCK& hLock
                ) ;

	//
	//	Get the page addresss,
	//	Get a shared lock on the directory AND
	//	an exclusive lock on the page !
	//
	PMAP_PAGE GetPageExclusive(
						IN	HASH_VALUE	HashValue,
						OUT	HPAGELOCK&	hLock
						) ;

    //
    // Get the page address and also get a shared lock
	//	on both the directory and page objects !
    //

    PMAP_PAGE GetDirAndPageShared(
                        IN HASH_VALUE HashValue,
                        OUT HPAGELOCK& hLock
                        );

	//
	//	Get the page address, an exclusive lock on the page
	//	and an exclusive lock on the directory !
	//
    PMAP_PAGE GetDirAndPageExclusive(
                        IN HASH_VALUE HashValue,
                        OUT HPAGELOCK& hLock
                        );

    //
    // Get the page address and also lock the directory and page
    // given the page number
    //

    PMAP_PAGE GetAndLockPageByNumber(
                                IN DWORD PageNumber,
                                OUT HPAGELOCK& hLock
                                );

	//
	//	Get the page address, and do not lock the directory, but
	//	do lock the page.  Caller must have directory lock already !
	//

	PMAP_PAGE GetAndLockPageByNumberNoDirLock(
					IN DWORD PageNumber,
					OUT HPAGELOCK& hLock
					) ;


    //
    // See if the next bit is one
    //

    BOOL I_NextBitIsOne( IN HASH_VALUE HashValue, IN DWORD PageDepth ) {
            return (BOOL)(HashValue & LeafMask[PageDepth]);
            }

    //
    // Releases the directory lock
    //
	VOID	ReleaseBackupLockShared( );
	VOID	ReleaseBackupLockExclusive();

    //
    // releases the lock
    //

#if 0
    VOID ReleaseLock( PMAP_PAGE	page, HPAGELOCK&	hLock ) {
                        hLock.ReleasePage( page ) ;
                        }
#endif

    //
    // releases both the page lock and the backup lock
    //

	inline	VOID
	ReleasePageShared(
					PMAP_PAGE	page,
					HPAGELOCK&	hLock
					)	;

	inline	VOID
	ReleasePageExclusive(
					PMAP_PAGE	page,
					HPAGELOCK&	hLock
					) ;

    //
    // Page compaction
    //

    BOOL CompactPage(
					IN	HPAGELOCK&	HLock,
					PMAP_PAGE Page
					);

    //
    // Expand hash file
    //

    BOOL ExpandHashFile(
            DWORD NumPagesToAdd = DEF_PAGE_INCREMENT
            );

    //
    // Expands the directory.  Directory will grow by
    // a multiple of 2**nBitsExpand.
    //

    BOOL ExpandDirectory(
			HPAGELOCK&	hPageLock,
            WORD nBitsExpand = DEF_DEPTH_INCREMENT
            );

    //
    // Find an existing entry
    //

    BOOL FindMapEntry(
                    IN const IKeyInterface*	pIKey,
                    IN HASH_VALUE HashValue,
                    IN PMAP_PAGE MapPage,
					IN const ISerialize* pIEntryInterface,
                    OUT PDWORD AvailIndex OPTIONAL,
                    OUT PDWORD MatchedIndex OPTIONAL
                    );

    //
    // Updates the header statistics
    //

    VOID FlushHeaderStats(
					BOOL	fLockHeld = FALSE
					);


	//
	// flush a page
	//
    BOOL FlushPage(
                    HPAGELOCK&  hLock,
					PVOID Base,
					BOOL	fDirtyOnly = FALSE
					);

	//
    // Get the remaining bytes in the system
    //

    DWORD GetBytesAvailable( PMAP_PAGE MapPage ) {
                return((DWORD)(MapPage->LastFree - MapPage->NextFree));
                }

    //
    // Given the hash value, get the index to the directory
    // NOTE: m_dirDepth must never be == 0 or else this computation
    // will not work.  It is initialized to 2 in the hash table so
    // can never be 0 by design.
    //

    DWORD GetDirIndex( HASH_VALUE HashValue ) {
                            return (HashValue >> (32 - m_dirDepth ));
                            }

    //
    // Get the leaf entry index
    //

    DWORD GetLeafEntryIndex( HASH_VALUE HashValue ) {
                            return (DWORD)(HashValue & LEAF_ENTRY_MASK);
                            }

    //
    // Increment global stats
    //

    VOID IncrementInsertCount( VOID ) {
                    InterlockedIncrement((PLONG)&m_nInsertions);
                    ++m_nEntries;}
    VOID IncrementDeleteCount( VOID ) {
                    InterlockedIncrement((PLONG)&m_nDeletions);
                    --m_nEntries;}

    VOID IncrementSearchCount( VOID ) { m_nSearches++; }
    VOID IncrementSplitCount( VOID ) { m_nPageSplits++; }
    VOID IncrementDirExpandCount( VOID ) { m_nDirExpansions++; }
    VOID IncrementTableExpandCount( VOID ) { m_nTableExpansions++; }
    VOID IncrementDupInsertCount( VOID ) { m_nDupInserts++; }

    //
    // link the deleted entry to the delete list
    //

    VOID LinkDeletedEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD Offset
                    );


    //
    // Allocate a deleted buffer, if possible
    //

    PVOID ReuseDeletedSpace(
                IN PMAP_PAGE MapPage,
				IN HPAGELOCK&	HLock,
                IN DWORD & NeededEntrySize
                );

    //
    // Sets a page flag bit
    //

    VOID SetPageFlag(
				PMAP_PAGE MapPage,
				HPAGELOCK&	HLock,
				WORD Mask
				) {
            MapPage->Flags |= (WORD)(Mask);
			FlushPage( HLock, MapPage ) ;
            }

    //
    // Splits a page
    //

    BOOL SplitPage(
            IN PMAP_PAGE Page,
			HPAGELOCK&	hLock,
            OUT BOOL & Expand
            );

	//
	// get the size of an entry
	//
	DWORD GetEntrySize(	const ISerialize*	pIKey,
						const ISerialize*	pHashEntry
						);

    //
    // **************************************************************
    // **************************************************************

    //
    // number of Map pages
    //

    DWORD m_nPagesUsed;

    //
    // number of insertions
    //

    DWORD m_nInsertions;

    //
    // number of deletions
    //

    DWORD m_nDeletions;

    //
    // number of entries in the hash table
    //

    DWORD m_nEntries;

    //
    // number of searches
    //

    DWORD m_nSearches;

    //
    // number of duplicate insertions
    //

    DWORD m_nDupInserts;

    //
    // number of pages plits
    //

    DWORD m_nPageSplits;

    //
    // number of times we had to expand the directory
    //

    DWORD m_nDirExpansions;

    //
    // number of times we had to remap the file
    //

    DWORD m_nTableExpansions;

}; // CHashMap


//
//	This class defines a hash table which uses LPSTR's as the
//	key !
//
class	CStringHashMap :	private	CHashMap	{
public :
	//
	// verify that a hash file isn't corrupted (fsck/chkdsk for hashmap
	// files).  this should be called before init
	//
	static BOOL VerifyHashFile(
				LPCSTR HashFileName,
				DWORD Signature,
				DWORD dwCheckFlags,
				DWORD *pdwErrorFlags,
				ISerialize	*pHashEntry)	{

		IStringKey	key ;

		return	CHashMap::VerifyHashFile(
					HashFileName,
					Signature,
					dwCheckFlags,
					pdwErrorFlags,
					&key,
					pHashEntry
					) ;
	}

    //
    // Initialize the hash table
	// this needs to be called before the hash table is used.
    //
    BOOL Initialize(
                IN LPCSTR HashFileName,
                IN DWORD Signature,
                IN DWORD MinimumFileSize,
				IN DWORD cPageEntry = 256,
				IN DWORD cNumLocks = 64,
				IN DWORD dwCheckFlags = HASH_VFLAG_PAGE_BASIC_CHECKS,
				IN HASH_FAILURE_PFN	HashFailurePfn = 0,
				IN LPVOID	lpvFailureCallback = 0
                )	{
		return	CHashMap::Initialize(
						HashFileName,
						Signature,
						MinimumFileSize,
						cPageEntry,
						cNumLocks,
						dwCheckFlags,
						HashFailurePfn,
						lpvFailureCallback
						) ;
	}

	//
	// Lookup an entry
	//
	// helper functions for some of the non-obvious uses of this are below
	//
	BOOL LookupMapEntry(LPBYTE Key,
						DWORD KeyLen,
						ISerialize	*pHashEntry,
						BOOL bDelete = FALSE)	{

		IStringKey	key( Key, KeyLen ) ;
		return	CHashMap::LookupMapEntry( &key, pHashEntry, bDelete ) ;
	}

    //
    // Delete an entry
    //
    BOOL DeleteMapEntry(LPBYTE Key, DWORD KeyLen) {
		return LookupMapEntry(Key, KeyLen, NULL, TRUE);
	}

	//
	// Lookup and Delete and entry in one step
	//
	BOOL LookupAndDelete(LPBYTE Key, DWORD KeyLen, ISerialize	*pHashEntry) {
		return LookupMapEntry(Key, KeyLen, pHashEntry, TRUE);
	}

	//
	// See if the entry is here
	//
	BOOL Contains(LPBYTE Key, DWORD KeyLen) {
		return LookupMapEntry(Key, KeyLen, NULL);
	}

	//
	// Insert or update a map entry
	//
	BOOL InsertOrUpdateMapEntry(LPBYTE Key, DWORD KeyLen, const ISerialize	*pHashEntry, BOOL bUpdate = FALSE)	{
		IStringKey	key( Key, KeyLen ) ;
		return	CHashMap::InsertOrUpdateMapEntry( &key, pHashEntry, bUpdate ) ;
	}

    //
	// Insert new entry
	//
	BOOL InsertMapEntry(LPBYTE Key, DWORD KeyLen, const ISerialize	*pHashEntry) {
		return InsertOrUpdateMapEntry(Key, KeyLen, pHashEntry, FALSE);
	}

	//
	// Update Map Entry
	//
	BOOL UpdateMapEntry(LPBYTE Key, DWORD KeyLen, const ISerialize	*pHashEntry) {
		return InsertOrUpdateMapEntry(Key, KeyLen, pHashEntry, TRUE);
	}

	//
    // returns the current number of entries in the hash table
    //
    DWORD GetEntryCount() const { return(m_nEntries); }

	//
	// see if the hash table is active
	//
	inline BOOL IsActive() { return	CHashMap::IsActive(); }

	//
	// methods for walking the entries in the hashtable.  order should be
	// considered random.
	//
	BOOL GetFirstMapEntry(	LPBYTE pKey,
							PDWORD pKeyLen,
							ISerialize	*pHashEntry,
							CHashWalkContext *pHashWalkContext)	{

		DWORD	cbData ;
		IStringKey	key( pKey, *pKeyLen ) ;
		BOOL	fReturn = CHashMap::GetFirstMapEntry(	&key,
														*pKeyLen,
														pHashEntry,
														cbData,
														pHashWalkContext,
														0
														) ;

		return	fReturn ;
	}

	BOOL GetNextMapEntry(	LPBYTE pKey,
							PDWORD pKeyLen,
							ISerialize	*pHashEntry,
							CHashWalkContext *pHashWalkContext)	{

		DWORD	cbData ;
		IStringKey	key( pKey, *pKeyLen ) ;
		BOOL	fReturn = CHashMap::GetNextMapEntry(	&key,
														*pKeyLen,
														pHashEntry,
														cbData,
														pHashWalkContext,
														0
														) ;

		return	fReturn ;


	}

	//
	// make a backup copy of the hashmap suitable
	//
	BOOL MakeBackup(LPCSTR pszBackupFilename)	{
		return	CHashMap::MakeBackup( pszBackupFilename ) ;
	}

} ;


//
//	This class defines a page cache that can be shared amongst hash tables !
//
//
class	CPageCache :	public	CRefCount	{
private :

	LPVOID			m_lpvBuffers ;

	//
	//	Number of PageLock objects we use to keep track of our cache.
	//
	DWORD			m_cPageEntry ;

	//
	//	Pointer to an array of PageEntry objects !
	//
	PageEntry*		m_pPageEntry ;

	//
	//	Track the number of locks we are using to sync access to the pages
	//
	DWORD			m_cpageLock ;

	//
	//	Pointer to the array of locks we are using !
	//
	_RWLOCK*		m_ppageLock ;

	//
	//	No copying of CPageCache objects !
	//
	CPageCache( CPageCache& ) ;
	CPageCache&	operator=( CPageCache& ) ;

public :

	CPageCache() ;
	~CPageCache() ;

	BOOL
	Initialize(		DWORD	cPageEntry = 0,
					DWORD	cLocks = 0
					) ;

	inline	PMAP_PAGE
	AcquireCachePageShared(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock,
					IN	BOOL	fDropDirectory
					) ;

	inline	PMAP_PAGE
	AcquireCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock,
					BOOL	fDropDirectory
					) ;


	inline	BOOL
	AddCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock
					) ;

    //
    // releases both the page lock and the backup lock
    //

	static	inline	VOID
	ReleasePageShared(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						) ;

	static	inline	VOID
	ReleasePageExclusive(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						) ;

	//
	//	Remove this file handle from the cache wherever it appears !
	//
	void
	FlushFileFromCache(
					IN	HANDLE	hFile
					) ;

} ;

DWORD
CalcNumPagesPerIO( DWORD nPages );


#include	"hashimp.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\iis3ext.h ===
/********
*
*  Copyright (c) 1995  Process Software Corporation
*
*  Copyright (c) 1995-1997  Microsoft Corporation
*
*
*  Module Name  : HttpExt.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*      HTTP Server Extension interface used to build ISAPI Applications
*
******************/

#ifndef _HTTPEXT_H_
#define _HTTPEXT_H_

#include <windows.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


/************************************************************
 *   Manifest Constants
 ************************************************************/

#define   HSE_VERSION_MAJOR           4      // major version of this spec
#define   HSE_VERSION_MINOR           0      // minor version of this spec
#define   HSE_LOG_BUFFER_LEN         80
#define   HSE_MAX_EXT_DLL_NAME_LEN  256

#define   HSE_VERSION     MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR )

//
// the following are the status codes returned by the Extension DLL
//

#define   HSE_STATUS_SUCCESS                       1
#define   HSE_STATUS_SUCCESS_AND_KEEP_CONN         2
#define   HSE_STATUS_PENDING                       3
#define   HSE_STATUS_ERROR                         4

//
// The following are the values to request services with the
//   ServerSupportFunction().
//  Values from 0 to 1000 are reserved for future versions of the interface

#define   HSE_REQ_BASE                             0
#define   HSE_REQ_SEND_URL_REDIRECT_RESP           ( HSE_REQ_BASE + 1 )
#define   HSE_REQ_SEND_URL                         ( HSE_REQ_BASE + 2 )
#define   HSE_REQ_SEND_RESPONSE_HEADER             ( HSE_REQ_BASE + 3 )
#define   HSE_REQ_DONE_WITH_SESSION                ( HSE_REQ_BASE + 4 )
#define   HSE_REQ_END_RESERVED                     1000

//
//  These are Microsoft specific extensions
//

#define   HSE_REQ_MAP_URL_TO_PATH                  (HSE_REQ_END_RESERVED+1)
#define   HSE_REQ_GET_SSPI_INFO                    (HSE_REQ_END_RESERVED+2)
#define   HSE_APPEND_LOG_PARAMETER                 (HSE_REQ_END_RESERVED+3)
#define   HSE_REQ_SEND_URL_EX                      (HSE_REQ_END_RESERVED+4)
#define   HSE_REQ_IO_COMPLETION                    (HSE_REQ_END_RESERVED+5)
#define   HSE_REQ_TRANSMIT_FILE                    (HSE_REQ_END_RESERVED+6)
#define   HSE_REQ_REFRESH_ISAPI_ACL                (HSE_REQ_END_RESERVED+7)
#define   HSE_REQ_IS_KEEP_CONN                     (HSE_REQ_END_RESERVED+8)
#define   HSE_REQ_ASYNC_READ_CLIENT                (HSE_REQ_END_RESERVED+10)
#define   HSE_REQ_GET_IMPERSONATION_TOKEN          (HSE_REQ_END_RESERVED+11)
#define   HSE_REQ_MAP_URL_TO_PATH_EX               (HSE_REQ_END_RESERVED+12)
#define   HSE_REQ_EXECUTE_CHILD                    (HSE_REQ_END_RESERVED+13)
#define   HSE_REQ_ABORTIVE_CLOSE                   (HSE_REQ_END_RESERVED+14)
#define   HSE_REQ_GET_CERT_INFO_EX                 (HSE_REQ_END_RESERVED+15)
#define   HSE_REQ_SEND_RESPONSE_HEADER_EX          (HSE_REQ_END_RESERVED+16)

//
//  Bit Flags for TerminateExtension
//
//    HSE_TERM_ADVISORY_UNLOAD - Server wants to unload the extension,
//          extension can return TRUE if OK, FALSE if the server should not
//          unload the extension
//
//    HSE_TERM_MUST_UNLOAD - Server indicating the extension is about to be
//          unloaded, the extension cannot refuse.
//

#define HSE_TERM_ADVISORY_UNLOAD                   0x00000001
#define HSE_TERM_MUST_UNLOAD                       0x00000002

//
// Flags for IO Functions, supported for IO Funcs.
//  TF means ServerSupportFunction( HSE_REQ_TRANSMIT_FILE)
//

# define HSE_IO_SYNC                      0x00000001   // for WriteClient
# define HSE_IO_ASYNC                     0x00000002   // for WriteClient/TF
# define HSE_IO_DISCONNECT_AFTER_SEND     0x00000004   // for TF
# define HSE_IO_SEND_HEADERS              0x00000008   // for TF

//
// Flags for HSE_REQ_EXECUTE_CHILD function
//

# define HSE_EXEC_NO_HEADERS              0x00000001   // Don't send any
                                                       // headers of child
# define HSE_EXEC_REDIRECT_ONLY           0x00000002   // Don't send any
                                                       // headers of child
                                                       // but send redirect
                                                       // message
# define HSE_EXEC_COMMAND                 0x00000004   // Treat as shell
                                                       // command instead of
                                                       // URL                                                       

/************************************************************
 *   Type Definitions
 ************************************************************/

typedef   LPVOID          HCONN;

//
// structure passed to GetExtensionVersion()
//

typedef struct   _HSE_VERSION_INFO {

    DWORD  dwExtensionVersion;
    CHAR   lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN];

} HSE_VERSION_INFO, *LPHSE_VERSION_INFO;


//
// structure passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (WINAPI * ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERRequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;




//
//  Bit field of flags that can be on a virtual directory
//

#define HSE_URL_FLAGS_READ          0x00000001    // Allow for Read
#define HSE_URL_FLAGS_WRITE         0x00000002    // Allow for Write
#define HSE_URL_FLAGS_EXECUTE       0x00000004    // Allow for Execute
#define HSE_URL_FLAGS_SSL           0x00000008    // Require SSL
#define HSE_URL_FLAGS_DONT_CACHE    0x00000010    // Don't cache (vroot only)
#define HSE_URL_FLAGS_NEGO_CERT     0x00000020    // Allow client SSL certs
#define HSE_URL_FLAGS_REQUIRE_CERT  0x00000040    // Require client SSL certs
#define HSE_URL_FLAGS_MAP_CERT      0x00000080    // Map SSL cert to NT account
#define HSE_URL_FLAGS_SSL128        0x00000100    // Require 128 bit SSL
#define HSE_URL_FLAGS_SCRIPT        0x00000200    // Allow for Script execution

#define HSE_URL_FLAGS_MASK          0x000003ff

//
//  Structure for extended information on a URL mapping
//

typedef struct _HSE_URL_MAPEX_INFO {

    CHAR   lpszPath[MAX_PATH]; // Physical path root mapped to
    DWORD  dwFlags;            // Flags associated with this URL path
    DWORD  cchMatchingPath;    // Number of matching characters in physical path
    DWORD  cchMatchingURL;     // Number of matching characters in URL

    DWORD  dwReserved1;
    DWORD  dwReserved2;

} HSE_URL_MAPEX_INFO, * LPHSE_URL_MAPEX_INFO;



//
// PFN_HSE_IO_COMPLETION - callback function for the Async I/O Completion.
//

typedef VOID
  (WINAPI * PFN_HSE_IO_COMPLETION)(
                                   IN EXTENSION_CONTROL_BLOCK * pECB,
                                   IN PVOID    pContext,
                                   IN DWORD    cbIO,
                                   IN DWORD    dwError
                                   );



//
// HSE_TF_INFO defines the type for HTTP SERVER EXTENSION support for
//  ISAPI applications to send files using TransmitFile.
// A pointer to this object should be used with ServerSupportFunction()
//  for HSE_REQ_TRANSMIT_FILE.
//

typedef struct _HSE_TF_INFO  {

    //
    // callback and context information
    // the callback function will be called when IO is completed.
    // the context specified will be used during such callback.
    //
    // These values (if non-NULL) will override the one set by calling
    //  ServerSupportFunction() with HSE_REQ_IO_COMPLETION
    //
    PFN_HSE_IO_COMPLETION   pfnHseIO;
    PVOID  pContext;

    // file should have been opened with FILE_FLAG_SEQUENTIAL_SCAN
    HANDLE hFile;

    //
    // HTTP header and status code
    // These fields are used only if HSE_IO_SEND_HEADERS is present in dwFlags
    //

    LPCSTR pszStatusCode; // HTTP Status Code  eg: "200 OK"

    DWORD  BytesToWrite;  // special value of "0" means write entire file.
    DWORD  Offset;        // offset value within the file to start from

    PVOID  pHead;         // Head buffer to be sent before file data
    DWORD  HeadLength;    // header length
    PVOID  pTail;         // Tail buffer to be sent after file data
    DWORD  TailLength;    // tail length

    DWORD  dwFlags;       // includes HSE_IO_DISCONNECT_AFTER_SEND, ...

} HSE_TF_INFO, * LPHSE_TF_INFO;


//
//	HSE_SEND_HEADER_EX_INFO allows an ISAPI application to send headers
//	and specify keep-alive behavior in the same call.
//

typedef struct _HSE_SEND_HEADER_EX_INFO  {

    //
    // HTTP status code and header
    //

    LPCSTR  pszStatus;  // HTTP status code  eg: "200 OK"
    LPCSTR  pszHeader;  // HTTP header

    DWORD   cchStatus;  // number of characters in status code
    DWORD   cchHeader;  // number of characters in header

    BOOL    fKeepConn;  // keep client connection alive?

} HSE_SEND_HEADER_EX_INFO, * LPHSE_SEND_HEADER_EX_INFO;


//
//	CERT_CONTEXT_EX is passed as an an argument to 
//  ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX )
//

typedef struct _CERT_CONTEXT_EX {
    CERT_CONTEXT    CertContext;
    DWORD           cbAllocated;
    DWORD           dwCertificateFlags;
} CERT_CONTEXT_EX;


/************************************************************
 *   Function Prototypes 
 *   o  for functions exported from the ISAPI Application DLL
 ************************************************************/

BOOL  WINAPI   GetExtensionVersion( HSE_VERSION_INFO  *pVer );
DWORD WINAPI   HttpExtensionProc(  EXTENSION_CONTROL_BLOCK *pECB );
BOOL  WINAPI   TerminateExtension( DWORD dwFlags );

// the following type declarations is for use in the server side

typedef BOOL
    (WINAPI * PFN_GETEXTENSIONVERSION)( HSE_VERSION_INFO  *pVer );

typedef DWORD 
    (WINAPI * PFN_HTTPEXTENSIONPROC )( EXTENSION_CONTROL_BLOCK * pECB );

typedef BOOL  (WINAPI * PFN_TERMINATEEXTENSION )( DWORD dwFlags );


#ifdef __cplusplus
}
#endif


#endif  // end definition _HTTPEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\ipsbase.h ===
/*
**	SSOBASE.H
**	Sean P. Nolan
**	
**	Simple MSN SSS Object Framework
*/

#ifndef _SSOBASE_H_
#define _SSOBASE_H_

#include "wcsutil.h"
#include <ascript.h>

/*--------------------------------------------------------------------------+
|	Types																	|
+--------------------------------------------------------------------------*/

typedef struct _SsoSupportStuff
	{
	EXCEPINFO		*pexcepinfo;
	LONG			lUser;
	IUnknown		*punk;
	OLECHAR			*wszMethodName;
	}
	SSSTUFF;

typedef HRESULT (*PFNSSOMETHOD)(WORD, DISPPARAMS *, VARIANT *, SSSTUFF *pssstuff);

typedef struct _SSOMethod
	{
	OLECHAR			*wszName;
	PFNSSOMETHOD	pfn;
	int				iMethod;
	}
	SSOMETHOD;

/*--------------------------------------------------------------------------+
|	Globals !!! Provided by the SSO !!!										|
+--------------------------------------------------------------------------*/

extern PFNSSOMETHOD	g_pfnssoDynamic;
extern SSOMETHOD	g_rgssomethod[];
extern LPSTR		g_szSSOProgID;
extern GUID			g_clsidSSO;
extern BOOL			g_fPersistentSSO;
extern LPSTR		g_szComponentName;  //used as event source name 
extern DWORD		g_dwEventID; // event id used if time bomb expired

/*--------------------------------------------------------------------------+
|	Globals Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern HINSTANCE g_hinst;

extern OLECHAR *c_wszOnNewTemplate;
extern OLECHAR *c_wszOnFreeTemplate;
extern HANDLE	g_hEventSrc;

/*--------------------------------------------------------------------------+
|	Routines Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern HRESULT	SSOTranslateVirtualRoot(VARIANT *, IUnknown*, LPSTR, DWORD); 
extern BOOL		SSODllMain(HINSTANCE, ULONG, LPVOID);

/*--------------------------------------------------------------------------+
|	Other Data Needed by the Framework										|
+--------------------------------------------------------------------------*/

const int cTimeSamplesMax = 100;

#define SSO_OFFICIAL_NAME_PREFIX "Microsoft ActiveX Server Component" 

#endif // _SSOBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\inetdata.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inetdata.h

Abstract:

    This module is the main include file for internet server
    specific declarations.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _INETDATA_
#define _INETDATA_
#define _LMACCESS_              // prevents duplicate defn. in lmaccess.h

//
// service object pointers.
//

extern PTCPSVCS_GLOBAL_DATA pTcpsvcsGlobalData; // Shared TCPSVCS.EXE data.

//
//  Service control functions.
//

VOID ServiceEntry( DWORD                cArgs,
                   LPWSTR               pArgs[],
                   PTCPSVCS_GLOBAL_DATA pGlobalData );

#endif // _INETDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\iis3filt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    httpfilt.h

Abstract:

    This module contains the Microsoft HTTP filter extension info

Revision History:

--*/

#ifndef _HTTPFILT_H_
#define _HTTPFILT_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Current version of the filter spec is 4.0
//

#define HTTP_FILTER_REVISION    MAKELONG( 0, 4)

#define SF_MAX_USERNAME         (256+1)
#define SF_MAX_PASSWORD         (256+1)
#define SF_MAX_AUTH_TYPE        (32+1)

#define SF_MAX_FILTER_DESC_LEN  (256+1)

typedef
VOID (WINAPI * PFN_SF_NOTIFY) (
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    );

//
//  These values can be used with the pfnSFCallback function supplied in
//  the filter context structure
//

enum SF_REQ_TYPE
{
    //
    //  Sends a complete HTTP server response header including
    //  the status, server version, message time and MIME version.
    //
    //  Server extensions should append other information at the end,
    //  such as Content-type, Content-length etc followed by an extra
    //  '\r\n'.
    //
    //  pData - Zero terminated string pointing to optional
    //      status string (i.e., "401 Access Denied") or NULL for
    //      the default response of "200 OK".
    //
    //  ul1 - Zero terminated string pointing to optional data to be
    //      appended and set with the header.  If NULL, the header will
    //      be terminated with an empty line.
    //

    SF_REQ_SEND_RESPONSE_HEADER,

    //
    //  If the server denies the HTTP request, add the specified headers
    //  to the server error response.
    //
    //  This allows an authentication filter to advertise its services
    //  w/o filtering every request.  Generally the headers will be
    //  WWW-Authenticate headers with custom authentication schemes but
    //  no restriction is placed on what headers may be specified.
    //
    //  pData - Zero terminated string pointing to one or more header lines
    //      with terminating '\r\n'.
    //

    SF_REQ_ADD_HEADERS_ON_DENIAL,

    //
    //  Only used by raw data filters that return SF_STATUS_READ_NEXT
    //
    //  ul1 - size in bytes for the next read
    //

    SF_REQ_SET_NEXT_READ_SIZE,

    //
    //  Used to indicate this request is a proxy request
    //
    //  ul1 - The proxy flags to set
    //      0x00000001 - This is a HTTP proxy request
    //
    //

    SF_REQ_SET_PROXY_INFO,

    //
    //  Returns the connection ID contained in the ConnID field of an
    //  ISAPI Application's Extension Control Block.  This value can be used
    //  as a key to cooridinate shared data between Filters and Applications.
    //
    //  pData - Pointer to DWORD that receives the connection ID.
    //

    SF_REQ_GET_CONNID,

    //
    // Used to set a SSPI security context + impersonation token
    // derived from a client certificate.
    //
    // pData - certificate info ( PHTTP_FILTER_CERTIFICATE_INFO )
    // ul1 - CtxtHandle*
    // ul2 - impersonation handle
    //

    SF_REQ_SET_CERTIFICATE_INFO,

    //
    // Used to get an IIS property
    // as defined in SF_PROPERTY_IIS
    //
    // ul1 - Property ID
    //

    SF_REQ_GET_PROPERTY,

    //
    // Used to normalize an URL
    //
    // pData - URL to normalize
    //

    SF_REQ_NORMALIZE_URL,

    //
    // Indicates end of renegotiation
    //
    // pData - LPBOOL : TRUE if renegotiation succeeded
    //

    SF_REQ_DONE_RENEGOTIATE,

    //
    // Set notify call-back
    //
    // ul1 - notification type ( SF_NOTIFY_TYPE )
    // pData - ptr to notify function ( PFN_SF_NOTIFY )
    //

    SF_REQ_SET_NOTIFY,

    //
    // Disable Notifications
    //
    // ul1 - notifications to disable
    //

    SF_REQ_DISABLE_NOTIFICATIONS,
    
};


enum SF_PROPERTY_IIS
{
    SF_PROPERTY_CLIENT_CERT_ENABLED,    // return BOOL in pData as LPBOOL
    SF_PROPERTY_MD5_ENABLED,            // return BOOL in pData as LPBOOL
    SF_PROPERTY_DIR_MAP_CERT,           // return BOOL in pData as LPBOOL
    SF_PROPERTY_GET_CERT11_MAPPER,      // These 4 functions returns ptr
    SF_PROPERTY_GET_RULE_MAPPER,        // to RefBlob containing mapper
    SF_PROPERTY_GET_MD5_MAPPER,
    SF_PROPERTY_GET_ITA_MAPPER,
    SF_PROPERTY_GET_INSTANCE_ID,
    SF_PROPERTY_MD_IF,
    SF_PROPERTY_SSL_CTXT,
    SF_PROPERTY_INSTANCE_NUM_ID,
} ;

enum SF_NOTIFY_TYPE
{
    SF_NOTIFY_MAPPER_MD5_CHANGED,
    SF_NOTIFY_MAPPER_ITA_CHANGED,
    SF_NOTIFY_MAPPER_CERT11_CHANGED,
    SF_NOTIFY_MAPPER_CERTW_CHANGED,
    SF_NOTIFY_MAPPER_SSLKEYS_CHANGED,
    SF_NOTIFY_MAPPER_CERT11_TOUCHED,
} ;

//
//  These values are returned by the filter entry point when a new request is
//  received indicating their interest in this particular request
//

enum SF_STATUS_TYPE
{
    //
    //  The filter has handled the HTTP request.  The server should disconnect
    //  the session.
    //

    SF_STATUS_REQ_FINISHED = 0x8000000,

    //
    //  Same as SF_STATUS_FINISHED except the server should keep the TCP
    //  session open if the option was negotiated
    //

    SF_STATUS_REQ_FINISHED_KEEP_CONN,

    //
    //  The next filter in the notification chain should be called
    //

    SF_STATUS_REQ_NEXT_NOTIFICATION,

    //
    //  This filter handled the notification.  No other handles should be
    //  called for this particular notification type
    //

    SF_STATUS_REQ_HANDLED_NOTIFICATION,

    //
    //  An error occurred.  The server should use GetLastError() and indicate
    //  the error to the client
    //

    SF_STATUS_REQ_ERROR,

    //
    //  The filter is an opaque stream filter and we're negotiating the
    //  session parameters.  Only valid for raw read notification.
    //

    SF_STATUS_REQ_READ_NEXT
};

//
//  pvNotification points to this structure for all request notification types
//

typedef struct _HTTP_FILTER_CONTEXT
{
    DWORD          cbSize;

    //
    //  This is the structure revision level.
    //

    DWORD          Revision;

    //
    //  Private context information for the server.
    //

    PVOID          ServerContext;
    DWORD          ulReserved;

    //
    //  TRUE if this request is coming over a secure port
    //

    BOOL           fIsSecurePort;

    //
    //  A context that can be used by the filter
    //

    PVOID          pFilterContext;

    //
    //  Server callbacks
    //

    BOOL (WINAPI * GetServerVariable) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszVariableName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    BOOL (WINAPI * AddResponseHeaders) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszHeaders,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * WriteClient)  (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPVOID                        Buffer,
        LPDWORD                       lpdwBytes,
        DWORD                         dwReserved
        );

    VOID * (WINAPI * AllocMem) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        DWORD                         cbSize,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * ServerSupportFunction) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        enum SF_REQ_TYPE              sfReq,
        PVOID                         pData,
        DWORD                         ul1,
        DWORD                         ul2
        );

} HTTP_FILTER_CONTEXT, *PHTTP_FILTER_CONTEXT;

//
//  This structure is the notification info for the read and send raw data
//  notification types
//

typedef struct _HTTP_FILTER_RAW_DATA
{
    //
    //  This is a pointer to the data for the filter to process.
    //

    PVOID         pvInData;
    DWORD         cbInData;       // Number of valid data bytes
    DWORD         cbInBuffer;     // Total size of buffer

    DWORD         dwReserved;

} HTTP_FILTER_RAW_DATA, *PHTTP_FILTER_RAW_DATA;

//
//  This structure is the notification info for when the server is about to
//  process the client headers
//

typedef struct _HTTP_FILTER_PREPROC_HEADERS
{
    //
    //  For SF_NOTIFY_PREPROC_HEADERS, retrieves the specified header value.
    //  Header names should include the trailing ':'.  The special values
    //  'method', 'url' and 'version' can be used to retrieve the individual
    //  portions of the request line
    //

    BOOL (WINAPI * GetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    //
    //  Replaces this header value to the specified value.  To delete a header,
    //  specified a value of '\0'.
    //

    BOOL (WINAPI * SetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    //
    //  Adds the specified header and value
    //

    BOOL (WINAPI * AddHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    DWORD HttpStatus;               // New in 4.0, status for SEND_RESPONSE
    DWORD SubStatus;                // New in 4.0, status for SEND_RESPONSE

} HTTP_FILTER_PREPROC_HEADERS, *PHTTP_FILTER_PREPROC_HEADERS;

typedef HTTP_FILTER_PREPROC_HEADERS HTTP_FILTER_SEND_RESPONSE;
typedef HTTP_FILTER_PREPROC_HEADERS *PHTTP_FILTER_SEND_RESPONSE;

//
//  Authentication information for this request.
//

typedef struct _HTTP_FILTER_AUTHENT
{
    //
    //  Pointer to username and password, empty strings for the anonymous user
    //
    //  Client's can overwrite these buffers which are guaranteed to be at
    //  least SF_MAX_USERNAME and SF_MAX_PASSWORD bytes large.
    //

    CHAR * pszUser;
    DWORD  cbUserBuff;

    CHAR * pszPassword;
    DWORD  cbPasswordBuff;

} HTTP_FILTER_AUTHENT, *PHTTP_FILTER_AUTHENT;


//
//  Authentication information for this request.
//

typedef struct _HTTP_FILTER_AUTHENTEX
{
    //
    //  Pointer to username and password, empty strings for the anonymous user
    //
    //  Client can overwrite hAccessToken
    //

    CHAR * pszUser;
    DWORD  cbUserBuff;

    CHAR * pszLogonUser;
    DWORD  cbLogonUserBuff;

    CHAR * pszPassword;
    CHAR * pszRealm;

    CHAR * pszAuthType;
    DWORD  cbAuthTypeBuff;

    HANDLE hAccessTokenPrimary;
    HANDLE hAccessTokenImpersonation;

} HTTP_FILTER_AUTHENTEX, *PHTTP_FILTER_AUTHENTEX;


//
//  Indicates the server is going to use the specific physical mapping for
//  the specified URL.  Filters can modify the physical path in place.
//

typedef struct _HTTP_FILTER_URL_MAP
{
    const CHAR * pszURL;

    CHAR *       pszPhysicalPath;
    DWORD        cbPathBuff;

} HTTP_FILTER_URL_MAP, *PHTTP_FILTER_URL_MAP;

//
//  Indicates the server is going to delete the specified impersonation token
//   Only called if the token was created by the filter
//

typedef struct _HTTP_FILTER_REQUEST_CLOSE_SECURITY_CONTEXT
{
    PVOID pCtxt;

} HTTP_FILTER_REQUEST_CLOSE_SECURITY_CONTEXT,
    *PHTTP_FILTER_REQUEST_CLOSE_SECURITY_CONTEXT;

//
//  Bitfield indicating the requested resource has been denied by the server due
//  to a logon failure, an ACL on a resource, an ISAPI Filter or an
//  ISAPI Application/CGI Application.
//
//  SF_DENIED_BY_CONFIG can appear with SF_DENIED_LOGON if the server
//  configuration did not allow the user to logon.
//

#define SF_DENIED_LOGON             0x00000001
#define SF_DENIED_RESOURCE          0x00000002
#define SF_DENIED_FILTER            0x00000004
#define SF_DENIED_APPLICATION       0x00000008

#define SF_DENIED_BY_CONFIG         0x00010000

typedef struct _HTTP_FILTER_ACCESS_DENIED
{
    const CHAR * pszURL;            // Requesting URL
    const CHAR * pszPhysicalPath;   // Physical path of resource
    DWORD        dwReason;          // Bitfield of SF_DENIED flags

} HTTP_FILTER_ACCESS_DENIED, *PHTTP_FILTER_ACCESS_DENIED;


//
// The server request a SSL certificate renegotiation.
// If filter accepts, it must set fAccepted to TRUE
//

typedef struct _HTTP_FILTER_REQUEST_CERT
{
    BOOL    fAccepted;              // [out] request accepted
    BOOL    fMapCert;               // [in] TRUE if cert to be mapped to
                                    //      NT account
    DWORD   dwReserved;

} HTTP_FILTER_REQUEST_CERT, *PHTTP_FILTER_REQUEST_CERT;

//
//  The log information about to be written to the server log file.  The
//  string pointers can be replaced but the memory must remain valid until
//  the next notification
//

typedef struct _HTTP_FILTER_LOG
{
    const CHAR * pszClientHostName;
    const CHAR * pszClientUserName;
    const CHAR * pszServerName;
    const CHAR * pszOperation;
    const CHAR * pszTarget;
    const CHAR * pszParameters;

    DWORD  dwHttpStatus;
    DWORD  dwWin32Status;

    DWORD  dwBytesSent;             // IIS 3.0 and later
    DWORD  dwBytesRecvd;            // IIS 3.0 and later
    DWORD  msTimeForProcessing;     // IIS 3.0 and later

} HTTP_FILTER_LOG, *PHTTP_FILTER_LOG;

//
//  Notification Flags
//
//  SF_NOTIFY_SECURE_PORT
//  SF_NOTIFY_NONSECURE_PORT
//
//      Indicates whether the application wants to be notified for transactions
//      that are happenning on the server port(s) that support data encryption
//      (such as PCT and SSL), on only the non-secure port(s) or both.
//
//  SF_NOTIFY_READ_RAW_DATA
//
//      Applications are notified after the server reads a block of memory
//      from the client but before the server does any processing on the
//      block.  The data block may contain HTTP headers and entity data.
//
//
//

#define SF_NOTIFY_SECURE_PORT               0x00000001
#define SF_NOTIFY_NONSECURE_PORT            0x00000002

#define SF_NOTIFY_READ_RAW_DATA             0x00008000
#define SF_NOTIFY_PREPROC_HEADERS           0x00004000
#define SF_NOTIFY_AUTHENTICATION            0x00002000
#define SF_NOTIFY_URL_MAP                   0x00001000
#define SF_NOTIFY_ACCESS_DENIED             0x00000800
#define SF_NOTIFY_SEND_RESPONSE             0x00000040
#define SF_NOTIFY_SEND_RAW_DATA             0x00000400
#define SF_NOTIFY_LOG                       0x00000200
#define SF_NOTIFY_END_OF_REQUEST            0x00000080
#define SF_NOTIFY_END_OF_NET_SESSION        0x00000100

#define SF_NOTIFY_AUTHENTICATIONEX          0x20000000
#define SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE \
                                            0x10000000
#define SF_NOTIFY_RENEGOTIATE_CERT          0x08000000

//
//  Filter ordering flags
//
//  Filters will tend to be notified by their specified
//  ordering.  For ties, notification order is determined by load order.
//
//  SF_NOTIFY_ORDER_HIGH - Authentication or data transformation filters
//  SF_NOTIFY_ORDER_MEDIUM
//  SF_NOTIFY_ORDER_LOW  - Logging filters that want the results of any other
//                      filters might specify this order.
//

#define SF_NOTIFY_ORDER_HIGH               0x00080000
#define SF_NOTIFY_ORDER_MEDIUM             0x00040000
#define SF_NOTIFY_ORDER_LOW                0x00020000
#define SF_NOTIFY_ORDER_DEFAULT            SF_NOTIFY_ORDER_LOW

#define SF_NOTIFY_ORDER_MASK               (SF_NOTIFY_ORDER_HIGH   |    \
                                            SF_NOTIFY_ORDER_MEDIUM |    \
                                            SF_NOTIFY_ORDER_LOW)

//
//  Filter version information, passed to GetFilterVersion
//

typedef struct _HTTP_FILTER_VERSION
{
    //
    //  Version of the spec the server is using
    //

    DWORD  dwServerFilterVersion;

    //
    //  Fields specified by the client
    //

    DWORD  dwFilterVersion;
    CHAR   lpszFilterDesc[SF_MAX_FILTER_DESC_LEN];
    DWORD  dwFlags;


} HTTP_FILTER_VERSION, *PHTTP_FILTER_VERSION;


typedef struct _HTTP_FILTER_CERTIFICATE_INFO
{
    PBYTE pbCert;
    DWORD cbCert;

} HTTP_FILTER_CERTIFICATE_INFO, *PHTTP_FILTER_CERTIFICATE_INFO;


//
//  A filter DLL's entry point looks like this.  The return code should be
//  an SF_STATUS_TYPE
//
//  NotificationType - Type of notification
//  pvNotification - Pointer to notification specific data
//

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvNotification
    );

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    );

BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    );

#ifdef __cplusplus
}
#endif

#endif //_HTTPFILT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\lodctr.h ===
/*++

lodctr.h

    Include file for lodctr 
    
--*/
#ifndef _LODCTR_H
#define _LODCTR_H


#define TYPE_HELP   1
#define TYPE_NAME   2


#define LC_CMD_HELP_1           201
#define LC_CMD_HELP_2           202
#define LC_CMD_HELP_3           203
#define LC_CMD_HELP_4           204
#define LC_CMD_HELP_5           205
#define LC_CMD_HELP_6           206
#define LC_CMD_HELP_7           207
#define LC_CMD_HELP_8           208
#define LC_CMD_HELP_9           209 
#define LC_CMD_HELP_10          210
#define LC_CMD_HELP_11          211
#define LC_FIRST_CMD_HELP   LC_CMD_HELP_1
#define LC_LAST_CMD_HELP    LC_CMD_HELP_11

#define LC_DEVNAME_ERR_1        107
#define LC_DEVNAME_ERR_2        108

#define LC_NO_INIFILE           109
                  
#define LC_LANGLIST_ERR         110

#define LC_ERR_OPEN_INCLUDE     111

#define LC_ERR_UPDATE_REG       112

#define LC_ERR_OPEN_DRIVERPERF1 113
#define LC_ERR_OPEN_DRIVERPERF2 114
#define LC_ERR_OPEN_PERFLIB     115
#define LC_ERR_READLASTPERFLIB  116
#define LC_ERR_ALREADY_IN       117
#define LC_ERR_UNABLESETBUSY    118

#define LC_BAD_KEY              120
#define LC_LANGNOTFOUND         121
#define LC_ERR_ADDENTRY         122
#define LC_ERRADDTOLANG         123
#define LC_UNABLESORTTABLES     124
#define LC_UNABLEOPENLANG       125
#define LC_UNABLESETVALUE       126
#define LC_ERR_UPDATELANG       127
#define LC_PERFLIBISBUSY        128
#define LC_CONNECT_PROBLEM      129

#endif  // _LODCTR_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\makefile.inc ===
copyfiles:
!if "$(_NTTREE)" != ""
	xcopy /yvirfd export $(_NTTREE)\staxpt\export\inc
!endif
!if "$(_NTTREE_NO_SPLIT)" != ""
	xcopy /yvirfd export $(_NTTREE_NO_SPLIT)\staxpt\export\inc
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\mapctxt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mapctxt.h

Abstract:

    Declaration of map context struct

Revision History:

--*/

#ifndef	_MAPCTXT_H_
#define	_MAPCTXT_H_

//
//	Each service must initialize and pass a SERVICE_MAPPING_CONTEXT
//	to Initialize() if it wants to do client-cert mapping. This context
//	contains a callback that knows how to return the mapper objects
//	for a given instance.
//

typedef struct _SERVICE_MAPPING_CONTEXT
{
	BOOL (WINAPI * ServerSupportFunction) (
		PVOID pInstance,
		PVOID pData,
		DWORD dwPropId
	);
	
} SERVICE_MAPPING_CONTEXT, *PSERVICE_MAPPING_CONTEXT;

#define	SIMSSL_PROPERTY_MTCERT11				1000
#define SIMSSL_PROPERTY_MTCERTW					1001
#define SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED		1002
#define SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED		1003
#define SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED	1004
#define SIMSSL_NOTIFY_MAPPER_CERT11_TOUCHED		1005

#endif // _MAPCTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\iroleutl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       iroleutl.h
//
//  Contents:   Definitions of utility stuff for use with Compound Document
//              objects.
//
//  Classes:
//                  CStaticClassFactory
//                  CDynamicClassFactory
//
//  Functions:
//
//  Macros:
//
//  History:    26-Feb-96    SSanu    adapted from Forms stuff
//----------------------------------------------------------------------------

#ifndef _IROLEUTL_HXX_
#define _IROLEUTL_HXX_

//---------------------------------------------------------------
//  SCODE and HRESULT macros
//---------------------------------------------------------------

#define OK(r)       (SUCCEEDED(r))
#define NOTOK(r)    (FAILED(r))


// {9AAB0270-7181-11cf-BE7A-00AA00577DD6}
DEFINE_GUID(CLSID_IndexNotify, 0x9aab0270, 0x7181, 0x11cf, 0xbe, 0x7a, 0x0, 0xaa, 0x0, 0x57, 0x7d, 0xd6); 
// 

// {991adb50-b7f1-11cf-86e3-00aa00b4e1b8}
DEFINE_GUID(CLSID_DSSNotify, 0x991adb50, 0xb7f1, 0x11cf, 0x86, 0xe3, 0x0, 0xaa, 0x0, 0xb4, 0xe1, 0xb8);
//

STDAPI _DllRegisterServer(HINSTANCE hInst, LPSTR lpszProgId, REFCLSID clsid);
STDAPI _DllUnregisterServer(LPSTR lpszProgID, REFCLSID clsid);

//---------------------------------------------------------------
//  IUnknown
//---------------------------------------------------------------


#define IRIncrement(__ul) InterlockedIncrement((long *) &__ul)
#define IRDecrement(__ul) InterlockedDecrement((long *) &__ul)



#define DECLARE_IR_IUNKNOWN_METHODS                              \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);          \
    STDMETHOD_(ULONG, AddRef) (void);                               \
    STDMETHOD_(ULONG, Release) (void);

#define DECLARE_IR_APTTHREAD_IUNKNOWN                        \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);          \
    ULONG _ulRefs;                                                  \
    STDMETHOD_(ULONG, AddRef) (void)                                \
        {                                                           \
            return ++_ulRefs;                                         \
        }                                                           \
    STDMETHOD_(ULONG, Release) (void)                               \
        {                                                           \
            if (!--_ulRefs)                           \
            {                                                       \
                delete this;                                        \
                return 0;                                           \
            }                                                       \
            return _ulRefs;                                         \
        }



#define DECLARE_IR_STANDARD_IUNKNOWN(cls)                        \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);          \
    ULONG _ulRefs;                                                  \
    STDMETHOD_(ULONG, AddRef) (void)                                \
        {                                                           \
            IRIncrement(_ulRefs);                                \
            return _ulRefs;                                         \
        }                                                           \
    STDMETHOD_(ULONG, Release) (void)                               \
        {                                                           \
            if (!IRDecrement(_ulRefs))                           \
            {                                                       \
                IRIncrement(_ulRefs);                            \
                delete this;                                        \
                return 0;                                           \
            }                                                       \
            return _ulRefs;                                         \
        }



//+---------------------------------------------------------------------
//
//  Miscellaneous useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

#if DBG == 1

STDAPI  CheckAndReturnResult(
                HRESULT hr,
                LPSTR   lpstrFile,
                UINT    line,
                int     cSuccess,
                ...);

STDAPI_(void)   CheckResult(HRESULT hr, LPSTR lpstrFile, UINT line);
STDAPI_(void)   PrintIID(DWORD dwFlags, REFIID riid);
STDAPI          PrintHRESULT(DWORD dwFlags, HRESULT hr);

#define SRETURN(hr) \
    return CheckAndReturnResult((hr), __FILE__, __LINE__, -1)
#define RRETURN(hr) \
    return CheckAndReturnResult((hr), __FILE__, __LINE__, 0)
#define RRETURN1(hr, s1) \
    return CheckAndReturnResult((hr), __FILE__, __LINE__, 1, (s1))
#define RRETURN2(hr, s1, s2) \
    return CheckAndReturnResult((hr), __FILE__, __LINE__, 2, (s1), (s2))
#define RRETURN3(hr, s1, s2, s3) \
    return CheckAndReturnResult((hr), __FILE__, __LINE__, 3, (s1), (s2), (s3))

#define WARN_ERROR(hr)  CheckResult((hr), __FILE__, __LINE__)

#define TRETURN(hr)         return PrintHRESULT(DEB_TRACE, (hr))
#define TRACEIID(iid)       PrintIID(DEB_TRACE, iid)
#define TRACEHRESULT(hr)    PrintHRESULT(DEB_TRACE, (hr))

#else   // DBG == 0

#define SRETURN(hr)                 return (hr)
#define RRETURN(hr)                 return (hr)
#define RRETURN1(hr, s1)            return (hr)
#define RRETURN2(hr, s1, s2)        return (hr)
#define RRETURN3(hr, s1, s2, s3)    return (hr)

#define WARN_ERROR(hr)

#define TRETURN(hr)     return (hr)
#define TRACEIID(iid)
#define TRACEHRESULT(hr)

#endif  // DBG


//+---------------------------------------------------------------------
//
//  Interface wrapper for tracing method invocations
//
//----------------------------------------------------------------------

#if DBG == 1

LPVOID WatchInterface(REFIID riid, LPVOID pv, LPWSTR lpstr);
#define WATCHINTERFACE(iid, p, lpstr)  WatchInterface(iid, p, lpstr)

#else   // DBG == 0

#define WATCHINTERFACE(iid, p, lpstr)  (p)

#endif  // DBG


//+---------------------------------------------------------------------
//
//  Standard IClassFactory implementation
//
//----------------------------------------------------------------------

//
// Functions to manipulate object count variable g_ulObjCount.  This variable
// is used in the implementation of DllCanUnloadNow.

inline void
INC_OBJECT_COUNT(void)
{
    extern ULONG g_ulObjCount;
    IRIncrement(g_ulObjCount);
}

inline void
DEC_OBJECT_COUNT(void)
{
    extern ULONG g_ulObjCount;
//    ASSERT(g_ulObjCount > 0);
    IRDecrement(g_ulObjCount);
}

inline ULONG
GET_OBJECT_COUNT(void)
{
    extern ULONG g_ulObjCount;
    return g_ulObjCount;
}


//+---------------------------------------------------------------
//
//  Class:      CStaticClassFactory
//
//  Purpose:    Standard implementation of a class factory object
//
//  Notes:          **************!!!!!!!!!!!!!!!!!*************
//              TAKE NOTE --- The implementation of Release on this
//              class does not perform a delete.  This is so you can
//              make the class factory a global static variable.
//              Use the CDynamicClassFactory class below for an object
//              which is not global static data.
//
//---------------------------------------------------------------

class CStaticClassFactory: public IClassFactory
{
public:
    CStaticClassFactory(void) : _ulRefs(1) {};

    // IUnknown methods
    DECLARE_IR_IUNKNOWN_METHODS;

    // IClassFactory methods
    STDMETHOD(LockServer) (BOOL fLock);

    // CreateInstance is left pure virtual.

protected:
    ULONG _ulRefs;
};



//+---------------------------------------------------------------------------
//
//  Class:      CDynamicClassFactory (DYNCF)
//
//  Purpose:    Class factory which exists on the heap, and whose Release
//              method does the normal thing.
//
//  Interface:  DECLARE_IR_STANDARD_IUNKNOWN -- IUnknown methods
//
//              LockServer             -- Per IClassFactory.
//              CDynamicClassFactory             -- ctor.
//              ~CDynamicClassFactory            -- dtor.
//
//----------------------------------------------------------------------------

class CDynamicClassFactory: public IClassFactory
{
public:
    // IUnknown methods
    DECLARE_IR_STANDARD_IUNKNOWN(CDynamicClassFactory)

    // IClassFactory methods
    STDMETHOD(LockServer) (BOOL fLock);

    // CreateInstance is left pure virtual.

protected:
            CDynamicClassFactory(void);
    virtual ~CDynamicClassFactory(void);
};


#endif //__IROLEUTL_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\mostpc.h ===
/*----------------------------------------------------------------------------
    mostpc.h
        
        Header for MOS transport common constants for client & server

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        Phillich    Philippe Choquier

    History:
        02/24/94    Phillich    Created.
  --------------------------------------------------------------------------*/

#if !defined( _MOSTPC_DEFINED )

#define MSI_LEVEL2TIMEOUT   	6000
#define SESSION_GROUP_SEPARATOR	"\\"

#define _MOSTPC_DEFINED

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\isquery.h ===
#include <windows.h>
#define OLEDBVER 0x0250 // enable ICommandTree interface
#include <ole2.h>
#include <oledb.h>
#include <cmdtree.h>
#include <ntquery.h>

// the maximum number of columns that the user can request in their
// comma delimited list
#define MAX_COLUMNS 6
#define MAX_FRIENDLYNAME 128

typedef HRESULT
(STDAPICALLTYPE *PCIMAKEICOMMAND)(ICommand **           ppQuery,
                          ULONG                 cScope,
                          DWORD const *         aDepths,
                          WCHAR const * const * awcsScope,
                          WCHAR const * const * awcsCat,
                          WCHAR const * const * awcsMachine );

typedef HRESULT
(STDAPICALLTYPE *PCITEXTTOFULLTREE)(WCHAR const * pwszRestriction,
                            WCHAR const * pwszColumns,
                            WCHAR const * pwszSortColumns, // may be NULL
                            WCHAR const * pwszGroupings,   // may be NULL
                            DBCOMMANDTREE * * ppTree,
                            ULONG cProperties,
              /*optional*/  CIPROPERTYDEF * pReserved,
                            LCID LocaleID );

class CIndexServerQuery {
    public:
		// This is used to globally initalize the CIndexServerQuery classes
		// by having it load the necessary bits that it needs from Tripoli.
		// It should be called on service startup by any service which
		// expects to use CIndexServerQuery
		static HRESULT GlobalInitialize();
		// This is the global shutdown code... it should be called on service
		// shutdown
		static HRESULT GlobalShutdown();
		// constructor
        CIndexServerQuery();
        //
        // start the query going.
        //
        // arguments:
        // [in] bDeepQuery - TRUE if deep query, FALSE if shallow
        // [in] pwszQueryString - the tripoli query string
        // [in] pwszMachine - the machine to query against (NULL for localhost)
        // [in] pwszCatalog - the tripoli catalog to query against (name or
        //                    path is okay).
        // [in] pwszScope - the tripoli scope to query against.  NULL for the
        //                  default scope (\).
        // [in] pwszColumns - the columns to return.  supported columns are
        //                    filename,newsarticleid,newsgroup,newsmsgid.
        //                    note: this string gets altered internally, so
        //                    it might change from what you pass in.
        // [in] pwszSortOrder - sort priority for the columns.  NULL to return
        //                      unsorted
        //
        HRESULT MakeQuery( BOOL bDeepQuery, WCHAR const *pwszQueryString,
            WCHAR const *pwszMachine, WCHAR const *pwszCatalog,
            WCHAR const *pwszScope, WCHAR *pwszColumns, WCHAR const *pwszSortOrder,
			LCID LocaleID = GetSystemDefaultLCID(), DWORD cMaxRows = 0);
        //
        // get the results from the query
        //
        // arguments:
        // [in] pcResults - pointer to the a size of the ppvResults array
        // [out] pcResults - the number of items put into ppvResults
        // [in/out] ppvResults - an array of pointers to PROPVARIANTS.  this is
        //                       filled in by column for up to *pcResults
        //                       rows.
        // [out] pfMore - set to TRUE if there are more results, FALSE if
        //                this is the last set of results.
        //
        // usage:
        // DWORD cResults;
        // PROPVARIANT *rgpvResults[COLUMNS * ROWS];
        // BOOL fMore;
        // cResults = ROWS;
        // HRESULT hr;
        // hr = GetQueryResults(&cResults, rgpvResults, &fMore);
        // if (FAILED(hr)) /* handle error */
        // else {
        //    for (i = 0; i < ROWS; i++) {
        //       PROPVARIANT **ppvColumn = rgpvResults + (j * ROWS);
        //       /* ppvColumn[0] has column 0 in row j */
        //       /* ppvColumn[1] has column 1 in row j */
        //       /* etc... */
        //    }
        // }
        //
        HRESULT GetQueryResults(DWORD *pcResults, PROPVARIANT **ppvResults,
                                BOOL *pfMore);
        ~CIndexServerQuery();

    private:
		// class globals
		static HMODULE				m_hmQuery;
		static PCIMAKEICOMMAND		m_pfnCIMakeICommand;
		static PCITEXTTOFULLTREE	m_pfnCITextToFullTree;
		
		// class variables
        HACCESSOR       			m_hAccessor;
        IRowset         			*m_pRowset;
        DWORD           			m_cCols;
        BOOL            			m_fNoMoreRows;
        HROW            			*m_phRows;
        DBCOUNTITEM       			m_cRowHandlesAllocated;
        DBCOUNTITEM        			m_cRowHandlesInUse;
		struct tagCIPROPERTYDEF		*m_pPropDef;
		DWORD						m_cPropDef;

        HRESULT CreateAccessor(WCHAR *szColumns);
		HRESULT BuildFriendlyNames(const WCHAR *pwszQueryString);
        void ReleaseAccessor();
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\norminfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetinfo.h

Abstract:

    This file contains the internet info server admin APIs.
	Added Normandy specific stuff.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

    Madana      10-Oct-1995  Made a new copy for product split from inetasrv.h
    MuraliK     12-Oct-1995  Fixes to support product split
    MuraliK     15-Nov-1995  Support Wide Char interface names

--*/

#ifndef _NORMINFO_H_
#define _NORMINFO_H_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  NNTP specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define NNTP_SERVICE_NAME        TEXT("NNTPSVC")
# define NNTP_SERVICE_NAME_A      "NNTPSVC"
# define NNTP_SERVICE_NAME_W      L"NNTPSVC"

//
//   Client Interface Name for RPC connections over named pipes
//

# define  NNTP_INTERFACE_NAME     NNTP_SERVICE_NAME
# define  NNTP_NAMED_PIPE         TEXT("\\PIPE\\") ## NNTP_INTERFACE_NAME
# define  NNTP_NAMED_PIPE_W       L"\\PIPE\\" ## NNTP_SERVICE_NAME_W

//
//	Service location stuff
//
#define INET_NNTP_SVCLOC_ID         (ULONGLONG)(0x0000000000000008)

#if 0
#define METACACHE_NNTP_SERVER_ID                 3
#define METACACHE_SMTP_SERVER_ID                 4
#define METACACHE_POP3_SERVER_ID                 5
#define METACACHE_IMAP_SERVER_ID                 6
#endif

#endif	// _NORMINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\moscl.h ===
/*----------------------------------------------------------------------------
    moscl.h
        
        Header for MOS client side API

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        Phillich    Philippe Choquier

    History:
        08/12/93    Phillich    Created.
  --------------------------------------------------------------------------*/

#if !defined(_MOSCL_DEFINED)

#include <servdefs.h>
#include <mostpc.h>

#if defined(__cplusplus)
extern "C" {
#endif

#if !defined(MOSDllImport)
#if defined(WIN32)
#define MOSDllImport(a) __declspec( dllimport ) a
#define MOSDllExport(a) __declspec( dllexport ) a
#else 
#define MOSDllExport(a) a __export
#define MOSDllImport(a) a __import
#endif
#endif

#if !defined(_MHANDLE_DEFINED)
typedef WORD MHANDLE;
typedef WORD HMCONNECT;
typedef HMCONNECT *PHMCONNECT;
typedef WORD HMSESSION;
typedef HMSESSION *PHMSESSION;
typedef WORD HMPIPE;
typedef HMPIPE *PHMPIPE;
#define _MHANDLE_DEFINED
#endif

#define INVALID_MOS_HANDLE_VALUE        ((MHANDLE)0xffff)
#define MOS_IO_ERROR                    0xffff

#define MOS_WRITE_PENDING                    0xfffffffe

typedef struct _MC_CONNECT_CB {
    WORD cSizeStructure;
    WORD Type;
    DWORD ComPort;
    DWORD BaudRate;
    DWORD dwOptions;
	WORD SpeakerMode;
	WORD wReserved;
    } MC_CONNECT_CB;

// for dwOptions

#define MOS_CONNECT_DISABLE_DATA_COMPRESSION	1
#define MOS_CONNECT_DISABLE_ERROR_CORRECTION	2
#define MOS_CONNECT_LAUNCH_LIGHTS				4
#define MOS_DONT_SET_DCEDTE_SPEED				8

enum MOS_SPEAKERMODE { MOS_SPEAKERALWAYSOFF, MOS_SPEAKERONUNTILCONNECT, MOS_SPEAKERALWAYSON, MOS_SPEAKEROFFWHILEDIALING }; 

enum MOS_CONNECT_TYPE {
    MOS_CONNECT_MODEM,
    MOS_CONNECT_ISDN,
    MOS_CONNECT_PIPE,
    MOS_CONNECT_EICON,
    MOS_CONNECT_EXISTING,
    MOS_CONNECT_INVALID,
    MOS_CONNECT_UDP,
    MOS_CONNECT_TAPI,
    MOS_CONNECT_TCP
    } ;

enum MOS_EVENT {
    EVENT_BUSY,
    EVENT_NOCARRIER,
    EVENT_CONNECTED,
    EVENT_NODIALTONE,
    EVENT_USER_CLOSED,
    EVENT_START_RECEIVE_DATA,
    EVENT_END_RECEIVE_DATA,
    EVENT_START_XMIT_DATA,
    EVENT_END_XMIT_DATA,
    EVENT_CRC_ERROR,
    EVENT_CONNECTION_DROPPED,
    EVENT_WRITE_ERROR,
    EVENT_NO_EVENT,
    EVENT_DATALINK,
    EVENT_SPEED_1200,
    EVENT_SPEED_2400,
    EVENT_SPEED_4800,
    EVENT_SPEED_9600,
    EVENT_SPEED_12000,
    EVENT_SPEED_14400,
    EVENT_SPEED_16800,
    EVENT_SPEED_19200,
    EVENT_SPEED_21600,
    EVENT_SPEED_24400,
    EVENT_SPEED_26400,
    EVENT_SPEED_28800,
    EVENT_SPEED_57600,
    EVENT_OPEN_ERROR,       // can't open communication device
	EVENT_SPEED,
	EVENT_UNREACHABLE_NETWORK_ADDRESS,
	EVENT_ACTIVE,
	EVENT_CAUSE_TOO_MANY_RCV_ERROR,
	EVENT_CAUSE_TOO_MANY_XM_ERROR,
	EVENT_PAD_DISCONNECT,
	EVENT_CAUSE_UNAVAIL,
	EVENT_SVCCONNECT_DONE,
	EVENT_RAS_AUTH_START,
	EVENT_RAS_AUTH_FAILED,
	EVENT_RAS_ERROR,
	EVENT_RAS_DIALSTART_PRIMARY,
	EVENT_RAS_DIALSTART_BACKUP,
	EVENT_TCPINSTALL_ERROR,
	EVENT_TCPCONNECT_START,
	EVENT_TCPCONNECT_RETRY,
	EVENT_TCPCONNECT_FAILED,
	EVENT_DNSLOOKUP,
	EVENT_DNSLOOKUP_FAILED,
	EVENT_LOCKEDACCOUNT,
	EVENT_INVALIDPASSWORD,
	EVENT_PPPRANDOMFAILURE,
	EVENT_RAS_REMOTE_DISCONNECTION,
	EVENT_RAS_NOCARRIER,
	EVENT_RAS_BADTCPCONFIG,
	EVENT_PROXYCONNECT_START,
	EVENT_PROXYCONNECT_FAILED,
	EVENT_PROXYAUTH_START,
	EVENT_PROXYAUTH_FAILED,
	EVENT_PROXY_DISCOVERY_START,
	EVENT_PROXY_DISCOVERY_FAILED,
	EVENT_PROXY_ALTCONNECT_START,
	EVENT_PROXY_RESOURCE_FAILURE,
	EVENT_PROXY_GENERIC_FAILURE,
	EVENT_PROXY_PROTOCOL_MISMATCH,
	EVENT_PROXY_BAD_SETTINGS,
	EVENT_PROXY_BAD_VERSION,
	EVENT_PPP_TIMEOUT,
    } ;

#define SERVER_NAME_MAX_LEN (30)
#define SERVICE_NAME_MAX_LEN (256)
#define IPADDRESS_MAX_LEN (30)
#define MOSCL_ATTACH_TIMEOUT	(15 * 1000)

#define MOSADDR_CANONIC		1
#define MOSADDR_DIALABLE	2
#define MOSADDR_WANADDR		3
#define MOSADDR_CARRIERID	4
#define MOSADDR_COUNTRYCODE	5
#define MOSADDR_AREACODE	6
#define MOSADDR_MODEMNAME	7
#define MOSADDR_CONNECTMODE	8

// Maximum Message Size
#define MSI_MAXMSGSIZE      (12*1024)

#define GMS_MAXMSGSIZE      1
#define GMS_LEVEL2TIMEOUT   2

typedef void (CALLBACK *MC_CONNECT_NOTIFY)(LPVOID, HMCONNECT, WORD, DWORD);
typedef void (CALLBACK *MP_READ_NOTIFY)(LPVOID, HMPIPE, DWORD);
typedef void (CALLBACK *MP_WRITE_NOTIFY)(LPVOID, HMPIPE, LPVOID, DWORD);
typedef void (CALLBACK *MP_OPEN_NOTIFY)(LPVOID, HMPIPE, WORD );

#if defined(WIN32)
MOSDllExport(BOOL WINAPI)               InitMOS( HINSTANCE, WORD );
#else
MOSDllExport(BOOL WINAPI)               InitMOS( HINSTANCE );
#endif
MOSDllExport(BOOL WINAPI)               TerminateMOS();
MOSDllExport(WORD WINAPI)               GetMOSConnectionStatus(HMCONNECT);
MOSDllExport(HMCONNECT WINAPI)          OpenMOSConnection(LPSTR,MC_CONNECT_NOTIFY,LPVOID,MC_CONNECT_CB FAR*);
MOSDllExport(BOOL WINAPI)               CloseMOSConnection(HMCONNECT);
MOSDllExport(HMSESSION WINAPI)          OpenMOSSession(HMCONNECT, LPSTR);
MOSDllExport(HMSESSION WINAPI)          OpenMOSSessionEx(HMCONNECT, LPSTR, SERVICE_VERSION );
MOSDllExport(BOOL WINAPI)               CloseMOSSession(HMSESSION);
MOSDllExport(HMPIPE WINAPI)             OpenMOSPipe(HMSESSION, LPSTR);
MOSDllExport(HMPIPE WINAPI)             OpenMOSPipeEx(HMSESSION, LPSTR, LPSTR);
MOSDllExport(BOOL WINAPI)               CloseMOSPipe(HMPIPE);
MOSDllExport(DWORD WINAPI)              ReadMOSPipe(HMPIPE, LPVOID, DWORD, WORD);
MOSDllExport(DWORD WINAPI)              WriteMOSPipe(HMPIPE, LPVOID, LPVOID, DWORD, BOOL);
MOSDllExport(MP_READ_NOTIFY WINAPI)     SetMOSPipeReadNotify(HMPIPE, MP_READ_NOTIFY, LPVOID);
MOSDllExport(MP_WRITE_NOTIFY WINAPI)    SetMOSPipeWriteNotify(HMPIPE, MP_WRITE_NOTIFY);
MOSDllExport(WORD WINAPI)               GetMOSLastError(HMCONNECT);
MOSDllExport(DWORD WINAPI)              GetMOSPipeReadSize(HMPIPE hmp, WORD );
MOSDllExport(DWORD WINAPI)              GetMOSSysInfo( HMCONNECT hmC, WORD wType );
MOSDllExport(HMPIPE WINAPI) 			OpenMOSPipeWithNotify(HMSESSION hms, LPSTR Name,
												LPSTR Param, MP_READ_NOTIFY r, LPVOID u, 
												MP_WRITE_NOTIFY );
MOSDllExport(HMPIPE WINAPI) 			OpenMOSPipeWithNotifyEx(HMSESSION hms, LPSTR Name,
												LPSTR Param, MP_READ_NOTIFY r, LPVOID u, 
												MP_WRITE_NOTIFY, SERVICE_VERSION sv );
MOSDllExport(HMPIPE WINAPI) 			OpenMOSPipeWithNotifyAndTimeoutEx(HMSESSION hms, LPSTR Name,
												LPSTR Param, MP_READ_NOTIFY r, LPVOID u, 
												MP_WRITE_NOTIFY, SERVICE_VERSION sv, DWORD dwT, MP_OPEN_NOTIFY pON );

#define OpenMOSPipeWithReadNotify(a,b,c,d,e) OpenMOSPipeWithNotify(a,b,c,d,e,NULL)
#if defined(__cplusplus)
}
#endif

// MOS error values
#define MOSERROR_FAILED			(-1)	  		// operation failed (reason unknown).
#define MOSERROR_SUCCESS		(0)				// operation successful.

#define MOSERROR_TIMEOUT        (1)
#define MOSERROR_IO_PENDING     (2)             // Overlapped IO operation in progress.
#define MOSERROR_IO_BUSY        (3)             // Synchronous operation in progress.
#define MOSERROR_INVALID_CONNECTION_HANDLE      (4)
#define MOSERROR_INVALID_SESSION_HANDLE (5)
#define MOSERROR_INVALID_PIPE_HANDLE    (6)
#define MOSERROR_PIPE_IS_CLOSING        (7)

#define MOSERROR_OPENING_ARENA (8)              // An error occured while trying to OpenSharedArena().
#define MOSERROR_ASYNC_WRITE_NO_CALLBACK (9)    // Cannot perform async write without first defining a callback function.
#define MOSERROR_ARENA_NOTHING_DURING_READ (10) // A call to GetFirstFromList() returned ARENA_NOTHING.
#define MOSERROR_ADDTOLIST_RET_FALSE (11)       // A call to AddToList() returned FALSE for some reason.
#define MOSERROR_PIPE_NOT_FOUND (12)

//#define MOSERROR_BUFFER_TOO_SMALL (13)      // The specified buffer was too small for the data to be returned in.
//#define MOSERROR_SERVICE_NOT_FOUND (14)     // The specified Service could not be found.
//#define MOSERROR_OVERLAPPED_BUFFERS (15)        // One or more of the specified buffers are overlapped.
//#define MOSERROR_RPC_FAILED (16)                        // An RPC call failed.

//#define MOSERROR_BILLING_DOWNLOAD_ALREADY_ACTIVE (17)   // Can't start download session event when existing session in progress.
//#define MOSERROR_BILLING_DOWNLOAD_NOT_ACTIVE (18)       // Can't ask for next or prev event when no download in progress.
//#define MOSERROR_BILLING_DOWNLOAD_INVALID_HANDLE (19)	// An invalid download session handle was specified.
//#define MOSERROR_BILLING_DOWNLOAD_INVALID_COMMAND (20)	// An invalid download command was specified.
//#define MOSERROR_ERROR_ACCESSING_LOGFILE (21)           // There was an error accessing the billing logfile.
#define MOSERROR_MSGSIZETOOBIG (22)                 // Message Size Too Big for WriteMOSPipe.

//#define MOSERROR_ERROR_SERIALIZING (23)		// An error occurred while a C++ object attempted to serialize itself.
//#define MOSERROR_ERROR_DESERIALIZING (24)	// An error occurred while a C++ object attempted to deserialize itself.
#define MOSERROR_INVALID_CONNECTION_TYPE    (25)    // InitMOS() & OpenMOSConnection mismatch

#define MOSERROR_MORE_DATA (26)	// Fitting # of logs are returned in the buffer, but more data is available still.
#define MOSERROR_INVALID_PARAMETER    (27)
#define MOSERROR_OUT_OF_RESOURCE	(28)
#define MOSERROR_ATTACH_REJECT		(29)
#define MOSERROR_NO_ACCESS			(30)
#define MOSERROR_LOCATE_REJECT		(31)
#define MOSERROR_SERVER_REJECT		(32)
#define MOSERROR_SERVICE_VERSION_MISMATCH	(33)
#define MOSERROR_TOO_MANY_PIPES		(34)
#define MOSERROR_PIPE_IS_NOTOPENED	(35)
#define MOSERROR_NO_ACCESS_ON_TOLL_FREE		(36)
#define MOSERROR_GET_RIGHTS_TIMEOUT		(37)

#define _MOSCL_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\ntlmsspi.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (c) 1993 Microsoft Corporation
//
//  File:       ntlmsspi.h
//
//  Contents:	Header file describing the interface to code common to the NT
//				Lanman Security Support Provider (NtLmSsp) Service and the DLL.
//
//  History:    SudK    Created     6/22/95
//
//----------------------------------------------------------------------------

#ifndef _SICILY_NTLMSSPI_INCLUDED_
#define _SICILY_NTLMSSPI_INCLUDED_


#define MSV1_0_CHALLENGE_LENGTH     8
    
//
// Maximum lifetime of a context
//
#define NTLMSSP_MAX_LIFETIME (2L*60L*1000L)    // 2 minutes

////////////////////////////////////////////////////////////////////////
//
// Opaque Messages passed between client and server
//
////////////////////////////////////////////////////////////////////////

#define NTLMSSP_SIGNATURE "NTLMSSP"
#define NTLMSSP_SIGN_VERSION   1

//
// MessageType for the following messages.
//

#ifndef WIN16_BUILD

typedef enum {
    NtLmNegotiate = 1,
    NtLmChallenge,
    NtLmAuthenticate,
	NtLmRedirect
} NTLM_MESSAGE_TYPE;

#else

#define NtLmNegotiate 1
#define NtLmChallenge 2
#define NtLmAuthenticate 3
#define NtLmRedirect 4

typedef long NTLM_MESSAGE_TYPE;

#endif // WIN16_BUILD

//
// Valid values of NegotiateFlags
//

#define NTLMSSP_NEGOTIATE_UNICODE    0x0001  // Text strings are in unicode
#define NTLMSSP_NEGOTIATE_OEM        0x0002  // Text strings are in OEM
#define NTLMSSP_REQUEST_TARGET       0x0004  // Server should return its
                                             // authentication realm
#define NTLMSSP_NEGOTIATE_SIGN        0x0010  // Request signature capability
#define NTLMSSP_NEGOTIATE_SEAL        0x0020  // Request confidentiality
#define NTLMSSP_RESERVED              0x0040  // reserved for past use
#define NTLMSSP_NEGOTIATE_LM_KEY      0x0080  // Use LM session key for sign/seal

#define NTLMSSP_NEGOTIATE_NETWARE    0x0100  // NetWare authentication
#define NTLMSSP_NEGOTIATE_NTLM       0x0200  // NTLM authentication

#define NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED  0x1000  // Domain Name supplied on negotiate
#define NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED  0x2000  // Workstation Name supplied on negotiate
#define NTLMSSP_NEGOTIATE_LOCAL_CALL  0x4000 // Indicates client/server are same machine
#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN 0x8000 // Sign for all security levels


//
// Valid target types returned by the server in Negotiate Flags
//

#define NTLMSSP_TARGET_TYPE_DOMAIN 0x10000  // TargetName is a domain name
#define NTLMSSP_TARGET_TYPE_SERVER 0x20000  // TargetName is a server name
#define NTLMSSP_TARGET_TYPE_SHARE  0x40000  // TargetName is a share name

//
// Opaque message returned from first call to InitializeSecurityContext
//

#define SIC_MIN_STR_SIZE            sizeof(ULONG)
#define MSAP_EXTRA_STR_SIZE(nn)     \
                        ((nn > SIC_MIN_STR_SIZE) ? nn - SIC_MIN_STR_SIZE : 0)

// New Sicily 2.0 Negotiate message
//
typedef struct _SIC20_NEGOTIATE_MSG {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    ULONG NegotiateFlags;
    STRING OemDomainName;
    STRING OemWorkstationName;

    // Reserved for future Sicily enhancement

    ULONG  Reserved1;                   // for future multiple realm support
    ULONG  Reserved2;                   // for future multiple realm support
    CHAR   Reserved3[SIC_MIN_STR_SIZE]; // for future multiple realm support

} SIC20_NEGOTIATE_MSG, *PSIC20_NEGOTIATE_MSG;


typedef struct _NEGOTIATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    ULONG NegotiateFlags;
    STRING OemDomainName;
    STRING OemWorkstationName;
} NEGOTIATE_MESSAGE, *PNEGOTIATE_MESSAGE;


//
// Old version of the message, for old clients
//

typedef struct _OLD_NEGOTIATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    ULONG NegotiateFlags;
} OLD_NEGOTIATE_MESSAGE, *POLD_NEGOTIATE_MESSAGE;

//
// Opaque message returned from first call to AcceptSecurityContext
//
typedef struct _SIC20_CHALLENGE_MSG {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
    ULONG ServerContextHandleLower;
    ULONG ServerContextHandleUpper;

    // Reserved for future Sicily enhancement

    ULONG  Reserved1;       // for future multiple realm support
    ULONG  Reserved2;       // for future multiple realm support
    ULONG  RealmListSize;   // list of comma seperated realms which server has

    //  ServerRealms consists of multiple Null terminated strings, each 
    //  represent a realm. This list is terminated by 2 Null characters.
    //  For now, this only has one realm
    //
    CHAR   ServerRealms[SIC_MIN_STR_SIZE]; 

} SIC20_CHALLENGE_MSG, *PSIC20_CHALLENGE_MSG;

typedef struct _CHALLENGE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
    ULONG ServerContextHandleLower;
    ULONG ServerContextHandleUpper;
} CHALLENGE_MESSAGE, *PCHALLENGE_MESSAGE;

//
// Old version of the challenge message
//

typedef struct _OLD_CHALLENGE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
} OLD_CHALLENGE_MESSAGE, *POLD_CHALLENGE_MESSAGE;

//
// Opaque message returned from second call to InitializeSecurityContext
//
typedef struct SIC20_AUTHENTICATE_MSG {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING LmChallengeResponse;
    STRING NtChallengeResponse;
    STRING DomainName;
    STRING UserName;
    STRING Workstation;
    STRING Challenge;       // This must be the last field for ease of 
                            // backward compatibility
} SIC20_AUTHENTICATE_MSG, *PSIC20_AUTHENTICATE_MSG;

typedef struct _AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING LmChallengeResponse;
    STRING NtChallengeResponse;
    STRING DomainName;
    STRING UserName;
    STRING Workstation;
} AUTHENTICATE_MESSAGE, *PAUTHENTICATE_MESSAGE;

//
// Opaque message sent by SSL ISAPI extension which forces the SSPI to
// reuse the supplied credential handle, which was previously created 
// through the accept security context API's.
//

typedef struct _REDIRECT_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
	BYTE KeyData[4];
	CredHandle OriginalHandle;
} REDIRECT_MESSAGE, *PREDIRECT_MESSAGE;

//
// Size of the largest message
//  (The largest message is the AUTHENTICATE_MESSAGE)
//

#define DNLEN_SICILY 15

#define NTLMSSP_MAX_MESSAGE_SIZE (sizeof(AUTHENTICATE_MESSAGE) + \
                                  LM_RESPONSE_LENGTH +           \
                                  NT_RESPONSE_LENGTH +           \
                                  (DNLEN_SICILY + 1) * sizeof(WCHAR) +  \
                                  (MAX_PATH + 1) * sizeof(WCHAR) +  \
                                  (MAX_PATH + 1) * sizeof(WCHAR))

#ifdef MAC
#define swaplongtype(Value,Type) \
      	  Value =  (Type)(  ((((long)Value) & 0xFF000000) >> 24) \
             | ((((long)Value) & 0x00FF0000) >> 8) \
             | ((((long)Value) & 0x0000FF00) << 8) \
             | ((((long)Value) & 0x000000FF) << 24))
#else
#define swaplongtype(value,type)
#endif

#ifdef MAC
#define swaplong(Value) \
      	  Value =  (  (((Value) & 0xFF000000) >> 24) \
             | (((Value) & 0x00FF0000) >> 8) \
             | (((Value) & 0x0000FF00) << 8) \
             | (((Value) & 0x000000FF) << 24))
#else
#define swaplong(Value)
#endif

#ifdef MAC
#define swapshort(Value) \
   Value = (  (((Value) & 0x00FF) << 8) \
             | (((Value) & 0xFF00) >> 8))
#else
#define swapshort(Value)
#endif


#endif // ifndef _SICILY_NTLMSSPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\msnsspi.h ===
//-------------------------------------------------------------
//
//  Module:     msnsspi.h
// 
//  Contents:   Functions that are supported in private version of
//              SSPI provider within the MSN data center for Sicily
//
//  History:    10/10/95    SudK    Created
//
//-------------------------------------------------------------

#ifndef _MSN_SSPI_H_
#define _MSN_SSPI_H_

#include <dbsqltyp.h>

#define MSN_REQ_EXTENDED_ERROR_CODE     0x01

//
// Signature structure
//
typedef struct _NTLMSSP_MESSAGE_SIGNATURE {
    ULONG   Version;
    ULONG   RandomPad;
    ULONG   CheckSum;
    ULONG   Nonce;
} NTLMSSP_MESSAGE_SIGNATURE, * PNTLMSSP_MESSAGE_SIGNATURE;

#define NTLMSSP_MESSAGE_SIGNATURE_SIZE sizeof(NTLMSSP_MESSAGE_SIGNATURE)

SECURITY_STATUS SEC_ENTRY
GetHACCT(  
    PCtxtHandle         phContext,
    HACCT               *phAcct
);

SECURITY_STATUS SEC_ENTRY
MSNGetUserName(
    PCtxtHandle     ContextHandle,
    PCHAR           lpszUserName,
    DWORD           *pcbBytes
);

SECURITY_STATUS SEC_ENTRY
SetMSNSecurityOptions(
    PCtxtHandle         phContext,
    UINT                Flags
);

UINT SEC_ENTRY
GetMSNExtendedError(
    PCtxtHandle         phContext
);    

BOOL SEC_ENTRY
SetMSNAccountInfo (
    LPSTR pUsername, 
    LPSTR pPassword
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\packoff.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack()
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\packon.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\pbag.cpp ===
//
// pbag.cpp
//


#include "pbag.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPropBag::Read(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog* pErrorLog)
{
	HRESULT hr = S_OK;
    BAGMAP::iterator pFind;

    pFind = m_map.find(pszPropName);

    if (pFind != m_map.end())
		 VariantCopy(pVar, &(*pFind).second);
    else 
		 hr = E_FAIL;
    return hr;
}

STDMETHODIMP CPropBag::Write( LPCOLESTR pszPropName, VARIANT* pVar ) 
{
	HRESULT hr = S_OK;

    try
    {
        pair<BAGMAP::iterator, bool> pr;
        
        pr = m_map.insert(BAGMAP::value_type(pszPropName, *pVar));

        if (!pr.second)     // couldn't insert (someone's there)
            VariantCopy(&(*pr.first).second, pVar);
    }
    catch(...)
    {
        return E_OUTOFMEMORY;
    }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\mtlib.h ===
/*++

	This header file exists to provide templates which support
	mutlithreaded software servers.

--*/



#include	<windows.h>
#include	"lockq.h"
#include	"smartptr.h"

#ifndef	_MTLIB_H_
#define	_MTLIB_H_


class	CStateStackInterface :	public	CRefCount	{
	//
	//	This class defines a pure virtual interface used
	//	to allocate memory for CCallState objects.
	//
public : 

	enum	STACK_CONSTANTS	{
		MAX_STACK_RESERVE	= 4096
	} ;

	//
	//	Initialize the stack !
	//
	virtual	BOOL
	Init( DWORD	cbReserve ) = 0 ;

	//
	//	Allocate bytes for the object
	//
	virtual	LPVOID
	Allocate( DWORD	cb ) = 0 ;

	//
	//	Release the bytes associated with the object
	//
	virtual	BOOL
	Release( LPVOID	lpvState ) = 0 ;

	//
	//	Provide virtual do nothing destructor.
	//
	virtual
	~CStateStackInterface()	{
	}

} ;

typedef	CRefPtr<	CStateStackInterface >	STACKPTR ;

//
//	This is just a definition of this symbol which
//	is used to implement these stack objects but otherwise
//	is hidden from clients !
//
class	CStateStackBase ;

//
//	A Smart Pointer TYPE for CStateStackBase objects !
//
typedef	CRefPtr<	CStateStackBase >	STACKBPTR ;

class	CStateStack : public	CStateStackInterface	{
/*++

	This is the object that users should instantiate when 
	they are ready to be allocating memory from these stack objects !

--*/
private :
	
	//
	//	Signature for recognizing these stacks in memory
	//
	DWORD	m_dwSignature ; 

	//
	//	Points to the object we delegate all operations to.
	//	This is really the top of a stack of such objects !
	//
	STACKBPTR	m_pImp ;

	//
	//	Push a CStateStackBase derived object onto our stack
	//	that can handle the next allocation !
	//
	BOOL
	NewStack(	DWORD	cbReserve ) ;

	//
	//	Copy construction not allowed !
	//
	CStateStack( CStateStack& ) ;
	
	
public : 

	//
	//	We have do nothing Constructor and Destructors - however
	//	we declare and define them so that the STACKBPTR type 
	//	is only referenced in the mtserver library.
	//
	CStateStack() ;
	~CStateStack() ;

	//
	//	Prepare the initial stack 
	//
	BOOL
	Init( DWORD	cbReserve ) ; 
		
	//
	//	Allocate bytes for the object
	//
	LPVOID
	Allocate( DWORD	cb ) ;
	//
	//	Release the bytes associated with the object
	//
	BOOL
	Release( LPVOID	lpvState ) ;

} ;


class	CCall	: public	CQElement	{
//
//	This class defines a base class for Call Objects created with
//	the TMFnCallAndCompletion objects. 
//	This base class will provide for memory management of Call Objects.
//
private : 

	//
	//	Do Nothing Constructor is private - everybody has 
	//	to provide args to constructor !
	//
	CCall() ;

	//
	//	Signature for these things !
	//
	DWORD	m_dwSignature ;

	//
	//	This is a reference to the allocator that should be used
	//	to create all Child CCallState objects of this one !
	//
	CStateStackInterface&	m_Allocator ;

protected : 

	//
	//	The only method we provide for retrieving the allocator !
	//
	CStateStackInterface&
	Allocator()	{
		return	m_Allocator ;
	}

public:	

	//	
	//	The only constructor we provide REQUIRES an allocator, 
	//	we don't take a pointer as that would let you pass a NULL!
	//
	CCall(	CStateStackInterface&	allocator	) : 
		m_dwSignature( DWORD('laCC') ),
		m_Allocator( allocator ) {

#ifdef	DEBUG
		LPVOID	lpv = this ;
		_ASSERT( *((CStateStackInterface**)lpv) = &allocator ) ;
#endif
	}
	
	//
	//	Allocate a CCallState object !
	//
	void*	
	operator	new( size_t	size, CStateStackInterface&	stack )	{

		size += sizeof( CStateStackInterface* ) ;
		LPVOID	lpv = stack.Allocate( size ) ;
		if( lpv != 0 ) {
			*((CStateStackInterface**)lpv) = &stack ;
			lpv = (LPVOID)(((CStateStackInterface**)lpv)+1) ;
		}	
		return	lpv ;
	}

	//
	//	Users are required to not use this version of operator new! - 
	//	The language doesn't let us hide it - so it will DebugBreak()
	//	at runtime if necessary !
	//
	void*
	operator	new(	size_t	size )	{
		DebugBreak() ;
		return	0 ;
	}

	//
	//	Free a CCallState derived object !
	//
	void
	operator	delete(	void*	lpv )	{
		if( lpv != 0 ) {
			CStateStackInterface*	pStack = ((CStateStackInterface**)lpv)[-1] ;
			lpv = (LPVOID)(((CStateStackInterface**)lpv)-1) ;
			pStack->Release( lpv ) ;
		}
	}
} ;





template<	class	RESULT	>	
class	TCompletion	{
//
//	This template defines an interface for Completion
//	objects which have a Virtual Function taking a 
//	particular kind of result.
//
public : 

	//
	//	One pure virtual function which gets the results !
	//
	virtual	void	
	Complete(	RESULT&	result ) = 0 ;

	//
	//	This function is called when the request is unable to be
	//	completed for whatever reason (most likely, we're in a 
	//	shutdown state.)
	//
	virtual	void
	ErrorComplete(	DWORD	dwReserved ) = 0 ;

	void*	
	operator	new( size_t	size, CStateStackInterface&	stack )	{

		size += sizeof( CStateStackInterface* ) ;
		LPVOID	lpv = stack.Allocate( size ) ;
		if( lpv != 0 ) {
			*((CStateStackInterface**)lpv) = &stack ;
			lpv = (LPVOID)(((CStateStackInterface**)lpv)+1) ;
		}	
		return	lpv ;
	}

	//
	//	Free a CCallState derived object !
	//
	void
	operator	delete(	void*	lpv )	{
		if( lpv != 0 ) {
			CStateStackInterface*	pStack = ((CStateStackInterface**)lpv)[-1] ;
			lpv = (LPVOID)(((CStateStackInterface**)lpv)-1) ;
			pStack->Release( lpv ) ;
		}
	}

} ;



template<	class	SERVER	>
class	ICall :	public	CCall	{
//
//	This template defines the interface to CCallState objects
//	that are to operate against SERVER's of type 'SERVER'.
//	
//	We define 2 virtual functions - ExecuteCall and CompleteCall.
//	This template only exists to provide a base class definition
//	for objects which are passed into the TMtService< SERVER >
//	QueueRequest function.
//
//	Derived Objects must manage their own destruction in a 
//	fashion which guarantees they are destroyed BEFORE the 
//	caller is notified of the completion.  This is because CCallState
//	objects are created with a memory manager that is managed
//	by the caller, which won't be in any other threads untill the
//	completion is called.
//
protected: 
	//
	//	Only derived classes are allowed to construct these things !
	//
	ICall(	CStateStackInterface&	allocator	) : 
		CCall( allocator )	{}
	
public : 

	typedef	CStateStackInterface	INITIALIZER ;

	//
	//	A return value of TRUE means that the CCallState object
	//	should be kept for a later call to CompleteCall
	//
	virtual	BOOL
	ExecuteCall(	SERVER&	server ) = 0 ;

	//
	//	This function is only called if ExecuteCall() return TRUE -
	//	indicating that all the thread safe aspects of the Execution
	//	had been completed, and that the CCallState could be called
	//	again to notify the original caller of the results.
	//
	virtual	void
	CompleteCall(	SERVER&	server ) = 0 ;

	//
	//	This function is called when we won't be given a change to 
	//	execute our request.  This occurs during shutdown for instance.
	//	dwReserved is for future use (i.e. indicate error conditions.)
	//
	virtual	void
	CancelCall(	DWORD	dwReserved ) = 0 ;

} ;


template<	class	SERVER,
			class	RESULT,
			class	ARGUMENT,
			class	BASECLASS = ICall<SERVER>
			>	
class	TMFnCall :	public	BASECLASS	{
//
//	This defines a call state object which can be passed to a TMtService<SERVER,BASECLASS>
//	The call object holds onto the arguments to which should be passed to the
//	member function of the server.
//
//	This object will call the member function and imediately complete the operation !
//
public : 
	//
	//	Define the signature of the member function we will call.
	//
	//	The member function must not have any return value.
	//
	typedef	void	(SERVER::*FUNC_SIGNATURE)( ARGUMENT, RESULT&  ) ;

	//
	//	Define the signature of the object which will handle the completion
	//	of the Async Call.
	//
	typedef	TCompletion<RESULT>	COMPLETION_OBJECT ;

private : 
	//
	//	Pointer to a member function of the server
	//
	FUNC_SIGNATURE	m_pfn ;

	//
	//	An argument for the member function of the server.
	//
	ARGUMENT		m_Arg ;

	//
	//	The object we will notify when the call completes !
	//
	COMPLETION_OBJECT*	m_pCompletion ;

public : 

	//
	//	Construct a TMFnCallAndCompletion object.
	//	We require a pointer to a function and a pointer
	//	to a Completion object.
	//	
	//
	TMFnCall(
		BASECLASS::INITIALIZER&	baseInit,
		FUNC_SIGNATURE	pfn,
		ARGUMENT		arg, 
		COMPLETION_OBJECT*	pCompletion
		) : 
		BASECLASS( baseInit ),
		m_pfn( pfn ),
		m_Arg( arg ),
		m_pCompletion( pCompletion ) {
	}

	TMFnCall(
		FUNC_SIGNATURE	pfn,
		ARGUMENT		arg, 
		COMPLETION_OBJECT*	pCompletion
		) : 
		m_pfn( pfn ),
		m_Arg( arg ),
		m_pCompletion( pCompletion ) {
	}




	//
	//	Execute the call !
	//
	//
	BOOL
	ExecuteCall(	SERVER&	server  ) {
		RESULT	results ;
		(server.*m_pfn)( m_Arg, results ) ;	

		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;

		delete	this ;

		if( pCompletion ) 
			pCompletion->Complete( results ) ;
		return	FALSE ;
	}		

	//
	//	Do nothing - no delayed completions
	//
	virtual	void
	CompleteCall(	SERVER&	server )	{
		
	}

	//
	//	Notify the caller that the call will not be executed.
	//
	void
	CancelCall(		DWORD	dwReserved )	{

		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;
		delete	this ;

		if( pCompletion ) 
			pCompletion->ErrorComplete() ;
	}

} ;



template<	class	SERVER,
			class	RESULT,
			class	ARGUMENT,
			class	BASECLASS = ICall<SERVER>
			>	
class	TMFnDelay :	public	BASECLASS	{
//
//	This defines a call state object which can be passed to a TMtService<SERVER>
//	The call object holds onto the arguments to which should be passed to the
//	member function of the server.
//
//	The main property of this object is that it can postpone calling the 
//	callers completion object until the worker thread is out of its critical
//	region !
//
public : 
	//
	//	Define the signature of the member function we will call.
	//	NOTE : the function takes references to the values !!
	//
	typedef	BOOL	(SERVER::*FUNC_SIGNATURE)( ARGUMENT&, RESULT&  ) ;

	//
	//	Define the signature of the object which will handle the completion
	//	of the Async Call.
	//
	typedef	TCompletion<RESULT>	COMPLETION_OBJECT ;

private : 
	//
	//	Pointer to a member function of the server
	//
	FUNC_SIGNATURE	m_pfn ;

	//
	//	An argument for the member function of the server.
	//
	ARGUMENT		m_Arg ;

	//
	//	Temporary to hold the results of the function
	//
	RESULT			m_Result ;

	//
	//	Pointer to the object which gets notified of the async completion.
	//
	COMPLETION_OBJECT*	m_pCompletion ;

public : 

	TMFnDelay(
		BASECLASS::INITIALIZER&	baseinit,
		FUNC_SIGNATURE	pfn,
		ARGUMENT		arg, 
		COMPLETION_OBJECT*	pCompletion
		) : 
		BASECLASS( baseinit ),
		m_pfn( pfn ),
		m_Arg( arg ),
		m_pCompletion( pCompletion ) {
	}

	TMFnDelay(
		FUNC_SIGNATURE	pfn,
		ARGUMENT		arg, 
		COMPLETION_OBJECT*	pCompletion
		) : 
		m_pfn( pfn ),
		m_Arg( arg ),
		m_pCompletion( pCompletion ) {
	}




	//
	//	Execute the call !
	//
	//	If we return TRUE, then this object will be
	//	put into a queue for a later call to CompletCall()
	//
	//
	BOOL
	ExecuteCall(	SERVER&	server  ) {
		if( (server.*m_pfn)( m_Arg, m_Result ) ) {
			return	TRUE ;
		}	

		RESULT	results = m_Result ;
		
		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;

		delete	this ;

		if( pCompletion ) 
			pCompletion->Complete( results ) ;
		return	FALSE ;
	}		

	//
	//	Destroy ourselves before invoking the completion object !
	//
	virtual	void
	CompleteCall(	SERVER&	server )	{
		RESULT	results = m_Result ;
		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;

		delete	this ;

		if( pCompletion ) 
			pCompletion->Complete( results ) ;
	}

	//
	//	Notify the caller that the call will not be executed.
	//
	void
	CancelCall(		DWORD	dwReserved )	{

		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;
		delete	this ;

		if( pCompletion ) 
			pCompletion->ErrorComplete( dwReserved ) ;
	}
} ;



template<	class	SERVER,
			class	RESULT,
			class	BASECLASS = ICall< SERVER >
			>	
class	TMFnNoArgDelay :	public	BASECLASS	{
//
//	This defines a call state object which can be passed to a TMtService<SERVER>
//	The call object holds onto the arguments to which should be passed to the
//	member function of the server.
//
public : 
	//
	//	Define the signature of the member function we will call.
	//	NOTE : the function takes references to the values !!
	//
	typedef	BOOL	(SERVER::*FUNC_SIGNATURE)( RESULT&  ) ;

	//
	//	Define the signature of the object which will handle the completion
	//	of the Async Call.
	//
	typedef	TCompletion<RESULT>	COMPLETION_OBJECT ;

private : 
	//
	//	Pointer to a member function of the server
	//
	FUNC_SIGNATURE	m_pfn ;

	//
	//	Temporary to hold the results of the function
	//
	RESULT			m_Result ;

	//
	//	Pointer to the object which gets notified of the async completion.
	//
	COMPLETION_OBJECT*	m_pCompletion ;

public : 

	TMFnNoArgDelay(
		BASECLASS::INITIALIZER&	baseInit,
		FUNC_SIGNATURE	pfn,
		COMPLETION_OBJECT*	pCompletion
		) : 
		BASECLASS( baseInit ),
		m_pfn( pfn ),
		m_pCompletion( pCompletion ) {
	}


	TMFnNoArgDelay(
		FUNC_SIGNATURE	pfn,
		COMPLETION_OBJECT*	pCompletion
		) : 
		BASECLASS( baseInit ),
		m_pfn( pfn ),
		m_pCompletion( pCompletion ) {
	}

	//
	//	Execute the call !
	//
	//	If we return TRUE, then this object will be
	//	put into a queue for a later call to CompletCall()
	//
	//
	BOOL
	ExecuteCall(	SERVER&	server  ) {
		if( (server.*m_pfn)( m_Result ) ) {
			return	TRUE ;
		}	

		RESULT	results = m_Result ;
		
		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;

		delete	this ;

		if( pCompletion ) 
			pCompletion->Complete( results ) ;
		return	FALSE ;
	}		

	//
	//	Destroy ourselves before invoking the completion object !
	//
	virtual	void
	CompleteCall(	SERVER&	server )	{
		RESULT	results = m_Result ;
		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;

		delete	this ;

		if( pCompletion ) 
			pCompletion->Complete( results ) ;
	}

	//
	//	Notify the caller that the call will not be executed.
	//
	void
	CancelCall(		DWORD	dwReserved )	{

		COMPLETION_OBJECT*	pCompletion = m_pCompletion ;
		delete	this ;

		if( pCompletion ) 
			pCompletion->ErrorComplete( dwReserved ) ;
	}
} ;



	


template<	class	SERVER,	
			class	CALLBASE = ICall< SERVER >	>
class	TMtService	{
//
//	This template defines the class that manages the 
//	multithreading issues for objects of type 'SERVER'
//
public : 
	typedef	CALLBASE	CALL_OBJECT ;
private : 
	
	//
	//	Queue of requests from different clients.
	//
	TLockQueue< CALL_OBJECT >	m_PendingCalls ;

	///
	//	Is somebody trying to shut us down ? 
	//
	BOOL	m_fShutdown ;

	//
	//	The Server object that will be provided to the call objects !
	//
	SERVER&	m_Server ;

	//
	//	Can't construct us without providing all of our parameters !
	//
	TMtService() ;

public : 
	
	//
	//	Initialize us !
	//
	TMtService(	SERVER&	server ) : 
		m_Server( server ), 
		m_fShutdown( FALSE )	{
	}

	//
	//	Queue a request to be executed !
	//
	void
	QueueRequest(	CALL_OBJECT*	pcallobj	)	{

		//
		//	Use this to keep a stack of Calls that we did not 
		//	immediately complete !
		//
		CALL_OBJECT*	pDelayedCompletion = 0 ;

		//
		//	If Append returns FALSE then another thread will service the request !
		//
		if( m_PendingCalls.Append( pcallobj ) ) {
			//
			//	We're the first thread in - still may be no work to do though - 
			//	Try to get a CALL_OBJECT to service.
			//
			while( (pcallobj = m_PendingCalls.RemoveAndRelease()) != 0 ) {
				//
				//	If we're shutting down then we don't execute requests - 
				//	just fail them.
				//
				if( m_fShutdown ) {
					pcallobj->CancelCall( 0 ) ;
				}	else	{
					//
					//	If Execute Call returns 
					//
					if( pcallobj->ExecuteCall( m_Server ) ) {
						pcallobj->m_pNext = pDelayedCompletion ;
						pDelayedCompletion = pcallobj ;
					}
				}
			}
			//
			//	At this point, other threads may be executing in the service
			//	and we are only giving those CALL_OBJECTS who can deal with
			//	it a chance to notify their invokers.
			//	
			//	NOTE : pDelayedCompletion is basically a stack - get better
			//	value out of the CPU Cache that way.
			//
			while( pDelayedCompletion != 0 ) {
				pcallobj = (CALL_OBJECT*)pDelayedCompletion->m_pNext ;
				pDelayedCompletion->m_pNext = 0 ;
				pDelayedCompletion->CompleteCall( m_Server ) ;
				pDelayedCompletion = pcallobj ;
			}
		}
	}
} ;
	
#endif	//	_MTLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\pbag.h ===
//
// pbag.h
//

#pragma once

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#pragma warning (disable : 4786)
#include <string>
#include <map>
using namespace std;

#include "tunk.h"

class CPropBag : public TUnknown<IPropertyBag>
{
public:
    CPropBag() : TUnknown<IPropertyBag> (IID_IPropertyBag) {};

	STDMETHOD(Read)(LPCOLESTR pszPropName,VARIANT* pVar, IErrorLog* pErrorLog);
	STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT* pVar);

protected:
    typedef map <wstring, CComVariant> BAGMAP;

    BAGMAP m_map;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\perflib.h ===
//																-*- c++ -*-
// perflib.h
//

#ifndef __PERFLIB_H
#define __PERFLIB_H

#define MAX_PERF_NAME			16
#define MAX_OBJECT_NAME			16
#define MAX_INSTANCE_NAME		32

typedef WCHAR OBJECTNAME[MAX_OBJECT_NAME];
typedef WCHAR INSTANCENAME[MAX_INSTANCE_NAME];


#define MAX_PERF_OBJECTS		16
#define MAX_OBJECT_INSTANCES	64
#define MAX_OBJECT_COUNTERS		64


class PerfObjectInstance;
class PerfCounterDefinition;
class PerfObjectDefinition;

struct INSTANCE_DATA
{
	BOOL						fActive;
	PERF_INSTANCE_DEFINITION	perfInstDef;
	INSTANCENAME				wszInstanceName;
};

class PerfLibrary
{

	friend class PerfObjectDefinition;
	friend class PerfCounterDefinition;
	
private:

	// name of this performance module
	WCHAR						m_wszPerfName[MAX_PERF_NAME];
		
	// array of PerfObjectDefinition's and a count of how many there are.
	PerfObjectDefinition*		m_rgpObjDef[MAX_PERF_OBJECTS];
	DWORD						m_dwObjDef;

	// shared memory handle and pointer to base of shared memory
	HANDLE						m_hMap;
	PBYTE						m_pbMap;
	

 	// pointers to places in the shared memory where we keep stuff
	DWORD*						m_pdwObjectNames;
	OBJECTNAME*					m_prgObjectNames;

	// base values for title text and help text for the library
	DWORD						m_dwFirstHelp;
	DWORD						m_dwFirstCounter;
	
	void AddPerfObjectDefinition( PerfObjectDefinition* pObjDef );
	
public:

	PerfLibrary( LPCWSTR pcwstrPerfName = L"");
	~PerfLibrary( void );
	
	
	void InitName( LPCWSTR pcwstrPerfName )
	{
		lstrcpynW( m_wszPerfName, pcwstrPerfName, MAX_PERF_NAME );
	}
	
	BOOL Init( void );
};


class PerfObjectDefinition
{

	friend class PerfLibrary;
	friend class PerfCounterDefinition;
	friend class PerfObjectInstance;
	
private:
	
	WCHAR						m_wszObjectName[MAX_OBJECT_NAME];
	
	DWORD 						m_dwObjectNameIndex;
	DWORD 						m_dwMaxInstances;

	PerfCounterDefinition*		m_rgpCounterDef[MAX_OBJECT_COUNTERS];
	DWORD						m_dwCounters;

	DWORD						m_dwDefinitionLength;
	DWORD						m_dwCounterData;
	DWORD						m_dwPerInstanceData;

	HANDLE						m_hMap;
	void*						m_pv;

	PERF_OBJECT_TYPE*			m_pPerfObjectType;
	PERF_COUNTER_DEFINITION*	m_rgPerfCounterDefinition;

	char*						m_pCounterData;

	DWORD						m_dwActiveInstances;

	
	BOOL Init( PerfLibrary* pPerfLib );
	void AddPerfCounterDefinition( PerfCounterDefinition* pcd );

	DWORD GetCounterOffset( DWORD dwId );

	void OnInstanceDestroyed( void );
	
public:

	PerfObjectDefinition( PerfLibrary& rPerfLib,
						  LPCWSTR pwcstrObjectName,
						  DWORD dwObjectNameIndex,
						  DWORD dwMaxInstances = PERF_NO_INSTANCES );

	PerfObjectDefinition( PerfLibrary& rPerfLib,
						  DWORD dwObjectNameIndex,
						  DWORD dwMaxInstances = PERF_NO_INSTANCES );

	void InitName( LPCWSTR pwcstrObjectName )
	{
		lstrcpynW( m_wszObjectName, pwcstrObjectName, MAX_OBJECT_NAME );
	}


	~PerfObjectDefinition( void );
	
	PerfObjectInstance* CreateObjectInstance( LPCWSTR pwstrInstanceName );

};


class PerfCounterDefinition
{

	friend class PerfObjectDefinition;
	
private:
	
	PerfObjectDefinition*		m_pObjDef;
	PerfCounterDefinition*		m_pCtrRef;
	DWORD 						m_dwCounterNameIndex;
	LONG  						m_lDefaultScale;
	DWORD 						m_dwCounterType;
	DWORD 						m_dwCounterSize;

	DWORD						m_dwOffset;

	void Init( PerfLibrary* pPerfLib,
			   PERF_COUNTER_DEFINITION* pdef, PDWORD pdwOffset );
	
public:

	PerfCounterDefinition( PerfObjectDefinition& robj,
						   DWORD dwCounterNameIndex,
						   DWORD dwCounterType = PERF_COUNTER_COUNTER,
						   LONG lDefaultScale = 0 );

	PerfCounterDefinition( PerfCounterDefinition& pRefCtr,
						   DWORD dwCounterNameIndex,
						   DWORD dwCounterType = PERF_COUNTER_COUNTER,
						   LONG lDefaultScale = 0 );
						   
};


class PerfObjectInstance
{

private:

	PerfObjectDefinition*		m_pObjDef;
	
	WCHAR						m_wszInstanceName[MAX_INSTANCE_NAME];

	INSTANCE_DATA*				m_pInstanceData;
	char*						m_pCounterData;

	
public:

	PerfObjectInstance( PerfObjectDefinition* pObjDef,
						LPCWSTR pwcstrInstanceName,
						char* pCounterData,
						INSTANCE_DATA* pInstanceData,
						LONG lID );
	~PerfObjectInstance();
	
	DWORD* GetDwordCounter( DWORD dwId );
	LARGE_INTEGER* GetLargeIntegerCounter( DWORD dwId );
};

class CLongCounter
{
	public:
	CLongCounter(): m_plCounter(NULL) {}
	~CLongCounter() {}

	void Init(DWORD *pdwCounter)
	{
		m_plCounter = (LPLONG)pdwCounter;
		Reset();
	}

	void Increment() { if(m_plCounter) InterlockedIncrement(m_plCounter); }
	void Decrement() { if(m_plCounter) InterlockedDecrement(m_plCounter); }
	void Reset() { if(m_plCounter) InterlockedExchange(m_plCounter, 0); }
	void Set(DWORD dw) { if(m_plCounter) InterlockedExchange(m_plCounter, (LONG)dw); }

	void operator++() { Increment(); }
	void operator--() { Decrement(); }
	void operator =(DWORD dw) { Set(dw); }

	private:
	LPLONG m_plCounter;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\perferr.h ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perferr.h
       (derived from perferr.mc by the message compiler  )

Abstract:

   Event message definititions used by routines in PERFAPI.DLL
   
Comments:
   I need to put more error codes here.  Also, they all need to
   be in the correct order.  Oh well, it works for now.

--*/
//
#ifndef _PERFERR_H_
#define _PERFERR_H_
//
//
//     Perfutil messages
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: UTIL_LOG_OPEN
//
// MessageText:
//
//  The Dynamic Performance counters DLL opened the Event Log.
//
#define UTIL_LOG_OPEN                    ((DWORD)0x4123076CL)

//
//
// MessageId: UTIL_CLOSING_LOG
//
// MessageText:
//
//  The Dynamic Performance counters DLL closed the Event Log.
//
#define UTIL_CLOSING_LOG                 ((DWORD)0x412307CFL)

//
//
// MessageId: PERFAPI_COLLECT_CALLED
//
// MessageText:
//
//  Perfapi Collect Function has been called.
//
#define PERFAPI_COLLECT_CALLED           ((DWORD)0x412307D0L)

//
//
// MessageId: PERFAPI_OPEN_CALLED
//
// MessageText:
//
//  Perfapi Open Function has been called.
//
#define PERFAPI_OPEN_CALLED              ((DWORD)0x412307D1L)

//
//
// MessageId: PERFAPI_UNABLE_OPEN_DRIVER_KEY
//
// MessageText:
//
//  Unable to open "Performance" key of PerfApiCounters in registy. Status code is returned in data.
//
#define PERFAPI_UNABLE_OPEN_DRIVER_KEY   ((DWORD)0xC12307D2L)

//
//
// MessageId: PERFAPI_UNABLE_READ_COUNTERS
//
// MessageText:
//
//  Unable to read the "Counters" value from the Perlib\<lang id> Key. Status codes returned in data.
//
#define PERFAPI_UNABLE_READ_COUNTERS     ((DWORD)0xC12307D3L)

//
//
// MessageId: PERFAPI_UNABLE_READ_HELPTEXT
//
// MessageText:
//
//  Unable to read the "Help" value from the Perflib\<lang id> Key. Status codes returned in data.
//
#define PERFAPI_UNABLE_READ_HELPTEXT     ((DWORD)0xC12307D4L)

//
//
// MessageId: PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM
//
// MessageText:
//
//  Failed to alloc and initialize the shared memory for object counters. Status is in data.
//
#define PERFAPI_FAILED_TO_ALLOC_OBJECT_SHMEM ((DWORD)0xC12307D5L)

//
//
// MessageId: PERFAPI_FAILED_TO_UPDATE_REGISTRY
//
// MessageText:
//
//  Failed to update the registry entries. Status code is in data.
//
#define PERFAPI_FAILED_TO_UPDATE_REGISTRY ((DWORD)0xC12307D6L)

//
//
// MessageId: PERFAPI_INVALID_OBJECT_HANDLE
//
// MessageText:
//
//  Invalid object handle passed. Cannot create counter/instance, or destroy object.
//
#define PERFAPI_INVALID_OBJECT_HANDLE    ((DWORD)0xC12307D7L)

//
//
// MessageId: PERFAPI_FAILED_TO_CREATE_INSTANCE_HANDLE
//
// MessageText:
//
//  Failed to create instance handle. Reason: too many instances.
//
#define PERFAPI_FAILED_TO_CREATE_INSTANCE_HANDLE ((DWORD)0xC12307D8L)

//
//
// MessageId: PERFAPI_FAILED_TO_CREATE_COUNTER_HANDLE
//
// MessageText:
//
//  Failed to create counter handle. Reason: out of memory.
//
#define PERFAPI_FAILED_TO_CREATE_COUNTER_HANDLE ((DWORD)0xC12307D9L)

//
//
// MessageId: PERFAPI_INVALID_TITLE
//
// MessageText:
//
//  Failed to create Performance object, instance or counter. Reason: no name was supplied.
//
#define PERFAPI_INVALID_TITLE            ((DWORD)0xC12307DAL)

//
//
// MessageId: PERFAPI_ALREADY_EXISTS
//
// MessageText:
//
//  The Performance object, counter or instance existed before an attempt to create it. The call did not create a new object, counter or instance. The handle, offset or instance id that was returned refer to the old object, counter or instance.
//
#define PERFAPI_ALREADY_EXISTS           ((DWORD)0x812307DBL)

//
//
// MessageId: PERFAPI_INVALID_INSTANCE_HANDLE
//
// MessageText:
//
//  The supplied Performance Instance handle is invalid.
//
#define PERFAPI_INVALID_INSTANCE_HANDLE  ((DWORD)0xC12307DCL)

//
//
// MessageId: PERFAPI_FAILED_TO_CREATE_INSTANCE
//
// MessageText:
//
//  Failed to create Performance instance. Possible reasons: Can't create any more instances for the object, or the object that the instance belongs to, does not support instances.
//
#define PERFAPI_FAILED_TO_CREATE_INSTANCE ((DWORD)0xC12307DDL)

//
//
// MessageId: PERFAPI_FAILED_TO_CREATE_COUNTER
//
// MessageText:
//
//  Can't create any more Performance counters for the object. 
//
#define PERFAPI_FAILED_TO_CREATE_COUNTER ((DWORD)0xC12307DEL)

//
//
// MessageId: PERFAPI_FAILED_TO_CREATE_OBJECT
//
// MessageText:
//
//  Can't create any more Performance objects. 
//
#define PERFAPI_FAILED_TO_CREATE_OBJECT  ((DWORD)0xC12307DFL)

//
//
// MessageId: PERFAPI_FAILED_TO_OPEN_REGISTRY
//
// MessageText:
//
//  The Dynamic Performance Counters DLL failed to open a registry key. 
//
#define PERFAPI_FAILED_TO_OPEN_REGISTRY  ((DWORD)0xC12307E0L)

//
//
// MessageId: PERFAPI_FAILED_TO_READ_REGISTRY
//
// MessageText:
//
//  The Dynamic Performance Counters DLL failed to read a value from a registry key. 
//
#define PERFAPI_FAILED_TO_READ_REGISTRY  ((DWORD)0xC12307E1L)

//
//
// MessageId: PERFAPI_INVALID_COUNTER_HANDLE
//
// MessageText:
//
//  The Performance counter handle supplied is invalid.
//
#define PERFAPI_INVALID_COUNTER_HANDLE   ((DWORD)0xC12307E2L)

//
//
// MessageId: PERFAPI_INVALID_INSTANCE_ID
//
// MessageText:
//
//  The supplied Performance Instance id is invalid.
//
#define PERFAPI_INVALID_INSTANCE_ID      ((DWORD)0xC12307E3L)

//
//
// MessageId: PERFAPI_OUT_OF_MEMORY
//
// MessageText:
//
//  An attempt to allocate local memory failed.
//
#define PERFAPI_OUT_OF_MEMORY            ((DWORD)0xC12307E4L)

//
//
// MessageId: PERFAPI_OUT_OF_REGISTRY_ENTRIES
//
// MessageText:
//
//  All the allocated registry entries for dynamic performance objects/counters have been filled out. Can not add any more objects/counters.
//
#define PERFAPI_OUT_OF_REGISTRY_ENTRIES  ((DWORD)0xC12307E5L)

//
//
// MessageId: PERFAPI_INVALID_COUNTER_ID
//
// MessageText:
//
//  The supplied Performance Counter id is invalid.
//
#define PERFAPI_INVALID_COUNTER_ID       ((DWORD)0xC12307E6L)

#endif // _PERFERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\perfapi.h ===
#ifndef __PERFAPI_H__
#define __PERFAPI_H__

#include <winperf.h>

typedef DWORD	INSTANCE_ID;
typedef DWORD	COUNTER_ID;

#define MAX_COUNTERS                    128
#define MAX_INSTANCES_PER_OBJECT        32
#define MAX_PERF_OBJECTS                64

#define	BITS_IN_DWORD					(sizeof(DWORD) << 3)

#ifdef __PERF_APP_API
#define	PERF_APP_API  __declspec(dllexport)
#else
#define PERF_APP_API  __declspec(dllimport)
#endif

/* NOTE: The member functions for all classes are in-line */

#ifdef __cplusplus

// CPerfObject Class
class PERF_APP_API CPerfObject {
private:
		HANDLE		hObject;							// Handle to Performance Object
		BOOL		bWithInstances;						// True, if object has instances
		BOOL		bValid;								// True, if the PerfMon object is OK.  False, if there had been an exception thrown.
		DWORD		cCounters;						// # of created counters for the object
		DWORD		dwCounterOffsets[MAX_COUNTERS];		// The object's counter offsets
		DWORD		bCounterSize[MAX_COUNTERS / BITS_IN_DWORD + 1];	// bitmap of counter sizes. If bit is 0, counter is a DWORD, otherwise (bit is 1), it's a LARGE_INTEGER.
		INSTANCE_ID	iidInstances[MAX_INSTANCES_PER_OBJECT]; // The object's instance ids
		BOOL		bOriginal[MAX_INSTANCES_PER_OBJECT]; // True, if the instance is original. Then, it needs to be destroyed.
		PBYTE		lpInstanceAddr[MAX_INSTANCES_PER_OBJECT];	// The object's instances' start addresses. If the object has no instances, the 0-th address is the object counter data start 

		friend class CPerfCounter;
    
public:
		CPerfObject (void) { bValid = FALSE; };
		BOOL Create (char *pTitle, BOOL bHasInstances = TRUE, char *pHelp = NULL, DWORD nSize = 0);
		BOOL Create (WCHAR *pTitle, BOOL bHasInstances = TRUE, WCHAR *pHelp = NULL, DWORD nSize = 0);
		~CPerfObject (void);
		COUNTER_ID CreateCounter (char *pCounterName, DWORD dwType = PERF_COUNTER_COUNTER, DWORD dwScale = 0, DWORD dwSize = sizeof(DWORD), char *pHelp = NULL);
		COUNTER_ID CreateCounter (WCHAR *pCounterName, DWORD dwType = PERF_COUNTER_COUNTER, DWORD dwScale = 0, DWORD dwSize = sizeof(DWORD), WCHAR *pHelp = NULL);
		INSTANCE_ID CreateInstance (char *pInstanceName);
		INSTANCE_ID CreateInstance (WCHAR *pInstanceName);
		BOOL DestroyInstance (INSTANCE_ID iid);

};

// CPerfCounter Class
class PERF_APP_API CPerfCounter {
private:
		LPDWORD	pAddr;		// Read address of the counter
		BOOL	bDword;		// If TRUE, the counter is a DWORD, otherwise, it's a LARGE_INTEGER

public:
		CPerfCounter (void) { pAddr = NULL; };
		BOOL Create (CPerfObject &cpoObject, COUNTER_ID idCounter, INSTANCE_ID idInstance = (INSTANCE_ID) -1);
		~CPerfCounter (void) { };

		CPerfCounter & operator = (DWORD nNewValue)
		{
			if (pAddr)
				*pAddr = nNewValue;
			return *this;
		};

		CPerfCounter & operator = (LARGE_INTEGER nNewValue)
		{
			if (pAddr)
				((LARGE_INTEGER *) pAddr)->QuadPart = nNewValue.QuadPart;
			return *this;
		};

		CPerfCounter & operator = (const CPerfCounter &PerfCtr)
		{
			if (pAddr && PerfCtr.pAddr) {
				if (bDword != PerfCtr.bDword)
					return *this;
				if (bDword)
					*pAddr = *(PerfCtr.pAddr);
				else
					((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) PerfCtr.pAddr)->QuadPart;
			}
			return *this;
		};

		CPerfCounter & operator += (DWORD nValue)
		{
			if (pAddr)
				*pAddr += nValue;
			return *this;
		};

		CPerfCounter & operator += (LARGE_INTEGER nValue)
		{
			if (pAddr)
				((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart + nValue.QuadPart;
			return *this;
		};

		CPerfCounter & operator += (const CPerfCounter &PerfCtr)
		{
			if (pAddr && PerfCtr.pAddr) {
				if (bDword != PerfCtr.bDword)
					return *this;
				if (bDword)
					*pAddr += *(PerfCtr.pAddr);
				else
					((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart + ((LARGE_INTEGER *) PerfCtr.pAddr)->QuadPart;
			}
			return *this;
		};

		CPerfCounter & operator -= (DWORD nValue)
		{
			if (pAddr)
				*pAddr -= nValue;
			return *this;
		};

		CPerfCounter & operator -= (LARGE_INTEGER nValue)
		{
			if (pAddr)
				((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart - nValue.QuadPart;
			return *this;
		};

		CPerfCounter & operator -= (const CPerfCounter &PerfCtr)
		{
			if (pAddr && PerfCtr.pAddr) {
				if (bDword != PerfCtr.bDword)
					return *this;
				if (bDword)
					*pAddr -= *(PerfCtr.pAddr);
				else
					((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart - ((LARGE_INTEGER *) PerfCtr.pAddr)->QuadPart;
			}
			return *this;
		};

		CPerfCounter & operator ++ (void)
		{
			if (pAddr) {
				if (bDword)
					(*pAddr)++;
				else
					((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart + 1;
			}
			return *this;
		};

		CPerfCounter & operator ++ (int dummy)
		{
			if (pAddr) {
				if (bDword)
					(*pAddr)++;
				else
					((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart + 1;
			}
			return *this;
		};

		CPerfCounter & operator -- (void)
		{
			if (pAddr) {
				if (bDword)
					(*pAddr)--;
				else
					((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart - 1;
			}
			return *this;
		};

		CPerfCounter & operator -- (int dummy)
		{
			if (pAddr) {
				if (bDword)
					(*pAddr)--;
				else
					((LARGE_INTEGER *) pAddr)->QuadPart = ((LARGE_INTEGER *) pAddr)->QuadPart - 1;
			}
			return *this;
		};

		operator DWORD ()
		{
			if (pAddr == NULL)
				return 0;
			return (*pAddr);
		};

		operator LARGE_INTEGER ()
		{
			if (pAddr == NULL) {
					LARGE_INTEGER li;
				li.QuadPart = 0;
				return li;
			}
			return (* (LARGE_INTEGER *) pAddr);
		};

}; 

#endif

#ifdef __cplusplus
extern "C"  {
#endif

/*
	MakeAPerfObject:: Creates a logical perf object, under which one can create 
	counters. This perf object shows up as an object in Perfmon and the counters
	showup under it. A maximum number of instances can be specified. (Currently 
	this is hardcoded to 16). And instances can be dynamically created and
	destroyed.

	An object can be removed with the DestroyObject API. The handle returned by
	the MakeObject is used to denote the object. Note this removes all the
	instances (and all the counters) that were associated with the Object.
	All pointers returned by the MakeCounter become invalidated and the risk is on
	the API user not to reference them anymore.

*/
PERF_APP_API HANDLE _stdcall MakeAPerfObjectW(PWCHAR pTitle, PWCHAR pHelp, DWORD nSize, BOOL bHasInstances, PVOID *lppObjectStart) ;
PERF_APP_API HANDLE _stdcall MakeAPerfObjectA(char * pTitle, char *pHelp, DWORD nSize, BOOL bHasInstances, PVOID *lppObjectStart) ;
PERF_APP_API BOOL   _stdcall DestroyPerfObject(HANDLE) ;

/*
	MakeAPerfCounter:: Returns the Offset of the counter from the start of the
	object.
*/
PERF_APP_API DWORD  _stdcall MakeAPerfCounterW(DWORD dwType, DWORD dwScale, DWORD dwSize, HANDLE hObject, PWCHAR pDesc, PWCHAR pHelp);
PERF_APP_API DWORD  _stdcall MakeAPerfCounterA(DWORD dwType, DWORD dwScale, DWORD dwSize, HANDLE hObject, char * pDesc, char * pHelp);
PERF_APP_API HANDLE _stdcall MakeAPerfCounterHandleW(DWORD dwType, DWORD dwScale, DWORD dwSize, HANDLE hObject, PWSTR pCounterName, PWSTR pHelp);
PERF_APP_API HANDLE _stdcall MakeAPerfCounterHandleA(DWORD dwType, DWORD dwScale, DWORD dwSize, HANDLE hObject,char *  pCounterName, char * pHelp);
PERF_APP_API BOOL   _stdcall DestroyPerfCounterHandle(HANDLE pCounterInfo);
/*
	MakeAPerfInstance  - creates a new instance of an already existing Object and
	duplicates all its counters, further any counter created for the object gets
	duplicated too. 
	
        If the return HANDLE is NULL then the API failed else success.
	The returned HANDLE can be used to Destroy the object instance.
	The final form of this api should be 
		MakeAPerfInstanceW(HANDLE, PWCHAR pInstName) ;
	The object name has to be replaced by the object handle returned by MakeObject
*/
PERF_APP_API INSTANCE_ID _stdcall MakeAPerfInstanceW(HANDLE hObject, PWCHAR pInstName, PVOID *lppInstanceStart) ;
PERF_APP_API INSTANCE_ID _stdcall MakeAPerfInstanceA(HANDLE hObject, char *pInstName, PVOID *lppInstanceStart) ;
PERF_APP_API HANDLE      _stdcall MakeAPerfInstanceHandleW(HANDLE hObject, PWCHAR pInstName);
PERF_APP_API HANDLE      _stdcall   MakeAPerfInstanceHandleA(HANDLE hObject, char *pInstName);
PERF_APP_API BOOL        _stdcall    DestroyPerfInstance(INSTANCE_ID iID);
PERF_APP_API BOOL        _stdcall     DestroyPerfInstanceHandle(HANDLE pInstanceInfo);
PERF_APP_API BOOL    _stdcall    SetCounterValueByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbNewValue);
PERF_APP_API BOOL    _stdcall    GetCounterValueByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbCounterValue);
PERF_APP_API BOOL    _stdcall    IncrementCounterByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbIncrement);
PERF_APP_API BOOL   _stdcall     DecrementCounterByHandle(HANDLE hCounter, HANDLE hParent, PBYTE pbDecrement);

#ifdef __cplusplus
}
#endif



#ifdef UNICODE
#define MakeAPerfObject		        MakeAPerfObjectW
#define MakeAPerfCounter 	        MakeAPerfCounterW
#define MakeAPerfCounterHandle 	    MakeAPerfCounterHandleW
#define MakeAPerfInstance	    MakeAPerfInstanceW
#define MakeAPerfInstanceHandle	MakeAPerfInstanceHandleW
#else
#define MakeAPerfObject		        MakeAPerfObjectA
#define MakeAPerfCounter	        MakeAPerfCounterA
#define MakeAPerfCounterHandle      MakeAPerfCounterHandleA
#define MakeAPerfInstance	    MakeAPerfInstanceA
#define MakeAPerfInstanceHandle  MakeAPerfInstanceHandleA
#endif   //UNICODE

#endif // __PERFAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\rc4.h ===
#ifndef _RC4_H_
#define _RC4_H_

#ifndef WIN16_BUILD

/* Key structure */
struct RC4_KEYSTRUCT
{
  unsigned char S[256];		/* State table */
  unsigned char i,j;		/* Indices */
};

NTSYSAPI
void
NTAPI
rc4_key(struct RC4_KEYSTRUCT *, int, PUCHAR);

NTSYSAPI
void
NTAPI
rc4(struct RC4_KEYSTRUCT *, int , PUCHAR);

#else

/* Key structure */
struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
};

void rc4_key(struct RC4_KEYSTRUCT SEC_FAR *, int, unsigned char SEC_FAR *);
void rc4(struct RC4_KEYSTRUCT *, int , unsigned char *);

#endif // WIN16_BUILD

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\refcount.inl ===
//
// refcount.inl
//
// This file implements the member functions of 
// CRefCount as defined in smartptr.h.  
// Refer to smartptr.h for all information.
//


//-------------------------------------------
//
//  Initialize the reference count to -1.  We Use -1 so 
//  that it will be possible to determine when the first reference
//  is made.
//  
inline
CRefCount::CRefCount( ) : m_refs( -1 ) { }

//-------------------------------------------
inline  LONG
CRefCount::AddRef( ) {
//
//  Add a reference to an object.
//
    return  InterlockedIncrement( &m_refs ) ;
}



//-------------------------------------------
inline  LONG
CRefCount::RemoveRef( ) {
//
//  Remove a Reference from an object.
//  When this function returns a negative number the object
//  should be destroyed.
//
    return  InterlockedDecrement( &m_refs ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\pxpacket.h ===
//#---------------------------------------------------------------
//  File:       pxpacket.h
//
//  Synopsis:   This file contains the structure definations for
//				the CProxyPacket class.
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    t-alexwe
//----------------------------------------------------------------

#ifndef __PXPACKET_H__
#define __PXPACKET_H__

#include "cliproto.h"

//
// The CProxyPacket class is a just a wrapper for the PROXYPACKET structure.
// it has no data members except those that it inherits from PROXYPACKET
// and is used to manipulate messages found in a packet.
//
class CProxyPacket : public PROXYPACKET {
	public:
		CProxyPacket();
		~CProxyPacket();
		//
		// reset a packet to have no messages or data
		//
		void clear() { cLength = PACKETHDRSIZE; cMessages = 0; }
		//
		// Get the next available data area in the packet.  Once
		// data has been written here it must be registered with
		// AddMessage()
		//
		PVOID getNextDataPointer(void)
			{ return (PVOID) ((DWORD_PTR) pData + (cLength - PACKETHDRSIZE)); }
		//
		// get the number of bytes of available space in the data area
		//
		WORD getAvailableSpace(void)
			{ return sizeof(PROXYPACKET) - cLength - PACKETHDRSIZE; }
		//
		// add a message to a packet
		//
		void addMessage(WORD wCommand, WORD cData);
		//
		// gets the length of the entire packet
		//
		WORD getSize(void) { return cLength; }
		//
		// Gets the number of messages in a packet
		//
		WORD getMessageCount(void) { return cMessages; }
		//
		// retrieves a pointer to the message data for a particular
		// message.
		//
		PVOID getMessage(WORD wIndex, PWORD pwCommand, PWORD pcData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\phatqcat.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: phatqcat.h
//
// Contents: Categorizer related definitions used outside of phatq code
//
// History:
// jstamerj 1999/08/31 16:34:54: Created.
//
//-------------------------------------------------------------

//
// The guid for creating a CSMTPCategorizer object
//
DEFINE_GUID(CLSID_PhatQCat, 
0xad8a7977, 0xa7b8, 0x41ca, 0xbe, 0x5e, 0xf5, 0xa9, 0x5e, 0x64, 0x15, 0x51);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\registry.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.h
//
//  Contents:   Definitions of classes for manipulating registry entries.
//
//  Classes:    CMyRegKey     - class for registry key objects
//              CRegValue   - base class for registry value objects
//              CRegSZ      - derived class for registry string values
//              CRegDWORD   - derived class for registry dword values
//              CRegBINARY  - derived class for registry binary values
//              CRegMSZ     - derived class for registry multi-string values
//
//  History:    09/30/92    Rickhi  Created
//
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it lightweight for normal set/get
//                                  operations. Threw out all exception code
//
//              12/09/97    Milans  Ported it over to Exchange
//
//  Notes:      CMyRegKey can use another CMyRegKey as a parent, so you can
//              build a tree of keys.  To kick things off, you can give one
//              of the default registry keys like HKEY_CURRENT_USER. When
//              you do this, the GetParent method returns NULL.  Currently
//              however, no ptrs are kept to child and sibling keys.
//
//              CRegValue is a base class for dealing with registry values.
//              The other classes (except CMyRegKey) are for dealing with a
//              specific type of registry value in the native data format.
//              For example, CRegDWORD lets you call methods just providing
//              a dword.  The methods take care of figuring out the size and
//              casting the dword to a ptr to bytes, etc for use in the Win32
//              registry APIs.
//
//              For any registry type not defined here, you can always resort
//              to using the CRegValue base class directly, though you then
//              must call GetValue or SetValue methods explicitly.
//
//              Sample Usage:
//
//                  The following reads the username in the ValueID UserName
//                  within the key HKEY_CURRENT_USER\LogonInfo. It then changes
//                  it to Rickhi.  It also sets the password valueid in the
//                  the same key to foobar.
//
//                  #include    <registry.h>
//
//                  //  open the registry key
//                  CMyRegKey rkLogInfo(HKEY_CURRENT_USER, L"LogonInfo");
//
//                  //  read the user name
//                  LPSTR  pszUserName;
//                  CRegSZ rszUserName(&rkLogInfo, "UserName", pszUserName);
//                  rszUserName.SetString("Rickhi");
//
//                  //  set the password
//                  CRegSZ rszPassWord(&rkLogInfo, "PassWord", "foobar");
//
//----------------------------------------------------------------------------

#ifndef __REGISTRY_H__
#define __REGISTRY_H__

#include "reg_cbuffer.h"

//  to simplify error creation
#define Creg_ERROR(x) (x)

//  forward declarations for use in the following structures
class   CRegValue;
class   CMyRegKey;

//  structure for enumerating subkeys of a key
typedef struct _SRegKeySet
{
        ULONG       cKeys;
        CMyRegKey     *aprkKey[1];
} SRegKeySet;

//  structure for enumerating values within a key
typedef struct _SRegValueSet
{
        ULONG       cValues;
        CRegValue   *aprvValue[1];
} SRegValueSet;

//  structure for dealing with multi-string values
typedef struct _SMultiStringSet
{
        ULONG       cStrings;
        LPSTR      apszString[1];
} SMultiStringSet;


//+-------------------------------------------------------------------------
//
//  Class:      CMyRegKey
//
//  Purpose:    class for abstracting Registry Keys
//
//  Interface:  CMyRegKey         - constructor for a registry key object
//              ~CMyRegKey        - destructor for a registry key object
//              GetParentHandle - returns parent key's handle
//              GetHandle       - returns this key's handle
//              GetName         - returns key path
//              Delete          - deletes the key from the registry
//              EnumValues      - enumerate values stored in the key
//              EnumKeys        - enumerates subkeys of the key
//              NotifyChange    - sets up change notification for the key
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CMyRegKey
{
public:
        //  constructor using HKEY for parent
        //  Mode: Create key if not present
        CMyRegKey(HKEY     hkParent,
                LPCSTR   pszPath,

                //  remaining parameters are optional
                      REGSAM      samDesiredAccess = KEY_ALL_ACCESS,
                LPCSTR      pszClass = NULL,
                      DWORD       dwOptions = REG_OPTION_NON_VOLATILE,
                      DWORD       *pdwDisposition = NULL,
                const LPSECURITY_ATTRIBUTES pSecurityAttributes = NULL
                );
        //  constructor using CMyRegKey as parent
        //  Mode: Create key if not present
        CMyRegKey(const CMyRegKey&    crkParent,
                LPCSTR      pszPath,
               //  remaining parameters are optional
                REGSAM      samDesiredAccess = KEY_ALL_ACCESS,
                LPCSTR      pszClass = NULL,
                DWORD       dwOptions = REG_OPTION_NON_VOLATILE,
                DWORD       *pdwDisposition = NULL,
                const LPSECURITY_ATTRIBUTES pSecurityAttributes = NULL
               );

        // Constructor using HKEY for parent
        // Mode: Simply Open the key, if exists
        CMyRegKey (HKEY    hkParent,
                 DWORD   *pdwErr,
                 LPCSTR  pszPath,
                 REGSAM  samDesiredAccess = KEY_ALL_ACCESS
               );

        // Constructor using CMyRegKey as parent
        // Mode: Simply open the key, if exists
        CMyRegKey  (const  CMyRegKey& crkParent,
                  DWORD    *pdwErr,
                  LPCSTR   pszPath,
                  REGSAM   samDesiredAccess = KEY_ALL_ACCESS
                );
        // Destructor - Closes registry key
        ~CMyRegKey(void);

        HKEY        GetHandle(void) const;
        LPCSTR GetName(void) const;
        DWORD     Delete(void);
        DWORD     EnumValues(SRegValueSet **pprvs);
        DWORD     EnumKeys(SRegKeySet **pprks);

        // This method can be called to determine if
        // Object is in sane state or not
        DWORD     QueryErrorStatus () const { return _dwErr ; }

        // Static routine which frees memory allocated during EnumValues/Keys
    static void         MemFree ( void * pv )
    {

        delete [] (BYTE*)pv;
    }

private:
        DWORD        CreateKey(HKEY      hkParent,
                               LPCSTR    pszPath,
                               REGSAM    samDesiredAccess,
                               LPCSTR    pszClass,
                               DWORD     dwOptions,
                               DWORD     *pdwDisposition,
                               const LPSECURITY_ATTRIBUTES pSecurityAttributes
                              );

        DWORD        OpenKey  (HKEY      hkParent,
                               LPCSTR      pszPath,
                               REGSAM    samDesiredAccess
                              );

        HKEY         _hkParent;      //  Handle to parent
        HKEY         _hkThis;        //  handle for this key
        CCHARBuffer _cszName;        // Buffer containing the registry path
                                     //  path from parent key to this key
        DWORD      _dwErr;           // Internal error status
};

inline HKEY CMyRegKey::GetHandle(void) const
{
    return _hkThis;
}

inline LPCSTR CMyRegKey::GetName(void) const
{
    return (LPCSTR) (LPSTR)_cszName;
}


//+-------------------------------------------------------------------------
//
//  Class:      CRegValue
//
//  Purpose:    base class for abstracting Registry Values
//
//  Interface:  CRegValue       - constructor for value
//              ~CRegValue      - destructor for value
//              GetKeyHandle    - returns handle for parent key
//              GetValueID      - returns the ValueID name
//              GetTypeCode     - returns the TypeCode of the data
//              GetValue        - returns the data associated with the value
//              SetValue        - sets the data associated with the value
//              Delete          - deletes the value from the registry
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92    Rickhi      Created
//
//  Notes:      This is a base class from which more specific classes are
//              derived for each of the different registry value types.
//
//--------------------------------------------------------------------------

class CRegValue
{
public:
                    CRegValue(const CMyRegKey& crkParentKey,
                              LPCSTR   pszValueID);
                    ~CRegValue(void){;};

    HKEY            GetParentHandle(void) const;
    LPCSTR    GetValueID(void)   const;

    // Caller supplies buffer
    DWORD         GetValue(LPBYTE pbData,   ULONG *pcbData, DWORD *pdwTypeCode);

    DWORD         SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode);
    virtual DWORD QueryErrorStatus (void) const { return _dwErr ; }

private:
    CCHARBuffer      _cszValueID;
    HKEY             _hkParent;
    DWORD          _dwErr ;
};

//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::CRegValue
//
//  Purpose:    constructor for base registry value
//
//  Arguments:  [prkParent] - ptr to parent CMyRegKey for the key
//              [pszValueID] - the valueID name for the value
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

inline  CRegValue::CRegValue(const CMyRegKey&  crkParent,
                             LPCSTR  pszValueID)
                        :   _hkParent (crkParent.GetHandle()),
                            _dwErr(crkParent.QueryErrorStatus())
{
        _cszValueID.Set((PCHAR) pszValueID);
}

inline HKEY CRegValue::GetParentHandle(void) const
{
        return _hkParent;
}

inline LPCSTR CRegValue::GetValueID(void) const
{
        return (LPCSTR) (LPSTR) _cszValueID;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegSZ
//
//  Purpose:    Derived class for abstracting Registry string Values
//
//  Interface:  CRegSZ      - constructor for registry value using string
//              ~CRegSZ     - destructor for registry string object
//              GetString   - returns the string
//              SetString   - sets a new string value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------
class CRegSZ : public CRegValue
{
public:
        //  create/write value constructor
        CRegSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID,
               LPCSTR  pszData
          );

        //  io-less constructor - used by enumerator
        CRegSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID
          );

        ~CRegSZ(void){;};

        DWORD         SetString(LPCSTR pszData);

        // Caller supplies buffer (supply the buffer size in bytes)
        DWORD         GetString(      LPSTR pszData, ULONG *pcbData);

        DWORD           GetTypeCode(void);

        DWORD         QueryErrorStatus(void) const { return _dwErr ; }

private:
        DWORD     _dwErr;

};

//+-------------------------------------------------------------------------
//
//  Member:     CRegSZ::CRegSZ
//
//  Purpose:    Constructor for registry string value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------
inline CRegSZ::CRegSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID,
                      LPCSTR    pszData)
    : CRegValue(crkParent, pszValueID)
{
    if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
        _dwErr = SetString(pszData);
}

inline CRegSZ::CRegSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID)
    : CRegValue(crkParent, pszValueID)
{
    //  automatic actions in header are sufficient
    _dwErr = CRegValue::QueryErrorStatus();
}

inline DWORD CRegSZ::SetString(LPCSTR pszData)
{
    return SetValue((LPBYTE)pszData, (strlen(pszData)+1), REG_SZ);
}

inline DWORD CRegSZ::GetString(LPSTR pszData, ULONG* pcbData)
{
    DWORD   dwTypeCode;

    return GetValue((LPBYTE)pszData, pcbData, &dwTypeCode);
}

inline DWORD CRegSZ::GetTypeCode(void)
{
    return  REG_SZ;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegMSZ
//
//  Purpose:    Derived class for abstracting Registry multi-string Values
//
//  Interface:  CRegMSZ      - constructor for registry value using string
//              ~CRegMSZ     - destructor for registry string object
//              GetString   -  returns the string
//              SetString   -  sets a new string value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------
class CRegMSZ : public CRegValue
{
public:
        //  create/write value constructor
        CRegMSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID,
               LPCSTR  pszData
          );

        //  io-less constructor - used by enumerator
        CRegMSZ(const CMyRegKey &crkParent,
               LPCSTR  pszValueID
          );

        ~CRegMSZ(void){;};

        DWORD         SetString(LPCSTR pszData);

        // Caller supplies buffer (supply the buffer size in bytes)
        DWORD         GetString(      LPSTR pszData, ULONG *pcbData);

        DWORD           GetTypeCode(void);

        DWORD         QueryErrorStatus(void) const { return _dwErr ; }

private:
        DWORD     _dwErr;

};

//+-------------------------------------------------------------------------
//
//  Member:     CRegMSZ::CRegMSZ
//
//  Purpose:    Constructor for registry string value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------
inline CRegMSZ::CRegMSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID,
                      LPCSTR    pszData)
    : CRegValue(crkParent, pszValueID)
{
    if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
        _dwErr = SetString(pszData);
}

inline CRegMSZ::CRegMSZ(const CMyRegKey   &crkParent,
                      LPCSTR    pszValueID)
    : CRegValue(crkParent, pszValueID)
{
    //  automatic actions in header are sufficient
    _dwErr = CRegValue::QueryErrorStatus();
}

inline DWORD CRegMSZ::SetString(LPCSTR pszData)
{
    DWORD   cLen, cbData;
    LPCSTR  pszNextString;

    for (pszNextString = pszData, cbData = 0;
            *pszNextString != '\0';
                pszNextString += cLen) {
         cLen = strlen(pszNextString) + 1;
         cbData += cLen;
    }
    cbData += sizeof('\0');

    return SetValue((LPBYTE)pszData, cbData, REG_MULTI_SZ);
}

inline DWORD CRegMSZ::GetString(LPSTR pszData, ULONG* pcbData)
{
    DWORD   dwTypeCode;

    return GetValue((LPBYTE)pszData, pcbData, &dwTypeCode);
}

inline DWORD CRegMSZ::GetTypeCode(void)
{
    return  REG_MULTI_SZ;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegDWORD
//
//  Purpose:    Derived class for abstracting Registry dword Values
//
//  Interface:  CRegDWORD   - constructor for registry value using dword
//              ~CRegDWORD  - destructor for registry dword object
//              GetDword    - returns the dword
//              SetDword    - sets a new dword value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------

class CRegDWORD : public CRegValue
{
public:
        //  create/write value constructor
        CRegDWORD(const CMyRegKey &crkParent,
                  LPCSTR  pszValueID,
                        DWORD   dwData);

        //  open/read value constructor
        CRegDWORD(const CMyRegKey &crkParent,
                  LPCSTR  pszValueID,
                        DWORD   *pdwData);

        //  io-less constructor - used by enumerator
        CRegDWORD( const CMyRegKey &crkParent,
                   LPCSTR  pszValueID);

        ~CRegDWORD(void){;};


        DWORD         SetDword(DWORD dwData);
        DWORD         GetDword(DWORD *pdwData);
        DWORD           GetTypeCode(void) ;
        DWORD         QueryErrorStatus(void) const { return _dwErr ; }

private:
        DWORD     _dwErr;
};

//+-------------------------------------------------------------------------
//
//  Member:     CRegDWORD::CRegDWORD
//
//  Purpose:    Constructor for registry dword value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

inline CRegDWORD::CRegDWORD(const CMyRegKey &crkParent,
                            LPCSTR  pszValueID,
                                  DWORD   dwData)
    : CRegValue(crkParent, pszValueID)
{

        if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
                _dwErr = SetDword(dwData);
}


inline CRegDWORD::CRegDWORD(const CMyRegKey &crkParent,
                            LPCSTR  pszValueID,
                                  DWORD   *pdwData)
    : CRegValue(crkParent, pszValueID)
{

        if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
                _dwErr = GetDword(pdwData);
}

inline CRegDWORD::CRegDWORD(const CMyRegKey &crkParent,
                            LPCSTR  pszValueID)
    : CRegValue(crkParent, pszValueID)
{
        //  automatic actions in header are sufficient
        _dwErr = CRegValue::QueryErrorStatus();
}

inline DWORD CRegDWORD::GetDword(DWORD *pdwData)
{
        DWORD   dwTypeCode;
        DWORD   dwErr;
        ULONG   cbData= sizeof(DWORD);
        dwErr = GetValue((LPBYTE)pdwData, &cbData, &dwTypeCode);
        return (dwErr);
}


inline DWORD CRegDWORD::SetDword(DWORD dwData)
{
        return SetValue((LPBYTE)&dwData, sizeof(DWORD), REG_DWORD);
}

inline DWORD CRegDWORD::GetTypeCode(void)
{
        return  REG_DWORD;
}

//+-------------------------------------------------------------------------
//
//  Class:      CRegBINARY
//
//  Purpose:    Derived class for abstracting Registry binary Values
//
//  Interface:  CRegBINARY  - constructor for registry value using binary data
//              ~CRegBINARY - destructor for registry binary data object
//              GetBinary   - returns the binary data
//              SetBinary   - sets a new binary data value
//              QueryErrorStatus - Should be used to determine if constructor
//                                 completed successfully or not
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:      Derived from CRegValue.
//
//              There are three constructors. The first is used if you want
//              to create a new value or overwrite the existing value data.
//              The second is used if you want to open an existing value
//              and read it's data.  The third is used if you just want to
//              make an object without doing any read/write of the data yet.
//              In all three cases, you can always use any of the Get/Set
//              operations on the object at a later time.
//
//--------------------------------------------------------------------------

class CRegBINARY : public CRegValue
{
public:
        //  create/write value constructor
        CRegBINARY(const CMyRegKey &crkParent,
                   LPCSTR  pszValueID,
                   const LPBYTE  pbData,
                         ULONG   cbData);

        //  io-less constructor - used by enumerator
        CRegBINARY(const CMyRegKey &crkParent,
                   LPCSTR  pszValueID);

        ~CRegBINARY(void){;};

        DWORD         SetBinary(const LPBYTE pbData, ULONG cbData);

        // Caller supplies buffer (supply the buffer size in bytes)
        DWORD         GetBinary(LPBYTE pbData, ULONG *pcbData);

        DWORD           GetTypeCode(void);
        DWORD         QueryErrorStatus(void) { return _dwErr ; }

private:
        DWORD     _dwErr;

};

//+-------------------------------------------------------------------------
//
//  Member:     CRegBINARY::CRegBINARY
//
//  Purpose:    Constructor for registry binary value
//
//  History:    09/30/92  Rickhi        Created
//
//  Notes:
//
//--------------------------------------------------------------------------


inline CRegBINARY::CRegBINARY(const CMyRegKey   &crkParent,
                              LPCSTR    pszValueID,
                              const LPBYTE    pbData,
                                    ULONG     cbData)
    : CRegValue(crkParent, pszValueID)
{

    if (ERROR_SUCCESS == (_dwErr = CRegValue::QueryErrorStatus()))
        _dwErr = SetBinary(pbData, cbData);
}

inline CRegBINARY::CRegBINARY(const CMyRegKey   &crkParent,
                              LPCSTR    pszValueID)
    : CRegValue(crkParent, pszValueID)
{
        //  automatic actions in header are sufficient
        _dwErr = CRegValue::QueryErrorStatus();
}


inline DWORD CRegBINARY::SetBinary(const LPBYTE pbData, ULONG cbData)
{
        return SetValue(pbData, cbData, REG_BINARY);
}

inline DWORD CRegBINARY::GetBinary(LPBYTE pbData, ULONG* pcbData)
{
        DWORD   dwTypeCode;
        return  GetValue(pbData, pcbData, &dwTypeCode);
}
inline DWORD CRegBINARY::GetTypeCode(void)
{
        return  REG_BINARY;
}

//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    This function can be used to deleting a key and all it's
//              children.
//
//  History:    09/30/93  AlokS        Created
//
//  Notes:      We assume that caller has proper access priviledge
//              and the key is non-volatile.
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPSTR lpszKeyPath);

#endif   // __REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\seoint.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	SEOINT.h

Abstract:

	This module contains the declarations for the internal
	interfaces to the Server Extension Objects library.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/23/96	created

--*/


#ifndef _SEOINT_INC
#define _SEOINT_INC


#ifndef SEOHANDLE_DEFINED
	#define SEOHANDLE_DEFINED
	DECLARE_HANDLE(SEOHANDLE);
#endif


SEODLLDEF STDAPI SEOInit(REFGUID guidInstance, SEOHANDLE *pshHandle);
SEODLLDEF STDAPI SEOTerm(SEOHANDLE shHandle);
SEODLLDEF STDAPI SEOCallBinding(SEOHANDLE shHandle,
								REFGUID guidBindingType,
								LONG lEvent);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\refptr2.h ===
//
// This file contains another implementation of smart pointers.  It is 
// different from the implementation found in smartptr.h because the
// object itself deletes itself when its reference count hits 0.  This
// is similar to the way COM objects are written.
//
#ifndef _SMARTP2_H_
#define _SMARTP2_H_

#include <dbgtrace.h>

//
// A reference counting implementation
//
class CRefCount2 {
protected:
    LONG    m_cRefs;

public: 
    CRefCount2() {
		m_cRefs = 1;
	}
	virtual ~CRefCount2() {
	}

	LONG AddRef() {
    	return InterlockedIncrement(&m_cRefs);
	}
    void Release() {
    	LONG r = InterlockedDecrement(&m_cRefs);
		_ASSERT(r >= 0);
		if (r == 0) delete this;
	}
};

template<class Type> class CRefPtr2;

//
// This is a type of pointer which can be returned by functions.  The only
// valid operation on it is to copy it to a CRefPtr2<Type> pointer.  It 
// tells the CRefPtr2 not to do an AddRef.
//
template<class Type>
class CRefPtr2HasRef {
	protected:
		Type	*m_p;

		CRefPtr2HasRef<Type>& operator=(const CRefPtr2HasRef<Type>& rhs) {
			_ASSERT(FALSE);
			return *this;
		}

		BOOL operator==(CRefPtr2<Type>&rhs) {
			_ASSERT(FALSE);
			return m_p == rhs.m_p;
		}
	
		BOOL operator!=(CRefPtr2<Type>&rhs) {
			_ASSERT(FALSE);
			return m_p != rhs.m_p;
		}

	public:

		//
		//	Do nothing protected constructor !
		//
		CRefPtr2HasRef() : m_p( 0 )	{
		}
	
	    CRefPtr2HasRef(const Type *p ) :
			m_p( (Type*)p )		{
			if (m_p) m_p->AddRef();
		}

	    ~CRefPtr2HasRef() {
			// this pointer always needs to be copied to a CRefPtr2, which
			// should set m_p to NULL
			_ASSERT(m_p == NULL);
		}

		friend class CRefPtr2<Type>;
};

template<class	Type, BOOL	fAddRef>
class	CHasRef : public	CRefPtr2HasRef<Type>	{
public : 

	CHasRef(	const	Type*	p = 0 )	{
		m_p = (Type*)p ;
		if( fAddRef ) {
			if( m_p )
				m_p->AddRef() ;
		}
	}
} ;

template< class Type >
class   CRefPtr2 {
private: 
    Type*  m_p ; 

public : 
    CRefPtr2(const CRefPtr2<Type>& ref) {
		m_p = ref.m_p;
		if (m_p) m_p->AddRef();
	}

	// copy from an intermediate pointer -- we don't need to do an addref
	CRefPtr2(CRefPtr2HasRef<Type> &ref) {
		m_p = ref.m_p;
		ref.m_p = NULL;
	}

    CRefPtr2(const Type *p = 0) {
		m_p = (Type *) p;
		if (m_p) m_p->AddRef();
	}
    
    ~CRefPtr2() {
		if (m_p) m_p->Release();
	}

	CRefPtr2<Type>& operator=(const CRefPtr2<Type>& rhs) {
		if (m_p != rhs.m_p) {
			Type *pTemp = m_p;
			m_p = rhs.m_p;
			if (m_p) m_p->AddRef();
			if (pTemp) pTemp->Release();
		}
		return *this;
	}

	// copy from an intermediate pointer -- we don't need to do an addref
	CRefPtr2<Type>& operator=(CRefPtr2HasRef<Type>& rhs) {
		Type *pTemp = m_p;
		m_p = rhs.m_p;
		if (pTemp) pTemp->Release();
		rhs.m_p = NULL;
		return *this;
	}

	CRefPtr2<Type>& operator=(const Type *rhs) {
		if (m_p != rhs) {
			Type *pTemp = m_p;
			m_p = (Type *) rhs;
			if (m_p) m_p->AddRef();
			if (pTemp) pTemp->Release();
		}
		return *this;
	}

	BOOL operator==(CRefPtr2<Type>&rhs) {
		return m_p == rhs.m_p;
	}

	BOOL operator!=(CRefPtr2<Type>&rhs) {
		return m_p != rhs.m_p;
	}

	BOOL operator==(Type *p) {
		return	m_p == p;
	}

	BOOL operator!=(Type *p) {
		return	m_p != p;
	}

    Type *operator->() const {
    	return  m_p ;
	}

	operator Type*() const {
		return	m_p ;
	}

    BOOL operator!() const {
		return	!m_p ;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\reg_cbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       cbuffer.h
//
//  Contents:   CHAR buffer definitions
//
//  History:    02-16-93    SethuR -- Implemented
//              07-28-94    AlokS  -- Added more methods
//              12-09-97    MilanS -- Ported to Exchange
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef __CBUFFER_H__
#define __CBUFFER_H__

//+---------------------------------------------------------------------
//
// Class:   CCHARBuffer
//
// Purpose: A CHAR buffer
//
// History:
//
// Notes:   Very often we encounter the case in string manipulation wherein
//          the length of the string is less than some value most of the time
//          (99%). However, in order to reliably with the very rare case we
//          are forced to either allocate the string on the heap or alternatively
//          go through some bizarre code that avoids the heap allocation in the
//          common case. This class is an abstraction of a WCHAR buffer and its
//          implementation is an attempt at hiding the detail from all clients.
//
//          As it is designed it is an ideal candidate for a temporary buffer
//          for string manipulation.
//
//----------------------------------------------------------------------

#define MAX_CHAR_BUFFER_SIZE 260 // long enough to cover all path names

class CCHARBuffer
{
public:

    inline CCHARBuffer(ULONG cwBuffer = 0);
    inline ~CCHARBuffer();

    inline DWORD    Size();
    inline PCHAR   ReAlloc(DWORD cwBuffer = MAX_CHAR_BUFFER_SIZE);
    inline void     Set(PWCHAR pwszFrom);
    inline void     Set(PCHAR  pszFrom);
    inline void     Cat(PCHAR pszPlus);

    inline      operator PCHAR ();
    inline      operator PCHAR () const;

    inline void operator  =(PWCHAR pwszFrom)
    {
        Set(pwszFrom);
    };

    inline void operator  =(PCHAR  pszFrom)
    {
        Set(pszFrom);
    };

    inline void operator  +=(PCHAR pszPlus)
    {
        Cat(pszPlus);
    };

private:

    DWORD   _cBuffer;
    PCHAR   pchBuffer;    // buffer ptr;
    CHAR   _achBuffer[MAX_CHAR_BUFFER_SIZE];
};

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::CCHARBuffer, inline public
//
//  Synopsis:   Constructor
//
//  Arguments:  [cBuffer]   -- desired buffer length.
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::CCHARBuffer(ULONG cBuffer) :
                     pchBuffer(NULL),
                     _cBuffer(cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::~CCHARBuffer, inline public
//
//  Synopsis:   Destructor
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::~CCHARBuffer()
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Size, inline public
//
//  Synopsis:   Retrieve the size of the buffer
//
//  Returns:    the size of the buffer as a DWORD
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline DWORD CCHARBuffer::Size()
{
    return _cBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::ReAlloc, inline public
//
//  Synopsis:   Reallocates the buffer to accomdate the newly specified size
//
//  Arguments:  [cBuffer] -- the desired buffer size
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline PCHAR CCHARBuffer::ReAlloc(DWORD cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }

    if ((_cBuffer = cBuffer) > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
    else if (_cBuffer == 0)
    {
        pchBuffer = NULL;
    }

    return pchBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::operator PCHAR (), inline public
//
//  Synopsis:   casting operator to accomdate syntactic sugaring
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::operator PCHAR ()
{
    return (PCHAR)pchBuffer;
}

inline CCHARBuffer::operator PCHAR () const
{
    return (PCHAR)pchBuffer;
}
//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Set, inline public
//
//  Synopsis:   Copies the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pwszFrom] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Set(PWCHAR pwszFrom)
{
    if (pwszFrom==NULL)
    {
        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        _cBuffer=0;
        pchBuffer = NULL;
    }
    else if (*pwszFrom)
    {
        DWORD len = wcslen(pwszFrom)+1;
        if (len > _cBuffer)
        {
            (void)ReAlloc (len);
        }
        // Now copy
        wcstombs(pchBuffer, pwszFrom, len);
    }
    else
    {
        *pchBuffer='\0';
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Set, inline public
//
//  Synopsis:   Copies the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pszFrom] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Set(PCHAR pszFrom)
{
    if (pszFrom==NULL)
    {
        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        _cBuffer=0;
        pchBuffer = NULL;
    }
    else if (*pszFrom)
    {
        DWORD len = strlen(pszFrom)+1;
        if ( len > _cBuffer)
        {
            (void)ReAlloc (len);
        }
        // Now copy
        memcpy(pchBuffer, pszFrom, len);
    }
    else
    {
        *pchBuffer=L'\0';
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Cat, inline public
//
//  Synopsis:   Concatnates the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pszPlus] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Cat(PCHAR pszFrom)
{
    DWORD  len1 = strlen(pchBuffer),
           len2 = strlen(pszFrom),
           len3 = len1+len2 + 1;

    if ( len3 > MAX_CHAR_BUFFER_SIZE)
    {
        PCHAR ptr = new CHAR [len3];
        memcpy(ptr, pchBuffer, len1);

        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        pchBuffer = ptr;
    }
    memcpy( ((LPWSTR)(pchBuffer)+len1), pszFrom, (len2+1) * sizeof(CHAR));
    _cBuffer = len3;
}
#endif // __CBUFFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\replacl.h ===
#ifndef REPLACL_DOT_H
#define REPLACL_DOT_H
/////////////////////////////////
// replacl.h
//////////////////////
// entry points and data definitions
//


// MSN Token Type
#define MST_MSNTOKEN    0
// Common NT SID
#define MST_NTSID       1
// Trusted Name
#define MST_NAME		2

// After all of the children of the SICILY_SD have been
// created, we will copy it to contigous memory allocated
// by the calling process and return it.

#define ANY_SIZE_ARRAY  1

BOOL WINAPI TranslateSecurityDescriptor(
	SECURITY_DESCRIPTOR     *p_sd,
	PBYTE      p_ssd,
	LONG    *sizereq);

BOOL WINAPI ReComposeSecurityDescriptor(
	PBYTE      p_ssd,
	DWORD			c_ssd,
	SECURITY_DESCRIPTOR     *p_sd,
	LONG    *sizereq);

BOOL WINAPI InitializeSrcSicily();
BOOL WINAPI CloseSrcSicily();
BOOL WINAPI InitializeDestSicily();
BOOL WINAPI CloseDestSicily();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\servdefs.h ===
/*--------------------------------------------------------

  servdefs.h
      Contains the global type definitions and constant 
      definitions used for the service & server attributes 
      used on the server-side of the datacenter.

  Copyright (C) 1993 Microsoft Corporation
  All rights reserved.

  Authors:
      rsraghav    R.S. Raghavan

  History:
      01-14-94    rsraghav    Created. 
	  06-05-94	  rsraghav 	  Changed the service state values
	  04-19-95	  rsraghav	  Added IP address definitions

  -------------------------------------------------------*/

#ifndef _SERVDEFS_H_
#define _SERVDEFS_H_

#if defined(DEBUG) && defined(INLINE)
#undef THIS_FILE
static char BASED_CODE SERVDEFS_H[] = "servdefs.h";
#define THIS_FILE SERVDEFS_H
#endif

// Type definitions of server related attributes.
typedef unsigned short MOS_SERVER_ID;	// MSID
typedef unsigned long CPU_INDEX;		// CI
typedef WORD MOS_LOCATE_TYPE;	// MLT
#if !defined(_MHANDLE_DEFINED)
typedef WORD MHANDLE;
typedef WORD HMCONNECT;
typedef WORD HMSESSION;
typedef WORD HMPIPE;
#define _MHANDLE_DEFINED
#endif

// Constants for server values
#define INVALID_MOS_SERVER_ID_VALUE (0xFFF0)
#define msidInvalid (INVALID_MOS_SERVER_ID_VALUE)
#define msidReservedForTest1 (0XFFEF)
#define msidReservedForTest2 (0XFFEE)
#define msidReservedForTest3 (0XFFED)
#define msidReservedForTest4 (0XFFEC)
#define msidReservedForTest5 (0XFFEB)
#define msidReservedForTest6 (0XFFEA)

// Locate redir values.
#define USE_LOCAL_SERVER        				0xffff
#define USE_NO_SERVER           				0xfffe
#define USE_LOAD_BALANCED_LOCATE				0xfffd
#define USE_LOAD_BALANCED_LOCATE_INCLUDE_SELF	0xfffc

// Type definitions of service attributes.
typedef unsigned long SERVICE_STATE; // SS
typedef unsigned long SERVICE_VERSION; // SV

// Type definitions of attachment state.
typedef unsigned long ATTACHMENT_STATE;	// AS

// Constants for service states	(values are kept so that ORing of two states will always give the highest of the two).
// NOTE: This strange number pattern is to reserve 2 bits between each value so that we can add new values without
//       changing the existing values and still be able to OR one or more states and get the highest state.
#define SSINVALID 			(0x00000000)
#define SSSTOPPED 			(0x00000001)
#define SSLAUNCHING 		(0x00000009)
#define SSLAUNCHED 			(0x00000049)
#define SSSYNCHRONIZING		(0x00000249)
#define SSSTOPPING	 		(0x00001249)
#define SSACTIVE	 		(0x00009249)
#define SSACTIVEACCEPTING 	(0x00049249)

// Constants for attachment states.
#define ASATTACHPENDING (0)
#define ASATTACHED		(1)
#define ASDETACHPENDING	(2)

// Constants for service version.  SVANY is used for searching in the Service Map.
#define INVALID_SERVICE_VERSION_VALUE (0xFFFFFFFF)
#define SVDEFAULT	(0)
#define SVANY		(0xFFFFFFFE)

// IP Address related definitions
typedef DWORD 			IPADDRESS; 			// IPA 

#define IPADDRESS_INVALID (0xFFFFFFFF)
#define MAX_IPADDRESS_STRING_LENGTH 16	// xxx.xxx.xxx.xxx format (max of 15 chars + \0)



//////////////////////////////////////////////////////////////////////
// CContext related definitions

// Disconnect cause.
enum CONTEXTCLOSESTATUS
{
    CCS_DATALINKDROP,
    CCS_CLIENTREQ,
    CCS_SRVREQ,
    CCS_SYSOP,
    CCS_COLDREDIR,
    CCS_HOTREDIR,
    CCS_NOP
};
#define PIPE_CLOSED_STATUS CONTEXTCLOSESTATUS


//////////////////////////////////////////////////////////////////////
// CRouter related definitions

#define ROUTER_NC               0
#define ROUTER_CONNECTED        1
#define ROUTER_CLOSING          2
#define ROUTER_IDLE             3
#define ROUTER_WAIT_OPEN        4
#define ROUTER_WAIT_CLOSE       5
#define ROUTER_GHOST            6   // no more available

#define MCP_VERSION_V1          0
#define MCP_VERSION_V2          1   // transmit intl info @ connect
#define MCP_VERSION_V3          2   // transmit intl info @ connect + failed addr
#define MCP_VERSION_V4          3   // transmit MCP config to client
#define MCP_VERSION_V5          4   // nothing new
#define MCP_VERSION_V6          5   // NAK
#define MCP_VERSION_V7          6   // transmit CLVER (client version)
#define MCP_VERSION_CURRENT     MCP_VERSION_V7
#define MCP_VERSION_NA          0x0 // not available

// Disconnect cause.
enum ROUTERUNCONNECTSTATUS
{ 
    RUS_DATALINKDROP,       // data link dropped
    RUS_CLIENTREQ,          // client requested data link drop
    RUS_SRVREQ,             // server requested data link drop
    RUS_SYSOP,              // sysop requested data link drop
    RUS_NOP,
    RUS_DATALINKTIMEOUT,    // inactivity time-out
    RUS_TOOMANYRETRANS,     // too many retransmission
    RUS_PUBLICTIMEOUT,      // public account access timeout
    RUS_TOOMANYPIPES,        // attempt to open too many pipes on a public account
	RUS_TOOMANY_BAD_PACKETS,  // too many back packets from client
	RUS_TRANSPORT_ERROR			  // transport error
};
#define CONNECTION_CLOSED_STATUS ROUTERUNCONNECTSTATUS


#endif // _SERVDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\simauth2.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simauth.h

Abstract:

    This module contains class declarations/definitions for

        CSecurityCtx (some code stolen from internet server)

Revision History:

--*/

#ifndef _SIMAUTH_H_
#define _SIMAUTH_H_


//
// Authentication commands supported
//

typedef enum _AUTH_COMMAND {

    AuthCommandUser,
    AuthCommandPassword,
    AuthCommandReverse,
    AuthCommandTransact,
    AuthCommandInvalid

} AUTH_COMMAND;

//
// struct for each package
//

typedef struct _AUTH_BLOCK
{
    //
    // name of the package
    //
    LPSTR Name;

} AUTH_BLOCK, *PAUTH_BLOCK;


//
// Response IDs for the Converse function.  If the return
// value is anything other than SecNull, the application
// should map these IDs to that appropriate protocol specific
// response string.  If the value is SecNull, the application
// should send the returned data from Converse to the client
// with the appropriate header ( ie +OK ) and trailer ( ie \r\n )
//
typedef enum _REPLY_LIST {
    SecAuthOk,
    SecAuthOkAnon,
    SecProtOk,
    SecNeedPwd,
    SecBadCommand,
    SecSyntaxErr,
    SecPermissionDenied,
    SecNoUsername,
    SecInternalErr,
    SecAuthReq,
    SecProtNS,
    SecNull,
    NUM_SEC_REPLIES
} REPLY_LIST;

enum PKG_REPLY_FMT
{
    PkgFmtSpace,
    PkgFmtCrLf
};


//
// CSecurityContext - user security context class designed to work with any
//  ssp interface. The object have 2 sets of context handles - one for
//  authentication, and one for encrption.  If we are using only one package,
//  then these handles point to the same thing.  This is used to support
//  use of multi-ssp packages like Sicily over SSL.
//

class CSecurityCtx : public TCP_AUTHENT
{

private:

    //
    // Have we been authenticated, if so did we use the
    // anonymous token
    //

    BOOL                m_IsAuthenticated;
    BOOL                m_IsClearText;
    BOOL                m_IsAnonymous;
    BOOL                m_IsGuest;
    BOOL                m_fBase64;      // encoding flag

    static BOOL         m_AllowGuest;
    static BOOL         m_StartAnonymous;

    //
    // storage for login name while waiting for the pswd
    //

    LPSTR               m_LoginName;

    //
    // storage for package name used
    //

    LPSTR               m_PackageName;

    DWORD               m_cProviderPackages;
    LPSTR               m_ProviderNames;
    PAUTH_BLOCK         m_ProviderPackages;

    //
    // Cleartext package name
    //

    char                m_szCleartextPackageName[MAX_PATH];
    char                m_szMembershipBrokerName[MAX_PATH];

    //
    // AUTHENT_INFO needed by k2
    //
    
    TCP_AUTHENT_INFO    m_TCPAuthentInfo;


    DWORD               m_dwInstanceAuthFlags;

    //
    // private member functions used to implement ProcessAuthInfo
    // after some amount of error and parameter checking
    //
    BOOL    ProcessUser(
                IN PIIS_SERVER_INSTANCE pIisInstance,
                IN LPSTR        pszUser,
                OUT REPLY_LIST* pReply
                );

    BOOL    ProcessPass(
                IN PIIS_SERVER_INSTANCE pIisInstance,
                IN LPSTR        pszPass,
                OUT REPLY_LIST* pReply
                );

    BOOL    ProcessTransact(
                IN PIIS_SERVER_INSTANCE pIisInstance,
                IN LPSTR        Blob,
                IN OUT LPBYTE   ReplyString,
                IN OUT PDWORD   ReplySize,
                OUT REPLY_LIST* pReply,
                IN DWORD        BlobLength
                );

    BOOL    MbsBasicLogon(
                IN LPSTR        pszUser,
                IN LPSTR        pszPass,
                OUT BOOL        *pfAsGuest,
                OUT BOOL        *pfAsAnonymous
                );


public:

    CSecurityCtx(
            PIIS_SERVER_INSTANCE pIisInstance,
            DWORD AuthFlags = TCPAUTH_SERVER|TCPAUTH_UUENCODE,
            DWORD InstanceAuthFlags = INET_INFO_AUTH_ANONYMOUS,
            TCP_AUTHENT_INFO *pTcpAuthInfo = NULL
            );

    ~CSecurityCtx();

    //
    // routines used to initialize and terminate use of this class
    //
    static BOOL Initialize(
                        BOOL                    fAllowGuest = TRUE,
                        BOOL                    fStartAnonymous = TRUE
                        );

    static VOID Terminate( VOID );

    BOOL SetInstanceAuthPackageNames(
        DWORD cProviderPackages,
        LPSTR ProviderNames,
        PAUTH_BLOCK ProviderPackages);

    BOOL GetInstanceAuthPackageNames(
        OUT LPBYTE          ReplyString,
        IN OUT PDWORD       ReplySize,
        IN PKG_REPLY_FMT    PkgFmt = PkgFmtSpace);

    //
    // Returns the login name of the user
    //

    LPSTR QueryUserName(void)   { return    m_LoginName; }

    //
    // returns whether session has successfully authenticated
    //

    BOOL IsAuthenticated( void )    { return m_IsAuthenticated; }

    //
    // returns whether session was a clear text logon
    //

    BOOL IsClearText( void )        { return m_IsClearText; }

    //
    // returns whether session logged on as Guest
    //

    BOOL IsGuest( void )            { return m_IsGuest; }

    //
    // returns whether session logged on Anonymously
    //

    BOOL IsAnonymous( void )        { return m_IsAnonymous; }

    //
    // Methods for determining whether MBS should be used
    //

    BOOL ShouldUseMbs( void );

    //
    // Method to set the cleartext package name of the current security context
    //
    VOID    SetCleartextPackageName(
                LPSTR           szCleartextPackageName, 
                LPSTR           szMembershipBrokerName
                );

    //
    // resets the user name
    //

    void Reset( void );

    //
    // set the supported SSPI packages
    // Parameter is the same format as returned by RegQueryValueEx for
    // REG_MULTI_SZ values
    //

    static BOOL SetAuthPackageNames(
            IN LPSTR            lpMultiSzProviders,
            IN DWORD            cchMultiSzProviders
            );

    //
    // different than set in that the packages are returned separated
    // by spaces and only a single terminating NULL.  This is done to 
    // make the response to the client easier to format
    //
    static BOOL GetAuthPackageNames(
            OUT LPBYTE          ReplyString,
            IN OUT PDWORD       ReplySize,
            IN PKG_REPLY_FMT    PkgFmt = PkgFmtSpace
            );

    //
    // Service Principal Name routines for Kerberos authentication. 
    //
    // A SPN is a name for a server that a client and server can independantly 
    // compute (ie, compute it without communicating with each other). Only 
    // then is mutual auth possible. 
    //
    // Here, we take the approach of using the stringized IP addrs returned by
    // doing a gethostbyname on the FQDN as the identifying part of SPNs. 
    // Since the clients connecting to this server know which IP they are using,
    // they too can indepedently generate the SPN.
    //
    // So, the usage of the methods below is:
    //
    // 1. On service startup, call ResetServicePrincipalNames.
    //      This cleans up all SPNs for the service registered on the local
    //      computer account.
    //
    // 2. On each virtual server startup, call RegisterServicePrincipalNames
    //      with the FQDN of that virtual server. This causes new SPNs to be
    //      registered on the local computer account.
    //
    // 3. When acting as a client (eg, SMTP outbound), call 
    //    SetTargetPrincipalName, passing in the IP address of the remote server
    //
    // 4. If desired, one may call ResetServicePrincipalNames on service 
    //    (NOT virtual server!) shutdown. This will unregister the SPNs for all
    //    virtual servers of that type.
    //
    // In all cases, szServiceClass is a service specific string, like "SMTP"
    //

    static BOOL ResetServicePrincipalNames(
            IN LPCSTR           szServiceType);

    static BOOL RegisterServicePrincipalNames(
            IN LPCSTR           szServiceType,
            IN LPCSTR           szFQDN);

    BOOL SetTargetPrincipalName(
            IN LPCSTR           szServiceType,
            IN LPCSTR           szTargetIP);

    // 
    // external interface for initiating a client-side AUTH protocol exchange.
    // You should use this instead of TCP_AUTHENT::Converse or 
    // TCP_AUTHENT::ConverseEx because it gives this object a chance to map
    // Internet security protocol names to NT package names (eg, from GSSAPI to
    // Negotiate)
    //
    BOOL ClientConverse( 
            IN VOID *           pBuffIn,
            IN DWORD            cbBuffIn,
            OUT BUFFER *        pbuffOut,
            OUT DWORD *         pcbBuffOut,
            OUT BOOL *          pfNeedMoreData,
            IN PTCP_AUTHENT_INFO pTAI,
            IN CHAR *           pszPackage  = NULL,
            IN CHAR *           pszUser     = NULL,
            IN CHAR *           pszPassword = NULL,
            IN PIIS_SERVER_INSTANCE psi = NULL );

    
    //
    // external interface for passing blobs received as part of AUTHINFO
    // or AUTH processing
    //
    BOOL ProcessAuthInfo(
            IN PIIS_SERVER_INSTANCE pIisInstance,
            IN AUTH_COMMAND     Command,
            IN LPSTR            Blob,
            IN OUT LPBYTE       ReplyString,
            IN OUT PDWORD       ReplySize,
            OUT REPLY_LIST*     pReplyListID,
            IN OPTIONAL DWORD   BlobLength = 0
            );


}; // CSecurityCtx


#endif  // _SIMAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\simssl2.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simssl.h

Abstract:

    This module contains class declarations/definitions for

        CEncryptCtx (some code stolen from internet server)

Revision History:

--*/

#ifndef _SIMSSL_H_
#define _SIMSSL_H_


class CEncryptCtx
{

private:

    //
    // is this the client side
    //

    BOOL                m_IsClient;

    //
    // indicates whether we are starting a new session
    //

    BOOL                m_IsNewSSLSession;

    //
    // should this session be encypted
    //

    BOOL                m_IsEncrypted;

    //
    // Handle to user's security context for encryption
    //

    CtxtHandle          m_hSealCtxt;

    //
    // Pointers to cached credential blocks
    //

    //
    //  Array of credential handles - Note this comes form the credential cache
    //  and should not be deleted.  m_phCredInUse is the pointer to the
    //  credential handle that is in use
    //

    PVOID               m_phCreds;

    CredHandle*         m_phCredInUse;
    DWORD               m_iCredInUse;

    //
    // ecryption header and trailer lengths
    //

    DWORD               m_cbSealHeaderSize;
    DWORD               m_cbSealTrailerSize;

    //
    // indicates whether we have context handles opened
    //

    BOOL                m_haveSSLCtxtHandle;

    //
    // Have we been authenticated ? we will consider an
    // SSL session to be authenticated, if we have a non-null
    // NT token.
    //

    BOOL                m_IsAuthenticated;

    //
    // SSL access perms - should we map client certs to NT accounts
    //

    DWORD               m_dwSslAccessPerms;

    //
    // NT token - non-NULL if client cert was mapped successfully
    //

    HANDLE              m_hSSPToken;

    //
    // Key size used - 40 bit vs 128 bit etc
    //

    DWORD               m_dwKeySize;
    
    //
    // Have we been authenticated, if so did we use the
    // anonymous token
    //

    static BOOL         m_IsSecureCapable;

    //
    // static variables used by all class instances
    //

    static WCHAR    wszServiceName[16];
#if 0
    static char szLsaPrefix[16];
#endif

    //
    // hSecurity - NULL when security.dll/secur32.dll  is not loaded
    //
    static HINSTANCE    m_hSecurity;

    //
    // hLsa - NULL for Win95, set for NT
    //
    static HINSTANCE    m_hLsa;

    //
    // shared context callback for instance mapper
    //
    static PVOID        m_psmcMapContext;
    
    //
    // internal routine to implement public Converse
    //

    DWORD EncryptConverse(
            IN PVOID        InBuffer,
            IN DWORD        InBufferSize,
            OUT LPBYTE      OutBuffer,
            OUT PDWORD      OutBufferSize,
            OUT PBOOL       MoreBlobsExpected,
            IN CredHandle*  pCredHandle,
            OUT PULONG      pcbExtra
            );

public:

    CEncryptCtx( BOOL IsClient = FALSE, DWORD dwSslAccessPerms = 0 );
    ~CEncryptCtx();

    //
    // routines used to initialize and terminate use of this class
    //

    static BOOL WINAPI Initialize(  LPSTR   pszServiceName,
                                    IMDCOM* pImdcom,
                                    PVOID   psmcMapContext = NULL,
                                    PVOID   pvAdminBase = NULL /*,
                            LPSTR pszLsaPrefix */ );

    static VOID WINAPI Terminate( VOID );

    //
    // routine to set the magic bits required by the IIS Admin tool
    //

    static void WINAPI GetAdminInfoEncryptCaps( PDWORD pdwEncCaps );

    //
    // returns whether sspi packages and credentials have been installed
    //

    static BOOL IsSecureCapable( void ) { return m_IsSecureCapable; }

    //
    // returns whether session is encrypted or not
    //

    BOOL IsEncrypted( void )            { return m_IsEncrypted; }

    //
    // returns whether session has successfully authenticated
    //

    BOOL IsAuthenticated( void )        { return m_IsAuthenticated; }

    //
    // returns key size used in SSL session
    //

    DWORD QueryKeySize()    { return m_dwKeySize; }
    
    //
    // Encryption routines
    //

    BOOL WINAPI SealMessage(
                    IN LPBYTE   Message,
                    IN DWORD    cbMessage,
                    OUT LPBYTE  pbuffOut,
                    OUT DWORD  *pcbBuffOut
                    );

    BOOL WINAPI UnsealMessage(
                    IN LPBYTE Message,
                    IN DWORD cbMessage,
                    OUT LPBYTE *DecryptedMessage,
                    OUT PDWORD DecryptedMessageSize,
                    OUT PDWORD ExpectedMessageSize,
                    OUT LPBYTE *NextSealMessage = NULL
                    );

    //
    // SSL specific routines.  This is used for processing SSL negotiation
    // packets.
    //

    DWORD WINAPI Converse(
            IN PVOID    InBuffer,
            IN DWORD    InBufferSize,
            OUT LPBYTE  OutBuffer,
            OUT PDWORD  OutBufferSize,
            OUT PBOOL   MoreBlobsExpected,
            IN LPSTR    LocalIpAddr,
            IN LPSTR    LocalPort,
            IN LPVOID   lpvInstance,
            IN DWORD    dwInstance,
            OUT PULONG  pcbExtra
            );

    //
    // resets the user name
    //

    void WINAPI Reset( void );

    //
    // returns the size of the encryption header for this session
    //
    DWORD GetSealHeaderSize( void )
        { return    m_haveSSLCtxtHandle ? m_cbSealHeaderSize : 0 ; }

    //
    // returns the size of the encryption trailer for this session
    //
    DWORD GetSealTrailerSize( void )
        { return    m_haveSSLCtxtHandle ? m_cbSealTrailerSize : 0 ; }

    //
    // return the NT token mapped from the client cert
    //

    HANDLE QueryCertificateToken() { return m_hSSPToken; }
    
    //
    // decrypts read buffer, concatenating all decrypted data at the
    // head of the buffer.
    //
    DWORD WINAPI DecryptInputBuffer(
                IN LPBYTE   pBuffer,
                IN DWORD    cbInBuffer,
                OUT DWORD*  pcbOutBuffer,
                OUT DWORD*  pcbParsable,
                OUT DWORD*  pcbExpected
            );

    //
    //  verifies the intended host name matches the name contained in the cert
    //  This function, checks a given hostname against the current certificate
    //  stored in an active SSPI Context Handle. If the certificate containts
    //  a common name, and it matches the passed in hostname, this function
    //  will return TRUE.
    //
    BOOL CheckCertificateCommonName(
                IN LPSTR pszHostName
            );

    BOOL CheckCertificateSubjectName(
                IN LPSTR pszHostName
            );
    //
    //  Check if the certificate is issued by a trusted authority
    //
    BOOL CheckCertificateTrust();

    //
    //  verifies the ccertificate has not expired
    //  returns TRUE if the cert is valid
    //
    BOOL CheckCertificateExpired(
                void
            );

    //
    //  check that a server cert is installed
    //

    BOOL CheckServerCert(
            IN LPSTR    LocalIpAddr,
            IN LPSTR    LocalPort,
            IN LPVOID   lpvInstance,
            IN DWORD    dwInstance);

}; // CSslCtx

//
// blkcred.cpp
//

#endif  // _SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\simssl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simssl.h

Abstract:

    This module contains class declarations/definitions for

        CEncryptCtx (some code stolen from internet server)

Revision History:

--*/

#ifndef	_SIMSSL_H_
#define	_SIMSSL_H_



class CEncryptCtx
{

private:

    //
    // is this the client side
    //

    BOOL                m_IsClient;

    //
    // indicates whether we are starting a new session
    //

    BOOL                m_IsNewSSLSession;

    //
    // should this session be encypted
    //

    BOOL                m_IsEncrypted;

    //
    // Handle to user's security context for encryption
    //

    CtxtHandle          m_hSealCtxt;

    //
    // Pointers to cached credential blocks
    //

    //
    //  Array of credential handles - Note this comes form the credential cache
    //  and should not be deleted.  m_phCredInUse is the pointer to the
    //  credential handle that is in use
    //

    PVOID				m_phCreds;

    CredHandle*			m_phCredInUse;
    DWORD				m_iCredInUse;

	//
	// ecryption header and trailer lengths
	//

	DWORD				m_cbSealHeaderSize;
	DWORD				m_cbSealTrailerSize;

    //
    // indicates whether we have context handles opened
    //

    BOOL                m_haveSSLCtxtHandle;

    //
    // Have we been authenticated, if so did we use the
    // anonymous token
    //

    BOOL                m_IsAuthenticated;

    //
    // Have we been authenticated, if so did we use the
    // anonymous token
    //

    static BOOL			m_IsSecureCapable;

	//
	// static variables used by all class instances
	//

	static char	szServiceName[16];
	static char	szLsaPrefix[16];

	//
	// hSecurity - NULL when security.dll/secur32.dll  is not loaded
	//
	static HINSTANCE	m_hSecurity;

	//
	// hLsa - NULL for Win95, set for NT
	//
	static HINSTANCE	m_hLsa;

	//
	// internal routine to implement public Converse
	//

    DWORD EncryptConverse(
            IN PVOID		InBuffer,
            IN DWORD		InBufferSize,
            OUT LPBYTE		OutBuffer,
            OUT PDWORD		OutBufferSize,
            OUT PBOOL		MoreBlobsExpected,
			IN CredHandle*	pCredHandle
            );


public:

    CEncryptCtx( BOOL IsClient = FALSE );
    ~CEncryptCtx();

	//
	// routines used to initialize and terminate use of this class
	//

	static BOOL WINAPI Initialize(	LPSTR pszServiceName,
							LPSTR pszLsaPrefix );

	static VOID WINAPI Terminate( VOID );

	//
	// routine to set the magic bits required by the IIS Admin tool
	//

	static void WINAPI GetAdminInfoEncryptCaps( PDWORD pdwEncCaps );

    //
    // returns whether sspi packages and credentials have been installed
    //

	static BOOL IsSecureCapable( void )	{ return m_IsSecureCapable; }

    //
    // returns whether session is encrypted or not
    //

    BOOL IsEncrypted( void )			{ return m_IsEncrypted; }

    //
    // returns whether session has successfully authenticated
    //

	BOOL IsAuthenticated( void )		{ return m_IsAuthenticated; }

    //
    // Encryption routines
    //

    BOOL WINAPI SealMessage(
                    IN LPBYTE	Message,
                    IN DWORD	cbMessage,
                    OUT LPBYTE	pbuffOut,
                    OUT DWORD  *pcbBuffOut
                    );

    BOOL WINAPI UnsealMessage(
                    IN LPBYTE Message,
                    IN DWORD cbMessage,
                    OUT LPBYTE *DecryptedMessage,
                    OUT PDWORD DecryptedMessageSize,
					OUT PDWORD ExpectedMessageSize,
                    OUT LPBYTE *NextSealMessage = NULL
                    );

    //
    // SSL specific routines.  This is used for processing SSL negotiation
    // packets.
    //

    DWORD WINAPI Converse(
            IN PVOID    InBuffer,
            IN DWORD    InBufferSize,
            OUT LPBYTE  OutBuffer,
            OUT PDWORD  OutBufferSize,
            OUT PBOOL   MoreBlobsExpected,
			IN LPSTR	LocalIpAddr = "127.0.0.1"
            );

	//
	// resets the user name
	//

	void WINAPI Reset( void );

	//
	// returns the size of the encryption header for this session
	//
	DWORD GetSealHeaderSize( void )
		{ return	m_haveSSLCtxtHandle ? m_cbSealHeaderSize : 0 ; }

	//
	// returns the size of the encryption trailer for this session
	//
	DWORD GetSealTrailerSize( void )
		{ return	m_haveSSLCtxtHandle ? m_cbSealTrailerSize : 0 ; }

	//
	// decrypts read buffer, concatenating all decrypted data at the
	// head of the buffer.
	//
	DWORD WINAPI DecryptInputBuffer(
                IN LPBYTE	pBuffer,
                IN DWORD	cbInBuffer,
                OUT DWORD*	pcbOutBuffer,
                OUT DWORD*	pcbParsable,
                OUT DWORD*	pcbExpected
			);

	//
	//  verifies the intended host name matches the name contained in the cert
	//  This function, checks a given hostname against the current certificate
	//  stored in an active SSPI Context Handle. If the certificate containts
	//  a common name, and it matches the passed in hostname, this function
	//  will return TRUE.
	//
	BOOL CheckCertificateCommonName(
				IN LPSTR pszHostName
			);


	//
	//	verifies the ccertificate has not expired
	//	returns TRUE if the cert is valid
	//
	BOOL CheckCertificateExpired(
				void
			);

}; // CSslCtx

//
// blkcred.cpp
//

#endif  // _SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\simauth.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simauth.h

Abstract:

    This module contains class declarations/definitions for

        CSecurityCtx (some code stolen from internet server)

Revision History:

--*/

#ifndef _SIMAUTH_H_
#define _SIMAUTH_H_


//
// Authentication commands supported
//

typedef enum _AUTH_COMMAND {

    AuthCommandUser,
    AuthCommandPassword,
    AuthCommandReverse,
    AuthCommandTransact,
    AuthCommandInvalid

} AUTH_COMMAND;


//
// Response IDs for the Converse function.  If the return
// value is anything other than SecNull, the application
// should map these IDs to that appropriate protocol specific
// response string.  If the value is SecNull, the application
// should send the returned data from Converse to the client
// with the appropriate header ( ie +OK ) and trailer ( ie \r\n )
//
typedef enum _REPLY_LIST {
    SecAuthOk,
    SecAuthOkAnon,
    SecProtOk,
    SecNeedPwd,
    SecBadCommand,
    SecSyntaxErr,
    SecPermissionDenied,
    SecNoUsername,
    SecInternalErr,
    SecAuthReq,
    SecProtNS,
    SecNull,
    NUM_SEC_REPLIES
} REPLY_LIST;

enum PKG_REPLY_FMT
{
    PkgFmtSpace,
    PkgFmtCrLf
};


//
// CSecurityContext - user security context class designed to work with any
//  ssp interface. The object have 2 sets of context handles - one for
//  authentication, and one for encrption.  If we are using only one package,
//  then these handles point to the same thing.  This is used to support
//  use of multi-ssp packages like Sicily over SSL.
//

class CSecurityCtx : public TCP_AUTHENT
{

private:

    //
    // Have we been authenticated, if so did we use the
    // anonymous token
    //

    BOOL                m_IsAuthenticated;
    BOOL                m_IsClearText;
    BOOL                m_IsAnonymous;
    BOOL                m_IsGuest;

    static BOOL         m_AllowGuest;
    static BOOL         m_StartAnonymous;

    //
    // storage for login name while waiting for the pswd
    //

    LPSTR               m_LoginName;

    //
    // storage for package name used
    //

    LPSTR               m_PackageName;

    //
    // static variables used by all class instances
    //

    static LPTSVC_INFO  m_pTsvcInfo;

    //
    // private member functions used to implement ProcessAuthInfo
    // after some amount of error and parameter checking
    //
    BOOL    ProcessUser(
                IN LPSTR        pszUser,
                OUT REPLY_LIST* pReply
                );

    BOOL    ProcessPass(
                IN LPSTR        pszPass,
                OUT REPLY_LIST* pReply
                );

    BOOL    ProcessTransact(
                IN LPSTR        Blob,
                IN OUT LPBYTE   ReplyString,
                IN OUT PDWORD   ReplySize,
                OUT REPLY_LIST* pReply,
                IN DWORD        BlobLength
                );



public:

    CSecurityCtx(
            DWORD AuthFlags = TCPAUTH_SERVER|TCPAUTH_UUENCODE
            );

    ~CSecurityCtx();

    //
    // routines used to initialize and terminate use of this class
    //
    static BOOL Initialize(
                        LPTSVC_INFO pTsvcInfo,
                        BOOL        fAllowGuest = TRUE,
                        BOOL        fStartAnonymous = TRUE
                        );

    static VOID Terminate( VOID );


    //
    // Returns the login name of the user
    //

    LPSTR QueryUserName(void)   { return    m_LoginName; }

    //
    // returns whether session has successfully authenticated
    //

    BOOL IsAuthenticated( void )    { return m_IsAuthenticated; }

    //
    // returns whether session was a clear text logon
    //

    BOOL IsClearText( void )        { return m_IsClearText; }

    //
    // returns whether session logged on as Guest
    //

    BOOL IsGuest( void )            { return m_IsGuest; }

    //
    // returns whether session logged on Anonymously
    //

    BOOL IsAnonymous( void )        { return m_IsAnonymous; }

    //
    // resets the user name
    //

    void Reset( void );

    //
    // set the supported SSPI packages
    // Parameter is the same format as returned by RegQueryValueEx for
    // REG_MULTI_SZ values
    //

    static BOOL SetAuthPackageNames(
            IN LPSTR            lpMultiSzProviders,
            IN DWORD            cchMultiSzProviders
            );

    //
    // different than set in that the packages are returned separated
    // by spaces and only a single terminating NULL.  This is done to 
    // make the response to the client easier to format
    //
    static BOOL GetAuthPackageNames(
            OUT LPBYTE          ReplyString,
            IN OUT PDWORD       ReplySize,
            IN PKG_REPLY_FMT    PkgFmt = PkgFmtSpace
            );

    //
    // Service Principal Name routines for Kerberos authentication. 
    //
    // A SPN is a name for a server that a client and server can independantly 
    // compute (ie, compute it without communicating with each other). Only 
    // then is mutual auth possible. 
    //
    // Here, we take the approach of using the stringized IP addrs returned by
    // doing a gethostbyname on the FQDN as the identifying part of SPNs. 
    // Since the clients connecting to this server know which IP they are using,
    // they too can indepedently generate the SPN.
    //
    // So, the usage of the methods below is:
    //
    // 1. On service startup, call ResetServicePrincipalNames.
    //      This cleans up all SPNs for the service registered on the local
    //      computer account.
    //
    // 2. On each virtual server startup, call RegisterServicePrincipalNames
    //      with the FQDN of that virtual server. This causes new SPNs to be
    //      registered on the local computer account.
    //
    // 3. When acting as a client (eg, SMTP outbound), call 
    //    SetTargetPrincipalName, passing in the IP address of the remote server
    //
    // 4. If desired, one may call ResetServicePrincipalNames on service 
    //    (NOT virtual server!) shutdown. This will unregister the SPNs for all
    //    virtual servers of that type.
    //
    // In all cases, szServiceClass is a service specific string, like "SMTP"
    //

    static BOOL ResetServicePrincipalNames(
            IN LPCSTR           szServiceType);

    static BOOL RegisterServicePrincipalNames(
            IN LPCSTR           szServiceType,
            IN LPCSTR           szFQDN);

    BOOL SetTargetPrincipalName(
            IN LPCSTR           szServiceType,
            IN LPCSTR           szTargetIP);

    //
    // external interface for passing blobs received as part of AUTHINFO
    // or AUTH processing
    //
    BOOL ProcessAuthInfo(
            IN AUTH_COMMAND     Command,
            IN LPSTR            Blob,
            IN OUT LPBYTE       ReplyString,
            IN OUT PDWORD       ReplySize,
            OUT REPLY_LIST*     pReplyListID,
            IN OPTIONAL DWORD   BlobLength = 0
            );


}; // CSecurityCtx


#endif  // _SIMAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\setuplib.h ===
#include <lodctr.h>
#include <unlodctr.h>

extern "C"
{
    int unlodctr( HKEY hkey, LPWSTR lpArg );
    int lodctr( HKEY hkey, LPWSTR lpIniFile );
}

/*++

  This function calls the service controller to create a new service.

  Arguments:
    pszServiceName  pointer to service name
    pszDisplayName  pointer to Display name
    pszPath			pointer to null-terminated string containing the path for 
					the service DLL.

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
CreateServiceEntry( IN char * pszServiceName,
                    IN char * pszDisplayName,
                    IN char * pszPath);


/*++

  This function calls the service controller to create a new service.

  Arguments:
    pszServiceName  pointer to service name
    pszDisplayName  pointer to Display name
    pszPath    pointer to null-terminated string containing the path for
                 the service DLL.
	dwServiceType   type of service
	pszDependencies pointer to array of dependency names
	pszServiceStartName  pointer to account name of service

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
CreateServiceEntry( IN char * pszServiceName,
                    IN char * pszDisplayName,
                    IN char * pszPath,
					IN DWORD  dwServiceType,
					IN char * pszDependencies,
					IN char * pszServiceStartName);

/*++

  This function calls the service controller to create a new service.

  Arguments:
    pszServiceName  pointer to service name
    pszDisplayName  pointer to Display name
    pszPath    pointer to null-terminated string containing the path for
                 the service DLL.
	dwServiceType   type of service
	pszDependencies pointer to array of dependency names
	pszServiceStartName  pointer to account name of service
	pszPassword  pointer to account password of service

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
CreateServiceEntry( IN char * pszServiceName,
                    IN char * pszDisplayName,
                    IN char * pszPath,
					IN DWORD  dwServiceType,
					IN char * pszDependencies,
					IN char * pszServiceStartName,
					IN char * pszPassword);

/*++

  This function calls the service controller to delete a 
  existing service.

  Arguments:
    pszServiceName  pointer to service name

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
DeleteServiceEntry( IN char * pszServiceName);

/*++

  This function calls the service controller to stop a 
  running service.

  Arguments:
    hService  service handle to server to stop

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
StopService( IN char * pszServiceName );

/*++

  This function calls the service controller to check if 
  a service is running.

  Arguments:
    lpszServiceName		Name of the service to check

  Returns:

    TRUE if it is running and FALSE otherwise.

--*/
BOOL
fIsServiceRunning(LPSTR lpszServiceName);

/*++

  This function adds the service to the list of services that
  inetinfo.exe will support.

  Arguments:
    pszServiceName  pointer to service name

  Returns:
    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

  Comments:
	Note that inetinfo.exe reads this value only at startup,
	therefore, inetinfo.exe must be restarted before this
	change will take effect.

--*/
BOOL
AddInetinfoService(IN LPSTR pszServiceName);

/*++

  This function removes a service from the list of services that
  inetinfo.exe will support.

  Arguments:
    pszServiceName  pointer to service name

  Returns:
    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

  Comments:

--*/
BOOL
RemoveInetinfoService(IN LPSTR pszServiceName);

/*++

  This function searches for inetinfo.exe services that are 
  running and returns a list separated by '\n' and terminated
  by '\n\0'.
  
  Arguments:
    lpSvcList	pointer to buffer to receive list
	cbMax		max size of buffer
	
  Returns:
    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
DetectRunningServicesEx(IN LPSTR lpSvcList,IN INT cbMax,IN LPSTR lpExtraSvcList);

/*++

  This function searches for inetinfo.exe services that are 
  running and returns a list separated by '\n' and terminated
  by '\n\0'.
  
  Arguments:
    lpSvcList	pointer to buffer to receive list
	cbMax		max size of buffer
	
  Returns:
    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
DetectRunningServices(IN LPSTR lpSvcList,IN INT cbMax);

/*++

  This function registers or unregisters a network service.
  
  Arguments:
	pszMachine			pointer to machine name
	pszServiceName		pointer to service name
	pGuid				pointer to service GUID
	SapId				service SAP ID (use zero)
	TcpPort				service TCP port number
	pszAnonPwdSecret	service anonymous user secret name
	pszAnonPwd			service anonymous user password
	pszRootPwdSecret	service root password secret name
	pszRootPwd			service root password
	fAdd				TRUE - add service, FALSE - remove service
	fSetSecretPasswd	TRUE - set passwords

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL 
PerformSetService( IN LPSTR	pszMachine,
                   IN LPSTR	pszServiceName,
                   IN GUID *	pGuid,
                   IN DWORD		SapId,
                   IN DWORD		TcpPort,
                   IN LPWSTR	pszAnonPwdSecret,
                   IN LPWSTR	pszAnonPwd,
                   IN LPWSTR	pszRootPwdSecret,
                   IN LPWSTR	pszRootPwd,
                   IN BOOL		fAdd,
                   IN BOOL		fSetSecretPasswd );

/*++

  This function installs a SNMP agent to the registry
  
  Arguments:
	hKey		key handle under which agent is added (HKEY_LOCAL_MACHINE)
	lpcName		pointer to the name of the service whos agent is being installed
	lpcPath		pointer to the path of the service extension agent DLL

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
void InstallAgent( HKEY hKey, LPCSTR lpcName, LPCSTR lpcPath );

/*++

  This function removes a SNMP agent
  
  Arguments:
	hKey		key handle under which agent is located (HKEY_LOCAL_MACHINE)
	lpcName		pointer to the name of the service whos agent is being removed

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
void RemoveAgent(  HKEY hKey, LPCSTR lpcName );


/*++

  This function registers the service's performance dll information.
  This function DOES NOT load the performance counters.
  
  Arguments:
	hKey		key handle, use HKEY_LOCAL_MACHINE for local machine
	lpcName		pointer to the name of the service
	lpcDll		pointer to service's performance dll
    lpcOpen		pointer to open api name
    lpcClose	pointer to close api name
    lpcCollect	pointer to collect api name

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
void InstallPerformance( IN HKEY hKey,
                IN LPCSTR lpcName,
                IN LPCSTR lpcDll,
                IN LPCSTR lpcOpen,
                IN LPCSTR lpcClose,
                IN LPCSTR lpcCollect );

/*++

  This function removes the service's performance DLL information.
  
  Arguments:
	hKey		key handle, use HKEY_LOCAL_MACHINE for local machine
	lpcName		pointer to the name of the service

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
void RemovePerformance( IN HKEY hKey,
                IN LPCSTR lpcName );

/*++

  This function registers the service's event log information.
  
  Arguments:
	hKey		key handle, use HKEY_LOCAL_MACHINE for local machine
	lpcName		pointer to the name of the service
	lpcMsgFile	pointer to service's message dll
    dwType		types supported

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL 
InstallEventLog(IN HKEY hKey, 
				IN LPCSTR lpcName, 
				IN LPCSTR lpcMsgFile, 
				IN DWORD dwType );

/*++

  This function registers the service's event log information.
  
  Arguments:
	hKey		key handle, use HKEY_LOCAL_MACHINE for local machine
	lpcName		pointer to the name of the service
	lpcMsgFile	pointer to service's message dll
    dwType		types supported
	dwLogType	Type of log entry: 0="System", 1="Security", or 2="Application"

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL 
InstallEventLog(IN HKEY hKey, 
				IN LPCSTR lpcName, 
				IN LPCSTR lpcMsgFile, 
				IN DWORD dwType,
				IN DWORD dwLogType);

/*++

  This function removes the service's event log information.
  
  Arguments:
	hKey		key handle, use HKEY_LOCAL_MACHINE for local machine
	lpcName		pointer to the name of the service

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
void 
RemoveEventLog( IN HKEY hKey, 
				IN LPCSTR lpcName );

/*++

  This function removes the service's event log information.
  
  Arguments:
	hKey		key handle, use HKEY_LOCAL_MACHINE for local machine
	lpcName		pointer to the name of the service
	dwLogType	Type of log entry: 0="System", 1="Security", or 2="Application"

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
void RemoveEventLog( HKEY hKey, LPCSTR lpcName, DWORD dwLogType );

/*++

  This function retrieves the install path for IIS 2.0
  
  Arguments:
	lpszPath	pointer to buffer to receive path
	cbMax		max size of buffer including null terminator

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

  Comments:
	To be used from an InstallShield3 script, this function 
	must be wrapped in a exported function that uses the C 
	calling convention.

	For example:

	extern "C" INT GetIISInstallPath(LPSTR lpszPath,INT cbMax)
	{
		return libGetIISInstallPath(lpszPath,cbMax);
	}

--*/
INT libGetIISInstallPath(LPSTR lpszPath,INT cbMax);

/*++

  This function retrieves the version info for the OS.
  
  Arguments:
	lpnPlatformId	pointer to buffer to receive the PlateformId
	lpnMajor		pointer to buffer to receive the Major version number
	lpnMinor		pointer to buffer to receive the Minor version number
	lpnBuild		pointer to buffer to receive the Build number
	lpnServicePack	pointer to buffer to receive the service pack number

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

  Comments:
	To be used from an InstallShield3 script, this function 
	must be wrapped in a exported function that uses the C 
	calling convention.

	For example:

	extern "C" INT GetOSVersionInfo(INT *lpnPlatformId, 
						INT *lpnBuild, 
						INT *lpnServicePack)
	{
		return libGetOSVersionInfo(lpnPlatformId, 
						lpnBuild, 
						lpnServicePack);
	}

  See also: GetVersionEx, OSVERSIONINFO

--*/
INT 
libGetOSVersionInfoEx(INT *lpnPlatformId, 
					  INT *lpnMajor,
					  INT *lpnMinor,
					  INT *lpnBuild, 
					  INT *lpnServicePack);
/*++
	Same as above but without nMajor and nMinor.
--*/
INT 
libGetOSVersionInfo(INT *lpnPlatformId, 
					INT *lpnBuild, 
					INT *lpnServicePack);


/*++

  This function gets the anonymous user and password used
  by the installed IIS services.
  
  Arguments:
	lpszUser	pointer to buffer to receive user name
	lpszPass	pointer to buffer to receive password

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
GetAnonymousUserPass(IN LPSTR lpszUser, 
					 IN LPSTR lpszPass);

/*++

  This function sets the anonymous user for a service.
  
  Arguments:
	lpszSvc		pointer to service name
	lpszUser	pointer to user name

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL 
SetAnonymousUser(IN LPSTR lpszSvc,
				 IN LPSTR lpszUser);

//
// Handy reg utility functions
//
LONG RegSetSZ(HKEY hKey,LPSTR lpszName,LPSTR lpszValue);
LONG RegSetDWORD(HKEY hKey,LPSTR lpszName,DWORD dwValue);
LONG RegSetMULTI_SZ(HKEY hKey, LPSTR szName, LPSTR szValue);
// same as RegDeleteKey except will delete all subkeys
LONG RegDeleteTree(HKEY hKey, LPCSTR lpszKeyName);

//+---------------------------------------------------------------------------
//
//  Function:   AppendRegKey
//
//  Synopsis:	Append a value to a comma-separated registry key string
//
//  Arguments:	[szRegKey]
//		[szRegSubkey]
//		[szRegValue]
//
//  Returns:	TRUE for success, FALSE for failure
//
//  History:    11/19/95     RobLeit    Created
//
//----------------------------------------------------------------------------
BOOL AppendRegKey(char *szRegKey, char *szRegSubkey, char *szRegValue);

//+---------------------------------------------------------------------------
//
//  Function:   UnAppendRegKey
//
//  Synopsis:	Remove the value from the comma separated string,
//				if it is there (undo AppendRegKey)
//
//  Arguments:	[szRegKey]
//		[szRegSubkey]
//		[szRegValue]
//
//  Returns:	TRUE for success, FALSE for failure
//
//  History:    11/27/95     RobLeit    Created
//
//  Notes:	
//
//----------------------------------------------------------------------------
BOOL UnAppendRegKey(char *szRegKey, char *szRegSubkey, char *szRegValue);

//+----------------------------------------------------------------------
//
//	Function:	IsDomainController
//
//	Synopsis:	This function checks if local machine is a
//			primary or backup domain controller (PDC or BDC)
//
//	Arguments: 	None
//
//	Returns:	BOOL - TRUE is it is a DC
//
//	History:	RobLeit	Created	1/25/96
//
//-----------------------------------------------------------------------
BOOL 
IsDomainController();

//+----------------------------------------------------------------------
//
//	Function:	GetDomainName
//
//	Synopsis:	This function gets the domain name for the local
//			machine.
//
//	Arguments: 	strDomain - where to store the domain
//			pcchDomain -	IN: size of strDomain array
//					OUT: length of strDomain string
//
//	Returns:	void
//
//	Comments:	From KB, PSS ID Number: Q111544
//
//	History:	RobLeit	Created	1/25/96
//
//-----------------------------------------------------------------------
void
GetDomainName(LPSTR	strDomain,LPDWORD pcchDomain);

//+----------------------------------------------------------------------
// BOOL IsAdmin(void)
// 
//   returns TRUE if user is an admin
//   FALSE if user is not an admin
//
//   PSS ID Number: Q118626
//+----------------------------------------------------------------------

BOOL IsAdmin(void);

//+----------------------------------------------------------------------
//
//	Function:	CheckAccount
//
//	Synopsis:	This function checks that the account exists in the given
//			domain.
//
//	Arguments: 	szUsername - User name
//				szDomain - Domain: may be NULL for local domain
//
//	Returns:	BOOL
//
//	History:	RobLeit	Created	1/25/96
//
//-----------------------------------------------------------------------
BOOL CheckAccount(char *szUsername,
				  char *szDomain);

//+----------------------------------------------------------------------
//
//	Function:	CreateGuestAccount
//
//	Synopsis:	This function creates an account in the given domain,
//				with privileges equivalent to guest
//
//	Arguments: 	szUsername - User name
//				szFullName - Full name of user
//				szComment - Account comment
//				szDomain - Domain: may be NULL for local domain
//				szPassword - Account password
//
//	Returns:	BOOL
//
//	History:	RobLeit	Created	1/25/96
//
//-----------------------------------------------------------------------
BOOL CreateGuestAccount(char *szUsername,
				  char *szFullName,
				  char *szComment,
				  char *szDomain,
				  char *szPassword);

/*++

   Description

     Sets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
DWORD
SetSecret(  IN  LPWSTR Server,
            IN  LPWSTR SecretName,
            IN  LPWSTR pSecret,
            IN  DWORD  cbSecret);

/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        szAnsiName - Name of LSA Secret to retrieve
        szAnsiSecret - Receives found secret

    Returns:
        TRUE on success and FALSE if any failure.

--*/
BOOL 
GetSecret( IN LPCSTR szAnsiName,
		   OUT LPSTR szAnsiSecret );

/*++

  This function calls the service controller to start 
  a service.

  Arguments:
    pszServiceName  pointer to service name

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
BOOL
libStartService(IN char * pszServiceName);

/*
* Checks to see if a service is installed
*/
BOOL 
libIsServiceInstalled(LPSTR lpszServiceName);

/*++

  This function determines if NT Server or NT Advance service is running.
  
  Arguments:

  Returns:

    TRUE if server is running NT server or NT advanced server and
	FALSE otherwise.
	
  Comments:

--*/
BOOL
libIsNTServer(void);

/*
* Adds reg entry for service ism dll
*/
BOOL
AddInetMgrAddOn(LPSTR lpszServiceName, LPSTR lpszDllName);

/*
* Removes reg entry for service ism dll
*/
BOOL
RemoveInetMgrAddOn(LPSTR lpszServiceName);

/*
* Adds reg entry for service key ring dll
*/
BOOL
AddKeyRingAddOn(LPSTR lpszServiceName, LPSTR lpszDllName);
/*
* Removes reg entry for service key ring dll
*/
BOOL
RemoveKeyRingAddOn(LPSTR lpszServiceName);

/*
 * check if the filesystem is an NTFS volume
 */
extern "C" BOOL libCheckNTFS( LPCTSTR ptstrFileSystemRoot );

/*
 * check if the filesystem has the capability to store acl's
 */
extern "C" BOOL libCheckFilesystemSupportsAcls( LPCTSTR ptstrFileSystemRoot );

/*
 * check if the drive is a fixed hard drive on the local system
 */
extern "C" BOOL libCheckIsLocalFixedDrive( LPCTSTR ptstrFileSystemRoot );

/*
* Installs Jnet reg keys and perfmon counters. Requires the full path dir 
* containing the jnfoctrs.ini and jfoctrs.h files. 
*/
BOOL libInstallJnfoComm(LPSTR lpszDstDir, LPSTR lpszIniDir);

/*
* Removes Jnet reg keys and perfmon counters when reference count on
* jnfocomm.dll reaches 1 or zero. It is assumed that this call is made
* before the file is actually deleted and the reference count reaches zero.
*/
void libRemoveJnfoComm(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\smartptr.h ===
//
// smartptr.h
//
//  This file contains stuff for implementing reference counting smart 
//  pointers.
//
// Implementation Schedule for all classes defined by this file : 
//
// 0.5 week.
//
// Unit Test Schedule for all classes defined by this file : 
//
// 0.5 week.
//  Unit Testing will consist of the following : 
//  Define a class derived from CRefCount.  On one thread 
//  create this object and place it into a smart pointer.
//  Pass a copy of the smart pointer to several other threads.
//  These threads should wait a random interval - print the contents
//  of the object and then destroy their smart pointer.
//
//  The test should insure that : 
//  All Memory is freed.
//  The objects are not prematurely destroyed by the smart pointers.
//  
// 


#ifndef _SMARTPTR_H_
#define _SMARTPTR_H_

#ifndef	Assert
#define	Assert	_ASSERT
#endif



//------------------------------------------------------------------
class   CRefCount    {
//
// This class contains a long which is used to count references to an 
// object.  This class is designed to work with the CRefPtr template
// that follows within this file.  
//
// Users of this class should publicly derive from the class 
// (ie :  'class CNewsGroup : public CRefCount {'.
// Once this is done, the derived object can be reference counted.
// The functions AddRef() and RemoveRef() are used to add and remove
// reference counts, using InterlockedIncrement and InterlockedDecrement.
// If RemoveRef returns a negative value the object no longer has 
// any references.
//
//  Objects derived from this should have Init() functions.
//  All initialization of the object should be done through these 
//  Init() functions, the constructor should do minimal work.
//
//  This allows the creation of a smart pointer to allocate the 
//  memory for the object.  The object is then initialized by calling
//  through the smart pointer into the Init() function.
//
public : 
    LONG    m_refs ;

    inline  CRefCount( ) ;
    inline  LONG    AddRef( ) ;
    inline  LONG    RemoveRef( ) ;
} ;

//
// refcount.inl contains all of the actual implementation of this class.
//
#include    "refcount.inl" 

//------------------------------------------------------------------
template< class Type >
class   CRefPtr {
//
// This template is used to build reference counting pointers to 
// an object.  The object should be a class derived from CRefCount.
// The cost of using these smart pointers is 1 DWORD for the smart pointer
// itself, and 1 DWORD in the pointed to object to contain the reference 
// count.
//
// These Smart Pointers will do the following : 
// On Creation the smart pointer will add a reference to the pointed to object.
// On Assignment 'operator=' the smart pointer will check for assignment
// to self, if this is not the case it will remove a reference from the 
// pointed to object and destroy it if necessary.  It will then point 
// itself to the assigned object and add a reference to it.
// On Destruction the smart pointer will remove a reference from the 
// pointed to object, and if necessary delete it.
//
private: 
    Type*  m_p ; 

    //CRefPtr( ) ;
public : 

    inline  CRefPtr( const CRefPtr< Type >& ) ;
    inline  CRefPtr( const Type *p = 0 ) ;
    
    inline  ~CRefPtr( ) ;

	inline	CRefPtr<Type>&	operator=( const	CRefPtr<Type>& ) ;
	inline	CRefPtr<Type>&	operator=( const	Type	* ) ;
	inline	BOOL			operator==( CRefPtr<Type>& ) ;
	inline	BOOL			operator!=( CRefPtr<Type>& ) ;
	inline	BOOL			operator==( Type* ) ;
	inline	BOOL			operator!=( Type* ) ;
    inline  Type*   operator->() const ;
	inline	operator Type*  () const ;
    inline  BOOL    operator!() const ;
	inline	Type*			Release() ;
	inline	Type*			Replace( Type * ) ;
} ;

//------------------------------------------------------------------
template< class Type >
class   CSmartPtr {
//
// This template is used to build reference counting pointers to 
// an object.  The object should be a class derived from CRefCount.
// The cost of using these smart pointers is 1 DWORD for the smart pointer
// itself, and 1 DWORD in the pointed to object to contain the reference 
// count.
//
// These Smart Pointers will do the following : 
// On Creation the smart pointer will add a reference to the pointed to object.
// On Assignment 'operator=' the smart pointer will check for assignment
// to self, if this is not the case it will remove a reference from the 
// pointed to object and destroy it if necessary.  It will then point 
// itself to the assigned object and add a reference to it.
// On Destruction the smart pointer will remove a reference from the 
// pointed to object, and if necessary delete it.
//
private: 
    Type*  m_p ; 

public : 

    inline  CSmartPtr( const CSmartPtr< Type >& ) ;
    inline  CSmartPtr( const Type *p = 0 ) ;
    
    inline  ~CSmartPtr( ) ;

    //inline  CSmartPtr<Type>&  operator=( CSmartPtr<Type>& ) ;
	inline	CSmartPtr<Type>&	operator=( const	CSmartPtr<Type>& ) ;
	inline	CSmartPtr<Type>&	operator=( const	Type	* ) ;
	inline	BOOL			operator==( CSmartPtr<Type>& ) ;
	inline	BOOL			operator!=( CSmartPtr<Type>& ) ;
	inline	BOOL			operator==( Type* ) ;
	inline	BOOL			operator!=( Type* ) ;
    inline  Type*   operator->() const ;
	inline	operator Type*  () const ;
    inline  BOOL    operator!() const ;
	inline	Type*			Release() ;
	inline	Type*			Replace( Type * ) ;
} ;





#include    "smartptr.inl"


#endif  // _SORTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tcpdebug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    tcpdebug.h

    This file contains a number of debug-dependent definitions for
    the TCP Services.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.

        MuraliK     12-Oct-1993 Stripped this down to simplify things

*/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG

//
//  TCP DLL Debug control flags.
//
//  TCP_DEBUG_SVC_RESERVED is the set of flags individual service DLLs
//  may use
//

#define TCP_DEBUG_SVC_RESERVED         0xf00fffffL

//
//  Common definitions for debug output (still used in each service DLL)
//

#define TCP_DEBUG_OUTPUT_TO_DEBUGGER   0x40000000L
#define TCP_DEBUG_OUTPUT_TO_LOG_FILE   0x80000000L


//
//  Used by common DLL
//

#define TCP_DEBUG_GATEWAY              0x00010000L
#define TCP_DEBUG_INETLOG              0x00020000L
#define TCP_DEBUG_DLL_EVENT_LOG        0x00100000L
#define TCP_DEBUG_DLL_SERVICE_INFO     0x00200000L
#define TCP_DEBUG_DLL_SECURITY         0x00400000L
#define TCP_DEBUG_DLL_CONNECTION       0x00800000L
#define TCP_DEBUG_DLL_SOCKETS          0x01000000L
#define TCP_DEBUG_HEAP_FILL            0x02000000L
#define TCP_DEBUG_HEAP_MSG             0x04000000L
#define TCP_DEBUG_HEAP_CHECK           0x08000000L
#define TCP_DEBUG_MIME_MAP             0x10000000L
#define TCP_DEBUG_VIRTUAL_ROOTS        0x20000000L


#else   // !DBG

//
//  Null assert & require.
//

#ifndef TCP_ASSERT

#define TCP_ASSERT(exp)
#define TCP_REQUIRE(exp) ((VOID)(exp))
#define DBG_CONTEXT      ( NULL)

#endif

#endif  // DBG

//
// Heap Routines
//
#define TCP_ALLOC(cb)          (VOID *)LocalAlloc( LPTR, cb )
#define TCP_FREE(p)            LocalFree( (HLOCAL) p )
#define TCP_DUMP_RESIDUE()     /* NOTHING */



#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\smtpevents.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       smtpevents.h

   Abstract:

       This file contains type definitions seo events

   Author:

        Rohan Phillips (Rohanp)     MAY-06-1998

   Revision History:

--*/

#ifndef _SMTPEVENT_PARAMS_
#define _SMTPEVENT_PARAMS_

#define SMTP_SERVER_EVENT_IO_TIMEOUT 5*60*1000

#include "filehc.h"

typedef struct _SMTP_EVENT_ALLOC_
{
	PFIO_CONTEXT hContent;
	PVOID IMsgPtr;
	PVOID BindInterfacePtr;
	PVOID pAtqClientContext;
//	PATQ_CONTEXT pAtqContext;
	PVOID	* m_EventSmtpServer;
	LPCSTR  m_DropDirectory;

	DWORD   m_InstanceId;
	
	DWORD	m_RecipientCount;

	DWORD	*pdwRecipIndexes;
	HRESULT hr;

	DWORD	m_dwStartupType;
    PVOID m_pNotify;
}SMTP_ALLOC_PARAMS;


typedef struct _SEOEVENT_OVERLAPPED
{
    FH_OVERLAPPED   	Overlapped;
	DWORD				Signature;
	ATQ_COMPLETION  pfnCompletion;
	PVOID				ThisPtr;
}   SERVEREVENT_OVERLAPPED;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tcpdata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    TCPdata.hxx

    This file contains the global variable definitions for the
    TCP Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     21-Feb-1995 Removed TCPDebug variable

*/


#ifndef _TCPDATA_H_
#define _TCPDATA_H_


//
//  Miscellaneous data.
//


//
// The global variable is to be defined for each service.
//  The variable is defined by using DEFINE_TSVCINFO_INTERFACE macro
//      in exactly one of the code files for the service.
//  Dont change the name of this global variable. Many macros depend on this.
//  Read As:  global pointer to Tcp service info object
//

# ifdef __cplusplus

extern LPTSVC_INFO       g_pTsvcInfo;

extern PMIME_MAP         g_pMimeMap;

# endif //  __cplusplus


#endif  // _TCPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\ssobase.h ===
/*
**	SSOBASE.H
**	Sean P. Nolan
**	
**	Simple MSN SSS Object Framework
*/

#ifndef _SSOBASE_H_
#define _SSOBASE_H_

#include "wcsutil.h"
#include <ascript.h>

/*--------------------------------------------------------------------------+
|	Types																	|
+--------------------------------------------------------------------------*/

typedef struct _SsoSupportStuff
	{
	EXCEPINFO		*pexcepinfo;
	LONG			lUser;
	IUnknown		*punk;
	OLECHAR			*wszMethodName;
	}
	SSSTUFF;

typedef HRESULT (*PFNSSOMETHOD)(WORD, DISPPARAMS *, VARIANT *, SSSTUFF *pssstuff);

typedef struct _SSOMethod
	{
	OLECHAR			*wszName;
	PFNSSOMETHOD	pfn;
	int				iMethod;
	}
	SSOMETHOD;

/*--------------------------------------------------------------------------+
|	Globals !!! Provided by the SSO !!!										|
+--------------------------------------------------------------------------*/

extern PFNSSOMETHOD g_pfnssoDynamic;
extern SSOMETHOD g_rgssomethod[];
extern LPSTR g_szSSOProgID;
extern GUID g_clsidSSO;
extern BOOL g_fPersistentSSO;

/*--------------------------------------------------------------------------+
|	Globals Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern HINSTANCE g_hinst;

extern OLECHAR *c_wszOnNewTemplate;
extern OLECHAR *c_wszOnFreeTemplate;

/*--------------------------------------------------------------------------+
|	Routines Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern HRESULT	SSOTranslateVirtualRoot(VARIANT *, IUnknown*, LPSTR, DWORD); 
extern BOOL		SSODllMain(HINSTANCE, ULONG, LPVOID);

/*--------------------------------------------------------------------------+
|	Other Data Needed by the Framework										|
+--------------------------------------------------------------------------*/

const int cTimeSamplesMax = 100;

#define SSO_OFFICIAL_NAME_PREFIX "Microsoft ActiveX Server Component" 

#endif // _SSOBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\smartptr.inl ===
//
//
//
//

template< class Type > 
inline  CRefPtr< Type >::CRefPtr( const CRefPtr< Type >&    ref ) : 
    m_p( ref.m_p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CRefPtr< Type >::CRefPtr( const	Type *p ) : m_p( (Type*)p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CRefPtr< Type >::~CRefPtr( ) {
    if( m_p && m_p->RemoveRef() < 0 ) {
        delete	m_p ;
    }
}

#if 0 
template< class Type > 
inline  CRefPtr< Type >&    CRefPtr< Type >::operator=( CRefPtr< Type >& rhs ) {
    if( m_p != rhs.m_p ) {
        if( m_p && m_p->RemoveRef() < 0 ) {
            delete m_p ;
        }        
    }   
    m_p = rhs.m_p ;
	if( m_p ) 
		m_p->AddRef() ;
    return  *this ;
} ;
#endif

template< class Type > 
inline  CRefPtr< Type >&    CRefPtr< Type >::operator=( const	CRefPtr< Type >& rhs ) {
    if( m_p != rhs.m_p ) {
		Type*	pTemp = m_p ;
		m_p = rhs.m_p ;
		if( m_p ) 
			m_p->AddRef() ;
        if( pTemp && pTemp->RemoveRef() < 0 ) {
            delete	pTemp ;
        }        
    }   
    return  *this ;
} ;

template< class Type >
inline	CRefPtr< Type >&	CRefPtr< Type >::operator=( const	Type*	rhs )	{
	if( m_p != rhs )	{
		Type*	pTemp = m_p ;
		m_p = (Type*)rhs ;
		if( m_p ) 
			m_p->AddRef() ;
		if( pTemp && pTemp->RemoveRef() < 0 )	{
			delete	pTemp ;
		}
	}
	return	*this ;
}

template< class Type > 
inline  Type*   CRefPtr< Type >::operator->()    const   {
    return  m_p ;
}

template< class Type > 
inline	CRefPtr< Type >::operator Type* () const	{
	return	m_p ;
}

#if 0 
template< class Type >
inline  CRefPtr<Type>::CRefPtr() : m_p( 0 ) {
}
#endif

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator ! ( void ) const {
	return	!m_p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator==( CRefPtr<Type>& rhs ) {
	return	m_p == rhs.m_p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator!=( CRefPtr<Type>& rhs )	{
	return	m_p != rhs.m_p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator==( Type * p )	{
	return	m_p == p ;
}

template< class Type > 
inline	BOOL	CRefPtr<Type>::operator!=( Type * p )	{
	return	m_p != p ;
}

template< class Type > 
inline	Type*	CRefPtr<Type>::Release()	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = 0 ;
	return	pReturn ;
}						

template< class Type > 
inline	Type*	CRefPtr<Type>::Replace( Type* p )	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = p ;
	if( m_p != 0 ) {
		p->AddRef() ;
		if( pReturn == p )	{
			pReturn = 0 ;
		}
	}
	return	pReturn ;
}						

template< class Type > 
inline  CSmartPtr< Type >::CSmartPtr( const CSmartPtr< Type >&    ref ) : 
    m_p( ref.m_p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CSmartPtr< Type >::CSmartPtr( const	Type *p ) : m_p( (Type*)p ) {
	if( m_p ) 
		m_p->AddRef() ;
}

template< class Type > 
inline  CSmartPtr< Type >::~CSmartPtr( ) {
    if( m_p && m_p->RemoveRef() < 0 ) {
        m_p->DestroySelf() ;
    }
}

#if 0 
template< class Type > 
inline  CSmartPtr< Type >&    CSmartPtr< Type >::operator=( CSmartPtr< Type >& rhs ) {
    if( m_p != rhs.m_p ) {
        if( m_p && m_p->RemoveRef() < 0 ) {
            delete m_p ;
        }        
    }   
    m_p = rhs.m_p ;
	if( m_p ) 
		m_p->AddRef() ;
    return  *this ;
} ;
#endif

template< class Type > 
inline  CSmartPtr< Type >&    CSmartPtr< Type >::operator=( const	CSmartPtr< Type >& rhs ) {

    if( m_p != rhs.m_p ) {
		Type*	pTemp = m_p ;
		m_p = rhs.m_p ;
		if( m_p ) 
			m_p->AddRef() ;
        if( pTemp && pTemp->RemoveRef() < 0 ) {
            pTemp->DestroySelf() ;
        }        
    }   
    return  *this ;
} ;

template< class Type >
inline	CSmartPtr< Type >&	CSmartPtr< Type >::operator=( const	Type*	rhs )	{
	if( m_p != rhs )	{
		Type*	pTemp = m_p ;
		m_p = (Type*)rhs ;
		if( m_p ) 
			m_p->AddRef() ;
		if( pTemp && pTemp->RemoveRef() < 0 )	{
			pTemp->DestroySelf() ;
		}
	}
	return	*this ;
}

template< class Type > 
inline  Type*   CSmartPtr< Type >::operator->()    const   {
    return  m_p ;
}

template< class Type > 
inline	CSmartPtr< Type >::operator Type* () const	{
	return	m_p ;
}

#if 0 
template< class Type >
inline  CSmartPtr<Type>::CSmartPtr() : m_p( 0 ) {
}
#endif

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator ! ( void ) const {
	return	!m_p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator==( CSmartPtr<Type>& rhs ) {
	return	m_p == rhs.m_p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator!=( CSmartPtr<Type>& rhs )	{
	return	m_p != rhs.m_p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator==( Type * p )	{
	return	m_p == p ;
}

template< class Type > 
inline	BOOL	CSmartPtr<Type>::operator!=( Type * p )	{
	return	m_p != p ;
}

template< class Type > 
inline	Type*	CSmartPtr<Type>::Release()	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = 0 ;
	return	pReturn ;
}						

template< class Type > 
inline	Type*	CSmartPtr<Type>::Replace( Type* p )	{
	Type*	pReturn = 0 ;
	if( m_p != 0 ) {
		if( m_p->RemoveRef() < 0 ) {
			pReturn = m_p ;
		}
	}
	m_p = p ;
	if( m_p != 0 ) {
		p->AddRef() ;
		if( pReturn == p )	{
			pReturn = 0 ;
		}
	}
	return	pReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\snprflib.h ===
/*==========================================================================*\

    Module:        exprflib.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the header for exprflib.h a perf library. This 
                   is the code that runs in the app exporting the counters.
    
\*==========================================================================*/


#ifndef __PERFLIB_H__
#define __PERFLIB_H__

///////////////////////////////////////////////////////////////////////////////
//
// Includes
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <winperf.h>
#include <stdio.h>
#ifdef STAXMEM
#include <exchmem.h>
#endif


///////////////////////////////////////////////////////////////////////////////
//
// Data Structures / typedefs / misc defines
//
///////////////////////////////////////////////////////////////////////////////
#define MAX_PERF_NAME           16
#define MAX_OBJECT_NAME         16
#define MAX_INSTANCE_NAME       16
#define MAX_PERF_OBJECTS        16
#define MAX_OBJECT_COUNTERS     200
#define SHMEM_MAPPING_SIZE      32768

typedef WCHAR OBJECTNAME[MAX_OBJECT_NAME];
typedef WCHAR INSTANCENAME[MAX_INSTANCE_NAME];
typedef unsigned __int64 QWORD;

struct INSTANCE_DATA
{
    BOOL                        fActive;
    PERF_INSTANCE_DEFINITION    perfInstDef;
    INSTANCENAME                wszInstanceName;
};


///////////////////////////////////////////////////////////////////////////////
//
// Forward class declarations
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectInstance;
class PerfCounterDefinition;
class PerfObjectDefinition;


///////////////////////////////////////////////////////////////////////////////
//
// Local memory management
//
///////////////////////////////////////////////////////////////////////////////
#ifdef STAXMEM
#undef new
#endif

class MemoryModule
{
public:

#ifdef STAXMEM
#ifdef DEBUG
    void* operator new (size_t cb, char * szFile, DWORD dwLine)
        { return ExchMHeapAllocDebug (cb, szFile, dwLine); }
#else //!DEBUG
    void* operator new (size_t cb)
        { return ExchMHeapAlloc (cb); }
#endif
    void  operator delete(void* pv)
        { ExchMHeapFree (pv); };
#endif
};

#ifdef STAXMEM
#ifdef DEBUG
#define new     new(__FILE__, __LINE__)
#endif
#endif


///////////////////////////////////////////////////////////////////////////////
//
// Shared memory management
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _SharedMemorySegment : public MemoryModule
{
    HANDLE  m_hMap;
    PBYTE   m_pbMap;
    struct _SharedMemorySegment * m_pSMSNext;
} SharedMemorySegment;



///////////////////////////////////////////////////////////////////////////////
//
// PerfLibrary class declaration. There is one perf library instance per linkee.
//
///////////////////////////////////////////////////////////////////////////////
class PerfLibrary : public MemoryModule
{
    friend class PerfObjectDefinition;
    friend class PerfCounterDefinition;
    
private:
    // Name of this performance module
    WCHAR                       m_wszPerfName[MAX_PERF_NAME];
        
    // Array of PerfObjectDefinition's and a count of how many there are.
    PerfObjectDefinition*       m_rgpObjDef[MAX_PERF_OBJECTS];
    DWORD                       m_dwObjDef;

    // Shared memory handle and pointer to base of shared memory
    HANDLE                      m_hMap;
    PBYTE                       m_pbMap;
    

    // Pointers to places in the shared memory where we keep stuff
    DWORD*                      m_pdwObjectNames;
    OBJECTNAME*                 m_prgObjectNames;

    // Base values for title text and help text for the library
    DWORD                       m_dwFirstHelp;
    DWORD                       m_dwFirstCounter;

    void AddPerfObjectDefinition (PerfObjectDefinition* pObjDef);
    
public:

    PerfLibrary (LPCWSTR pcwstrPerfName);
    ~PerfLibrary (void);

    PerfObjectDefinition* AddPerfObjectDefinition (LPCWSTR pcwstrObjectName,
                                                   DWORD dwObjectNameIndex,
                                                   BOOL fInstances);
    
    BOOL Init (void);
    void DeInit (void);
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectDefinition class declaration. There is one of these for each
//  perfmon object exported. Generally there is just one, but not neccessarily.
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectDefinition : public MemoryModule
{
    friend class PerfLibrary;
    friend class PerfCounterDefinition;
    friend class PerfObjectInstance;
    
private:
    
    WCHAR                       m_wszObjectName[MAX_OBJECT_NAME];
    
    DWORD                       m_dwObjectNameIndex;
    BOOL                        m_fInstances;

    PerfCounterDefinition*      m_rgpCounterDef[MAX_OBJECT_COUNTERS];
    DWORD                       m_dwCounters;

    DWORD                       m_dwDefinitionLength;
    DWORD                       m_dwCounterData;
    DWORD                       m_dwPerInstanceData;

    PERF_OBJECT_TYPE*           m_pPerfObjectType;
    PERF_COUNTER_DEFINITION*    m_rgPerfCounterDefinition;

    DWORD                       m_dwActiveInstances;

    SharedMemorySegment*        m_pSMS;
    DWORD                       m_dwShmemMappingSize;
    DWORD                       m_dwInstancesPerMapping;
    DWORD                       m_dwInstances1stMapping;

    CRITICAL_SECTION            m_csPerfObjInst;
    BOOL                        m_fCSInit;

    PerfObjectInstance*         m_pPoiTotal;
    
    BOOL Init (PerfLibrary* pPerfLib);
    void DeInit (void);
    void AddPerfCounterDefinition (PerfCounterDefinition* pcd);

    DWORD GetCounterOffset (DWORD dwId);

public:

    PerfObjectDefinition (LPCWSTR pwcstrObjectName,
                          DWORD dwObjectNameIndex,
                          BOOL  fInstances = FALSE);

    ~PerfObjectDefinition (void);

    PerfCounterDefinition* AddPerfCounterDefinition (
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale = 0);

    PerfCounterDefinition* AddPerfCounterDefinition (
                                    PerfCounterDefinition * pCtrRef,
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale = 0);

    PerfObjectInstance*    AddPerfObjectInstance (LPCWSTR pwcstrInstanceName);

    void DeletePerfObjectInstance ();
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfCounterDefinition class declaration. There is one of these per counter.
//
///////////////////////////////////////////////////////////////////////////////
class PerfCounterDefinition : public MemoryModule
{
    friend class PerfObjectDefinition;
    
private:    
    PerfObjectDefinition*       m_pObjDef;
    PerfCounterDefinition*      m_pCtrRef;
    DWORD                       m_dwCounterNameIndex;
    LONG                        m_lDefaultScale;
    DWORD                       m_dwCounterType;
    DWORD                       m_dwCounterSize;

    DWORD                       m_dwOffset;

    void Init (PerfLibrary* pPerfLib,
               PERF_COUNTER_DEFINITION* pdef,
               PDWORD pdwOffset);
    
public:
    PerfCounterDefinition (DWORD dwCounterNameIndex,
                           DWORD dwCounterType = PERF_COUNTER_COUNTER,
                           LONG lDefaultScale = 0);

    PerfCounterDefinition (PerfCounterDefinition* pRefCtr,
                           DWORD dwCounterNameIndex,
                           DWORD dwCounterType = PERF_COUNTER_COUNTER,
                           LONG lDefaultScale = 0);
                           
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectInstance class declaration. There is one of these per instance
//  of an object. There is one if there are no instances (the global instance.)
//
// NOTE: User is responsible for allocating space and Init this object after
//       the PerfLibrary is initialized. When destroying the perf counters,
//       this object must be destroyed before the PerfLibrary is deinitialized.
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectInstance : public MemoryModule
{
    friend class PerfObjectDefinition;

private:
    PerfObjectDefinition*       m_pObjDef;  
    WCHAR                       m_wszInstanceName[MAX_INSTANCE_NAME];
    INSTANCE_DATA*              m_pInstanceData;
    char*                       m_pCounterData;
    BOOL                        m_fInitialized;

    void Init (char* pCounterData,
               INSTANCE_DATA* pInstData,
               LONG lID);
    
public:
    PerfObjectInstance (PerfObjectDefinition* pObjDef,
                        LPCWSTR pwcstrInstanceName);
    ~PerfObjectInstance () { DeInit(); };
    
    VOID                DeInit (void);

    BOOL                FIsInitialized () {return m_fInitialized; };
    DWORD *             GetDwordCounter (DWORD dwId);
    LARGE_INTEGER *     GetLargeIntegerCounter (DWORD dwId);
    QWORD *             GetQwordCounter (DWORD dwId);
    PERF_OBJECT_TYPE *  GetPerfObjectType ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\stags.h ===
//
// Property names we look for in the ISharedPropertyGroup/IpropertyBag
//
#pragma once

//  Required properties.
const WCHAR   wszScriptTextProp[]                = L"ScriptText"; //stream property name


// Optional properties.
const WCHAR   wszMaxExecutionTimeProp[]          = L"MaxExecutionTime";
const WCHAR   wszASPSyntaxProp[]                 = L"ScriptASPSyntax";
const WCHAR   wszScriptProgIDProp[]              = L"ScriptProgID";
const WCHAR   wszEnableCreateObjects[]           = L"EnableCreateObjects";
const WCHAR   wszNumNamedPropsProp[]             = L"NumNamedProps";
const WCHAR   wszNamedPropIDPrefix[]             = L"NamedPropID";
const WCHAR   wszNamedUnkPtrPrefix[]             = L"NamedUnkPtr";
const WCHAR   wszNamedSourcesPrefix[]            = L"NamedSource";


//default values
WCHAR   wszDefProgID[]                           = L"VBScript";
const ULONG   ulExecutionTime                    = 15 * 60 ;     // 15 minutes
const bool    fEnableCreateObjects               = false;

// data returned in the bag.
WCHAR   wszErrorResponse[]                      = L"ErrorResponse";
WCHAR   wszScriptResponse[]                     = L"ScriptResponse";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tflistex.h ===
#ifndef __TFLISTEX_H__
#define __TFLISTEX_H__

//
// This defines TFListEx, which is just like TFList but it has built in
// locking.  For usage information refer to tflist.h.  For examples of
// TFList usage look at the unit test found in 
// src\core\tflist\utest\tflist.cpp.
//
// -awetmore
//

#include "tflist.h"
#include "rwnew.h"

template <class Data> class TFListEx : public TFList<Data> {
	protected:
		CShareLockNH m_lock;

		// 
		// This is a helper class which automatically does the lock/unlock
		// operation for us.  The compiler will turn a method that looks 
		// like:
		//
		// bool IsEmpty(void) {
		// 		CListShareLock lock(this);
		//		return TFList<Data>::IsEmpty();
		// }
		//
		// become:
		// bool IsEmpty(void) {
		// 		bool f;
		//		m_lock.ShareLock();
		//		f = TFList<Data>::IsEmpty();
		//		m_lock.ShareUnlock();
		//		return f;
		// }
		//
		// I chose to do things this way because its less error prone (I 
		// can't return without releasing the lock, etc) and makes the 
		// inline functions shorter and cleaner.  
		//
		class CListShareLock {
			private:
				TFListEx<Data> *m_pList;
			public:
				CListShareLock(TFListEx<Data> *pList) { 
					m_pList = pList;
					m_pList->m_lock.ShareLock(); 
				}
				~CListShareLock() { 
					m_pList->m_lock.ShareUnlock(); 
				}
		};

		//
		// same as CListShareLock, but it grabs the lock exclusively.
		//
		class CListExclusiveLock {
			private:
				TFListEx<Data> *m_pList;
			public:
				CListExclusiveLock(TFListEx<Data> *pList) { 
					m_pList = pList;
					m_pList->m_lock.ExclusiveLock(); 
				}
				~CListExclusiveLock() { 
					m_pList->m_lock.ExclusiveUnlock(); 
				}
		};	

	public:
		TFListEx(NEXTPTR pPrev, NEXTPTR pNext) : TFList<Data>(pPrev, pNext) {}

		bool IsEmpty() {
			CListShareLock lock(this);
			return TFList<Data>::IsEmpty();
		}

        void PushFront(Data *node) { 
			CListExclusiveLock lock(this);
			TFList<Data>::PushFront(node);
		}

        void PushBack(Data *node) { 
			CListExclusiveLock lock(this);
			TFList<Data>::PushBack(node);
		}

        Data *PopFront() { 
			CListExclusiveLock lock(this);
			return TFList<Data>::PopFront();
		}

        Data *PopBack() { 
			CListExclusiveLock lock(this);
			return TFList<Data>::PopBack();
		}

		Data* GetFront() {
			CListShareLock lock(this);
			return TFList<Data>::GetFront();
		}

		Data* GetBack() {
			CListShareLock lock(this);
			return TFList<Data>::GetBack();
		}

		//
		// The Iterator holds a lock for the objects lifetime.  You can
		// choose a share lock or an exclusive lock with the second parameter.
		// It defaults to a share lock.
		//
		class Iterator : public TFList<Data>::Iterator {
			public:
				Iterator(TFListEx<Data> *pList, BOOL fExclusive = FALSE, BOOL fForward = TRUE) :
					TFList<Data>::Iterator((TFList<Data> *) pList, fForward) 
				{
					m_fExclusive = fExclusive;
					if (m_fExclusive) {
						pList->m_lock.ExclusiveLock();
					} else {
						pList->m_lock.ShareLock();
					}

                    ResetHeader( pList );
				}
	
				~Iterator() {
					TFListEx<Data> *pList = (TFListEx<Data> *) m_pList;
					if (m_fExclusive) {
						pList->m_lock.ExclusiveUnlock();
					} else {
						pList->m_lock.ShareUnlock();
					}
				}

#ifdef DEBUG
				//
				// In debug builds we have _ASSERTs to make sure that no
				// operations which require an exclusive lock are performed
				// while holding a share lock.
				//

				Data *RemoveItem(void) {
					if (!m_fExclusive) _ASSERT(FALSE);
					TFList<Data>::Iterator *pThis = (TFList<Data>::Iterator *) this;
					return pThis->RemoveItem();
				}

				void InsertBefore(Data* pNode) {
					if (!m_fExclusive) _ASSERT(FALSE);
					TFList<Data>::Iterator *pThis = (TFList<Data>::Iterator *) this;
					pThis->InsertBefore(pNode);
				}

				void InsertAfter(Data* pNode) {
					if (!m_fExclusive) _ASSERT(FALSE);
					TFList<Data>::Iterator *pThis = (TFList<Data>::Iterator *) this;
					pThis->InsertAfter(pNode);
				}
#endif

			private:
				// what sort of lock did we grab?
				BOOL	m_fExclusive;
		};

		// our helper classes need to be able to access the lock
		friend class TFListEx<Data>::CListShareLock;
		friend class TFListEx<Data>::CListExclusiveLock;
		friend class TFListEx<Data>::Iterator;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tcpsvcs.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Tcpsvcs.h

Abstract:

    Header file fr TCP/IP services.

Author:

    David Treadwell (davidtr)   7-27-93

Revision History:

--*/

#ifndef _TCPSVCS_
#define _TCPSVCS_

//
// Service DLLs loaded into tcpsvcs.exe all export the same main
// entry point.  TCPSVCS_ENTRY_POINT defines that name.
//
// Note that TCPSVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define TCPSVCS_ENTRY_POINT         ServiceEntry
#define TCPSVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Name for the common RPC pipe shared by all the RPC servers in tcpsvcs.exe.
// Note:  Because version 1.0 of WinNt had seperate names for each server's
// pipe, the client side names have remained the same.  Mapping to the new
// name is handled by the named pipe file system.
//

#define TCPSVCS_RPC_PIPE           L"nttcpsvcs"

//
// Start and stop RPC server entry point prototype.
//

typedef
DWORD
(*PTCPSVCS_START_RPC_SERVER_LISTEN) (
    VOID
    );

typedef
DWORD
(*PTCPSVCS_STOP_RPC_SERVER_LISTEN) (
    VOID
    );

//
// Structure containing "global" data for the various DLLs.
//

typedef struct _TCPSVCS_GLOBAL_DATA {

    //
    // Entry points provided by TCPSVCS.EXE.
    //

    PTCPSVCS_START_RPC_SERVER_LISTEN  StartRpcServerListen;
    PTCPSVCS_STOP_RPC_SERVER_LISTEN   StopRpcServerListen;

} TCPSVCS_GLOBAL_DATA, *PTCPSVCS_GLOBAL_DATA;

//
// Service DLL entry point prototype.
//

typedef
VOID
(*PTCPSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPTSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );

#endif	// ndef _TCPSVCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tflist.h ===
#ifndef __CLIST_H__
#define __CLIST_H__


//
// TFList - a class for handling templated lists.  Lists support adding
// and removing items from the front and back of the list.  The item on
// the front or back can be examined.  Using iterator the list can
// be traversed easily (see the block comment below).
//
// The objects that this list hold should have this form:
//
// CListObject {
// 		public:
//			CListObject *m_pNext;		// for use by TFList<CListObject>
//			CListObject *m_pPrev;		// for use by TFList<CListObject>
//		// other object parameters
// }
//
// The constructor for the object should set m_pNext and m_pPrev to NULL
// in debug builds to avoid hitting _ASSERTs.
//
// To construct the list you need to pass in the offsets for the m_pNext
// and m_pPrev members using C++'s member offset syntax.  Here is an
// example:
//	TFList<CListObject> list(&CListObject::m_pPrev, &CListObject::m_pNext);
//
template <class Data> class TFList {
	public:
		typedef Data *Data::*NEXTPTR;

    protected:
		Data		*m_pHead;				// the head of the list
		Data 		*m_pTail;				// the tail of the list
		NEXTPTR		m_pNext;				// offset to the next pointer
		NEXTPTR		m_pPrev;				// offset to the prev pointer

    public:
		TFList(NEXTPTR pPrev, NEXTPTR pNext) {
			m_pHead = NULL;
			m_pTail = NULL;
			m_pNext = pNext;
			m_pPrev = pPrev;
		}

		~TFList() {
			// the user should empty the list before deleting it
			_ASSERT(m_pHead == NULL);
			_ASSERT(m_pTail == NULL);
		}

		// see if the list is empty
		bool IsEmpty() {
			bool f = (m_pHead == NULL);
			// if the head is null then the tail has to be null
			_ASSERT(!f || m_pTail == NULL);
			return f;
		}

        // push an element onto the front of the list
        void PushFront(Data *node) { 	
			_ASSERT(node != NULL);
			// you can't put an entry into the list that is already in it
			_ASSERT(node->*m_pNext == NULL);
			_ASSERT(node->*m_pPrev == NULL);
			// set the next and prev pointers
			node->*m_pPrev = NULL;
			node->*m_pNext = m_pHead;
			// if the list is empty then this new item is the tail too
			if (IsEmpty()) {
				_ASSERT(m_pTail == NULL);
				m_pTail = node;
			} else {
				_ASSERT(m_pHead->*m_pPrev == NULL);
				m_pHead->*m_pPrev = node;
			}
			m_pHead = node;
		}

        // push an element onto the back of the list
        void PushBack(Data* node) { 
			_ASSERT(node != NULL);
			// you can't put an entry into the list that is already in it
			_ASSERT(node->*m_pNext == NULL);
			_ASSERT(node->*m_pPrev == NULL);
			// set the next and prev pointers
			node->*m_pNext = NULL;
			node->*m_pPrev = m_pTail;
			// if the list is empty then this new item is the head too
			if (IsEmpty()) {
				_ASSERT(m_pHead == NULL);
				m_pHead = node;
			} else {
				_ASSERT(m_pTail->*m_pNext == NULL);
				m_pTail->*m_pNext = node;
			}			
			m_pTail = node;
		}

        // remove the item from the front of the list
        Data *PopFront() { 
			if (m_pHead == NULL) return NULL;
			Data *node = m_pHead;
			m_pHead = node->*m_pNext;
			if (m_pHead == NULL) m_pTail = NULL;
			else m_pHead->*m_pPrev = NULL;
			node->*m_pNext = NULL;
			node->*m_pPrev = NULL;
			return node;
		}

        // remove the item from the back of the list
        Data *PopBack() { 
			if (m_pTail == NULL) return NULL;
			Data *node = m_pTail;
			m_pTail = node->*m_pPrev;
			if (m_pTail == NULL) m_pHead = NULL;
			else (m_pTail)->*m_pNext = NULL;
			node->*m_pNext = NULL;
			node->*m_pPrev = NULL;
			return node;
		}

        // get the item on the front of the list
        Data* GetFront() { return m_pHead; }

        // get the item on the back of the list
        Data* GetBack() { return m_pTail; }


	public:
		//
		// The Iterator object is used to walk the list and modify members
		// that are in the middle of the list.  It is declared using this
		// syntax:
		// 	TFList<CListObject>::Iterator it(&list);
		//
		class Iterator {
		    protected:
				Data *m_pCur;				// our cursor
				int m_fForward; 			// TRUE for forward, FALSE for back
				TFList<Data> *m_pList;		// the list that we are iterating
				NEXTPTR m_pPrev, m_pNext;
		
		    public:
				//
				// create a new iterator object
				// 
				// arguments: 
				//   pList - the list to iterate across
				//   fForward - TRUE to start at the front, and go forward.
				//              FALSE to start at the back, and go backwards.
				//
				Iterator(TFList<Data> *pList, BOOL fForward = TRUE) {
					_ASSERT(pList != NULL);
					m_pList = pList;
					m_fForward = fForward;
					m_pCur = (fForward) ? pList->m_pHead : pList->m_pTail;
					m_pPrev = pList->m_pPrev;
					m_pNext = pList->m_pNext;
				}

				void ResetHeader( TFList<Data> *pList ) {
				    _ASSERT( pList != NULL );
				    m_pList = pList;
				    m_pCur = (m_fForward) ? m_pList->m_pHead : m_pList->m_pTail;
				    m_pPrev = m_pList->m_pPrev;
				    m_pNext = m_pList->m_pNext;
				}
		
				//
				// get a pointer to the current item
				//
				Data *Current() {
					return m_pCur;
				}
		
				//
		        // go to the previous item in the list
				//
		        void Prev() { 
					if (m_pCur != NULL) {
						m_pCur = m_pCur->*m_pPrev;
					} else {
						// if they switch direction and are at the end of
						// the list then they need to get to a legal place
						if (m_fForward) m_pCur = m_pList->m_pTail;
					}

					m_fForward = FALSE;
				}

				//
		        // go to the next item in the list
				//
		        void Next() { 
					if (m_pCur != NULL) {
						m_pCur = m_pCur->*m_pNext;
					} else {
						// if they switch direction and are at the end of
						// the list then they need to get to a legal place
						if (!m_fForward) m_pCur = m_pList->m_pHead;
					}

					m_fForward = TRUE;
				}

				// 
				// Go to the head of the list
				//
				void Front() {
					m_pCur = m_pList->m_pHead;
					m_fForward = TRUE;
				}

				// 
				// Go to the tail of the list
				//
				void Back() {
					m_pCur = m_pList->m_pTail;
					m_fForward = FALSE;
				}

				//
				// unlinks an item from the linked list
				//
				// cursor updates:
				//   if the last movement in this list was forward then the 
				//   iterator will point towards the pPrev item in the list.  
				//   visa-versa if the last movement was backward.  this is 
				//   so that a for loop over an iterator still works as 
				//   expected.
				//
				// returns:
				//   a pointer to the item that was unlinked.  
				//
				Data *RemoveItem(void) {
					Data *pTemp;
		
					if (m_pCur == NULL) return NULL;

					pTemp = m_pCur;

					// update cur
					if (m_fForward) Next(); else Prev();

					// fix head and tail pointers if necessary
					if (m_pList->m_pHead == pTemp) 
						m_pList->m_pHead = pTemp->*m_pNext;
					if (m_pList->m_pTail == pTemp) 
						m_pList->m_pTail = pTemp->*m_pPrev;

					// fix up the links on the adjacent elements
					if (pTemp->*m_pNext != NULL) 
						pTemp->*m_pNext->*m_pPrev = pTemp->*m_pPrev;
					if (pTemp->*m_pPrev != NULL) 
						pTemp->*m_pPrev->*m_pNext = pTemp->*m_pNext;

					// clean up the next and prev pointers
					pTemp->*m_pNext = NULL;
					pTemp->*m_pPrev = NULL;

					// return the item
					return pTemp;
				}
		
				//
				// insert a new item before the current item.
				//
				// Cursor updates:
				// If you use this method to insert an item then it should
				// not be visited if the next cursor movement is a Next().
				// If the next cursor movement is a Prev() then it should
				// be visited.
				//
				void InsertBefore(Data* pNode) {
					// this entry shouldn't be linked into the list
					_ASSERT(pNode->*m_pNext == NULL);
					_ASSERT(pNode->*m_pPrev == NULL);

					if (m_pCur == NULL) {
						// if we are at the head of the list then we'll insert
						// before the head
						if (m_fForward) {
							m_pList->PushFront(pNode);
							// set the current pointer to this item, so that
							// if we iterate forward we dont' see this item
							m_pCur = pNode;
						} else {
							// invalid operation.  do nothing
							_ASSERT(FALSE);
						}
					} else {
						pNode->*m_pNext = m_pCur;
						pNode->*m_pPrev = m_pCur->*m_pPrev;
						m_pCur->*m_pPrev = pNode;
						if (pNode->*m_pPrev != NULL) 
							pNode->*m_pPrev->*m_pNext = pNode;
						if (m_pList->m_pHead == m_pCur) 
							m_pList->m_pHead = pNode;
					}
				}
		
				//
				// insert a new item after the current item.
				//
				// Cursor updates are the opposite of InsertBefore().
				//
				void InsertAfter(Data *pNode) {
					// this entry shouldn't be linked into the list
					_ASSERT(pNode->*m_pNext == NULL);
					_ASSERT(pNode->*m_pPrev == NULL);

					if (m_pCur == NULL) {
						// if we are at the tail of the list then we'll insert
						// before the tail
						if (!m_fForward) {
							m_pList->PushBack(pNode);
							// set the current pointer to this item, so that
							// if we iterate backwards we dont' see this item
							m_pCur = pNode;
						} else {
							// invalid operation.  do nothing
							_ASSERT(FALSE);
						}
					} else {
						pNode->*m_pPrev = m_pCur;
						pNode->*m_pNext = m_pCur->*m_pNext;
						m_pCur->*m_pNext = pNode;
						if (pNode->*m_pNext != NULL) 
							pNode->*m_pNext->*m_pPrev = pNode;
						if (m_pList->m_pTail == m_pCur) 
							m_pList->m_pTail = pNode;
					}				
				}
		
				//
				// see if we are at either the front or back of the list
				//
				bool AtEnd() {
					return (m_pCur == NULL);
				}
		};

		friend class TFList<Data>::Iterator;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tfdlist.h ===
/*++

	TFDLIST.H

	This header file defines templates for manipulating doubly linked lists.
	These are intrusive lists - the client must provide a DLIST_ENTRY item
	within each data member for us to maintain the list.

--*/



#ifndef	_TFDLIST_H_
#define	_TFDLIST_H_

class	DLIST_ENTRY	{
/*++

Class Description :

	This class is intended to be incorporated into classes which are held
	within doubly linked lists.   This class will define two pointers used
	to chain the items within the lists.

	IMPORTANT : m_pNext and m_pPrev point to DLIST_ENTRY's and not to the
	top of the containing item - the template classes provided following here
	are to be used to manipulate these items.

--*/
private :

	//
	//	These are private - they don't make sense for clients !
	//
	DLIST_ENTRY( DLIST_ENTRY& ) ;
	DLIST_ENTRY&	operator=(DLIST_ENTRY&) ;
protected :
	//
	//	The items which allows maintain the doubly linked list !
	//
	class	DLIST_ENTRY*	m_pNext ;
	class	DLIST_ENTRY*	m_pPrev ;
	//
	//	The base class for all iterators !
	//
	friend class	DLISTIterator ;

	void
	InsertAfter(	DLIST_ENTRY* p )	{
	/*++

	Routine Description :

		Insert an item into the list after THIS !
	
	Arguments :
	
		p - the item to be inserted !

	Return Value

		None.

	--*/
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		_ASSERT( p->m_pNext == p ) ;
		_ASSERT( p->m_pPrev == p ) ;
		DLIST_ENTRY*	pNext = m_pNext ;
		p->m_pNext = pNext ;
		p->m_pPrev = this ;
		pNext->m_pPrev = p ;
		m_pNext = p ;
	}
	
	void
	InsertBefore(	DLIST_ENTRY* p )	{
	/*++

	Routine Description :

		Insert an item into the list before THIS !
	
	Arguments :
	
		p - the item to be inserted !

	Return Value

		None.

	--*/

		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		_ASSERT( p->m_pNext == p ) ;
		_ASSERT( p->m_pPrev == p ) ;
		DLIST_ENTRY*	pPrev = m_pPrev ;
		p->m_pNext = this ;
		p->m_pPrev = pPrev ;
		pPrev->m_pNext = p ;
		m_pPrev = p ;
	}

public :
	
	//
	//	Initialize a list !
	//	
	DLIST_ENTRY() {
		m_pNext = this ;
		m_pPrev = this ;
	}


	//
	//	It would be nice to comment out this Destructor in Retail builds,
	//	however - VC5 has a compiler bug where if you allocate an array of
	//	DLIST_ENTRY objects it adds a DWORD to hold the number of allocated
	//	objects.  Unless you have a Destructor (even a do nothing like this
	//	one will be in retail), the delete[] operator won't do the math
	//	to account for the DWORD counter - and you get Assert's etc...
	//	in your memory allocators.
	//
//#ifdef	DEBUG
	//
	//	Destroy an item in a list - should be empty when destroyed !
	//
	~DLIST_ENTRY()	{
		_ASSERT( m_pNext == this ) ;
		_ASSERT( m_pPrev == this ) ;
		_ASSERT( m_pNext == m_pPrev ) ;
	}
//#endif	

	BOOL
	IsEmpty()	{
	/*++

	Routine Description :

		This function returns TRUE if there is nothing else in the list but us.

	Arguments :

		None.

	Return Value :

		TRUE if Empty, FALSE otherwise !

	--*/
		_ASSERT( m_pPrev != 0 && m_pNext != 0 ) ;
		return	m_pPrev == this ;
	}

	void
	RemoveEntry( ) {
	/*++

	Routine Description :

		Remote this item from the list !

	Arguments :

		None.

	Return Value :

		None.

	--*/
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		
		DLIST_ENTRY*	pPrev = m_pPrev ;
		DLIST_ENTRY*	pNext = m_pNext ;
		pPrev->m_pNext = pNext ;
		pNext->m_pPrev = pPrev ;
		m_pPrev = this ;
		m_pNext = this ;
	}

	void
	Join( DLIST_ENTRY&	head )	{
	/*++

	Routine Description :

		Take one list and join it with another.
		The referenced head of the list is not to become an element in the list,
		and is left with an empty head !
	
	Arguments ;

		head - the head of the list that is to become empty, and whose elements
		are to be joined into this list !

	Return Value :

		None.

	--*/
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;

		if( !head.IsEmpty() ) {
			//
			//	First - save the guy that is at the head of our list !
			//
			DLIST_ENTRY*	pNext = m_pNext ;
			head.m_pPrev->m_pNext = pNext ;
			pNext->m_pPrev = head.m_pPrev ;
			head.m_pNext->m_pPrev = this ;
			m_pNext = head.m_pNext ;
			head.m_pNext = &head ;
			head.m_pPrev = &head ;
		}
		_ASSERT( head.IsEmpty() ) ;
	}


} ;


class	DLISTIterator	{
/*++

Class Description :

	Implement an iterator which can go both directions over
	doubly linked lists built on the DLIST_ENTRY class !
	This is the base class for a set of templates that will
	provide iteration over generic items which contain DLIST_ENTRY
	objects for their list manipulation !

--*/
protected :
	//
	//	The current position in the list !
	//
	DLIST_ENTRY	*m_pCur ;
	//
	//	the DLIST_ENTRY which is both head & tail of the list
	//	(since it is circular !)
	//
	DLIST_ENTRY	*m_pHead ;
public :

	//
	//	TRUE if we're using the m_pNext pointers to go forward !
	//	This member should not be manipulated by clients - its exposed
	//	for read only purposes only.
	//
	BOOL		m_fForward ;

	DLISTIterator(	
				DLIST_ENTRY*	pHead,
				BOOL			fForward = TRUE
				) :
		m_pHead( pHead ),
		m_fForward( fForward ),
		m_pCur( fForward ? pHead->m_pNext : pHead->m_pPrev ) {
		_ASSERT( m_pHead != 0 ) ;
	}

	void
	ReBind(	DLIST_ENTRY*	pHead,
			BOOL	fForward
			)	{

		m_pHead = pHead ;
		m_fForward = fForward ;
		m_pCur = fForward ? pHead->m_pNext : pHead->m_pPrev ;
	}

	void
	ReBind(	DLIST_ENTRY*	pHead	)	{

		m_pHead = pHead ;
		m_pCur = m_fForward ? pHead->m_pNext : pHead->m_pPrev ;
	}



	void
	Prev()	{
	/*++

	Routine Description :

		This function moves the iterator back one slot.
		Note that m_pHead is the end of the list, and we avoiud
		setting m_pCur equal to m_pHead !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		_ASSERT( m_pCur != m_pHead || m_pHead->IsEmpty() || m_fForward ) ;

		m_pCur = m_pCur->m_pPrev ;
		m_fForward = FALSE ;
	}

	void
	Next()	{
	/*++

	Routine Description :

		This function moves the iterator forward one slot.
		Note that m_pHead is the end of the list, and we avoiud
		setting m_pCur equal to m_pHead !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		_ASSERT( m_pCur != m_pHead || m_pHead->IsEmpty() || !m_fForward ) ;

		m_pCur = m_pCur->m_pNext ;
		m_fForward = TRUE ;
	}
	void
	Front()	{
	/*++

	Routine Description :

		Reset the iterator to reference the first item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/

		m_pCur = m_pHead->m_pNext ;
		m_fForward = TRUE ;
	}
	void
	Back()	{
	/*++

	Routine Description :

		Reset the iterator to reference the last item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
	
		m_pCur = m_pHead->m_pPrev  ;
		m_fForward = FALSE ;
	}

	BOOL
	AtEnd()	{
	/*++

	Routine Description :

		Return TRUE if we are at the end of the list !
		This is a little more complicated to compute -
		depends on which way we are going !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		return	m_pCur == m_pHead ;

	}

	DLIST_ENTRY*	
	CurrentEntry()	{
		return	m_pCur ;
	}

	DLIST_ENTRY*
	RemoveItemEntry()	{
	/*++

	Routine Description :

		Remove the item that the iterator currently
		references from the list.
		If we are going forward then the iterator
		will be setting on the previous element,
		otherwise the iterator is left on the next element.
		We have to take care that we don't leave the iterator
		sitting on an invalid element.

	Arguments :

		None.

	Return	Value :

		Pointer to the removed item.

	--*/

		if( m_pCur == m_pHead )
			return	0 ;
		DLIST_ENTRY*	pTemp = m_pCur ;
		if( m_fForward )	{
			m_pCur = pTemp->m_pNext;
		}	else	{
			m_pCur = pTemp->m_pPrev ;
		}
		pTemp->RemoveEntry() ;
		return	pTemp ;
	}

	void
	InsertBefore(	DLIST_ENTRY*	p )		{
	/*++

	Routine Description :

		Insert an item before our current position in the list !

	Arguments :

		None.

	Return	Value :

		Nothin

	--*/
		
		m_pCur->InsertBefore( p ) ;
	}

	void
	InsertAfter(	DLIST_ENTRY*	p )		{
	/*++

	Routine Description :
	
		Insert an Item after our current position in the list !

	Arguments :

		None.

	Return	Value :

		Nothin

	--*/

		m_pCur->InsertAfter( p ) ;
	}

} ;

template<	class	LISTHEAD	>
class	TDListIterator : public DLISTIterator	{
/*++

Class Description :

	This class provides an iterator which can walk over a specified List !

--*/
public :
	typedef	LISTHEAD::EXPORTDATA	Data ;
private :

#if 0
	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	void
	ReBind(	DLIST_ENTRY*	pHead,
			BOOL	fForward
			) ;

	void
	ReBind(	DLIST_ENTRY*	pHead ) ;
#endif

	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	DLIST_ENTRY*
	RemoveItemEntry() ;

	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	DLIST_ENTRY*
	CurrentEntry() ;

	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	void
	InsertBefore( DLIST_ENTRY* ) ;
	
	//
	//	Make the following functions private !
	//	They come from DLISTIterator and are not for use by our customers !
	//
	void
	InsertAfter( DLIST_ENTRY* ) ;

public :

	TDListIterator(
		LISTHEAD*		pHead,
		BOOL			fForward = TRUE
		) :
		DLISTIterator( pHead, fForward )	{
	}

	TDListIterator(
		LISTHEAD&		head,
		BOOL			fForward = TRUE
		) : DLISTIterator( &head, fForward ) {
	}

	TDListIterator(
		DLIST_ENTRY*	pHead,
		BOOL			fForward = TRUE
		) :
		DLISTIterator( pHead, fForward ) {
	}

	void
	ReBind(	LISTHEAD*	pHead )	{
		DLISTIterator::ReBind( pHead ) ;
	}

	void
	ReBind(	LISTHEAD*	pHead, BOOL fForward )	{
		DLISTIterator::ReBind( pHead, fForward ) ;
	}

	inline Data*
	Current( ) {
		return	LISTHEAD::Convert( m_pCur ) ;
	}

	inline Data*
	RemoveItem( )	{
		DLIST_ENTRY*	pTemp = DLISTIterator::RemoveItemEntry() ;
		return	LISTHEAD::Convert( pTemp ) ;
	}

	inline void
	InsertBefore(	Data*	p )		{
		DLIST_ENTRY*	pTemp = LISTHEAD::Convert( p ) ;
		DLISTIterator::InsertBefore( pTemp ) ;
	}
	
	inline void
	InsertAfter(	Data*	p )		{
		DLIST_ENTRY*	pTemp = LISTHEAD::Convert( p ) ;
		DLISTIterator::InsertAfter(	pTemp ) ;
	}

	//
	//	For debug purposes - let people know what the head is !
	//
	LISTHEAD*	
	GetHead()	{
		return	(LISTHEAD*)m_pHead ;
	}
} ;

template<	class	Data,
			Data::PFNDLIST	pfnConvert 	>
class	TDListHead : private	DLIST_ENTRY	{
/*++

Class	Description :

	This class defines the head of a doubly linked list of items of DATAHELPER::LISTDATA
	We provide all the functions required to manipulate the list, and a mechanism
	for creating iterators.

--*/
public :

	//
	//	Publicly redefine the type that we deal with into a nice short form !
	//
	typedef	Data	EXPORTDATA ;

private :

	//
	//	These kinds of iterators are our friends !
	//
	friend	class	TDListIterator< TDListHead<Data, pfnConvert> > ;

	static inline Data*
	Convert(	DLIST_ENTRY*	p )	{
	/*++

	Routine Description :

		This function takes a pointer to a DLIST_ENTRY and returns a pointer
		to the beginning of the data item !

	Arguments :

		p - pointer to a DLIST_ENTRY found within our list !

	Return Value :

		Pointer to the Data Item containing the referenced DLIST_ENTRY !

	--*/

		if( p )		{
			return	(Data*)(((PCHAR)p) - (PCHAR)(pfnConvert(0))) ;
		}
		return	0 ;
	}

	static inline DLIST_ENTRY*
	Convert( Data* pData ) {
		return	pfnConvert(pData) ;
	}

	//
	//	Copy Constructor and Operator= are private, as they don't make sense !
	//
	

public :

	//
	//	Redefine this to be public !
	//
	inline BOOL
	IsEmpty()	{
		return	DLIST_ENTRY::IsEmpty() ;
	}

	inline void
	PushFront(	Data*	pData ) {	
	/*++

	Routine Description :

		Push the Data item onto the front of the doubly linked list !

	Arguments :

		pData - item to add to the front of the list

	Return Value :

		None.

	--*/
		_ASSERT( pData != 0 ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	p = Convert(pData);
		InsertAfter( p ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
	}

	inline void
	PushBack(	Data*	pData ) {
	/*++

	Routine Description :

		Push the Data item onto the back of the doubly linked list !

	Arguments :

		pData - item to add to the front of the list

	Return Value :

		None.

	--*/

		_ASSERT( pData != 0 ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	p = Convert(pData) ;
		InsertBefore( p ) ;
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
	}

	inline Data*
	PopFront()	{
	/*++

	Routine Description :

		Remove the data item from the front of the List !

	Arguments :
		
		None.

	Return Value :

		The front of the list - NULL if empty !

	--*/

		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	pReturn = 0;
		if( m_pNext != this ) {
			pReturn = m_pNext ;
			pReturn->RemoveEntry() ;
		}
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		return	Convert( pReturn ) ;
	}

	inline Data*
	PopBack()	{
	/*++

	Routine Description :

		Remove the data item from the Back of the List !

	Arguments :
		
		None.

	Return Value :

		The Back of the list - NULL if empty !

	--*/


		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		DLIST_ENTRY*	pReturn = 0 ;
		if( m_pPrev != this ) {
			pReturn = m_pPrev ;
			pReturn->RemoveEntry() ;
		}
		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		return	Convert( pReturn ) ;
	}

	static inline void
	Remove(	Data*	pData )	{
	/*++

	Routine Description :

		Remove the specified item from the list !
		
	Arguments :
		
		None.

	Return Value :

		The Back of the list - NULL if empty !

	--*/

		DLIST_ENTRY*	p = Convert( pData ) ;
		p->RemoveEntry() ;
	}

	inline Data*
	GetFront()	{
	/*++

	Routine Description :

		Return the data item from the Front of the List !

	Arguments :
		
		None.

	Return Value :

		The Front of the list - NULL if empty !

	--*/


		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		if( m_pNext == this ) {
			return	0 ;
		}
		return	Convert( m_pNext ) ;
	}			
	
	inline Data*
	GetBack()	{
	/*++

	Routine Description :

		Return the data item from the Back of the List !

	Arguments :
		
		None.

	Return Value :

		The Back of the list - NULL if empty !

	--*/


		_ASSERT( m_pNext != 0 ) ;
		_ASSERT( m_pPrev != 0 ) ;
		if( m_pPrev == this ) {
			return	0 ;
		}
		return	Convert( m_pPrev ) ;
	}

	inline void
	Join( TDListHead&	head )	{
	/*++

	Routine Description :

		Take one list and join it with another.
		The referenced head of the list is not to become an element in the list,
		and is left with an empty head !
	
	Arguments ;

		head - the head of the list that is to become empty, and whose elements
		are to be joined into this list !

	Return Value :

		None.

	--*/

		DLIST_ENTRY::Join( head ) ;
	}
} ;

#endif	// _TFDLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\transdbg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: transdbg.h
//
//  Description:  Include file to define some basic debugger extension macros
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __TRANSDBG_H__
#define __TRANSDBG_H__

#define  NOEXTAPI
#include <wdbgexts.h>

//---[ TRANS_DEBUG_EXTENSION ]-------------------------------------------------
//
//
//  Description: Macro used to declare a debug extension.  The variable names
//      used are consistant with the debug function macros defined below
//
//  Parameters:
//      function - Name of the function to declare
//
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
#define TRANS_DEBUG_EXTENSION(function) \
    void function(HANDLE hCurrentProcess, \
        HANDLE hCurrentThread, \
        DWORD dwCurrentPc, \
        PWINDBG_EXTENSION_APIS pExtensionApis, \
        PCSTR szArg)

//---[ Debug function Macros ]-------------------------------------------------
//
//
//  Description:
//      The following Macros are defined to make writing debugging extensions
//      easier.
//          dprintf - printf to the debugger
//          GetExpression - Resolves symbolic expression to DWORD.  Takes a
//                  LPSTR.
//          GetSymbol -
//          Disassm - Disasemble code at given location
//          CheckControlC -
//          ReadMemory - Readmemory in the debuggee. Takes the follow arg:
//                  a PVOID - Pointer value to read
//                  b PVOID - Buffer to copy memory to
//                  c DWORD - # of bytes to read
//                  d PDWORD - OUT - # of bytes read (can be NULL)
//          WriteMemory - Writememory in the process being debugged.  Takes
//              the same arguments as ReadMemory.
//          DebugArgs - Used to pass all the debug args to another extension
//
//  Notes:
//      It is important to realize that you cannot directly read/write pointers
//      that are obtained from the process being debugged.  You must use the
//      ReadMemory and WriteMemory Macros
//
//-----------------------------------------------------------------------------
#define dprintf                 (pExtensionApis->lpOutputRoutine)
#define GetExpression           (pExtensionApis->lpGetExpressionRoutine)
#define GetSymbol               (pExtensionApis->lpGetSymbolRoutine)
#define Disasm                  (pExtensionApis->lpDisasmRoutine)
#define CheckControlC           (pExtensionApis->lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d) \
    ((pExtensionApis->nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( hCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : pExtensionApis->lpReadProcessMemoryRoutine( (ULONG_PTR)(a), (b), (c), (d) ))
#define WriteMemory(a,b,c,d) \
    ((pExtensionApis->nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( hCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : pExtensionApis->lpWriteProcessMemoryRoutine( (ULONG_PTR)(a), (LPVOID)(b), (c), (d) ))
#define DebugArgs hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szArg

#endif //__TRANSDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\thrdpool.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.h
//
//  Contents:    definitions needed for clients of the thrdpool lib
//
//	Description: The thrdpool library defines the CWorkerThread base class
//				 Users of this lib should define their own derived class
//				 that inherits from CWorkerThread. Each CWorkerThread object
//				 has a thread that is used to do some work. It is also
//				 associated with a common completion port that is used to
//				 queue work items. All worker threads will normally block on
//				 GetQueuedCompletionStatus(). Clients of the CWorkerThread
//				 objects will call PostWork() to get work done. This will
//				 result in one of the worker threads returning from 
//				 GetQueuedCompletionStatus() and calling the derived class'
//				 WorkCompletion() routine with a pvContext.
//
//				 NOTE: the base class has no knowledge of the type of work
//				 getting done. It just manages the details of getting work
//				 requests and distributing it to threads in its pool. This 
//				 allows the derived class to focus on processing the actual
//				 work item without bothering about queueing etc.
//
//				 Completion ports are used merely to leverage its queueing
//				 semantics and not for I/O. If the work done by each thread
//				 is fairly small, LIFO semantics of completion ports will 
//				 reduce context switches.
//
//  Functions:  
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------

#ifndef THRDPOOL_H
#define THRDPOOL_H

//
//	This is the blob that is passed thro the completion port 
//
typedef struct _WorkContextEnv
{
	OVERLAPPED		Ov;					// needed by Post/GetQueuedCompletionStatus
	PVOID			pvWorkContext;		// actual work context - user defined 
} WorkContextEnv, *LPWorkContextEnv;

//
//	Base worker thread class
//
class CWorkerThread
{
public:
	//
	//	Constructor, destructor
	//
	CWorkerThread();
	virtual ~CWorkerThread();

	//
	//	class initializer - should be called once before this class is used
	//
	static BOOL InitClass( DWORD dwConcurrency );

	//
	//	class terminator - should be called once when done using the class
	//
	static BOOL TermClass();

	//
	//	clients should call this to post work items
	//
	BOOL 						PostWork(PVOID pvWorkContext);

	//
	//	expose shutdown event
	//
	HANDLE QueryShutdownEvent() { return m_hShutdownEvent; }

protected:

	//
	//	derived method called when work items are posted
	//
	virtual VOID 				WorkCompletion(PVOID pvWorkContext) = 0;

private:

	//
	//	check for matching InitClass(), TermClass() calls
	//
	static	LONG				m_lInitCount;

	//
	//	handle to completion port
	//
	static HANDLE				m_hCompletionPort;

	//
	//	handle to worker thread
	//
	HANDLE						m_hThread;

	//
	//	shutdown event
	//
	HANDLE						m_hShutdownEvent;

	//
	//	thread function
	//
	static DWORD __stdcall 		ThreadDispatcher(PVOID pvWorkerThread);

	//
	//	block on GetQueuedCompletionStatus for work items
	//
	VOID 						GetWorkCompletion(VOID);
};

#endif		// #ifndef THRDPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tran_evntlog.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        
    Copyright (C) 1998 Microsoft Corporation
    All rights reserved.

    File:       evntlog.h

    Abstract:   EventLog DLL interface

    Authors:    Hao Zhang

    History:    Oct 25, 1999
                
----------------------------------------------------------------------*/
#define TRAN_CAT_ROUTING_ENGINE                                      1
#define TRAN_CAT_CATEGORIZER                                         2
#define TRAN_CAT_CONNECTION_MANAGER                                  3
#define TRAN_CAT_QUEUE_ENGINE                                        4
#define TRAN_CAT_EXCHANGE_STORE_DRIVER                               5      
#define TRAN_CAT_SMTP_PROTOCOL                                       6
#define TRAN_CAT_NTFS_STORE_DRIVER                                   7

#define LOGEVENT_LEVEL_FIELD_ENGINEERING       7
#define LOGEVENT_LEVEL_MAXIMUM                 5
#define LOGEVENT_LEVEL_MEDIUM                  3
#define LOGEVENT_LEVEL_MINIMUM                 1
#define LOGEVENT_LEVEL_NONE                    0

#define LOGEVENT_FLAG_ALWAYS		   0x00000001
#define LOGEVENT_FLAG_ONETIME		   0x00000002
#define LOGEVENT_FLAG_PERIODIC	       0x00000003
// we use the lower 8 bits for various logging modes, and reserve the
// other 24 for flags
#define LOGEVENT_FLAG_MODEMASK         0x000000ff

// 100ns units between periodic event logs.  this can't be larger then 
// 0xffffffff
#define LOGEVENT_PERIOD (DWORD) (3600000000) // 60 minutes 

//
// setup DLL Export macros
//
#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif

#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif

/******************************************************************************/
DllExport
HRESULT TransportLogEvent(
    IN DWORD idMessage,
    IN WORD idCategory,
    IN WORD cSubstrings,
    IN LPCSTR *rgszSubstrings,
    IN WORD wType,
    IN DWORD errCode,
    IN WORD iDebugLevel,
    IN LPCSTR szKey,
    IN DWORD dwOptions);

DllExport
HRESULT TransportLogEventEx(
    IN DWORD idMessage,
    IN WORD idCategory,
    IN WORD cSubstrings,
    IN LPCSTR *rgszSubstrings,
    IN WORD wType,
    IN DWORD errCode,
    IN WORD iDebugLevel,
    IN LPCSTR szKey,
    IN DWORD dwOptions,
    DWORD iMessageString,
    HMODULE hModule);

DllExport
HRESULT TransportLogEventFieldEng(
    IN DWORD idMessage,
    IN WORD idCategory,
    IN LPCTSTR format,
    ...
    );
 
DllExport 
HRESULT TransportResetEvent(
    IN DWORD idMessage,
    IN LPCSTR szKey);

DllExport 
DWORD TransportGetLoggingLevel(
    IN WORD idCategory);

DllExport
HRESULT TransportLogEventInit ();

//
// Attention:
// Make sure that no other logging was called
// before calling this Deinit function
//
DllExport
HRESULT TransportLogEventDeinit ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\transmem.h ===
//-----------------------------------------------------------------------------
//
//  File:        TRANSMEM.H
//
//  Copyright Microsoft Corporation 1997, All Rights Reserved.
//
//  Owner: NIKOS
//
//  Description: This file contains memory routines and macros for using 
//               EXCHMEM as a dynamic memory allocator. If your object can
//               be made fixed in size, it may be more appropriate to use
//               CPool especially if your object is allocated/freed often.
//                
//               Note: CPool never releases (frees) objects, so some sort of
//                     free such objects may also be needed.
//
//  Modified 2/98 by mikeswa - Added Multi-heap support
//-----------------------------------------------------------------------------

#ifndef __TRANSMEM_H__
#define __TRANSMEM_H__

#include <exchmem.h>
#include <cpool.h>

#define HEAP_LOW_MEMORY_RESERVE 65536   // to be freed when we're low on memory

//define number of exchmem heaps if not already defined
#ifndef  NUM_EXCHMEM_HEAPS
#define  NUM_EXCHMEM_HEAPS   0
#endif  //NUM_EXCHMEM_HEAPS


//
// These three globals:
//
// HANDLE g_hTransHeap = NULL;
//
// must be declared somewhere in a C file so things will link properly. The macros
// declared use these to store heap handles, etc. to make things work.
//
#ifdef __cplusplus
extern "C" {
#endif
    extern HANDLE g_hTransHeap;
#ifdef __cplusplus
}
#endif

//
// TrHeapCreate needs to be called once at startup time to initialize Exchmem and create
// the heap.
//
#ifdef __cplusplus
__inline BOOL TrHeapCreate(DWORD dwFlags=0, DWORD dwInitialSize=1024000, DWORD dwMaxSize=0)
#else
__inline BOOL TrHeapCreate(DWORD dwFlags, DWORD dwInitialSize, DWORD dwMaxSize)
#endif
{
    if (g_hTransHeap)
        return FALSE;

    g_hTransHeap = ExchMHeapCreate(NUM_EXCHMEM_HEAPS, dwFlags, dwInitialSize, dwMaxSize);

    if (g_hTransHeap)
        return TRUE;
    else
        return FALSE;
}

//
// TrHeapDestroy() needs to be called once at shutdown time to free the heap and it's contents.
//
// Note: Because the heap is destroyed before the module is finished unloading, all objects that
//       allocated memory must be destroyed (with delete) before the module is unloaded. If not
//       done, nasty crashes will result. This is a BAD thing to do:
//
// CObject g_Object;
//
// CObject::~CObject()
// {
//     if (NULL != m_pBuffer)
//     {
//         TrFree(m_pBuffer);
//         m_pBuffer = NULL;
//     }
// }
//
// since ~CObject() will be called AFTER TrHeapDestroy, and TrFree will be called on a (destroyed) heap.
//
__inline BOOL TrHeapDestroy(void)
{
    BOOL b = TRUE;

    if (g_hTransHeap)
    {
        b = ExchMHeapDestroy();
        g_hTransHeap = NULL;
    }

    return b;
}

//
// TrCalloc: replacement for calloc()
//                    
__inline void * TrCalloc(unsigned int x, unsigned int y, char * szFile = __FILE__, unsigned int uiLine = __LINE__)
{
    return g_hTransHeap ? ExchMHeapAllocDebug(x*y, szFile, uiLine) : NULL;
}
        

//
// TrFree: replacement for free() 
__inline void TrFree(void *pv)
{
    if (g_hTransHeap)
    {
        ExchMHeapFree(pv);
    }
    else
    {
        // Our allocs / frees are out of sync.
#ifdef DEBUG
        DebugBreak();
#endif
    }
}

// TrMalloc: replacement for malloc()
__inline void * TrMalloc(unsigned int size, char * szFile = __FILE__, unsigned int uiLine = __LINE__)
{
    return g_hTransHeap ? ExchMHeapAllocDebug(size, szFile, uiLine) : NULL;
}

// TrRealloc: replacement for realloc()
__inline void * TrRealloc(void *pv, unsigned int size, char * szFile = __FILE__, unsigned int uiLine = __LINE__)
{
    return g_hTransHeap ? ExchMHeapReAllocDebug(pv, size, szFile, uiLine) : NULL;
}

#ifdef __cplusplus
#define TransCONST const
#else
#define TransCONST
#endif

// TrStrdupW: replacement for wcsdup()
__inline LPWSTR TrStrdupW(TransCONST LPWSTR pwszString)
{
    LPWSTR pwszTmp = NULL;
    
    if (NULL == g_hTransHeap || NULL == pwszString)
        return NULL;
    
    pwszTmp = (LPWSTR) ExchMHeapAlloc((wcslen(pwszString) + 1) * sizeof(WCHAR));
    if (NULL != pwszTmp)
        wcscpy(pwszTmp,pwszString);

    return pwszTmp;
}

// TrStrdupA: replacement for strdup()
__inline LPSTR TrStrdupA(TransCONST LPSTR pszString)
{
    LPSTR pszTmp = NULL;
    
    if (NULL == g_hTransHeap || NULL == pszString)
        return NULL;
    
    pszTmp = (LPSTR) ExchMHeapAlloc((strlen(pszString) + 1) * sizeof(CHAR));
    if (NULL != pszTmp)
        strcpy(pszTmp,pszString);

    return pszTmp;
}


#ifdef _UNICODE
#define TrStrdup(x) TrStrdupW(x)
#else
#define TrStrdup(x) TrStrdupA(x)
#endif

//
// Please use the pv* macros... defined here allocators may change over time and this will
// make it easy to change when needed.
//
#define pvMalloc(x)        TrMalloc(x, __FILE__, __LINE__)
#define FreePv(x)          TrFree(x)
#define pvCalloc(x,y)      TrCalloc(x,y, __FILE__, __LINE__)
#define pszStrdup(x)       TrStrdup(x)
#define pvRealloc(pv,size) TrRealloc(pv, size, __FILE__, __LINE__)

#ifdef __cplusplus
// Replacement for the default new() operator
__inline void * __cdecl operator new(size_t stAllocateBlock)
{
    return TrMalloc( stAllocateBlock );
}

// Replacement for the default new() operator that allows 
//specification of file and line #
// To use this allocator as your default allocator, simply use the following:
//#define new TRANSMEM_NEW
//NOTE: You must be careful when you redefine this macro... it may cause
//problems with overloaded new operators (a la CPOOL or STL).
#define TRANSMEM_NEW new(__FILE__, __LINE)
__inline void * __cdecl operator new(size_t stAllocateBlock, char * szFile, unsigned int uiLine)
{
    return TrMalloc( stAllocateBlock, szFile, uiLine );
}
// Replacement for the default delete() operator
__inline void __cdecl operator delete( void *pvMem )
{
    FreePv( pvMem );
}

#endif

// Convenient macro to set the pointer you freed to NULL as well
#define TRFREE(x) \
if (NULL != x) \
{ \
    FreePv(x); \
    x = NULL; \
}

// Convenient macro to set the pointer to the object to NULL as well
#define TRDELETE(x) \
if (NULL != x) \
{ \
    delete x; \
    x = NULL; \
}

#endif /* __TRANSMEM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\vroot.h ===
#ifndef __VROOT_H__
#define __VROOT_H__

#include <dbgtrace.h>
#include <iadmw.h>
#include <mddefw.h>
#include <tflist.h>
#include <rwnew.h>
#include <refptr2.h>
#include <listmacr.h>

#define MAX_VROOT_PATH MAX_PATH + 1

class CVRootTable;

#define VROOT_GOOD_SIG  'TOOR'
#define VROOT_BAD_SIG   'ROOT'

//
// There is one of these objects for each of the VRoots defined.  It contains
// the VRoot parameters.  The only parameter used by the VRoot library is the
// vroot name, but users of this library should inherit from this and make
// their own version which stores all of the other parameters of interest.
//
class CVRoot : public CRefCount2 {
        public:
                CVRoot() {
                        m_fInit = FALSE;
                        m_pPrev = NULL;
                        m_pNext = NULL;
                        m_dwSig = VROOT_GOOD_SIG;
                }

                virtual ~CVRoot();

                //
                // initialize this class.
                //
                void Init(LPCSTR pszVRootName, CVRootTable *pVRootTable, LPCWSTR wszConfigPath, BOOL fUpgrade );

                //
                // get the vroot name (and optionally its length) from this entry.
                //
                LPCSTR GetVRootName(DWORD *pcch = NULL) { 
                        _ASSERT(m_fInit);
                        if (pcch != NULL) *pcch = m_cchVRootName;
                        return m_szVRootName; 
                }

                // get the MB configuration path
                LPCWSTR GetConfigPath() { return m_wszConfigPath; }

                //
                // This needs to be defined by a subclass of CVRoot.
                //
                virtual HRESULT ReadParameters(IMSAdminBase *pMB, 
                                                   METADATA_HANDLE hmb) = 0;

                //
                // Virtual function for handling orphan VRoot during VRootRescan/VRootDelete
                //
                virtual void DispatchDropVRoot() {};

                // the next and previous pointers for our list
                CVRoot *m_pPrev;
                CVRoot *m_pNext;

#ifdef DEBUG
    LIST_ENTRY  m_DebugList;
#endif

        protected:

        DWORD   m_dwSig;
                BOOL m_fInit;
                // the name of this vroot (alt.binaries for example) and its length.
                char m_szVRootName[MAX_VROOT_PATH];
                DWORD m_cchVRootName;
                // the table which owns us
                CVRootTable *m_pVRootTable;
                // our config path in the metabase
                WCHAR m_wszConfigPath[MAX_VROOT_PATH];
                // upgrad flag
                BOOL m_fUpgrade;
};

typedef CRefPtr2<CVRoot> VROOTPTR;

//
// an implementation of CVRoot which reads the parameters likely to be used
// by all IIS based client of this VRoot implementation.
//
class CIISVRoot : public CVRoot {
        public:
                virtual ~CIISVRoot() {}

                void Init(void *pContext,                       // ignored
                              LPCSTR pszVRootName,              // passed to CVRoot::Init
                                  CVRootTable *pVRootTable,     // passed to CVRoot::Init
                              LPCWSTR pwszConfigPath,
                              BOOL fUpgrade )   // available via GetConfigPath()
                {
                        CVRoot::Init(pszVRootName, pVRootTable, pwszConfigPath, fUpgrade);
                        m_pContext = pContext;
                }

                // get the context pointer
                void *GetContext() { return m_pContext; }

                // SSL properties
                DWORD GetSSLAccessMask() { return m_dwSSL; }

                // access properties
                DWORD GetAccessMask() { return m_dwAccess; }

                // is the content indexed?
                BOOL IsContentIndexed() { return m_fIsIndexed; }

                // this method reads the parameters below from the metabase
                virtual HRESULT ReadParameters(IMSAdminBase *pMB, 
                                                                           METADATA_HANDLE hmb);

        protected:
                // this method reads a dword from the metabase (wraps GetData())
                virtual HRESULT GetDWord(IMSAdminBase *pMB,
                                                                 METADATA_HANDLE hmb,
                                                                 DWORD dwId,
                                                                 DWORD *pdw);

                // this method reads a string from the metabase (wraps GetData())
                virtual HRESULT GetString(IMSAdminBase *pMB,
                                                                  METADATA_HANDLE hmb,
                                                                  DWORD dwId,
                                                                  LPWSTR szString,
                                                                  DWORD *pcString);

        protected:
                // parameters given to use by the constructor
                void *m_pContext;

                // parameters read from the metabase
                BOOL m_fIsIndexed;                                      // is the content indexed?
                BOOL m_fDontLog;                                        // should logging be disabled here?
                DWORD m_dwAccess;                                       // access permissions bitmask
                DWORD m_dwSSL;                                          // SSL access perm's bitmask

};

//
// a subclass of the above which hides the fact that context is a void *.
//
// template arguments:
//  _context_type - the type for the context.  must be castable to void *.
//
template <class _context_type>
class CIISVRootTmpl : public CIISVRoot {
        public:
                virtual ~CIISVRootTmpl() {}

                void Init(_context_type pContext,
                              LPCSTR pszVRootName, 
                                  CVRootTable *pVRootTable,
                                  LPCWSTR pwszConfigPath,
                                  BOOL fUpgrade )
                {
                        CIISVRoot::Init((void *) pContext, 
                                                        pszVRootName, 
                                                        pVRootTable,
                                                        pwszConfigPath,
                                                        fUpgrade );
                }

                // return the context pointer (mostly likely a pointer to an IIS 
                // instance)
                _context_type GetContext() { 
                        return (_context_type) CIISVRoot::GetContext(); 
                }
};

//
// this is a type that points to a function which can create CVRoot objects.
// use it to create your own version of the CVRoot class.
//
// parameters:
//  pContext - the context pointer passed into CVRootTable
//  pszVRootName - the name of the vroot
//  pwszConfigPath - a Unicode string with the path in the metabase for 
//                   this vroot's configuration information.
//
typedef VROOTPTR (*PFNCREATE_VROOT)(void *pContext, 
                                                                    LPCSTR pszVRootName,
                                                                        CVRootTable *pVRootTable,
                                                                    LPCWSTR pwszConfigPath,
                                                                    BOOL fUpgrade );

//
// a function of this type is called when the vroot table is scanned.  it
// is passed a copy of the context pointer
//
typedef void (*PFN_VRTABLE_SCAN_NOTIFY)(void *pContext);

typedef void (*PFN_VRENUM_CALLBACK)(void *pEnumContext,
                                                                        CVRoot *pVRoot);

//
// The CVRootTable object keeps a list of VRoots and can find a vroot for
// a given folder.
//
class CVRootTable {
        public:
                static HRESULT GlobalInitialize();
                static void GlobalShutdown();
                CVRootTable(void *pContext, 
                                        PFNCREATE_VROOT pfnCreateVRoot,
                                        PFN_VRTABLE_SCAN_NOTIFY pfnScanNotify);
                virtual ~CVRootTable();
                HRESULT Initialize(LPCSTR pszMBPath, BOOL fUpgrade );
                HRESULT Shutdown(void);
                HRESULT FindVRoot(LPCSTR pszPath, VROOTPTR *ppVRoot);
                HRESULT EnumerateVRoots(void *pEnumContext, 
                                                                PFN_VRENUM_CALLBACK pfnCallback);

        private:
                VROOTPTR NewVRoot();
                HRESULT ScanVRoots( BOOL fUpgrade );
                HRESULT InitializeVRoot(CVRoot *pVRoot);
                HRESULT InitializeVRoots();
                HRESULT ScanVRootsRecursive(METADATA_HANDLE hmbParent, 
                                                                        LPCWSTR pwszKey, 
                                                                        LPCSTR pszVRootName,
                                                                        LPCWSTR pwszPath,
                                                                        BOOL    fUpgrade );
                void InsertVRoot(VROOTPTR pVRoot);

                // find a vroot
                HRESULT FindVRootInternal(LPCSTR pszPath, VROOTPTR *ppVRoot);

                // convert a config path to a vroot name
                void ConfigPathToVRootName(LPCWSTR pwszConfigPath, LPSTR szVRootName);

                // used to pass metabase notifications back into this object
                static void MBChangeNotify(void *pThis, 
                                                                   DWORD cChangeList, 
                                                                   MD_CHANGE_OBJECT_W pcoChangeList[]);

                // parameters changed under a vroot
                void VRootChange(LPCWSTR pwszConfigPath, LPCSTR pszVRootName);

                // a vroot was deleted
                void VRootDelete(LPCWSTR pwszConfigPath, LPCSTR pszVRootName);

                // a vroot was added
                void VRootAdd(LPCWSTR pwszConfigPath, LPCSTR pszVRootName);

                // rescan the whole vroot list
                void VRootRescan(void);

#ifdef DEBUG
        LIST_ENTRY      m_DebugListHead;
        CShareLockNH    m_DebugListLock;
        
        void DebugPushVRoot( CVRoot *pVRoot ) {
            _ASSERT( pVRoot );
            m_DebugListLock.ExclusiveLock();
            InsertTailList( &m_DebugListHead, &pVRoot->m_DebugList );
            m_DebugListLock.ExclusiveUnlock();
        }

        void DebugExpungeVRoot( CVRoot *pVRoot ) {
            m_DebugListLock.ExclusiveLock();
            RemoveEntryList( &pVRoot->m_DebugList );
            m_DebugListLock.ExclusiveUnlock();
        }
#endif

                // locking: for walking the list either m_lock.ShareLock must be
                // held or m_cs must be held.  For editting the list both 
                // m_lock.ExclusiveLock must be held and m_cs must be held.  
                // When making large changes (such as rebuilding the entire list)
                // m_cs should be held until all of the changes are complete.

                // lock for the vroot list
                CShareLockNH m_lock;

                // critical section used for making global changes on the vroot
                // list.  this is used to make sure that only one thread can editting
                // the list at a time
                CRITICAL_SECTION m_cs;

                // our context pointer
                void *m_pContext;

                // the path to our metabase area
                WCHAR m_wszRootPath[MAX_VROOT_PATH];
                DWORD m_cchRootPath;

                // have we been initialized?
                BOOL m_fInit;

        // are we shutting down?
        BOOL m_fShuttingDown;

                // function to create a new vroot object
                PFNCREATE_VROOT m_pfnCreateVRoot;

                // function to call when the vroot table is rescanned
                PFN_VRTABLE_SCAN_NOTIFY m_pfnScanNotify;

                // the list of vroots
                TFList<CVRoot> m_listVRoots;

                // this RW lock is used to figure out when all of the VRoot objects
                // have shutdown.  They hold a ShareLock on it for their lifetime,
                // so the CVRootTable can grab an ExclusiveLock to wait for all of
                // the VRoot objects to disappear.
                CShareLockNH m_lockVRootsExist;

                // these guys need access to m_lockVRootsExist
                friend void CVRoot::Init(LPCSTR, CVRootTable *, LPCWSTR, BOOL);
                friend CVRoot::~CVRoot();
};

//
// this is a templated version of CIISVRootTable.  You tell it the version of
// CVRoot that you are using, and the context type that you are using.  
//
// template arguments:
//  _CVRoot - a subclass of CVRoot that you'll be using
//  _context_type - the type that you'll be using for context information.
//                  this must be castable to void *.
//
template <class _CVRoot, class _context_type>
class CIISVRootTable {
        public:
                CIISVRootTable(_context_type pContext,
                               PFN_VRTABLE_SCAN_NOTIFY pfnScanNotify) : 
                        impl((void *) pContext, 
                             CIISVRootTable<_CVRoot, _context_type>::CreateVRoot, pfnScanNotify) 
                {
                }
                HRESULT Initialize(LPCSTR pszMBPath, BOOL fUpgrade ) {
                        return impl.Initialize(pszMBPath, fUpgrade);
                }
                HRESULT Shutdown(void) {
                        return impl.Shutdown();
                }
                HRESULT FindVRoot(LPCSTR pszPath, CRefPtr2<_CVRoot> *ppVRoot) {
                        return impl.FindVRoot(pszPath, (VROOTPTR *) ppVRoot);
                }
                HRESULT EnumerateVRoots(void *pEnumContext, 
                                                                PFN_VRENUM_CALLBACK pfnCallback) 
                {
                        return impl.EnumerateVRoots(pEnumContext, pfnCallback);
                }
        private:
                static VROOTPTR CreateVRoot(void *pContext, 
                                            LPCSTR pszVRootName, 
                                            CVRootTable *pVRootTable, 
                                            LPCWSTR pwszConfigPath,
                                            BOOL fUpgrade) 
                {                                                               
                        // create the vroot object
                        CRefPtr2<_CVRoot> pVRoot = new _CVRoot;
                        // initialize it
                        pVRoot->Init((_context_type) pContext, 
                                                 pszVRootName, 
                                                 pVRootTable,
                                                 pwszConfigPath,
                                                 fUpgrade );
                        return (_CVRoot *)pVRoot;
                }

                CVRootTable impl;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\wcguids.h ===
/*
**	wcguids.h
**
**	the MSN WC guid block starts at 4d9e4500-6de1-11cf-87a7-444553540000
**	and goes through 4d9e45ff.
*/

#define DEFINE_WC_GUID(clsname, num) \
	DEFINE_GUID(clsname, 0x4d9e45##num, 0x6de1, 0x11cf, \
				0x87, 0xa7, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)


DEFINE_WC_GUID(CLSID_MSNUserPrefs,				00);	// CLSID:	MSN User Prefs object
DEFINE_WC_GUID(CLSID_SSOChatQuery,				01);	// CLSID:	SSO Chat Client Object
DEFINE_WC_GUID(CLSID_SSOVote,					02);	// CLSID:	SSO Vote Object
DEFINE_WC_GUID(CLSID_SSOSMail,					03);	// CLSID:	SSO SMail.DLL
DEFINE_WC_GUID(CLSID_SSOChatMonitor,			04);	// CLSID:	SSO Chat transcript -> SQL object
DEFINE_WC_GUID(CLSID_SSONextLink,				05);	// CLSID:	NextLink SSO
DEFINE_WC_GUID(CLSID_SSOChatTranscript,			06);	// CLSID:	SSO SQL -> IIS object
DEFINE_WC_GUID(CLSID_SSOAcctBill,				07);	// CLSID:	SSO OLS & Change Payments
DEFINE_WC_GUID(CLSID_SSOUserSurvey,				08);	// CLSID:	SSO User Survey
DEFINE_WC_GUID(CLSID_SSOPropAdm,				09);	// CLSID:	SSO PropDB Admin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\unlodctr.h ===
/*++

unlodctr.h

    Definitions that are specific to the counter unloader
   
Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#ifndef _UNLODCTR_H_
#define _UNLODCTR_H_

// resource file constants
#define UC_CMD_HELP_1       201
#define UC_CMD_HELP_2       202
#define UC_CMD_HELP_3       203
#define UC_CMD_HELP_4       204
#define UC_CMD_HELP_5       205
#define UC_CMD_HELP_6       206
#define UC_CMD_HELP_7       207
#define UC_CMD_HELP_8       208
#define UC_CMD_HELP_9       209
#define UC_CMD_HELP_10      210
#define UC_CMD_HELP_11      211
#define UC_FIRST_CMD_HELP   UC_CMD_HELP_1
#define UC_LAST_CMD_HELP    UC_CMD_HELP_11
                           
#define UC_ERROR_READ_NAMES 110
#define UC_DRIVERNOTFOUND   111
#define UC_NOTINSTALLED     112
#define UC_REMOVINGDRIVER   113
#define UC_UNABLEOPENKEY    114
#define UC_UNABLESETVALUE   115
#define UC_UNABLEREADVALUE  116
#define UC_UNEVENINDEX      117
#define UC_DOINGLANG        118
#define UC_UNABLEMOVETEXT   119
#define UC_UNABLELOADLANG   120 
#define UC_PERFLIBISBUSY    121
#define UC_CONNECT_PROBLEM  122

#endif // _UNLODCTR_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\tunk.h ===
//---[ tunk.h ]----------------------------------------------------------------
//
//    Template for IUnknown<T>
//
//-----------------------------------------------------------------------------

#pragma once

#ifndef _TUNK_H_
#define _TUNK_H_

template<class T>
class TUnknown : public T
{
public:
    TUnknown (REFIID iid) : m_nRef(1), m_iid(iid) {}
    virtual ~TUnknown() {}

    virtual ULONG __stdcall AddRef()
    {   return ++m_nRef; }

    virtual ULONG __stdcall Release()
    {
        int nRef = --m_nRef;

        if (!nRef)
            delete this;

        return nRef;
    }

    virtual HRESULT __stdcall QueryInterface(REFIID iid, void ** lppv)
    {
        if ((iid == IID_IUnknown) ||
			(iid == m_iid))
        {
            *lppv = this;
            AddRef();
            return S_OK;
        }
        else
        {
            *lppv = NULL;
            return E_NOINTERFACE;

        }
    }

protected:
    int m_nRef;
    REFIID m_iid;
};

template<class T1, class T2>
class TUnknown2 : public T1, public T2
{
public:
    TUnknown2 (REFIID iid, REFIID iid2) : m_nRef(1), m_iid(iid), m_iid2(iid2) {}
    virtual ~TUnknown2() {}

    virtual ULONG __stdcall AddRef()
    {   return ++m_nRef; }

    virtual ULONG __stdcall Release()
    {
        int nRef = --m_nRef;

        if (!nRef)
            delete this;

        return nRef;
    }

    virtual HRESULT __stdcall QueryInterface(REFIID iid, void ** lppv)
    {
        if ((iid == IID_IUnknown) ||
			(iid == m_iid))
        {
            *lppv = (LPUNKNOWN)(T1*)this;
            AddRef();
            return S_OK;
        }
		else if (iid == m_iid2)
		{
            *lppv = (LPUNKNOWN)(T2*)this;
            AddRef();
            return S_OK;
		}
        else
        {
            *lppv = NULL;
            return S_FALSE;
        }
    }

protected:
    int m_nRef;
    REFIID m_iid;
    REFIID m_iid2;
};

template<class T1, class T2, class T3>
class TUnknown3 : public T1, public T2, public T3
{
public:
    TUnknown3 (REFIID iid, REFIID iid2, REFIID iid3) : m_nRef(1), m_iid(iid), m_iid2(iid2), m_iid3(iid3) {}
    virtual ~TUnknown3() {}

    virtual ULONG __stdcall AddRef()
    {   return ++m_nRef; }

    virtual ULONG __stdcall Release()
    {
        int nRef = --m_nRef;

        if (!nRef)
            delete this;

        return nRef;
    }

    virtual HRESULT __stdcall QueryInterface(REFIID iid, void ** lppv)
    {
        if ((iid == IID_IUnknown) ||
			(iid == m_iid))
        {
            *lppv = (LPUNKNOWN)(T1*)this;
            AddRef();
            return S_OK;
        }
		else if (iid == m_iid2)
		{
            *lppv = (LPUNKNOWN)(T2*)this;
            AddRef();
            return S_OK;
		}
		else if (iid == m_iid3)
		{
            *lppv = (LPUNKNOWN)(T3*)this;
            AddRef();
            return S_OK;
		}
        else
        {
            *lppv = NULL;
            return S_FALSE;
        }
    }

protected:
    int m_nRef;
    REFIID m_iid;
    REFIID m_iid2;
    REFIID m_iid3;
};

template<class T1, class T2, class T3, class T4>
class TUnknown4 : public T1, public T2, public T3, public T4
{
public:
    TUnknown4 (REFIID iid, REFIID iid2, REFIID iid3, REFIID iid4) : 
        m_nRef(1), m_iid(iid), m_iid2(iid2), m_iid3(iid3), m_iid4(iid4) {}
    virtual ~TUnknown4() {}

    virtual ULONG __stdcall AddRef()
    {   return ++m_nRef; }

    virtual ULONG __stdcall Release()
    {
        int nRef = --m_nRef;

        if (!nRef)
            delete this;

        return nRef;
    }

    virtual HRESULT __stdcall QueryInterface(REFIID iid, void ** lppv)
    {
        if ((iid == IID_IUnknown) ||
			(iid == m_iid))
        {
            *lppv = (LPUNKNOWN)(T1*)this;
            AddRef();
            return S_OK;
        }
		else if (iid == m_iid2)
		{
            *lppv = (LPUNKNOWN)(T2*)this;
            AddRef();
            return S_OK;
		}
		else if (iid == m_iid3)
		{
            *lppv = (LPUNKNOWN)(T3*)this;
            AddRef();
            return S_OK;
		}
		else if (iid == m_iid4)
		{
            *lppv = (LPUNKNOWN)(T4*)this;
            AddRef();
            return S_OK;
		}
        else
        {
            *lppv = NULL;
            return S_FALSE;
        }
    }

protected:
    int m_nRef;
    REFIID m_iid;
    REFIID m_iid2;
    REFIID m_iid3;
    REFIID m_iid4;
};

template<class T1, class T2, class T3, class T4, class T5>
class TUnknown5 : public T1, public T2, public T3, public T4, public T5
{
public:
    TUnknown5 (REFIID iid, REFIID iid2, REFIID iid3, REFIID iid4, REFIID iid5) : 
        m_nRef(1), m_iid(iid), m_iid2(iid2), m_iid3(iid3), m_iid4(iid4), m_iid5(iid5) {}
    virtual ~TUnknown5() {}

    virtual ULONG __stdcall AddRef()
    {   return ++m_nRef; }

    virtual ULONG __stdcall Release()
    {
        int nRef = --m_nRef;

        if (!nRef)
            delete this;

        return nRef;
    }

    virtual HRESULT __stdcall QueryInterface(REFIID iid, void ** lppv)
    {
        if ((iid == IID_IUnknown) ||
			(iid == m_iid))
        {
            *lppv = (LPUNKNOWN)(T1*)this;
            AddRef();
            return S_OK;
        }
		else if (iid == m_iid2)
		{
            *lppv = (LPUNKNOWN)(T2*)this;
            AddRef();
            return S_OK;
		}
		else if (iid == m_iid3)
		{
            *lppv = (LPUNKNOWN)(T3*)this;
            AddRef();
            return S_OK;
		}
		else if (iid == m_iid4)
		{
            *lppv = (LPUNKNOWN)(T4*)this;
            AddRef();
            return S_OK;
		}
		else if (iid == m_iid5)
		{
            *lppv = (LPUNKNOWN)(T5*)this;
            AddRef();
            return S_OK;
		}
        else
        {
            *lppv = NULL;
            return S_FALSE;
        }
    }

protected:
    int m_nRef;
    REFIID m_iid;
    REFIID m_iid2;
    REFIID m_iid3;
    REFIID m_iid4;
    REFIID m_iid5;
};

#endif // _TUNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\wcsutil.h ===
/*
**	wcsutil.h
**	Sean P. Nolan
**	
**	server-side utils
*/

#ifndef _WCSUTIL_H_
#define _WCSUTIL_H_

#include <windows.h>
#include <ole2.h>
#include <winsock.h>
#include <httpext.h>
#include "wcguids.h"

/*--------------------------------------------------------------------------+
|	Utilities Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern LPSTR g_szSSOProgID;

// Logging to application event log -- see ReportEvent() in win32 sdk
// documentation for information on wType and dwEventID.
void LogEvent(WORD wType, DWORD dwEventID, char *sz);

// Asserts
#ifdef DEBUG
extern void AssertProc(PCSTR szFile, DWORD dwLine, PCSTR szMsg, DWORD dwFlags);
#define AssertSzFlg(f, sz, dwFlag)		( (f) ? 0 : AssertProc(__FILE__, __LINE__, sz, dwFlag))
#else // !DEBUG
#define AssertSzFlg(f, sz, dwFlg)
#endif // !DEBUG

#define AP_GETLASTERROR		0x00000001

// under non-debug, AssertSzFlg is defined away, so these #defines don't
// have to be #ifdef DEBUG
#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
#define AssertEx(f)					AssertSz((f), "!(" #f ")")
#define Assert(f)					AssertEx(f)
#define AssertSzGLE(f, sz)			AssertSzFlg(f, sz, AP_GETLASTERROR)
#define AssertExGLE(f)				AssertSzGLE((f), "!(" #f ")")

// Debug Printing
#ifdef DEBUG
int dbgprintf(PCSTR pFormat, ...);
#else
#define dbgprintf()
#endif

// Memory Mgmt
LPVOID _MsnAlloc(DWORD cb);
LPVOID _MsnRealloc(LPVOID pv, DWORD cb);
void _MsnFree(LPVOID pv);

// Data Munging
LPSTR _SzFromVariant(VARIANT *pvar);
BSTR _BstrFromVariant(VARIANT *pvar, BOOL *pfFree);
BOOL _FIntFromVariant(VARIANT *pvar, int *pi);

// String Manipulation / Parsing											
void _AnsiStringFromGuid(REFGUID rguid, LPSTR sz);
LPSTR _SkipWhiteSpace(LPSTR sz);
LPSTR _FindEndOfLine(LPSTR sz);
DWORD _atoi(LPSTR sz);

// URL Fiddling
int UrlType(char *szUrl);
#define URL_TYPE_ABSOLUTE		0		// e.g. http://foo/bar or just //foo.com/bar.htm
#define URL_TYPE_LOCAL_ABSOLUTE	1		// e.g. /foo/bar/baz.htm
#define URL_TYPE_RELATIVE		2		// e.g. xyzzy/plugh.html

// IIS Hacks
#ifdef _HTTPEXT_H_
BOOL _FTranslateVirtualRoot(EXTENSION_CONTROL_BLOCK *pecb, LPSTR szPathIn, 
							LPSTR szPathTranslated, DWORD cbPathTranslated);
#endif // _HTTPEXT_H_

// Critical Sections
class CCritSec
	{
	private:
		CRITICAL_SECTION	m_cs;

	public:
		CCritSec(void)		{ ::InitializeCriticalSection(&m_cs);	}
		~CCritSec(void)		{ ::DeleteCriticalSection(&m_cs);		}
		void Lock(void)		{ ::EnterCriticalSection(&m_cs);		}
		void Unlock(void)	{ ::LeaveCriticalSection(&m_cs);		}
	};

/*--------------------------------------------------------------------------+
|	CThingWatcher/CFileWatcher/CRegKeyWatcher								|
+--------------------------------------------------------------------------*/

typedef void (*PFNFILECHANGED)(LPSTR szFile, LONG lUser);
typedef void (*PFNREGKEYCHANGED)(HKEY hkey, LONG lUser);

typedef int (__stdcall *PFNCLOSEHEVTNOTIFY)(HANDLE hevtNotify);

class CThingWatcher
{
	friend DWORD ThingWatcherThread(CThingWatcher *pfw);

public:
	CThingWatcher(PFNCLOSEHEVTNOTIFY pfnCloseHevtNotify);
	~CThingWatcher();
	
	BOOL				FWatchHandle(HANDLE hevtNotify);

private:	
	virtual BOOL		FireChange(DWORD dwWait)			= 0;

	HANDLE				m_rghWait[2];
	HINSTANCE           m_hModule;
	PFNCLOSEHEVTNOTIFY	m_pfnCloseHevtNotify;
};

class CFileWatcher : public CThingWatcher
{
private:
	char			m_szPath[MAX_PATH];
	FILETIME		m_ftLastWrite;
	LONG			m_lUser;
	PFNFILECHANGED	m_pfnChanged;
	BOOL			m_fDirectory;
	HANDLE			m_hevtNotify;

public:
	CFileWatcher(void);
	~CFileWatcher(void);

	BOOL FStartWatching(LPSTR szPath, LONG lUser, PFNFILECHANGED pfnChanged); 

private:
	virtual BOOL FireChange(DWORD dwWait);
};
	
class CRegKeyWatcher : public CThingWatcher
{
public:
	CRegKeyWatcher();
	~CRegKeyWatcher();

	BOOL				FStartWatching(HKEY hkey, BOOL fSubTree, DWORD dwNotifyFilter, LONG lUser, PFNREGKEYCHANGED pfnChanged);

private:
	virtual BOOL		FireChange(DWORD dwWait);
	
	HKEY				m_hkey;
	LONG				m_lUser;
	PFNREGKEYCHANGED	m_pfnChanged;
	HANDLE				m_hevtNotify;
};

/*--------------------------------------------------------------------------+
|	CDataFile																|
+--------------------------------------------------------------------------*/

class CDataFile
	{
	friend class CDataFileGroup;
	friend void DataFileChanged(LPSTR szFile, LONG lUser);

	private:
		ULONG			m_cRef;

		CDataFile	   *m_pdfNext;
		CDataFile	   *m_pdfPrev;
		CDataFileGroup *m_pfg;

	protected:
		CCritSec		m_cs;
		char			m_szDataPath[MAX_PATH];
		CFileWatcher	m_fw;

	public:
		CDataFile(LPSTR szDataPath, CDataFileGroup *pfg);
		~CDataFile(void);

		ULONG		AddRef(void);
		ULONG		Release(void);

		BOOL		FWatchFile(PFNFILECHANGED pfnChanged = NULL);

		virtual void FreeDataFile(void) { delete this; }

	private:
		ULONG		GetRefCount(void);
		BOOL		FMatch(LPSTR szDataPath);

		CDataFile	*GetNext(void)				{ return(m_pdfNext);	}
		CDataFile	*GetPrev(void)				{ return(m_pdfPrev);	}
		void		SetNext(CDataFile *pdf)		{ m_pdfNext = pdf;		}
		void		SetPrev(CDataFile *pdf)		{ m_pdfPrev = pdf;		}
	};

/*--------------------------------------------------------------------------+
|	CDataFileGroup															|
+--------------------------------------------------------------------------*/

#define NUM_GROUP_BUCKETS (1024)

typedef struct _HashBucket
	{
	CDataFile *pdfHead;
	CDataFile *pdfTail;
	}
	HB;

class CDataFileGroup
	{
	private:
		CCritSec	m_cs;
		HB			m_rghb[NUM_GROUP_BUCKETS];
				
	public:
		CDataFileGroup(void);
		~CDataFileGroup(void);

		CDataFile  *GetDataFile(LPSTR szDataPath);
		void		ForgetDataFile(CDataFile *pdf);

		virtual CDataFile *CreateDataFile(LPSTR szDataPath) = 0;

	private:
		void		RememberDataFile(CDataFile *pdf, HB *phb = NULL);
		HB		   *GetHashBucket(LPSTR szDataPath);
	};
	
/*--------------------------------------------------------------------------+
|	CGenericHash															|
+--------------------------------------------------------------------------*/

typedef struct _HashItem
	{
	BSTR				bstrName;
	LPVOID				pvData;
	struct _HashItem	*phiNext;
	struct _HashItem	*phiPrev;
	}
	HITEM;

class CGenericHash
	{
	protected:
		DWORD		m_chi;
		HITEM		**m_rgphi;
		CCritSec	m_cs;

	public:
		CGenericHash(DWORD cBuckets);
		~CGenericHash(void);

		LPVOID PvFind(OLECHAR *wszName);

		BOOL FAdd(OLECHAR *wszName, LPVOID pv);
		void Remove(OLECHAR *wszName);
		void RemoveAll(void);

		void Lock(void)		{ m_cs.Lock(); }
		void Unlock(void)	{ m_cs.Unlock(); }

		virtual DWORD	GetHashValue(OLECHAR *wsz);
		virtual void	FreeHashData(LPVOID pv);

	private:
		HITEM	*FindItem(OLECHAR *wszName, HITEM ***ppphiHead);
		void	RemoveItem(HITEM **pphiHead, HITEM *phi);
		BOOL	FEnsureBuckets(void);
	};

/*--------------------------------------------------------------------------+
|	CResourceCollection														|
+--------------------------------------------------------------------------*/

typedef struct _resource
{
	BOOL			fInUse;
	BOOL			fValid;
	PVOID			pv;
} RS, *PRS;

typedef PRS HRS;
#define hrsNil NULL

class CResourceCollection
{
public:
	CResourceCollection();
	~CResourceCollection();
	
	BOOL			FInit(int cRsrc);
	BOOL			FTerm();
	
	HRS				HrsGetResource();
	void			ReleaseResource(BOOL fReset, HRS hrs);

	void			CleanupAll(PVOID pvNil);
	BOOL			FValid(HRS hrs);

private:
	PRS				PrsFree();
	void			WaitForRs();

	CCritSec		m_cs;
	HANDLE			m_hsem;
	
	int				m_crs;
	PRS				m_rgrs;

	virtual BOOL	FInitResource(PRS prs)		= 0;
	virtual void	CleanupResource(PRS prs)	= 0;
};

/*--------------------------------------------------------------------------+
|	CSocketCollection														|
+--------------------------------------------------------------------------*/

class CSocketCollection : public CResourceCollection
{
public:
	CSocketCollection() : CResourceCollection()		{};
	~CSocketCollection()							{};
	
	BOOL			FInit(int cRsrc, char *szServer, USHORT usPort); // usPort should be in host byte order
	BOOL			FReinit(char *szServer, USHORT usPort);
	
	SOCKET			ScFromHrs(HRS hrs);
	
private:
	char			m_szServer[MAX_PATH];
	int				m_usPort;
	SOCKADDR_IN		m_sin;

	virtual BOOL	FInitResource(PRS prs);
	virtual void	CleanupResource(PRS prs);
};

#endif // _WCSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\_dbgdump.h ===
//-----------------------------------------------------------------------------
//
//
//  File: _dbgext.h
//
//  Description: 
//      Defines macros for defining structures to dump in your CDB extension
//
//  Usage:
//      Create a head file that includes this file and defines your field
//      descriptors using only the following macros:
//
//      BIT MASKS:
//          BEGIN_BIT_MASK_DESCRIPTOR(BitMaskName) -
//              start bit mask descriptor
//          BIT_MASK_VALUE(Value) -
//              Give a defined value for a bit mask.  Uses #Value 
//              to describe the value.  If your bitmask values are
//              defined using #defines... then only the numerical
//              values will appear in the dump... use BIT_MASK_VALUE2
//              instead.
//          BIT_MASK_VALUE2(Value, Description) -
//              Give a value and description for a bit mask.
//          END_BIT_MASK_DESCRIPTOR
//              Mark the end of a bit mask descriptor
//
//      ENUMS:
//          BEGIN_ENUM_DESCRIPTOR(BitMaskName) -
//              start enum descriptor
//          ENUM_VALUE(Value) -
//              Give a defined value for a enum.  Uses #Value 
//              to describe the value.
//          ENUM_VALUE2(Value, Description) -
//              Give a value and description for a enum.
//          END__DESCRIPTOR -
//              Mark the end of a enum descriptor
//
//      STRUCTURES & CLASSES:
//          BEGIN_FIELD_DESCRIPTOR(FieldDescriptorName) - 
//              start field decscritor
//          FIELD3(FieldType, StructureName, FieldName) - 
//              define non-enum public field
//          FIELD4(FieldType, StructureName, FieldName, AuxInfo) - 
//              define enum public field
//              For FIELD4, you should pass one of the following to
//              to define the aux info:
//                  GET_ENUM_DESCRIPTOR(x)
//                  GET_BITMASK_DESCRIPTOR(x)
//              Where x is one of the values used to define a bit mask
//              or enum.
//              
//          END_FIELD_DESCRIPTOR -
//              Define end of field descriptors for class/struct
//
//      GLOBALS: - Used to tell ptdbgext what class/structures to dump
//          BEGIN_STRUCT_DESCRIPTOR -
//              Marks the begining of the global stuct descriptor
//          STRUCT(TypeName,FieldDescriptor) -
//              Defines a struct to dump.  TypeName is the name of the 
//              type, and FieldDescriptor is a name given in a 
//              BEGIN_FIELD_DESCRIPTOR.
//
//      NOTE: You must define bit masks & enums before classes and structures.  
//      You must also define the global STRUCT_DESCRIPTOR last.
//
//      **this include file with redefine the key words "protected" and "private"***
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef ___DBGEXT_H__FIRST_PASS_
#define ___DBGEXT_H__FIRST_PASS_

#ifndef PTDBGEXT_USE_FRIEND_CLASSES
//Needed to allow access to private members of classes
#define private public
#define protected public 
#endif //PTDBGEXT_USE_FRIEND_CLASSES

#define DEFINE_VALUE(VAL)  \
        {VAL, #VAL},
#define DEFINE_VALUE2(VAL, DESCRIPTION)  \
        {VAL, DESCRIPTION},

//---[ ENUM MACROS ]-----------------------------------------------------------
//
//
//  Description: Enum macro definitions.... used to define enum values for 
//      the dump command.
//
//  
//-----------------------------------------------------------------------------
#define GET_ENUM_DESCRIPTOR(ENUM_NAME) EnumValueDescrsOf_##ENUM_NAME
#define BEGIN_ENUM_DESCRIPTOR(ENUM_NAME) \
    ENUM_VALUE_DESCRIPTOR GET_ENUM_DESCRIPTOR(ENUM_NAME)[] = {
#define END_ENUM_DESCRIPTOR \
    0                       \
    };
#define ENUM_VALUE(VAL)  DEFINE_VALUE(VAL)
#define ENUM_VALUE2(VAL, DESCRIPTION)  DEFINE_VALUE2(VAL, DESCRIPTION)

//Bit masks
//---[ BIT MASK MACROS ]-------------------------------------------------------
//
//
//  Description: Bit mask macro definitions... used to define bit mask values
//      for the dump command.
//
//  
//-----------------------------------------------------------------------------
#define GET_BIT_MASK_DESCRIPTOR(BITMAP_NAME) BitmapValueDescrsOf_##BITMAP_NAME
#define BEGIN_BIT_MASK_DESCRIPTOR(BITMAP_NAME) \
    BIT_MASK_DESCRIPTOR GET_BIT_MASK_DESCRIPTOR(BITMAP_NAME)[] = {
#define END_BIT_MASK_DESCRIPTOR   \
    0                             \
    };
#define BIT_MASK_VALUE(VAL)  DEFINE_VALUE(VAL)
#define BIT_MASK_VALUE2(VAL, DESCRIPTION)  DEFINE_VALUE2(VAL, DESCRIPTION)

//---[ FIELD MACROS ]----------------------------------------------------------
//
//
//  Description: Field descriptor macros.... used to define fields from structures
//      and classes to dump.
//
//  
//-----------------------------------------------------------------------------
//Field descriptor... used to define structures and classes
#define BEGIN_FIELD_DESCRIPTOR(x) \
    FIELD_DESCRIPTOR x[] = {
#define END_FIELD_DESCRIPTOR \
    NULL_FIELD               \
    };
#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL},
#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,(VOID *) AuxInfo},
#ifdef PTDBGEXT_USE_FRIEND_CLASSES
#define FIELD3_PRIV(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , 0 ,NULL},
#define FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , 0,(VOID *) AuxInfo},
#else //PTDBGEXT_USE_FRIEND_CLASSES not defined
#define FIELD3_PRIV(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL},
#define FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,(VOID *) AuxInfo},
#endif //PTDBGEXT_USE_FRIEND_CLASSES

//Struct descriptor
#define BEGIN_STRUCT_DESCRIPTOR \
    STRUCT_DESCRIPTOR Structs[] = {
#define END_STRUCT_DESCRIPTOR \
    0               \
    };
#define STRUCT(StructTypeName,FieldDescriptors) \
        { #StructTypeName,sizeof(StructTypeName),FieldDescriptors},

#define EMBEDDED_STRUCT(StructTypeName, FieldDescriptors, EmbeddedStructName) \
    STRUCT_DESCRIPTOR EmbeddedStructName[] = \
        { STRUCT(StructTypeName, FieldDescriptors) 0 };

#else //___DBGEXT_H__FIRST_PASS_ already defined...at least 2nd pass
#ifdef PTDBGEXT_USE_FRIEND_CLASSES  //if not set, do not do the multipass stuff
#ifndef ___DBGEXT_H__
#define ___DBGEXT_H__
//
//      As an alternative to using #defining private and protected to public, you
//      may wish to use the friend class method of accessing the structure offsets.
//      (If, for example, the organization of your classes are changed as a result
//      of those #defining private and prctected).
//
//      To do so, #define PTDBGEXT_USE_FRIEND_CLASSES and use the following 
//      additional macros:
//
//          FIELD3_PRIV(FieldType, StructureName, FieldName) - 
//              define non-enum private field
//          FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) - 
//              define enum private field
//
//      If you use FIELD?_PRIV, then you are accessing private members of a
//      class.  In this case, you need to create a void (void) initialization 
//      function and assign it to g_pExtensionInitRoutine.  It should be a 
//      member function of class that is a friend of all the classes you are
//      interested in debugging.  Suppose your field descriptors are defined 
//      in mydump.h, you would need to create an initialization function as 
//      follows:
//
//          #include <mydump.h> //initial definition
//          ...
//          void CMyDebugExt::Init(void) {
//          #include <mydump.h>
//          }

//undefine previously defined macros
#undef BEGIN_FIELD_DESCRIPTOR
#undef END_FIELD_DESCRIPTOR
#undef FIELD3
#undef FIELD4
#undef FIELD3_PRIV
#undef FIELD4_PRIV
#undef GET_ENUM_DESCRIPTOR
#undef BEGIN_ENUM_DESCRIPTOR
#undef END_ENUM_DESCRIPTOR
#undef GET_BIT_MASK_DESCRIPTOR
#undef BEGIN_BIT_MASK_DESCRIPTOR
#undef END_BIT_MASK_DESCRIPTOR
#undef BEGIN_STRUCT_DESCRIPTOR
#undef STRUCT
#undef END_STRUCT_DESCRIPTOR
#undef DEFINE_VALUE
#undef DEFINE_VALUE2
#undef EMBEDDED_STRUCT

#define GET_ENUM_DESCRIPTOR(ENUM_NAME) 
#define BEGIN_ENUM_DESCRIPTOR(ENUM_NAME)
#define END_ENUM_DESCRIPTOR 
#define GET_BIT_MASK_DESCRIPTOR(BITMAP_NAME) 
#define BEGIN_BIT_MASK_DESCRIPTOR(BITMAP_NAME)
#define END_BIT_MASK_DESCRIPTOR 
#define DEFINE_VALUE(VAL) 
#define DEFINE_VALUE2(VAL, DESCRIPTION) 
#define BEGIN_STRUCT_DESCRIPTOR
#define STRUCT(x, y)
#define END_STRUCT_DESCRIPTOR
#define EMBEDDED_STRUCT(x, y, z)

#define BEGIN_FIELD_DESCRIPTOR(x) \
    pfd = x; 
#define END_FIELD_DESCRIPTOR \
    pfd = NULL;

#define FIELD3(FieldType,StructureName, FieldName) \
    pfd++;
#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
    pfd++;

//Use Field?_PRIV when dealing with private memebers.  Requires 2 passes
#define FIELD3_PRIV(FieldType,StructureName, FieldName) \
        pfd->Offset = FIELD_OFFSET(StructureName, FieldName); \
        pfd++;

#define FIELD4_PRIV(FieldType, StructureName, FieldName, AuxInfo) \
        pfd->Offset = FIELD_OFFSET(StructureName, FieldName); \
        pfd++;

    FIELD_DESCRIPTOR *pfd = NULL;  //Variable declaration in INIT function
#else //whoops
#pragma message "WARNING: _dbgext.h included more than twice"
#endif //___DBGEXT_H__
#endif //PTDBGEXT_USE_FRIEND_CLASSES
#endif //___DBGEXT_H__FIRST_PASS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\xmemwrpr.h ===
/*++
Copyright (c) 1998 Microsoft Corporation
All rights reserved.

Module:

    xmemwrpr.h

Abstract:

    Wrapper of exchmem.  

    User of this wrapper: you should create the heap using
    ExchMHeapCreate before allocating any memory from EXCHMEM.
    You should destroy the heap using ExchMHeapDestroy.

    For raw memory allocation from heap, you should use PvAlloc,
    PvRealloc and FreePv functions.

    For object creation, unless you overload new yourself in
    the class defintion, using "new" will go to EXCHMEM, using
    "XNEW" will go to EXCHMEM while at the same time catch the
    file and line information for that allocation ( this is
    for debug version only )
                        
Authors:

    KangYan      Kangrong Yan     Sept. 29, 1998

History:
    09/29/98    KangYan      Created
--*/
#if !defined(_XMEMWRPR_H_)
#define _XMEMWRPR_H_

#include <exchmem.h>
#include <dbgtrace.h>

//
// Define number of exchmem heaps if not already defined
//
#if !defined(NUM_EXCHMEM_HEAPS)
#define NUM_EXCHMEM_HEAPS   0
#endif

//
// Macros for major heap allocation functions. ( We follow
// exchange store's convention here )
//
#if defined( DEBUG )
#define PvAlloc(_cb)                    ExchMHeapAllocDebug(_cb, __FILE__, __LINE__)
#define PvRealloc(_pv, _cb)             ExchMHeapReAllocDebug(_pv, _cb, __FILE__, __LINE__)
#define FreePv(_pv)                     ExchMHeapFree(_pv)
#else
#define PvAlloc(_cb)                    ExchMHeapAlloc(_cb)
#define PvRealloc(_pv, _cb)             ExchMHeapReAlloc(_pv, _cb)
#define FreePv(_pv)                     ExchMHeapFree(_pv)
#endif

//
// Operator XNEW, XDELETE are defined to replace "new" where xchmem wants to 
// be used so that we can pass in file name and line number of each allocation
// to make catching leaks much easier in debug builds.  In rtl builds,
// the file name or line number will not be passed in
//
#if defined( DEBUG )
#define XNEW new(__FILE__,__LINE__)
#else
#define XNEW new
#endif

#define XDELETE  delete

// 
// Overload global new operators 
//
__inline void * __cdecl operator new(size_t size, char *szFile, unsigned int uiLine )
{
    void *p = ExchMHeapAllocDebug( size, szFile, uiLine );
    SetLastError( p? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY );
    return p;
}

__inline void * __cdecl operator new( size_t size )
{
    void *p = ExchMHeapAlloc( size );
    SetLastError( p? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY );
    return p;
}

//
// Overload global delete operator, one version only
//
__inline void __cdecl operator delete( void *pv )
{
    ExchMHeapFree( pv );
    SetLastError( NO_ERROR );
}

//
// Create creation wrappers
//
__inline BOOL  CreateGlobalHeap( DWORD cHeaps, DWORD dwFlag, DWORD dwInit, DWORD dwMax ) {
    if ( ExchMHeapCreate( cHeaps, dwFlag, dwInit, dwMax ) ) {
        SetLastError( NO_ERROR );
        return TRUE;
    } else {
        _ASSERT( 0 );
        return FALSE;
    }
}

__inline BOOL DestroyGlobalHeap() {
    if ( ExchMHeapDestroy() ) {
        return TRUE;
    } else {
        _ASSERT( 0 );
        return FALSE;
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\build\sources.inc ===
!if "$(FREEBUILD)"=="1"
### !message **** FREE BUILD ***
!else
C_DEFINES=$(C_DEFINES) -DDEBUG=1
!if !$(WIN64)
MSC_OPTIMIZATION=/Od
!endif
!endif

!ifdef TRACE_ENABLED
C_DEFINES=$(C_DEFINES) -DTRACE_ENABLED
!endif

INCLUDES=$(INCLUDES);$(STAXINC)\export;$(IISBASEDIR)\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\build\paths.inc ===
#
#  Places all of the internet binaries into the inetsrv tree.
#  Also establishes some standard conventions used across the project.
#

#
# Override IISBASEDIR if you're one of those weirdos that didn't
# enlist the IIS project into the correct directory.
#

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

STAXBASE=$(IISBASEDIR)\svcs
STAXINC=$(IISBASEDIR)\staxinc
STAXCORE=$(STAXBASE)\staxcore
STAXCORETARGET=$(STAXCORE)\$(_OBJ_DIR)
STAXCORELIBPATH=$(STAXCORETARGET)\$(TARGET_DIRECTORY)

!if [mkdir $(STAXCORETARGET)\$(TARGET_DIRECTORY)]
!endif


!if "$(FREEBUILD)"=="1"
### message **** FREE BUILD ***
STAXFLAVOR=rtl
!else
### message **** DEBUG BUILD ***
### DEBUG_CRTS=1
STAXFLAVOR=dbg
!endif

USE_MSVCRT=1

!ifdef BUILD_ALT_DIR
ALT_PROJECT_TARGET=$(BUILD_ALT_DIR)
!endif


## Note, .hlp file suggests that this be done in the environment
## and not in the sources file...
## "You usually do this in your environment, not in your sources file.
## You should do this on your build machine rather than on all of your
## developers' machines because they probably want the symbols there.
## It's easier to track. The debugger does not have to do all this hand
## waving to find the debug symbolic files that match the images themselves."
NTDBGFILES=1

NTDEBUGTYPE=both

LINKER_FLAGS=-merge:.VTABLE=.text -merge:RODATA=.text -merge:.rdata=.text -merge:.data1=.data -merge:.SHARED1=.SHARED

##
## Default system libraries
##

#
# We'll use our own COFFBASE.TXT and PLACEFIL.TXT, thank you very much.
#
## xxx: Need to merge coffbase.txt?

!IFNDEF COFFBASE_TXT_FILE
COFFBASE_TXT_FILE=$(IISBASEDIR)\coffbase.txt
!ENDIF

!IFNDEF BINPLACE_PLACEFILE
BINPLACE_PLACEFILE=$(IISBASEDIR)\staxinc\build\placefil.txt
!ENDIF

# This used to have the -y option.  Now, inetsrv binaries are binplaced
# to retail, so the symbols should be binplaced to symbols\retail.
# The -y switch causes the symbols to be binplaced to the wrong directory.

### BINPLACE_FLAGS=$(BINPLACE_FLAGS)

# enable building legoizable binaries
!IFNDEF IIS_NO_BBT
NTBBT=1
!ENDIF

!IFNDEF IIS_NO_PDB
USE_PDB=1
!ENDIF

!IF $(386)
!IFNDEF IIS_NO_SYM
USE_MAPSYM=1
!ENDIF
!ENDIF

!if 0
# (DISABLED)


#
# ENABLE WARNING LEVEL 3, TREAT WARNINGS AS ERRORS
#

!IFNDEF MSC_WARNING_LEVEL
## XXX: only enable /W3
##MSC_WARNING_LEVEL=/W3 /WX
MSC_WARNING_LEVEL=/W3
!ENDIF

#
# DON'T ALLOW ANYONE TO DISABLE WARNINGS AS ERRORS.
#
# IF ANY OF THE {PLATFORM}_WARNING_LEVEL MACROS ARE DEFINED WITHOUT
# THE /WX SWITCH, APPEND /WX TO THE MACRO AND WHINE ABOUT IT.
#

!IFDEF 386_WARNING_LEVEL
! IF ("$(386_WARNING_LEVEL:/WX=X)" == "$(386_WARNING_LEVEL)") && ("$(386_WARNING_LEVEL:-WX=X)" == "$(386_WARNING_LEVEL)")
!  MESSAGE 386_WARNING_LEVEL DEFINED WITHOUT /WX
386_WARNING_LEVEL=$(386_WARNING_LEVEL) /WX
! ENDIF
!endif

!ifdef AMD64_WARNING_LEVEL
! if ("$(AMD64_WARNING_LEVEL:/WX=x)" == "$(AMD64_WARNING_LEVEL)") && ("$(AMD64_WARNING_LEVEL:-WX=x)" == "$(AMD64_WARNING_LEVEL)")
!  message AMD64_WARNING_LEVEL defined without /WX
AMD64_WARNING_LEVEL=$(AMD64_WARNING_LEVEL) /WX
! endif
!endif

!ifdef IA64_WARNING_LEVEL
! if ("$(IA64_WARNING_LEVEL:/WX=x)" == "$(IA64_WARNING_LEVEL)") && ("$(IA64_WARNING_LEVEL:-WX=x)" == "$(IA64_WARNING_LEVEL)")
!  message IA64_WARNING_LEVEL defined without /WX
IA64_WARNING_LEVEL=$(IA64_WARNING_LEVEL) /WX
! endif
!endif

!endif


#
# Win95 Chokes if the subsystem version is 5.00
#

###SUBSYSTEM_VERSION=5.00
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\abook.h ===
//+---------------------------------------------------------------
//
//  File:   Abook.h
//
//  Synopsis:   Prove Server level api for MSN Servers to access addres book
//
//  Copyright (C) 1995 Microsoft Corporation
//          All rights reserved.
//
//  History:    SunShaw     Created         30 Jan 1996
//
//----------------------------------------------------------------

#ifndef _ABOOK_H_
#define _ABOOK_H_

#include <abtype.h>

#if defined(__cplusplus)
extern "C" {

#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif
#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif

#if !defined(_ABOOK_DLL_DEFINED)
    #define _ABOOK_DLL_DEFINED
    #if defined(WIN32)
        #if defined(_ABOOK_DLL)
            #define AbookDll DllExport
        #else
            #define AbookDll DllImport
        #endif
    #else
        #define _ABOOK_DLL
    #endif
#endif

#define ABCALLCONV  __stdcall

#define ABEXPDLLCPP extern "C" AbookDll

//+---------------------------------------------------------------
//
// All Function Prototype used by SMTP, POP3 or AbSysAdmin
//
//----------------------------------------------------------------

typedef ABRETC (ABCALLCONV *LPFNAB_INIT)(LPSTR, LPFNLOGTRANX, PLIST_ENTRY, HANDLE*);
typedef ABRETC (ABCALLCONV *LPFNAB_TERM)(HANDLE);
typedef ABRETC (ABCALLCONV *LPFNAB_CANCEL)(HANDLE);

typedef ABRETC (ABCALLCONV *LPFNAB_GET_ERROR_STRING)(ABRETC, LPSTR, DWORD);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_ROUTING_DIRECTORY)(PLIST_ENTRY pleSources, LPSTR szDirectory);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_SOURCES)(HANDLE, PLIST_ENTRY);
typedef ABRETC (ABCALLCONV *LPFNAB_VALIDATE_SOURCE)(HANDLE hAbook, LPSTR szSource);
typedef ABRETC (ABCALLCONV *LPFNAB_VALIDATE_NUM_SOURCES)(HANDLE hAbook, DWORD dwNumSources);

typedef ABRETC (ABCALLCONV *LPFNAB_RES_ADDR)(HANDLE, PLIST_ENTRY, PABADDRSTAT pabAddrStat, PABROUTING pabroutingCheckPoint, ABRESOLVE *pabresolve);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_RES_ADDR)(HANDLE, PABRESOLVE pabresolve, PABROUTING pabrouting);
typedef ABRETC (ABCALLCONV *LPFNAB_END_RES_ADDR)(HANDLE, PABRESOLVE pabresolve);
typedef ABRETC (ABCALLCONV *LPFNAB_RES_ADDR_ASYNC)(HANDLE, PLIST_ENTRY, PABADDRSTAT pabAddrStat, PABROUTING pabroutingCheckPoint, ABRESOLVE *pabresolve, LPVOID pContext);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_MAILROOT)(HANDLE, PCHAR, LPSTR, LPDWORD);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_PERFMON_BLK)(HANDLE, PABOOKDB_STATISTICS_0);

typedef ABRETC (ABCALLCONV *LPFNAB_END_ENUM_RESULT)(HANDLE, PABENUM);

typedef ABRETC (ABCALLCONV *LPFNAB_ENUM_NAME_LIST)(HANDLE, LPSTR, BOOL, DWORD, PABENUM);
typedef ABRETC (ABCALLCONV *LPFNAB_ENUM_NAME_LIST_FROM_DL)(HANDLE, LPSTR, LPSTR, BOOL, DWORD, PABENUM);
typedef ABRETC (ABCALLCONV *LPFNAB_GET_NEXT_EMAIL)(HANDLE, PABENUM, DWORD*, LPSTR);

typedef ABRETC (ABCALLCONV *LPFNAB_ADD_LOCAL_DOMAIN)(HANDLE, LPSTR);
typedef ABRETC (ABCALLCONV *LPFNAB_ADD_ALIAS_DOMAIN)(HANDLE, LPSTR, LPSTR);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_LOCAL_DOMAIN)(HANDLE, LPSTR);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_ALL_LOCAL_DOMAINS)(HANDLE);

typedef ABRETC (ABCALLCONV *LPFNAB_CREATE_USER)(HANDLE hAbook, LPSTR szEmail, LPSTR szForward, BOOL fLocalUser, LPSTR szVRoot, DWORD cbMailboxMax, DWORD cbMailboxMessageMax);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_USER)(HANDLE hAbook, LPSTR szEmail);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_FORWARD)(HANDLE hAbook, LPSTR szEmail, LPSTR szForward);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_MAILROOT)(HANDLE hAbook, LPSTR szEmail, LPSTR szVRoot);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_MAILBOX_SIZE)(HANDLE hAbook, LPSTR szEmail, DWORD cbMailboxMax);
typedef ABRETC (ABCALLCONV *LPFNAB_SET_MAILBOX_MESSAGE_SIZE)(HANDLE hAbook, LPSTR szEmail, DWORD cbMailboxMessageMax);

typedef ABRETC (ABCALLCONV *LPFNAB_CREATE_DL)(HANDLE hAbook, LPSTR szEmail, DWORD dwType);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_DL)(HANDLE hAbook, LPSTR szEmail);
typedef ABRETC (ABCALLCONV *LPFNAB_CREATE_DL_MEMBER)(HANDLE hAbook, LPSTR szEmail, LPSTR szMember);
typedef ABRETC (ABCALLCONV *LPFNAB_DELETE_DL_MEMBER)(HANDLE hAbook, LPSTR szEmail, LPSTR szMember);

typedef ABRETC (ABCALLCONV *LPFNAB_GET_USER_PROPS)(HANDLE hAbook, LPSTR lpszEmail, ABUSER *pABUSER);

typedef ABRETC (ABCALLCONV *LPFNAB_MAKE_BACKUP)(HANDLE hAbook, LPSTR szConfig);

typedef DWORD (ABCALLCONV *LPFNAB_GET_TYPE)(void);


// Get user or DL's properties
ABEXPDLLCPP ABRETC ABCALLCONV AbGetUserProps(HANDLE hAbook, LPSTR lpszEmail, ABUSER *pABUSER);
ABEXPDLLCPP ABRETC ABCALLCONV AbGetDLProps(HANDLE hAbook, LPSTR lpszEmail, ABDL *pABDL);

// Given beginning chars, match user names
ABEXPDLLCPP ABRETC ABCALLCONV AbEnumNameList(HANDLE hAbook, LPSTR lpszEmail, BOOL f ,
                                             DWORD dwType, PABENUM pabenum);
// Match user names only in the given DL
ABEXPDLLCPP ABRETC ABCALLCONV AbEnumNameListFromDL(HANDLE hAbook, LPSTR lpszDLName, LPSTR lpszEmail,
                                                   BOOL f , DWORD dwType, PABENUM pabenum);
// Get back all the matching names
ABEXPDLLCPP ABRETC ABCALLCONV AbGetNextEmail(HANDLE hAbook, PABENUM pabenum, DWORD *pdwType, LPSTR lpszEmail);


//+---------------------------------------------------------------
//
//  Function:   AbGetType
//
//  Synopsis:   returns the routing type number
//
//  Arguments:
//
//  Returns:    DWORD       Routing type number defined above
//
//----------------------------------------------------------------

#define ROUTING_TYPE_SQL    1
#define ROUTING_TYPE_FF     2
#define ROUTING_TYPE_LDAP   3

ABEXPDLLCPP DWORD ABCALLCONV AbGetType
        ();


//+---------------------------------------------------------------
//
//  Function:   AbInitialize
//
//  Synopsis:   Must be the first call to abookdb.dll (except AbGetType)
//
//  Arguments:
//              LPSTR        [in] Display name for abookdb users/context,
//                              i.e. SMTP, POP3 or NULL if don't care.
//              LPFNLOGTRANX [in] Transaction Logging callback.
//                              NULL if don't care about transaction logging.
//              PHANDLE      [out] Return buffer for context handle,
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbInitialize
        (LPSTR pszDisplayName, LPFNLOGTRANX pfnTranx, PLIST_ENTRY pHead, HANDLE* phAbook);


//+---------------------------------------------------------------
//
//  Function:   AbSetSources
//
//  Synopsis:   Called to update available data sources at any time
//
//  Arguments:  LPSTR       it's the command line and should have the following form:
//                      [server=ayin][,][MaxCnx=100]
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbSetSources(HANDLE hAbook, PLIST_ENTRY pHead);

//+---------------------------------------------------------------
//
//  Function:   AbGetErrorString
//
//  Synopsis:   To translate ABRETC to an error string
//
//  Arguments:  ABRETC  [in]    The return code from abook API
//              LPSTR   [out]   Buffer for the error string to copy into
//              DWORD   [in]    The size of the buffer supplized
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbGetErrorString(ABRETC abrc, LPSTR lpBuf, DWORD cbBufSize);


//+---------------------------------------------------------------
//
//  Function:   AbTerminate
//
//  Synopsis:   User must call this when done with abook.dll
//
//  Arguments:
//              HANDLE   [in] Context Handle returned from AbInitialize.
//
//  Returns:    NONE
//
//----------------------------------------------------------------

ABEXPDLLCPP VOID ABCALLCONV AbTerminate(HANDLE hAbook);


//+---------------------------------------------------------------
//
//  Function:   AbCancel
//
//  Synopsis:   This function will cancel all resolve address calls
//              to DB so that SMTP can shut down cleanly without waiting
//              too long.
//
//  Arguments:
//              HANDLE   [in] Context Handle returned from AbInitialize.
//
//  Returns:    ABRETC
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbCancel(HANDLE hAbook);


//+---------------------------------------------------------------
//
//  Function:   AbResolveAddress
//
//  Synopsis:   Resolves email address to minimum routing info.
//
//  Arguments:
//              HANDLE       [in]     Context Handle returned from AbInitialize.
//              HACCT        [in]     HACCT for sender, 0 for non-MSN account
//              PQUEUE_ENTRY [in|out] List of CAddr/Recipients
//              LPFNCREATEADDR   [in] Callback constructor of CAddr
//              BOOL*        [out]    Pointer to buffer to indicate at least 1
//                                      recipient is encrypted and needs verification
//                                      could be NULL in 2.0
//
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------
ABEXPDLLCPP ABRETC ABCALLCONV AbResolveAddress
    (
    HANDLE hAbook,
    PLIST_ENTRY pltInput,
    PABADDRSTAT pabAddrStat,
    PABROUTING pabroutingCheckPoint,
    ABRESOLVE *pabresolve
    );

ABEXPDLLCPP ABRETC ABCALLCONV AbAsyncResolveAddress
    (
    HANDLE hAbook,
    PLIST_ENTRY pltInput,
    PABADDRSTAT pabAddrStat,
    PABROUTING pabroutingCheckPoint,
    ABRESOLVE *pabresolve,
    LPFNRESOLVECOMPLETE pfnCompletion,
    LPVOID pContext
    );



ABEXPDLLCPP ABRETC ABCALLCONV AbGetResolveAddress
    (
    HANDLE hAbook,
    ABRESOLVE *pabresolve,
    ABROUTING *pabrouting
    );



ABEXPDLLCPP ABRETC ABCALLCONV AbEndResolveAddress
    (
    HANDLE hAbook,
    ABRESOLVE *pabresolve
    );


ABEXPDLLCPP ABRETC ABCALLCONV AbEndEnumResult
        (HANDLE hAbook, PABENUM pabEnum);


//+---------------------------------------------------------------
//
//  Function:   AbAddLocalDomain  AbDeleteLocalDomain
//
//  Synopsis:   add and delete Local domain to the database
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              HACCT   [in] Currently ignored
//              PABPDI  [in] Pointer to the Local domain structure
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbAddLocalDomain(HANDLE hAbook, LPSTR szDomainName);
ABEXPDLLCPP ABRETC ABCALLCONV AbAddAliasDomain(HANDLE hAbook, LPSTR szDomainName, LPSTR szAliasName);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeleteLocalDomain(HANDLE hAbook, LPSTR szDomainName);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeleteAllLocalDomains(HANDLE hAbook);


//+---------------------------------------------------------------
//
//  Function:   AbGetUserMailRoot
//
//  Synopsis:   Gets the Virtual Mail Root for the specified users
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              PCHAR   [in] ASCII user name
//              LPCHAR  [in] ASCII Virtual Mail Root
//              LPDWORD [in|out] (in) size of buffer, (out) string length
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbGetUserMailRoot
        (HANDLE hAbook, PCHAR pszUser, LPSTR pszVRoot, LPDWORD pcbVRootSize);

//+---------------------------------------------------------------
//
//  Function:   AbGetPerfmonBlock
//
//  Synopsis:   Gets the Pointer to the Perfmon Statistic block
//              associated with hAbook.  The pointer is guaranteed
//              to be valid before the AbTerminate call.
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              PABOOKDB_STATISTICS_0*
//                      [out] Buffer is receive the pointer to stat
//                               block.
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbGetPerfmonBlock
        (HANDLE hAbook, PABOOKDB_STATISTICS_0* ppabStat);

//+---------------------------------------------------------------
//
//  Function:   AbMakeBackup
//
//  Synopsis:   Triggers the routing table to make a backup of the
//              data associated with hAbook.
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              LPSTR   [in] configuration string
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbMakeBackup
    (HANDLE hAbook, LPSTR szConfig);

//+---------------------------------------------------------------
//
//  Function:   AbValidateSource
//
//  Synopsis:   Validates a single source for accuracy before
//              saving into the registry
//
//  Arguments:
//              HANDLE  [in] Context Handle returned from AbInitialize.
//              LPSTR   [in] source string
//
//  Returns:    ABRETC      AddressBook Return code details in <abtype.h>
//
//----------------------------------------------------------------

ABEXPDLLCPP ABRETC ABCALLCONV AbValidateSource
    (HANDLE hAbook, LPSTR szSource);
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\aqadmtyp.h ===
/*
        @doc ADVANCED QUEUEING DATA TYPES
        @module aqadmtyp.h | Data types used in advanced queueing interfaces
*/

/*++/

Copyright (c) 1999  Microsoft Corporation

Module Name:

    aqadmtyp.h

Abstract:

    This module defines data types used in advanced queueing interfaces


--*/
#ifndef __AQADMTYP_H__
#define __AQADMTYP_H__

#ifdef __midl
#define MIDL(x) x
#else
#define MIDL(x)
#endif

// max *required* size of buffer returned by implementor of QAPI
// If the size of the requested information exceeds this constant,
// then QAPI *may* truncate the buffer.
#define QUEUE_ADMIN_MAX_BUFFER_REQUIRED  200

// @enum QUEUE_ADMIN_VERSIONS | Enum specify current and supported
//  queue admin versions.
// @emem CURRENT_QUEUE_ADMIN_VERSION | The current queue admin version
//  that all structures should have this value in their dwVersion field.
typedef enum tagQUEUE_ADMIN_VERSIONS {
    CURRENT_QUEUE_ADMIN_VERSION = 4,
} QUEUE_ADMIN_VERSIONS;


// 
// @struct MESSAGE_FILTER | Structure describing criteria for selecting 
// messages
// @field DWORD | dwVersion | Version of MESSAGE_FILTER struct - must be CURRENT_QUEUE_ADMIN_VERSION
// @field DWORD | fFlags | <t MESSAGE_FILTER_FLAGS> indicating which 
//  fields of filter are specified
// @field LPCWSTR | szMessageId | Message ID, as returned in a MESSAGE_INFO 
// struct
// @field LPCWSTR | szMessageSender | Messages sent by this sender match
// @field LPCWSTR | szMessageRecipient | Messages sent to this recipient match
// @field DWORD | dwLargerThanSize | Messages larger than this value match
// @field SYSTEMTIME | stOlderThan | Messages older than this value match
//
typedef struct tagMESSAGE_FILTER {
                    DWORD dwVersion; 
                    DWORD fFlags;
    MIDL([string])  LPCWSTR szMessageId;
    MIDL([string])  LPCWSTR szMessageSender;
    MIDL([string])  LPCWSTR szMessageRecipient;
                    DWORD  dwLargerThanSize;
                    SYSTEMTIME stOlderThan;
} MESSAGE_FILTER, *PMESSAGE_FILTER;

// @enum MESSAGE_FILTER_FLAGS | Type specifying the type of filter 
// requested.  These are bitflags and can be OR'd together.
// @emem MF_MESSAGEID | The <e MESSAGE_FILTER.szMessageId> is specified
// @emem MF_SENDER | The <e MESSAGE_FILTER.szMessageSender> is specified
// @emem MF_RECIPIENT | The <e MESSAGE_FILTER.szMessageRecipient> is specified
// @emem MF_SIZE | The <e MESSAGE_FILTER.dwLargerThanSize> is specified
// @emem MF_TIME | The <e MESSAGE_FILTER.stOlderThan> is specified
// @emem MF_FROZEN | The <e MESSAGE_FILTER.fFrozen> is specified
// @emem MF_FAILED | Selects messages that have had a failed delivery attempt
// @emem MF_INVERTSENSE | If set, indicates that the negation of the filter
// @emem MF_ALL | Select all messages
typedef enum tagMESSAGE_FILTER_FLAGS {
                    MF_MESSAGEID                = 0x00000001,
                    MF_SENDER                   = 0x00000002,
                    MF_RECIPIENT                = 0x00000004,
                    MF_SIZE                     = 0x00000008,
                    MF_TIME                     = 0x00000010,
                    MF_FROZEN                   = 0x00000020,
                    MF_FAILED                   = 0x00000100,
                    MF_ALL                      = 0x40000000,
                    MF_INVERTSENSE              = 0x80000000
} MESSAGE_FILTER_FLAGS;

// @enum MESSAGE_ACTION | Type specifying possible administrative actions
//      that may be applied to messages in a virtual server, link, or queue
// @emem MA_DELETE | Remove message from the virtual server, link, or queue
// @emem MA_DELETE_SILENT | Remove message without generating an NDR
// @emem MA_FREEZE | Freeze the message in the virtual server, link, or queue
// @emem MA_THAW | Un-freeze the message in the virtual server, link, or queue
// @emem MA_COUNT | Null operation, does not affect messages, but does return count.
typedef enum tagMESSAGE_ACTION {
                    MA_THAW_GLOBAL              = 0x00000001, 
                    MA_COUNT                    = 0x00000002,
                    MA_FREEZE_GLOBAL            = 0x00000004,
            		MA_DELETE                   = 0x00000008,
                    MA_DELETE_SILENT            = 0x00000010
} MESSAGE_ACTION;

// @enum MESSAGE_ENUM_FILTER_TYPE | Type specifying the type of filter 
// requested.  These are bitflags and can be OR'd together.
// @emem MEF_FIRST_N_MESSAGES | Return the first 
// <e MESSAGE_ENUM_FILTER.cMessages> messages
// @emem MEF_N_LARGEST_MESSAGES | Return the largest 
// <e MESSAGE_ENUM_FILTER.cMessages> messages
// @emem MEF_N_OLDEST_MESSAGES | Return the oldest
// <e MESSAGE_ENUM_FILTER.cMessages> messages
// @emem MF_SENDER | The <e MESSAGE_ENUM_FILTER.szMessageSender> is specified
// @emem MF_RECIPIENT | The <e MESSAGE_ENUM_FILTER.szMessageRecipient> is specified
// @emem MEF_OLDER_THAN | Return messages older than 
// <e MESSAGE_ENUM_FILTER.stDate>
// @emem MEF_LARGER_THAN | Return messages larger than 
// <e MESSAGE_ENUM_FILTER.cbSize> bytes
// @emem MEF_FROZEN | Return messages that are frozen
// @emem MEF_INVERTSENSE  | Invert the meaning of the filter
// @emem MEF_ALL | Select all messages
// @emem MEF_FAILED | Return only messages that have had failed delivery
// attempts.
typedef enum tagMESSAGE_ENUM_FILTER_TYPE {
                    MEF_FIRST_N_MESSAGES        = 0x00000001,
                    MEF_SENDER                  = 0x00000002,
                    MEF_RECIPIENT               = 0x00000004,
                    MEF_LARGER_THAN             = 0x00000008,
                    MEF_OLDER_THAN              = 0x00000010,
                    MEF_FROZEN                  = 0x00000020,
                    MEF_N_LARGEST_MESSAGES      = 0x00000040,
                    MEF_N_OLDEST_MESSAGES       = 0x00000080,
                    MEF_FAILED                  = 0x00000100,
                    MEF_ALL                     = 0x40000000,
                    MEF_INVERTSENSE             = 0x80000000,
} MESSAGE_ENUM_FILTER_TYPE;

// @struct MESSAGE_ENUM_FILTER | Structure describing criteria for enumerating
// messages
// @field DWORD | dwVersion | Version of filter - must be CURRENT_QUEUE_ADMIN_VERSION
// @field MESSAGE_ENUM_FILTER_TYPE | mefType | <t MESSAGE_ENUM_FILTER_TYPE> Flags for filter.
// @field DWORD | cMessages | Number of messages to return
// @field DWORD | cbSize | Size parameter of messages
// @field DWORD | cSkipMessages | Number of messages at front of queue to skip.
//  This is provided to allow "paged" queries to the server.
// @field SYSTEMTIME | stDate | Date/Time parameter of messages
typedef struct tagMESSAGE_ENUM_FILTER {
                    DWORD dwVersion;
                    DWORD mefType;
                    DWORD cMessages;
                    DWORD cbSize;
                    DWORD cSkipMessages;
                    SYSTEMTIME stDate;
    MIDL([string])  LPCWSTR szMessageSender;
    MIDL([string])  LPCWSTR szMessageRecipient;
} MESSAGE_ENUM_FILTER, *PMESSAGE_ENUM_FILTER;


// @enum LINK_INFO_FLAGS | Type specifying the state of the link 
// @emem LI_ACTIVE | Link has an active connection transferring mail
// @emem LI_READY | Link is ready for a connection, but there are no connections
// @emem LI_RETRY | Link is waiting for the retry interval to elapse
// @emem LI_SCHEDULED | Link is waiting for the next scheduled time
// @emem LI_REMOTE | Link is to be activated by remote server. A connection
//  will not be made unless requested by a remote server.
// @emem LI_FROZEN | Link was frozen by administrative action
// @emem LI_TYPE_REMOTE_DELIVERY | Messages on link are being delivered
//  remotely.  This is the default type of link.
// @emem LI_TYPE_LOCAL_DELIVERY | Messages on this link are being delivered
//  locally.
// @emem LI_TYPE_PENDING_CAT | Messages on this link are pending message
//  categorization.
// @emem LI_TYPE_PENDING_ROUTING | Messages on this link have not been routed
//  to their next hop.
// @emem LI_TYPE_CURRENTLY_UNREACHABLE | Messages on this link do not have an 
//  available route to their final destination.  This is due to transient 
//  network or server errors.  These messages will be retried when a route
//  becomes available.
// @emem LI_TYPE_INTERNAL | This link is an internal link not described 
//  by the above.
typedef enum tagLINK_INFO_FLAGS {
                    LI_ACTIVE                       = 0x00000001,
                    LI_READY                        = 0x00000002,
                    LI_RETRY                        = 0x00000004,
                    LI_SCHEDULED                    = 0x00000008,
                    LI_REMOTE                       = 0x00000010,
                    LI_FROZEN                       = 0x00000020,
                    LI_TYPE_REMOTE_DELIVERY         = 0x00000100,
                    LI_TYPE_LOCAL_DELIVERY          = 0x00000200,
                    LI_TYPE_PENDING_ROUTING         = 0x00000400,
                    LI_TYPE_PENDING_CAT             = 0x00000800,
                    LI_TYPE_CURRENTLY_UNREACHABLE   = 0x00001000,
                    LI_TYPE_DEFERRED_DELIVERY       = 0x00002000,
                    LI_TYPE_INTERNAL                = 0x00004000,
                    LI_TYPE_PENDING_SUBMIT          = 0x00008000,
} LINK_INFO_FLAGS;

// @enum LINK_ACTION | Actions that can be applied to a link
// @emem LA_KICK | Force a connection to be made for this link. 
//  This will even work for connections pending retry or a scheduled connection.
// @emem LA_FREEZE | Prevent outbound connections from being made for a link
// @emem LA_THAW | Undo a previous admin freeze action.
typedef enum tagLINK_ACTION {
                    LA_INTERNAL                 = 0x00000000,
                    LA_KICK                     = 0x00000001,
                    LA_FREEZE                   = 0x00000020,
                    LA_THAW                     = 0x00000040,
} LINK_ACTION;

//
// @struct LINK_INFO | Structure describing state of a virtual server AQ link
// @field DWORD | dwVersion | Version of LINK_INFO structure - will be CURRENT_QUEUE_ADMIN_VERSION
// @field LPWSTR | szLinkName | Name of next-hop
// @field DWORD | cMessages | Number of messages queued up for this link
// @field DWORD | fStateFlags | <t LINK_INFO_FLAGS> indicating Link State
// @field SYSTEMTIME | stNextScheduledConnection | The time at which the next
// connection will be attempted.
// @field SYSTEMTIME | stOldestMessage | The oldest message on this link
// @field ULARGE_INTEGER | cbLinkVolume | Total number of bytes on link
// @field LPWSTR | szLinkDN | DN associated with this link by routing.  Can be NULL.
// @field LPWSTR | szExtendedStateInfo | If present, this provides additional state
// information about why a link is in <t LI_RETRY> state.
// @field DWORD | dwSupportedLinkActions | Tells which <t LINK_ACTIONS> are supported
// by this link.
typedef struct tagLINK_INFO {
                    DWORD dwVersion; 
    MIDL([string])  LPWSTR szLinkName;
                    DWORD cMessages;
                    DWORD fStateFlags;
                    SYSTEMTIME stNextScheduledConnection;
                    SYSTEMTIME stOldestMessage;
                    ULARGE_INTEGER cbLinkVolume;
    MIDL([string])  LPWSTR szLinkDN;
    MIDL([string])  LPWSTR szExtendedStateInfo;
                    DWORD  dwSupportedLinkActions;
} LINK_INFO, *PLINK_INFO;

//
// @struct QUEUE_INFO | Structure describing state of a virtual server link 
// queue
// @field DWORD | dwVersion | Version of LINK_INFO structure - will be CURRENT_QUEUE_ADMIN_VERSION
// @field LPWSTR | szQueueName | Name of queue
// @field LPWSTR | szLinkName | Name of link that is servicing this queue
// @field DWORD | cMessages | Number of messages on this queue
// @field ULARGE_INTEGER | cbQueueVolume | Total number of bytes on queue
// @field DWORD | dwMsgEnumFlagsSupported | The types of message enumeration supported
typedef struct tagQUEUE_INFO {
                    DWORD dwVersion; 
    MIDL([string])  LPWSTR szQueueName;
    MIDL([string])  LPWSTR szLinkName;
                    DWORD cMessages;
                    ULARGE_INTEGER cbQueueVolume;
                    DWORD dwMsgEnumFlagsSupported;
} QUEUE_INFO, *PQUEUE_INFO;

//
// @enum AQ_MESSAGE_FLAGS | Flags describing message properties
// @flag MP_HIGH | High Priority Message
// @flag MP_NORMAL | Normal Priority Message
// @flag MP_LOW | Low Priority Message
// @flag MP_MSG_FROZEN | Message has been frozen by admin.
// @flag MP_MSG_RETRY | Delivery has been attempted and failed at least once
//  for this message.
// @flag MP_MSG_CONTENT_AVAILABLE | The content for this message can be 
//  accessed through the QAPI.
typedef enum tagAQ_MESSAGE_FLAGS {
                    MP_HIGH                     = 0x00000001,
                    MP_NORMAL                   = 0x00000002,
                    MP_LOW                      = 0x00000004,
                    MP_MSG_FROZEN               = 0x00000008,
                    MP_MSG_RETRY                = 0x00000010,
                    MP_MSG_CONTENT_AVAILABLE    = 0x00000020,
} AQ_MESSAGE_FLAGS;

// @struct MESSAGE_INFO | Structure describing a single mail message
// @field DWORD | dwVersion | Version of LINK_INFO structure - will be CURRENT_QUEUE_ADMIN_VERSION
// @field LPWSTR | szMessageId | Message ID
// @field LPWSTR | szSender | Sender Address, from "From:" header
// @field LPWSTR | szSubject | Message Subject
// @field DWORD | cRecipients | Number of recipients
// @field LPWSTR | szRecipients | Recipient Addresses, from "To:" header
// @field DWORD | cCCRecipients | Number of CC recipients
// @field LPWSTR | szCCRecipients | CC Recipient Addresses, from "CC:" header
// @field DWORD | cBCCRecipients | Number of BCC recipients
// @field LPWSTR | szBCCRecipients | BCC Recipient Addresses, from "BCC:" header
// @field DWORD | cbMessageSize | size of message in bytes
// @field DWORD | fMsgFlags | <t AQ_MESSAGE_FLAGS> describing message properties.
// @field SYSTEMTIME | stSubmission | Time of message submission
// @field SYSTEMTIME | stReceived | Time message was received by this server
// @field SYSTEMTIME | stExpiry | Time message will expire by if not delivered
// to all recipients, thus generating an NDR
// @field DWORD | cFailures | The number of failured delivery attempts for 
// this message
// @field DWORD | cEnvRecipients | The number of envelope recipeints
// @field DWORD | cbEnvRecipients | The size in bytes of the envelope recipients
// @field WCHAR * | mszEnvRecipients | A multi-string UNICODE buffer containing
// a NULL-terminated string for each recipient.  The buffer itself is terminated
// by an additional NULL.  Each recipient string will be formatted in the proxy
// address format of 'addr-type ":" address'.  The addr-type should match
// the address type found in the DS (ie SMTP).  The address should be returned 
// in it's native format.
typedef struct tagMESSAGE_INFO {
                                    DWORD dwVersion; 
    MIDL([string])                  LPWSTR szMessageId;
    MIDL([string])                  LPWSTR szSender;
    MIDL([string])                  LPWSTR szSubject;
                                    DWORD cRecipients;
    MIDL([string])                  LPWSTR szRecipients;
                                    DWORD cCCRecipients;
    MIDL([string])                  LPWSTR szCCRecipients;
                                    DWORD cBCCRecipients;
    MIDL([string])                  LPWSTR szBCCRecipients;
                                    DWORD fMsgFlags;
                                    DWORD cbMessageSize;
                                    SYSTEMTIME stSubmission;
                                    SYSTEMTIME stReceived;
                                    SYSTEMTIME stExpiry;
                                    DWORD cFailures;
                                    DWORD cEnvRecipients;
                                    DWORD cbEnvRecipients;
    MIDL([size_is(cbEnvRecipients/sizeof(WCHAR))]) WCHAR *mszEnvRecipients;
} MESSAGE_INFO, *PMESSAGE_INFO;

typedef enum tagQUEUELINK_TYPE {
                    QLT_QUEUE,
                    QLT_LINK,
                    QLT_NONE
} QUEUELINK_TYPE;

typedef struct tagQUEUELINK_ID {
                    GUID            uuid;
    MIDL([string])  LPWSTR          szName;
                    DWORD           dwId;
                    QUEUELINK_TYPE  qltType;
} QUEUELINK_ID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\abtype.h ===
//+---------------------------------------------------------------
//
//  File:   Abtype.h
//
//  Synopsis:   Includes all defs and datatype used in MSN Address Book 2.x
//
//  Copyright (C) 1995 Microsoft Corporation
//          All rights reserved.
//
//  History:    SunShaw     Created                 30 Jan 1996
//              FeiSu       modified error code     21 May 1996
//
//----------------------------------------------------------------



#ifndef  _AB_TYPE_H_
#define  _AB_TYPE_H_


#include <wtypes.h>
#include <dbsqltyp.h>


#define AB_API_SIGNATURE    (DWORD) 'PABA'
#define AB_DOMAIN_LIST_SIG  (DWORD) 'ldbA'

//+---------------------------------------------------------------
//
// Definitions used in MSN Address Book 2.x
//
//----------------------------------------------------------------

#define AB_MAX_MONIKER  (250)
#define AB_MAX_LOGIN    (64)

#define AB_MAX_EMAIL    (AB_MAX_LOGIN)
#define AB_MAX_DOMAIN   (250)
#define AB_MAX_FULL_EMAIL_WO_NULL   (AB_MAX_LOGIN + AB_MAX_DOMAIN + 1)
#define AB_MAX_INTERNAL_FULL_EMAIL  (AB_MAX_LOGIN + AB_MAX_DOMAIN + 1 + 1)
#define AB_MAX_CONTEXT_NAME (16)
#define AB_MAX_CONFIG   (512)
#define AB_MAX_VROOT    (250)
#define AB_MAX_LDAP_DN  (AB_MAX_INTERNAL_FULL_EMAIL)
#define AB_MAX_AUTOREPLY_SUBJECT (250)

#define AB_SUCCESS                  0x00000000  //  Success
#define AB_SUCCESS_NOTLOCAL         0x00000001  //  AB Internal Use only

#define MAX_SERVERNAME          31  // same value, different name as defined in sqlfront.h
#define MAX_NAME                30  // same value, different name as defined in sqlfront.h

/////////////////////////////////////////////////////////////////////
//
//  Abook error codes are moved to abmsg.h, which is generated by abmsg.mc
//  To add a new error code, check both abmsg.mc and abget.cpp
//
/////////////////////////////////////////////////////////////////////
#define WIN32_ERROR_FROM_AB

//+---------------------------------------------------------------
//
// Types used in MSN Address Book 2.x
//
//----------------------------------------------------------------

typedef DWORD ABRETC;   // Address Book Return Code


typedef struct tagDOMAIN_LIST {
    DWORD       dwSignature;
    CHAR        szDomainName[AB_MAX_DOMAIN+1];
    LIST_ENTRY  list;
} DOMAIN_LIST;


// added june 5th 1996
typedef struct tagABUSER {
    CHAR    szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    CHAR    szForward[AB_MAX_INTERNAL_FULL_EMAIL];
    BOOL    fLocal;
    DWORD   cbMailBoxSize;
    DWORD   cbMailBoxMessageSize;
    CHAR    szVRoot[AB_MAX_VROOT];
} ABUSER;

typedef struct tagABDL {
    CHAR    szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    DWORD   dwToken;
} ABDL;


//  The ABROUTING structure contains the information necessary for
//  the mail servers to route mail to a user.
typedef enum tagABSTATUS {
    absUnknown      = 0,    // CAddr should be initialize with this value
    absLocal        = 1,
    absUnresolved   = 3,
    absNotLocal     = 4,
    absNotUsed      = 6,    // Just discard the CAddr
    absNotDelivered = 7,    // Local mail delivery failed
    absAccessDenied = 8,    // Access Denied to usage the DL
    absDelivered    = 9,    // Need for DL to file
    //
    // Values from 60 to 200 are reserved for Abook Internal Use Only
    //
    absInPartial    = 60,
    absInDistList   = 64,   // Is Small DL with no public token, needs to call GetAccountRight
    absInDistListEx = 128   // Is Large DL with no public token, needs to call
                            //      GetAccountRight then AbResolveAddressEx

} ABSTATUS;

#define ABROUTING_SIGNATURE 'gtRA'

typedef struct tagABROUTING {
    DWORD       dwSignature;
    ABSTATUS    abstatus;
    CHAR        szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];
    CHAR        szVRoot[AB_MAX_MONIKER];
    CHAR        szDN[AB_MAX_LDAP_DN];
    CHAR        szAutoReplySubject[AB_MAX_AUTOREPLY_SUBJECT];
    DWORD       cbMaxInbox;
    DWORD       cbMaxInboxMessages;
    BOOL        fAutoReply;
} ABROUTING, *PABROUTING;

#define ABRESOLVE_SIGNATURE 'vsRA'
typedef struct tagABRESOLVE
{
    DWORD       dwSignature;
    HANDLE      hConnection;
    PVOID       dbproc;
} ABRESOLVE, *PABRESOLVE;

typedef struct tagABPARTIALINFO {
    DWORD   dwAbMagicId;
    DWORD   dwAbInfoId;
    DWORD   dwAbToken;
    DWORD   dwAbType;
} ABPARTIALINFO, *PABPARTIALINFO;




typedef struct tagABROUTINGEX {
    ABSTATUS    abs;
    CHAR        szFullEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    ABROUTING   abrouting;
} ABROUTINGEX, *PABROUTINGEX;


typedef ULONG ABIID;        // AbInfoId

// Address Book Type Search Flag
typedef ULONG ABTSF;
#define ABTSF_ACCOUNT       0x00000001      // 1
#define ABTSF_NORMAL_DL     0x00000040      // 64
#define ABTSF_EXTENED_DL    0x00000080      // 128
#define ABTSF_DOMAIN_DL     0x00000100      // 256
#define ABTSF_SITE_DL       0x00000200      // 512
#define ABTSF_DISTLIST      (ABTSF_NORMAL_DL | ABTSF_EXTENDED_DL | ABTSF_DOMAIN_DL | ABTSF_SITE_DL)
#define ABTSF_ALLTYPE       0xffffffff

typedef enum {
    abtUnknown      = 0,
    abtAccount      = ABTSF_ACCOUNT,
    abtNormalDL     = ABTSF_NORMAL_DL,
    abtExtendedDL   = ABTSF_EXTENED_DL,
    abtDomainDL     = ABTSF_DOMAIN_DL,
    abtSiteDL       = ABTSF_SITE_DL
} ABTYPE;

typedef enum {
    abasValid   = 0,
    abasExpired = 1
} ABACCTSTATUS;


typedef struct tagABINFO_COM {
    ABIID   abiid;
    ABTYPE  abt;
    CHAR    szEmail[AB_MAX_EMAIL];
    CHAR    szDomain[AB_MAX_DOMAIN];
    INT     nDomainId;
} ABINFO_COM, *PABINFO_COM;


typedef struct tagABINFO_ACCOUNT {
    ABIID       abiid;
    ABTYPE      abt;
    CHAR        szEmail[AB_MAX_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];    //
    INT         nDomainId;                  // Reserved for Internal use, must set to -1.
    HACCT       hAcct;                      //
    DWORD       dwGroupId;
    DWORD       dwFlags;
} ABINFO_ACCOUNT, *PABINFO_ACCOUNT;


typedef struct tagABINFO_DISTLIST {
    ABIID       abiid;
    ABTYPE      abt;
    CHAR        szEmail[AB_MAX_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];
    INT         nDomainId;
    HACCT       hAcctOwner;
    TOKEN       token;
    DWORD       dwSecureLevel;
} ABINFO_DISTLIST, *PABINFO_DISTLIST;




typedef struct tagABSERVER_INFO {
    DWORD   dwServerId;
    DWORD   dwTypeFlags;
    CHAR    szServerName[MAX_PATH];
} ABSRVR_INFO, *PABSRVR_INFO;


union ABINFO_SUPERSET {
    ABINFO_ACCOUNT      abiacc;
    ABINFO_DISTLIST     abidl;
    ABSRVR_INFO         absrvr;
};


typedef struct tagAbPersistDomainInfo {
    CHAR        szDomainName[AB_MAX_DOMAIN];    // ie uk.eu.msn.com
    BOOL        fLocal;                         // Local to current site
    BOOL        fReplicate;                     // Not local but just want to subscribe to the info
    CHAR        szParentDomain[AB_MAX_DOMAIN];  // ie eu.msn.com
    LIST_ENTRY  list;                           // list pointers
} ABPDI, *PABPDI;

typedef struct tagAbSource {
    CHAR        szConfig[AB_MAX_CONFIG];
    LIST_ENTRY  list;
} ABSOURCE, *PABSOURCE;

typedef struct tagAbSourceEntry {
    LONG            lType;
    LONG            lMaxCnx;
    LONG            lQueryTimeOut;
    DWORD           dwRecoverTime;

    CHAR            szServerName[MAX_SERVERNAME + 1];
    CHAR            szDBName[MAX_NAME + 1];
    CHAR            szLoginName[MAX_NAME + 1];
    CHAR            szPassWord[MAX_NAME +1];

    DWORD           dwAction;

    LIST_ENTRY      list;

    void* operator new(size_t size);
    void  operator delete(void* pvMem, size_t size);
} ABSOURCE_ENTRY, *PABSOURCE_ENTRY;

typedef struct tagAbAddrStatistic {
    BOOL    cRemote;            // Number of remote recips to return
    BOOL    cLocal;             // Number of local recips to return
    DWORD   cUnresolved;        // Number of unresolved recips to return
} ABADDRSTAT,*PABADDRSTAT;


typedef enum {
    abatResolveDL = 1,
    abatMatchName = 2,
    abatServerList= 3,
    abatDomainList= 4,
    abatEnumResolveEx=5,
    abatEnumUserGroup=6
} ABACTIONTYPE;

typedef struct tagABENUM {
    ABRETC          abrcLastError;
    BOOL            fCheckRights;
    HACCT           hAcct;
    DWORD           dwRights;
    DWORD           cRowSoFar;
    DWORD           cRowRejected;
    DWORD           cRowMatched;
    DWORD           cRowReturned;
    PVOID           dbproc;
    HANDLE          hconn;  // HANDLE returned from DbGetConnection() in dbcon.dll
    ABACTIONTYPE    abat;
    BOOL            fUseLastRow;
    ABINFO_SUPERSET rgbLastRow;
} ABENUM, *PABENUM;

typedef struct _ABOOKDB_STATISTICS_0
{
    DWORD               NumResolvedAddresses;
    DWORD               NumUnresolvedAddresses;

    // Distribution List specific
    DWORD               NumDLsExpanded;
    DWORD               NumSmallDLsExpanded;
    DWORD               NumLargeDLsExpanded;
    DWORD               TimeResolvingSmallDLs;
    DWORD               TimeResolvingLargeDLs;

    // Api call frequency
    DWORD               NumAbResolveAddressCalls;
    DWORD               NumAbResolveAddressExCalls;
    DWORD               NumAbGetUserMailRootCalls;
    DWORD               NumAbGetUserMailRootFromHacctCalls;

    DWORD               NumAbCreateDL;
    DWORD               NumAbUpdateDL;
    DWORD               NumAbDeleteDL;
    DWORD               NumAbAddDLMember;
    DWORD               NumAbDeleteDLMember;

    DWORD               NumAbCreateInternetAcct;
    DWORD               NumAbDeleteInternetAcct;

    DWORD               NumAbCreateLocalUser;
    DWORD               NumAbCreateRemoteUser;
    DWORD               NumAbDeleteUser;

    DWORD               NumAbGetAbinfoFromEmail;
    DWORD               NumAbGetAbinfoFromAbiid;

    DWORD               NumAbResolveDLMembers;
    DWORD               NumAbMatchSimilarName;
    DWORD               NumAbGetServerList;
    DWORD               NumAbGetDomainList;
    DWORD               NumAbGetSiteList;

    // Data Base specific
    DWORD               NumDBFailures;
    DWORD               NumAuthenticationRequested;

} ABOOKDB_STATISTICS_0, *PABOOKDB_STATISTICS_0;

//
//  Completion callback from ABResolveAddress
//
typedef VOID (__stdcall *LPFNRESOLVECOMPLETE)(
    DWORD dwErr,
    PVOID pContext,
    PABADDRSTAT pAddrStat,
    PABRESOLVE pAbresolve);
//
//  Callback from TransactionLogging
//
typedef VOID  (__stdcall *LPFNLOGTRANX)(LPCSTR,LPCSTR,LPCSTR,DWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\artcore.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    article.h

Abstract:

    This module contains class declarations/definitions for

		CArticle
        CField
			CDateField
			CFromField
			CMessageIDField
			CSubjectField
			CNewsgroupsField
			CPathField
			CXrefField
			CFollowupToField
			CReplyToField
			CApprovedField
			CSenderField
			CExpiresField
			COrganizationField
			CSummaryField
			CReferencesField
            CControlField
			CLinesField
			CDistributionField
			CKeywordsField
			CNNTPPostingHostField
			CXAuthLoginNameField
		CNAMEREFLIST


    **** Overview ****

    An CArticle object provides an software interface for viewing
	and editing a netnews article.
	
	An object is initialized by
	giving it a handle or filename for a file containing a Netnews
	article. During initialization the article is "preparsed".
	Preparsing consists of memory mapping the file and then
	finding the location of
	    1. The gap that may preceed the article in the file.
		2. The article in the file.
		3. The article's header
		4. The article's body.

	Also for every header line in the header, the preparsing creates an
	entry in an array that records the location of:
		1. The header line
		2. The keyword
		4. The value

	All these locations are represented with Pointer/Counter Strings (See
	CPCString in pcstring.h.) This representation has just to parts
		1. A char pointer to the start of the item in the memory mapped file..
		2. A dword containing the length of the item.


  **** Fields ****

	Each CArticle object can also have several CField subobjects. These
	subobjects specialize in parsing and editing specific types of fields.
	For example, the CNewsgroupsField object knows how to validate, get,
	and set the "Newsgroups: " field.

  **** Derivied Objects ****

	Every type of feed (e.g. FromClient, FromPeer, etc) defines its own CArticle
	object with the CField subobjects that it needs. For example, for FromClient
	feeds there is a CFromClientArticle (defined in fromclnt.h) with a
	CFromClientFromField (also defined in fromclnt.h) that does very strict
	parsing of the article's "From: " field.

  **** Editing an Article ****

	The header of an article can be edited by deleting old headers and adding
	new ones. Headers are deleted just may marking an field in the array of
	header values. Headers are added by adding a new entry to the array. This
	entry can't just point to the memory-mapped file, so it instead points
	to dynamically allocated memory.

	When an article is "saved" (or "flushed"), the actual image on disk is
	changed to reflected the changes made.



Author:

    Carl Kadie (CarlK)     10-Oct-1995

Revision History:

--*/

#ifndef	_ARTCORE_H_
#define	_ARTCORE_H_

#include	"tigtypes.h"
#include	"grouplst.h"
#include    "artglbs.h"
#include 	"pcstring.h"
#include 	"nntpret.h"
#include 	"mapfile.h"
#include 	"artutil.h"
#include 	"nntpmacr.h"
#include 	"pcparse.h"
#include 	"nntpcons.h"
#include 	"timeconv.h"

// forward declaration
class	CInFeed ;

//
// CPool Signature
//

#define ARTCORE_SIGNATURE (DWORD)'artc'

//
//	Utility functions
//
BOOL	AgeCheck(	CPCString	pcDate	) ;

//
// NAME_AND_ARTREF - structure for storing a newsgroups name, groupid, and article id.
//

typedef struct _NAME_AND_ARTREF {
	CPCString pcName;
	CArticleRef artref;
} NAME_AND_ARTREF;


//
// CNAMEREFLIST - object implementing a list of newsgroups. For each newsgroup,
// its name, group id and article id is recorded.
//

#ifndef	_NO_TEMPLATES_

#ifndef _NAMEREF_GROUPLIST_TEMPLATE_
#define _NAMEREF_GROUPLIST_TEMPLATE_
typedef CGroupList< NAME_AND_ARTREF > CNAMEREFLIST;
#endif

#else

DECLARE_GROUPLST(	NAME_AND_ARTREF )

typedef	INVOKE_GROUPLST( NAME_AND_ARTREF )	CNAMEREFLIST ;

#endif




//
// An interger setting an upper limit on the number of
// fields in a header can be processed.
//

const unsigned int uMaxFields = 60;

//
// Used to note that the size of the gap before the article starts is
// not known.
//

const DWORD cchUnknownGapSize = (DWORD) -1;


//
// The maximum size of a component (e.g. "alt", "ms-windows") of a
// newsgroup name. (Value is from the Son of 1036 spec.)
//

const DWORD cchMaxNewsgroups = 14;

//
// Define some header field keywords
//

const char szKwFrom[] =			"From:";
const char szKwDate[] =			"Date:";
const char szKwSubject[] =		"Subject:";
const char szKwNewsgroups[] =	"Newsgroups:";
const char szKwMessageID[] =	"Message-ID:";
const char szKwPath[] =			"Path:";
const char szKwReplyTo[] =		"ReplyTo:";
const char szKwSender[] =		"Sender:";
const char szKwFollupTo[] =		"FollowupTo:";
const char szKwExpires[] =		"Expires:";
const char szKwReferences[] =	"References:";
const char szKwControl[] =		"Control:";
const char szKwDistribution[] =	"Distribution:";
const char szKwOrganization[] =	"Organization:";
const char szKwKeywords[] =		"Keywords:";
const char szKwSummary[] =		"Summary:";
const char szKwApproved[] =		"Approved:";
const char szKwLines[] =		"Lines:";
const char szKwXref[] =			"Xref:";
const char szKwNNTPPostingHost[] = "NNTP-Posting-Host:";
const char szKwFollowupTo[] =	"Followup-To:";
const char szKwXAuthLoginName[] =	"X-Auth-Login-Name:";

//
// Used to create an array that points to header values.
// The memory may be allocated in a mapped file or
// dynamically.
//

typedef struct
{
	CPCString	pcKeyword;		//  The keyword upto the ":"
	CPCString	pcValue;		//  The value (starting after any whitespace,

								//
								//		not including newline characters
								//

	CPCString	pcLine;			//  The whole line include any newline characters
	BOOL		fInFile;	//  True if pointer to a file (rather than other memory
	BOOL		fRemoved;
} HEADERS_STRINGS;


//
// Forward class declarations (the full classes are declared later)
//

class	CArticle;
class	CXrefField;
class	CPathField;
class   CArticleCore;

//
// Represents the states of a field.
//

typedef enum _FIELD_STATE {
	fsInitialized,
	fsFound,
	fsParsed,
	fsNotFound,
} FIELD_STATE;

//
// Represents the types of control messages
// The order should EXACTLY match the keyword array that follows
//

typedef enum _CONTROL_MESSAGE_TYPE {
	cmCancel,
	cmNewgroup,
	cmRmgroup,
	cmIhave,
    cmSendme,
    cmSendsys,
    cmVersion,
    cmWhogets,
    cmCheckgroups,
} CONTROL_MESSAGE_TYPE;

//
// Control message strings
//
#define MAX_CONTROL_MESSAGES 9

static  char  *rgchControlMessageTbl[ MAX_CONTROL_MESSAGES ] =
{
	"cancel", "newgroup", "rmgroup", "ihave", "sendme", "sendsys",
	"version", "whogets", "checkgroups",
};

//
//	Switch to decide what From: header to use in the envelope of mail messages
//
typedef enum _MAIL_FROM_SWITCH {
	mfNone,
	mfAdmin,
	mfArticle,
} MAIL_FROM_SWITCH;

static const char* lpNewgroupDescriptorTag = "For your newsgroups file:";
static const char lpModeratorTag[] = "Group submission address:";

//
//
//
// CField - pure virtual base class for manipulating a field in an
//			article.
//
//	Each CArticle object can also have several CField subobjects. These
//	subobjects specialize in parsing and editing specific types of fields.
//	For example, the CNewsgroupsField object knows how to validate, get,
//	and set the "Newsgroups: " field.
//

class	CField {

public :

	//
	// Constructor
	//

	CField():
		   m_pHeaderString(NULL),
		   m_fieldState(fsInitialized)
		   { numField++; };

	//
	// Deconstructor
	//

    virtual ~CField(void){ numField--;};

	//
	// Returns the keyword of the field on which this CField works.
	//

	virtual const char * szKeyword(void) = 0;

	//
	// Finds the field of interest in the article (if it is there)
	// and parses it.
	//

	BOOL fFindAndParse(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);


	//
	// Makes sure the keyword for this file has the correct
	// capitalization.
	//

	BOOL fConfirmCaps(
			CNntpReturn & nntpReturn
			);


	//
	// The derived objects will define Get(s) that return the type of interest, but
	// here are some virtual functions for the most common types.
	//

	//
	// Get the value in multisz form
	//

	virtual const char * multiSzGet(void)	{
			return (char *) NULL;
			};

	//
	// Get the value in DWORD form
	//

	virtual DWORD cGet(void) {
			return (DWORD) -1;
			};

	//
	// Get the value as a CPCString
	//

	virtual CPCString pcGet(void) {
			return m_pc;
			}

	//
	// Specify friends
	//

	friend CArticle;
	friend CPathField;

protected:


	// Finds this field in the article
	virtual BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Parses this field. By default just find the begining
	// and end of the value.

	virtual BOOL fParse(
				CArticleCore & article,
				CNntpReturn & nntpReturn)
			{
				return fParseSimple(FALSE, m_pc, nntpReturn);
			};

	// One type of "find" -- Find one or zero occurances of this field.
	// Any other number is a error.
	BOOL fFindOneOrNone(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "find" -- Find zero occurances of this field.
	// Any other number is a error.
	BOOL fFindNone(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Just finds the beginning and end of the value.
	BOOL fParseSimple(
			BOOL fEmptyOK,
			CPCString & pc,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Splits the value into a list of items.
	BOOL fParseSplit(
			BOOL fEmptyOK,
			char * & multisz,
			DWORD & c,
			char const * szDelimSet,
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the strict Newsgroups parse rules.
	BOOL fStrictNewsgroupsParse(
			BOOL fEmptyOK,
			char * & multiSzNewsgroups,
			DWORD & cNewsgroups,
		    CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the strict Date parse rules.
	// Useful for Date and Expires.
	BOOL fStrictDateParse(
			CPCString & pcDate,
			BOOL fEmptyOK,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the relative Date parse rules.
	// Useful for Date and Expires.
	BOOL fRelativeDateParse(
			CPCString & pcDate,
			BOOL fEmptyOK,
			CNntpReturn & nntpReturn
			);

	// One type of "parse". Applies the strict From parse rules.
	// Useful for From, Sender, and ReplyTo
	BOOL fStrictFromParse(
			CPCString & pcFrom,
			BOOL fEmptyOK,
			CNntpReturn & nntpReturn
			);


	// Test a message id value for legal values.
	BOOL fTestAMessageID(
			const char * szMessageID,
			CNntpReturn & nntpReturn
			);
	
	// Points to the item in the article's array for this field.
	HEADERS_STRINGS * m_pHeaderString;

	// The state of this field
	FIELD_STATE m_fieldState;

	// The result of SimpleParse (this may not be used)
	CPCString m_pc;

};


//
//
// Pure virtual base class for manipulating an article's Date field.

class CDateField : public CField {

public:

    CDateField(){ numDateField++;};
    ~CDateField(void){ numDateField--;};

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwDate;
			};
};


//
//
// Pure virtual base class for manipulating an article's From field.

class CFromField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwFrom;
			};

};



//
//
// Pure virtual base class for manipulating an article's MessageID field.

class CMessageIDField : public CField {

public:
	//
	// Initalize the member variable
	//
	CMessageIDField (void)
			{
			m_szMessageID[0] = '\0';
			}

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwMessageID;
			};

	// Parse a message id field
	BOOL fParse(
			 CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Get the message id
	char * szGet(void) {
			return m_szMessageID;
			};

protected:
	// a place to store the message id that parsing findds
	char m_szMessageID[MAX_MSGID_LEN];
};



//
//
// Pure virtual base class for manipulating an article's Subject field.

class CSubjectField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwSubject;
			};

	// The subject field is parsed with ParseSimple
	BOOL fParse(
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
			{
				return fParseSimple(TRUE, m_pc, nntpReturn);
			};

	friend CArticle;

};


//
//
// Pure virtual base class for manipulating an article's Newsgroups field.
//

class CNewsgroupsField : public CField {

public:

	// Constructor
	CNewsgroupsField():
			m_multiSzNewsgroups(NULL),
			m_cNewsgroups((DWORD) -1),
			m_pAllocator(NULL)
			{};

	// Destructor
	virtual ~CNewsgroupsField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzNewsgroups);
				}
			};


	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwNewsgroups;
			};

	// Parse the Newsgroups field
	BOOL fParse(
			 CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Return the newsgroups as a multisz
	const char * multiSzGet(void);

	// Return the number of newsgroups found
	DWORD cGet(void);

	friend CXrefField;

protected:

	// A pointer to the dynamic memory used to hold the list of newsgroups
	char * m_multiSzNewsgroups;

	// The number of newsgroups
	DWORD m_cNewsgroups;

	// Where to allocate from
	CAllocator * m_pAllocator;

};



class CDistributionField : public CField {

public:

	// Constructor
	CDistributionField():
			m_multiSzDistribution(NULL),
			m_cDistribution((DWORD) -1),
			m_pAllocator(NULL)
			{};

	// Destructor
	virtual ~CDistributionField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzDistribution);
				}
			};


	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwDistribution;
			};

	BOOL fFind(
		CArticleCore & article,
		CNntpReturn & nntpReturn)
	{
		return fFindOneOrNone(article, nntpReturn);
	};

// Parse the Distribution field
	BOOL fParse(
			 CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	// Return the Distribution as a multisz
	const char * multiSzGet(void);

	// Return the number of Distribution found
	DWORD cGet(void);

protected:

	// A pointer to the dynamic memory used to hold the list of Distribution
	char * m_multiSzDistribution;

	// The number of Distribution
	DWORD m_cDistribution;

	// Where to allocate from
	CAllocator * m_pAllocator;

};

//
//  base class for manipulating an article's Control field.
//
class CControlField : public CField {

public:
    //
    // Constructor
    //
    CControlField(){ m_cmCommand = (CONTROL_MESSAGE_TYPE)MAX_CONTROL_MESSAGES;}

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwControl;
			};

	//
	// There should only be one such field in articles from clients.
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse to get the type of control message
	//
	BOOL fParse(
		    CArticleCore & article,
			CNntpReturn & nntpReturn
            );

    //
    // Return the type of control message
    //
    CONTROL_MESSAGE_TYPE    cmGetControlMessage(){return m_cmCommand;}

protected:
    //
    // Control message type
    //
    CONTROL_MESSAGE_TYPE    m_cmCommand;
};

//
//
// Pure virtual base class for manipulating an article's Xref field.

class CXrefField : public CField {

public:
		
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwXref;
			};

	// This is a way of saying that, by default, the Xref line should
	// never be parsed.
	virtual BOOL fParse(
				 CArticle & article,
				 CNntpReturn & nntpReturn
				 )
			{
				_ASSERT(FALSE);
				return FALSE;
			};

	// Create a new Xref line.
	BOOL fSet(
			CPCString & pcHub,
			CNAMEREFLIST & namereflist,
			CArticleCore & article,
			CNewsgroupsField & fieldNewsgroups,
			CNntpReturn & nntpReturn
			);

	// Just delete any Xref lines
	BOOL fSet(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);


	// Return the list of newsgroup name's, groupid, and article id's
	CNAMEREFLIST * pNamereflistGet(void)	{
			_ASSERT(m_namereflist.fAsBeenInited());
			return &m_namereflist;
			};

	// Return the number of newsgroups that we are posting to locally.
	DWORD cGet(void) {
			_ASSERT(m_namereflist.fAsBeenInited());
			return m_namereflist.GetCount();
			};

	friend CArticle;

protected:

	// Store a list of the local newsgroups we are posting to.
	CNAMEREFLIST m_namereflist;

};


//
//
// Pure virtual base class for manipulating an article's FollowupTo field.

class CFollowupToField : public CField {

public:

	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwFollowupTo;
			};

};


//
//
// Pure virtual base class for manipulating an article's ReplyTo field.

class CReplyToField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwReplyTo;
			};
};

//
//
// Pure virtual base class for manipulating an article's Approved field.

class CApprovedField : public CField {

public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwApproved;
			};

};

//
//
// Pure virtual base class for manipulating an article's Sender field.

class CSenderField	: public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwSender;
			};
};

//
//
// Pure virtual base class for manipulating an article's Expires field.

class CExpiresField	: public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwExpires;
			};
};

//
//
// Pure virtual base class for manipulating an article's Organization field.

class COrganizationField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwOrganization;
			};
};

//
//
// Pure virtual base class for manipulating an article's Summary field.

class CSummaryField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwSummary;
			};
};

//
//
// Pure virtual base class for manipulating an article's References field.

class CReferencesField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwReferences;
			};
};

//
//
// Pure virtual base class for manipulating an article's Lines field.
//

class CLinesField : public CField {

public:
		
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwLines;
			};

	//
	// There should be one or none
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};


	//
	// How to set the field.
	//

	virtual BOOL fSet(
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);

	//
	// Do we need to back fill ?
	//
	BOOL fNeedBackFill() { return fsParsed != m_fieldState; }

	//
	// Get lines back fill offset
	//
	DWORD   GetLinesOffset() { return m_dwLinesOffset; }

private:

    //
    // back fill offset
    //
    DWORD   m_dwLinesOffset;

};

//
//
// Pure virtual base class for manipulating an article's Keywords field.

class CKeywordsField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwKeywords;
			};
};

//
//
// Pure virtual base class for manipulating an article's NNTPPostingHost field.

class CNNTPPostingHostField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwNNTPPostingHost;
			};
};

//
//
// Pure virtual base class for manipulating an article's XAuthLoginName field.

class CXAuthLoginNameField : public CField {
public:
	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwXAuthLoginName;
			};
};

//
// Represents the states of an article
//
typedef enum _ARTICLE_STATE {
	asUninitialized,
	asInitialized,
	asPreParsed,
	asModified,
	asSaved
} ARTICLE_STATE;

//
// CCreateFileImpl implements the way we create the file for mapfile,
// in this case we do CacheCreateFile.
//
class CCacheCreateFile : public CCreateFile {

public:
    CCacheCreateFile( BOOL fOpenForRead ) :
        m_fOpenForRead( fOpenForRead ),
        m_pFIOContext( NULL )
    {}
    ~CCacheCreateFile();
    virtual HANDLE CreateFileHandle( LPCSTR szFileName );

    PFIO_CONTEXT    m_pFIOContext;

private:

    CCacheCreateFile();
    static HANDLE CacheCreateCallback(  LPSTR   szFileName,
                                        LPVOID  pv,
                                        PDWORD  pdwSize,
                                        PDWORD  pdwSizeHigh );

    BOOL            m_fOpenForRead;
};

//
//
//
// CArticleCore - pure virtual base class for manipulating an article.
// Article are derived from CRefCount. Thus, when nothing points
// to an article it is freed up.


class	CArticleCore  : public CRefCount{
private :

	// Used for memory allocation
	static	CPool*	g_pArticlePool;

	// Uesd for special create file with CMapFile
	CCacheCreateFile m_CacheCreateFile;

//
// Public Members
//

public :

	// Used for memory allocation
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	inline	void*	operator	new(	size_t	size ) ;
	inline	void	operator	delete( void *pv ) ;

	//
	//   Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
    CArticleCore();

   	//
   	//   Destructor
   	//

    virtual ~CArticleCore() ;

	//
	//   Initialize from a filename or handle
	//

	BOOL fInit(
			const char * szFilename,
			CNntpReturn & nntpReturn,
			CAllocator * pAllocator,
			HANDLE hFile = INVALID_HANDLE_VALUE,
			DWORD	cBytesGapSize = cchUnknownGapSize,
			BOOL    fCacheCreate = FALSE
			);

	//
	//	If an incoming article was small enough to fit entirely into
	//	a memory buffer - call this function !
	//
	
	BOOL	fInit(
				char*		pchHead,
				DWORD		cbHead,
				DWORD		cbArticle,
				DWORD		cbBufferTotal,
				CAllocator*	pAllocator,
				CNntpReturn&	nntpReturn
				) ;

	//
	//	If an incoming article was so large that it did not fit into
	//	a memory buffer call this initialization function !
	//
	
	BOOL	fInit(
				char*		pchHead,
				DWORD		cbHead,
				DWORD		cbArticle,
				DWORD		cbBufferTotal,
				HANDLE		hFile,
				LPSTR		lpstrFileName,
				DWORD		ibHeadOffset,
				CAllocator*	pAllocator,
				CNntpReturn&	nntpReturn
				) ;

	//
	// create's an IStream pointer to the article contents and returns
	// it
	//
	BOOL fGetStream(IStream **ppStream);

	//
	//  Get body - map file if needed
	//

	BOOL fGetBody(
			CMapFile * & pMapFile,
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//	return TRUE if the article is in memory only and there is no file !
	//
	inline	BOOL	fIsArticleCached()	{
				return	m_szFilename == 0 ;
				}

	//
	//	Find out where the head and body of the article are within the file !
	//
	inline	void	GetOffsets(
						WORD	&wHeadStart,
						WORD	&wHeadSize,
						DWORD	&dwTotalSize
						)	{
		wHeadStart = (WORD)m_pcGap.m_cch ;
		wHeadSize  = (WORD)m_pcHeader.m_cch ;
		dwTotalSize = m_pcArticle.m_cch ;
	}

	//
	// These functions get (parts of) an article for transmission.
	// The second in each par of functions is useful when the article
	// is to be encrypted.
	//


	//
	//  Get header for file transmission
	//

	BOOL fHead(
			HANDLE & hFile,
			DWORD & dwOffset,
			DWORD & dwLength
			);

	//
	//  Get header for encryption
	//

	BOOL fHead(
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//  Get body for file transmission
	//

	BOOL fBody(
			HANDLE & hFile,
			DWORD & dwOffset,
			DWORD & dwLength
			);

	//
	//  Get body for encryption
	//

	BOOL fBody(
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//  Get body for encryption
	//

	DWORD dwBodySize(void)
		{
			return m_pcBody.m_cch;			
		}

	//
	//  Get whole article for file transmission
	//

	BOOL fWholeArticle(
			HANDLE & hFile,
			DWORD & dwOffset,
			DWORD & dwLength
			);

	//
	//  Get whole article for encryption
	//

	BOOL fWholeArticle(
			char * & pchMappedFile,
			DWORD & dwLength
			);

	//
	//   Sets the value of a header field including any newlines.
	// New values are always stored in dynamic memory allocated
	// with heap_alloc from the local thread. This function also sets
	// m_HeadersDirty and dwCurrentHeaderSize;
	//

	BOOL fSetHeaderValue(
			char const * szKeyword,
			const char * pchValue,
			DWORD cchValue
			);

	//
	// a header line of exactly the same length. It returns an error
	// if the lines aren't the same length.
	// Its expected use it to add the value of the XRef line to an
	// article without having to moving anything else around.
	//

	BOOL fOverwriteHeaderValue(
			char const * szKeyword,
			const char * pchValue,
			DWORD cchValue
			);

	//
	// Should we really changed the order the header lines just because we want
	// to touch "path" and "xref"?
	//
	//   Writes out the header. This means: Writing out the known fields in the
	// order they appear in the HEADER_FIELDS enumeration. If the gap is not big enough,
	// this will require coping the file. Unknown headers are written after the known ones.
	// This clears dwHeadersDirty, sets dwOriginalHeaderSize to be the current header size.
	// If another pass of changes is required, then m_fParse must be called again.
	// The parameter tell if the headers should be output in the original order or if they
	// should be output in the prefered order.
	//

	BOOL fSaveHeader(
			CNntpReturn     &nntpReturn,
			PDWORD          pdwLinesOffset = NULL
			);

	BOOL fSaveCachedHeaderInternal(
			CNntpReturn&	nntpReturn,
			PDWORD          pdwLinesOffset = NULL
			) ;

	BOOL fBuildNewHeader(	
			CPCString&	pcHeaderBuf	,
			CNntpReturn&	nntpReturn,
			PDWORD          pdwLinesOffset = NULL
			) ;

	//
	// calling this function makes it safe to use fGetHeader after a
	// call to vClose.
	//
	BOOL fMakeGetHeaderSafeAfterClose(CNntpReturn &nntpReturn);

	BOOL fSaveHeaderInternal(
			CPCString & pcHeaderBuf,
			CPCString & pcNewBody,
			CNntpReturn & nntpReturn,
			PDWORD      pdwLinesOffset = NULL
			);

	BOOL fGetHeader(
			LPSTR	lpstrHeader,
			BYTE*	lpbOutput,
			DWORD	cbOutput,
			DWORD&	cbReturn
			) ;
			

	// Removes any occurance of a field

	BOOL fRemoveAny(
			const char * szKeyword,
			CNntpReturn & nntpReturn
			);

	// Adds a line of text to the header

	BOOL fAdd(
			char * pchCurrent,
			const char * pchMax,
			CNntpReturn & nntpReturn
			);

	// Returns the article's filename
	char *	szFilename(void) {
			return m_szFilename;
			};


	//
	// For dynamic memory allocation
	//

	CAllocator * pAllocator(void)
		{ return m_pAllocator;}

	// Returns the article's main artref
	CArticleRef	articleRef(void) {
			return m_articleRef;
			};

	// Sets the article's main artref
	void vSetArticleRef(CArticleRef	& articleRef) {
			m_articleRef = articleRef;
			};

	// Returns XOver information for the article.
	BOOL fXOver(
			CPCString & pcBuffer,
			CNntpReturn & nntpReturn
			);

	// Closes the article's filemapping.
	void vClose(void);
	void vCloseIfOpen(void);

	//	Flush the article to disk !
	void	vFlush(void);

	// Finds the one and only occurance of the a field in the headers.
	// If there are no occurances or multiple occurances, then an error
	// is returned.

	BOOL fFindOneAndOnly(
			const char * szKeyword,
			HEADERS_STRINGS * & pHeaderString,
			CNntpReturn & nntpReturn
			);

	friend CField;

	//
	//	Public interface which should be used if fSaveHeader() is not called
	//	to fill in any initial gap within the file !
	//
	BOOL	
	fCommitHeader(	
			CNntpReturn &	nntpReturn
			) ;
			

	//
	//	Did the headers remain in the IO buffer - if so where ?
	//
	BOOL
	FHeadersInIOBuff(	char*	pchStartIOBuffer, DWORD	cbIOBuffer )	{
		if( m_pcHeader.m_pch > pchStartIOBuffer &&
			m_pcHeader.m_pch < &pchStartIOBuffer[cbIOBuffer] ) 	{
			_ASSERT( (m_pcHeader.m_pch + m_pcHeader.m_cch) < (m_pcHeader.m_pch + cbIOBuffer) ) ;
			return	TRUE ;
		}
		return	FALSE ;
	}

	DWORD	
	GetHeaderPosition(	char*	pchStartIOBuffer,
						DWORD	cbIOBuffer,	
						DWORD&	ibOffset
						) 	{
		//
		//	Only use this function if FHeadersInIOBuff() returns TRUE !
		//
		_ASSERT( FHeadersInIOBuff( pchStartIOBuffer, cbIOBuffer ) ) ;
		ibOffset = (DWORD)(m_pcHeader.m_pch - pchStartIOBuffer) ;
		return	m_pcHeader.m_cch + 2 ;
	}
	
	// get the length of the headers.  we add space for the \r\n
	DWORD GetHeaderLength(	) {
		return m_pcHeader.m_cch + 2;
	}

	// copy the headers into another buffer.  the buffer must be at least
	// GetHeaderLength characters long
	void CopyHeaders(char *pszDestination) {
		memmove(pszDestination, m_pcHeader.m_pch, m_pcHeader.m_cch);
		memmove(pszDestination + m_pcHeader.m_cch, "\r\n", 2);
	}

	// get the length of the headers.  no space for \r\n
	DWORD GetShortHeaderLength() { return m_pcHeader.m_cch; }

	char *GetHeaderPointer() {
		return m_pcHeader.m_pch;
	}

	//
	// protected Members
	//

protected :

	// The function that is actually used to add lines to
	// the article's header.
	BOOL fAddInternal(
			char * & pchCurrent,
			const char * pchMax,
			BOOL fInFile,
			CNntpReturn & nntpReturn
			);

	//
	//  the name of the article's file
	//

	LPSTR	m_szFilename ;

	//
	//  A handle to the article's file
	//

	HANDLE  m_hFile;

	//
	//	Offset to the body of the article within the file !
	//

	DWORD	m_ibBodyOffset ;

	//
	//  A pointer to a file mapping of the article
	//

	CMapFile * m_pMapFile;

	//
	//	If we have to allocate a buffer to hold a header which grows at some
	//	point we will set this pointer.
	//
	char*	m_pHeaderBuffer ;

	//
	//  a pointer-and-count string that points to the
	// whole article
	//

	CPCString m_pcFile;

	//
	//  a pointer-and-count string that points to the
	//	gap
	//

	CPCString m_pcGap;

	//
	//  a pointer-and-count string that points to the
	//	whole article
	//

	CPCString m_pcArticle;

	//
	// Fill the gap in the file with blanks (and other info).
	//

	void vGapFill(void);

	//
	//  build an array pointing to known header types
	//

	BOOL fPreParse(
			CNntpReturn & nntpReturn
			);

	//
	//  a pointer-and-count string that points to the
	//	header of the article
	//

	CPCString m_pcHeader;

	//
	//  a pointer-and-count string that points to the
	//	body of the article.
	//

	CPCString m_pcBody;

	//
	//  An array that points to the header fields
	//

	HEADERS_STRINGS m_rgHeaders[(unsigned int) uMaxFields];

	//
	//  The article reference for this article
	//

	CArticleRef m_articleRef;

	//
	// For dynamic memory allocation
	//

	CAllocator * m_pAllocator;

	//
	// the number of fields in the header.
	//

	DWORD m_cHeaders;

	
	//
	// Removed deleted entries from the array of headers.
	//

	void vCompressArray(void);

	//
	// Find the size of the gap by looking at the file.
	//

	void vGapRead(void);

	//
	// Remove a header line.
	//

	void vRemoveLine(
			HEADERS_STRINGS * phs
			);

	//
	// Remove all header lines that have no values.
	//

	BOOL fDeleteEmptyHeader(
			CNntpReturn & nntpReturn
			);

	//
	// Record the state of the article.
	//

	ARTICLE_STATE m_articleState;

	//
	// Add more information to the XOver data.
	//

	BOOL fXOverAppend(
			CPCString & pc,
			DWORD cchLast,
			const char * szKeyword,
			BOOL fRequired,
			BOOL fIncludeKeyword,
			CNntpReturn & nntpReturn
			);

	//
	// Add References information to the XOver data. Shorten the
	// data if necessary.
	//

	BOOL fXOverAppendReferences(
			CPCString & pc,
			DWORD cchLast,
			CNntpReturn & nntpReturn
			);
	//
	// Append a string to the XOver data.
	//

	BOOL fXOverAppendStr(
			CPCString & pc,
			DWORD cchLast,
			char * const sz,
			 CNntpReturn & nntpReturn
			 );

	//
	// Tells if the article should open the file with read/write mode.
	//

	virtual BOOL fReadWrite(void) { return FALSE ;}

	//
	// Check if the length of the article's body is not too long.
	//


	virtual BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn) { return TRUE; };

	//
	// Check the character following the ":" in a header.
	//

	virtual BOOL fCheckFieldFollowCharacter(
			char chCurrent) { return TRUE; }

	//
	// Run "FindAndParse" on a list of fields.
	//

	BOOL fFindAndParseList(
			CField * * rgPFields,
			DWORD cFields,
			CNntpReturn & nntpReturn
			);

	//
	// Run "ConfirmCaps" on a list of fields.
	//

	BOOL fConfirmCapsList(
			CField * * rgPFields,
			DWORD cFields,
			CNntpReturn & nntpReturn
			);

	BOOL ArtCloseHandle( HANDLE& );

	friend CField;
	friend CMessageIDField;
	friend CNewsgroupsField;

} ;

extern const unsigned cbMAX_ARTCORE_SIZE;

inline  void*
CArticleCore::operator  new(    size_t  size )
{
    _ASSERT( size <= cbMAX_ARTCORE_SIZE ) ;
    return  g_pArticlePool->Alloc() ;
}

inline  void
CArticleCore::operator  delete( void*   pv )
{
    g_pArticlePool->Free( pv ) ;
}

//
//
// Pure virtual base class for manipulating an article's Path field.

class CPathField : public CField {

public:
	// Constructor
	CPathField():
			m_multiSzPath(NULL),
			m_cPath((DWORD) -1),
			m_pAllocator(NULL),
			m_fChecked(FALSE)
			{};

	//
	//   Deconstructor
	//

	virtual ~CPathField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzPath);
				}
			};


	//
	// Returns the keyword of the field on which this CField works.
	//
	const char * szKeyword(void) {
			return szKwPath;
			};

	//
	//!!!constize
	//!!! is a null path OK?
	//!!!CLIENT NEXT
	//

	// Parse the Path value into its components.
	BOOL fParse(
				CArticleCore & article,
				CNntpReturn & nntpReturn
				)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fParseSplit(FALSE, m_multiSzPath, m_cPath, " \t\r\n!",
				article, nntpReturn);
			};

	// Return the path as a multsz list.
	const char * multiSzGet(void);

	// Set a new path by appending our hub to the old value.
	BOOL fSet(
			CPCString & pcHub,
			CArticleCore & article,
			CNntpReturn & nntpReturn
			);


	// Check for a loop by looking for our hub in the path (by not in the last location)
	BOOL fCheck(
			CPCString & pcHub,
			CNntpReturn & nntpReturn
			);

protected:

	// A pointer to the dynamic memory that contains the path as a multisz
	char * m_multiSzPath;

	// The number of components in the path.
	DWORD m_cPath;

	// Where to allocate from
	CAllocator * m_pAllocator;

	// True, if and only if, the path has been checked for a loop.
	BOOL m_fChecked;
};

//
// Some other functions
//

// Test a newsgroup name for legal values.
BOOL fTestComponents(
		const char * szNewsgroups
		);


// Tests the components of a newsgroup name (e.g. "alt", "ms-windows") for
// legal values.
BOOL fTestAComponent(
		const char * szComponent
		);

//
//  Largest possible CArticle derived object
//
#define MAX_ARTCORE_SIZE    sizeof( CArticleCore )
#define MAX_SESSIONS        15000
#define	MAX_ARTICLES	(2 * MAX_SESSIONS)

#define MAX_REFERENCES_FIELD 512
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\aqdll.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdll.h
//
//  Description:    Declarations for non-COM functionality exported in
//      aqueue.dll. This file is included by aqueue.h, so no one should
//      need to include this file directly.
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQDLL_H__
#define __AQDLL_H__

#define AQ_DLL_NAME "aqueue.dll"
#define AQ_INITIALIZE_FUNCTION_NAME "HrAdvQueueInitialize"
#define AQ_DEINITIALIZE_FUNCTION_NAME "HrAdvQueueDeinitialize"
#define AQ_INITIALIZE_FUNCTION_NAME_EX "HrAdvQueueInitializeEx"
#define AQ_DEINITIALIZE_FUNCTION_NAME_EX "HrAdvQueueDeinitializeEx"
typedef void (*PSRVUPDATEFN)(PVOID);
typedef HRESULT (*AQ_INITIALIZE_FUNCTION)(ISMTPServer *pISMTPServer, DWORD dwServerInstance, IAdvQueue **ppIAdvQueue, IConnectionManager **ppIConnectionManager, IAdvQueueConfig **ppIAdvQueueConfig, PVOID *ppvContext);
typedef HRESULT (*AQ_INITIALIZE_EX_FUNCTION)(ISMTPServer *pISMTPServer, DWORD dwServerInstance, LPSTR szUser, LPSTR szDomain, LPSTR szPassword, PSRVUPDATEFN pFn, PVOID pvSrvContext, IAdvQueue **ppIAdvQueue, IConnectionManager **ppIConnectionManager, IAdvQueueConfig **ppIAdvQueueConfig, PVOID *ppvContext);
typedef HRESULT (*AQ_DEINITIALIZE_FUNCTION)(PVOID pvContext);
typedef HRESULT (*AQ_DEINITIALIZE_EX_FUNCTION)(PVOID pvContext, PSRVUPDATEFN pFn, PVOID pvSrvContext);

HRESULT HrAdvQueueInitialize(
                    IN  ISMTPServer *pISMTPServer,
					IN	DWORD	dwServerInstance,
                    OUT IAdvQueue **ppIAdvQueue,
                    OUT IConnectionManager **ppIConnectionManager,
                    OUT IAdvQueueConfig **ppIAdvQueueConfig,
					OUT PVOID *ppvContext);

HRESULT HrAdvQueueDeinitialize(PVOID pvContext);

#endif //__AQDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\blockmgr.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

        blockmgr.h

Abstract:

        This module contains the definition of the block memory manager

Author:

        Keith Lau       (keithlau@microsoft.com)

Revision History:

        keithlau        02/27/98        created

--*/

#ifndef __BLOCKMGR_H__
#define __BLOCKMGR_H__

#include "rwnew.h"

#include "cpoolmac.h"
#include "mailmsg.h"

//
// Nasty forwards for these interfaces ...
//
struct IMailMsgPropertyStream;
struct IMailMsgNotify;

/***************************************************************************/
// Define this to remove contention control
//
// #define BLOCKMGR_DISABLE_ATOMIC_FUNCS
// #define BLOCKMGR_DISABLE_CONTENTION_CONTROL
//
#ifdef BLOCKMGR_DISABLE_CONTENTION_CONTROL
#define BLOCKMGR_DISABLE_ATOMIC_FUNCS
#endif

/***************************************************************************/
// Debug stuff ...
//

#ifdef DEBUG

#define DEBUG_TRACK_ALLOCATION_BOUNDARIES

#endif

/***************************************************************************/
// CBlockManager - Implementation of pseudo flat memory space using a
//    heap that works like an I-Node. The underlying memory utilizes
//    disjoint, fixed-size memory blocks.
//
// Each node is as follows:
//
// +---------------------------------------------------------+
// | Pointers to other nodes | Space for arbitrary data      |
// +---------------------------------------------------------+
//
// Analysis:
// We assume in some way or another memory allocation is based on
// 4K pages or some multiple thereof. The first thing we want to
// determine is how many pointers to other nodes we want to have in
// the node (order of the heap). We know that each node would probably
// be some size between 1K to 2K so that we won't waste space in the
// average case of small email messages, yet provide scalability for
// huge email messages that potentially may have millions of email
// addresses. 2 intuitive candidates are 32 and 64 pointers.
//
// We consider the worst case scenario of MSN, which has about 2.5
// million users. Assuming the averace recipient record is about
// 45 bytes (name & attributes, etc.), then we need 112.5M of
// storage, which is about 2 ^ 27. Assume the average data payload
// is 1K per node (2 ^ 10), then we need 2 ^ 17 nodes. Thus, for
// 23 pointers (2 ^ 5) per node, we need 4 layers to cover the
// required address space of 112M. However, this turns out to be
// an overkill since 4 layers covers 1G (2 ^ 20) where we only need
// about 10% of that. As for the 64 pointers case, we only need 3
// layers to cover 256M (2 ^ (18 + 10)), which roughly covers 5
// million users. We will choose 64 pointer per node (256 bytes).
//
// As for the size of the payload, I considered using 1K allocations
// and using the remaining 768 bytes as data payload. But since this
// is not a round power of two, it would be expensive to do a
// div and mod operation. As an alternative, I suggest allocating
// 1024 + 256 byte blocks. This makes both numbers round powers of
// two, which makes div and mod operations simple AND and SHR
// operations, which typically take 2-4 cycles to complete. Also,
// when the wasted space is considered, turns out that a 4K page
// fits 3 such blocks, and only 256 bytes is wasted per page. This
// comes to 93.3% utilization of space.
//
// So each node would look like this:
// +---------------------------------------------------------+
// | 64 pointers = 256 bytes | 1K block for arbitrary data   |
// +---------------------------------------------------------+
//
// It is an explicit objective that a typical mail message header
// fits in a single block. Each block fans out to 64 other blocks
// and each block's payload maps to 1K of the flat data address
// space. The root node maps to the first 1K of the data space
// (i.e. absolute address 0 to 1023 in data space), then each
// of the next 64 nodes in the next layer represents the next 64K,
// respectively, and so on for each subsequent layer. Nodes for
// the next layer is not created until the current layer is
// depleted. Collpasing of nodes is not required due to the fact
// that the heap can only grow.
//
// During commit of the whole heap, the scatter-gather list is
// built by traversing the entire heap. The average number of
// dereferences is n*(log64(n))/2).
//
// All items in a message object is allocated off this heap.
//
// An slight modification can be used to track dirty or unused
// bits. We can actually add a block of flags and attributes to
// each node to track dirty regions and other flags. This will
// probably not be implemented in the initial implementation,
// but such capability will be factored in. In terms of allocation
// optimization, we can have a block of up to 64 bytes without
// disrupting the 4K page allocation scheme. In fact, adding a
// 64-byte block to each node boosts memory utilization to up
// to 98.4% without any real extra cost while still keeping each
// node 64-byte aligned.
//
// Synchronization:
// Allocation of memory in the data space is done through a
// reservation model where multiple threads can concurrently
// reserve memory and be guaranteed to get a unique block.
// A lightweight critical section is used to synchronize block
// creation should the reservation span into blocks that are
// not yet allocated. Allocation of new blocks is serialized.
//
// Synchronization for concurrent access to the same data space
// must be enforced at a higher level, if desired.
//

// Define the constants chosen for this implementation

#ifdef _WIN64
// The order will be 5 bits in 64-bit (8 * 32 = 256 bytes)
#define BLOCK_HEAP_ORDER_BITS		(5)
#else
// The order will be 6 bits in 32-bit (4 * 64 = 256 bytes)
#define BLOCK_HEAP_ORDER_BITS		(6)
#endif

#define BLOCK_HEAP_ORDER			(1 << BLOCK_HEAP_ORDER_BITS)
#define BLOCK_HEAP_ORDER_MASK		(BLOCK_HEAP_ORDER - 1)
#define BLOCK_HEAP_PAYLOAD_BITS		(10)
#define BLOCK_HEAP_PAYLOAD			(1 << BLOCK_HEAP_PAYLOAD_BITS)
#define BLOCK_HEAP_PAYLOAD_MASK		(BLOCK_HEAP_PAYLOAD - 1)
#define BLOCK_DWORD_ALIGN_MASK		(sizeof(DWORD) - 1)

#define BLOCK_DEFAULT_FLAGS			(BLOCK_IS_DIRTY)

#define BLOCK_MAX_ALLOWED_LINEAR_HOPS 3

// Define the underlying data type for a flat address in the
// linear address space, and the type that we use to count nodes.
// This is for scalability so when we want to use 64-bit
// quantities, we can simply replace this section of data-size
// specific values
//
// Note: you need to make sure that the data size is AT LEAST:
// 1 + (BLOCK_HEAP_ORDER_BITS * MAX_HEAP_DEPTH) + BLOCK_HEAP_PAYLOAD_BITS
//
// Note: In order for this type to be used as the base address
// type, the following operations must be supported:
// - Assignment
// - Comparison
// - Arithmetic operators
// - Bitwise operators
// - Interlocked operations
//
// Start data-size-specific values

	typedef SIZE_T					HEAP_BASE_ADDRESS_TYPE;
	typedef HEAP_BASE_ADDRESS_TYPE		HEAP_NODE_ID;
	typedef HEAP_NODE_ID				*LPHEAP_NODE_ID;
	typedef HEAP_BASE_ADDRESS_TYPE		FLAT_ADDRESS;
	typedef FLAT_ADDRESS				*LPFLAT_ADDRESS;

	// These must be changed if HEAP_BASE_ADDRESS_TYPE is not DWORD
	#define NODE_ID_MAPPING_FACTOR		\
			(HEAP_BASE_ADDRESS_TYPE)(	\
				 1 |					\
				(1 << BLOCK_HEAP_ORDER_BITS) |		\
				(1 << (BLOCK_HEAP_ORDER_BITS * 2))	\
				)
	//	And so on, etc ...
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 3))
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 4))

	#define NODE_ID_ABSOLUTE_MAX		\
			(HEAP_BASE_ADDRESS_TYPE)(	\
				(1 << BLOCK_HEAP_ORDER_BITS) |		\
				(1 << (BLOCK_HEAP_ORDER_BITS * 2)) |\
				(1 << (BLOCK_HEAP_ORDER_BITS * 3))	\
				)
	//	And so on, etc ...
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 4))
	//			(1 << (BLOCK_HEAP_ORDER_BITS * 5))

	#define NODE_ID_BORROW_BIT			\
			(HEAP_BASE_ADDRESS_TYPE)(1 << (BLOCK_HEAP_ORDER_BITS * 3))

	// Depth of heap allowed by base data type
	#define MAX_HEAP_DEPTH				4

	// Node Id space mask
	#define MAX_FLAT_ADDRESS			\
				(FLAT_ADDRESS)((1 << (MAX_HEAP_DEPTH * BLOCK_HEAP_ORDER_BITS)) - 1)

	// Same as a NULL pointer
	#define INVALID_FLAT_ADDRESS		((FLAT_ADDRESS)-1)

	// Number of bits to rotate the mapped result
	#define NODE_ID_ROR_FACTOR			((MAX_HEAP_DEPTH - 1) * BLOCK_HEAP_ORDER_BITS)

	// Define the rotate functions
	#define ROTATE_LEFT(v, n)			_lrotl((v), (n))
	#define ROTATE_RIGHT(v, n)			_lrotr((v), (n))

	// Define the interlocked functions
	#define AtomicAdd(pv, a)			\
				(HEAP_BASE_ADDRESS_TYPE)InterlockedExchangeAdd((long *)(pv), (a))

// End data-size-specific values

// Forward declaration of the _BLOCK_HEAP_NODE structure
struct _BLOCK_HEAP_NODE;

// Define the attribute block for each node
typedef struct _BLOCK_HEAP_NODE_ATTRIBUTES
{
	struct _BLOCK_HEAP_NODE	*pParentNode;	// Pointer to parent node
	HEAP_NODE_ID			idChildNode;	// Which child am I?
	HEAP_NODE_ID			idNode;			// Id of node in block heap
	FLAT_ADDRESS			faOffset;		// Starting offset the node
	DWORD					fFlags;			// Attributes of the block

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES
	// This tracks the allocation boundaries between memory
	// allocations so that we can check whether a read or write
	// crosses an allocation boundary. We use a bit to represent
	// the start of a block. Since the allocations are DWORD-aligned,
	// we need BLOCK_HEAP_PAYLOAD >> 2 >> 3 bits to track
	// all allocation boundaries per block.
	BYTE					rgbBoundaries[BLOCK_HEAP_PAYLOAD >> 5];
#endif

} BLOCK_HEAP_NODE_ATTRIBUTES, *LPBLOCK_HEAP_NODE_ATTRIBUTES;

// Define each node in the heap
typedef struct _BLOCK_HEAP_NODE
{
	struct _BLOCK_HEAP_NODE		*rgpChildren[BLOCK_HEAP_ORDER];
	BLOCK_HEAP_NODE_ATTRIBUTES	stAttributes;
	BYTE						rgbData[BLOCK_HEAP_PAYLOAD];

} BLOCK_HEAP_NODE, *LPBLOCK_HEAP_NODE;

#define BLOCK_HEAP_NODE_SIZE	(sizeof(BLOCK_HEAP_NODE))

#define BOP_LOCK_ACQUIRED			0x80000000
#define BOP_NO_BOUNDARY_CHECK		0x40000000
#define BOP_OPERATION_MASK			0x0000ffff

typedef enum _BLOCK_OPERATION_CODES
{
	BOP_READ = 0,
	BOP_WRITE

} BLOCK_OPERATION_CODES;

// Define the block attribute flags
#define BLOCK_IS_DIRTY				0x00000001
#define BLOCK_PENDING_COMMIT		0x00000002

// block allocation flags
// the block was allocated with CMemoryAccess instead of cpool
#define BLOCK_NOT_CPOOLED           0x00010000

#define BLOCK_CLEAN_MASK			(~(BLOCK_IS_DIRTY))
#define RESET_BLOCK_FLAGS(_flags_) _flags_ &= 0xffff0000
#define DEFAULT_BLOCK_FLAGS(_flags_) _flags_ &= (0xffff0000 | BLOCK_IS_DIRTY)

//
// Define a method signature for acquiring a stream pointer
//
typedef IMailMsgPropertyStream	*(*PFN_STREAM_ACCESSOR)(LPVOID);

/***************************************************************************/
// Context class for memory access
//

class CBlockContext
{
  private:

	DWORD				m_dwSignature;

  public:

	CBlockContext() { Invalidate(); }
	~CBlockContext() { Invalidate(); }

	BOOL IsValid();

	void Set(
				LPBLOCK_HEAP_NODE	pLastAccessedNode,
				FLAT_ADDRESS		faLastAccessedNodeOffset
				);

	void Invalidate();

	LPBLOCK_HEAP_NODE	m_pLastAccessedNode;
	FLAT_ADDRESS		m_faLastAccessedNodeOffset;
};


/***************************************************************************/
// Memory allocator classes
//

class CBlockMemoryAccess
{
  public:

	CBlockMemoryAccess() {}
	~CBlockMemoryAccess() {}

	HRESULT AllocBlock(
				LPVOID	*ppvBlock,
				DWORD	dwBlockSize
				);

	HRESULT FreeBlock(
				LPVOID	pvBlock
				);

	//
	// CPool
	//
	static CPool m_Pool;
};


class CMemoryAccess
{
  public:

	CMemoryAccess() {}
	~CMemoryAccess() {}

	static HRESULT AllocBlock(
				LPVOID	*ppvBlock,
				DWORD	dwBlockSize
				);

	static HRESULT FreeBlock(
				LPVOID	pvBlock
				);
};

/***************************************************************************/
// Class for accessing stream
//

class CBlockManagerGetStream
{
  public:
	virtual HRESULT GetStream(
				IMailMsgPropertyStream	**ppStream,
				BOOL					fLockAcquired
				) = 0;
};


/***************************************************************************/
// Block heap manager
//

class CBlockManager
{
  public:
	CBlockManager(
				IMailMsgProperties *pMsg,
				CBlockManagerGetStream	*pParent = NULL
				);
	~CBlockManager();

	// Sanity check
	BOOL IsValid();

	// This initializes an empty MailMsg to a certain size.
	// CAUTION: This should only be used to initialize an empty MailMsg
	// when binding to a non-empty stream. Any other uses will cause
	// unpredictable results and/or corruption or even crashes.
	HRESULT SetStreamSize(
				DWORD	dwStreamSize
				);

	//
	// Synopsis:
	// Allocate the desired amount of memory.
	// Thread safe.
	//
	// Arguments:
	// dwSizeDesired - the size of the block desired
	// pfaOffsetToReservedMemory - returns the offset to the
	//      reserved block of memory, if successful, in the
	//      flat memory space managed by the block manager.
	// pdwSizeAllocated - returns the actual size allocated, which
	//		is greater than or equal to the desired size, if successful.
	// pContext (Optional) - fills in a context that describes
	//      the reserved block. This context can be used in
	//      subsequent reads and writes to the block. Accesses
	//      using this context are faster than using the
	//      offset alone. Ignored if NULL. The caller must allocate
	//      the context structure prior to calling ReserveMemory.
	//
	// Return values:
	// S_OK - Success, the memory of requested size is
	//      successfully reserved.
	// STG_E_INSUFFICIENTMEMORY - Error, the required amount of memory
	//      is not available to honor the request.
	// STG_E_INVALIDPARAMETER - Internal error, mostly used
	//      for debug considerations.
	//
	HRESULT AllocateMemory(
				DWORD				dwSizeDesired,
				FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
				DWORD				*pdwSizeAllocated,
				CBlockContext		*pContext	// Optional
				);

	//
	// Synopsis:
	// Returns the total size allocated by this block manager.
	// Thread safe.
	//
	// Arguments:
	// pfaSizeAllocated - returns the total size allocated.
	//
	// Return values:
	// S_OK - Success, the memory of requested size is
	//      successfully reserved.
	// STG_E_INVALIDPARAMETER - Internal error, mostly used
	//      for debug considerations.
	//
	HRESULT GetAllocatedSize(
				FLAT_ADDRESS	*pfaSizeAllocated
				);

	//
	// Synopsis:
	// Reads a chunk of contiguous memory in flat address space into a
	// user-supplied buffer. Synchronization not supported at this level.
	//
	// Arguments:
	// pbBuffer - buffer to return contents read, must be large enough
	//      to store the data read.
	// faTargetOffset - offset measured in flat address space to start
	//      reading from.
	// dwBytesToRead - number of contiguous bytes to read
	// pdwBytesRead - returns number of bytes actually read
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the read is successful.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_READFAULT - Error, The read failed to complete, pdwBytesRead
	//      reflects the actual number of bytes read into pbBuffer.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a read is issued to read past
	//      the current allocated block.
	//
	HRESULT ReadMemory(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faTargetOffset,
				DWORD			dwBytesToRead,
				DWORD			*pdwBytesRead,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Writes a chunk of contiguous memory from a specified buffer into
	// a specified offset in the flat address space. Synchronization not
	// supported at this level.
	//
	// Arguments:
	// pbBuffer - source buffer of bytes to be written
	// faTargetOffset - offset measured in flat address space to start
	//      writing to.
	// dwBytesToWrite - number of contiguous bytes to write
	// pdwBytesWritten - returns number of bytes actually written
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the read is successful.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_WRITEFAULT - Error, The read failed to complete, pdwBytesRead
	//      reflects the actual number of bytes read into pbBuffer.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//      the current allocated block.
	//
	HRESULT WriteMemory(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faTargetOffset,
				DWORD			dwBytesToWrite,
				DWORD			*pdwBytesWritten,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Copies a chunk of contiguous memory of a specified size from a specified
	// starting offset into the same starting offset of the target address space
	// managed by the target block manager. Synchronization is not supported at this
	// level.
	//
	// Note that a copy is special in that it can cross allocation boundaries.
	//
	// Arguments:
	// faOffset - offset measured in flat address space to start copying.
	// dwBytesToCopy - number of contiguous bytes to copy.
	// pTargetBlockManager - Target block manager whose address space to
	//		copy into.
	//
	// Return values:
	// S_OK - Success, the copy is successful.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_READFAULT - Error, a read failed to complete, the copy is not
	//		comleted.
	// STG_E_WRITEFAULT - Error, a write failed to complete, the copy is not
	//		comleted.
	//
	HRESULT CopyTo(
				FLAT_ADDRESS	faOffset,
				DWORD			dwBytesToCopy,
				CBlockManager	*pTargetBlockManager,
				BOOL			fLockAcquired = FALSE
				);

	//
	// Synopsis:
	// Atomically reads the length and size of a data block, and loads the
	// data block from the offset of the size specified.
	//
	// Arguments:
	// pbBuffer - target buffer of bytes to write the read data
	// pdwBufferSize - Contains the length of the supplied buffer going in,
	//      and returns the length of data actually read.
	// pbInfoStruct - Structure containing the information structure
	// faOffsetToInfoStruct - Offset to the info structure
	// dwSizeOfInfoStruct - Size of the info struct to load
	// dwOffsetInInfoStructToOffset - Offset to the address of the data block.
	//      this is measured w.r.t. the info structure
	// dwOffsetInInfoStructToOffset - Offset to the size of the data block.
	//      this is measured w.r.t. the info structure
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the read is successful.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) - Error/Informational,
	//      the supplied buffer is not large enough to hold all the data.
	//      *pdwBufferSize returns the actual number of bytes read.
	// STG_E_READFAULT - Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a read is issued to read past
	//      the current allocated block.
	//
	HRESULT AtomicDereferenceAndRead(
				LPBYTE			pbBuffer,
				DWORD			*pdwBufferSize,
				LPBYTE			pbInfoStruct,
				FLAT_ADDRESS	faOffsetToInfoStruct,
				DWORD			dwSizeOfInfoStruct,
				DWORD			dwOffsetInInfoStructToOffset,
				DWORD			dwOffsetInInfoStructToSize,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Atomically writes the contents of a buffer to memory in flat space and
	// increments a DWORD value by a specified amount. The write is attempted
	// first, and if it succeeds, the value is incremented. If the write fails
	// for some reason, the value will not be incremented. This is to ensure that
	// all the data is written before the increment so the data "exists" by the
	// time the counter is updated.
	//
	// Arguments:
	// pbBuffer - source buffer of bytes to be written
	// faOffset - offset measured in flat address space to start
	//      writing to.
	// dwBytesToWrite - number of contiguous bytes to write
	// pdwValueToIncrement - Pointer to the value to be atomically incremented
	//      after the write successfully written. If this value is NULL, the
	//      increment is ignored and only a protected write is performed.
	// dwReferenceValue - If the value in pdwValueToIncrement differs from this
	//      value, the call will be aborted.
	// dwIncrementValue - Amount to increment pdwValueToIncrement.
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the write is successful.
	// HRESULT_FROM_WIN32(ERROR_RETRY) - Informational, The reference value
	//      changed during processing and the call cannot complete. A retry
	//      should be performed immediately.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_WRITEFAULT - Error, The write failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//      the current allocated block.
	//
	HRESULT AtomicWriteAndIncrement(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faOffset,
				DWORD			dwBytesToWrite,
				DWORD			*pdwValueToIncrement,
				DWORD			dwReferenceValue,
				DWORD			dwIncrementValue,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Atomically allocates memory, writes the contents of a buffer to memory
	// in flat space and increments a DWORD value by a specified amount. The
	// allocation is preceeded by a synchronization object and the allocation
	// takes place only if the value of the value to increment is identical before
	// and after the synchronization object is acquired. This allows multiple threads
	// to call this function for the same base object and only one such allocation
	// will succeed. The user can specify a buffer containing content data that will
	// be copied to the allocated buffer should the allocation succeed.
	// There can be 3 outcomes from the allocation:
	// 1) Allocation succeeded
	// 2) Allocation failed due to memory system problems
	// 3) Allocation was not done because the increment value changed during the
	//    acquisition of the synchronization object.
	//
	// If the allocation failed due to memory problems, this function will fail without
	// performing the rest of the duties. For scenario 1, the function will
	// continue. For scenario 3, the function will return a specific error code
	// indicating that it had been beaten and the caller will have to do something else
	//
	// After the allocation phase, the write is attempted first, and if it succeeds,
	// the value is incremented. If the write fails for some reason, the value will
	// not be incremented. This is to ensure that all the data is written before the
	// increment so the data "exists" by the time the counter is updated. On the
	// event of a write failure, the memory cannot be salvaged.
	//
	// Arguments:
	// dwDesiredSize - Size of memory block to allocate
	// pfaOffsetToAllocatedMemory - returns the starting offset to the
	//      allocated block, in flat address space
	// faOffsetToWriteOffsetToAllocatedMemory - Specifies a location in
	//      which to store the offset of the allocated block
	// faOffsetToWriteSizeOfAllocatedMemory - Specifies a location in
	//      which to store the actual size of the allocated block
	// pbInitialValueForAllocatedMemory - Specifies a buffer that contains
	//      the initial value for the allocated block. This will be copied
	//      to the allocated block if the allocation succeeds.
	// pbBufferToWriteFrom - source buffer of bytes to be written
	// dwOffsetInAllocatedMemoryToWriteTo - offset from the start of the
	// allocated block to start writing to.
	// dwSizeofBuffer - number of contiguous bytes to write
	// pdwValueToIncrement - Pointer to the value to be atomically incremented
	//      after the write successfully written. This value MUST NOT be NULL.
	// dwReferenceValue - If the value in pdwValueToIncrement differs from this
	//      value, the call will be aborted.
	// dwIncrementValue - Amount to increment pdwValueToIncrement.
	// pContext (Optional) - if specified, uses an alternate optimized
	//      algorithm to access the memory, otherwise, the system looks
	//      up the node in question using a full lookup, which is slower.
	//      The system decides which algorithm to use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, the write is successful.
	// HRESULT_FROM_WIN32(ERROR_RETRY) - Informational, The reference value
	//      changed during processing and the call cannot complete. A retry
	//      should be performed immediately.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// STG_E_WRITEFAULT - Error, The write failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//      the current allocated block.
	//
	HRESULT AtomicAllocWriteAndIncrement(
				DWORD			dwDesiredSize,
				FLAT_ADDRESS	*pfaOffsetToAllocatedMemory,
				FLAT_ADDRESS	faOffsetToWriteOffsetToAllocatedMemory,
				FLAT_ADDRESS	faOffsetToWriteSizeOfAllocatedMemory,
				LPBYTE			pbInitialValueForAllocatedMemory,
				DWORD			dwSizeOfInitialValue,
				LPBYTE			pbBufferToWriteFrom,
				DWORD			dwOffsetInAllocatedMemoryToWriteTo,
				DWORD			dwSizeofBuffer,
				DWORD			*pdwValueToIncrement,
				DWORD			dwReferenceValue,
				DWORD			dwIncrementValue,
				CBlockContext	*pContext	// Optional
				);

	//
	// Synopsis:
	// Traverses the list of allocated blocks, from the specified address, and
	// finds dirty blocks. For each dirty block encountered, the block will be
	// changed from "DIRTY" to "PENDING COMMIT". The flat address offset, block
	// size, and memory pointer to that block will be stored in the pdwOffset,
	// pdwSize, and ppbData arrays, respectively. An optional faLengthToScan
	// specifies the number of bytes from the starting offset to scan for
	// dirty blocks, if this is INVALID_FLAT_ADDRESS, then this function scans
	// to the end of all allocated blocks. It is not an error if there are
	// less allocated bytes than the length specified, only the allocated blocks
	// are scanned.
	//
	// The number of elements in each of these arrays is specified therough
	// pdwCount, which returns the number of dirty pages returned.
	//
	// When this function is first called, a strat address should be specified
	// (e.g. 0). When the function returns, pContext will be filled with the
	// next block to start traversing the next time this function is called.
	// Subsequent calls should pass in INVALID_FLAT_ADDRESS for start address
	// and use the pContext previously returned.
	//
	// Arguments:
	// faStartingOffset - Starting offset to start scanning for dirty blocks
	// dwLengthToScan - Length of memory from start to scan for dirty blocks
	// pdwCount - Specifies the number of entries allocated for each of the
	//		offset, size and pointer arrays. Returns the number of dirty
	//		pages actually found.
	// pdwOffset - Array to hold the offsets of pages
	// pdwSize - Array to hold the sizes of pages
	// ppbData - Array to hold the memory pointer to each page
	// pContext - Causes an alternate optimized algorithm to be used to access
	//		the memory, otherwise, the system looks up the node in question using
	//		a full lookup, which is slower. The system decides which algorithm to
	//		use based on some heuristics.
	//
	// Return values:
	// S_OK - Success, one or more dirty blocks are returned.
	// HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) - Informational, no more dirty
	//		blocks are found from the starting address to the end of the list.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	//
	HRESULT BuildDirtyBlockList(
				FLAT_ADDRESS	faStartingOffset,
				FLAT_ADDRESS	faLengthToScan,
				DWORD			*pdwCount,
				FLAT_ADDRESS	*pfaOffset,
				DWORD			*pdwSize,
				LPBYTE			*ppbData,
				CBlockContext	*pContext
				);

	//
	// Synopsis:
	// Walks the list of allocated blocks ans changes all blocks whose state
	// is "PENDING COMMIT" to "CLEAN" or "DIRTY".
	//
	// In the debug version, any block that is both "DIRTY" and "PENDING COMMIT"
	// is invalid and results in an ASSERT.
	//
	// Arguments:
	// fClean	- TRUE to mark the blocks as "CLEAN", FALSE for "DIRTY"
	//
	// Return values:
	// S_OK - Success.
	//
	HRESULT MarkAllPendingBlocks(
				BOOL	fClean
				);

	//
	// Synopsis:
	// Sets the state of a specified block to the specified state.
	//
	// In the debug version, any block that is both "DIRTY" and "PENDING COMMIT"
	// is invalid and results in an ASSERT.
	//
	// Arguments:
	// pbData - block as specified by its data pointer
	// fClean	- TRUE to mark the blocks as "CLEAN", FALSE for "DIRTY"
	//
	// Return values:
	// S_OK - Success.
	//
	HRESULT MarkBlockAs(
				LPBYTE			pbData,
				BOOL			fClean
				);

	//
	// Synopsis:
	// Traverses the list of allocated blocks, from the specified address, and
	// finds dirty blocks. For each dirty block encountered, the block will be
	// changed from "DIRTY" to "PENDING COMMIT" and the block will marked for
	// commit. When enough of these blocks are encountered, they will be
	// committed in a batch and the committed blocks will be marked as "CLEAN".
	// The process will iterate until no more dirty blocks. An optional faLengthToScan
	// specifies the number of bytes from the starting offset to scan for
	// dirty blocks, if this is INVALID_FLAT_ADDRESS, then this function scans
	// to the end of all allocated blocks. It is not an error if there are
	// less allocated bytes than the length specified, only the allocated blocks
	// are scanned.
	//
	// Arguments:
	// faStartingOffset - Starting offset to start scanning for dirty blocks
	// dwLengthToScan - Length of memory from start to scan for dirty blocks
	// pStream - specifies the IMailMsgPropertyStore to use to commit the blocks.
	// fComputeBlockCountsOnly - don't make calls to WriteBlocks, just
	//    compute counters for what would be sent to WriteBlocks.
	// pcBlocksToWrite - incremented by how many blocks we would write
	// pcTotalBytesToWrite - incremented by the total byte count of what we
	//    would write
	//
	// Return values:
	// S_OK - Success, one or more dirty blocks are returned.
	// STG_E_INVALIDPARAMETER - Error, one or more parameters are invalid, or
	//      otherwise inconsistent.
	// Plus the error codomain of IMailMsgPropertyStream
	//
	HRESULT CommitDirtyBlocks(
				FLAT_ADDRESS			faStartingOffset,
				FLAT_ADDRESS			faLengthToScan,
				DWORD					dwFlags,
				IMailMsgPropertyStream	*pStream,
				BOOL					fDontMarkAsCommit,
				BOOL					fComputeBlockCountsOnly,
				DWORD					*pcBlocksToWrite,
				DWORD					*pcTotalBytesToWrite,
				IMailMsgNotify			*pNotify
				);

	//
	// Synopsis:
	// Releases the entire list of nodes managed by this object.
	//
	// Arguments:
	// None.
	//
	// Return values:
	// S_OK - Success.
	//
	HRESULT Release();

	//
	// Synopsis:
	// Exposes the lock in the block manager, attempts to access the internal lock
	//
	// Arguments:
	// None.
	//
	// Remarks:
	// These locks will cause deadlocks if a thread tries to acquire it twice.
	// In debug builds, there will be some sort of deadlock detection, in
	// retail, you will deadlock.
	//
	// Return values:
	// S_OK - Success, the lock operation succeeded.
	// !(SUCCESS(HRESULT)) - An error occurred and the lock operaiton failed.
	//
	HRESULT ReadLock() { m_rwLock.ShareLock(); return(S_OK); }
	HRESULT ReadUnlock() { m_rwLock.ShareUnlock(); return(S_OK); }
	HRESULT WriteLock() { m_rwLock.ExclusiveLock(); return(S_OK); }
	HRESULT WriteUnlock() { m_rwLock.ExclusiveUnlock(); return(S_OK); }

	// return the state of the dirty flag
	BOOL IsDirty() { return m_fDirty; }

	// change the value of the dirty flag.  this is used by MailMsg to
	// set it to FALSE when a successful Commit has occured.
	void SetDirty(BOOL fDirty) {
        m_fDirty = fDirty;
#ifdef DEBUG
//        _ASSERT(!(m_fCommitting && m_fDirty));
#endif
    }
    void SetCommitMode(BOOL fCommitting) {
#ifdef DEBUG
        m_fCommitting = fCommitting;
#endif
    }

  private:

	// GetNodeIdFromOffset() defined as a macro in the source

	// Method to load a block from the stream if required
	/*
	HRESULT ConnectLeftSibling(
				LPBLOCK_HEAP_NODE	pNode,
				LPBLOCK_HEAP_NODE	pParent,
				DWORD				dwChildId
				);

	HRESULT ConnectRightSibling(
				LPBLOCK_HEAP_NODE	pNode,
				LPBLOCK_HEAP_NODE	pParent,
				DWORD				dwChildId
				);
	*/

	HRESULT GetStream(
				IMailMsgPropertyStream	**ppStream,
				BOOL					fLockAcquired
				);

	HRESULT MoveToNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				HEAP_NODE_ID		idTargetNode,
				BOOL				fLockAcquired
				);

	HRESULT GetNextNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				);

	HRESULT LoadBlockIfUnavailable(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	pParent,
				HEAP_NODE_ID		idChildNode,
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				);

	HRESULT GetEdgeListFromNodeId(
				HEAP_NODE_ID		idNode,
				HEAP_NODE_ID		*rgEdgeList,
				DWORD				*pdwEdgeCount
				);

	HRESULT GetNodeFromNodeId(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired = FALSE
				);

	HRESULT GetParentNodeFromNodeId(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	*ppNode
				);

	HRESULT GetPointerFromOffset(
				FLAT_ADDRESS		faOffset,
				LPBYTE				*ppbPointer,
				DWORD				*pdwRemainingSize,
				LPBLOCK_HEAP_NODE	*ppNode
				);

	HRESULT InsertNodeGivenPreviousNode(
				LPBLOCK_HEAP_NODE	pNodeToInsert,
				LPBLOCK_HEAP_NODE	pPreviousNode
				);

	BOOL IsMemoryAllocated(
				FLAT_ADDRESS		faOffset,
				DWORD				dwLength
				);

	HRESULT AllocateMemoryEx(
				BOOL				fAcquireLock,
				DWORD				dwSizeDesired,
				FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
				DWORD				*pdwSizeAllocated,
				CBlockContext		*pContext	// Optional
				);

	HRESULT WriteAndIncrement(
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faOffset,
				DWORD			dwBytesToWrite,
				DWORD			*pdwValueToIncrement,
				DWORD			dwIncrementValue,
				CBlockContext	*pContext	// Optional
				);

	HRESULT OperateOnMemory(
				DWORD			dwOperation,
				LPBYTE			pbBuffer,
				FLAT_ADDRESS	faTargetOffset,
				DWORD			dwBytesToDo,
				DWORD			*pdwBytesDone,
				CBlockContext	*pContext	// Optional
				);

	HRESULT ReleaseNode(
				LPBLOCK_HEAP_NODE	pNode
				);

	DWORD					m_dwSignature;

	// This value indicates the current end of data. This is
	// always changed with interlocked operations such that
	// multiple threads can increment this variable and the
	// increments are properly serialized
	FLAT_ADDRESS			m_faEndOfData;

	HEAP_NODE_ID			m_idNodeCount;
	LPBLOCK_HEAP_NODE		m_pRootNode;

	CBlockManagerGetStream	*m_pParent;

	CBlockMemoryAccess		m_bma;

#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	CShareLockNH			m_rwLock;
#endif

	IMailMsgProperties		*m_pMsg;

	BOOL					m_fDirty;
#ifdef DEBUG
    BOOL                    m_fCommitting;
#endif

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cache2.h ===
/*++

	Cache2.h

	This header file defines an LRU0 cache template that
	can be used to hold arbitrary objects !

	Items in the Cache must have the following format :

	class	DataItem	{
		ICacheRefInterface*		m_pCacheRefInterface ;
	} ;

    class   Constructor {
        DATA*
        Create( KEY&, PERCACHEDATA& )
        void
        Release( DATA*, PERCACHEDATA* )
        void
        StaticRelease( DATA*, PERCACHEDATA* )
    }

--*/


#ifndef	_CACHE2_H_
#define	_CACHE2_H_

#include	"randfail.h"

#include	"fdlhash.h"
#include	"lockq.h"
#include	"tfdlist.h"
#include	"rwnew.h"
#include	"refptr2.h"

typedef	CShareLockNH	CACHELOCK ;


class	CAllocatorCache	{
/*++

Class Description :

	This class provides a Memory Allocation cache - we work with
	an operator new provide below.   We exist to provide some
	optimizations for allocations of the elements of the caches
	specified in this module.

NOTE :

	We assume the caller provides all locking !

--*/
private :
	//
	//	The structurure we use to keep our free list !
	//
	struct	FreeSpace	{
		struct	FreeSpace*	m_pNext ;
	} ;

	//
	//	Size of each element - clients must not ask for something bigger !
	//
	DWORD	m_cbSize ;
	//
	//	Number of elements in our list at this moment !
	//
	DWORD	m_cElements ;
	//
	//	The maximum number of elements we should hold !
	//
	DWORD	m_cMaxElements ;
	//
	//	Top of the stack !
	//
	struct	FreeSpace*	m_pHead ;

	//	
	//	Make the following private - nobody is allowed to use these !
	//
	CAllocatorCache( CAllocatorCache& ) ;
	CAllocatorCache&	operator=( CAllocatorCache& ) ;

public :

	//
	//	Initialize the Allocation Cache !
	//
	CAllocatorCache(	DWORD	cbSize,
						DWORD	cMaxElements = 512
						) ;

	//
	//	Destroy the Allocation Cache - release extra memory back to system !
	//
	~CAllocatorCache() ;

	//
	//	Allocate a block of memory
	//	returns NULL if Out of Memory !
	//
	void*
	Allocate(	size_t	cb ) ;

	//
	//	Return some memory back to the system heap !
	//
	void
	Free(	void*	pv ) ;
} ;





class	ICacheRefInterface : public CQElement	{
/*++

Class	Description :

	This class defines the interface for Cache References -
	the mechanism that allows multiple caches to reference
	a single data item.

--*/
protected :

	//
	//	Add an item to the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	AddCacheReference( class	ICacheRefInterface*,	void*	pv, BOOL	) = 0 ;

	//
	//	Remove an item from the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	RemoveCacheReference(	BOOL	fQueue ) = 0 ;

	//
	//	Remove all references to the cache item !
	//
	virtual BOOL
	RemoveAllReferences( ) = 0 ;
} ;

#include	"cintrnl.h"


// This callback function is used to issue a stop hint during a
// long spin while shutting down so that the shutdown won't time
// out.
typedef void (*PSTOPHINT_FN)();

extern	CRITICAL_SECTION	g_CacheShutdown ;

//
//	Call these functions to initialize the Cache Library
//
extern	BOOL	__stdcall CacheLibraryInit() ;
extern	BOOL	__stdcall CacheLibraryTerm() ;

template	<	class	Data, 
				class	Key
				>
class	CacheExpungeObject	{
public : 

	//
	//	This function is called to determine whether we should remove 
	//	the item from the cache.
	//
	//	pKey - Pointer to the Key of the item in the cache
	//	pData - Pointer to the data for the item in the cache 
	//	cOutstandingReferences - The number of times of outstanding check-outs on the item !
	//	fMultipleReferenced - TRUE if there is more than one cache that contains
	//		this item !
	//
	virtual
	BOOL
	fRemoveCacheItem(	Key*	pKey, 
						Data*	pData
						) = 0 ;

} ;

template	<	class	Data >
class	CacheCallback	{
public :
	virtual	BOOL	fRemoveCacheItem(	Data&	d )	{
		return	FALSE ;
	}
} ;


class	CacheStats : public	CHashStats	{
public :

	enum	COUNTER	{
		ITEMS,				//	Number of items in the cache
		CLRU,				//	Number of items in the LRU List
		EXPIRED,			//	Number of items that have been expired !
		INSERTS,			//	Number of items inserted over time
		READHITS,			//	Number of times we've had a cache hit needing only readlocks during FindOrCreate()!
		SUCCESSSEARCH,		//	Number of times we've successfully searched for an item !
		FAILSEARCH,			//	Number of times we've failed to find an item !
		RESEARCH,			//	Number of times we've had to search a second time for an item
		WRITEHITS,			//	Number of times we've had a cache hit requiring a PartialLock()
		PARTIALCREATES,		//	Number of times we've created an item with only a PartialLock
		EXCLUSIVECREATES,	//	Number of times we've created an item with an Exclusive Lock !
		CEFAILS,			//	Number of times we've failed to allocate a CACHEENTRY structure
		CLIENTALLOCFAILS,	//	Number of times we've failed to allocate a Data object
		CLIENTINITFAILS,	//	Number of times a client object has failed to initialize !
		MAXCOUNTER			//	A Invalid Counter - all values smaller than this !
	} ;
	//
	//	Array of longs to hold different values !
	//
	long	m_cCounters[MAXCOUNTER] ;

	CacheStats()	{
		ZeroMemory( m_cCounters, sizeof(m_cCounters) ) ;
	}
} ;


typedef	CacheStats	CACHESTATS ;


inline	void
IncrementStat(	CacheStats*	p, CACHESTATS::COUNTER	c ) {
	_ASSERT( c < CACHESTATS::MAXCOUNTER ) ;
	if( p != 0 ) {
		InterlockedIncrement( &p->m_cCounters[c] ) ;
	}
}

inline	void
AddStat(	CacheStats*p, CACHESTATS::COUNTER	c, long	l ) {
	_ASSERT( c < CACHESTATS::MAXCOUNTER ) ;
	if( p != 0 ) {
		InterlockedExchangeAdd( &p->m_cCounters[c], l ) ;
	}
}

inline	void
DecrementStat(	CacheStats* p, CACHESTATS::COUNTER	c )		{
	_ASSERT( c < CACHESTATS::MAXCOUNTER ) ;
	if( p != 0 ) {
		InterlockedDecrement( &p->m_cCounters[c] ) ;
	}
}

template	<	class	Data,
				class	Key,
				class	Constructor,
				class	PerCacheData = LPVOID
				>
class	CacheEx :	public	CacheTable	{
public :

	//
	//	For compare, hash functions etc.... we will use this type !
	//
	typedef	Data	DATA ;
	typedef	Key		KEY ;
	typedef	Key*	PKEY ;

	//
	//	Hash Computation function
	//
	typedef	DWORD	(*PFNHASH)( PKEY ) ;

	//
	//	Key Comparison function - to be provided by caller !
	//
	typedef	int	(*PKEYCOMPARE)(PKEY, PKEY) ;

	//
	//	Callback objects for Expunge Operations !
	//
	typedef	CacheCallback< DATA >	CALLBACKOBJ ;

	//
	//	Objects that the user can give to the cache to manage the removal of items !
	//
	typedef	CacheExpungeObject<	DATA, KEY >	EXPUNGEOBJECT ;

private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CCacheItemKey< DATA, KEY, Constructor, PerCacheData >	CACHEENTRY ;

	//
	//	Define the helper class for Hash Tables
	//
	typedef	TFDLHash< CACHEENTRY, PKEY, &CacheState::HashDLIST >	HASHTABLE ;

	//
	//	An iterator that lets us walk everything in the hash table !
	//
	typedef	TFDLHashIterator< HASHTABLE >	HASHITER ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	An object to collect statistics about cache operations !
	//	This may be NULL !
	//
	class	CacheStats*				m_pStats ;

	//
	//	A list of everything in the Cache, used for TTL processing
	//
	CLRUList						m_ExpireList ;

	//
	//	A hash table we use to find things within the Cache
	//
	HASHTABLE						m_Lookup ;

	//
	//	Pointer to a runtime-user provided function which is used
	//	to determine what things should be removed from the Cache
	//
//	BOOL							(* m_pfnExpungeSpecific )( Data & ) ;

	//	
	//	Pointer to a runtime-user provided object derived from CacheCallback< Data >
	//	which lets the user invoke some function for each item in the Cache !
	//
	CALLBACKOBJ*					m_pCallbackObject ;

	//
	//	Reader writer lock which protects all these data structures !
	//
	CACHELOCK						m_Lock ;

	//
	//	The initial TTL we should assign to all newly cached objects !
	//
	DWORD							m_TTL ;

	//
	//	The cache used for creation/deletion of our CACHEENTRY objects !
	//
	CAllocatorCache					m_Cache ;


protected :

	//
	//	Virtual function called by CScheduleThread's thread which
	//	we use to bump TTL counters
	//
	void
	Schedule();

	//
	//	Function which removes an Entry from the Cache !
	//
	BOOL	
	RemoveEntry(	
			CacheState*	pEntry
			) ;

	//
	//	Virtual Function called by CacheList when we pass call
	//	CacheList::ExpungeSpecific
	//
	BOOL	
	QueryRemoveEntry(	
			CacheState*	pEntry
			) ;

	//
	//	Virtual Function part of CacheTable interface - used
	//	by LRUList to do appropriate locking !
	//
	CACHELOCK&
	GetLock()	{
		return	m_Lock ;
	}

public :

	//
	//	This is the users extra data - we will provide it on calls
	//	to constructor objects so that they can track some state sync'd
	//	with the cache locks !
	//
	PerCacheData	m_PerCacheData ;

	//
	//	This function is used to return an item to the cache -
	//	it will bump down a ref count for the number of clients
	//	currently using the item !
	//
	static	void
	CheckIn( DATA* ) ;

	//
	//	This function is provided for cases when the client needs
	//	to check-in an item from a Cache Callback function (i.e. Expunge)
	//
	//
	static	void
	CheckInNoLocks(	DATA*	) ;

	//
	//	This function is used to add a client reference to an item in the cache !
	//
	static	void
	CheckOut(	DATA*,
				long	cClientRefs = 1
				) ;

	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	CacheEx( ) ;

	//
	//	Destructor - remove ourselves from schedule list before continuing !
	//
	~CacheEx() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			PFNHASH	pfnHash,
			PKEYCOMPARE	pKeyCompare,
			DWORD	dwLifetimeSeconds,
			DWORD	cMaxInstances,
			CACHESTATS*	pStats,
			PSTOPHINT_FN pfnStopHint = NULL
			) {
	/*++

	Routine Description :

		This function initializes the cache so that it is ready
		to take entries.

	Arguments :

		pfnHash - function to be used to compute hash values on keys
		dwLifetimeSeconds - The number of seconds objects should live in the Cache
		pfnStopHint - function to be used to send stop hints during
		  long spins so shutdown's don't time out.

	Return Value :

		TRUE if successfull

	--*/

		m_pStats = pStats ;

		m_ExpireList.Init(	cMaxInstances,
							dwLifetimeSeconds
							) ;
		
		return	m_fValid = m_Lookup.Init(
										256,
										128,
										4,
										pfnHash,
										&CACHEENTRY::GetKey,
										pKeyCompare,
										0,
										pStats
										) ;
	}

	void
	Expire() {

		EnterCriticalSection( &g_CacheShutdown ) ;

		DWORD	c = 0 ;
		m_ExpireList.Expire( this, &m_Cache, c, &m_PerCacheData ) ;

		LeaveCriticalSection( &g_CacheShutdown ) ;

	}

	//
	//	Called to remove all items from the cache !
	//
	BOOL
	EmptyCache() ;

	BOOL
	ExpungeItems(
				EXPUNGEOBJECT*	pExpunge
				) ; 

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	ExpungeKey(	
			DWORD	dwHash,
			PKEY	key
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//

	//
	//	INTERNAL API's - These are public for convenience - not intended
	//	for Use outside of cachelib !!
	//
	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result !
	//
	//	
	//
	BOOL
	FindOrCreateInternal(	
			DWORD	dwHash,
			KEY&	key,
			Constructor&	constructor,
			DATA*	&pData,
			BOOL	fEarlyCreate = FALSE  /* Best Perf if this is FALSE - but required by some users !*/
			) ;

	//
	//	Find the item if it is in the cache !
	//
	DATA*	
	FindInternal(
			DWORD	dwHash,
			KEY&	key
			) ;

	//
	//	Insert a new item into the cache -
	//	We get to specify whether and what kind of reference
	//	we will hold outside of the cache !
	//
	BOOL
	InsertInternal(
			DWORD	dwHash,
			KEY&	key,
			DATA*	pData,
			long	cClientRefs = 0
			) ;

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData = LPVOID
				>
class	MultiCacheEx {
public:

	typedef	Data	DATA ;
	typedef	Key		KEY ;
	typedef	Key*	PKEY ;

	//
	//	Hash Computation function
	//
	typedef	DWORD	(*PFNHASH)( PKEY ) ;

	//
	//	Key Comparison function - to be provided by caller !
	//
	typedef	int	(*PKEYCOMPARE)(PKEY, PKEY) ;

	//
	//	Callback objects for Expunge Operations !
	//
	typedef	CacheCallback< DATA >	CALLBACKOBJ ;

	//
	//	Objects that the user can give to the cache to manage the removal of items !
	//
	typedef	CacheExpungeObject<	DATA, KEY >	EXPUNGEOBJECT ;


private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CCacheItemKey< DATA, KEY, Constructor, PerCacheData >	CACHEENTRY ;
	//
	//	Define the type for a single instance !
	//
	typedef	CacheEx< Data, Key, Constructor, PerCacheData >	CACHEINSTANCE ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	Pointer to the various Cache's we subdivide our work into
	//
	CACHEINSTANCE					*m_pCaches ;

	//
	//	Number of sub cache's we use to split up the work !
	//
	DWORD							m_cSubCaches ;

	//
	//	We use the hash function to choose which of our subcaches to work with !
	//
	CACHEINSTANCE::PFNHASH			m_pfnHash ;

	//
	//	Return the correct cache instance to hold the selected piece of data !
	//
	DWORD							ChooseInstance( DWORD	dwHash ) ;

public :

	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	MultiCacheEx(  ) ;

	//
	//	Destructor - destroys are various sub cache's
	//
	~MultiCacheEx() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			PFNHASH	pfnHash,
			PKEYCOMPARE	pfnCompare,
			DWORD	dwLifetimeSeconds,
			DWORD	cMaxElements,
			DWORD	cSubCaches,
			CACHESTATS*	pStats,
			PSTOPHINT_FN pfnStopHint = NULL
			) ;

	//
	//	Expire items in the cache !
	//
	void
	Expire() ;

	//
	//	Called to remove all items from the cache !
	//
	BOOL
	EmptyCache() ;

	//
	//	The user wants to remove a large set of items from the cache !
	//
	BOOL
	ExpungeItems(
				EXPUNGEOBJECT*	pExpunge
				) ; 

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	ExpungeKey(	
			PKEY	key
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	Data*
	FindOrCreate(	
			Key&	key,
			Constructor&	constructor,
			BOOL	fEarlyCreate = FALSE
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//	NOTE : This is for use when the caller has a cheaper
	//	way to compute the hash value then us - in debug we
	//	need to assure that the caller correctly computes this !
	//
	Data*
	FindOrCreate(	
			DWORD	dwHash,
			Key&	key,
			Constructor&	constructor,
			BOOL	fEarlyCreate = FALSE
			) ;

	//
	//	Find an item in the cache - hash of key is precomputed !
	//
	Data*
	Find(	DWORD	dwHash,
			KEY&	key
			) ;

	//
	//	Find an item in the cache
	//
	Data*
	Find(	KEY&	key ) ;

	//
	//	Insert a new item into the cache -
	//	We get to specify whether and what kind of reference
	//	we will hold outside of the cache !
	//
	BOOL
	Insert( DWORD	dwHash,
			KEY&	key,
			Data*	pData,
			long	cClientRefs = 0
			) ;

	//
	//	Insert a new item into the cache -
	//	We get to specify whether and what kind of reference
	//	we will hold outside of the cache !
	//
	BOOL
	Insert( KEY&	key,
			Data*	pData,
			long	cClientRefs = 0
			) ;





	//
	//	This function is used to return an item to the cache -
	//	it will bump down a ref count for the number of clients
	//	currently using the item !
	//
	static	void
	CheckIn( DATA* ) ;

	//
	//	This function is provided for cases when the client needs
	//	to check-in an item from a Cache Callback function (i.e. Expunge)
	//
	//
	static	void
	CheckInNoLocks(	DATA*	) ;

	//
	//	This function is used to add a client reference to an item in the cache !
	//
	static	void
	CheckOut(	DATA*,
				long	cClientRefs = 1	
				) ;

} ;



#include	"cache2i.h"


#endif	// _CACHE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cmmsprop.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmsprop.h

Abstract:

	This module contains the definition of the special property class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	04/19/98	created

--*/

#ifndef _CMMVPROP_H_
#define _CMMVPROP_H_

#include "propid.h"

// Define a generic accessor function to access special properties
typedef HRESULT (*GET_ACCESSOR_FUNCTION)(
			PROP_ID	idProp, 
			LPVOID	pContext,
			LPVOID	pParam,
			DWORD	cbLength, 
			LPDWORD	pcbLength,
			LPBYTE	pbBuffer 
			);

typedef HRESULT (*PUT_ACCESSOR_FUNCTION)(	
			PROP_ID	idProp,
			LPVOID	pContext,
			LPVOID	pParam,
			DWORD	cbLength, 
			LPBYTE	pbBuffer
			);

// Define the property item structure
//
// Note: In this implementation, all special properties are volatile
// We can do Serialize() and Restore() operations in the future if we want.
//
typedef struct _SPECIAL_PROPERTY_ITEM
{
	PROP_ID							idProp;			// Property ID of property
	DWORD							ptBaseType:16;	// Lowest 16 bits: property type
	DWORD							fAccess:15;		// Upper 15 bits: access rights
	DWORD							fVolatile:1;	// MSB: TRUE if property is volatile
	GET_ACCESSOR_FUNCTION			pfnGetAccessor;	// Accessor to get property value
	PUT_ACCESSOR_FUNCTION			pfnPutAccessor;	// Accessor to set property value

} SPECIAL_PROPERTY_ITEM, *LPSPECIAL_PROPERTY_ITEM;

// Define a generic structure to define a set of properties
typedef struct _PTABLE
{
	LPSPECIAL_PROPERTY_ITEM		pProperties;	// Actual property table
	DWORD						dwProperties;	// Count
	BOOL						fIsSorted;		// Prop table sorted by PROP_ID?

} PTABLE, *LPPTABLE;

// Enumerated types representing type of access on property
typedef enum _PROPERTY_ACCESS
{
	PA_NONE = 0,
	PA_READ = 1,
	PA_WRITE = 2,
	PA_READ_WRITE = PA_READ | PA_WRITE,
	PA_MAXPA

} _PROPERTY_ACCESS;

// Enumerated types representing property types
typedef enum _PROPERTY_DATA_TYPES
{
	PT_NONE = 0,
	PT_STRING,
	PT_DWORD,
	PT_BOOL,
	PT_INTERFACE,
	PT_MAXPT

} PROPERTY_DATA_TYPES;


// =================================================================
// class for searching special properties
//
class CSpecialPropertyTable
{
  public:

	CSpecialPropertyTable(
				LPPTABLE	pPropertyTable
				);

	~CSpecialPropertyTable();

	//
	// Synopsis:
	// Method to retrieve a special property item, if exists in the 
	// special property table.
	//
	// Arguments:
	// idProp - Property ID
	// pContext - context for accessor function
	// ptBaseType - one of the values in PROPERTY_DATA_TYPES. If specified,
	//			this type will be checked against the base type of the special
	//			property. A perfect type match would then be required. If this
	//			is PT_NONE, then a type check is not performed.
	// cbLength - length of buffer provided
	// pcbLength - returns length of property value
	// pbBuffer - buffer to receive property value
	// fCheckAccess - [optional] TRUE if the caller wants an access check on
	//			the property, FALSE (default) skips the check
	//
	// Return values:
	// S_OK - success, the specified property if found and its value returned
	// S_FALSE - success, the specified property is not found in the table
	// E_INVALIDARG - error, one or more arguments are invalid
	// E_ACCESSDENIED - error, desired access to the specified property is
	//			denied
	// TYPE_E_TYPEMISMATCH - error, a specific data type is given, but the
	//			specified and actual types don't match
	// HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) - error, the specified
	//			buffer is not large enough to hold the property value. 
	//			*pcbLength should contain the required length in bytes.
	// Or any other HRESULT from the get accessor
	//
	HRESULT GetProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				DWORD		*pcbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess = FALSE
				);

	//
	// Synopsis:
	// Method to set a special property item, if exists in the 
	// special property table.
	//
	// Arguments:
	// idProp - Property ID
	// pContext - context for accessor function
	// ptBaseType - one of the values in PROPERTY_DATA_TYPES. If specified,
	//			this type will be checked against the base type of the special
	//			property. A perfect type match would then be required. If this
	//			is PT_NONE, then a type check is not performed.
	// cbLength - length of buffer provided
	// pcbLength - returns length of property value
	// pbBuffer - buffer to receive property value
	// fCheckAccess - [optional] TRUE if the caller wants an access check on
	//			the property, FALSE (default) skips the check
	//
	// Return values:
	// S_OK - success, the specified property if found and its value is set
	// S_FALSE - success, the specified property is not found in the table
	// E_INVALIDARG - error, one or more arguments are invalid
	// E_ACCESSDENIED - error, desired access to the specified property is
	//			denied
	// TYPE_E_TYPEMISMATCH - error, a specific data type is given, but the
	//			specified and actual types don't match
	// Or any other HRESULT from the put accessor
	//
	HRESULT PutProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess = FALSE
				);

  private:
  
	// Method to search the property table and return the associated
	// property item, if found
	LPSPECIAL_PROPERTY_ITEM SearchForProperty(
				PROP_ID	idProp
				);

	// Pointer to property table and count of items
	LPSPECIAL_PROPERTY_ITEM		m_pProperties;
	DWORD						m_dwProperties;

	// TRUE if the table of properties is sorted, will use
	// binary search if so. Otherwise, a linear scan is performed
	BOOL						m_fIsSorted;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cache2i.h ===
/*++

cache2i.h -

	This file contains all the template function definitions required
	to make the cache manager work.


--*/

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx< Data, Key, Constructor, PerCacheData >::Schedule()	{
/*++

Routine Description :

	This function runs through all the items in the Cache
	bumping TTL's.  If there are any items ready to go
	then we dump them from the Cache.

Arguments :

	None.

Return Value :

	Nothing

--*/

	//TraceFunctEnter( "CacheEx::Schedule" ) ;

	if( !m_fValid )
		return ;

	DWORD	cExpired = 0 ;
	Expire( ) ;

}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL	
CacheEx<Data, Key, Constructor, PerCacheData>::RemoveEntry(	
					CacheState*	pEntry
					)	{
/*++

Routine Description :

	This function removes an entry from the Cache.
	We call our hash table to delete the item.
	the CacheState destructor automagically removes
	the item from our linked lists.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item to be removed from cache

Return Value :

	TRUE if successfully removed !

--*/

	TraceFunctEnter( "CacheEx::RemoveEntry" ) ;
	DebugTrace( (DWORD_PTR)this, "pEntry %x", pEntry ) ;

	CACHEENTRY	*pCacheEntry = (CACHEENTRY*)pEntry ;
	m_Lookup.Delete( pCacheEntry ) ;

	m_ExpireList.DecrementItems() ;
	//
	//	Update our counters !
	//
	DecrementStat( m_pStats, CACHESTATS::ITEMS ) ;

	return	TRUE ;
}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL	
CacheEx<Data, Key, Constructor, PerCacheData>::QueryRemoveEntry(	
					CacheState*	pEntry )	{
/*++

Routine Description :

	This function is called from CacheList object to
	determine whether we want to remove an item from the Cache.
	This function is used to implement the ExpungeSpecific
	function available to clients.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item we want to determine whether it should remain !

Return Value :

	TRUE if successfully removed !

--*/

	TraceFunctEnter( "CacheEx::QueryRemoveEntry" ) ;

	CACHEENTRY	*pCacheEntry = (CACHEENTRY*) pEntry ;

	if( m_pCallbackObject ) {
//		return	m_pCallbackObject->fRemoveCacheItem( *pCacheEntry->m_pData ) ;
	}
	return	FALSE ;
}


#ifdef	DEBUG

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
long	CacheEx<Data, Key, Constructor, PerCacheData>::s_cCreated = 0 ;

#endif

	
template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
CacheEx<Data, Key, Constructor, PerCacheData>::CacheEx( ) :
	m_fValid( FALSE ),
	m_Cache( sizeof( CACHEENTRY ) )	 {
/*++

Routine Description :

	This function initializes our member variables.

Arguments :

	cMax - maximum number of elements the cache should hold

Return Value :

	Nothing

--*/

#ifdef	DEBUG

	InterlockedIncrement( &s_cCreated ) ;

#endif

	AddToSchedule() ;

}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
CacheEx<Data, Key, Constructor, PerCacheData>::~CacheEx( ) {
/*++

Routine Description :

	This function destroys a Cache object !

Arguments :

	None

Return Value :

	Nothing

--*/

	RemoveFromSchedule() ;

	EnterCriticalSection( &g_CacheShutdown ) ;

	//
	//	Member and Base class destruction follows !!
	//

	BOOL	f = EmptyCache() ;

	LeaveCriticalSection( &g_CacheShutdown ) ;

	_ASSERT( f ) ;

#ifdef	DEBUG

	InterlockedDecrement( &s_cCreated ) ;

#endif

}


#if 0
template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::Init(	
				PFNHASH	pfnHash,
				PKEYCOMPARE	pKeyCompare,
				DWORD	dwLifetimeSeconds,
				DWORD	cMaxInstances,
				PSTOPHINT_FN pfnStopHint
		) {
/*++

Routine Description :

	This function initializes the cache so that it is ready
	to take entries.

Arguments :

	pfnHash - function to be used to compute hash values on keys
	dwLifetimeSeconds - The number of seconds objects should live in the Cache
	pfnStopHint - function to be used to send stop hints during
	  long spins so shutdown's don't time out.

Return Value :

	TRUE if successfull

--*/


	m_ExpireList.Init(	cMaxInstances,
						dwLifeTimeSeconds
						) ;
	
	return	m_fValid = m_Lookup.Init(
									256,
									128,
									4,
									pfnHash,
									&CACHEENTRY::GetKey,
									pKeyCompare
									) ;
}
#endif



template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::EmptyCache(	) {
/*++

Routine Description :

	This function removes everything from the cache.
	We are used during shutdown and destruction of the cache.

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/

	if (!m_fValid) {
		return TRUE;
	}

	BOOL	fReturn = TRUE ;

	FILETIME	filetimeNow ;

	ZeroMemory( &filetimeNow, sizeof( filetimeNow ) ) ;

	BOOL	fTerm = FALSE ;

	m_Lock.ExclusiveLock() ;

	m_ExpireList.ProcessWorkQueue(0,0) ;

	//BOOL	fReturn = m_ExpireList.Empty( this, &m_Cache, &m_PerCacheData ) ;

	HASHITER	Iter( m_Lookup ) ;
	
	while( !Iter.AtEnd() ) {

		CACHEENTRY*	pEntry = Iter.Current() ;
		//BOOL	fLock = pEntry->FLockCandidate( FALSE, filetimeNow, fTerm ) ;

		//_ASSERT( fLock ) ;

		pEntry->IsolateCandidate() ;

		CACHEENTRY*	pTemp = Iter.RemoveItem() ;
		m_ExpireList.DecrementItems() ;
		_ASSERT( pTemp == pEntry ) ;

		long l = pTemp->Release( &m_Cache, &m_PerCacheData ) ;
		_ASSERT( l== 0 || l == 1) ;
	}

	m_ExpireList.DrainWorkQueue() ;

	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}

template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::ExpungeItems(
			EXPUNGEOBJECT*	pExpunge
			) {
/*++

Routine Description :

	This function removes everything from the cache.
	We are used during shutdown and destruction of the cache.

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/

	BOOL	fReturn = TRUE ;

	m_Lock.ExclusiveLock() ;

	//
	//	Build an iterator that can walk our hash tables !
	//
	HASHITER	Iter( m_Lookup ) ;
	
	//
	//	Examine everything in the hash tables !
	//
	while( !Iter.AtEnd() ) {

		CACHEENTRY*	pEntry = Iter.Current() ;

		//
		//	We only let you Expunge Master Entries !
		//
		CacheState*	pMaster = 0 ;
		BOOL	fLocked = pEntry->FLockExpungeCandidate(pMaster) ;
		if( fLocked )	{

			//
			//	Ask the user if they want to delete this item !
			//
			if( pExpunge->fRemoveCacheItem(	pEntry->GetKey(),
											pEntry->m_pData
											) )	{

				CACHEENTRY*	pTemp = Iter.RemoveItem() ;
				m_ExpireList.DecrementItems() ;
				_ASSERT( pTemp == pEntry ) ;

				//
				//	This removes the cache item from any association
				//	it may have with other cache items ! In addition
				//	it drops the locks we were holding !
				//
				pTemp->FinishCandidate(pMaster) ;

				//
				//	Drop the cache's reference - this will leave the
				//	item orphaned - to be destroyed when the final
				//	client reference is released !
				//
				long l = pTemp->Release( &m_Cache, &m_PerCacheData ) ;
				continue ;
			}	else	{
				
				//
				//	We're not deleting this guy - release any locks we're holding !
				//
				pEntry->ReleaseLocks(pMaster) ;

			}
		}
		Iter.Next() ;
	}

	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}


template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::ExpungeKey(
			DWORD	dwHash,
			PKEY	pKeyExpunge
			) {
/*++

Routine Description :

	This function removes everything from the cache.
	We are used during shutdown and destruction of the cache.

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/

	TraceFunctEnter( "CacheEx::ExpungeKey" ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( pKeyExpunge ) ) ;

	BOOL	fReturn = FALSE ;
	m_Lock.PartialLock() ;

	Data*	pDataOut = 0 ;

	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
	}	else	{
		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = m_Lookup.SearchKey( dwHash, pKeyExpunge ) ;
		if( pEntry ) {
			//
			//	We've found the entry we want to remove - now go to an Exclusive Lock
			//	so we can ensure people don't blow up walking hash bucket chains 
			//
			m_Lock.FirstPartialToExclusive() ;
			CacheState*	pMaster ;
			BOOL	fLocked = pEntry->FLockExpungeCandidate(pMaster) ;
			//
			//	If we successfully locked the item, we're ready to go ahead an remove the item !
			//
			if( fLocked )	{
				//
				//	get rid of the guy !
				//
				m_Lookup.Delete( pEntry ) ;
				m_ExpireList.DecrementItems() ;
				pEntry->FinishCandidate(pMaster) ;
				//
				//	This could be the final reference, (but maybe not if clients are still holding it etc...)
				//
				long l = pEntry->Release( &m_Cache, &m_PerCacheData ) ;
				fReturn = TRUE ;
			}	
			m_Lock.ExclusiveUnlock() ;
			return	fReturn ;
		}
	}
	m_Lock.PartialUnlock() ;
	return	FALSE ;
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::FindOrCreateInternal(
						DWORD	dwHash,
						Key&	key,
						Constructor&	constructor,
						Data*	&pDataOut,
						BOOL	fEarlyCreate
						) {
/*++

Routine Description :

	This function is called when we want something out
	of the Cache.  We will either find the object or create it.

	WE WILL GRAB THE NECESSARY LOCKS !
	WE ARE NOT REENTRANT -
	
	At several points we call user provided code - it must
	not re-enter this cache !

Arguments :

	dwHash - The hash of the key we've been passed
	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pDataOut - Pointer which gets the result !
	fEarlyCreate - If this is TRUE we should call the constructor.Create()
		function early in the Cache Insertion process - this allows us to
		correctly deal with the condition where the Create() call may return
		a reference to another cache.	
	

Return Value :

	TRUE if successfull

--*/

	TraceFunctEnter( "CacheEx::FindOrCreateInternal" ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( &key ) ) ;

	Data*	pRelease = 0 ;
	pDataOut = 0 ;
	long	cClientRefs = 1 ;

	DebugTrace( (DWORD_PTR)this, "Args - dwHash %x fEarlyCreate %x", dwHash, fEarlyCreate ) ;

	//
	//	Check that the cache is initialized !
	//
	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
		return	FALSE ;
	}	else	{

		m_Lock.ShareLock() ;
		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = 0 ;
		HASHTABLE::ITER	iter = m_Lookup.SearchKeyHashIter( dwHash, &key, pEntry ) ;
		if( pEntry ) {
			pDataOut = pEntry->PublicData( &m_ExpireList ) ;
		}

		DebugTrace( (DWORD_PTR)this, "Initial Search - pDataOut %x", pDataOut ) ;

		if( pDataOut != 0 ) {

			//
			//	We're all done - release the lock !
			//
			m_Lock.ShareUnlock() ;
			//
			//	Increment our statistics !
			//
			IncrementStat( m_pStats, CACHESTATS::READHITS ) ;

		}	else	{

			//
			//	Try to convert our shared lock to a partial lock -
			//	if we can do so then we don't need to search the hash table again !
			//
			if( !m_Lock.SharedToPartial() ) {
				
				m_Lock.ShareUnlock() ;
				m_Lock.PartialLock() ;

				//
				//	Search the table again - something could happen while we briefly
				//	dropped the lock !
				//
				iter = m_Lookup.SearchKeyHashIter( dwHash, &key, pEntry ) ;

				IncrementStat( m_pStats, CACHESTATS::RESEARCH ) ;
				if( pEntry )
					IncrementStat( m_pStats, CACHESTATS::WRITEHITS ) ;

			}

			DebugTrace( (DWORD_PTR)this, "After possible Second Search - pEntry %x", pEntry ) ;
		
			//
			//	Time to re-evaluate, is there an entry in the cache !
			//
			if( pEntry != 0 )	{
				//
				//	Ok - we found an entry in the hash table, but it contained no data -
				//	so we need to do our FindOrCreate protocol on this element !
				//
				pDataOut = pEntry->FindOrCreate(
										m_Lock,
										constructor,
										m_PerCacheData,
										&m_ExpireList,
										m_pStats
										) ;

				//
				//	NOTE : pEntry->FindOrCreate() manipulates the global lock !
				//	it MUST unlock for us before it returns !
				//
				//m_Lock.PartialUnlock() ;
			}	else	{

				//
				//	Ok - first try to create the item we will be placing into the cache !
				//
				if( fEarlyCreate )
					pRelease = pDataOut = constructor.Create( key, m_PerCacheData ) ;

				DebugTrace( (DWORD_PTR)this, "fEarlyCreate %x pDataOut %x", fEarlyCreate, pDataOut ) ;

				if( !fEarlyCreate || pDataOut ) {

					//
					//	This must be the case !
					//
					_ASSERT( (pDataOut && fEarlyCreate) || (!pDataOut && !fEarlyCreate) ) ;

					CCacheItemBase<Data>*	pRef = 0 ;
					if( pDataOut )	{
						pRef = (CCacheItemBase<Data>*)pDataOut->m_pCacheRefInterface ;
						//
						//	Add a client reference IF this item is NOT contained in another cache !
						//
						cClientRefs = !pRef ? 1 : 0 ;
					}
					//
					//	Now - we will see if we can make the container to hold this data item !
					//	NOTE : we use pRef to figure out if we should add a client reference
					//	to this object - only do so if pRef is NULL meaning that this CACHEENTRY object
					//	OWNS the item in the cache !
					//
					//	This all means that pEntry is constructed with 1 or 2 references altogether
					//	which we need to handle in the error paths !
					//
					//	NOTE : if failure occurs pEntry should only be destroyed with FailedCheckOut() !
					//
#ifdef	DEBUG
					if( fTimeToFail() ) {
						pEntry = 0 ;
					}	else
#endif
					pEntry = new( m_Cache )	CACHEENTRY( &m_ExpireList, key, 0, cClientRefs ) ;

					DebugTrace( (DWORD_PTR)this, "pEntry %x pRef %x pDataOut %x pEntry->m_pData %x", pEntry, pRef,
						pDataOut, pEntry ? pEntry->m_pData : 0 ) ;

					if( pEntry != 0 ) {
						//
						//	Just check some basic things here !
						//
						_ASSERT( !pEntry->IsInLRUList() ) ;
						_ASSERT( pEntry->IsCheckedOut() || pRef ) ;

						//
						//	Grab the lock on the entry !
						//
						if( pRef )	{
							pRef->ExclusiveLock() ;
							//
							//	This must be checked out of its native cache,
							//	otherwise it could be destroyed from under us !
							//
							_ASSERT( pRef->IsCheckedOut() ) ;
							_ASSERT( pRef->IsMatch( pDataOut ) ) ;
						}
						pEntry->ExclusiveLock() ;
						//
						//	Convert to an Exclusive Lock for inserting into
						//	the hash table !
						//
						m_Lock.FirstPartialToExclusive() ;

						BOOL	fInsert ;
#ifdef	DEBUG
						//
						//	Periodically fail to insert into the hash table !
						//
						if( fTimeToFail() ) {
							fInsert = FALSE ;
						}	else
#endif
						fInsert = m_Lookup.InsertDataHashIter( iter, dwHash, &key, pEntry ) ;

						DebugTrace( (DWORD_PTR)this, "Insert Results - %x pDataOut %x pEntry %x", fInsert, pDataOut, pEntry ) ;
						_ASSERT( pRelease == pDataOut ) ;

						//
						//	Both the global Cache Lock - m_Lock and
						//	the locks for pEntry must be released within the branches of
						//	this if !
						//

						if( fInsert ) {
							m_ExpireList.IncrementItems() ;
							//
							//	Don't need to hold the whole cache anymore
							//
							m_Lock.ExclusiveUnlock() ;	

							//
							//	Number of times we've created an item while holding hash lock exclusively !
							//
							IncrementStat(	m_pStats, CACHESTATS::EXCLUSIVECREATES ) ;

							//
							//	This must be the case !
							//
							_ASSERT( (pDataOut && fEarlyCreate) || (!pDataOut && !fEarlyCreate) ) ;

							//
							//	Now do whatever is necessary to finish initialization ! -
							//	must always call Init() unless we're going to give up on this thing !
							//
							//	NOTE : Errors at this point can leave a dud CACHEENTRY in the
							//	cache, which should be cleaned up by expiration !
							//

							_ASSERT( pRelease == pDataOut ) ;

							if( !pDataOut ) {
								//
								//	This should only occur if we were not asked to do early creation !
								//
								_ASSERT( !fEarlyCreate ) ;

								pRelease = pDataOut = constructor.Create( key, m_PerCacheData ) ;
								pEntry->m_pData = pDataOut ;
								if( !pDataOut )	{
									//
									//	Keep Track of our statistics !
									//
									IncrementStat( m_pStats, CACHESTATS::CLIENTALLOCFAILS ) ;
								}
							}	

							_ASSERT( pRelease == pDataOut ) ;

							if( pDataOut && pDataOut->Init( key, constructor, m_PerCacheData ) ) {
								if( !pRef ) {
									pDataOut->m_pCacheRefInterface = pEntry ;
									pEntry->m_pData = pDataOut ;
								}	else {
#ifdef	DEBUG
									//
									//	Periodically fail these operations !
									//
									if( fTimeToFail() ) {
										pDataOut = 0 ;
									}	else	{
#endif
										//
										//	The item resides in another cache, and there must
										//	already be a user reference on the item, the user
										//	always gets a client ref through FindOrCreate - but
										//	they will get the client ref taken out by the
										//	constructor.Create call to provide us with the item !
										//
										if( !pRef->InsertRef( pEntry, pDataOut, 0 ) )	{
											pDataOut = 0 ;
										}
#ifdef	DEBUG
									}	//	Part of making the operation fail periodically !
#endif
								}	
							}	else	{
								//
								//	Should check the item in so that expire catches it !
								//
								pEntry->m_pData = pDataOut = 0 ;
								IncrementStat( m_pStats, CACHESTATS::CLIENTINITFAILS ) ;

							}

							DebugTrace( (DWORD_PTR)this, "pDataOut is Now %x pEntry %x pEntry->m_pData %x",
								pDataOut, pEntry, pEntry->m_pData ) ;

							_ASSERT( pDataOut == pEntry->m_pData ) ;

							//
							//	If things have gone bad - remove the client
							//	ref and put in the expiration list !
							//
							if( pDataOut ) {
								IncrementStat(	m_pStats, CACHESTATS::ITEMS ) ;
								pRelease = 0 ;
							}	else	{
								pEntry->FailedCheckOut( &m_ExpireList,
														cClientRefs,
														0,			// Can't give them the Allocation Cache - no lock held
														0			// Can't give them per cache stuff - no lock held !
														) ;
								_ASSERT( !pDataOut || pDataOut->m_pCacheRefInterface == pRef ) ;
							}	

							//
							//	Release the lock on the pEntry !
							//
							pEntry->ExclusiveUnlock() ;

						}	else	{

							DebugTrace( (DWORD_PTR)this, "Failed to Insert - pDataOut %x pRelease %x pRef %x pEntry %x",
								pDataOut, pRelease, pRef, pEntry ) ;

							_ASSERT( !pDataOut || pDataOut->m_pCacheRefInterface == pRef ) ;

							_ASSERT( pRelease == pDataOut ) ;
							pDataOut = 0 ;
							_ASSERT( pEntry->m_pData == pDataOut ) ;

							//
							//	This item should have been checked out !
							//
							_ASSERT( pEntry->IsCheckedOut() || pRef ) ;

							//
							//	Release the lock on the pEntry object before we destroy it !
							//
							pEntry->ExclusiveUnlock() ;

							//
							//	Release back to the cache -did we have a client ref -
							//	have to get rid of that if necessary !
							//	NOTE : This should totally destroy pEntry - we will also
							//	remove his last reference and return to the allocator cache !
							//
							pEntry->FailedCheckOut( &m_ExpireList,
													cClientRefs,
													&m_Cache,
													&m_PerCacheData
													) ;

							//
							//	To prevent a deadlock we have to release this lock !
							//	This is because the locks used within CACHEENTRY's are not re-entrant
							//	but if we call constructor.Release() below, we may try to re-enter
							//	pRef's lock (our client may try to Re-Enter !)
							//
							if( pRef )	{
								_ASSERT( pRef->IsCheckedOut() ) ;
								pRef->ExclusiveUnlock() ;
								pRef = 0 ;	// set to 0
							}
			
							if( pRelease != 0 ) {
								_ASSERT( pDataOut == 0 ) ;
								//
								//	Well we called the constructors create call - need to
								//	release the object back to the constructor !
								//
								constructor.Release( pRelease, &m_PerCacheData ) ;
							}
							pRelease = 0 ;


							//
							//	Release the hash table lock
							//
							m_Lock.ExclusiveUnlock() ;
						}

						if( pRef )	{
							//
							//	This must be checked out of its native cache,
							//	otherwise it could be destroyed from under us !
							//
							_ASSERT( pRef->IsCheckedOut() ) ;
							pRef->ExclusiveUnlock() ;
							pRef = 0 ;
						}
						//
						//	pRef should be unlocked by this point -
						//
						_ASSERT( pRef == 0 ) ;
					}	else	{
						//
						//	Number of times we've failed to alloc a CACHEENTRY object !
						//
						IncrementStat( m_pStats, CACHESTATS::CEFAILS ) ;

						_ASSERT( pRelease == pDataOut ) ;
						pDataOut = 0 ;

						//
						//	We were unable to allocate the necessary object to
						//	hold in the cache !
						//
						m_Lock.PartialUnlock() ;
						SetLastError( ERROR_OUTOFMEMORY ) ;
					}
				}	else	{
					m_Lock.PartialUnlock() ;
	
					//
					//	Keep Track of our statistics !
					//
					IncrementStat( m_pStats, CACHESTATS::CLIENTALLOCFAILS ) ;
	
				}
			}
		}
	}

	//
	//	One of these had better be NULL !
	//
	_ASSERT( pRelease == 0 || pDataOut == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "pRelease %x", pRelease ) ;

	if( pRelease != 0 ) {
		_ASSERT( pDataOut == 0 ) ;
		//
		//	Well we called the constructors create call - need to
		//	release the object back to the constructor !
		//
		constructor.Release( pRelease, 0 ) ;
	}

	//
	//	Well return TRUE if we got something to return after all !
	//
	return	pDataOut != 0 ;
}

template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
Data*
CacheEx<Data, Key, Constructor, PerCacheData>::FindInternal(
						DWORD	dwHash,
						Key&	key
						) {
/*++

Routine Description :

	This function will try to find something within the cache !

Arguments :

	dwHash - the hash value of the item we're looking for !
	key - The unique key used to find the item in the Cache.
	fClient - the kind of reference to stick on the item we find !	

Return Value :

	TRUE if successfull

--*/

	TraceFunctEnter( "CacheEx::FindInternal" ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( &key ) ) ;

	Data*	pDataOut = 0 ;

	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
		return	FALSE ;
	}	else	{

		m_Lock.ShareLock() ;
		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = m_Lookup.SearchKey( dwHash, &key ) ;
		if( pEntry ) {
			pDataOut = pEntry->PublicData( &m_ExpireList ) ;
		}
		m_Lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "After Search pEntry %x pDataOut %x", pEntry, pDataOut ) ;

		//
		//	Set up the error codes for why we may have failed !
		//
		if( !pEntry ) {
			SetLastError( ERROR_FILE_NOT_FOUND ) ;
		}	else if( !pDataOut )	{
			SetLastError( ERROR_INVALID_DATA ) ;
		}
	}
	if( pDataOut )
		IncrementStat( m_pStats, CACHESTATS::SUCCESSSEARCH ) ;
	else
		IncrementStat( m_pStats, CACHESTATS::FAILSEARCH ) ;

	return	pDataOut ;
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
CacheEx<Data, Key, Constructor, PerCacheData>::InsertInternal(
						DWORD	dwHash,
						Key&	key,
						Data*	pDataIn,
						long	cClientRefs
						) {
/*++

Routine Description :

	This function is called when we have a data item,
	and we wish to insert it into the cache !

Arguments :

	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pData - Pointer which gets the result !
	

Return Value :

	TRUE if successfull

--*/

	TraceFunctEnter( "CacheEx::InsertInternal" ) ;
	DebugTrace( (DWORD_PTR)this, "Args dwHash %x pDataIn %x cClientRefs %x",
		dwHash, pDataIn, cClientRefs ) ;

	_ASSERT( dwHash == m_Lookup.ComputeHash( &key ) ) ;

	BOOL	fReturn = FALSE ;

	if( !m_fValid ) {
		SetLastError( ERROR_NOT_SUPPORTED ) ;
		return	FALSE ;
	}	else	{

		//
		//	Grab the cache lock with a Partial Lock - this
		//	guarantees that nobody else can insert or delete
		//	from the hash table untill we finish.
		//
		//	Note : every branch in the following if's must
		//	ensure that the lock is properly released/manipulated !
		//
		m_Lock.PartialLock() ;

		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = 0 ;
		HASHTABLE::ITER	iter = m_Lookup.SearchKeyHashIter( dwHash, &key, pEntry ) ;
		//CACHEENTRY	*pEntry = m_Lookup.SearchKey( dwHash, &key ) ;

		DebugTrace( (DWORD_PTR)this, "After Search pEntry %x pEntry->m_pData %x",
			pEntry, pEntry ? pEntry->m_pData : 0 ) ;

		if( pEntry != 0 )	{
			fReturn = pEntry->SetData( pDataIn, &m_ExpireList, cClientRefs ) ;
			m_Lock.PartialUnlock() ;
		}	else	{
			CCacheItemBase<Data>*	pRef = (CCacheItemBase<Data>*)pDataIn->m_pCacheRefInterface ;

#ifdef	DEBUG
			//
			//	Periodically fail to allocate memory !
			//
			if( fTimeToFail() ) {
				pEntry = 0 ;
			}	else
#endif
			pEntry = new( m_Cache )	CACHEENTRY( &m_ExpireList, key, 0, cClientRefs ) ;

			DebugTrace( (DWORD_PTR)this, "pEntry %x pRef %x", pEntry, pRef ) ;

			if( pEntry != 0 ) {
				//
				//	Just check some basic things here !
				//
				_ASSERT( !pEntry->IsCheckedOut() || cClientRefs != 0 ) ;
				_ASSERT( !pEntry->IsInLRUList() ) ;

				//
				//	Grab the lock on the entry !
				//
				if( pRef )	{
					pRef->ExclusiveLock() ;
					//
					//	This must be checked out of its native cache,
					//	otherwise it could be destroyed from under us !
					//
					_ASSERT( pRef->IsCheckedOut() ) ;
					_ASSERT( pRef->IsMatch( pDataIn ) ) ;
				}
				pEntry->ExclusiveLock() ;

				//
				//	Convert to an Exclusive Lock for inserting into
				//	the hash table !
				//
				m_Lock.FirstPartialToExclusive() ;

#ifdef	DEBUG
				//
				//	Periodically fail to insert into the hash table !
				//
				if( fTimeToFail() ) {
					fReturn = FALSE ;
				}	else
#endif
				fReturn = m_Lookup.InsertDataHashIter( iter, dwHash, &key, pEntry ) ;

				DebugTrace( (DWORD_PTR)this, "Insert results %x", fReturn ) ;

				//
				//	Both the global Cache Lock - m_Lock and
				//	the locks for pEntry must be released within the branches of
				//	this if !
				//
				if( fReturn ) {

					m_Lock.ExclusiveUnlock() ;

					m_ExpireList.IncrementItems() ;
		
					if( !pRef ) {
						//
						//	Ok, lets set up our Entry
						//
						pEntry->m_pData = pDataIn ;
						_ASSERT( pDataIn->m_pCacheRefInterface == 0 ) ;
						pDataIn->m_pCacheRefInterface = pEntry ;
					}	else	{
						//
						//	If the user checked this out of one cache, to make
						//	a reference in ours - he/she shouldn't ask us to add
						//	another check-out reference !
						//
						_ASSERT( cClientRefs == 0 ) ;
#ifdef	DEBUG
						//
						//	Periodically fail these operations !
						//
						if( fTimeToFail() ) {
							fReturn = FALSE ;
						}	else
#endif
						fReturn = pRef->InsertRef( pEntry, pDataIn, cClientRefs ) ;

						DebugTrace( (DWORD_PTR)this, "InsertRef Resutls - fReturn %x", fReturn ) ;

						//
						//	Failure at this point leaves a dangling dummy entry in
						//	the cache - we need to insure that expiration gets it !
						//
						if( !fReturn ) {
							pEntry->FailedCheckOut( &m_ExpireList,
													cClientRefs,
													0,
													0
													) ;
							_ASSERT( pEntry->m_pData == 0 ) ;
						}						
					}
					_ASSERT( (!fReturn && pEntry->m_pData==0) || (fReturn && pEntry->m_pData) ) ;
					_ASSERT( pDataIn->m_pCacheRefInterface != pEntry ||
							pEntry->m_pData == pDataIn ) ;
					pEntry->ExclusiveUnlock() ;
				}	else	{

					_ASSERT( pEntry->m_pData == 0 ) ;

					//
					//	Since the client provided this item, we set this to 0 as
					//	we have not been able to add a reference to the item !
					//	This prevents us from calling Release when our pEntry is destroyed !
					//
					pEntry->m_pData = 0 ;

					_ASSERT( pDataIn->m_pCacheRefInterface != pEntry ||
							pEntry->m_pData == pDataIn ) ;

					pEntry->ExclusiveUnlock() ;
					//
					//	Release back to the cache -did we have a client ref -
					//	have to get rid of that if necessary !
					//
					pEntry->FailedCheckOut( &m_ExpireList,
											cClientRefs,
											&m_Cache,
											&m_PerCacheData
											) ;
					//
					//	Let this go after we've accessed the allocation cache !
					//
					m_Lock.ExclusiveUnlock() ;
				}
				//
				//	Release any remaining locks !
				//
				if( pRef )	{
					//
					//	This must be checked out of its native cache,
					//	otherwise it could be destroyed from under us !
					//
					_ASSERT( pRef->IsCheckedOut() ) ;
					pRef->ExclusiveUnlock() ;
				}
			}	else	{
				//
				//	Either we found the item after all,
				//	or we were unable to allocate memory
				//	to make the container !
				//
				m_Lock.PartialUnlock() ;
			}
		}
	}
	return	fReturn ;
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx<Data, Key, Constructor, PerCacheData>::CheckIn(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	if( pData )	{
		CacheState*	p	 = (CacheState*)pData->m_pCacheRefInterface ;
		_ASSERT( p ) ;
		p->ExternalCheckIn( ) ;
	}
}


template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx<Data, Key, Constructor, PerCacheData>::CheckInNoLocks(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	if( pData )	{
		CacheState*	p	 = (CacheState*)pData->m_pCacheRefInterface ;
		_ASSERT( p ) ;
		p->ExternalCheckInNoLocks( ) ;
	}
}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
CacheEx<Data, Key, Constructor, PerCacheData>::CheckOut(
						Data*	pData,
						long	cClientRefs
						) {
/*++

Routine Description :

	This function is called when we want to add a client
	reference to something that is already in the cache !

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;
	_ASSERT( cClientRefs > 0 ) ;

	if( pData )	{
		CacheState*	p	 = (CacheState*)pData->m_pCacheRefInterface ;
		_ASSERT( p ) ;
		p->CheckOut( 0, cClientRefs ) ;
	}
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
MultiCacheEx< Data, Key, Constructor, PerCacheData >::MultiCacheEx() :
	m_fValid( FALSE ),
	m_pCaches( 0 ) ,
	m_cSubCaches( 0 ),
	m_pfnHash( 0 ) {
/*++

Routine Description :

	This function initializes the MultiCache's data structures

Arguments :

	None.

Return Value :

	Nothing

--*/
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
MultiCacheEx< Data, Key, Constructor, PerCacheData >::~MultiCacheEx()	{
/*++

Routine Description :

	This function destroys all of our data structures - release
	all of our subcaches !

Arguments :

	None.

Return Value :

	Nothing

--*/


	if( m_pCaches ) {

		delete[]	m_pCaches ;

	}

}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Init(
				PFNHASH	pfnHash,
				PKEYCOMPARE	pfnCompare,
				DWORD	dwLifetimeSeconds,
				DWORD	cMaxElements,
				DWORD	cSubCaches,
				CACHESTATS*	pStats,
				PSTOPHINT_FN pfnStopHint
				) {

/*++

Routine Description :

	This function initializes the MultiCache - we use
	multiple independent Caches to split the work
	of caching all the data.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( !m_fValid ) ;
	_ASSERT( m_pCaches == 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	pfnHash != 0 ) ;
	_ASSERT(	pfnCompare != 0 ) ;
	_ASSERT(	dwLifetimeSeconds != 0 ) ;
	_ASSERT(	cSubCaches != 0 ) ;
	_ASSERT(	cMaxElements != 0 ) ;

	m_pfnHash = pfnHash ;
	m_cSubCaches = cSubCaches ;

	//
	//	Allocate the necessary subcaches !
	//

	m_pCaches = new	CACHEINSTANCE[m_cSubCaches] ;

	if( !m_pCaches ) {
		return	FALSE ;
	}	else	{

		for( DWORD	i=0; i<cSubCaches; i++ ) {
			
			if( !m_pCaches[i].Init( m_pfnHash,
									pfnCompare,
									dwLifetimeSeconds,
									(cMaxElements / cSubCaches) + 1,
									pStats,
									pfnStopHint
									) ) {
				delete[]	m_pCaches ;
				m_pCaches = NULL;
				return	FALSE ;
			}
		}
	}
	m_fValid = TRUE ;
	return	TRUE ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
DWORD
MultiCacheEx< Data, Key, Constructor, PerCacheData >::ChooseInstance(
				DWORD	dwHash
				) {
/*++

Routine Description :

	Given a Key figure out which of our subinstances we wish to use.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( m_fValid ) ;
	_ASSERT( m_pCaches != 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	m_pfnHash != 0 ) ;
	_ASSERT(	m_cSubCaches != 0 ) ;

	
	//DWORD	dwHash = m_pfnHash( k ) ;
	
	//
	//	Constants below stolen from C-runtime rand() function !
	//

	dwHash = (((dwHash * 214013) +2531011) >> 8) % m_cSubCaches ;

	return	dwHash ;

}



template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx<Data, Key, Constructor, PerCacheData>::ExpungeItems(
			EXPUNGEOBJECT*	pExpunge
			) {
/*++

Routine Description :

	This function allows the user to remove a specific set of objects
	from the cache - a callback object is provided to visit each element !

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/


	TraceFunctEnter( "MultiCacheEx::ExpungeItems" ) ;

	BOOL	fReturn = TRUE ;

	for( DWORD i=0; i<m_cSubCaches; i++ ) {
		fReturn &= m_pCaches[i].ExpungeItems( pExpunge ) ;
	}

	return	fReturn ;
}


template	<	class	Data,
				class	Key,
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx<Data, Key, Constructor, PerCacheData>::ExpungeKey(
			PKEY	pKeyExpunge
			) {
/*++

Routine Description :

	This function allows us to remove a particular key from the cache !

Arguments :

	None

Return Value :

	TRUE if successfull
	FALSE - means that there are still items checked out of the cache -
		a NO-NO !

--*/


	TraceFunctEnter( "MultiCacheEx::ExpungeKey" ) ;
	DWORD	dw = m_pfnHash( pKeyExpunge ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	return	pInstance->ExpungeKey(	dw, pKeyExpunge ) ;
}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::FindOrCreate(
				Key&	key,
				Constructor&	constructor,
				BOOL	fEarlyCreate
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	DWORD	dw = m_pfnHash( &key ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	Data*	pDataOut = 0 ;

	BOOL	fSuccess = pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut, fEarlyCreate ) ;
	_ASSERT( fSuccess || pDataOut == 0 ) ;
	
	return	pDataOut ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::FindOrCreate(
				DWORD	dw,
				Key&	key,
				Constructor&	constructor,
				BOOL	fEarlyCreate
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	_ASSERT( dw == m_pfnHash( &key ) ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	Data*	pDataOut = 0 ;
	BOOL	fSuccess = pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut ) ;
	_ASSERT( fSuccess || pDataOut == 0 ) ;
	
	return	pDataOut ;
}




template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Find(
				Key&	key
				) {
/*++

Routine Description :

	Given the key of an element - find it in the cache !

Arguments :

	None.

Return Value :

	Nothing

--*/

	DWORD	dw = m_pfnHash( &key ) ;
	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->FindInternal( dw, key ) ;
}




template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
Data*
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Find(
				DWORD	dw,
				Key&	key
				) {
/*++

Routine Description :

	Given the key of an element - find it in the cache !

Arguments :

	None.

Return Value :

	Nothing

--*/

	_ASSERT( dw == m_pfnHash( &key ) ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->FindInternal( dw, key ) ;
}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx<Data, Key, Constructor, PerCacheData>::CheckIn(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	CACHEINSTANCE::CheckIn( pData ) ;

}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx<Data, Key, Constructor, PerCacheData>::CheckInNoLocks(
						Data*	pData
						) {
/*++

Routine Description :

	This function is called when we want to return something
	to the cache.

Arguments :

	p - the item being returned to the cache.	

Return Value :

	none

--*/

	_ASSERT( pData ) ;

	CACHEINSTANCE::CheckInNoLocks( pData ) ;

}



template	<	class Data, class Key,
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx<Data, Key, Constructor, PerCacheData>::CheckOut(
						Data*	pData,
						long	cClientRefs
						) {
/*++

Routine Description :

	This function is called when we want to add a client
	reference to something in the cache !

Arguments :

	p - the item checked out of the cache !

Return Value :

	none

--*/

	_ASSERT( pData ) ;
	_ASSERT( cClientRefs > 0 ) ;

	CACHEINSTANCE::CheckOut( pData, cClientRefs ) ;

}



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
void
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Expire() {
/*++

Routine Description :

	Remove old items from the cache !

Arguments :

	None.

Return Value :

	Nothing

--*/

	for( DWORD i=0; i<m_cSubCaches; i++ ) {
		m_pCaches[i].Expire( ) ;
	
	}
}



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Insert(
				Key&	key,
				Data*	pData,
				long	cClientRefs
				) {
/*++

Routine Description :

	Given the key of an element and a piece of data - insert it
	into the cache !

Arguments :

	key - key of the item being inserted into the cache
	pData - The data item to go into the cache
	cClientRefs - the number of client references we want to stick on the item !

Return Value :

	TRUE if successfull

--*/

	DWORD	dw = m_pfnHash( &key ) ;
	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->InsertInternal( dw, key, pData, cClientRefs ) ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				class	PerCacheData
				>
BOOL
MultiCacheEx< Data, Key, Constructor, PerCacheData >::Insert(
				DWORD	dw,
				Key&	key,
				Data*	pData,
				long	cClientRefs
				) {
/*++

Routine Description :

	Given the key of an element - find it in the cache !

Arguments :

	dw - hash of the key !
	key - key of the item being inserted into the cache
	pData - The data item to go into the cache
	fReference - do we want the item checked out !

Return Value :

	TRUE if successfull

--*/

	_ASSERT( dw == m_pfnHash( &key ) ) ;
	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;
	return	pInstance->InsertInternal( dw, key, pData, cClientRefs ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cintrnl.h ===
/*++

	cintrnl.h

	This file contains internal definitions for the cache library -
	this stuff should not be of interest for most users.

--*/

#ifndef	_CINTRNL_H_
#define	_CINTRNL_H_

class	CScheduleThread {
/*++

Class Description :

	This is a base class for those objects which wish to be
	called on a regularily scheduled basis.

	The constructors for this class will automatically
	put the object in a doubly linked list walked by a
	background thread which periodically executes a virtual function.


--*/
private :

	//
	//	Special constructor for the 'Head' element of the
	//	doubly linked list this class maintains.
	//
	CScheduleThread( BOOL	fSpecial ) ;
	
protected :

	//
	//	Has the scheduler been initialized ?
	//
	static	BOOL			s_fInitialized ;

	//
	//	Crit sect protecting doubly linked list.
	//
	static	CRITICAL_SECTION	s_critScheduleList ;

	//
	//	Handle to event used to terminate background thread.
	//
	static	HANDLE			s_hShutdown ;

	//
	//	Handle to background thread.
	//
	static	HANDLE			s_hThread ;

	//
	//	The head element of the doubly linked list.
	//
	static	CScheduleThread		s_Head ;

	//
	//	The thread which calls our virtual functions
	//
	static	DWORD	WINAPI	ScheduleThread(	LPVOID	lpv ) ;

	//
	//	Previous and Next pointers which maintain doubly linked
	//	list of scheduled itesm.
	//
	class	CScheduleThread*	m_pPrev ;
	class	CScheduleThread*	m_pNext ;

protected :

	//
	//	Derived classes should override this function -
	//	it will be called on a regular basis by the scheduler thread.
	//
	virtual	void	Schedule( void ) {}

	//
	//	Constructor and Destructor automagically manage
	//	insertion into doubly linked list of other scheduled items.
	//	These are protected as we want people to buid only
	//	derived objects which use this.
	//
	CScheduleThread() ;

	//
	//	Member functions which put us into the regular schedule !
	//
	void	AddToSchedule() ;
	void	RemoveFromSchedule() ;
		
public :

	//
	//	Initialize the class - don't construct
	//	any derived objects before this is called.
	//
	static	BOOL	Init() ;

	//
	//	Terminate class and background thread !
	//
	static	void	Term() ;

	//
	//	Global which tells clients how frequently they
	//	will be called !	
	//
	static	DWORD	dwNotificationSeconds ;

	//
	//	Destructor is protected - we should only be invoked
	//	by derived class constructors
	//
	virtual	~CScheduleThread() ;

} ;




class	CacheState : public	ICacheRefInterface	{
/*++

Class Description :

	This class will provide the base support for LRU
	removal of items in the cache !

Base Class :

	CQElement - we put these objects into
		a TLockQueue to amortize LRU operations !

--*/
private :

	//
	//	The following operations are not allowed !
	//
	CacheState() ;
	CacheState( CacheState& ) ;
	CacheState&	operator=( CacheState& ) ;

	//
	//	Tell us if this entry is older than the specified time !
	//
	BOOL
	OlderThan( FILETIME&	filetime )	{
		return	CompareFileTime( &m_LastAccess, &filetime ) <= 0 ;
	}

protected :

	//
	//	The LRU List which holds all of these items gets to
	//	know are innards !
	//
	friend	class	CLRUList ;

	//
	//	For debug purposes - make the memory recognizable !
	//
	DWORD	m_dwSignature ;

	//
	//	The lock used to protect operations within the derived
	//	classes of this object - most operations within this class
	//	don't require locking, however all derived classes need
	//	various locking services, so we provide one lock for all users !
	//
	CACHELOCK		m_lock ;

	//
	//	Our signaure, and constants for supporting us implementing two
	//	kinds of reference counts !
	//
	enum	CACHESTATE_CONSTANTS	{
		CACHESTATE_SIGNATURE = 'hcaC',
		CLIENT_REF	= 0x10000,
		CLIENT_BITS = 0xFFFF0000
	} ;

	//
	//	Keep a reference count - number of references holding
	//	this in memory !
	//	NOTE : we hold two types of references in here -
	//	regular references added by AddRef() and Release()
	//	which are references from other caches
	//	As well as client references.  To Add a client reference
	//	add CLIENT_REF atomically to this !
	//
	volatile	long	m_cRefs ;

	//
	//	a long that we use as a lock for calls to LRUReference
	//
	volatile	long	m_lLRULock ;

	//
	//	The last time this was touched - helps LRU algorithm !
	//
	FILETIME	m_LastAccess ;

	//
	//	The LRU List that owns this object !
	//
	public:	class	CLRUList*	m_pOwner ;

	//
	//	Pointers to maintain doubly linked list of
	//	items in the LRU chain !
	//
	protected:	DLIST_ENTRY	m_LRUList ;

	//
	//	structure to keep track of all the References to a
	//	particular item ! - note m_lock is used to protect
	//	access to this list
	//
	DLIST_ENTRY		m_ReferencesList ;

	//
	//	The field used to chain in Hash Table buckets
	//
	DLIST_ENTRY	m_HashList ;


	//
	//	This Constructor is protected as we only ever want to see
	//	classes derived from this thing created !
	//
	CacheState(	class	CLRUList*,
				long	cClientRefs = 1
				) ;

	//
	//	Destructor must be virtual - lots of derived classes !
	//
	virtual	~CacheState() ;

	//
	//	Touch the structure in a fashion so that the LRU state
	//	is updated !
	//
	void
	LRUReference(	class	CLRUList*	pLRU ) ;

	//
	//	calling this function insures that the correct Destructor is called !
	//
	void	virtual
	Destroy(	void*	pv	) = 0 ;

	//
	//	Reference counting support - Add a reference
	//
	long
	AddRef() ;

	//
	//	Keeping track of clients - remove a client ref !
	//
	long	
	CheckIn(	class	CAllocatorCache* pAlloc = 0
				) ;

	//
	//	Keeping track of clients - remove a client ref !
	//
	long	
	CheckInNoLocks(	class	CAllocatorCache* pAlloc = 0
				) ;

	virtual
	BOOL
	IsMasterReference()	{
		return	TRUE ;
	}

	virtual
	CacheState*
	GetMasterReference()	{
		return	this ;
	}

	CacheState*
	AddRefMaster( )	{
		TraceFunctEnter( "CacheState::AddRefMaster()" ) ;
		m_lock.ShareLock() ;		
		CacheState*	pReturn = GetMasterReference() ;
		if( pReturn ) {
			long l = pReturn->AddRef() ;
			DebugTrace( DWORD_PTR(pReturn), "Added a reference to %x this %x", pReturn, this ) ;
		}
		m_lock.ShareUnlock() ;
		return	pReturn ;
	}


public :

#ifdef	DEBUG
	//
	//	The number of these things that have been allocated !
	//
	static	long	g_cCacheState ;
#endif


	//
	//	Remove a reference - when we return 0 we're destroyed !
	//
	long
	Release(	class	CAllocatorCache	*pAlloc,
				void*	pv
				) ;

	//
	//	Provided to deal with failures during initialization of items
	//	being insert into the cache - this function ensures that the
	//	cache item ends up on the list for destruction !
	//
	void
	FailedCheckOut(	class	CLRUList*	p,
					long	cClientRefs,
					CAllocatorCache*	pAllocator,
					void*	pv
					) ;

	//
	//	For allocating these we use this special operator new
	//	which goes through our allocation cache !
	//
	//	NOTE : We take a reference because the cache MUST be provided !
	//
	void*
	operator	new(	size_t size,
						class CAllocatorCache&	cache
						) {
		return	cache.Allocate( size ) ;
	}

	//
	//	Exclusive Lock ourselves !
	//
	void
	ExclusiveLock()	{
		m_lock.ExclusiveLock() ;
	}

	//	
	//	Unlock ourselves
	//
	void
	ExclusiveUnlock()	{
		m_lock.ExclusiveUnlock() ;
	}

	//
	//	Keeping track of clients - Add a client ref !
	//
	long
	CheckOut(	class	CLRUList*	p,
				long	cClientRefs = 1
				)	;

	long
	ExternalCheckIn( ) ;

	long
	ExternalCheckInNoLocks( ) ;

	//
	//	Check to see whether this element is still referenced
	//	by the hash table containing the cache !
	//
	BOOL
	InCache()	{
		return	!m_HashList.IsEmpty() ;
	}

	//
	//	Check to see whether any Cache clients have a
	//	reference to this item !
	//	Return TRUE if any clients have added a reference !
	//
	BOOL	
	IsCheckedOut()	{
		_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
		return	(m_cRefs & CLIENT_BITS) != 0 ;
	}

	//
	//	Return TRUE if this item is in our LRU list !
	//
	BOOL
	IsInLRUList()	{
		_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
		//	return whether we are in the LRU List !
		return	!m_LRUList.IsEmpty() ;

	}

#ifdef	DEBUG
	//
	//	This is used in _ASSERT's and stuff to check that the cache is correctly ordered
	//	by time !
	//
	BOOL
	IsOlder(	FILETIME	filetimeIn,
				FILETIME&	filetimeOut
				) ;
#endif

	//
	//	The following support functions are used to support manipulating
	//	these objects in the various kinds of doubly linked lists we may reside in
	//
	//
	BOOL
	FLockCandidate(	BOOL	fExpireChecks,
					FILETIME&	filetime,
					BOOL&	fToYoung
					) ;

	//
	//	The following function locks an element of the cache.
	//	If this is the master cache entry, we will also look all associated items and return TRUE.
	//	If this is not the master, we lock only the one entry !
	//
	BOOL
	FLockExpungeCandidate(	CacheState*&	pMaster	) ;

	//
	//	This function pairs with FLockExpungeCandidate()
	//
	void
	ReleaseLocks(	CacheState*	pMaster ) ;

	//
	//	This is the other half of FLockExpungeCandidate -
	//	we ensure the destruction of the selected item !
	//
	void
	FinishCandidate(	CacheState*	pMaster ) ;

	//
	//	The following is not thread safe and is only for use during
	//	shutdown, where there should be no thread issues !
	//
	void
	IsolateCandidate() ;

	//
	//	This removes the item from the LRU List - Cache lock must be held exclusive or partially !
	//
	void
	RemoveFromLRU() ;

	//
	//	Define the Pointer to Function type that is so usefull
	//	for using the DLIST templates !
	//
	typedef		DLIST_ENTRY*	(*PFNDLIST)( class	CacheState* pState ) ;

	//
	//	Helper function for Doubly linked lists of these items in the
	//	Cache's hash tables !
	//
	inline	static
	DLIST_ENTRY*
	HashDLIST(	CacheState*	p ) {
		return	&p->m_HashList ;
	}

	//
	//	Helper function for Doubly linked lists of these items in the
	//	LRU lists
	//
	inline	static
	DLIST_ENTRY*
	LRUDLIST(	CacheState* p ) {
		return	&p->m_LRUList ;
	}

	//
	//	Helper function for Doubly linked lists of these items in
	//	the reference lists - the list of items referencing the same
	//	cache item !
	//
	inline	static
	DLIST_ENTRY*
	REFSDLIST(	CacheState*	p )	{
		return	&p->m_ReferencesList ;
	}
} ;




//
//	Now Define some Doubly Linked Lists that we can use to manipulate the
//	items in the cache in various ways !
//
typedef	TDListHead< CacheState, &CacheState::LRUDLIST	>	LRULIST ;
typedef	TDListHead< CacheState,	&CacheState::REFSDLIST	>	REFSLIST ;
typedef	TDListIterator<	REFSLIST >	REFSITER ;


class	CacheTable :	public	CScheduleThread	{
/*++

Class	Description :

	This class defines a call back interface which we hand to
	the LRU List to manipulate the items in the cache !

--*/
public :
	//
	//	Get the lock we use for manipulating the lock state of the table !
	//
	virtual	CACHELOCK&	
	GetLock() = 0 ;

	//
	//	Remove an item from the Cache's hash table !
	//
	virtual	BOOL
	RemoveEntry(
			CacheState*	pEntry
			) = 0 ;

	//
	//	Ask if we want to remove this particular item !
	//
	virtual	BOOL	
	QueryRemoveEntry(	
			CacheState*	pEntry
			) = 0 ;

} ;


class	CLRUList	{
/*++

Class Description :

	This class implements our LRU algorithms and selects
	the elements that are to be deleted from the cache !

--*/
private :

	//
	//	The head of the LRU List !
	//
	LRULIST		m_LRUList ;

	//	
	//	A list of items that have been touched in the LRU List !
	//
	TLockQueue<	CacheState >	m_lqModify ;	

	//
	//	Maximum number of elements we should hold in this cache !
	//
	DWORD		m_cMaxElements ;

	//
	//	Number of items we inserted !
	//
	DWORD		m_dwAverageInserts ;

	//
	//	Number of items NOT in the LRU List !
	//
	DWORD		m_cCheckedOut ;

	//
	//	The number of subtract from the current time to
	//	determine our expire date !
	//
	ULARGE_INTEGER	m_qwExpire ;

	//
	//	This function actually selects the items that will be expired
	//
	void
	SelectExpirations(	DLIST_ENTRY&	expireList ) ;

	//
	//	Do the expires !
	//
	DWORD
	DoExpirations(	DLIST_ENTRY&	expireList ) ;
	
	//
	//	Don't allow copies!
	//
	CLRUList( CLRUList& ) ;
	CLRUList&	operator=( CLRUList& ) ;
	

public :

	//
	//	Number of items in the cache !
	//
	long		m_cItems ;

	//CLRUList(	ULARGE_INTEGER	qwExpire ) ;
	CLRUList() ;

	//
	//	Initialize the LRU List with the parameters
	//	controlling the maximum number of elements and the time to live !
	//
	void
	Init(	DWORD	cMaxInstances,
			DWORD	cLifeTimeSeconds
			) ;

	//
	//	Something has changed - put it in the list of items needing
	//	to be examined !
	//	
	//	This function should only be called when the containing cache has
	//	a lock on the cache !
	//
	void
	AddWorkQueue( 	CacheState*	pbase ) ;

	//
	//	This function examines each item in the Work Queue and does
	//	appropriate processing !
	//
	void
	ProcessWorkQueue(	CAllocatorCache*	pAllocCache,
						LPVOID				lpv
						) ;

	//
	//	This function drains each item out of the Work Queue and releases
	//	them - called during shutdown/destruction of a cache !
	//
	void
	DrainWorkQueue() ;

	//
	//	Bump the number of items in the cache !
	//
	long
	IncrementItems()	{
		return	InterlockedIncrement( &m_cItems ) ;
	}

	//
	//	Decrease the number of items in the cache !
	//
	long
	DecrementItems()	{
		return	InterlockedDecrement( &m_cItems ) ;
	}

	//
	//	Do the work required to expire an item !
	//
	void
	Expire(	CacheTable*	pTable,
			CAllocatorCache*	pCache,
			DWORD&	countExpired,
			void*	pv	//per cache data !
			) ;

	BOOL
	Empty(	CacheTable*	pTable,
			CAllocatorCache*	pCache,
			void*	pv
			) ;


	//
	//	Remove a random set of elements in the table !
	//
	void
	ExpungeItems(	
				CacheTable*	pTable,
				DWORD&	countExpunged
				) ;

} ;



template<	class	Data
			>
class	CCacheItemBase :	public	CacheState 	{
/*++

Class Desceription :

	This class provides the interface defination for
	items in the cache which may or may not hold the
	key as well within the cache !

Arguments :

	Data - the item we will hold within the Cache

--*/
protected:

	//
	//	Constructor - initialize stuff to zero !
	//
	CCacheItemBase(	class	CLRUList*	p,
					Data*	pData,
					BOOL	fClientRef
					) :
		CacheState( p, fClientRef ),
		m_pData( pData ) {
	}

	~CCacheItemBase()	{
		//
		//	Somebody else must free our data elements !
		//
		_ASSERT(m_pData == 0 ) ;
	}

	BOOL
	IsMasterReference()	{

		return
			m_pData == 0 ||
			m_pData->m_pCacheRefInterface == this ;
	}

	CacheState*
	GetMasterReference( )	{
		if( m_pData == 0 ) {
			return	this ;
		}	
		return	(CacheState*)m_pData->m_pCacheRefInterface ;
	}

public :

	//
	//	The actual item we are holding within the Cache !
	//
	Data*	m_pData ;

	//
	//	Check that our data items match !
	//	used for _ASSERT's
	//
	BOOL
	IsMatch(	Data*	p ) {
		return	p == m_pData ;
	}

	//
	//	Must be able extract the Data Item !
	//
	Data*
	PublicData(	class	CLRUList*	p	)	{
	/*++
	
	Routine Description :

		This function adds a client reference to an item in the cache,
		and sets up the necessary LRU Manipulations!
		We also return the data pointer to the client, and add a reference
		to ourselves to keep track of !

	Arguments :

		p - the LRUList that owns us !

	Return Value :

		Pointer to the Data item we contain - can be NULL !

	--*/
		TraceFunctEnter( "CCacheItemBase::PublicData" ) ;

		_ASSERT( p != 0 ) ;
		_ASSERT( p == m_pOwner ) ;

		Data*	pReturn = 0 ;
		m_lock.ShareLock() ;

		DebugTrace( (DWORD_PTR)this, "m_pData %x m_pCacheRef %x",
			m_pData, m_pData ? m_pData->m_pCacheRefInterface : 0 ) ;

		if( m_pData ) {
			CacheState*	pState = (CacheState*)m_pData->m_pCacheRefInterface ;
			pState->CheckOut( p ) ;
			pReturn = m_pData ;
		}

		//
		//	If there's no data in this item - it must not be checked out !
		//
		_ASSERT( pReturn || !IsCheckedOut() ) ;
	
		m_lock.ShareUnlock() ;
		return	pReturn ;
	}

	//
	//	This is called when the locks are NOT held -
	//	do all the correct logic for setting this item up !
	//
	BOOL
	SetData(	Data*	pData,
				CLRUList*	pList,
				long	cClientRefs
				)	{
	/*++

	Routine Description :

		Make this Cache Element point to some piece of data that was provided
		by the end user.

		NOTE :
		The piece of data may be referenced by another cache - in which case
		we must work well with it !!!!

	Arguments :

		pData - the Item the client wants us to refer to with our key
		pList - the LRU List containing us !

		fReference - Is the client putting the item in the cache and not keeping
			his reference, this is TRUE if


	--*/

		TraceFunctEnter( "CCacheItemBase::SetData" ) ;

		BOOL	fReturn = FALSE ;

		_ASSERT( pData != 0 ) ;
		_ASSERT( pList != 0 ) ;
		_ASSERT( pList == m_pOwner ) ;

		DebugTrace( (DWORD_PTR)this, "pData %x pList %x cClientRefs %x", pData, pList, cClientRefs ) ;

		//
		//	Is this an item referenced by another cache -
		//	NOTE : IF it is an item from another Cache it MUST be checked out with a
		//	client reference !  The m_pCacheRefInterface of an item MUST NEVER CHANGED
		//	as long as an item is checked out by clients, so the following dereference
		//	is safe !
		//
		CCacheItemBase*	p = (CCacheItemBase*)pData->m_pCacheRefInterface ;

		DebugTrace( (DWORD_PTR)this, "Examined Item - m_pCacheRefInterface %x", p ) ;

		if( p != 0 ) {
			//
			//	In this scenario it is meaningless to access for a client reference -
			//	the client MUST have gotten one from the other cache !
			//
			_ASSERT( cClientRefs == 0 ) ;
			_ASSERT( p->IsCheckedOut() ) ;

			//
			//	Ok make our cache reference the same item !
			//
			fReturn = p->AddCacheReference( this, pData ) ;
			//	
			//	This can fail if the user tries to insert the same name twice !
			//
			//_ASSERT( fReturn ) ;
		}	else	{
			m_lock.ExclusiveLock() ;
			if( !m_pData ) {
				//
				//	The Cache should never have refences outstanding with
				//	the data pointer equal to NULL - so _ASSERT that we're
				//	not checked out by a client !
				//
				_ASSERT( !IsCheckedOut() ) ;
				//
				//	Now point to the data the client wants us to point at !
				//
				m_pData = pData ;
				pData->m_pCacheRefInterface = this ;
				//
				//	It worked - return TRUE !
				//
				fReturn = TRUE ;
				//
				//	Now we are checked out by a client !
				//
				if( cClientRefs )
					CheckOut( pList, cClientRefs ) ;
			}
			m_lock.ExclusiveUnlock() ;
		}
		return	fReturn ;
	}


	//
	//	Add an item to the list of caches referencing
	//	this cache item !
	//
	BOOL
	InsertRef(	CCacheItemBase<Data>*	p,
				Data*	pData,
				long	cClientRefs = 0
				)	{
	/*++

	Routine Description :

				


	--*/

		TraceFunctEnter( "CCacheItemBase::InsertRef" ) ;

		_ASSERT( p != 0 ) ;
		_ASSERT( pData != 0 ) ;
		_ASSERT( IsCheckedOut() ) ;
		_ASSERT( pData->m_pCacheRefInterface == this ) ;


		BOOL	fReturn = FALSE ;

		REFSITER	refsiter( &m_ReferencesList ) ;

		DebugTrace( (DWORD_PTR)this, "m_pData %x p %x p->m_pData %x cClientRefs %x",
			m_pData, p, p->m_pData, cClientRefs ) ;

		if( m_pData != 0 ) {
			//
			//	Now grab the second lock !
			//
			//	This _ASSERT isn't valid, the user can insert names that are already in use !
			//
			//_ASSERT( p->m_pData == 0 || p->m_pData == m_pData ) ;
			if( p->m_pData == 0 ) {
				//
				//	Insert p into the list of item in the list !
				//
				refsiter.InsertBefore( p ) ;

				//
				//	We've added another reference to ourself !
				//	This comes from another Cache item, so count it specially !
				//	
				long l = AddRef() ;

				DebugTrace( (DWORD_PTR)this, "AddRef result %x this %x p %x", l, this, p ) ;

				//
				//	Give a reference to the data we are holding !
				//
				p->m_pData = m_pData ;
				fReturn = TRUE ;
			}	else	if( p->m_pData == m_pData ) {
				fReturn = TRUE ;
			}
			//	This _ASSERT isn't valid, the user can insert names that are already in use !
			//
			//_ASSERT( p->m_pData == m_pData ) ;
		}

		if( fReturn && cClientRefs ) {
			CheckOut( m_pOwner, cClientRefs ) ;
		}
		return	fReturn ;
	}



	//
	//	Add an item to the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	AddCacheReference(	class	ICacheRefInterface*	pInterface,
						void*	pv,
						BOOL	fReference = FALSE
						)	{
	/*++

	Routine Description :

				


	--*/

		TraceFunctEnter( "CCacheItemBase::AddCacheReference" ) ;

		Data*	pData = (Data*)pv ;
		CCacheItemBase<Data>*	p = (CCacheItemBase<Data>*)pInterface ;
		BOOL	fReturn = TRUE  ;

		_ASSERT( pData != 0 ) ;
		_ASSERT( p != 0 ) ;

		REFSITER	refsiter( &m_ReferencesList ) ;

		DebugTrace( (DWORD_PTR)this, "pInterface %x pv %x fReference %x", pInterface, pv, fReference ) ;

		m_lock.ExclusiveLock() ;
		p->m_lock.ExclusiveLock() ;

		fReturn = InsertRef(	p,
								pData,
								fReference
								) ;

		p->m_lock.ExclusiveUnlock() ;
		_ASSERT( m_pData == pData ) ;
		m_lock.ExclusiveUnlock() ;

		return	fReturn ;
	}

	//
	//	Remove an item from the list of caches referencing
	//	this cache item !
	//
	virtual	BOOL
	RemoveCacheReference(	BOOL	fQueue	)	{

		TraceFunctEnter( "CCacheItemBase::RemoveCacheReference" ) ;

		DebugTrace( (DWORD_PTR)this, "m_pData %x m_pData->m_pCacheRefInterface %x",
			m_pData, m_pData ? m_pData->m_pCacheRefInterface: 0 ) ;

		m_pData = 0 ;

		//
		//	Well now - we're on our own - we should be expired !
		//
		if( fQueue )
			LRUReference( m_pOwner ) ;

		//
		//	p no longer has a reference - you can remove it !
		//
		return	FALSE ;
	}

	//
	//	Remove all references to the cache item !
	//
	virtual BOOL
	RemoveAllReferences( )	{

		return	FALSE ;
	}

} ;


template<	class	Data,
			class	Key,
			class	Constructor,
			class	PerCacheData
			>
class	CCacheItemKey : public	CCacheItemBase< Data > {
/*++

Class Description :

	This class item holds the key of the item we are
	referencing within the cache !
	We don't assume that the data objects hold the
	keys for us - we do this ourselves.

--*/
private :

	//
	//	This is the type of the key we are going to be holding !
	//
	Key		m_key ;

	//
	//	Make all these constructors and copiers private !
	//
	CCacheItemKey() ;
	CCacheItemKey&	operator=( CCacheItemKey& ) ;

protected :
	//
	//	Destroy ourselves
	//
	void
	Destroy(	void*	pv )	{
		TraceFunctEnter( "CCacheItemKey::Destroy" ) ;
		DebugTrace( (DWORD_PTR)this, "m_pData %x pv %x", m_pData, pv ) ;
		PerCacheData*	p = (PerCacheData*)pv ;
		if( m_pData )
			Constructor::StaticRelease( m_pData, pv ) ;
		m_pData = 0 ;			
		CCacheItemKey::~CCacheItemKey() ;
	}

public :

	~CCacheItemKey()	{
		if( m_pData ) {
			Constructor::StaticRelease( m_pData, 0 ) ;
			m_pData = 0 ;
		}
	}

	//
	//	Can only create by initializing the key !
	//
	CCacheItemKey(	class	CLRUList*	p,
					Key& k,
					Data*	pData,
					long	cClientRefs
					) :
		CCacheItemBase<Data>( p, pData, cClientRefs ),
		m_key( k ) {
	}

	Key*	GetKey()	{
		return	&m_key ;
	}


	//
	//	This is called when no locks are held - assumes
	//	that we may find that data is in the item, or that
	//	we need to build it !
	//
	Data*
	FindOrCreate(
				CACHELOCK&		cachelock,
				Constructor&	constructor,
				PerCacheData&	cachedata,
				CLRUList*		plrulist,
				class	CacheStats*		pStats
				)	{
	/*++

	Routine Description :

		This function executes our creation protocol with the client.

		The constructor.Create() function is called to create a partially
		constructed Item for the cache.  We will check if the returned item
		is referenced in another cache - if it is we will build the list
		of CacheState objects referencing the same cache item.		

		The caller assumes that cachelock is released by the time we return !
		
	Arguments :

		cachelock - The lock for the containing cache, we get this so that
			we can minimize the time it is held !
		constructor -
			The object that can build an item for the cache !
		cachedata -
			Some client data that they get for free !
		plrulist -
			The LRU list that we should use !

	Return Value :

		Pointer to a Data item if successfull !

	--*/

		TraceFunctEnter( "CCacheItemKey::FindOrCreate" ) ;

		_ASSERT( plrulist == m_pOwner || plrulist == 0 ) ;

		DebugTrace( (DWORD_PTR)this, "plrulist %x", plrulist ) ;

		Data*	pReturn = 0 ;
		//
		//	First look to see if there happens to be something here already !
		//
		m_lock.ShareLock() ;
		if( m_pData ) {

			DebugTrace( (DWORD_PTR)this, "m_pData %x m_pData->m_pCacheRefInterface %x",
				m_pData, m_pData->m_pCacheRefInterface ) ;
			//
			//	We've found this item constructed in the cache -	
			//	so check it out, AND put on the LRU work list !
			//
			CacheState*	pState = (CacheState*)m_pData->m_pCacheRefInterface ;
			pState->CheckOut( plrulist ) ;
			pReturn = m_pData ;
		}	
		m_lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "pReturn %x", pReturn ) ;
		
		//
		//	Did we find something !
		//
		if( pReturn  ) {
			//
			//	Because caller assumes this is unlocked - do so now !
			//
			cachelock.PartialUnlock() ;
		}	else	{
			//
			//	An item with no data - Must not be checked out !
			//
			_ASSERT( !IsCheckedOut() ) ;
			_ASSERT( m_pData == 0 ) ;

			//
			//	Partially build the data object we want to hold !
			//
			Data*	pData = constructor.Create( m_key, cachedata ) ;
	
			DebugTrace( (DWORD_PTR)this, "Created pData %x", pData ) ;

			if( !pData ) {
				//
				//	We failed - release our locks and go away !
				//
				cachelock.PartialUnlock() ;

			}	else	{
				
				//
				//	Figure out if we got a reference to an item already in the cache !
				//
				CCacheItemBase<Data>*	p = (CCacheItemBase<Data>*)pData->m_pCacheRefInterface ;

				//
				//	Grab the locks in the correct order for what we might need !
				//
				if( p )	{
					p->ExclusiveLock() ;
					//
					//	If he gave us an item, it must be checked out of whatever cache
					//	it came from - this ensures that it will not be destroyed while we
					//	access it, because we are not at the point of adding our own reference
					//	yet !
					//
					_ASSERT( p->IsCheckedOut() ) ;
					_ASSERT( p->IsMatch( pData ) ) ;
				}
				m_lock.ExclusiveLock() ;

				//
				//	Don't need to hold onto the cache anymore !
				//
				cachelock.PartialUnlock() ;

				DebugTrace( (DWORD_PTR)this, "Create path - pData %x p %x m_pData %x", pData, p, m_pData ) ;

				//
				//	Now do whatever is necessary to finish initialization ! -
				//	must always call Init() unless we're going to give up on this thing !
				//

				//
				//	We should not change state as long as we've been holding either
				//	the cachelock or our item lock up until this point - which is the case !
				//
				_ASSERT( m_pData == 0 ) ;


				if( pData->Init(	m_key,
									constructor,
									cachedata ) ) {
					if( !p ) {
						m_pData = pData ;
						pData->m_pCacheRefInterface = this ;
						pReturn = m_pData ;
						CheckOut( m_pOwner ) ;
					}	else	{
						//
						//	NOTE : If the client's constructor gave us an object from another
						//	cache they MUST add the client's reference for us - so we pass 0 to
						//	InsertRef(), so that we don't add yet another reference.
						//
						if( p->InsertRef( this, pData, 0 ) ) {
							//
							//	Insert Ref should setup our m_pData pointer !
							//
							_ASSERT( m_pData == pData ) ;
							pReturn = m_pData ;
						}
					}
				}

				DebugTrace( (DWORD_PTR)this, "Create path - pReturn %x", pReturn ) ;

				//
				//	NOTE :
				//	If pReturn==0 indicating some kind of error, than there should
				//	have been no client refs added at this point !
				//
				_ASSERT( pReturn || !IsCheckedOut() ) ;
				_ASSERT( pReturn == m_pData ) ;

				if( p ) {
					//
					//	If he gave us an item, it must be checked out of whatever cache
					//	it came from - this ensures that it will not be destroyed while we
					//	access it, because we are not at the point of adding our own reference
					//	yet !
					//
					_ASSERT( p->IsCheckedOut() ) ;
					p->ExclusiveUnlock() ;
				}

				if( pReturn ) {
					IncrementStat(	pStats, CACHESTATS::ITEMS ) ;
				}	else	{
					//
					//	Release the data item back to the user
					//	NOTE - Don't have the cachelock so can't give them
					//	the cachedata at this point !
					//
					constructor.Release( pData, 0 ) ;

					//
					//	Insure that we get onto the expiration list - this CACHEENTRY
					//	should be removed at some point !
					//
					FailedCheckOut( plrulist, FALSE, 0, 0 ) ;
				}
				//
				//	Release the locks - this can be done before we go down the 
				//	error path because we know that we won't get destroyed !
				//
				m_lock.ExclusiveUnlock() ;
			}
		}
		return	pReturn ;
	}
} ;








#endif	// _CINTRNL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cmmprops.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmprops.h

Abstract:

	This module contains the definition of the property search class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/02/98	created

--*/

#ifndef _PROPS_H_
#define _PROPS_H_

#include "blockmgr.h"
#include "propid.h"
#include "mailmsgprops.h"

/*

	This file defines a generice class for property tables. The following is
	the terminology used in relation to property tables:

	Search key - A value used to uniquely identify a property
	Property - A tuple consisting of a { Property Identifier, Value } pair.
	Property Identifier - the search key for the property table. The property
		table class does not restrict the data type or length of the property
		identifier, but rather, the caller must specify the length of the
		property identifier and provide a compare function when an instance
		of the property table is created.
	Value - A tuple consisting of a { Offset, Length } pair. The offset points
		to the physical location of the value and its length is specified by
		the Length element.
	Property Table - A collection of properties keyed off the designated
		property identifier. 

	A property table contains an instance info record (PROPERTY_TABLE_INSTANCE), 
	which describes the	parameters of the table, such as the length of each 
	property item record (PROPERTY_ITEM), how many items fit in a fragment
	(PROPERTY_TABLE_FRAGMENT), and a link to the first fragment.

	Fragments are linked together and thus a property table can hold an 
	arbitrarily larger number of properties, until the identifier space is
	exhausted. Fragments contain property item records, each item record
	contains an ordered tuple: { Offset, Length, Max Length, Property Identifier }
	In the definition of PROPERTY_ITEM, the Property Identifier element is not
	explicitly defined, but it is implied that whatever follows Max Length 
	is the property identifier. This allows maximum flexibility for different
	search key types. Similarly, although PROPERTY_TABLE_FRAGMENT does not
	include an array of PROPERTY_ITEMs, it is implied that an array of item
	records follow after faNextFragment. The size of the property identifier field 
	is specified during instance creation so the size of each property item 
	is fixed and known at run time.

	Since the property identifiers can be of different sizes, the creator must
	provide a function that knows how to compare a search key against a 
	property item.

	A memory manager must be specified when the property table is created.
	This provides a mechanism for memory to be allocated and released in 
	a linear, flat address space.
 */

// Define the well-known property item structure. We will have a sorted
// array of these items that make up the list of well-known properties.
// 
// Arrays of this type MUST be sorted for correct search results.
typedef struct _INTERNAL_PROPERTY_ITEM
{
	PROP_ID				idProp;			// Prop ID 
	DWORD				dwIndex;		// Reserved index of this prop ID

} INTERNAL_PROPERTY_ITEM, *LPINTERNAL_PROPERTY_ITEM;

// Define a generic structure to represent a property in the property
// table
// Each property table that uses this class as the accessor must have 
// an item structure that includes this structure as its first member
typedef struct _PROPERTY_ITEM
{
	FLAT_ADDRESS		faOffset;		// Offset in flat space to value
	DWORD				dwSize;			// Size of value data in bytes
	DWORD				dwMaxSize;		// Max size allocated for value

} PROPERTY_ITEM, *LPPROPERTY_ITEM;

// Define a generic structure to describe a fragment in the property table
typedef struct _PROPERTY_TABLE_FRAGMENT
{
	DWORD				dwSignature;	// Signature of fragment
	FLAT_ADDRESS		faNextFragment;	// Link to next fragment

} PROPERTY_TABLE_FRAGMENT, *LPPROPERTY_TABLE_FRAGMENT;

// Define a function type specifying the generic compare function passed
// into the search routine
//
// Arguments:
// LPVOID - pointer to search key value, the compare function must have
//          intimate knowledge of how to retrieve the property key from
//          the pointer and its size.
// LPPROPERTY_ITEM - pointer to item to compare against. The compare
//          function must have intimate knowledge of how to retrieve the
//          property key from the item pointer. The actual size of this
//          structure is in PROPERTY_TABLE_INSTANCE.dwItemSize.
//
// Return values:
// SUCCESS(HRESULT) - The item matches the search key
// !SUCCESS(HRESULT) - The item does not match the search key
//
typedef HRESULT (*LPPROPERTY_COMPARE_FUNCTION)(LPVOID, LPPROPERTY_ITEM);

// Define a generic structure to describe the property table instance
// Each property table that uses this class as the accessor must have 
// an instance structure that includes this structure as its first member
typedef struct _PROPERTY_TABLE_INSTANCE
{
	DWORD				dwSignature;	// Signature of instance
	FLAT_ADDRESS		faFirstFragment;// Link to first fragment
	DWORD				dwFragmentSize;	// Size of each fragment
	DWORD				dwItemBits;		// # lower bits that represent the item
	DWORD				dwItemSize;		// Size of a specific PROPERTY_ITEM
	DWORD				dwProperties;	// # properties in this instance
	FLAT_ADDRESS		faExtendedInfo;	// Link to any specific extended into

} PROPERTY_TABLE_INSTANCE, *LPPROPERTY_TABLE_INSTANCE;

// Enumerate the different applications of the property table
// This is used to track what kind of table we are looking at for debugging
typedef enum _PROPERTY_TABLE_TYPES
{
	PTT_INVALID_TYPE = 0,				// Default value
	PTT_PROPERTY_TABLE,					// Standard property table
	PTT_RECIPIENT_TABLE,				// Recipient table
	PTT_PROP_ID_TABLE					// Prop ID management table

} PROPERTY_TABLE_TYPES;

// Enumerate the different types of operations GetOrSetNextExistingItem
// supports
typedef enum _PROPERTY_ITEM_OPERATIONS
{
	PIO_INVALID_TYPE = 0,				// Default value
	PIO_READ_ITEM,						// Normal read
	PIO_WRITE_ITEM,						// Normal write
	PIO_ATOMIC_WRITE_ITEM				// Protected write

} PROPERTY_ITEM_OPERATIONS;

#include "cmmtypes.h"

// =================================================================
// class for accessing items from the property table. This class
// hides the details of fragmentation.
//
// This class is single-threaded
//
class CPropertyTableItem
{
  public:

    CPropertyTableItem(
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
				);
	~CPropertyTableItem();

	HRESULT AddItem(
				LPPROPERTY_ITEM pItem,
				DWORD			*pdwIndex,
                FLAT_ADDRESS    *pfaOffsetToItem = NULL
				);

	HRESULT UpdateItem(
				DWORD			dwIndex,
				LPPROPERTY_ITEM pItem,
                FLAT_ADDRESS    *pfaOffsetToItem = NULL
				);

	HRESULT GetItemAtIndex(
				DWORD			dwIndex,
				LPPROPERTY_ITEM pItem,
				LPFLAT_ADDRESS	pfaOffset = NULL
				);

	HRESULT GetNextItem(
				LPPROPERTY_ITEM pItem
				);

	HRESULT GetOffsetToCurrentItem(
				FLAT_ADDRESS	*pfaOffset
				)
	{ if (pfaOffset) *pfaOffset = m_faOffsetToCurrentItem; return(S_OK); }

  private:

	HRESULT GetOrSetNextExistingItem(
				// This looks at m_dwCurrentItem for index
				LPPROPERTY_ITEM pItem,
				DWORD			dwOperation,
				LPFLAT_ADDRESS	pfaOffset = NULL
				);
  
	HRESULT ReadFragmentFromFragmentNumber(
				DWORD			dwFragmentNumber
				);

	HRESULT ReadFragment(
				FLAT_ADDRESS	faOffset
				);

public:
	HRESULT ReadItem(
				FLAT_ADDRESS	faOffset,
				LPPROPERTY_ITEM	pItem
				);

private:
	HRESULT WriteItem(
				FLAT_ADDRESS	faOffset,
				LPPROPERTY_ITEM	pItem,
				BOOL			fAtomic
				);

    // Info of parent instance
	LPPROPERTY_TABLE_INSTANCE	m_pInstanceInfo;

	// Current fragment being processed
	BOOL						m_fLoaded;
	PROPERTY_TABLE_FRAGMENT		m_Fragment;
	DWORD						m_dwCurrentFragment;
	FLAT_ADDRESS				m_faOffsetToFragment;
	DWORD						m_dwCurrentItem;
	DWORD						m_dwCurrentItemInFragment;
	FLAT_ADDRESS				m_faOffsetToCurrentItem;
	
	// Memory manager pointer and context for fast access
	CBlockManager				*m_pBlockManager;
	CBlockContext				m_bcContext;
};

// =================================================================
// class for accessing an instance of a property table
//
class CPropertyTable
{
  public:

	CPropertyTable(
				PROPERTY_TABLE_TYPES		pttTableType,
				DWORD						dwValidSignature,
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo,
				LPPROPERTY_COMPARE_FUNCTION	pfnCompare,
				const LPINTERNAL_PROPERTY_ITEM	pInternalProperties	= NULL,
				DWORD						dwInternalProperties	= 0
				);
	~CPropertyTable();

	BOOL IsValid();
	BOOL IsInstanceInfoValid();

	//
	// Method to return the property count
	//
	// GetCount - Returns the current property count
	//
	// Arguments
	// pdwCount		- Pointer to DWORD to return count
	//
	// Return values
	//
	// S_OK						- Succeeded
	//
	HRESULT GetCount(
				DWORD		*pdwCount
				);

	//
	// Method to create or update a property item and value given a search key
	//
	// PutProperty - Creates the specified property if the property does not
	//				 exist, or updates the value of the property otherwise.
	//
	// Arguments
	// pvPropKey	- Pointer to the search key
	// pItem		- Pointer to the property item to write
	// dwSize		- Size of property value data
	// pbValue		- Pointer to property value data. If this value is NULL,
	//				  then no data is written, only the item record is created
	//				  or updated. dwSize must also be zero.
	//
	// Return values
	//
	// S_OK						- Succeeded, property already exists, but the
	//								value is updated as specified.
	// S_FALSE					- Succeeded, new property is created
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_WRITEFAULT			- Error, The write failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a write is issued to write past
	//								the current allocated block.
	//
	HRESULT PutProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem,
				DWORD			dwSize,
				LPBYTE			pbValue
				);

	//
	// Method to retrieve a property item given a search key
	//
	// GetPropertyItem - Attempts to find the property item specified by the
	//				 Search key. If found, the property item record will
	//				 be returned.
	//
	// Arguments
	// pvPropKey	- Pointer to the search key
	// pItem		- Pointer to the property item to return, sufficient space
	//				  must be allocated by the caller to hold the property item
	//
	// Return values
	//
	// S_OK						- Succeeded
	// STG_E_UNKNOWN			- Error, specified property not found.
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_READFAULT			- Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS - Debug Error, a read is issued to write past
	//								the current allocated block.
	//
	HRESULT GetPropertyItem(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	//
	// Method to retrieve a property item and its associated value
	//
	// GetPropertyItemAndValue - Attempts to find the property item specified 
	//				 by the Search key. If found, the property item record, as
	//				 well as the value data will be returned.
	//
	// Arguments
	// pvPropKey	- Pointer to the search key
	// pItem		- Pointer to the property item to return, sufficient space
	//				  must be allocated by the caller to hold the property item
	// dwLength		- Size of buffer allocated for value data
	// pdwLengthRead- Size of value data actually read, if the provided buffer is
	//				  insufficient, then the full length of the property data is
	//				  returned.
	// pbValue		- Pointer to return property value data.
	//
	// Return values
	//
	// S_OK						- Succeeded
	// STG_E_UNKNOWN			- Error, specified property not found.
	// HRESULT_FROM_WIN32(ERROR_MORE_DATA) - Error, the buffer provided is not
	//							large enough to hold all the value data.
	//							*pdwLengthRead returns the full length. *pItem
	//							would still return the item record in this case.
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_READFAULT			- Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS		- Debug Error, a read is issued to write past
	//								the current allocated block.
	//
	HRESULT GetPropertyItemAndValue(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem,
				DWORD			dwLength,
				DWORD			*pdwLengthRead,
				LPBYTE			pbValue
				);

	//
	// Method to retrieve a property item and its associated value, using an
	// internal index instead of a search key.
	//
	// GetPropertyItemAndValueUsingIndex - Attempts to find the property item 
	//				 specified by the Search key. If found, the property item 
	//				 record, as well as the value data will be returned.
	//
	// Arguments
	// dwIndex		- Index of item to retrieve, this is actually the dwIndex'th
	//				  item in the property table. One can walk the entire table
	//				  using this method.
	// pItem		- Pointer to the property item to return, sufficient space
	//				  must be allocated by the caller to hold the property item
	// dwLength		- Size of buffer allocated for value data
	// pdwLengthRead- Size of value data actually read, if the provided buffer is
	//				  insufficient, then the full length of the property data is
	//				  returned.
	// pbValue		- Pointer to return property value data.
	//
	// Return values
	//
	// S_OK						- Succeeded
	// STG_E_UNKNOWN			- Error, specified property not found.
	// HRESULT_FROM_WIN32(ERROR_MORE_DATA) - Error, the buffer provided is not
	//							large enough to hold all the value data.
	//							*pdwLengthRead returns the full length. *pItem
	//							would still return the item record in this case.
	// STG_E_INVALIDPARAMETER	- Error, one or more parameters are invalid, or
	//								otherwise inconsistent.
	// STG_E_READFAULT			- Error, The read failed to complete.
	// TYPE_E_OUTOFBOUNDS		- Debug Error, a read is issued to write past
	//								the current allocated block.
	//
	HRESULT GetPropertyItemAndValueUsingIndex(
				DWORD			dwIndex,
				LPPROPERTY_ITEM	pItem,
				DWORD			dwLength,
				DWORD			*pdwLengthRead,
				LPBYTE			pbValue
				);

  private:
  
	// Method to search the property table and return the associated
	// property item, if found
	HRESULT SearchForProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem,
				DWORD			*pdwIndexToItem,
				FLAT_ADDRESS	*pfaOffsetToItem
				);

    //
    // map a propid into an array index into m_rgWellKnownProps.  returns
    // -1 if the prop isn't well known
    //
    int MapCachedProp(DWORD iPropId) {
        if (m_cCachedProps &&
            iPropId >= m_iCachedPropsBase && 
            iPropId < m_iCachedPropsBase + m_cCachedProps)
        {
            int i = iPropId - m_iCachedPropsBase;
            _ASSERT(i < (int) m_cCachedProps);
            return i;
        } else {
            return -1;
        }
    }

    //
    // Initialize the property cache
    //
    void InitializePropCache();

    //
    // set an item in the property cache.  to invalidate an item pass in
    // INVALID_FLAT_ADDRESS for fa.
    //
    void UpdatePropCache(LPPROPERTY_ITEM pItem,
                         FLAT_ADDRESS fa,
                         DWORD dwIndex);

	DWORD						m_dwSignature;
	DWORD						m_dwTableType;
	DWORD						m_dwValidInstanceSignature;

	// Keep a local instance structure, and track the offset to the
	// copy in flat space
	PROPERTY_TABLE_INSTANCE		*m_pInstanceInfo;

	// List of well-known properties, we will use the count to determine
	// whether there are any well-known properties
	//
	// Note that well-known 
	LPINTERNAL_PROPERTY_ITEM	m_pInternalProperties;
	DWORD						m_dwInternalProperties;

	// Function pointer to do property comparisons
	LPPROPERTY_COMPARE_FUNCTION	m_pfnCompare;

	// Memory manager to use
	CBlockManager				*m_pBlockManager;

    // this structure is used for each item in the cache.  
    typedef struct {
        // the flat address for this item, or INVALID_FLAT_ADDRESS if its not in the cache
        FLAT_ADDRESS    fa;
        // its index
        DWORD           dwIndex;
    } PROPCACHEITEM;

    // array of cached property offsets for the predefined properties.
    // if its GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID
    // then this has the prop ids from IMMPID_MP_BEFORE+1 to IMMPID_MP_AFTER
    // otherwise this will be NULL
    //
    // There is no reason to cache recipient property offsets at this
    // time since the recipient property table is instantiated, used
    // once, then thrown away.  we'd spend more time making the cache
    // then the linear search in SearchForProperty costs
    PROPCACHEITEM              *m_rgCachedProps;
    DWORD                       m_iCachedPropsBase;
    DWORD                       m_cCachedProps;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\commsg.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    commsg.h

Abstract:

    HRESULT <-> Win32 error mapping macros.

Author:

    Michael W. Thomas (michth)   24-Sep-1996

Revision History:

    Keith Moore (keithmo)        07-Feb-1997
        Cleanup, comment, made Metadata errors "real" HRESULTs.

--*/


#ifndef _COMMSG_H_
#define _COMMSG_H_


//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))


//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#endif  // _COMMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cmmtypes.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmtypes.h

Abstract:

	This module contains the definition of the item and fragment types

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/09/98	created

--*/

#ifndef _CMMTYPES_H_
#define _CMMTYPES_H_

#include "cmmprops.h"


// =================================================================
// Private Definitions
//

// == GLOBAL PROPERTIES ==================================================

#define GLOBAL_PROPERTY_ITEM_BITS		5
#define GLOBAL_PROPERTY_ITEMS			(1 << (GLOBAL_PROPERTY_ITEM_BITS))

//
// Specific data structure for a global property item, note the default
// structures defined in props.h are used as preludes.
//
typedef struct _GLOBAL_PROPERTY_ITEM
{
	PROPERTY_ITEM		piItem;			// Default property item prelude
	PROP_ID				idProp;			// Property Id of item

} GLOBAL_PROPERTY_ITEM, *LPGLOBAL_PROPERTY_ITEM;

#define GLOBAL_PROPERTY_ITEM_SIZE			sizeof(GLOBAL_PROPERTY_ITEM)

//
// Specific data structure for a global property table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _GLOBAL_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT	ptfFragment;// Default fragment prelude
	GLOBAL_PROPERTY_ITEM	rgpiItems[GLOBAL_PROPERTY_ITEMS];	
										// Array of items

} GLOBAL_PROPERTY_TABLE_FRAGMENT, *LPGLOBAL_PROPERTY_TABLE_FRAGMENT;

#define GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(GLOBAL_PROPERTY_TABLE_FRAGMENT)


// == RECIPIENT LIST =====================================================

#define RECIPIENTS_PROPERTY_ITEM_BITS		5
#define RECIPIENTS_PROPERTY_ITEMS			(1 << (RECIPIENTS_PROPERTY_ITEM_BITS))

//
// Define the maximum number of hash keys supported
//
#define MAX_COLLISION_HASH_KEYS		5

//
// Define which address is of which type
//
typedef enum _ADDRESS_TYPE_INDICES
{
	AT_SMTP = 0,
	AT_X400,
	AT_X500,
	AT_LEGACY_EX_DN,
    AT_OTHER,
	AT_MAXAT
} ADDRESS_TYPE_INDICES;


//
// Specific data structure for a recipient item. This essentially contains
// an instance to the per-recipient property table
//
typedef struct _RECIPIENTS_PROPERTY_ITEM
{
	DWORD					dwFlags;		// Flags for this recipient
	FLAT_ADDRESS			faNameOffset[MAX_COLLISION_HASH_KEYS];	
											// Offset to each name
	DWORD					dwNameLength[MAX_COLLISION_HASH_KEYS];
											// Length of each name
	PROP_ID					idName[MAX_COLLISION_HASH_KEYS];
											// Prop ID of each name
	PROPERTY_TABLE_INSTANCE	ptiInstanceInfo;// Rcpt property table instance

} RECIPIENTS_PROPERTY_ITEM, *LPRECIPIENTS_PROPERTY_ITEM;

#define RECIPIENTS_PROPERTY_ITEM_SIZE			sizeof(RECIPIENTS_PROPERTY_ITEM)



class CMemoryAccess;

typedef struct _RECIPIENTS_PROPERTY_ITEM_HASHKEY {
    BYTE                                *pbKey;
    DWORD                               cKey;
} RECIPIENTS_PROPERTY_ITEM_HASHKEY;

#define RECIPIENTS_PROPERTY_ITEM_EX_SIG	'eipR'
//
// Specific data structure for a recipient item. This extends it to contain 
// in-memory structures for hashing and domain grouping
//
typedef struct _RECIPIENTS_PROPERTY_ITEM_EX
{
	DWORD								dwSignature;
    // reference counting on this object
    // there is always one reference for the list of recipients
    // there is an additional reference for each recipient hash table that
    // the item is in
    long                                m_cRefs;
    // hashkey for the domain
    RECIPIENTS_PROPERTY_ITEM_HASHKEY    rgHashKeys[MAX_COLLISION_HASH_KEYS];
	struct _RECIPIENTS_PROPERTY_ITEM_EX	*pNextHashEntry[MAX_COLLISION_HASH_KEYS];
														// Next entry in same hash bucket
	struct _RECIPIENTS_PROPERTY_ITEM_EX	*pNextInDomain;	// Next entry in same domain
	struct _RECIPIENTS_PROPERTY_ITEM_EX	*pNextInList;	// List used for deallocating
	RECIPIENTS_PROPERTY_ITEM			rpiRecipient;	// Recipient structure
} RECIPIENTS_PROPERTY_ITEM_EX, *LPRECIPIENTS_PROPERTY_ITEM_EX;

#define RECIPIENTS_PROPERTY_ITEM_SIZE_EX	sizeof(RECIPIENTS_PROPERTY_ITEM_EX)

//
// Specific data structure for a recipient table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _RECIPIENTS_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT		ptfFragment;// Default fragment prelude
	RECIPIENTS_PROPERTY_ITEM	rgpiItems[RECIPIENTS_PROPERTY_ITEMS];	
											// Array of items

} RECIPIENTS_PROPERTY_TABLE_FRAGMENT, *LPRECIPIENTS_PROPERTY_TABLE_FRAGMENT;

#define RECIPIENTS_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(RECIPIENTS_PROPERTY_TABLE_FRAGMENT)


// == PROPERTY MANAGEMENT ================================================

#define PROPID_MGMT_PROPERTY_ITEM_BITS		3
#define PROPID_MGMT_PROPERTY_ITEMS			(1 << (PROPID_MGMT_PROPERTY_ITEM_BITS))

//
// Specific data structure for a recipient item, note the default
// structures defined in props.h are used as preludes.
//
typedef struct _PROPID_MGMT_PROPERTY_ITEM
{
	PROPERTY_ITEM		piItem;			// Default property item prelude
	GUID				Guid;			// GUID identifying each reservation

} PROPID_MGMT_PROPERTY_ITEM, *LPPROPID_MGMT_PROPERTY_ITEM;

#define PROPID_MGMT_PROPERTY_ITEM_SIZE			sizeof(PROPID_MGMT_PROPERTY_ITEM)

//
// Specific data structure for a recipient table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _PROPID_MGMT_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT		ptfFragment;// Default fragment prelude
	PROPID_MGMT_PROPERTY_ITEM	rgpiItems[PROPID_MGMT_PROPERTY_ITEMS];	
											// Array of items

} PROPID_MGMT_PROPERTY_TABLE_FRAGMENT, *LPPROPID_MGMT_PROPERTY_TABLE_FRAGMENT;

#define PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(PROPID_MGMT_PROPERTY_TABLE_FRAGMENT)


// == RECIPIENT PROPERTIES ===============================================

#define RECIPIENT_PROPERTY_ITEM_BITS		3
#define RECIPIENT_PROPERTY_ITEMS			(1 << (RECIPIENT_PROPERTY_ITEM_BITS))

//
// Specific data structure for a recipient item, note the default
// structures defined in props.h are used as preludes.
//
typedef struct _RECIPIENT_PROPERTY_ITEM
{
	PROPERTY_ITEM		piItem;			// Default property item prelude
	PROP_ID				idProp;			// Property Id of item

} RECIPIENT_PROPERTY_ITEM, *LPRECIPIENT_PROPERTY_ITEM;

#define RECIPIENT_PROPERTY_ITEM_SIZE			sizeof(RECIPIENT_PROPERTY_ITEM)

//
// Specific data structure for a recipient table fragment, note
// the default structures defined in props.h are used as preludes.
//
typedef struct _RECIPIENT_PROPERTY_TABLE_FRAGMENT
{
	PROPERTY_TABLE_FRAGMENT	ptfFragment;// Default fragment prelude
	RECIPIENT_PROPERTY_ITEM	rgpiItems[RECIPIENT_PROPERTY_ITEMS];	
										// Array of items

} RECIPIENT_PROPERTY_TABLE_FRAGMENT, *LPRECIPIENT_PROPERTY_TABLE_FRAGMENT;

#define RECIPIENT_PROPERTY_TABLE_FRAGMENT_SIZE	sizeof(RECIPIENT_PROPERTY_TABLE_FRAGMENT)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cpool.h ===
//#---------------------------------------------------------------
//  File:		CPool.h
//        
//	Synopsis:	Header for the CPool class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------

#ifndef	_CPOOL_H_
#define _CPOOL_H_

#include "dbgtrace.h"

#define POOL_SIGNATURE	 			(DWORD)'looP' 
#define UPSTREAM_SIGNATURE 			(DWORD)'tspU' 
#define DOWNSTREAM_SIGNATURE 		(DWORD)'tsnD' 
#define AUTHENTICATION_SIGNATURE 	(DWORD)'htuA' 
#define USER_SIGNATURE 				(DWORD)'resU' 
#define PROXY_SIGNATURE 		    (DWORD)'xorP' 

#define	DEFAULT_ALLOC_INCREMENT		0xFFFFFFFF

//
// maximum number of VirtualAlloc chunks to allow
//

#define	MAX_CPOOL_FRAGMENTS			16


class CPool
{
		//
		// struct def'n for linking free instances
		// see page 473 of Stroustrup
		//
		struct	Link	{ Link*	pNext; };

	public:
		CPool( DWORD dwSignature=1 );
		~CPool( void );

	    void *operator new( size_t cSize )
						{ return HeapAlloc( GetProcessHeap(), 0, cSize ); }

	    void operator delete (void *pInstance)
						{ HeapFree( GetProcessHeap(), 0, pInstance ); }

#ifdef DEBUG
		void	IsValid( void );
#else
		inline void IsValid( void ) { return; }
#endif
		//
		// to be called after the constructor to VirtualAlloc the necessary
		// memory address
		//
		BOOL	ReserveMemory(	DWORD MaxInstances,
								DWORD InstanceSize,
								DWORD IncrementSize = DEFAULT_ALLOC_INCREMENT ); 

		BOOL	ReleaseMemory( void );

		void*	Alloc( void );
		void	Free( void* pInstance );

		DWORD	GetContentionCount( void );

		DWORD	GetEntryCount( void );

		DWORD	GetTotalAllocCount()
				{ return	m_cTotalAllocs; }

		DWORD	GetTotalFreeCount()
				{ return	m_cTotalFrees; }

		DWORD	GetTotalExtraAllocCount()
				{ return	m_cTotalExtraAllocs; }

		DWORD	GetCommitCount()
				{ return	m_cNumberCommitted; }

		DWORD	GetAllocCount()
				{ return	m_cNumberInUse; }

		DWORD	GetInstanceSize(void);

	private:
		//
		// internal function to alloc more mem from the OS
		//
		void 	GrowPool( void );
		//
		// Structure signature for a pool object
		// 
		const DWORD			m_dwSignature;
		//
		// total number of descriptors ( maximum )
		//
		DWORD				m_cMaxInstances;
		//
		// size of the descriptor
		//
		DWORD				m_cInstanceSize;
		//
		// virtual array number of committed instances
		//
		DWORD				m_cNumberCommitted;
		//
		// number of In_use instances ( debug/admin only )
		//
		DWORD				m_cNumberInUse;
		//
		// number of Free instances ( debug/admin only )
		//
		DWORD				m_cNumberAvail;
		//
		// the handle of the pool critical section
		//
		CRITICAL_SECTION	m_PoolCriticalSection;
		//
		// the pointer to the first descriptor on the free list
		//
		Link				*m_pFreeList;
		//
		// the pointer to a free descriptor not on the free list
		//
		Link				*m_pExtraFreeLink;
		//
		// number to increment the pool when expanding
		//
		DWORD				m_cIncrementInstances;

		//
		// Debug counters for perf testing ( debug/admin only )
		//
		DWORD				m_cTotalAllocs;
		DWORD				m_cTotalFrees;
		DWORD				m_cTotalExtraAllocs;

		//
		// Debug variables to help catch heap bugs
		//
		Link				*m_pLastAlloc;
		Link				*m_pLastExtraAlloc;

		//
		// size of each fragment in instances
		//
		DWORD				m_cFragmentInstances;

		//
		// maximum number of fragments
		//
		DWORD				m_cFragments;

		//
		// maximum number of fragments
		//
		LPVOID				m_pFragments[ MAX_CPOOL_FRAGMENTS ];
};



#endif //!_CPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\cpoolmac.h ===
//-----------------------------------------------------------------------------
//
//
//  File: CPoolMac.h
//
//  Description: Definitions of CPool Helper Macros.  Moved from transmem.h to
//      make it easier to use CPool without Exchmem (for COM dlls).
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _CPOOLMAC_H_
#define _CPOOLMAC_H_

#include <cpool.h>
#include <dbgtrace.h>

//If you would rather use Exchmem (or the default new & delete), 
//then define OVERRIDE_CPOOL
#ifndef OVERRIDE_CPOOL
    //Use after "public:" in class definition
    #define DEFINE_CPOOL_MEMBERS    \
                static CPool m_MyClassPool; \
                inline void *operator new(size_t size) {return m_MyClassPool.Alloc();}; \
                inline void operator delete(void *p, size_t size) {m_MyClassPool.Free(p);};
    //Use at top of classes CPP file
    #define DECLARE_CPOOL_STATIC(CMyClass) \
                CPool CMyClass::m_MyClassPool;
    //Use in "main" before any classes are allocated
    #define F_INIT_CPOOL(CMyClass, NumPreAlloc)  \
                CMyClass::m_MyClassPool.ReserveMemory(NumPreAlloc, sizeof(CMyClass))
    #define RELEASE_CPOOL(CMyClass) \
                {_ASSERT(CMyClass::m_MyClassPool.GetAllocCount() == 0);CMyClass::m_MyClassPool.ReleaseMemory();}
#else //use exchmem to track allocations 
    #define DEFINE_CPOOL_MEMBERS    
    #define F_INIT_CPOOL(CMyClass, NumPreAlloc) true
    #define RELEASE_CPOOL(CMyClass) 
#endif //OVERRIDE_CPOOL

#endif //_CPOOLMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\dt_ctrl.h ===
/////////////////////////////////////////////////////////////////////
// Common header file for the Date Time control dll:

/////////////////////////////////////////////////////////////////////
// Export or import functions depending on how we are compiled:

#if defined(DT_CTRL_LIB)
    #define DT_DLL_BASED
#elif defined(DT_CTRL_DLL)
    #define DT_DLL_BASED   __declspec(dllexport)
#else
    #define DT_DLL_BASED   __declspec(dllimport)
#endif

/////////////////////////////////////////////////////////////////////
//

// extern "C" {

DT_DLL_BASED BOOL WINAPI InitTimeAndDateControls (HINSTANCE);

// }

// Globals:

#define TIMECTRL_CLASS      ( __TEXT("GuiAdminTimeCtrl") )
#define TCM_GET_TIME		( WM_USER + 1800 )
#define TCM_SET_TIME		( WM_USER + 1801 )
#define TCM_SET_MODE		( WM_USER + 1802 )	
#define TCM_GET_MODE		( WM_USER + 1803 )

#define DATECTRL_CLASS      ( __TEXT("GuiAdminDateCtrl") )
#define DCM_GET_DATE		( WM_USER + 1900 )
#define DCM_SET_DATE		( WM_USER + 1901 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\dbsqltyp.h ===
/****************************************************************************************
 * NAME:        DBSQLTYP.H
 * MODULE:      DBSQL
 * AUTHOR:      Ross M. Brown
 *
 * HISTORY
 *      08/29/94  ROSSB      Created
 *		05/08/96  DanielLi	 Added Pxxxx defs
 *
 * OVERVIEW
 *
 * Includes basic Account database types for use by other services.
 * (See "acctapi.h" for api definitions.)
 *
 ****************************************************************************************/

#ifndef DBSQLTYP_H
#define DBSQLTYP_H

#include <windows.h>

typedef ULONG 	HACCT;
typedef HACCT 	*PHACCT;
typedef ULONG 	HOWNER;
typedef ULONG 	HPAYMENTMETHOD;
typedef int	  	TOKEN;
typedef TOKEN	*PTOKEN;
typedef WORD  	AR;
typedef AR		*PAR;
typedef ULONG	HGROUP;
typedef HGROUP	*PHGROUP;

//typedef ULONG TOKEN;

#endif // DBSQLTYP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\domhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       domhash.h
//
//  Contents:   Definition and public include for domain lookup table.
//
//  History:    SethuR -- Implemented
//              MikeSwa - Modified for Domain Name lookup 2/98
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DOMAIN_NAME_TABLE_ENTRY,DOMAIN_NAME_TABLE_BUCKET and the
//              DOMAIN_NAME_TABLE.
//
//              The DOMAIN_NAME_TABLE is a hash table of DOMAIN_NAME_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DOMAIN_NAME_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//  2/98        The major difference between the DFS version and the domain
//              name lookup is the size of the table, the ability for
//              wildcard lookups (*.foo.com), and the reverse order of the
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick
//              mapping of the major files is (for those familiar with the
//              DFS code):
//                  domhash.h    (prefix.h)  -   Public include file
//                  _domhash.h   (prefixp.h) -   Private inlcude file
//                  domhash.cpp  (prefix.c)  -   Implementation of API
//                  _domhash.cpp (prefixp.c) -   Private helper functions.
//
//              Many functions defined an C macros have been converted to C++
//              style inline functions to make debugging easier.
//
//              The public API has moved to be public member functions of
//              the DOMAIN_NAME_TABLE *class*.
//--------------------------------------------------------------------------

#ifndef __DOMHASH_H__
#define __DOMHASH_H__

#include <windows.h>
//#include <ole2.h>
//#include <mapicode.h>
#include <stdio.h>
//#include <string.h>

// Transport specific headers - every component should use these
#include "transmem.h"
//#include "baseobj.h"
#include <dbgtrace.h>
//#include <rwnew.h>

#include <tchar.h>
#include <stdlib.h>

//Macro to ensure uniformity of domain strings
#define INIT_DOMAIN_STRING(str, cbDomain, szDomain) \
{ \
    _ASSERT(_tcslen(szDomain)*sizeof(TCHAR) == cbDomain); \
    str.Length = (USHORT) (cbDomain); \
    str.MaximumLength = str.Length; \
    str.Buffer = (szDomain); \
}

//Macro to init global or stack declared domain strings with
//constant string values
#define INIT_DOMAIN_STRING_AT_COMPILE(String) \
        { \
            (sizeof(String)-sizeof(TCHAR)), /*Length*/ \
            (sizeof(String)-sizeof(TCHAR)), /*Maximum*/ \
            String                          /*String buffer*/ \
        }

//Define internal HRESULTs
#define	DOMHASH_E_DOMAIN_EXISTS		HRESULT_FROM_WIN32(ERROR_DOMAIN_EXISTS)
#define DOMHASH_E_NO_SUCH_DOMAIN	HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN)

#define WILDCARD_SIG            'dliW'
#define ENTRY_SIG               'yrtN'
#define DOMAIN_NAME_TABLE_SIG   'hsHD'

#ifndef PAGE_SIZE
#define PAGE_SIZE 4000
#endif //PAGE_SIZE

//---[ UNICODE/ANSI Macros ]---------------------------------------------------
//
//
//  The domain hashing function depend on a string structure like UNICODE_STRING
//  or ANSI_STRING.  If UNICODE is defined, unicode strings and the
//  UNICODE_STRING structure will be used... otherwise ANSI_STRING will be used
//
//  However, because of the splintering of the NT Headers, I cannot always
//  include the files that have ANSI_STRING and UNICODE_STRING defined
//-----------------------------------------------------------------------------
typedef     TCHAR *         PTCHAR;
typedef     TCHAR *         PTSTR;

typedef     struct _DOMAIN_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PTCHAR Buffer;
} DOMAIN_STRING, *PDOMAIN_STRING;

//+---------------------------------------------------------------------
//
// Struct:  DOMAIN_NAME_TABLE_ENTRY
//
// History: 2/98 modifed from DFS_PREFIX_TABLE_ENTRY by MikeSwa
//
// Notes:   Each DOMAIN_NAME_TABLE_ENTRY is in reality a member of two linked
//          lists -- a doubly linked list chaining the entries in a bucket
//          and a singly linked list establishing the path from any entry to
//          the root of the name space. In addition we have the data associated
//          with each entry, viz., the name and the data (pData). We also
//          keep track of the number of children of each entry. It can also
//          be defined as the number of paths to the root of which this entry
//          is a member.
//
//----------------------------------------------------------------------

typedef struct _DOMAIN_NAME_TABLE_ENTRY_
{
   DWORD                            dwEntrySig;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pParentEntry;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pNextEntry;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pPrevEntry;

   //
   // pFirstChildEntry and pSiblingEntry are used purely for enumeration
   //
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pFirstChildEntry;
   struct _DOMAIN_NAME_TABLE_ENTRY_ *pSiblingEntry;

   ULONG                            NoOfChildren;

   DOMAIN_STRING                    PathSegment;
   PVOID                            pData;
   DWORD                            dwWildCardSig;
   PVOID                            pWildCardData;
} DOMAIN_NAME_TABLE_ENTRY, *PDOMAIN_NAME_TABLE_ENTRY;

//+---------------------------------------------------------------------
//
// Struct:  DOMAIN_NAME_TABLE_BUCKET
//
// History: 2/8 modified from DFS_PREFIX_TABLE_BUCKET
//
// Notes:   The DOMAIN_NAME_TABLE_BUCKET is a doubly linked list of
//          DOMAIN_NAME_TABLE_ENTRY's. The current implementation employs
//          the notion of a sentinel entry associated with each bucket. The
//          end pointers are never null but are always looped back to the
//          sentinel entry. The reason we employ such an organization is that
//          it considerably simplifies the list manipulation routines. The
//          reason this needs to be a doubly linked list is that we would like
//          to have the ability of deleting entries without having to traverse
//          the buckets from beginning.
//
//          The following inline methods ( macro defns. ) are provided for
//          inserting, deleting and looking up an entry in the bucket.
//
//----------------------------------------------------------------------

typedef struct _DOMAIN_NAME_TABLE_BUCKET_
{
   ULONG                    NoOfEntries;   // High water mark for entries hashing to the bkt.
   DOMAIN_NAME_TABLE_ENTRY  SentinelEntry;
} DOMAIN_NAME_TABLE_BUCKET, *PDOMAIN_NAME_TABLE_BUCKET;

//+---------------------------------------------------------------------
//
// Struct:  NAME_PAGE
//
// History:
//
// Notes:   The name segments associated with the various entries are all
//          stored together in a name page. This allows us to amortize the
//          memory allocation costs over a number of entries and also allows
//          us to speed up traversal ( for details see DOMAIN_NAME_TABLE
//          definition ).
//
//----------------------------------------------------------------------

#define FREESPACE_IN_NAME_PAGE ((PAGE_SIZE - sizeof(ULONG) - sizeof(PVOID)) / sizeof(TCHAR))

typedef struct _NAME_PAGE_
{
   struct _NAME_PAGE_  *pNextPage;
   LONG                cFreeSpace; // free space avilable in TCHAR's
   TCHAR               Names[FREESPACE_IN_NAME_PAGE];
} NAME_PAGE, *PNAME_PAGE;

typedef struct _NAME_PAGE_LIST_
{
   PNAME_PAGE  pFirstPage;
} NAME_PAGE_LIST, *PNAME_PAGE_LIST;

//+---------------------------------------------------------------------
//
// Struct:  DOMAIN_NAME_TABLE
//
// History: 2/98 modified from DFS_PREFIX_TABLE
//
// Notes:   The DOMAIN_NAME_TABLE is a hashed collection of DOMAIN_NAME_TABLE_ENTRY
//          organized in the form of buckets. In addition one other space
//          conserving measure is adopted. There is only one copy of each
//          name segment stored in the table. As an example consider the
//          two name foo.bar and bar.foo. We only store one copy of foo
//          and bar eventhough we accomdate both these paths. A beneficial
//          side effect of storing single copies is that our traversal of the
//          collision chain is considerably speeded up since once we have
//          located the pointer to the name, subsequent comparisons need merely
//          compare pointers as opposed to strings.
//
//----------------------------------------------------------------------

#define NO_OF_HASH_BUCKETS 997

//prototype of function passed to domain iterator
typedef VOID (* DOMAIN_ITR_FN) (
        IN PVOID pvContext,   //context passed to HrIterateOverSubDomains
        IN PVOID pvData,   //data entry to look at
        IN BOOL fWildcard,    //true if data is a wildcard entry
        OUT BOOL *pfContinue,   //TRUE if iterator should continue to the next entry
        OUT BOOL *pfDelete);  //TRUE if entry should be deleted

class DOMAIN_NAME_TABLE
{
private:
    DWORD               m_dwSignature;
    NAME_PAGE_LIST      NamePageList;
    //
    // NextEntry is used purely for enumeration
    //
    DOMAIN_NAME_TABLE_ENTRY  RootEntry;
    DOMAIN_NAME_TABLE_BUCKET Buckets[NO_OF_HASH_BUCKETS];
    HRESULT HrLookupDomainName(
                            IN  DOMAIN_STRING            *pPath,
                            OUT BOOL                     *pfExactMatch,
                            OUT PDOMAIN_NAME_TABLE_ENTRY *ppEntry);

    HRESULT HrPrivInsertDomainName(IN  PDOMAIN_STRING  pstrDomainName,
                                IN  DWORD dwDomainNameTableFlags,
                                IN  PVOID pvNewData,
                                OUT PVOID *ppvOldData);

    inline void LookupBucket(IN  PDOMAIN_NAME_TABLE_BUCKET pBucket,
                         IN  PDOMAIN_STRING  pName,
                         IN  PDOMAIN_NAME_TABLE_ENTRY pParentEntry,
                         OUT PDOMAIN_NAME_TABLE_ENTRY *ppEntry,
                         OUT BOOL  *pfNameFound);

    PDOMAIN_NAME_TABLE_ENTRY pNextTableEntry(
                         IN  PDOMAIN_NAME_TABLE_ENTRY pEntry,
                         IN  PDOMAIN_NAME_TABLE_ENTRY pRootEntry = NULL);

    void    DumpTableContents();
    void    RemoveTableEntry(IN PDOMAIN_NAME_TABLE_ENTRY pEntry);

    ULONG   m_cLookupAttempts;  //Total number of lookup attempts
    ULONG   m_cLookupSuccesses; //Number of those attempts that where successful
    ULONG   m_cLookupCollisions; //Number of lookups that had some sort of collision
    ULONG   m_cHashCollisions;  //Number of entries we had to check becuase another
                                //another string hashed to the same bucket.
                                //This can be decrease by a better hash or more buckets
    ULONG   m_cStringCollisions; //Number of entries we had to check becuase the
                                 //same string has different parents ("foo" in
                                 //"foo.com" and "foo.net"
    ULONG   m_cBucketsUsed;     //High water mark bucket usage count

    enum {
        DMT_INSERT_AS_WILDCARD = 0x00000001,
        DMT_REPLACE_EXISTRING  = 0x00000002,
    };
public:
    DOMAIN_NAME_TABLE();
    ~DOMAIN_NAME_TABLE();
    //NOTE: Init, Insert, and Remove require *external* exclusive lock,
    //find and next need a *external* read lock
    HRESULT HrInit();

    PVOID   pvNextDomainName(IN OUT PVOID *ppvContext); //NULL context restarts

    inline HRESULT HrInsertDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvData,
                                IN  BOOL  fTreatAsWildcard = FALSE,
                                OUT PVOID *ppvOldData = NULL);

    HRESULT HrRemoveDomainName( IN  PDOMAIN_STRING  pstrDomainName,
                                OUT PVOID *ppvData);
    HRESULT HrFindDomainName(   IN  PDOMAIN_STRING  pstrDomainName,
                                OUT PVOID *ppvData,
                                IN  BOOL  fExactMatch = TRUE);

    //Insert Domain Name and replaces old value if neccessary.  Returns old
    //data as well.
    inline HRESULT HrReplaceDomainName(IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvNewData, //New data to insert
                                IN  BOOL  fTreatAsWildcard,
                                OUT PVOID *ppvOldData); //Previous data

    HRESULT HrIterateOverSubDomains(
        IN DOMAIN_STRING *pstrDomain, //string to search for subdomains of
        IN DOMAIN_ITR_FN pfn, //mapping function (described below)
        IN PVOID pvContext);  //context ptr pass to mapping function

};

typedef DOMAIN_NAME_TABLE * PDOMAIN_NAME_TABLE;


//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrInsertDomainName
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//              [fTreatAsWildcard] -- TRUE if the domain is NOT a wildcard
//                      domain, but it should be treated as one (more efficient
//                      than reallocated a string to prepend "*.".
//
//              [ppvOldData] -- Old Data (if any) that was previously associated
//                      with this domain name.  If NULL, previous data will
//                      not be returned
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    05-11-98  MikeSwa Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrInsertDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvData,
                                IN  BOOL  fTreatAsWildcard,
                                OUT PVOID *ppvOldData)
{
    return (HrPrivInsertDomainName(pstrDomainName,
        (fTreatAsWildcard ? DMT_INSERT_AS_WILDCARD : 0), pvData, ppvOldData));
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrReplaceDomainName
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//              [fTreatAsWildcard] -- TRUE if the domain is NOT a wildcard
//                      domain, but it should be treated as one (more efficient
//                      than reallocated a string to prepend "*.".
//
//              [ppvOldData] -- Old Data (if any) that was previously associated
//                      with this domain name.  If NULL, previous data will
//                      not be returned
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    05-11-98  MikeSwa Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrReplaceDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  PVOID pvNewData,
                                IN  BOOL  fTreatAsWildcard,
                                OUT PVOID *ppvOldData)
{
    return (HrPrivInsertDomainName(pstrDomainName,
            (fTreatAsWildcard ? (DMT_INSERT_AS_WILDCARD | DMT_REPLACE_EXISTRING) :
                            DMT_REPLACE_EXISTRING),
            pvNewData, ppvOldData));
}


#endif // __DOMHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\evntwrap.h ===
/*
 * An event log wrapper to simplify event logging for DLLs and to add
 * a few extra features.
 */

#ifndef __EVENTWRAP_H__
#define __EVENTWRAP_H__

#include <dbgtrace.h>
#include <fhashex.h>

#define LOGEVENT_DEBUGLEVEL_HIGH       1
#define LOGEVENT_DEBUGLEVEL_MEDIUM     2^15
#define LOGEVENT_DEBUGLEVEL_LOW        2^16

#define LOGEVENT_FLAG_ALWAYS		   0x00000001
#define LOGEVENT_FLAG_ONETIME		   0x00000002
#define LOGEVENT_FLAG_PERIODIC	       0x00000003
// we use the lower 8 bits for various logging modes, and reserve the
// other 24 for flags
#define LOGEVENT_FLAG_MODEMASK         0x000000ff

//
// This object is the key for the eventlog hash table
//
class CEventLogHashKey {
    public:
        char *m_szKey;
        DWORD m_idMessage;
        BOOL m_fAllocKey;

        CEventLogHashKey() {
            m_fAllocKey = FALSE;
            m_szKey = NULL;
            m_idMessage = 0;
        }

        HRESULT Init(const char *szKey, DWORD idMessage) {
            m_idMessage = idMessage;
            m_szKey = new char[strlen(szKey) + 1];
            if (m_szKey) {
                m_fAllocKey = TRUE;
                strcpy(m_szKey, szKey);
            } else {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }

        ~CEventLogHashKey() {
            if (m_fAllocKey && m_szKey) {
                delete[] m_szKey;
                m_szKey = NULL;
                m_fAllocKey = FALSE;
            }
            m_idMessage = 0;
        }
};

// 100ns units between periodic event logs.  this can't be larger then 
// 0xffffffff
#define LOGEVENT_PERIOD (DWORD) (3600000000) // 60 minutes

//
// For each unique idMessage/szKey event that is logged we insert one
// of these objects into a hash table.  This allows us to support the
// LOGEVENT_FLAG_ONETIME and LOGEVENT_FLAG_PERIODIC flags
//
class CEventLogHashItem {
    public:
        CEventLogHashItem *m_pNext;

        CEventLogHashItem() {
            m_pNext = NULL;
            ZeroMemory(&m_timeLastLog, sizeof(FILETIME));
            UpdateLogTime();
        }

        CEventLogHashKey *GetKey() {
            return &(m_key);
        }

        int MatchKey(CEventLogHashKey *pOtherKey) {
            return (m_key.m_idMessage == pOtherKey->m_idMessage &&
                    strcmp(m_key.m_szKey, pOtherKey->m_szKey) == 0);
        }

        HRESULT InitializeKey(const char *szKey, DWORD idMessage) {
            return m_key.Init(szKey, idMessage);
        }

        BOOL PeriodicLogOkay() {
            FILETIME timeCurrent;

            GetSystemTimeAsFileTime(&timeCurrent);

            LARGE_INTEGER liCurrent = 
                { timeCurrent.dwLowDateTime, timeCurrent.dwHighDateTime };
            LARGE_INTEGER liLastLog = 
                { m_timeLastLog.dwLowDateTime, m_timeLastLog.dwHighDateTime };
            LARGE_INTEGER liDifference;
            liDifference.QuadPart = liCurrent.QuadPart - liLastLog.QuadPart;

            return (liDifference.HighPart || 
                    liDifference.LowPart > LOGEVENT_PERIOD);
        }

        void UpdateLogTime() {
            GetSystemTimeAsFileTime(&m_timeLastLog);
        }

    private:
        CEventLogHashKey m_key;
        FILETIME m_timeLastLog;
};

class CEventLogWrapper {
    public:
        CEventLogWrapper() {
            m_hEventLog = NULL;
        }

        //
        // Register your event source in the registry.
        //
        // Parameters:
        //   szEventSource - the name of the eventsource
        //   szMessageFile - the full path to the DLL which contains the 
        //                   eventlog strings
        //   fApplication - The eventsource is an application, not a system
        //     component
        //
        static
        HRESULT AddEventSourceToRegistry(char *szEventSource,
                                         char *szMessageFile,
                                         BOOL fApplication = FALSE);

        //
        // Unregister your event source in the registry.
        //
        // Parameters:
        //   szEventSource - the name of the eventsource
        //   fApplication - The eventsource is an application, not a system
        //     component
        //
        static
        HRESULT RemoveEventSourceFromRegistry(char *szEventSource, 
                                              BOOL fApplication = FALSE);

        //
        // Initialize the event logging library.  
        //
        // Parameters:
        //   szEventSource - the name of the eventsource
        //
        HRESULT Initialize(char *szEventSource);

        //
        // Write an event to the event log
        //
        // Parameters:
        //   idMessage - the eventlog ID
        //   cSubstrings - count of strings in rgszSubstrings
        //   rgszSubstrings - substrings for the eventlog text
        //   wType - eventlog error type.  Should be EVENTLOG_WARNING_TYPE,
        //     EVENTLOG_INFORMATION_TYPE or EVENTLOG_ERROR_TYPE.
        //   errCode - Win32 error code to log (or 0)
        //   iDebugLevel - debug level of the event.  1 = highest priority,
        //     2^16 = lowest priority.  normally anything above 2^15 isn't
        //     logged.
        //   szKey - a key which is used along with idMessage to uniquely
        //     identify this eventlog.  It is used to control the options.
        //   dwOptions - options for logging this event.
        // Optional Parameters:
        //   iMessageString - call FormatMessage on errCode and save
        //     the string into rgszSubstrings[iMessageString].
        //   HMODULE hModule - module with extra error codes for 
        //     FormatMessage.
        //
        HRESULT LogEvent(DWORD idMessage,
                         WORD cSubstrings,
                         LPCSTR *rgszSubstrings,
                         WORD wType,
                         DWORD errCode,
                         WORD iDebugLevel,
                         LPCSTR szKey,
                         DWORD dwOptions,
                         DWORD iMessageString = 0xffffffff,
                         HMODULE hModule = NULL);

        //
        // Reset any history about events using this message and key,
        // so that the next LogEvent with one-time or periodic logging
        // will cause the event to be logged.
        //
        // Parameters:
        //   idMessage - the eventlog ID
        //   szKey - a key which is used along with idMessage to uniquely
        //     identify this eventlog.  
        //
        HRESULT ResetEvent(DWORD idMessage,
                           LPCSTR szKey);

        ~CEventLogWrapper();
    private:
        // the handle returned from RegisterEventSource
        HANDLE m_hEventLog;

        // this hash table is used to remember which keys we have
        // used to support PERIODIC and ONETIME options
        TFHashEx<CEventLogHashItem, CEventLogHashKey *, CEventLogHashKey *> m_hash;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\dbgtrace.h ===
/*----------------------------------------------------------------------
    dbgtrace.h
        Definitions for async tracing routines

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_DBGTRACE_H_)
#define _DBGTRACE_H_

//
// setup DLL Export macros
//
#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif
#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif
#if !defined(_DBGTRACE_DLL_DEFINED)
    #define _DBGTRACE_DLL_DEFINED
    #if defined(WIN32)
        #if defined(_DBGTRACE_DLL_IMPLEMENTATION)
            #define DbgTraceDLL DllExport
        #else
            #define DbgTraceDLL DllImport
        #endif
    #else
        #define DbgTraceDLL
    #endif
#endif

#ifndef THIS_FILE
#define THIS_FILE   __FILE__
#endif

#ifndef THIS_MODULE
#define THIS_MODULE "ALL"
#endif

#if defined( NOTRACE )

#define FLUSHASYNCTRACE                         // for _ASSERT below

#define FatalTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
#define DebugTrace  1 ? (void)0 : PreAsyncTrace
#define StateTrace  1 ? (void)0 : PreAsyncTrace
#define FunctTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTraceX 1 ? (void)0 : PreAsyncTrace
#define DebugTraceX 1 ? (void)0 : PreAsyncTrace

#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )

#define TraceQuietEnter( sz )
#define TraceFunctEnter( sz )
#define TraceFunctEnterEx( lparam, sz )
#define TraceFunctLeave()
#define TraceFunctLeaveEx(lparam)

//
// import functions from DBGTRACE.DLL
//
#define InitAsyncTrace()
#define TermAsyncTrace()
#define FlushAsyncTrace()

__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
        return( 1);
}


#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )



#else // NOTRACE

#define FLUSHASYNCTRACE     FlushAsyncTrace(),  // for _ASSERT below

#define FatalTrace  !(__dwEnabledTraces & FATAL_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, FATAL_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define ErrorTrace  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTrace  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define StateTrace  !(__dwEnabledTraces & STATE_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, STATE_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define FunctTrace  !(__dwEnabledTraces & FUNCT_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, FUNCT_TRACE_MASK ) &&     \
                    PreAsyncTrace

//
// Support for unspecified function names
//

#define ErrorTraceX  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, "Fn", ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTraceX  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, "Fn", DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace


//
// use to explicitly remove function tracing even for debug builds
//
#define TraceQuietEnter( sz )                   \
        char    *___pszFunctionName = sz

//
// disable function tracing for retail builds
// reduces code size increase and only should
// only be used sparingly
//
#ifdef  DEBUG

#define TraceFunctEnter( sz )                   \
        TraceQuietEnter( sz );                  \
        FunctTrace( 0, "Entering %s", sz )

#define TraceFunctLeave()                       \
        FunctTrace( 0, "Leaving %s", ___pszFunctionName )

#define TraceFunctEnterEx( lParam, sz )         \
        TraceQuietEnter( sz );                  \
        FunctTrace( lParam, "Entering %s", sz )

#define TraceFunctLeaveEx( lParam )             \
        FunctTrace( lParam, "Leaving %s", ___pszFunctionName )

#else

#define TraceFunctEnter( sz )           TraceQuietEnter( sz )
#define TraceFunctEnterEx( lParam, sz ) TraceQuietEnter( sz )

#define TraceFunctLeave()
#define TraceFunctLeaveEx( lParam )

#endif

//
// import functions from DBGTRACE.DLL
//
extern DbgTraceDLL BOOL WINAPI InitAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI TermAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI FlushAsyncTrace( void );




//
// fixed number of parameters for Binary trace macros
//
#define MessageTrace( lParam, pbData, cbData )                  \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_MESSAGE, pbData, cbData )

#define BinaryTrace( lParam, pbData, cbData )                   \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_BINARY, pbData, cbData )

#define UserTrace( lParam, dwUserType, pbData, cbData )         \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParamsEx( THIS_MODULE, THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, dwUserType, pbData, cbData )

//
// imported trace flag used by trace macros to determine if the trace
// statement should be executed
//
extern DWORD DbgTraceDLL    __dwEnabledTraces;



extern DbgTraceDLL int WINAPI AsyncStringTrace( LPARAM  lParam,
                                                LPCSTR  szFormat,
                                                va_list marker );

extern DbgTraceDLL int WINAPI AsyncBinaryTrace( LPARAM  lParam,
                                                DWORD   dwBinaryType,
                                                LPBYTE  pbData,
                                                DWORD   cbData );

extern DbgTraceDLL int WINAPI SetAsyncTraceParams(  LPSTR   pszFile,
                                                    int     iLine,
                                                    LPSTR   szFunction,
                                                    DWORD   dwTraceMask );

extern DbgTraceDLL int WINAPI SetAsyncTraceParamsEx(LPSTR   pszModule,
                                                    LPSTR   pszFile,
                                                    int     iLine,
                                                    LPSTR   szFunction,
                                                    DWORD   dwTraceMask );

//
// Trace flag constants
//
#define FATAL_TRACE_MASK    0x00000001
#define ERROR_TRACE_MASK    0x00000002
#define DEBUG_TRACE_MASK    0x00000004
#define STATE_TRACE_MASK    0x00000008
#define FUNCT_TRACE_MASK    0x00000010
#define MESSAGE_TRACE_MASK  0x00000020
#define ALL_TRACE_MASK      0xFFFFFFFF

#define NUM_TRACE_TYPES     6

//
// Output trace types. used by tools to modify the
// registry to change the output target
//
enum tagTraceOutputTypes {
    TRACE_OUTPUT_DISABLED = 0,
    TRACE_OUTPUT_FILE = 1,
    TRACE_OUTPUT_DEBUG = 2,
    TRACE_OUTPUT_DISCARD = 4        // used to find race windows
};

#define TRACE_OUTPUT_INVALID    \
        ~(TRACE_OUTPUT_FILE|TRACE_OUTPUT_DEBUG|TRACE_OUTPUT_DISCARD)


#define IsTraceFile(x)      ((x) & TRACE_OUTPUT_FILE)
#define IsTraceDebug(x)     ((x) & TRACE_OUTPUT_DEBUG)
#define IsTraceDiscard(x)   ((x) & TRACE_OUTPUT_DISCARD)


//
// predefined types of binary trace types.  User defined
// types must be greater than 0x8000
//
enum tagBinaryTypes {
    TRACE_STRING = 0,
    TRACE_BINARY,
    TRACE_MESSAGE,
    TRACE_USER = 0x8000
};

#include <stdarg.h>

//
// use __inline to ensure grab __LINE__ and __FILE__
//
__inline int WINAPIV PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
    va_list marker;
    int     iLength;

    va_start( marker, szFormat );
    iLength = AsyncStringTrace( lParam, szFormat, marker );
    va_end( marker );

    return  iLength;
}

// !defined(NOTRACE) from way at the top of this include file
#endif // !defined(NOTRACE)

// Asserts are independent of tracing
// (with the exception of flushing the trace buffer).

//
// For now enable ASSERT defines only if debugging is enabled
//
#ifdef  DEBUG
#define _ENABLE_ASSERTS

#ifndef NOTRACE
#define _ENABLE_VERBOSE_ASSERTS
#endif  // NO_TRACE

#endif  // DEBUG

//
// Macros added for doing asserts and verifies.  basic clones
// of the MFC macros with a prepended _ symbol
//
#ifdef  _ENABLE_ASSERTS

extern DllExport void WINAPI DebugAssert(   DWORD dwLine,
                                            LPSTR lpszFunction,
                                            LPSTR lpszExpression );

#ifndef _ASSERT
#ifdef  _ENABLE_VERBOSE_ASSERTS
#define _ASSERT(f)  !(f) ? DebugAssert( __LINE__,  THIS_FILE, #f ) : ((void)0)
#else
#define _ASSERT(f)  !(f) ? DebugBreak() : ((void)0)
#endif  //_ENABLE_VERBOSE_ASSERTS
#endif

#define _VERIFY(f)  _ASSERT(f)

#else

#undef _ASSERT
#undef _VERIFY
#define _ASSERT(f)  ((void)0)
#define _VERIFY(f)  ((void)(f))

#endif  // _ENABLE_ASSERTS

#endif // !defined(_DBGTRACE_H_)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\fhashex.h ===
/*++
	FHash.h

	This file contains a template class for a hash table.
	The template has two arguments, the type of the Data Elements and the 
	type of the Key.  

	The Data type must support the following : 

	class Data {
		Data*	m_pNext ;

		KEYREF	GetKey(	) ;

		int		MatchKey(	KEYREF	otherkey) ;	/* NOTE : MatchKey returns non-zero on equality
	} ;

	DWORD	(* m_pfnHash)( KEYREF k ) ;	
	
--*/

#ifndef	_FHASHEX_H_
#define	_FHASHEX_H_

//------------------------------------------------------------
template<	class	Data,		/* This is the item that resides in the hashtable */
			class	Key,		/* This is the type of the Key */
			class	KEYREF		/* This is the type used to point or reference items in the cache*/
			>
class	TFHashEx	{
//
//	This class defines a Hash table which can grow dynamically to 
//	accomodate insertions into the table.  The table only grows, and 
//	does not shrink.
//
public : 
	//
	//	Define the subtypes we need !
	//

	//
	//	This is a member pointer to a pointer to Data - 
	//	i.e. this is the offset in the class Data where we 
	//	will hold the next pointers for our hash buckets !
	//
	typedef	Data*	Data::*NEXTPTR ;

	//
	//	This is a member function pointer to a function which
	//	will retrieve the key we are to use !
	//
	typedef	KEYREF	(Data::*GETKEY)( ) ;

	//
	//	This is a member function pointer of the type that will
	//	compare keys for us !
	//
	typedef	int		(Data::*MATCHKEY)( KEYREF key ) ;


private : 


	//
	// An array of pointer to buckets.
	//
	Data**	m_ppBucket ;	

	//
	//	Member Pointer - points to where the pointer is that
	//	we should use for chaining buckets together !
	//
	NEXTPTR	m_pNext ;	

	//
	//	Member Pointer - will get the key out of the object for us !
	//
	GETKEY	m_pGetKey ;

	//
	//	Member Pointer - will compare the key in the item for us !
	//
	MATCHKEY	m_pMatchKey ;
	
	//
	// A counter that we use to determine when to grow the
	// hash table.  Each time we grow the table we set this
	// to a large positive value, and decrement as we insert
	// elements.  When this hits 0 its time to grow the table !
	//
	long	m_cInserts ;		

	//
	// The function we use to compute hash values.
	// (Provided by the Caller of Init())
	//
	DWORD	(* m_pfnHash)( KEYREF k ) ;	

	//
	// Number of Buckets used in index computation
	//
	int		m_cBuckets ;		

	//
	// Number of Buckets we are actually using
	// Assert( m_cBuckets >= m_cActiveBuckets ) always true.
	//
	int		m_cActiveBuckets ;	

	//
	// Number of Buckets we have allocated 
	// Assert( m_cNumAlloced >= m_cActiveBuckets ) must
	// always be true.
	//
	int		m_cNumAlloced ;		

	//
	// The amount we should grow the hash table when we 
	// decide to grow it.
	//
	int		m_cIncrement ;		

	//
	// The number of CBuckets we should allow in each 
	// collision chain (on average).
	//
	int		m_load ;			

	//
	// The function we use to compute the 
	// position of an element in the hash table given its
	// Hash Value.
	//
	DWORD	
	ComputeIndex( DWORD dw ) ;	

public : 
	TFHashEx( ) ;
	~TFHashEx( ) ;

	BOOL	
	Init(	NEXTPTR	pNext,
			int		cInitial, 
			int		cIncrement, 
			DWORD	(* pfnHash)( KEYREF	), 
			int,
			GETKEY,
			MATCHKEY
			) ;

	//
	//	Check that the hash table is in a valid state
	//	if fCheckHash == TRUE we will walk all the buckets and check that
	//	the data hashes to the correct value !
	//
	BOOL	
	IsValid( BOOL fCheckHash = FALSE ) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	
	InsertDataHash(	DWORD	dw,
					Data&	d 
					) ;

	//
	//	Insert a piece of Data into the Hash Table
    //  We take a pointer to the Data object.
	//
	Data*	
	InsertDataHash(	DWORD	dw,
					Data*	pd 
					) ;

	//
	//	Insert a piece of Data into the Hash Table
	//
	Data*	
	InsertData(	Data&	d ) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	
	SearchKeyHash(	DWORD	dw,
					KEYREF	k 
					) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*	
	SearchKey(	KEYREF	k ) ;

	//
	//	Search for a given Key in the Hash Table and remove
	//	the item if found.  We will return a pointer to the item.
	//
	Data*
	DeleteData(	KEYREF	k,	
				Data*	pd = 0	
				) ;

	//	
	//	Insert the given block of data into the hash table.
	//	We will make a copy of the Data Object and store it in one 
	//	of our bucket objects.
	//
	BOOL	
	Insert( Data&	d	) ;

	//	
	//	Insert the given block of data into the hash table.
	//	We take a pointer to the Data Object and store it in one 
	//	of our bucket objects.
	//
	BOOL	
	Insert( Data*	pd	) ;

	//	
	//	Find the given key in the table and copy the Data object into 
	//	the out parameter 'd'
	//
	BOOL	
	Search( KEYREF	k, 
			Data &d 
			) ;

	//
	//	Delete the key and associated data from the table.
	//
	BOOL	
	Delete( KEYREF	k ) ;

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	void	Clear( ) ;

	//
	//	Removes all of the items in the hash table.  Does not call "delete"
	//  on them.
	//
	void	Empty( ) ;

	//
	//	Function to compute hash value of a key for callers
	//	who don't keep track of the hash function 
	//
	DWORD
	ComputeHash(	KEYREF	k ) ;

} ;

#include	"fhashex.inl"

#endif // _FHASHEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\fhashex.inl ===
/*++

	FHashEx.inl

	This file contains the template implementation of the class TFHashEx.

--*/


//---------------------------------------------
template<	class Data, 
			class Key,
			class KEYREF		/* This is the type used to point or reference items in the cache*/
			>
TFHashEx< Data, Key, KEYREF	>::TFHashEx( ) : 
	m_cBuckets( 0 ), 
	m_cActiveBuckets( 0 ),
	m_cNumAlloced( 0 ), 
	m_cIncrement( 0 ), 
	m_ppBucket( 0 ), 
	m_pfnHash( 0 ), 
	m_pGetKey( 0 ),
	m_pMatchKey( 0 ),	
	m_load( 0 )	{
//
//	Very basic constructor
//

}

//---------------------------------------------
template<	class	Data, 
			class	Key, 
			class	KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Init( 
							NEXTPTR	pNext,
							int cInitial, 
							int cIncrement, 
							DWORD (*pfnHash)(KEYREF), 
							int load,
							GETKEY		pGetKey, 
							MATCHKEY	pMatchKey
							) {
/*++

Routine Description : 

	Initialize the hash table 

Arguments : 

	pNext - A pointer to Member with class Data where we can hold
		our bucket pointers !
	cInitial - Initial size of the hash table
	cIncrement - Amount to grow the hash table by !
	pfnHash - Hash Function - 
	load - Average bucket length before growing the table !

Return Value : 

	TRUE if successfull FALSE otherwise

--*/

	m_pGetKey = pGetKey ;
	m_pMatchKey = pMatchKey ;

    //
    // Compute nearest power of 2
    //

	m_pNext = pNext ;

    int	power = cInitial ;
    while( power & (power-1) )
        power = power & (power-1) ;
    power<<= 1 ;

    cInitial = power;
	m_load = load ;
	m_pfnHash = pfnHash ;

    //
    // Number of ActiveBuckets is initially half that of the number of buckets.
    //

    m_cActiveBuckets = power/2  ;
    m_cBuckets = power ;
    m_cInserts = m_cActiveBuckets * m_load ;
    m_cIncrement = m_cActiveBuckets / 4;
	m_cNumAlloced = cInitial + 5 * m_cIncrement ;

	//
	// Allocate bucket pointers and zero initialize
	//

	m_ppBucket = new Data*[m_cNumAlloced] ;

    if( m_ppBucket ) {
	    ZeroMemory( m_ppBucket, m_cNumAlloced * sizeof( Data*) ) ;
	    _ASSERT( IsValid( FALSE ) ) ;
	    return  TRUE ;
	}
	return	FALSE ;
}

//------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::IsValid( BOOL fCheckHash ) {
/*++

Routine Description : 

	Check that the hash table is valid 

Arguments : 

	fCheckHash - verify that all the buckets contain the correct hash values !

Return Value : 

	TRUE if successfull FALSE otherwise

--*/

	//
	//	This function checks that all member variables are consistent and correct.
	//	Do not call this function until AFTER calling the Init() function.
	//

	if( m_cBuckets <= 0 ||
		m_cActiveBuckets <= 0 ||
		m_cNumAlloced <= 0 ||
		m_cIncrement <= 0 ||
		m_load <= 0 )
		return	FALSE ;

	if( m_cActiveBuckets < (m_cBuckets / 2) || m_cActiveBuckets > m_cBuckets )
		return	FALSE ;

	if( m_cActiveBuckets > m_cNumAlloced )
		return	FALSE ;

	if( m_cInserts > (m_load * m_cActiveBuckets) )
		return	FALSE ;

	if( m_ppBucket == 0 )
		return	FALSE ;

	if( fCheckHash ) {
		//
		// Examine every bucket chain to ensure that elements are in correct slots.
		//
		for( int i=0; i<m_cNumAlloced; i++ ) {

			if( i>=m_cActiveBuckets ) {
				if( m_ppBucket[i] != 0 ) {
					return	FALSE ;
				}
			}	else	{
				for( Data	*p = m_ppBucket[i]; p != 0; p = p->*m_pNext ) {
					KEYREF	keyref = (p->*m_pGetKey)();
					if( ComputeIndex( m_pfnHash( keyref ) ) != unsigned(i) ) {
						return	FALSE ;
					}
				}
			}
		}
	}
	return	TRUE ;
}



//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
TFHashEx< Data, Key, KEYREF >::~TFHashEx() {
/*++

Routine Description : 

	Destroy the hash table !

Arguments : 

	None

Return Value : 

	None

--*/
	//
	//	The destructor discards any memory we have allocated.
	//
	Clear();
}


//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
void
TFHashEx< Data, Key, KEYREF >::Clear() {
/*++

Routine Description : 

	Delete all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !

Arguments : 
	
	None.

Return Value : 

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_ppBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		for( int i=0; i<m_cNumAlloced; i++ ) {
			Data	*p, *pNext ;
			for( p = m_ppBucket[i], pNext = p ? p->*m_pNext : 0;
					p!=0; p=pNext, pNext= p ? p->*m_pNext : 0 ) {
				delete	p ;
			}
		}
		delete[] m_ppBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}


//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
void
TFHashEx< Data, Key, KEYREF >::Empty() {
/*++

Routine Description : 

	Remove all entries in the table, and reset all member variables !
	User must call Init() again before the table is usable !
	This is just like Clear() but it does do a "delete".

Arguments : 
	
	None.

Return Value : 

	None

--*/

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	if( m_ppBucket ) {
		_ASSERT( IsValid( TRUE ) ) ;

		delete[] m_ppBucket;
	}

	m_cBuckets = 0;
	m_cActiveBuckets = 0;
	m_cNumAlloced = 0;
	m_cIncrement = 0;
	m_ppBucket = 0;
	m_pfnHash = 0;
	m_load = 0;
}

//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
DWORD
TFHashEx< Data, Key, KEYREF >::ComputeIndex( DWORD dw ) {
/*++

Routine Description : 

	Compute which bucket an element should be in

	This function tells us where we should store elements.  To do this we mod with
	m_cBuckets.  Since we only have m_cActiveBuckets in reality, we check the result
	of the mod and subtract m_cBuckets over 2 if necessary.

Arguments : 

	dw - the hash value of the entry we are adding to the table

Return Value : 

	Index to the bucket to use !

--*/

	DWORD	dwTemp = dw % m_cBuckets ;
	return	(dwTemp >= (unsigned)m_cActiveBuckets) ? dwTemp - (m_cBuckets/2) : dwTemp ;
}



template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Insert( Data& d ) {
/*++

Routine Description : 

	Insert a Data element into the hash table

Arguments : 

	d - reference to the item to be inserted into the table 

Return Value : 

	TRUE if successfull - FALSE otherwise !

--*/

	_ASSERT( d.*m_pNext == 0 ) ;
	_ASSERT( IsValid( FALSE ) ) ;

	if( InsertData( d ) ) 
		return	TRUE ;
	return	FALSE ;
}

template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Insert( Data* pd ) {
/*++

Routine Description : 

	Insert a Data element into the hash table

Arguments : 

	pd - pointer to the item to be inserted into the table 

Return Value : 

	TRUE if successfull - FALSE otherwise !

--*/

	_ASSERT( pd->*m_pNext == 0 ) ;
	_ASSERT( IsValid( FALSE ) ) ;

	KEYREF	keyref = (pd->*m_pGetKey)() ;
	if( InsertDataHash( m_pfnHash( keyref ), pd ) ) 
		return	TRUE ;
	return	FALSE ;
}

//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::InsertDataHash( 
								DWORD	dwHash,
								Data&	d 
								) {
/*++

Routine Description : 

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments : 

	dw - the hash value of the entry we are adding to the table
	d -  The item we are adding to the table !

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( d.*m_pNext == 0 ) ;

	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			Data** pTemp = new Data*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				//
				//	bugbug ... need to handles this error better !?
				//
				return	0 ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( Data*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( Data* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) 
			m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			Data**	ppNext = &m_ppBucket[ iCurrent ] ;
			Data*	p = *ppNext ;
			while( p ) {

				KEYREF	keyref = (p->*m_pGetKey)();
				int	index = ComputeIndex( m_pfnHash( keyref ) ) ;
				Data*	pNext = p->*m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->*m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &(p->*m_pNext) ;
				}
				p = pNext ;
			}
		}
		_ASSERT( IsValid( TRUE ) ) ;
	}

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	KEYREF	keyref = (d.*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;

	d.*m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = &d ;

	_ASSERT( IsValid( FALSE ) ) ;

	return	&d ;
}

//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::InsertDataHash( 
								DWORD	dwHash,
								Data*	pd 
								) {
/*++

Routine Description : 

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain.

Arguments : 

	dw - the hash value of the entry we are adding to the table
	pd - Pointer to the item we are adding to the table !

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( pd->*m_pNext == 0 ) ;

	//
	// First check whether it is time to grow the hash table.
	//
	if( --m_cInserts == 0 ) {

		//
		// Check whether we need to reallocate the array of Bucket pointers.
		//
		if( m_cIncrement + m_cActiveBuckets > m_cNumAlloced ) {


			Data** pTemp = new Data*[m_cNumAlloced + 10 * m_cIncrement ] ;

			if( pTemp == 0 ) {
				//
				//	bugbug ... need to handles this error better !?
				//
				return	0 ;
			}	else	{
				ZeroMemory( pTemp, (m_cNumAlloced + 10 *m_cIncrement)* sizeof( Data*) ) ;
				CopyMemory( pTemp, m_ppBucket, m_cNumAlloced * sizeof( Data* ) ) ;
				delete[] m_ppBucket;
				m_cNumAlloced += 10 * m_cIncrement ;
				m_ppBucket = pTemp ;
			}
		}

		//
		// Okay grow the array by m_cIncrement.
		//
		m_cActiveBuckets += m_cIncrement ;
		if( m_cActiveBuckets > m_cBuckets ) 
			m_cBuckets *= 2 ;		
		m_cInserts = m_cIncrement * m_load ;

		//
		// Now do some rehashing of elements.
		//

		for( int	i = -m_cIncrement; i < 0; i++ ) {
			int	iCurrent = (m_cActiveBuckets + i) - (m_cBuckets / 2) ;
			Data**	ppNext = &m_ppBucket[ iCurrent ] ;
			Data*	p = *ppNext ;
			while( p ) {

				KEYREF	keyref = (p->*m_pGetKey)();
				int	index = ComputeIndex( m_pfnHash( keyref ) ) ;
				Data*	pNext = p->*m_pNext ;
				if( index != iCurrent) {
					*ppNext = pNext ;					
					p->*m_pNext = m_ppBucket[index] ;
					m_ppBucket[index] = p ;
				}	else	{
					ppNext = &(p->*m_pNext) ;
				}
				p = pNext ;
			}
		}
		_ASSERT( IsValid( TRUE ) ) ;
	}

	//
	//	Finally, insert into the Hash Table.
	//
	//DWORD	index = ComputeIndex( m_pfnHash( d.GetKey() ) ) ;

	KEYREF	keyref = (pd->*m_pGetKey)();
	_ASSERT( dwHash == m_pfnHash( keyref ) ) ;
	DWORD	index = ComputeIndex( dwHash ) ;

	_ASSERT( index < unsigned(m_cActiveBuckets) ) ;

	pd->*m_pNext = m_ppBucket[index] ;
	m_ppBucket[index] = pd ;

	_ASSERT( IsValid( FALSE ) ) ;

	return	pd ;
}


//-------------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
inline	Data*
TFHashEx< Data, Key, KEYREF >::InsertData( Data& d ) {
/*++

Routine Description : 

	Insert an element into the hash table.
	We will use member's of Data to hold the bucket chain,
	and we will also compute the hash of the key !

Arguments : 

	d -  The item we are adding to the table !

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/
	_ASSERT( IsValid( FALSE ) ) ;

	KEYREF	keyref = (d.*m_pGetKey)() ;
	return	InsertDataHash(	m_pfnHash( keyref ), d ) ;
}


//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Search(	KEYREF	k, 
										Data &dOut 
										) {
/*++

Routine Description : 

	Search for an element in the hashtable.

Arguments : 


	k - key of the item to find
	dOut - A reference that we will set to the
		located data item

Return Value : 

	TRUE if found, FALSE otherwise 

--*/

	const	Data*	pData = SearchKey( k ) ;
	if( pData ) {
		dOut = *pData ;
		return	TRUE ;
	}
	return	FALSE ;
}

//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::SearchKeyHash( 
									DWORD	dwHash, 
									KEYREF	k 
									) {
/*++

Routine Description : 

	Search for an element in the Hash Table, 
	
Arguments : 

	dwHash - the hash value of the entry we are adding to the table
	k - reference to the key we are to compare against 

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	_ASSERT( dwHash == (m_pfnHash)(k) ) ;

	DWORD	index = ComputeIndex(	dwHash ) ;
	Data*	p = m_ppBucket[index] ;
	while( p ) {
		if( (p->*m_pMatchKey)( k ) )
			break ;
		p = p->*m_pNext ;
	}
	return	p ;
}



//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
inline	Data*
TFHashEx< Data, Key, KEYREF >::SearchKey( KEYREF	k ) {
/*++

Routine Description : 

	Search for an element in the Hash Table, 
	We will compute the hash of the key.
	
Arguments : 

	k - reference to the key we are to compare against 

Return Value : 

	Pointer to the Data Item in its final resting place !

--*/

	_ASSERT( IsValid( FALSE ) ) ;
	return	SearchKeyHash( m_pfnHash( k ), k ) ;
}



//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
BOOL	
TFHashEx< Data, Key, KEYREF >::Delete( KEYREF	k ) {
/*++

Routine Description : 

	Find an element in the hash table, remove it from
	the table and then destroy it !
	
Arguments : 

	k - reference to the key we are to compare against 

Return Value : 

	TRUE if an item is found and destroyed, FALSE otherwise !

--*/


	Data*	p = DeleteData( k, 0 ) ;
	if( p ) {
		delete	p ;
		return	TRUE ;
	}
	return	FALSE ;
}



//-----------------------------------------------
template<	class Data, 
			class Key, 
			class KEYREF 
			>
Data*
TFHashEx< Data, Key, KEYREF >::DeleteData(	KEYREF	k,
											Data*	pd
											) {
//
//	Remove an element from the Hash Table.  We only need the
//	Key to find the element we wish to remove.
//

	_ASSERT( IsValid( FALSE ) ) ;

	DWORD	dwHash = (m_pfnHash)( k ) ;

	DWORD	index = ComputeIndex( dwHash ) ;
	Data**	ppNext = &m_ppBucket[index] ;
	Data*	p = *ppNext ;

	while( p ) {
		if( (p->*m_pMatchKey)( k ) )
			break ;
		ppNext = &(p->*m_pNext) ;
		p = *ppNext ;
	}
	if( p ) {
		//
		//	If we were given a pointer to a data block, than the client
		//	wants us to check to make sure that we are deleting the correct
		//	instance !!
		//
		if( !pd || pd == p ) {
			*ppNext = p->*m_pNext ;
			p->*m_pNext = 0 ;


			//
			//	Finally - since we removed something from the hash table 
			//	increment the number of inserts so that we don't keep splitting
			//	the table unnecessarily !
			//
			m_cInserts++ ;

			_ASSERT( IsValid( FALSE ) ) ;
		}	else	{
			p = 0 ;
		}
	}
	_ASSERT( IsValid( FALSE ) ) ;
	return	p ;
}

template<	class Data, 
			class Key, 
			class KEYREF 
			>
DWORD
TFHashEx< Data, Key, KEYREF >::ComputeHash(	KEYREF	k	)	{

	return	m_pfnHash( k ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\immprops.h ===
//
// jstamerj 1999/09/21 20:07:55: 
//
// This file will be deleted within a few days.
// Do not use this file unless you want to break the build for jstamerj.
// Instead, use mailmsgprops.h
// 
//   ####   #####    ####    ####   #       ######   #####  ######
//  #    #  #    #  #       #    #  #       #          #    #
//  #    #  #####    ####   #    #  #       #####      #    #####
//  #    #  #    #       #  #    #  #       #          #    #
//  #    #  #    #  #    #  #    #  #       #          #    #
//   ####   #####    ####    ####   ######  ######     #    ######
// 
// 
//  #####    ####           #    #   ####    #####          #    #   ####   ######
//  #    #  #    #          ##   #  #    #     #            #    #  #       #
//  #    #  #    #          # #  #  #    #     #            #    #   ####   #####
//  #    #  #    #          #  # #  #    #     #            #    #       #  #
//  #    #  #    #          #   ##  #    #     #            #    #  #    #  #
//  #####    ####           #    #   ####      #             ####    ####   ######
// 
// 
#include <mailmsgprops.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\gibtype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    gibtype.h

Abstract:

    This file contains information pertaining to any Gibraltar Service.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995
	Richard Kamicar	 (rkamicar)			20-Dec-1995
		-- changed from specific to each service to common.

--*/


#ifndef _GIBTYPE_
#define _GIBTYPE_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Simple types.
//

#define CHAR char                       // For consitency with other typedefs.

typedef DWORD APIERR;                   // An error code from a Win32 API.
typedef INT SOCKERR;                    // An error code from WinSock.

#ifdef _USE_NEW_INTERLOCKED
#define	INTERLOCKED_ADD(__pAddend__, __value__) \
		InterlockedExchangeAdd((LPLONG) (__pAddend__), (LONG) (__value__))

#define	INTERLOCKED_CMP_EXCH(__pDest__, __exch__, __cmp__, __ok__) \
		(__ok__) = InterlockedCompareExchange( \
				(PVOID *) (__pDest__), (PVOID) (__exch__), (PVOID) (__cmp__) \
				)

#define	INTERLOCKED_ADD_CHEAP(__pAddend__, __value__) \
		INTERLOCKED_ADD(__pAddend__, __value__)

#define	INTERLOCKED_CMP_EXCH_CHEAP(__pDest__, __exch__, __cmp__, __ok__) \
		INTERLOCKED_CMP_EXCH(__pDest__, __exch__, __cmp__, __ok__)

#else
#define	INTERLOCKED_ADD_CHEAP(__pAddend__, __value__) \
		*((LPLONG) (__pAddend__)) += (LONG) (__value__)

#define	INTERLOCKED_CMP_EXCH_CHEAP(__pDest__, __exch__, __cmp__, __ok__) \
		if (*(__pDest__) == (__cmp__)) { \
			*(__pDest__) = (__exch__); \
			(__ok__) = TRUE; \
		} else { \
			(__ok__) = FALSE; \
		} \

#define	INTERLOCKED_ADD(__pAddend__, __value__) \
		LockConfig(); \
		INTERLOCKED_ADD_CHEAP(__pAddend__, __value__); \
		UnLockConfig()

#define	INTERLOCKED_CMP_EXCH(__pDest__, __exch__, __cmp__, __ok__) \
		LockConfig(); \
		INTERLOCKED_CMP_EXCH_CHEAP(__pDest__, __exch__, __cmp__, __ok__) \
		UnLockConfig()
#endif

#define	INTERLOCKED_DEC(__pAddend__, __value__) \
		INTERLOCKED_ADD(__pAddend__, -((LONG)(__value__)))

#define	INTERLOCKED_BIGADD_CHEAP(__pAddend__, __value__) \
		{ \
			BOOL __ok__ = FALSE; \
			for (;!__ok__;) { \
				unsigned __int64 __old__ = *(__pAddend__); \
				unsigned __int64 __new__ = (__old__) + (__value__); \
				INTERLOCKED_CMP_EXCH_CHEAP(__pAddend__, __new__, __old__, __ok__); \
			} \
		}

#ifdef __cplusplus
}
#endif

#endif _GIBTYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\flatfile.h ===
//
// flatfile.h -- This file contains the class definations for:
//  CFlatFile
//
// Created:
//   Sep 3, 1996 -- Alex Wetmore (awetmore)
// Changes:
//   May 7, 1998 -- Alex Wetmore (awetmore)
//      -- Modify for use in NNTP.  Remove sorting features, file handle
//         cache, etc.
//   Oct 23,1998 -- Kangrong Yan ( kangyan )
//      -- Added integrity flag
//

#ifndef __FLATFILE_H__
#define __FLATFILE_H__

#include <windows.h>
#include <stdio.h>
#include <writebuf.h>

//
// size of the read buffer used for GetFirstRecord/GetNextRecord()
//
#define FF_BUFFER_SIZE 8192

//
// maximum record size
//
#define MAX_RECORD_SIZE 4096

// do a automatic compaction if there are more then 10 deleted records and
// the ratio of records to deleted records is less then 10
#define FF_COMPACTION_MIN_DELETED_RECORDS 10
#define FF_COMPACTION_MIN_TOTAL_RECORDS 100
#define FF_COMPACTION_RATIO 10

//
// Integrity flag values
//
#define FF_FILE_GOOD    0x0000FFFF
#define FF_FILE_BAD     0x00010000

//
// file extensions for flat files
//
#define NEW_FF_EXT ".tmp"       // extension for new flatfile as its built
#define BAK_FF_EXT ".bak"       // extension for an old backup flatfile
#define FF_IDX_EXT ".idx"       // extension for an index file

#pragma pack(push, flatfile)
#pragma pack(1)

//
// the structure for the header of the file
//
typedef struct {
    DWORD   dwSignature;                    // file signature
	DWORD	dwFlags;						// file flags
} FLATFILE_HEADER;

#define FF_FLAG_COMPACT		0x01

#define FLATFILE_SIGNATURE (DWORD)'__fF'

//
// the record structure for the data file
//
// the size of it is RECORD_HEADER_SIZE + cData;
//
typedef struct {
    BOOL    fDeleted;                       // is this deleted?
    DWORD   cData;                          // length of the data
    BYTE    pData[MAX_RECORD_SIZE];         // data
} RECORD;

typedef struct {
    BOOL    fDeleted;                       // is this deleted?
    DWORD   cData;                          // length of the data
} RECORDHDR;

#define RECORD_HEADER_SIZE sizeof(RECORDHDR)

#pragma pack(pop, flatfile)

//
// A function of this type will be called whenever a record's offset 
// changes in the flatfile.  It is used to keep the owner up to date 
// on record offsets, so that the owner can make quick Delete's
//
typedef void (*PFN_OFFSET_UPDATE)(void *pContext, BYTE *pData, DWORD cData, DWORD iNewOffset);

class CFlatFile {
    public:

        friend class CFlatFileWriteBuf;
        
        CFlatFile(LPSTR szFilename, 
				  LPSTR szExtension, 
				  void *pContext,
				  PFN_OFFSET_UPDATE pfnOffsetUpdate,
				  DWORD dwSignature = FLATFILE_SIGNATURE,
				  BOOL fClear = FALSE, 
				  DWORD dwFileFlags = 0);
        ~CFlatFile();

		// insert a new record into the file
        HRESULT InsertRecord(LPBYTE pData, DWORD cData, DWORD *piOffset = NULL, DWORD dwVer = 0);

		// delete a record from the file
        HRESULT DeleteRecord(DWORD iOffset);

		// compact out any deleted records in the file
        HRESULT Compact();

		// get the first record in the file
        HRESULT GetFirstRecord(LPBYTE pData, 
							   DWORD *cData,
            				   DWORD *piByteOffset = NULL,
            				   DWORD *pdwVer = NULL );

		// get the next record in the file
        HRESULT GetNextRecord(LPBYTE pData, 
							  DWORD *cData,
            				  DWORD *piByteOffset = NULL,
            				  DWORD *pdwVer = NULL);

        // delete everything in the file
        void DeleteAll();

        // Dirty the integrity flag
        HRESULT DirtyIntegrityFlag();

        // Set the integrity flag
        HRESULT SetIntegrityFlag();

        // Is the file in good integrity ?
        BOOL  FileInGoodShape();

        // Enable the write buffer
        VOID EnableWriteBuffer( DWORD cbBuffer );

        // Check to see if the file has been opened
        BOOL IsFileOpened();

    private:
        //
        // open/close a file.  
        //
        // because this uses cached file handles, the position of the file
        // should not be assumed
        //
        HRESULT OpenFile(LPSTR szFilename = NULL,
                         DWORD dwOpenMode = OPEN_ALWAYS, 
						 DWORD dwFlags = 0);

		//
		// close the file handle
		//
		void CloseFile();

        //
        // set and get the file header
        //
        HRESULT SetFileHeader(FLATFILE_HEADER *pHeader);
        HRESULT GetFileHeader(FLATFILE_HEADER *pHeader);

        //
        // read the next chunk of the file into the temporary buffer
        // used by GetFirstRecord/GetNextRecord()
        //
        HRESULT ReadNextNBytes(LPBYTE pData, DWORD cData);
        HRESULT ReadNBytesFrom(LPBYTE pData, DWORD cData, DWORD iOffset, DWORD *pcDidRead = NULL);
        // iOffset can be set to infinite to append
        HRESULT WriteNBytesTo(LPBYTE pData, 
							  DWORD cData,
            				  DWORD *piOffset = NULL,
            				  DWORD iOffset = INFINITE,
            				  DWORD *pcDidWrite = NULL);
            				  
        HRESULT CFlatFile::WriteNBytesToInternal(
                                 LPBYTE pData,
								 DWORD cData,
								 DWORD *piOffset,
                              	 DWORD iOffset,
								 DWORD *pcDidWrite);

        HRESULT ReloadReadBuffer();

        //
		// the file handle for this file
        //
        HANDLE  m_hFile;

        //
        // flags for creating the file with
        //
        DWORD   m_dwFileFlags;

        //
        // filename for the flat file
        //
        char    m_szFilename[FILENAME_MAX];
        char    m_szBaseFilename[FILENAME_MAX];

        //
        // current read buffer
        //
        BYTE    m_pBuffer[FF_BUFFER_SIZE];

        //
        // current offset inside the buffer
        //
        DWORD   m_iBuffer;

        //
        // offset of the read buffer in the file
        //
        DWORD   m_iFile;

        //
        // size of the read buffer (zero means its not valid)
        //
        DWORD   m_cBuffer;

        //
        // clear the file on the next open
        //
        BOOL    m_fClearOnOpen;

        //
        // the number of deleted records in the file.  this is first 
		// computed by FindFirst/FindNext and then kept updated by
		// DeleteRecord and DeleteRecordAtOffset
        //
        DWORD   m_cDeletedRecords;

        //
        // the number of records in the file.  this is first 
		// computed by FindFirst/FindNext and then kept updated by
		// InsertRecord
        //
        DWORD   m_cRecords;

		//
		// context passed into callback functions
		//
		void *m_pContext;

		//
		// Whether the file is open
		//
		BOOL m_fOpen;

		//
		// The write buffer
		//
		CFlatFileWriteBuf m_wbBuffer;

		//
		// function to call when an items offset changes in the flatfile
		//
		PFN_OFFSET_UPDATE m_pfnOffsetUpdate;

		// 
		// signature for the file
		//
		DWORD m_dwSignature;
};

#define ret(__rc__) { /* TraceFunctLeave(); */ return(__rc__); }
#define retEC(__ec__, __rc__) { SetLastError(__ec__); /* TraceFunctLeave(); */ return(__rc__); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\listmacr.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    listmacr.h

Abstract:

    This module defines the macros that manipulates list
    structures defined in winnt.h.  Code is copied from the
    internal NT project.

Author:

    Johnson Apacible (JohnsonA)     30-Sept-1994

Revision History:

--*/

#ifndef _LISTMACR_
#define _LISTMACR_

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // ndef _LISTMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\filehc.h ===
/*++

	FILEHC.H

	This file defines the public interfaces for issuing async Reads/Writes to a file
	using the fileh wrapper library.

--*/

#ifndef	_FILEHC_H_
#define	_FILEHC_H_

// Published parts of the File Handle cache !


#ifdef	__cplusplus	
extern	"C"	{
#endif

typedef	VOID
(*PFN_IO_COMPLETION)(
		IN	struct	FIO_CONTEXT*	pContext,
		IN	struct	FH_OVERLAPPED*	lpo, 
		IN	DWORD		cb, 
		IN	DWORD		dwCompletionStatus
		);



struct	FH_OVERLAPPED	{
/*++

	This structure defines the extended OVERLAPPED structure
	used by the File IO layer implemented in this module.

	The first 5 elements of this structure are identical to 
	NT's OVERLAPPED structure and have the exact same semantics.
	
	The final additional parameter is a pointer to a 
	function that will be called to complete the IO.

--*/
	UINT_PTR	Internal ;
	UINT_PTR	InternalHigh ;
	DWORD		Offset ;
	DWORD		OffsetHigh ;
	HANDLE		hEvent ;
	PFN_IO_COMPLETION	pfnCompletion ;	
	UINT_PTR	Reserved1 ;
	UINT_PTR	Reserved2 ;
	UINT_PTR	Reserved3 ;
	UINT_PTR	Reserved4 ;
} ;

typedef	struct	FH_OVERLAPPED*	PFH_OVERLAPPED ;

struct	FIO_CONTEXT	{
/*++

	This structure defines the context object
	that is used to represent file handles.

--*/
    //
    //  Temporary hack - mailmsg object assumes it can put a NULL in us !
    //
    DWORD       m_dwTempHack ;

	//
	//	The context signature !
	//
	DWORD		m_dwSignature ;

	//
	//	The users file handle !
	//
	HANDLE		m_hFile ;

	//
	//  The offset to back fill Lines header - nntp aware only
	//
	DWORD       m_dwLinesOffset;

	//
	//  Header length - nntp aware only
	//
	DWORD       m_dwHeaderLength;
} ;

typedef	FIO_CONTEXT*	PFIO_CONTEXT ;


#ifdef	_FILEHC_IMPLEMENTATION_
#define	FILEHC_EXPORT	__declspec( dllexport )	
#else
#define	FILEHC_EXPORT	__declspec( dllimport )	
#endif


//
//	Initialize the DLL for Async IO - 
//	This is a counting initialize - for each call to FIOInitialize()
//	there should be a matching call to FIOTerminate
//
FILEHC_EXPORT
BOOL	__stdcall
FIOInitialize(
    IN DWORD dwFlags
    );

//
//	Terminate the DLL's support for Async IO !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOTerminate(
    VOID
    );

//
//	Do an async read against the File !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOReadFile(
    IN  PFIO_CONTEXT	pContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
    IN  FH_OVERLAPPED *	lpo
    );

//
//	Do an async read against the file - pass extra args
//	so that if the FIO_CONTEXT is doing dot stuffing for the user
//	it can do so efficiently !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOReadFileEx(
    IN  PFIO_CONTEXT	pContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
	IN	DWORD			BytesAvailable, // must be >= BytesToWrite - number of bytes I can mess with.
    IN  FH_OVERLAPPED *	lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ? 
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
    );


//
//	Do an async write against the file !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOWriteFile(
    IN  PFIO_CONTEXT	pContext,
    IN  LPCVOID			lpBuffer,
    IN  DWORD			BytesToWrite,
    IN  FH_OVERLAPPED * lpo
    );

//
//	Do an async write against the file - pass extra args
//	so that if the FIO_CONTEXT is doing dot stuffing for the user
//	it can do so efficiently !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOWriteFileEx(
	IN	PFIO_CONTEXT	pContext,
	IN	LPVOID			lpBuffer,
	IN	DWORD			BytesToWrite,
	IN	DWORD			BytesAvailable, // must be >= BytesToWrite - number of bytes I can mess with.
	IN	FH_OVERLAPPED*	lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ? 
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
	) ;

//
//	Callback functions which create things in the cache !
//
//	NOTE: this is equivalent to FCACHE_RICHCREATE_CALLBACK where
//
//	pfDidWeScanIt - returns FALSE
//	pfIsStuffed - return FALSE
//	pfStoredWithDots - return FALSE
//
typedef	
HANDLE	
(__stdcall	*FCACHE_CREATE_CALLBACK) (
		IN	LPSTR	lpstrName, 
		IN	LPVOID	lpvData, 
		OUT	DWORD*	cbFileSize,
		OUT	DWORD*	cbFileSizeHigh
		) ;


//
//	Callback functions which create things in the cache !
//
//	This function will be called by CacheRichCreateFile().
//
//	lpstrName - the name of the file 
//	lpvData - User provided data, provided to CacheRichCreateFile
//	cbFileSize - The function should return the size of the file through this
//	cbFileSizeHigh - place to return the High DWORD of the file size
//	pfDidWeScanIt - if THIS is true then at some point the created file has been
//		scanned for DOTs appearing at the beginning of lines
//	pfIsStuffed - This is only meaningfull if pfDidWeScanIt==TRUE, in which case
//		if this is TRUE this indicates that there are DOTs at the beginning of lines
//	pfStoredWithDots - If this is TRUE then it indicates that any DOTs that appear
//		at the beginning of lines are stored with an extra dot as required in NNTP, 
//		SMTP and POP3 protocols.  if this is FALSE then the message is stored without
//		DOT stuffing.
//
typedef	
HANDLE	
(__stdcall	*FCACHE_RICHCREATE_CALLBACK) (
		IN	LPSTR	lpstrName, 
		IN	LPVOID	lpvData, 
		OUT	DWORD*	cbFileSize, 
		OUT	DWORD*	cbFileSizeHigh,
        OUT BOOL*   pfDidWeScanIt,
        OUT BOOL*   pfIsStuffed,
		OUT	BOOL*	pfStoredWithDots, 
		OUT	BOOL*	pfStoredWithTerminatingDot
		) ;

//
//	Initialize the File Handle Cache - 
//
//	NOTE : this will automatically initialize the DLL for async
//	IO as well !
//
FILEHC_EXPORT
BOOL	__stdcall
InitializeCache() ;

//
//	Terminate the cache !
//	
//	NOTE : this will terminate the DLL for async IO as well !
//
FILEHC_EXPORT
BOOL	__stdcall
TerminateCache() ;

//
//	Associate a file with an async context !
//
FILEHC_EXPORT
PFIO_CONTEXT	__stdcall	
AssociateFile(	HANDLE	hFile	) ;

//
//	This allows the user to specify whether file stores content with extra DOTS
//	added for RFC 822 protocols (i.e. NNTP and SMTP DATA commands).
//
//	NOTE: AssociateFile() is the same as AssociateFileEx( hFile, FALSE ) ;
//
//	hFile - The file that contains message content, or in which we will write message content
//	fStoreWithDots - if TRUE then each period or DOT in the file which starts a line
//		but is NOT part of the terminating CRLF.CRLF will be stored with an extra dot
//		adjacent to it.  This is the on the wire format for NNTP for instance.
//
FILEHC_EXPORT
PFIO_CONTEXT	__stdcall
AssociateFileEx(	HANDLE	hFile,
					BOOL	fStoreWithDots, 
					BOOL	fStoredWithTerminatingDot 
					) ;

//
//	Add a reference to a context - 
//	
//	Each call to AddRefContext() must be matched by a corresponding
//	call to ReleaseContext().   Both AssociateFile and CacheCreateFile()
//	also add a single reference which must be matched by a call to ReleaseContext().
//
FILEHC_EXPORT
void	__stdcall	
AddRefContext(	PFIO_CONTEXT ) ;

//
//	Release a Context !
//
//	FIO_CONTEXT's are reference counted - the user must call
//	this for each successfull call to CacheCreateFile(), and 
//	each call to InsertFile() where fKeepReference is TRUE
//
FILEHC_EXPORT
void	__stdcall
ReleaseContext(	PFIO_CONTEXT ) ;

//
//	Close a handle associated with a non-cached FIO_CONTEXT
//
//	This is used to Close the file handle within a context.
//	This only succeeds if the FIO_CONTEXT is not cached !
//
FILEHC_EXPORT
BOOL	__stdcall
CloseNonCachedFile(	PFIO_CONTEXT	) ;

//
//	Create a file in the cache, or find an existing one !
//
//	If the file is not in the cache, the cache will call 
//	pfnCallBack with lpv to do the actual work of calling
//	CreateFile().
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
CacheCreateFile(	IN	LPSTR	lpstrName, 
					IN	FCACHE_CREATE_CALLBACK	pfnCallBack, 
					IN	LPVOID	lpv, 
					IN	BOOL	fAsyncContext
					) ;
					
//
//	Create a file in the cache or find an existing one, 
//	if we create the file we can add properties onto it in 
//	the cache !
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
CacheRichCreateFile(	IN	LPSTR	lpstrName, 
						IN	FCACHE_RICHCREATE_CALLBACK	pfnCallBack, 
						IN	LPVOID	lpv, 
						IN	BOOL	fAsyncContext
						) ;

//
//	This function allows a user to remove all files with the specified 
//	Name from the cache.  if fAllPrefixes is TRUE, we will remove all files
//	where the Name matches the beginning of the path !
//	If fAllPrefixes is FALSE then we will remove only the one file which 
//	exactly matches lpstrName !
//
FILEHC_EXPORT
void	__stdcall
CacheRemoveFiles(	IN	LPSTR	lpstrName,
					IN	BOOL	fAllPrefixes
					) ;
//
//	Insert the file into the cache !
//
//	This function will add the file handle in the FIO_CONTEXT
//	to the cache.  All searches by lpstrName will find this
//	item untill it expires from the cache.
//
//	If fKeepReference is TRUE then the user must make a call to 
//	ReleaseContext() for the inserted FIO_CONTEXT !
//
FILEHC_EXPORT
BOOL	__stdcall	
InsertFile(		IN	LPSTR	lpstrName, 
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL	fKeepReference 
				) ;

//
//	Report the file size that we've cached with the handle
//
FILEHC_EXPORT
DWORD	__stdcall
GetFileSizeFromContext(	IN	FIO_CONTEXT*	pContext, 
						OUT	DWORD*			pcbFileSizeHigh
						) ;

//----------------------------------------------------------------------
// NAME CACHE NAME CACHE NAME CACHE - 
//
//	Name Cache API's
//
//

//
//	This is the function pointer provided by clients to compare 
//	keys.  This must be provided on all calls.
//
//	The function has memcmp() semantics, i.e. it must order the keys
//	consistently, and return <0 if key1 is smaller then key2, ==0 if the
//	keys match and >0 if key1 is greater then key2.
//
typedef	
int
(__stdcall	*CACHE_KEY_COMPARE)(	IN	DWORD	cbKey1, 
									IN	LPBYTE	lpbKey1,
									IN	DWORD	cbKey2, 
									IN	LPBYTE	lpbKey2
									) ;

//
//	This is the function provided by clients to compute a hash 
//	value on Keys - NOTE: The Cache will provide a hash function 
//	IF the user does not, however the internally provided hash
//	function is best only for things that appear to be regular strings.
//
typedef
DWORD
(__stdcall	*CACHE_KEY_HASH)(	IN	LPBYTE	lpbKey, 
								IN	DWORD	cbKey
								) ;

//
//	This is the generic callback function that is provided to the 
//	cache to help examine items within the cache.
//	The BOOL return value is meaningfull to the Cache API's only
//	on the following calls : 
//
//
typedef	
BOOL
(__stdcall	*CACHE_READ_CALLBACK)(	IN	DWORD	cb, 
									IN	LPBYTE	lpb, 
									IN	LPVOID	lpvContext
									) ;

//	
//	This is a callback that is called whenever we destroy an entry in 
//	the name cache - this is called once for both key and data components, 
//	and gives the client a chance to track any relationships 
//
//	NOTE : if the client does not associate 
//	data with the name, the function will only be called for the Key data.
//
typedef
void
(__stdcall	*CACHE_DESTROY_CALLBACK)(	IN	DWORD	cb, 
										IN	LPBYTE	lpb
										) ;

//
//	This is a callback this is called whenever we evaluate a security descriptor.
//	If it is not provided we will call the standard NT AccessCheck() call !
//
//	The function has the same signature as AccessCheck, however there are arguments
//	we don't use - PrivilegeSet will always be NULL and PrivilegeSetLength will always be 0 !
//
typedef
BOOL
(WINAPI	*CACHE_ACCESS_CHECK)(	IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
								IN	HANDLE					hClientToken,
								IN	DWORD					dwDesiredAccess, 
								IN	PGENERIC_MAPPING		GenericMapping, 
								IN	PRIVILEGE_SET*			PrivilegeSet, 
								IN	LPDWORD					PrivilegeSetLength,
								IN	LPDWORD					GrantedAccess, 
								IN	LPBOOL					AccessStatus
								) ;


//
//	This is the externally exposed structure representing a Name Cache - 
//	it doesn't contain any fields usefull for a client, but must be passed
//	back into all of the name cache API's
//
struct	NAME_CACHE_CONTEXT	{
	//
	//	Signature DWORD ! - user must not touch this !
	//
	DWORD		m_dwSignature ;
} ;

typedef	struct	NAME_CACHE_CONTEXT*	PNAME_CACHE_CONTEXT ;

//
//	API's for creating/manging NAME CACHE's
//	NOTE : Name Cache's are reference counted, and if this
//	function is called twice with the same name we will 
//	Add a reference to an existing Name Cache.
//
FILEHC_EXPORT
PNAME_CACHE_CONTEXT	__stdcall
FindOrCreateNameCache(
		//
		//	Must not be NULL ! - this is CASE SENSITVE !
		//
		LPSTR	lpstrName, 
		//
		//	Must not be NULL !
		//
		CACHE_KEY_COMPARE		pfnKeyCompare, 
		//
		//	This may be NULL, in which case the cache will provide one !
		//
		CACHE_KEY_HASH			pfnKeyHash, 
		//
		//	The following two function pointers may be NULL !
		//
		CACHE_DESTROY_CALLBACK	pfnKeyDestroy, 
		CACHE_DESTROY_CALLBACK	pfnDataDestroy
		) ;

//
//	API's for releasing the NAME CACHE !
//
//	The caller must guarantee the thread safety of this call - This function must not 
//	be called if any other thread is simultanesouly executing within 
//	CacheFindContectFromName(), AssociateContextWithName(), AssociateDataWithName(), or InvalidateName() 
//
FILEHC_EXPORT
long	__stdcall
ReleaseNameCache(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache
		) ;


//
//	API's for setting options on the name cache - this can be used to change
//	how Security is evaluated !
//
FILEHC_EXPORT
BOOL	__stdcall
SetNameCacheSecurityFunction(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache, 
		//
		//	This is the function pointer that will be used to evaluate security - 
		//	this may be NULL - if it is we will use the Win32 Access Check !
		//
		CACHE_ACCESS_CHECK		pfnAccessCheck
		) ;

//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer, 
//	if the user passed a NULL FIO_CONTEXT to AssociateContextWithName() !
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					) ;


//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer, 
//	if the user passed a NULL FIO_CONTEXT to AssociateContextWithName() !
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindSyncContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					) ;


//
//	Cache Associate context with name !
//	This insert a Name into the Name cache, that will find the specified FIO_CONTEXT !
//
//	If the name is already present in the cache, this will fail with GetLastError()==ERROR_DUP_NAME !
//
FILEHC_EXPORT
BOOL	__stdcall
AssociateContextWithName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User may provide some arbitrary data to assoicate with the name !
					//	
					IN	LPBYTE	lpbData, 
					IN	DWORD	cbData, 
					//
					//	User may provide a self relative security descriptor to 
					//	be associated with the name !
					//
					IN	PGENERIC_MAPPING		pGenericMapping,
					IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
					//
					//	User provides the FIO_CONTEXT that the name should reference
					//
					FIO_CONTEXT*		pContext,
					//
					//	User specifies whether they wish to keep their reference on the FIO_CONTEXT
					//
					BOOL				fKeepReference
					) ;

//
//	This function allows the user to remove a single name and all associated data
//	from the name cache.
//
FILEHC_EXPORT
BOOL
InvalidateName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName
					) ;
	

//
//	End of Name Cache API's
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
//	DOT STUFFING API's
//

//
//  This function gets an FIO_CONTEXT with the requested state.
//  We may or may not create a new FIO_CONTEXT, if we do create one we'll stick 
//  it into the cache so it can be used again !
//  NOTE: if we have to do work, the user has the only reference to the resulting
//  FIO_CONTEXT which will go away when they call ReleaseContext() !
//
//	pContext - the original FIO_CONTEXT
//	lpstrName - the file name associated with pContext
//	fWantItDotStuffed - if TRUE the resulting FIO_CONTEXT should be dot stuffed !
//	fTerminatorIncluded - if this is TRUE the source FIO_CONTEXT contains a terminating
//	dot that we should be carefull not to stuff !
//
//	NOTE: We may return the same FIO_CONTEXT as the caller provided - in which case
//	an extra reference has been added that needs to be dropped with ReleaseContext() !
//
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
ProduceDotStuffedContext(	IN	FIO_CONTEXT*	pContext,
                            IN  LPSTR           lpstrName,
							IN  BOOL			fWantItDotStuffed // if TRUE add dots, if FALSE remove dots
							) ;

//
//	This function takes a source FIO_CONTEXT (pContextSource) and copies
//	the content into pContextDestination.
//
//	The user specifies whether the Destination FIO_CONTEXT should be dot stuffed
//	with fWantItDotStuffed, and whether the source FIO_CONTEXT includes the 
//	terminating CRLF.CRLF
//
//	The out parameter pfModified is TRUE if there were modifications when
//	Source was copied to Destination !
//
//	The function returns TRUE if successfull, FALSE otherwise !
//
FILEHC_EXPORT
BOOL	__stdcall
ProduceDotStuffedContextInContext(
							IN	FIO_CONTEXT*	pContextSource,
							IN	FIO_CONTEXT*	pContextDestination,
							IN	BOOL			fWantItDotStuffed, 
							OUT	BOOL*			pfModified
							) ;
							



//
//	Find out whether the file has a terminating 'CRLF.CRLF' sequence !
//
FILEHC_EXPORT
BOOL	__stdcall
GetIsFileDotTerminated(	IN	FIO_CONTEXT*	pContext ) ;

//
//	Set whether the file has a terminating 'CRLF.CRLF' sequence !
//
FILEHC_EXPORT
void	__stdcall
SetIsFileDotTerminated(	IN	FIO_CONTEXT*	pContext,
						IN	BOOL			fIsDotTerminated 
						) ;

//
//	Enable dot stuffing properties on the write path of the file
//	handle cache of this message !
//
//	if fEnable is FALSE then all dot stuffing behaviour is turned
//	off.
//
//	if fStripDots is TRUE the File Handle Cache will convert 
//	occurrences of "\r\n." to "\r\n" within your message.
//
//	if fStripDots is FALSE the FileHandle Cache will convert occurrences
//	of "\r\n.." to "\r\n" within your message.
//	
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotStuffingOnWrites(	IN	FIO_CONTEXT*	pContext, 
						//
						//	fEnable == FALSE means ignore fStripDots, and writes are unmodified
						//
						IN	BOOL			fEnable,
						//
						//	fStripDots == TRUE means we remove dots that are dot stuffed, 
						//	fStripDots == FALSE means that we add dots to make the message dot stuffed
						//
						IN	BOOL			fStripDots
						) ;

#if 0 
//
//	This function temporarily disabled !
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotStuffingOnReads(	IN	FIO_CONTEXT*	pContext,
						IN	BOOL			fEnable,
						IN	BOOL			fStripDots
						) ;
#endif

//
//	Enable dot scanning properties on the write path 
//	of the file handle cache for this file !
//
//	if fEnable is TRUE the we will examine each write
//	that goes through us to determine whether the
//	message has any occurrences of "\r\n.".
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotScanningOnWrites(	IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fEnable
						) ;

//
//	
//	This function should be called when we have finished doing all writes to an FIO_CONTEXT
//	This function should be paired with SetDotStuffingOnWrites() and the fStripDots
//	parameter should be the same as when SetDotStuffingOnWrites() was called.
//
//	We will update the Dot Stuffing State of the FIO_CONTEXT and discard 
//	all dot stuffing memory and stuff that may have been required !
//
//	If this function call is paired with a call to SetDotScanningOnWrites() fStripDots should be TRUE !
//
FILEHC_EXPORT
void	__stdcall
CompleteDotStuffingOnWrites(	IN	FIO_CONTEXT*	pContext, 
								IN	BOOL			fStripDots
								) ;

//
//	This will cause us to examine each read for occurrences of 
//	"\r\n."
//
//	NOTE : the user must use ASYNC Reads for this to work - we will assert
//	if the user tries to pend any synchronous reads while we are in this state !
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotScanningOnReads(	IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fEnable
						) ;
							

//
//	If any of the dot stuffing mechanism our turned on, 
//	this will get a count of the number of occurrences/modifications
//	have occurred.
//
//	if fReads is TRUE we get the count for occurrences on Read's
//	if fReads is FALSE we get the count for occurrences on Write's
//
//	if dot stuffing was turned off or not enabled somehow then
//	GetDotStuffState() will return FALSE.
//
//	NOTE: A NULL pfStuffed is not allowed !
//
FILEHC_EXPORT
BOOL	__stdcall
GetDotStuffState(		IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fReads,
						OUT	BOOL*			pfStuffed,
						OUT	BOOL*			pfStoredWithDots
						) ;

//
//	In this case we always assume that the FIO_CONTEXT is not going to be dot stuffed.
//	fRequiresStuffing == TRUE indicates that it SHOULD BE stuffed.
//	fRequiresStuffing == FALSE indicates that the message does not need dot stuffing.
//
FILEHC_EXPORT
void	__stdcall
SetDotStuffState(		IN	FIO_CONTEXT*	pContext, 
						//
						//	fIsStuffed is only relevant when fKnown == TRUE
						//
						IN	BOOL			fKnown,		// We do know the dot stuff state
						//
						//	if fKnown is TRUE then fIsStuffed is meaningfull, when thats the case
						//	if fIsStuffed is TRUE then the message 
						//
						IN	BOOL			fRequiresStuffing// if fKnown is TRUE this arg is meaningfull
						) ;


#ifdef	__cplusplus	
}
#endif



#endif	// _FILEHC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\lockq.h ===
//
//	LOCKQ.H
//
//	This file contains classes which define a queue mechanism which will
//	safely synchronize additions and removals from the queue, where every
//	thread which appends to the Queue must be prepared to deal with owning the
//	queue.  Additionally, elements will come off the queue in the same order
//	that they are appended.
//
//	The structure of a thread using this stuff should be the following :
//
//	class	CUsefull : public CQElement { } ;
//	template	CLockQueue< CUsefull >	UsefullQ ;
//
//	
//		if( UsefullQ.Append( pUsefull ) ) {
//
//			while( UsefullQ.GetHead( &pUsefullWorkItem )  ) {
//				/* Do some usefull work. */
//
//				UsefullQ.Remove() ;
//			}
//		}
//
//	Implementation Schedule for all classes defined in this file :
//		1 day
//
//	Unit Test schedule for all classes defined in this file :
//		1 day
//		Unit Testing should consist of a multi theaded appli
//
//



#ifndef	_LOCKQ_H_
#define	_LOCKQ_H_

#include	"qbase.h"

#ifdef	DEBUG
#define	LOCKQ_DEBUG
#endif

#ifdef	_DEBUG
#ifndef	LOCKQ_DEBUG
#define	LOCKQ_DEBUG
#endif
#endif



//------------------------------------------------
class	CQueueLockV1	{
//
// This class implements a queue which is multi-threaded safe for append operations.
//	In addition, this queue will synchronize removal of elements amongst those
//	threads which are appending to the queue.  Each thread that appends to the
//	queue potentially becomes the owner of the removal lock of the queue.
//  (If Append() returns TRUE the thread owns the removal lock of the queue.)
//	There is no way to relinquish the removal lock except to empty the queue.
//	Emptying the queue must be done as a series of GetHead(), Remove() calls.
//	A GetHead() call MUST preceed each Remove() call.
//
//	Each time the thread calls GetHead, it will be
//	told whether it still owns the removallock (when the queue is emptied the lock is
//	relinquished.)
//	Owning the removal lock in no way interferes with other threads appending to the queue.
//
//	The class uses InterlockedExchange to handle all synchronization issues.
//
//	For appending - InterlockedExchange does the following :
//		Exchange the tail pointer with what we want to be the new tail.
//		Make the old tail that we got from the exchange point to the new element.
//		The list is now intact. Because there is an extra element in the queue
//		(m_special) the tail pointer never becomes NULL.
//
//	For synchronization safety -
//		InterlockedExchange is used on the element next pointers in order to
//		determine what thread has the removal lock.
//		Each call to GetHead Exchanges the head's next pointer with LOCKVAL.
//		Each Append call will also Exchange the old tail elements next value
//		with the new m_pTail value.  So there are only two threads which can
//		be exchanging the next pointer at any given instant.
//
//		The remove thread either gets 0 or a NON-NULL pointer after its Exchange.
//
//		If it gets Zero, it knows it Exchanged before the Appending thread,
//		in which case it loses the lock (since it can't safely do anything.)
//		If it gets a Non-Zero value, the other thread exchanged first.
//		In this case, the remover still has the lock and repairs the list.
//
//		In the case of the appending thread - after its Exchange it either gets
//		zero or LOCKVAL.
//
//		If the appending thread gets zero, it Exchanged first so the other thread
//		should hold onto the lock.   If the appending thread gets LOCKVAL then it
//		owns the lock.
//
//		Finally, note that there is ALWAYS AT LEAST ONE ELEMENT in the Queue (m_special).
//		This means that if there is anything of value in the queue at all then
//		there must be at least TWO elements in the queue (and m_pHead->p is non null).
//
//
//	Usage should be the following in each worker thread :
//		CQueueLockV1	*pQueue ;
//
//		if( pQueue->Append( p ) ) {
//			CQueueElement *pWork ;
//
//			while( pQueue->GetHead( pWork ) ) {
//				/* Do work on pWork It is safe to do further calls to pQueue->Append()
//					while doing whatever work.  That does not mean those Appended
//					elements will be processed on this thread. */
//
//				pQueue->Remove() ;
//			}
//		}
//
private :
	enum	CONSTANTS	{
		LOCKVAL	= -1,
	} ;

	CQElement	m_special ;	// element used ensure that the Queue always contains
							// something.
	CQElement	m_release ;	// element used with ReleaseLock calls to give up the
							//  RemovalLock on the Queue.

	//	This pointer is set after a call to ReleaseLock() - and
	//	will pointer to the queue element before the m_release element in
	//	the queue.
	CQElement	*m_pHead ;
	CQElement	*m_pTail ;

#ifdef	LOCKQ_DEBUG
	DWORD		m_dwOwningThread ;
	LONG		m_lock ;
#endif

	BOOL	OfferOwnership( CQElement* p ) ;
	CQElement*	GetFront( ) ;
public :
	CQueueLockV1( ) ;
	~CQueueLockV1( ) ;

	//
	//	Append - returns TRUE if we have added the first element into the queue
	//	and we now own the lock.
	//
	BOOL		Append( CQElement *p ) ;

	//
	// Remove - takes the head element off the list.  The head element should be
	//  examined with GetHead().  As long as we are calling GetHead() at least once
	//	before each call to Remove(), the synchronization aspects of the queue will
	//	work.
	//
	void		Remove( ) ;

	//
	//	GetHead - returns TRUE as long as there is an element to be had at the front
	//	 of the queue.  The element pointer is returned through the reference to a pointer.
	//
	BOOL		GetHead( CQElement *&p ) ;

	//
	// RemoveRelease - takes the head element off the list.
	//	Also offers the removal lock to any other thread out there.
	//	If the function returns TRUE then this thread still has the lock,
	//	otherwise another thread has it.
	//
	BOOL		RemoveAndRelease( ) ;

} ;


#ifndef _NO_TEMPLATES_
//--------------------------------------------------
template<	class	Element	>
class	TLockQueueV1	{
//
//	This template is designed for use with Elements derived from CQElement.
//	This will use the CQueueLockV1 class above to implement a locking queue containing
//	elements of type 'Element'.
//
private :
	CQueueLockV1		m_queue ;
public :
	inline	TLockQueueV1() ;
	inline	~TLockQueueV1() ;

	//	Add an element to the Queue - if this returns TRUE we own the lock.
	inline	BOOL		Append( Element* p ) ;

	// remove an element from the Queue - lock ownership does not change.
	inline	void		Remove( ) ;
	inline	BOOL		GetHead( Element *&p ) ;
	inline	BOOL		RemoveAndRelease( ) ;
} ;
#endif

#define	DECLARE_LOCKQ( Type )	\
class	LockQ ## Type	{	\
private :	\
	CQueueLockV1		m_queue ;	\
public :	\
	LockQ ## Type ()	{}	\
	~LockQ ## Type ()	{}	\
	BOOL	Append(	Type *	p )	{	return	m_queue.Append( (CQElement*)p ) ;	}	\
	void	Remove( )	{	m_queue.Remove() ;	}	\
	BOOL	GetHead(	Type	*&p	)	{	\
CQElement*	pTemp = 0;	\
BOOL	fTemp = m_queue.GetHead( pTemp ) ;	\
p = (Type*)pTemp ;	\
return	fTemp ;	\
}	\
	BOOL	RemoveAndRelease( )	{	\
return	m_queue.RemoveAndRelease() ;	\
}	\
} ;

#define	INVOKE_LOCKQ( Type )	LockQ ## Type


class	CQueueLock	{
//
// This class implements a queue which is multi-threaded safe for append operations.
//	In addition, this queue will synchronize removal of elements amongst those
//	threads which are appending to the queue.  Each thread that appends to the
//	queue potentially becomes the owner of the removal lock of the queue.
//  (If Append() returns TRUE the thread owns the removal lock of the queue.)
//	There is no way to relinquish the removal lock except to empty the queue.
//
//	Usage should be the following in each worker thread :
//		CQueueLock	*pQueue ;
//
//		if( pQueue->Append( p ) ) {
//			CQueueElement *pWork ;
//
//			while( (pWork = pQueue->RemoveAndRelease( )) ) {
//				/* Do work on pWork It is safe to do further calls to pQueue->Append()
//					while doing whatever work.  That does not mean those Appended
//					elements will be processed on this thread. */
//			}
//		}
//
private :

	//
	//	Class constants - LOCKVAL that special value marking the queue element
	//	which is ready to be grabbed !
	//
	enum	CONSTANTS	{
		LOCKVAL	= -1,
	} ;

	//
	//	Element which always remains in the list !
	//
	CQElement	m_special ;	

	//
	//	Head of the list
	//
	CQElement	*m_pHead ;

	//
	//	Tail of the list !
	//
	CQElement	*m_pTail ;

public :
	//
	//	Initialize the queue to an empty state -
	//	and also sets things up so that the first Append
	//	will own the lock !	
	//
	inline	CQueueLock( ) ;

	//
	//	Also initializes to an empty state, however
	//	allows caller to specify whether queue can be
	//	grabbed on the first Append !
	//
	inline	CQueueLock(	BOOL	fSet ) ;

#ifdef	LOCKQ_DEBUG
	//
	//	Check that the queue is emptied when it is destroyed !
	//
	inline	~CQueueLock( ) ;
#endif

	//
	//	Set the lock to the lockable state where the next
	//	call to Append() will acquire the lock !
	//	This function is not thread safe and should only
	//	be called when we are sure there is only one thread
	//	using the object !
	//
	inline	void		Reset() ;

	//
	//	Append - returns TRUE if we have added the first element into the queue
	//	and we now own the lock.
	//
	inline	BOOL		Append( CQElement *p ) ;

	//
	//	return the head of the Queue - if we return NULL then some other thread
	//	may own the lcok the queue implicitly implies !
	//
	inline	CQElement*	RemoveAndRelease( ) ;

	//
	//	return the head of the Queue - but don't let any other threads
	//	grab the queue !
	//
	inline	CQElement*	Remove( ) ;

} ;


template<	class	Element	>
class	TLockQueue	{
//
//	This template is designed for use with Elements derived from CQElement.
//	This will use the CQueueLock class above to implement a locking queue containing
//	elements of type 'Element'.
//
private :
	CQueueLock		m_queue ;

public :
	//
	//	Create an empty queue
	//
	inline	TLockQueue() ;

	//
	//	Create empty queue and specify whether the
	//	lock is initially available
	//
	inline	TLockQueue( BOOL	fSet ) ;

	//	
	//	Caller must already have lock and be only thread
	//	using object - make the lock available !
	//
	inline	void	Reset() ;
	
	//
	//	Add an element to the Queue - if this returns TRUE we own the lock.
	//
	inline	BOOL		Append( Element* p ) ;
	
	//
	// remove an element from the Queue - lock ownership does not change unless this
	//	returns NULL !
	//
	inline	Element*	RemoveAndRelease( ) ;

	//
	//	remove an element from the Queue - but don't relinquish lock !
	//
	inline	Element*	Remove() ;
} ;

#include	"lockq.inl"

#endif		// _LOCKQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\lockq.inl ===
inline
CQueueLock::CQueueLock( ) : m_pHead( &m_special ), m_pTail( &m_special ) {

	//
	// This function initializes the queue to an empty state.
	// In the empty state the queue contains one element which
	// has a Next pointer of 'LOCKVAL'.
	// The next pointer is initialized to LOCKVAL so that the first
	// append to the Queue owns the removal lock.
	//
 	m_special.m_pNext = (CQElement*)((DWORD_PTR)LOCKVAL) ;
}

inline
CQueueLock::CQueueLock(	BOOL	fSet ) :
	m_pHead( &m_special ),
	m_pTail( &m_special )	{

	if( fSet ) {
		m_special.m_pNext = (CQElement*)((DWORD_PTR)LOCKVAL) ;
	}	else	{
		m_special.m_pNext = 0 ;
	}
}

#ifdef	LOCKQ_DEBUG

CQueueLock::~CQueueLock( ) {
//	_ASSERT( m_pHead == m_pTail ) ;
//	_ASSERT( m_pHead == &m_special ) ;
//	_ASSERT( m_dwOwningThread == 0 || m_dwOwningThread == GetCurrentThreadId() ) ;

}
#endif

inline void
CQueueLock::Reset(	)	{

	m_pTail->m_pNext = (CQElement*)((DWORD_PTR)LOCKVAL) ;

}



inline BOOL
CQueueLock::Append( CQElement*	pAppend ) {
	//
	// We must set the Next pointer to NULL so that the next
	//	we come to append the tail pointer is properly set up.
	//
//	_ASSERT( pAppend->m_pNext == 0 ) ;
	pAppend->m_pNext = 0 ;

	// Get the old tail pointer.  This guy won't be touched by the
	// remove thread if his next pointer is still NULL.
	CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (LPVOID *)&m_pTail, pAppend ) ;

	// After we set the old tail pointer's next pointer to NON NULL
	// he becomes fair game for whoever is removing from the queue.
	// We may become the thread removing from the queue if whoever was
	// previously removing got to the last element and changed its next pointer
	// to LOCKVAL.
	//
	// NOTE : This thread and any thread doing removals should be the only
	//	threads touching the pNext field of the pTemp element.
	//
	PVOID	l = InterlockedExchangePointer( (LPVOID *)&(pTemp->m_pNext), pAppend ) ;

	return	l == (PVOID)LOCKVAL ;
}

inline CQElement*
CQueueLock::RemoveAndRelease( void )	{


	CQElement*	p = (CQElement*)InterlockedCompareExchangePointer( (LPVOID*)&m_pHead->m_pNext,
												(LPVOID)LOCKVAL,
												0 ) ;

	_ASSERT( (DWORD_PTR)p != LOCKVAL ) ;

	if( p != 0 ) {

		//
		//	There is an element following the head element -
		//	so we can safely examine the head element has nobody
		//	will touch its next pointer but us !
		//

		CQElement*	pReturn = m_pHead ;
		m_pHead = p ;
		pReturn->m_pNext = 0 ;

		if( pReturn == &m_special ) {

			//
			//	We can ignore the return value of Append -
			//	it must always succeed as we are the only thread
			//	that is allowed to relinquish the lock, and we ain't going to
			//	do so !
			//
			Append( pReturn ) ;

			//
			//	Now, we must offer ownership again !
			//

			p = (CQElement*)InterlockedCompareExchangePointer( (LPVOID*)&m_pHead->m_pNext,
														(LPVOID)LOCKVAL,
														0 ) ;

			_ASSERT( (DWORD_PTR)p != LOCKVAL ) ;

			if( p != 0 ) {

				//
				//	The head element must not be the special element -
				//	we took pains already to see that that didn't happen -
				//	so we can safely remove the element from the head of the queue.
				//

				pReturn = m_pHead ;
				m_pHead = p ;
				pReturn->m_pNext = 0 ;
		
				return	pReturn ;
			}

		}	else	{

			return	pReturn ;

		}
	
	}

	//
	//	_ASSERT( p==0 ) ;
	//

	return	p ;
}

inline CQElement*
CQueueLock::Remove( void )	{


	CQElement*	p = m_pHead->m_pNext ;
	if( p != 0 ) {

		//
		//	There is an element following the head element -
		//	so we can safely examine the head element has nobody
		//	will touch its next pointer but us !
		//
		p = m_pHead ;

		if( p == &m_special ) {

			//
			//	The head element is the special element, so we want
			//	to send it to the back and try examining the front again !
			//

			m_pHead = p->m_pNext ;
			p->m_pNext = 0 ;

			//
			//	We can ignore the return value of Append -
			//	it must always succeed as we are the only thread
			//	that is allowed to relinquish the lock, and we ain't going to
			//	do so !
			//
			Append( p ) ;

			//
			//	Ok, lets see if we can remove the head element now !
			//

			p = m_pHead->m_pNext ;
		}
	
		//
		//	If this ain't 0, then the next pointer is set
		//	and no other threads will be touching the next pointer,
		//	so we can safely advance the head pointer and return
		//	the first element.
		//
		if( p != 0 ) {

			p = m_pHead ;
			//
			//	The head element must not be the special element -
			//	we took pains already to see that that didn't happen -
			//	so we can safely remove the element from the head of the queue.
			//
			m_pHead = p->m_pNext ;
			p->m_pNext = 0 ;
	
			return	p ;
		}
	}

	return	0 ;
}


template< class Element >
inline	TLockQueue< Element >::TLockQueue( ) { }

template< class	Element >
inline	TLockQueue< Element >::TLockQueue( BOOL fSet ) :
	m_queue( fSet ) { }

template< class Element >
inline	void	TLockQueue< Element >::Reset()	{
	m_queue.Reset() ;
}

template< class Element >
inline	BOOL	TLockQueue< Element >::Append( Element *p ) {
	return	m_queue.Append( (CQElement*)p ) ;
}

template< class Element >
inline	Element*	TLockQueue< Element >::Remove( ) {
	return	(Element*) m_queue.Remove( ) ;
}

template< class Element >
inline	Element*	TLockQueue< Element >::RemoveAndRelease( ) {
	return	(Element*) m_queue.RemoveAndRelease( ) ;
}



#ifndef _NO_TEMPLATES_

template< class Element >
inline	TLockQueueV1< Element >::TLockQueueV1( ) { }

template< class Element >
inline	TLockQueueV1< Element >::~TLockQueueV1( ) { }

template< class Element >
inline	BOOL	TLockQueueV1< Element >::Append( Element *p ) {
	return	m_queue.Append( (CQElement*)p ) ;
}

template< class Element >
inline	void	TLockQueueV1< Element >::Remove( ) {
	m_queue.Remove( ) ;
}

template< class Element >
inline	BOOL	TLockQueueV1< Element >::GetHead( Element* &p ) {
	CQElement	*pTemp = 0 ;
	BOOL	fTemp = m_queue.GetHead( pTemp ) ;
	p = (Element*)pTemp ;
	return	fTemp ;
}

template< class Element >
inline	BOOL	TLockQueueV1< Element >::RemoveAndRelease( ) {
	return	m_queue.RemoveAndRelease( ) ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\mapfile.h ===
/* -------------------------------------------------------------------------
  mapfile.h
      (was bbmpfile.h)
  	Definitions for the mapped file class.

  Copyright (C) 1995   Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:49 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on pvMapFile() and derivatives.

   ------------------------------------------------------------------------- */

/*
 *    Generic class to handle mapped files.  Part of the reason for
 *  turning this into a class is to allow tracking of mapping/unmapping
 *  and thus to handle clean up of dangling mappings in exception
 *  handling code.  Tracking is enabled if the fTrack parameter is
 *  specified.
 */

#ifndef _MAPFILE_H_
#define _MAPFILE_H_

//   Bits used in the m_fFlags field below.
#define	MF_TRACKING		0x0001			// Tracking use of this item.
#define	MF_RELINQUISH	0x0002			// Someone else to free this item.

class CCreateFile
{
public:
    virtual HANDLE CreateFileHandle( LPCSTR szFileName ) = 0;
};

class  CMapFile
{
public:
	CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease = 0, CCreateFile *pCreateFile = NULL);
	CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack );
	CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbSizeIncrease = 0 );
	CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0, BOOL fZero = FALSE );

	~CMapFile( void );

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

private:
	DWORD	 m_cb;			// Size of this file.
	void	*m_pv;			// Address to use.
	DWORD	 m_fFlags;		// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero = FALSE );
};


/*
 *    For compatability with old code, the original functions remain.
 */

void *pvMapFile( DWORD *pdwSize, const char  *pchFileName, BOOL bWriteEnable );
void *pvMapFile( DWORD *pdwSize, const WCHAR *pwchFileName, BOOL bWriteEnable );

void *pvMapFile(const char  *pchFileName, BOOL bWriteEnable,
		 DWORD  *pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

void * pvFromHandle( HANDLE hFile,	BOOL bWriteEnable,
		DWORD * pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

class  CMapFileEx
{
public:
	CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0 );
	~CMapFileEx( void );
	void Cleanup( void );		// cleanup in case of failure !

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return (void*)m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

	//	Protect and Unprotect mapping
	BOOL	ProtectMapping();
	BOOL	UnprotectMapping();

private:
	DWORD	 m_cb;								// Size of this file.
	LPBYTE	 m_pv;								// Address to use.
	DWORD	 m_fFlags;							// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	HANDLE	 m_hFile;							// handle to the mapped file
	LPBYTE	 m_pvFrontGuard;					// front guard page
	DWORD	 m_cbFrontGuardSize;				// front guard page size
	LPBYTE	 m_pvRearGuard;						// rear guard page
	DWORD	 m_cbRearGuardSize;					// rear guard page size
	CRITICAL_SECTION m_csProtectMap;			// crit sect to protect/unprotect mapping

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease );
};

#endif // DEBUG
#endif // _MAPFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\msgutils.h ===
#ifndef __MSGUTILS_H__
#define __MSGUTILS_H__

HRESULT CreateDummyISMTPServer(
			DWORD		dwInstance,
			LPSTR		szLogFileName,
			ISMTPServer	**ppServer
			);

HRESULT CreateStoreDriver(
			DWORD				dwInstance,
			ISMTPServer			*pServer,
			IMailMsgStoreDriver	**ppStore
			);

HRESULT CreateUnboundMailMsg(
			IMailMsgProperties	**ppMsg
			);

HRESULT BindMailMsg(
			IMailMsgProperties		*ppMsg,
			IMailMsgStoreDriver		*pStore,
			IMailMsgPropertyStream	*pStream,
			HANDLE					hFile
			);

HRESULT CreateBoundMailMsg(
			IMailMsgStoreDriver	*pStore,
			IMailMsgProperties	**ppMsg
			);

HRESULT GenerateRandomProperties(
			IMailMsgProperties	*pMsg,
			DWORD				dwNumGlobalProperties,
			DWORD				dwAvgGlobalPropertyLength,
			DWORD				dwNumRecipients,
			DWORD				dwAvgUserNameLength,
			DWORD				dwAvgDomainNameLength,
			DWORD				dwNumRecipientProperties,
			DWORD				dwAvgRecipientPropertyLength
			);


class CDummySMTPServer : public ISMTPServer
{
public:
	CDummySMTPServer(
				DWORD	dwInstance,
				LPSTR	szLogFileName
				)
	{
		m_dwInstance = dwInstance;
		if (szLogFileName)
			lstrcpy(m_szLogFileName, szLogFileName);
		else
			*m_szLogFileName = '\0';
		m_hLogFile = INVALID_HANDLE_VALUE;
		m_ulRefCount = 1;
	}
	~CDummySMTPServer()
	{
		if (m_hLogFile != INVALID_HANDLE_VALUE)
			CloseHandle(m_hLogFile);
	}

	HRESULT Init();

	STDMETHOD(QueryInterface)(REFIID iid, void  **ppvObject);
	STDMETHOD_(ULONG, AddRef)(void) {return(InterlockedIncrement(&m_ulRefCount));};
	STDMETHOD_(ULONG, Release) (void) 
	{
		LONG    lRefCount = InterlockedDecrement(&m_ulRefCount);
		if (lRefCount == 0)
		{
            delete this;
		}

		return(lRefCount);
	};

	STDMETHOD (AllocMessage)(
				IMailMsgProperties **ppMsg
				);

	STDMETHOD (SubmitMessage)(
				IMailMsgProperties *pMsg
				);

	STDMETHOD (TriggerLocalDelivery)(IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes);

	STDMETHOD (ReadMetabaseString)(DWORD MetabaseId, LPBYTE Buffer, DWORD * BufferSize, BOOL fSecure);

	STDMETHOD (ReadMetabaseDword)(DWORD MetabaseId, DWORD * dwValue);
	STDMETHOD (ServerStartHintFunction)();
	STDMETHOD (ServerStopHintFunction)();

private:
	LONG	m_ulRefCount;
	DWORD	m_dwInstance;
	char	m_szLogFileName[MAX_PATH * 2];
	HANDLE	m_hLogFile;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\mailmsgprops.h ===
/*
        @doc MAILMSG PROPERTIES
        @module mailmsgprops.h | MailMsg Properties for SMTP and NNTP
*/

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mailmsgprops.h

Abstract:

    This module contains the definitions for the MailMsg 
    Object property ID's.


--*/

#ifndef __MAILMSGPROPS_H__
#define __MAILMSGPROPS_H__

/*=======================================================================*/
// These macros are used to define the tables of property ID's.


#define IMMPID_START_LIST(name,start,guid)    struct __declspec(uuid(guid)) tagIMMPID_##name##_STRUCT;\
                                            typedef enum tagIMMPID_##name##_ENUM {\
                                                IMMPID_##name##_BEFORE__ = (start)-1,
#define IMMPID_END_LIST(name)                    IMMPID_##name##_AFTER__\
                                            } IMMPID_##name##_ENUM;


/*=======================================================================*/


// These are the per-message properties.

IMMPID_START_LIST(MP,0x1000,"13384CF0-B3C4-11d1-AA92-00AA006BC80B")

    // @const IMMPID | IMMPID_MP_RECIPIENT_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_RECIPIENT_LIST,

    // @const IMMPID | IMMPID_MP_CONTENT_FILE_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_CONTENT_FILE_NAME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_SMTP | 
    //  ANSI String - SMTP Address of sender
    IMMPID_MP_SENDER_ADDRESS_SMTP,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X500 | 
    //  ANSI String - X500 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X500,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X400 | 
    //  String - X400 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X400,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN | 
    //  String - Legacy DN Address of sender
    IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN,

    // @const IMMPID | IMMPID_MP_DOMAIN_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_DOMAIN_LIST,

    // @const IMMPID | IMMPID_MP_PICKUP_FILE_NAME | 
    //  ANSI String - Filename of msg file in pickup directory
    IMMPID_MP_PICKUP_FILE_NAME,

    // @const IMMPID | IMMPID_MP_AUTHENTICATED_USER_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_AUTHENTICATED_USER_NAME,

    // @const IMMPID | IMMPID_MP_CONNECTION_IP_ADDRESS | 
    //  ANSI String - IP address of MTA or client that submitted this message
    IMMPID_MP_CONNECTION_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_HELO_DOMAIN | 
    //  ANSI String - Domain name used in HELO/EHLO when message was submitted
    IMMPID_MP_HELO_DOMAIN,

    // @const IMMPID | IMMPID_MP_EIGHTBIT_MIME_OPTION | 
    //  BOOL - TRUE if message body is 8-bit MIME
    IMMPID_MP_EIGHTBIT_MIME_OPTION,

    // @const IMMPID | IMMPID_MP_CHUNKING_OPTION | 
    //   *** OBSOLETE ***
    IMMPID_MP_CHUNKING_OPTION,

    // @const IMMPID | IMMPID_MP_BINARYMIME_OPTION | 
    //  BOOL - TRUE if message body is binary MIME
    IMMPID_MP_BINARYMIME_OPTION,

    // @const IMMPID | IMMPID_MP_REMOTE_AUTHENTICATION_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_AUTHENTICATION_TYPE,

    // @const IMMPID | IMMPID_MP_ERROR_CODE | 
    //   *** OBSOLETE ***
    IMMPID_MP_ERROR_CODE,

    // @const IMMPID | IMMPID_MP_DSN_ENVID_VALUE | 
    //  Value of RFC1891 ENVID of submitted message
    IMMPID_MP_DSN_ENVID_VALUE,

    // @const IMMPID | IMMPID_MP_DSN_RET_VALUE | 
    //  ANSI String of what follows ESMTP RET
    IMMPID_MP_DSN_RET_VALUE,                

    // @const IMMPID | IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE,    

    // @const IMMPID | IMMPID_MP_ARRIVAL_TIME | 
    //  FILETIME that message arrived in system
    IMMPID_MP_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MESSAGE_STATUS | 
    // MP_STATUS_* value describing status of message system 
    IMMPID_MP_MESSAGE_STATUS,

    // @const IMMPID | IMMPID_MP_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration
    IMMPID_MP_EXPIRE_DELAY,         

    // @const IMMPID | IMMPID_MP_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration
    IMMPID_MP_EXPIRE_NDR,           

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_DELAY,   

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_NDR,     

    // @const IMMPID | IMMPID_MP_ARRIVAL_FILETIME | 
    //  FILETIME when message was submitted to queue
    IMMPID_MP_ARRIVAL_FILETIME,     

    // @const IMMPID | IMMPID_MP_HR_CAT_STATUS | 
    //  HRESULT MsgCat status (ie CAT_W_SOME_UNDELIVERABLE_MSGS)
    IMMPID_MP_HR_CAT_STATUS,        

    // @const IMMPID | IMMPID_MP_MSG_GUID | 
    //  String GUID ID which is only used if you want need to be able to replace 
    //  this message with another newer version.  This property is only 
    //  effective when used for a small amount of mail on the server, and is
    //  best suited for versioned mail (like DS replication).
    IMMPID_MP_MSG_GUID,        

    // @const IMMPID | IMMPID_MP_SUPERSEDES_MSG_GUID | 
    //  String GUID ID which this message superscedes.  If a message with with a 
    //  IMMPID_MP_MSG_GUID equal to this property is still on the server, then
    //  that message will not be sent out.

    IMMPID_MP_SUPERSEDES_MSG_GUID,

    // @const IMMPID | IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input was scanned for <CRLF>.<CRLF> in the msg
    // body
    IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF,

    // @const IMMPID | IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input had any <CRLF>.<CRLF>
    //
    IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, 

    // @const IMMPID | IMMPID_MP_MSG_SIZE_HINT | 
    //  Provides an approximate size of the message content.  Does not convert
    //  message, or guarantee accuracy. For an accurate message size (but at 
    //  a higher performance cost) use IMailMsgProperties::GetContentSize.
    //
    IMMPID_MP_MSG_SIZE_HINT, 

    // @const IMMPID | IMMPID_MP_RFC822_MSG_ID | 
    //  String -- RFC 822 Message Id header.
    IMMPID_MP_RFC822_MSG_ID,

    // @const IMMPID | IMMPID_MP_RFC822_MSG_SUBJECT | 
    //  String -- RFC822 subject header
    IMMPID_MP_RFC822_MSG_SUBJECT,

    // @const IMMPID | IMMPID_MP_RFC822_FROM_ADDRESS | 
    //  String -- RFC822 from address
    IMMPID_MP_RFC822_FROM_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_TO_ADDRESS | 
    //  String -- RFC822 To address
    IMMPID_MP_RFC822_TO_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_CC_ADDRESS | 
    //  String -- RFC822 Cc address
    IMMPID_MP_RFC822_CC_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_BCC_ADDRESS | 
    //  String -- RFC822 Bcc address
    IMMPID_MP_RFC822_BCC_ADDRESS,

    // @const IMMPID | IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS | 
    //  String -- server IP Address
    IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_SERVER_NAME | 
    //  String -- server name
    IMMPID_MP_SERVER_NAME,

    // @const IMMPID | IMMPID_MP_SERVER_VERSION | 
    //  String -- server version
    IMMPID_MP_SERVER_VERSION,

    // @const IMMPID | IMMPID_MP_NUM_RECIPIENTS | 
    //  DWORD -- number of recipients
    IMMPID_MP_NUM_RECIPIENTS,


    // @const IMMPID | IMMPID_MP_X_PRIORITY | 
    //  DWORD -- the priority of message
    IMMPID_MP_X_PRIORITY,

    // @const IMMPID | IMMPID_MP_FROM_ADDRESS | 
    //  String -- From: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_FROM_ADDRESS,
    
    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS | 
    //  String -- Sender: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_SENDER_ADDRESS,

    // @const IMMPID | IMMPID_MP_DEFERRED_DELIVERY_FILETIME | 
    //  FILETIME -- Universal time to wait until before allowing
    //  message to be delivered.
    IMMPID_MP_DEFERRED_DELIVERY_FILETIME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_OTHER | 
    //  ANSI String - with the format "type:address"
    IMMPID_MP_SENDER_ADDRESS_OTHER,

    // @const IMMPID | IMMPID_MP_ORIGINAL_ARRIVAL_TIME | 
    //  FILETIME that message arrived in first exchange system
    IMMPID_MP_ORIGINAL_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MSG_CLASS | 
    //  The Message class of the mail, e.g. syste, replication, etc...
    IMMPID_MP_MSGCLASS,

    // @const IMMPID | IMMPID_MP_CONTENT_TYPE | 
    //  The content type of message.
    //  ANSI STRING.
    IMMPID_MP_CONTENT_TYPE,

    //@const IMMPID | IMMPID_MP_ENCRYPTION_TYPE |
    // DWORD - 0, no encryption
    //         1, signed only
    //         2, encrypted
    IMMPID_MP_ENCRYPTION_TYPE,

    //@const IMMPID | IMMPID_MP_CONNECTION_SERVER_PORT | 
    // DOWRD - Port (if any) that this message was submitted on 
    IMMPID_MP_CONNECTION_SERVER_PORT,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_USER | 
    // ASCII STRING - Name of authenticated user
    IMMPID_MP_CLIENT_AUTH_USER,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_TYPE | 
    // ASCII STRING - Type of authentication used (AUTH keyword)
    IMMPID_MP_CLIENT_AUTH_TYPE,

    // Add new per-message properties above this line.
IMMPID_END_LIST(MP)


// Message classes
// @const DWORD | MP_MSGCLASS_SYSTEM
// for msgs of type -- system
#define MP_MSGCLASS_SYSTEM       1

// @const DWORD | MP_MSGCLASS_REPLICATION
// for msgs of type -- replication
#define MP_MSGCLASS_REPLICATION  2

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- delivery report
#define MP_MSGCLASS_DELIVERY_REPORT     3

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- non-delivery report
#define MP_MSGCLASS_NONDELIVERY_REPORT  4


// Message status property values defined:

// @const DWORD | MP_STATUS_SUCCESS | 
//  Initial status of message
#define MP_STATUS_SUCCESS                    0

// @const DWORD | MP_STATUS_RETRY | 
//  Status indicating retry.
#define MP_STATUS_RETRY                      1

// @const DWORD | MP_STATUS_ABORT_DELIVERY | 
//  Delivery of this message should be aborted and the message deleted.
#define MP_STATUS_ABORT_DELIVERY             2

// @const DWORD | MP_STATUS_BAD_MAIL | 
//  This message should be moved to badmail.
#define MP_STATUS_BAD_MAIL                   3

// @const DWORD | MP_STATUS_SUBMITTED | 
//  Message has been submitted for delivery.
#define MP_STATUS_SUBMITTED                  4

// @const DWORD | MP_STATUS_CATEGORIZED | 
//  Message has been categorized.
#define MP_STATUS_CATEGORIZED                5

// @const DWORD | MP_STATUS_ABANDON_DELIVERY | 
//  Delivery of this message should be abandoned until the service restarts
#define MP_STATUS_ABANDON_DELIVERY           6

//Per recipient flags for IMMPID_RP_RECIPIENT_FLAGS

// @const DWORD | RP_RECIP_FLAGS_RESERVED | 
//  You should not modify / use these bits
#define RP_RECIP_FLAGS_RESERVED     0x0000000F 

// @const DWORD | RP_DSN_NOTIFY_SUCCESS | 
//  Notify on success - set if RFC1891 NOTIFY=SUCCESS is used
#define RP_DSN_NOTIFY_SUCCESS       0x01000000 

// @const DWORD | RP_DSN_NOTIFY_FAILURE | 
//  Notify on failure - set if RFC1891 NOTIFY=FAILURE is used
#define RP_DSN_NOTIFY_FAILURE       0x02000000 

// @const DWORD | RP_DSN_NOTIFY_DELAY | 
//  Notify on delay - set if RFC1891 NOTIFY=DELAY is used
#define RP_DSN_NOTIFY_DELAY         0x04000000 

// @const DWORD | RP_DSN_NOTIFY_NEVER | 
//  Never notify - set if RFC1891 NOTIFY=NEVER is used
#define RP_DSN_NOTIFY_NEVER         0x08000000 

// @const DWORD | RP_DSN_NOTIFY_MASK | 
//  Mask of all notify parameters
#define RP_DSN_NOTIFY_MASK          0x0F000000

//The following flags can be used in searches, but should not be set directly

// @const DWORD | RP_HANDLED | 
//  Recipient has either been delivered or should not be delivered
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_HANDLED                  0x00000010 

// @const DWORD | RP_GENERAL_FAILURE | 
//  some form of hard failure happend
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_GENERAL_FAILURE          0x00000020 

// @const DWORD | RP_DSN_HANDLED | 
//  Final DSN has been sent (or no DSN needs to be sent)
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_DSN_HANDLED              0x00000040 

//The following constants define how a message can be RP_HANDLED

// @const DWORD | RP_DELIVERED | 
//  The recipient has been delivered successfully
#define RP_DELIVERED                0x00000110 

// @const DWORD | RP_DSN_SENT_NDR | 
//  NDR (FAILED DSN) for this recipient has been sent
#define RP_DSN_SENT_NDR             0x00000450 

// @const DWORD | RP_FAILED | 
//  Recipient has a hard failure
#define RP_FAILED                   0x00000830 

// @const DWORD | RP_UNRESOLVED | 
//  This recipient was not resolved by categorization
#define RP_UNRESOLVED               0x00001030 

// @const DWORD | RP_ENPANDED | 
//  ***OBSOLETE*** (replaced by RP_EXPANDED)
#define RP_ENPANDED                 0x00002010 

// @const DWORD | RP_EXPANDED | 
//  This recipient is an expanded DL
#define RP_EXPANDED                 0x00002010 

// @const DWORD | RP_DSN_SENT_DELAYED | 
//  At least one Delay DSN sent
#define RP_DSN_SENT_DELAYED         0x00004000 

// @const DWORD | RP_DSN_SENT_EXPANDED | 
//  Expanded DSN has been sent
#define RP_DSN_SENT_EXPANDED        0x00008040 

// @const DWORD | RP_DSN_SENT_RELAYED | 
//  Relayed DSN has been sent
#define RP_DSN_SENT_RELAYED         0x00010040 

// @const DWORD | RP_DSN_SENT_DELIVERED | 
//  Delivered DSN has been sent
#define RP_DSN_SENT_DELIVERED       0x00020040 


// @const DWORD | RP_REMOTE_MTA_NO_DSN | 
//  Remote MTA does not advertise DSN support (relay might be needed)
#define RP_REMOTE_MTA_NO_DSN        0x00080000 


// @const DWORD | RP_ERROR_CONTEXT_STORE | 
//  Error happened in store driver
#define RP_ERROR_CONTEXT_STORE      0x00100000 

// @const DWORD | RP_ERROR_CONTEXT_CAT | 
//  Error happened during categorization
#define RP_ERROR_CONTEXT_CAT        0x00200000 

// @const DWORD | RP_ERROR_CONTEXT_MTA | 
//  Error happened in a MTA (eg SMTP stack)
#define RP_ERROR_CONTEXT_MTA        0x00400000 


// @const DWORD | RP_VOLATILE_FLAGS_MASK | 
//  Flags that can be used for temp storage
#define RP_VOLATILE_FLAGS_MASK      0xF0000000 
                                               //while a component has access to recipients
                                               //Once control of recipients is passed, value
                                               //is un-defined.

// @const DWORD | RP_DSN_NOTIFY_INVALID | 
//  *** OBSOLETE ***
#define RP_DSN_NOTIFY_INVALID       0x00000000 

/*=======================================================================*/


// These are the per-recipient properties.

IMMPID_START_LIST(RP,0x2000,"79E82048-D320-11d1-9FF4-00C04FA37348")


    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_SUCCESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_SUCCESS,

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_INVALID | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_INVALID,    

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE,            

    // @const IMMPID | IMMPID_RP_ADDRESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS,                

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE_SMTP | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE_SMTP,    

    // @const IMMPID | IMMPID_RP_ERROR_CODE | 
    //   HRESULT status code
    IMMPID_RP_ERROR_CODE,            

    // @const IMMPID | IMMPID_RP_ERROR_STRING | 
    //   *** OBSOLETE ***
    IMMPID_RP_ERROR_STRING,            

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_VALUE | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_VALUE,        

    // @const IMMPID | IMMPID_RP_DSN_ORCPT_VALUE | 
    //   ANSI string - \<address type\>;\<address\>
    IMMPID_RP_DSN_ORCPT_VALUE,        

    // @const IMMPID | IMMPID_RP_ADDRESS_SMTP | 
    //   ANSI string - SMTP address
    IMMPID_RP_ADDRESS_SMTP,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X400 | 
    //   ANSI string - X.400 address
    IMMPID_RP_ADDRESS_X400,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X500 | 
    //   ANSI string - X.500 address
    IMMPID_RP_ADDRESS_X500,            

    // @const IMMPID | IMMPID_RP_LEGACY_EX_DN | 
    //   ANSI string - DN for Exchange 5.5 and prev
    IMMPID_RP_LEGACY_EX_DN,            

    // @const IMMPID | IMMPID_RP_RECIPIENT_FLAGS | 
    //   Per-recipient DSN/delivery flags. Flag constansts start with RP_.
    IMMPID_RP_RECIPIENT_FLAGS,      

    // @const IMMPID | IMMPID_RP_SMTP_STATUS_STRING | 
    //   ANSI string - SMTP status string... if defined
    IMMPID_RP_SMTP_STATUS_STRING,   
                                    // *must* start with 3-digit status code

    // @const IMMPID | IMMPID_RP_DSN_PRE_CAT_ADDRESS | 
    //   Original address as received by MTA in
    IMMPID_RP_DSN_PRE_CAT_ADDRESS,  
                                    // IMMPID_RP_DSN_ORCPT_VALUE format

    // @const IMMPID | IMMPID_RP_MDB_GUID | 
    //   Categorizer stamps the MDB guid
    IMMPID_RP_MDB_GUID,             
                                    // for this recipient here

    // @const IMMPID | IMMPID_RP_USER_GUID | 
    //   Categorizer stamps the
    IMMPID_RP_USER_GUID,            
                                    // objectGUID of the user object here
    // @const IMMPID | IMMPID_RP_DOMAIN | 
    //   Alternate SMTP domain for categorization
    IMMPID_RP_DOMAIN,            

    // @const IMMPID | IMMPID_RP_ADDRESS_OTHER | 
    //   ANSI string - other address type
    IMMPID_RP_ADDRESS_OTHER,            

    // @const IMMPID | IMMPID_RP_DISPLAY_NAME |
    //   Unicode string - recipient display name
    IMMPID_RP_DISPLAY_NAME,

    // Add new per-recipient properties above this line.
IMMPID_END_LIST(RP)


/*=======================================================================*/


// These are per-message volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(MPV,0x3000,"CBE69706-C9BD-11d1-9FF2-00C04FA37348")

    // @const IMMPID | IMMPID_MPV_STORE_DRIVER_HANDLE | 
    //  Store driver context for this message.
    IMMPID_MPV_STORE_DRIVER_HANDLE,

    // @const IMMPID | IMMPID_MPV_MESSAGE_CREATION_FLAGS | 
    //  Flags set at creation of mailmsg.
    IMMPID_MPV_MESSAGE_CREATION_FLAGS,

    // @const IMMPID | IMMPID_MPV_MESSAGE_OPEN_HANDLES | 
    // The number of handles (property and content) open for this message.
    //   0 means no handles open.
    //   1 means property or content open.
    //   2 means both property and content open.
    IMMPID_MPV_MESSAGE_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_HANDLES | 
    // The current total number of open message handles (of any type) 
    // on this server. 
    IMMPID_MPV_TOTAL_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES | 
    // The current total number of open property streams on this server. 
    IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES | 
    // The current total number of open content handles on this server. 
    IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES,

    // Add new per-message volatile properties above this line.
IMMPID_END_LIST(MPV)

// This is the structure for the IMMPID_MPV_STORE_DRIVER_HANDLE property.
typedef struct tagIMMP_MPV_STORE_DRIVER_HANDLE {
    GUID guidSignature;    // signature of the store driver whose handle this is
} IMMP_MPV_STORE_DRIVER_HANDLE;

// Define message object creation flags

// @const DWORD | MPV_INBOUND_CUTOFF_EXCEEDED | 
//  Mailmsg configured cutoff has been exceeded... if this is an external 
//  delivery attempt, we should indicate that we do not have sufficient 
//  resources to accept the mail.
#define MPV_INBOUND_CUTOFF_EXCEEDED            0x00000001

// @const DWORD | MPV_WRITE_CONTENT |
//  Indicates that the content of this message can be modified.
#define MPV_WRITE_CONTENT                      0x00000002

/*=======================================================================*/


// These are per-recipient volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(RPV,0x4000,"79E82049-D320-11d1-9FF4-00C04FA37348")

    // @const IMMPID | IMMPID_RPV_DONT_DELIVER | 
    //  IMMPID_RPV_DONT_DELIVER is a boolean.  If set to TRUE, mailmsg 
    //  ignores this recipient when doing WriteList() (the recipient will 
    //  not exist in the new list).

    IMMPID_RPV_DONT_DELIVER,

    // @const IMMPID | IMMPID_RPV_NO_NAME_COLLISIONS | 
    //  IMMPID_RPV_NO_NAME_COLLISIONS is a boolean.  If set to TRUE, mailmsg 
    //  does not detect duplicates with this recipient on future calls to 
    //  AddSecondary().

    IMMPID_RPV_NO_NAME_COLLISIONS,
    // Add new per-recipient volatile properties above this line.
IMMPID_END_LIST(RPV)


// These are defined for backwards-compatability.  They will be removed
// ASAP...

// @const DWORD | IMMPID_RP_DONT_DELIVER | 
//   *** OBSOLETE ***
#define IMMPID_RP_DONT_DELIVER            IMMPID_RPV_DONT_DELIVER

// @const DWORD | IMMPID_RP_NO_NAME_COLLISIONS | 
//   *** OBSOLETE ***
#define IMMPID_RP_NO_NAME_COLLISIONS    IMMPID_RPV_NO_NAME_COLLISIONS


/*=======================================================================*/

// These are the per-message properties for NNTP

IMMPID_START_LIST(NMP,0x6000,"7433a9aa-20e2-11d2-94d6-00c04fa379f1")

    // @const IMMPID | IMMPID_NMP_SECONDARY_GROUPS | 
    //  An array of pointers to INNTPPropertyBag objects for each of
    //  the newsgroups that the article is being posted into for the
    //  current driver.
    IMMPID_NMP_SECONDARY_GROUPS,        

    // @const IMMPID | IMMPID_NMP_SECONDARY_ARTNUM | 
    //  An array of article numbers for each of the newsgroups that
    //  the article is being posted into for the current driver.
    IMMPID_NMP_SECONDARY_ARTNUM,

    // @const IMMPID | IMMPID_NMP_PRIMARY_GROUP | 
    //  A pointer to the INNTPPropertyBag object which represents the
    //  primary group for the current driver.
    IMMPID_NMP_PRIMARY_GROUP,

    // @const IMMPID | IMMPID_NMP_PRIMARY_ARTID | 
    //  The primary article number for the primary group.
    IMMPID_NMP_PRIMARY_ARTID,

    // @const IMMPID | IMMPID_NMP_POST_TOKEN | 
    //   The HTOKEN representing the client context.
    IMMPID_NMP_POST_TOKEN,                

    // @const IMMPID | IMMPID_NMP_NEWSGROUP_LIST | 
    //   The string of newsgroups which this article is being stored in.
    IMMPID_NMP_NEWSGROUP_LIST,            

    // @const IMMPID | IMMPID_NMP_HEADERS | 
    //   A string containing the headers of the message.
    IMMPID_NMP_HEADERS,                    

    // @const IMMPID | IMMPID_NMP_NNTP_PROCESSING | 
    //   Flags which describe how the message should be processed.  The 
    //   possible values are: NMP_PROCESS_POST, NMP_PROCESS_CONTROL, 
    //   and NMP_PROCESS_MODERATOR.  
    IMMPID_NMP_NNTP_PROCESSING,            

    // @const IMMPID | IMMPID_NMP_NNTP_APPROVED_HEADER | 
    //   A string containing the Approved: header of the message  
    IMMPID_NMP_NNTP_APPROVED_HEADER,            

    // Add new per-message properties above this line.
IMMPID_END_LIST(NMP)

// flags for IMMPID_NMP_NNTP_PROCESSING

// @const DWORD | NMP_PROCESS_POST | 
//  Set this flag to allow the NNTP server to post this message.
#define NMP_PROCESS_POST            0x00000001

// @const DWORD | NMP_PROCESS_CONTROL | 
//  Set this flag to allow the NNTP server to process control headers in this
//  message.
#define NMP_PROCESS_CONTROL            0x00000002

// @const DWORD | NMP_PROCESS_MODERATOR | 
//  Set this flag to allow the NNTP server to run this message through the
//  default moderated posting path.
#define NMP_PROCESS_MODERATOR        0x00000004

/*=======================================================================*/


// This is the starting range for user-reserved properties

IMMPID_START_LIST(CPV,0x8000,"A2A76B2A-E52D-11d1-AA64-00C04FA35B82")

    // @const IMMPID | IMMPID_CP_START | 
    //  Start of range
    IMMPID_CP_START,
IMMPID_END_LIST(CPV)


/*=======================================================================*/

// This table collects the data about the properties so that range-
// checking can be performed.  If any new property ranges are
// defined, they must be added to this structure.


#define IMMPID_DECLARE_ENTRY(name)    {&_uuidof(tagIMMPID_##name##_STRUCT),\
                                     IMMPID_##name##_BEFORE__+1,\
                                     IMMPID_##name##_AFTER__-1}

extern const __declspec(selectany) struct tagIMMPID_GUIDLIST_ITEM {
                                       const GUID *pguid;
                                       DWORD dwStart;
                                       DWORD dwLast;
                                   } IMMPID_GUIDS[] = {IMMPID_DECLARE_ENTRY(MP),
                                                       IMMPID_DECLARE_ENTRY(RP),
                                                       IMMPID_DECLARE_ENTRY(MPV),
                                                       IMMPID_DECLARE_ENTRY(RPV),
                                                       {&GUID_NULL,0,0}};

#endif // _MAILMSGPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\nntptype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntptype.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _NNTPTYPE_
#define _NNTPTYPE_

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD FEED_TYPE;

#define FEED_TYPE_INVALID           0xffffffff

//
// Function types
//
typedef
BOOL
(*GET_DEFAULT_DOMAIN_NAME_FN)(PCHAR,DWORD);

//
// Type of feed we are managing
//

#define FEED_TYPE_PULL              0x00000000
#define FEED_TYPE_PUSH              0x00000001
#define FEED_TYPE_PASSIVE           0x00000002
#define FEED_ACTION_MASK            0x0000000f

//
// Type of server we are talking to
//

#define FEED_TYPE_PEER              0x00000000
#define FEED_TYPE_MASTER            0x00000010
#define FEED_TYPE_SLAVE             0x00000020
#define FEED_REMOTE_MASK            0x000000f0

//
// Should this go through a secure channel like SSL?
//

#define FEED_TYPE_SSL               0x00000100

//
// Valid bits
//

#define FEED_TYPE_MASK              (FEED_TYPE_PULL | FEED_TYPE_PUSH | \
                                    FEED_TYPE_PASSIVE | FEED_TYPE_PEER | \
                                    FEED_TYPE_MASTER | FEED_TYPE_SLAVE | \
                                    FEED_TYPE_SSL)


//
// Macros
//

#define FEED_IS_SSL( _x )           (((_x) & FEED_TYPE_SSL) != 0)
#define FEED_IS_SLAVE( _x )         (((_x) & FEED_TYPE_SLAVE) != 0)
#define FEED_IS_MASTER( _x )        (((_x) & FEED_TYPE_MASTER) != 0)
#define FEED_IS_PEER( _x )          (((_x) & 0x000000f0) == 0)
#define FEED_IS_PULL( _x )          (((_x) & 0x0000000f) == 0)
#define FEED_IS_PUSH( _x )          (((_x) & FEED_TYPE_PUSH) != 0)
#define FEED_IS_PASSIVE( _x )       (((_x) & FEED_TYPE_PASSIVE) != 0)

//
//  Simple types.
//

#define CHAR char                       // For consitency with other typedefs.

typedef DWORD APIERR;                   // An error code from a Win32 API.
typedef INT SOCKERR;                    // An error code from WinSock.

#ifdef __cplusplus
}
#endif

#endif _NNTPTYPE_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\perfcat.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: perfcat.h
//
// Contents: Categorizer performance counter block
//
// History:
// jstamerj 1999/02/26 21:17:46: Created.
//
//-------------------------------------------------------------
#ifndef __PERFCAT_H__
#define __PERFCAT_H__


typedef struct _tagCATLDAPPERFBLOCK
{
    //
    // LDAP counters
    //
    DWORD Connections;
    DWORD ConnectFailures;
    DWORD OpenConnections;
    DWORD Binds;
    DWORD BindFailures;
    DWORD Searches;
    DWORD PagedSearches;
    DWORD SearchFailures;
    DWORD PagedSearchFailures;
    DWORD SearchesCompleted;
    DWORD PagedSearchesCompleted;
    DWORD SearchCompletionFailures;
    DWORD PagedSearchCompletionFailures;
    DWORD GeneralCompletionFailures;
    DWORD AbandonedSearches;
    DWORD PendingSearches;

} CATLDAPPERFBLOCK, *PCATLDAPPERFBLOCK;


typedef struct _tagCATPERFBLOCK
{
    //
    // Counters per-categorization
    //
    DWORD CatSubmissions;
    DWORD CatCompletions;
    DWORD CurrentCategorizations;
    DWORD SucceededCategorizations;
    DWORD HardFailureCategorizations;
    DWORD RetryFailureCategorizations;
    DWORD RetryOutOfMemory;
    DWORD RetryDSLogon;
    DWORD RetryDSConnection;
    DWORD RetryGeneric;
    
    //
    // Counters per message
    //
    DWORD MessagesSubmittedToQueueing;
    DWORD MessagesCreated;
    DWORD MessagesAborted;

    //
    // Counters per recip
    //
    DWORD PreCatRecipients;
    DWORD PostCatRecipients;
    DWORD NDRdRecipients;

    DWORD UnresolvedRecipients;
    DWORD AmbiguousRecipients;
    DWORD IllegalRecipients;
    DWORD LoopRecipients;
    DWORD GenericFailureRecipients;
    DWORD RecipsInMemory;

    //
    // Counters per sender
    //
    DWORD UnresolvedSenders;
    DWORD AmbiguousSenders;

    //
    // Counters per address lookup
    //
    DWORD AddressLookups;
    DWORD AddressLookupCompletions;
    DWORD AddressLookupsNotFound;

    //
    // Misc counters
    //
    DWORD MailmsgDuplicateCollisions;

    //
    // LDAP counters
    //
    CATLDAPPERFBLOCK LDAPPerfBlock;

} CATPERFBLOCK, *PCATPERFBLOCK;



#endif //__PERCAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\nntpapi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nntpapi.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _NNTPAPI_
#define _NNTPAPI_

#ifdef __cplusplus
extern "C" {
#endif

#include <inetcom.h>
#ifndef NET_API_FUNCTION
#define NET_API_FUNCTION _stdcall
#endif

//
// 0 - Perfmon stats
//

typedef struct _NNTP_STATISTICS_0 {

    //
    // total bytes sent/received, including protocol msgs
    //

    LARGE_INTEGER   TotalBytesSent;
    LARGE_INTEGER   TotalBytesReceived;

    //
    // incoming connections (includes all connections including hubs)
    //

    DWORD           TotalConnections;       // total connects from Nntp clients
    DWORD           TotalSSLConnections;
    DWORD           CurrentConnections;     // current number
    DWORD           MaxConnections;         // max simultaneous

    DWORD           CurrentAnonymousUsers;
    DWORD           CurrentNonAnonymousUsers;
    DWORD           TotalAnonymousUsers;
    DWORD           TotalNonAnonymousUsers;
    DWORD           MaxAnonymousUsers;
    DWORD           MaxNonAnonymousUsers;

    //
    // outgoing connections
    //

    DWORD           TotalOutboundConnects;      // total
    DWORD           OutboundConnectsFailed;
    DWORD           CurrentOutboundConnects;    // current
    DWORD           OutboundLogonFailed;        // failed logon

    //
    // common
    //

    DWORD           TotalPullFeeds;
    DWORD           TotalPushFeeds;
    DWORD           TotalPassiveFeeds;

    DWORD           ArticlesSent;           // articles sent by us
    DWORD           ArticlesReceived;       // articles received

    DWORD           ArticlesPosted;
    DWORD           ArticleMapEntries;
    DWORD           HistoryMapEntries;
    DWORD           XoverEntries;

    DWORD           ControlMessagesIn;          // number of control messages received
    DWORD           ControlMessagesFailed;      // number of control messages failed
    DWORD           ModeratedPostingsSent;      // number of moderated postings we attempt to send to an smtp server
    DWORD           ModeratedPostingsFailed;    // number of moderated postings we failed to send to an smtp server

    //
    // The number of sessions currently in a flow controlled state where
    // writes to disk are not keeping up with network reads.
    //

    DWORD           SessionsFlowControlled;

    //
    // The number of articles expired since the service was started
    //
    
    DWORD           ArticlesExpired;

    //
    // User command counters - one counter for each type of command
    //
    
    DWORD           ArticleCommands;
    DWORD           GroupCommands;
    DWORD           HelpCommands;
    DWORD           IHaveCommands;
    DWORD           LastCommands;
    DWORD           ListCommands;
    DWORD           NewgroupsCommands;
    DWORD           NewnewsCommands;
    DWORD           NextCommands;
    DWORD           PostCommands;
    DWORD           QuitCommands;
    DWORD           StatCommands;
    DWORD           LogonAttempts;          // validations
    DWORD           LogonFailures;          // validation failures
    DWORD			CheckCommands;
    DWORD			TakethisCommands;
    DWORD			ModeCommands;
    DWORD			SearchCommands;
    DWORD			XHdrCommands;
    DWORD			XOverCommands;
    DWORD			XPatCommands;
    DWORD			XReplicCommands;

    DWORD           TimeOfLastClear;        // statistics last cleared

} NNTP_STATISTICS_0, *LPNNTP_STATISTICS_0;

//
// Information about the server
//

typedef struct _NNTP_CONFIG_INFO {

    //
    // Arcane Gibraltar field
    //

    FIELD_CONTROL FieldControl;

#if 0

    // !!!newfields
    // Notes:

    // None of the old fields really need to be here.  The ui doesn't
    // use them.

    // _INET_INFO_CONFIG_INFO must be fully supported by the nntpsvc.
    // The apis are defined in inetinfo.h

    // The virtual root structure must be extended to support retention
    // policy on directories.  Retention policy is by posted date (days) or
    // by newsgroup size (megabytes).

    //
    // The new fields:
    //

    //
    // Connection Information
    //

    BOOL            AllowClientConnections;     // Allow clients to connect?
    BOOL            AllowServerFeeds;           // Allow servers to connect?
    DWORD           MaximumFeedConnections;     // Max Number of server feeds

    //
    // Organization & Path ID
    //

    LPWSTR          Organization;
    LPWSTR          PathID;

#endif

    //  Following 2 fields controlled by FC_NNTP_POSTINGMODES
    
    //
    //  If TRUE then clients are allowed to post
    //
    BOOL            AllowClientPosting ;

    //
    //  If TRUE then we accept articles from feeds !
    //
    BOOL            AllowFeedPosting ;

    //  Following field controlled by FC_NNTP_ORGANIZATION

    //
    //  For the organization header in postings !
    //
    LPSTR           Organization ;

    //  Following 2 fields controlled by FC_NNTP_POSTLIMITS

    //
    //  Number of bytes a user can post into a file before we break the socket !
    //
    DWORD           ServerPostHardLimit ;       

    //
    //  Maximum posting sizes the server will accept - if the user exceeds this 
    //  (without exceeding the hard limit) we will reject the post.
    //
    DWORD           ServerPostSoftLimit ;

    //
    //  Maximum size of articles from a feed - hard and soft limits
    //
    DWORD           ServerFeedHardLimit ;
    DWORD           ServerFeedSoftLimit ;

    //
    // Encryption Capabilities flags
    //

    DWORD           dwEncCaps;

    //
    // SMTP address for moderated postings
    //

    LPWSTR          SmtpServerAddress;

    //
    // server's UUCP name
    //

    LPWSTR          UucpServerName;

    //
    // Control Messages allowed ?
    //

    BOOL            AllowControlMessages;

    //
    // Default moderator for moderated postings
    //

    LPWSTR          DefaultModerator;

} NNTP_CONFIG_INFO, * LPNNTP_CONFIG_INFO;

#define FC_NNTP_POSTINGMODES        	((FIELD_CONTROL)BitFlag(0))
#define FC_NNTP_ORGANIZATION        	((FIELD_CONTROL)BitFlag(1))
#define FC_NNTP_POSTLIMITS          	((FIELD_CONTROL)BitFlag(2))
#define FC_NNTP_FEEDLIMITS          	((FIELD_CONTROL)BitFlag(3))
#define FC_NNTP_ENCRYPTCAPS         	((FIELD_CONTROL)BitFlag(4))
#define FC_NNTP_SMTPADDRESS         	((FIELD_CONTROL)BitFlag(5))
#define FC_NNTP_UUCPNAME            	((FIELD_CONTROL)BitFlag(6))
#define FC_NNTP_CONTROLSMSGS        	((FIELD_CONTROL)BitFlag(7))
#define FC_NNTP_DEFAULTMODERATOR		((FIELD_CONTROL)BitFlag(8))
#define FC_NNTP_AUTHORIZATION			((FIELD_CONTROL)BitFlag(9))
#define FC_NNTP_DISABLE_NEWNEWS     	((FIELD_CONTROL)BitFlag(10))
#define FC_MD_SERVER_SS_AUTH_MAPPING  	((FIELD_CONTROL)BitFlag(11))
#define FC_NNTP_CLEARTEXT_AUTH_PROVIDER ((FIELD_CONTROL)BitFlag(12))
#define FC_NTAUTHENTICATION_PROVIDERS  	((FIELD_CONTROL)BitFlag(13))
#define FC_NNTP_ALL                 (                             \
                                      FC_NNTP_POSTINGMODES			| \
                                      FC_NNTP_ORGANIZATION			| \
                                      FC_NNTP_POSTLIMITS			| \
                                      FC_NNTP_FEEDLIMITS        	| \
                                      FC_NNTP_ENCRYPTCAPS       	| \
                                      FC_NNTP_SMTPADDRESS       	| \
                                      FC_NNTP_UUCPNAME				| \
                                      FC_NNTP_CONTROLSMSGS      	| \
                                      FC_NNTP_DEFAULTMODERATOR  	| \
                                      FC_NNTP_AUTHORIZATION     	| \
                                      FC_NNTP_DISABLE_NEWNEWS   	| \
                                      FC_MD_SERVER_SS_AUTH_MAPPING  | \
                                      FC_NNTP_CLEARTEXT_AUTH_PROVIDER	| \
                                      FC_NTAUTHENTICATION_PROVIDERS | \
                                      0 )

//
// Feed Server information
//

typedef struct _NNTP_FEED_INFO {

    LPWSTR          ServerName;         // feed server
    FEED_TYPE       FeedType;

    //
    // date/time specified when doing a NEWNEWS/NEWGROUP
    //

    FILETIME        PullRequestTime;

    //
    // Date/Time scheduling is to start
    //

    FILETIME        StartTime;

    //
    // Time the next feed is scheduled
    //

    FILETIME        NextActiveTime;

    //
    // Interval in minutes between feeds.  If 0, a one time feed
    // specified by StartTime
    //

    DWORD           FeedInterval;

    //
    // Unique number assigned to this feed
    //

    DWORD           FeedId;

    //
    // Create automatically?
    //

    BOOL            AutoCreate;

    //
    //  Disable the feed ?
    //
    BOOL            Enabled ;

    DWORD           cbNewsgroups;
    LPWSTR          Newsgroups;
    DWORD           cbDistribution;
    LPWSTR          Distribution;
    DWORD           cbUucpName ;
    LPWSTR          UucpName ;
    DWORD           cbFeedTempDirectory ;
    LPWSTR          FeedTempDirectory ;

    //
    //  For outgoing feeds - maximum number of connect attempts
    //  before we disable the feed !
    //
    DWORD           MaxConnectAttempts ;

    //
    //  For outgoing feeds - the number of concurrent sessions 
    //  to start.
    //
    DWORD           ConcurrentSessions ;

    //
    //  Feed session security - do we use a protocol like SSL 
    //  or PCT to encrypt the session !
    //
    
    DWORD           SessionSecurityType ;

    //
    //  Feed Nntp security - do we do some variotion of a logon 
    //  protocol !!
    //
    
    DWORD           AuthenticationSecurityType ;
    
    DWORD           cbAccountName ;
    LPWSTR          NntpAccountName ;
    DWORD           cbPassword ;
    LPWSTR          NntpPassword ;

    //
    //  Allow control messages on this feed ?
    //
    BOOL            fAllowControlMessages;

	//
	//	Port to use for outgoing feeds
	//
	DWORD			OutgoingPort;

	//
	//	Associated feed pair id
	//
	DWORD			FeedPairId;

} NNTP_FEED_INFO, *LPNNTP_FEED_INFO;


#define AUTH_PROTOCOL_NONE  0   
#define AUTH_PROTOCOL_MSN   1       // Sicily
#define AUTH_PROTOCOL_NTLM  2       // NTLM
#define AUTH_PROTOCOL_CLEAR 10      // clear text authinfo user/authinfo pass

#define SESSION_PROTOCOL_SSL    3
#define SESSION_PROTOCOL_PCT    4


//
// Flags for feed admin handshake
//
#define FEED_UPDATE_CONFIRM     0x00000000
#define FEED_UPDATING           0x00000001
#define FEED_UPDATE_COMPLETE    0x00000002

//
// Parameter mask. Used to indicate where the error was during a set.
//

#define FEED_PARM_FEEDTYPE          0x00000001
#define FEED_PARM_STARTTIME         0x00000002
#define FEED_PARM_FEEDID            0x00000004
#define FEED_PARM_FEEDINTERVAL      0x00000008
#define FEED_PARM_NEWSGROUPS        0x00000010
#define FEED_PARM_DISTRIBUTION      0x00000020
#define FEED_PARM_SERVERNAME        0x00000040
#define FEED_PARM_AUTOCREATE        0x00000080
#define FEED_PARM_ENABLED           0x00000100
#define FEED_PARM_UUCPNAME          0x00000200
#define FEED_PARM_TEMPDIR           0x00000400
#define FEED_PARM_MAXCONNECT        0x00000800
#define FEED_PARM_SESSIONSECURITY   0x00001000
#define FEED_PARM_AUTHTYPE          0x00002000
#define FEED_PARM_ACCOUNTNAME       0x00004000
#define FEED_PARM_PASSWORD          0x00008000
#define FEED_PARM_CONCURRENTSESSION 0x00010000
#define FEED_PARM_ALLOW_CONTROL     0x00020000
#define FEED_PARM_OUTGOING_PORT     0x00040000
#define FEED_PARM_FEEDPAIR_ID		0x00080000
#define FEED_PARM_PULLREQUESTTIME   0x00100000

#define FEED_ALL_PARAMS             0xffffffff

//
// Indicates whether this field is to be changed
//

#define FEED_FEEDTYPE_NOCHANGE      0xffffffff
#define FEED_AUTOCREATE_NOCHANGE    0xffffffff
#define FEED_STARTTIME_NOCHANGE     0xffffffff
#define FEED_PULLTIME_NOCHANGE      0xffffffff
#define FEED_FEEDINTERVAL_NOCHANGE  0xffffffff
#define	FEED_MAXCONNECTS_NOCHANGE	0xffffffff
#define FEED_STRINGS_NOCHANGE       NULL

//
// Sessions
//
#define MAX_USER_NAME_LENGTH        64

typedef struct _NNTP_SESSION_INFO {

    FILETIME        SessionStartTime;
    DWORD           IPAddress;          // ipaddress
    DWORD           AuthenticationType; // type of authentication
    DWORD           PortConnected;      // port connected to
    BOOL            fAnonymous;         // using anonymous?
    CHAR            UserName[MAX_USER_NAME_LENGTH+1]; // logged on user

} NNTP_SESSION_INFO, *LPNNTP_SESSION_INFO;




typedef struct  _NNTP_EXPIRE_INFO   {
    //
    //  Expiration policies are numbered
    //
    DWORD       ExpireId ;

    //
    //  Units of Megabytes
    //
    DWORD       ExpireSizeHorizon ;

    //
    //  In retail builds - units of hours, debug builds - units of ??
    //
    DWORD       ExpireTime ;

    //
    //  MULTISZ expiration pattern and size !
    //

    DWORD       cbNewsgroups ;
    PUCHAR      Newsgroups;

	//
	//	Name of expire policy
	//

	LPWSTR		ExpirePolicy ;

} NNTP_EXPIRE_INFO, *LPNNTP_EXPIRE_INFO ;


typedef struct  _NNTP_NEWSGROUP_INFO    {

    DWORD       cbNewsgroup ;

    PUCHAR      Newsgroup ;

    DWORD       cbDescription ;

    PUCHAR      Description ;

    DWORD       cbModerator ;

    PUCHAR      Moderator ;

	BOOL		fIsModerated ;
	
    BOOL        ReadOnly ;

    DWORD       cbPrettyname ;

    PUCHAR      Prettyname ;

	FILETIME	ftCreationDate;

}   NNTP_NEWSGROUP_INFO,    *LPNNTP_NEWSGROUP_INFO ;

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

//
// Find RPC structs
//

typedef struct _NNTP_FIND_ENTRY
{
    LPWSTR      lpszName;
} NNTP_FIND_ENTRY, *LPNNTP_FIND_ENTRY;


typedef struct _NNTP_FIND_LIST
{
    DWORD       cEntries;
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    NNTP_FIND_ENTRY aFindEntry[];
} NNTP_FIND_LIST, *LPNNTP_FIND_LIST;


//
// Retention policy flags
//

#define NEWS_EXPIRE_BOTH                0x30000000
#define NEWS_EXPIRE_TIME                0x10000000
#define NEWS_EXPIRE_SIZE                0x20000000
#define NEWS_EXPIRE_OLDEST              0x00000001
#define NEWS_EXPIRE_BIGGEST             0x00000002
#define NEWS_EXPIRE_SIZE_OLDEST         (NEWS_EXPIRE_SIZE | NEWS_EXPIRE_OLDEST)
#define NEWS_EXPIRE_SIZE_BIGGEST        (NEWS_EXPIRE_SIZE | NEWS_EXPIRE_BIGGEST)
#define NEWS_EXPIRE_BOTH_OLDEST         (NEWS_EXPIRE_BOTH | NEWS_EXPIRE_OLDEST)
#define NEWS_EXPIRE_BOTH_BIGGEST        (NEWS_EXPIRE_BOTH | NEWS_EXPIRE_BIGGEST)

//
// Get Server Statistics
//

NET_API_STATUS
NET_API_FUNCTION
NntpQueryStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN DWORD  Level,
    OUT LPBYTE * Buffer
    );

//
// Clear server statistics
//

NET_API_STATUS
NET_API_FUNCTION
NntpClearStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId
    );

//
// Statistics clear flags
//

#define NNTP_STAT_CLEAR_OUTGOING         0x00000001
#define NNTP_STAT_CLEAR_INGOING          0x00000002


//
// Getting and setting server Information
//
//

NET_API_STATUS
NET_API_FUNCTION
NntpGetAdminInformation(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPNNTP_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
NntpSetAdminInformation(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_CONFIG_INFO pConfig,
    OUT LPDWORD pParmError OPTIONAL
    );


//
// Sessions
//

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateSessions(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_SESSION_INFO *Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
NntpTerminateSession(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPSTR UserName OPTIONAL,
    IN LPSTR IPAddress OPTIONAL
    );

//
// Feeds
//

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateFeeds(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_FEED_INFO *FeedInfo
    );

NET_API_STATUS
NET_API_FUNCTION
NntpGetFeedInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN DWORD FeedId,
    OUT LPNNTP_FEED_INFO *FeedInfo
    );

NET_API_STATUS
NET_API_FUNCTION
NntpSetFeedInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NntpAddFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL,
	OUT LPDWORD pdwFeedId
    );

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN DWORD FeedId
    );

NET_API_STATUS
NET_API_FUNCTION
NntpEnableFeed(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  DWORD           FeedId,
    IN  BOOL            Enable,
    IN  BOOL            Refill,
    IN  FILETIME        RefillTime 
    ) ;


NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateExpires(
    IN  LPWSTR      ServerName,
    IN	DWORD		InstanceId,
    OUT LPDWORD         EntriesRead,
    OUT LPNNTP_EXPIRE_INFO* Buffer 
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpAddExpire(
    IN  LPWSTR              ServerName,
    IN	DWORD				InstanceId,
    IN  LPNNTP_EXPIRE_INFO  ExpireInfo,
    OUT LPDWORD             ParmErr OPTIONAL,
	OUT LPDWORD				pdwExpireId
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteExpire(
    IN  LPWSTR              ServerName,
    IN	DWORD				InstanceId,
    IN  DWORD               ExpireId 
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpGetExpireInformation(
    IN  LPWSTR              ServerName,
    IN	DWORD				InstanceId,
    IN  DWORD               ExpireId,
    OUT LPNNTP_EXPIRE_INFO  *Buffer
    ) ;


NET_API_STATUS
NET_API_FUNCTION
NntpSetExpireInformation(
    IN  LPWSTR              ServerName  OPTIONAL,
    IN	DWORD				InstanceId,
    IN  LPNNTP_EXPIRE_INFO  ExpireInfo,
    OUT LPDWORD             ParmErr OPTIONAL
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpGetNewsgroup(
    IN  LPWSTR              ServerName  OPTIONAL,
    IN	DWORD				InstanceId,
    IN OUT  LPNNTP_NEWSGROUP_INFO   *NewgroupInfo
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpSetNewsgroup(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  LPNNTP_NEWSGROUP_INFO   NewgroupInfo
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpCreateNewsgroup(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  LPNNTP_NEWSGROUP_INFO   NewsgroupInfo
    ) ;

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteNewsgroup(
    IN  LPWSTR          ServerName  OPTIONAL,
    IN	DWORD			InstanceId,
    IN  LPNNTP_NEWSGROUP_INFO   NewsgroupInfo
    ) ;

//
//  Find RPCs
//
NET_API_STATUS
NET_API_FUNCTION
NntpFindNewsgroup(
    IN   LPWSTR                 ServerName,
    IN	 DWORD					InstanceId,
    IN   LPWSTR                 NewsgroupPrefix,
    IN   DWORD                  MaxResults,
    OUT  LPDWORD                pdwResultsFound,
    OUT  LPNNTP_FIND_LIST       *ppFindList
    ) ;

#define NNTPBLD_DEGREE_THOROUGH			0x00000000
#define NNTPBLD_DEGREE_STANDARD			0x00000001
#define NNTPBLD_DEGREE_MEDIUM			0x00000010

//
//	Nntpbld structs and RPCs
//

typedef struct _NNTPBLD_INFO	{

	//
	//	Verbosity of reporting
	//
	BOOL	Verbose ;

	//
	//	Specify whether to blow away all old data structures 
	//
	BOOL	DoClean ;

	//
	//	If TRUE then don't delete the history file regardless of other settings.
	//
	BOOL	NoHistoryDelete ;

	//
	//	0x00000000 for thorough ie delete all index files
	//	0x00000001 for standard ie reuse all index files
	//	0x00000101 for standard with skip corrupt group enabled
	//  0x00000010 for medium   ie validate index files
	//
	DWORD	ReuseIndexFiles ;

	//
	//	If TRUE, omit non-leaf dirs
	//
	BOOL	OmitNonleafDirs ;

	//
	//	Name of a file containing either an INN style 'Active' file or 
	//	a tool generated newsgroup list file.  Either way, we will pull
	//	newsgroups out of this file and use them to build a news tree.	
	//
	DWORD	cbGroupFile ;
	LPWSTR	szGroupFile ;

	//
	//	Name of report file
	//
	DWORD	cbReportFile ;
	LPWSTR	szReportFile ;

	//
	//	If TRUE then szGroupFile specifies an INN style Active file,
	//	otherwise it specifies a tool generated human edit newsgroup list.
	//
	BOOL IsActiveFile ;	

	//
	//	Number of rebuild threads
	//

	DWORD NumThreads;

} NNTPBLD_INFO, *LPNNTPBLD_INFO ;

//
// Nntpbld RPCs
//
//

NET_API_STATUS
NET_API_FUNCTION
NntpStartRebuild(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTPBLD_INFO pBuildInfo,
    OUT LPDWORD pParmError OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NntpGetBuildStatus(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  BOOL	fCancel,
    OUT LPDWORD pdwProgress
    );

//
// Nntp vroot PRCs
//

NET_API_STATUS
NET_API_FUNCTION
NntpGetVRootWin32Error(
    IN LPWSTR wszServer,
    IN DWORD dwInstanceId,
    IN LPWSTR wszVRootPath,
    OUT LPDWORD pdwWin32Error
    );

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntpAddDropNewsgroup(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  LPCSTR	szNewsgroup
);

NET_API_STATUS
NET_API_FUNCTION
NntpRemoveDropNewsgroup(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  LPCSTR	szNewsgroup
);
#endif

NET_API_STATUS
NET_API_FUNCTION
NntpCancelMessageID(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN  LPCSTR	szMessageID
);
		

//
// Used to free buffers returned by APIs
//

VOID
NntpFreeBuffer(
    LPVOID Buffer
    );

#ifdef __cplusplus
}
#endif

#endif _NNTPAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\propid.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	propid.h

Abstract:

	This module contains the definition of the property ID related types
	and values

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/03/98	created

--*/

#ifndef _PROPID_H_
#define _PROPID_H_

// Define a type for the property ID, we don't want to lock in to
// a specific data type
typedef DWORD PROP_ID;

// Define a bunch of values pertaining to the PROP ID type
#define MAX_PROP_ID							((PROP_ID)-1)
#define FIRST_AVAILABLE_PROP_ID				((PROP_ID)1)
#define UNDEFINED_PROP_ID					((PROP_ID)0)

// 
// Prop ID 0 is reserved for many things ...
//
#define PROP_ID_RESERVED					((PROP_ID)0)
#define PROP_ID_DELETED						((PROP_ID)0)
#define PROP_ID_NOT_FOUND					((PROP_ID)0)

//
// Define a structure for PROP ID management
//
typedef struct _PROP_ID_MANAGEMENT_ITEM
{
	GUID			idRange;	// GUID identifying the range of PROP IDs
	PROP_ID			idStartId;	// PROP ID of first ID in the managed range
	DWORD			dwLength;	// Number of contiguous PROP IDs in this range

} PROP_ID_MANAGEMENT_ITEM, *LPPROP_ID_MANAGEMENT_ITEM;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\propstr.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       propstr.h
//
//  Contents:   Property name strings for all public IMsg properties
//
//  Classes:    None
//
//  Functions:  None
//
//  History:    November 7, 1997 - Milans, Created
//
//-----------------------------------------------------------------------------

#ifndef _PROPSTR_H_
#define _PROPSTR_H_

//
// IMsg property names. The MP_ prefix stands for Message Property
//

#define MP_RECIPIENT_LIST   "Recipients"
#define MP_RECIPIENT_LIST_W L"Recipients"

#define MP_CONTENT_FILE_NAME "ContentFileName"
#define MP_CONTENT_FILE_NAME_W L"ContentFileName"

#define MP_SENDER_ADDRESS_TYPE "SenderAddressType"
#define MP_SENDER_ADDRESS_TYPE_W L"SenderAddressType"

#define MP_SENDER_ADDRESS "SenderAddress"
#define MP_SENDER_ADDRESS_W L"SenderAddress"

#define MP_DOMAIN_LIST "DomainList"
#define MP_DOMAIN_LIST_W L"DomainList"

#define MP_PICKUP_FILE_NAME "PickupFileName"
#define MP_PICKUP_FILE_NAME_W L"PickupFileName"

#define MP_AUTHENTICATED_USER_NAME "AuthenticatedUserName"
#define MP_AUTHENTICATED_USER_NAME_W L"AuthenticatedUserName"

#define MP_CONNECTION_IP_ADDRESS "ConnectionIpAddress"
#define MP_CONNECTION_IP_ADDRESS_W L"ConnectionIpAddress"

#define MP_HELO_DOMAIN "HeloDomain"
#define MP_HELO_DOMAIN_W L"HeloDomain"

#define MP_EIGHTBIT_MIME_OPTION "EightBitMime"
#define MP_EIGHTBIT_MIME_OPTION_W L"EightBitMime"

#define MP_CHUNKING_OPTION "Chunking"
#define MP_CHUNKING_OPTION_W L"Chunking"

#define MP_BINARYMIME_OPTION "BinaryMime"
#define MP_BINARYMIME_OPTION_W L"BinaryMime"

#define MP_REMOTE_AUTHENTICATION_TYPE "RemoteAuthenticationType"
#define MP_REMOTE_AUTHENTICATION_TYPE_W L"RemoteAuthenticationType"

#define MP_ERROR_CODE "IMsgErrorCode"
#define MP_ERROR_CODE_W L"IMsgErrorCode"

#define MP_DSN_ENVID_VALUE "EnvidDsnOption"
#define MP_DSN_ENVID_VALUE_W L"EnvidDsnOption"

#define MP_DSN_RET_VALUE "RetDsnValue"
#define MP_DSN_RET_VALUE_W L"RetDsnValue"

#define MP_REMOTE_SERVER_DSN_CAPABLE "RemoteServerDsnCapable"
#define MP_REMOTE_SERVER_DSN_CAPABLE_W L"RemoteServerDsnCapable"


//
// Recipient property names. The RP_ prefix stands for Recipient Property
//

#define DSN_NOTIFY_SUCCESS	0x00000001
#define DSN_NOTIFY_FAILURE	0x00000002
#define DSN_NOTIFY_DELAY	0x00000004
#define DSN_NOTIFY_NEVER	0x00000008
#define DSN_NOTIFY_INVALID	0x10000000

#define IMMPID_RP_DSN_NOTIFY_SUCCESS_W	L"DSN_Notify_Success"
#define IMMPID_RP_DSN_NOTIFY_FAILURE_W	L"DSN_Notify_Failure"
#define IMMPID_RP_DSN_NOTIFY_DELAY_W	L"DSN_Notify_Delay"
#define IMMPID_RP_DSN_NOTIFY_NEVER_W	L"DSN_Notify_Never"
#define IMMPID_RP_DSN_NOTIFY_INVALID_W	L"DSN_Notify_Invalid"

#define IMMPID_RP_ADDRESS_SMTP_W		L"SMTPAddress"
#define IMMPID_RP_ADDRESS_X400_W		L"X400Address"
#define IMMPID_RP_ADDRESS_X500_W		L"X500Address"

#define RP_ADDRESS_TYPE "AddressType"
#define RP_ADDRESS_TYPE_W L"AddressType"
#define RP_ADDRESS "Address"
#define RP_ADDRESS_W L"Address"

#define RP_ADDRESS_TYPE_SMTP "SMTP"
#define RP_ADDRESS_TYPE_SMTP_W L"SMTP"

#define RP_ADDRESS_TYPE_EX "EX"
#define RP_ADDRESS_TYPE_EX_W L"EX"

#define RP_ADDRESS_TYPE_X400 "X400"
#define RP_ADDRESS_TYPE_X400_W L"X400"

#define RP_ADDRESS_TYPE_X500 RP_ADDRESS_TYPE_EX
#define RP_ADDRESS_TYPE_X500_W RP_ADDRESS_TYPE_EX_W

#define RP_ADDRESS_TYPE_DN "DN"
#define RP_ADDRESS_TYPE_DN_W L"DN"

#define RP_ADDRESS_TYPE_LEGACY_EX_DN "LegacyExDN"
#define RP_ADDRESS_TYPE_LEGACY_EX_DN_W L"LegacyExDN"

#define RP_ERROR_CODE "RcptErrorCode"
#define RP_ERROR_CODE_W L"RcptErrorCode"

#define RP_ERROR_STRING "RcptErrorString"
#define RP_ERROR_STRING_W L"RcptErrorString"

#define RP_DSN_NOTIFY_VALUE "NotifyDsnValue"
#define RP_DSN_NOTIFY_VALUE_W L"NotifyDsnValue"

#define RP_DSN_ORCPT_VALUE "OrcptDsnValue"
#define RP_DSN_ORCPT_VALUE_W L"OrcptDsnValue"

#define IMMPID_RP_LEGACY_EX_DN_W	L"LegacyExDN"

#endif _PROPSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\rwex.h ===
#ifndef _RWEX_INC
#define _RWEX_INC

namespace rwex {
	#include "rw.h"
}

typedef rwex::CShareLock CExShareLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\qbase.h ===
//
// QBASE.h
//
//	This file defines CQElement - a base class for all types which
//	are to be used in the lockq.h and other templated queue manipulation
//	classes.
// 
// 




#ifndef	_QBASE_H_
#define	_QBASE_H_

#include	"dbgtrace.h"

//-----------------------------------------------
// Base Element Class
//
// This is the base class for Queue and stack Elements.
// The various implementations of Stacks and Queues are friends.
//	
class	CQElement	{
public : 
	CQElement	*m_pNext ;

	inline	CQElement( ) ;
	inline	CQElement( CQElement*	p ) ;
	inline	~CQElement( ) ;
} ;

CQElement::CQElement( ) : 
	m_pNext( 0 )  {
//
//	Construct a queue element - not in any list pointer must be NULL
//
}

CQElement::~CQElement( ) 	{
//
//	Destroy a queue element - next pointer must be NULL or
//	-1 (for lockq.h) so that we know the element is not 
//	on a queue at destruction time and the user has properly 
//	managed the linking and unlinking of the queue.
//
	_ASSERT( m_pNext == 0 || m_pNext == (CQElement*)(DWORD_PTR)-1 ) ;
}

CQElement::CQElement( CQElement *pIn ) : 
	m_pNext( pIn ) {
//
//	Constructor which sets the initial next pointer value !
//
}

#endif	// _CQUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\rwinst.h ===
//-----------------------------------------------------------------------------
//
//
//  File: rwinst.h
//
//  Description:  Instramented share lock implementations.  Our current 
//      sharelock implementation is non-reentrant.  This wrapper can also
//      be used to check for possible deadlocks.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/10/99 - MikeSwa Created 
//      8/6/99 - MikeSwa created phatq version
//      11/6/99 - MikeSwa updated to use CShareLockNH
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __PTRWINST_H__
#define __PTRWINST_H__

#include "rwnew.h"
#include "listmacr.h"

#define SHARE_LOCK_INST_SIG         'kcoL'
#define SHARE_LOCK_INST_SIG_FREE    '!koL'


#define THREAD_ID_BLOCK_SIG         'klBT'
#define THREAD_ID_BLOCK_SIG_FREE    '!lBT'
#define THREAD_ID_BLOCK_UNUSED      0xFFFFFFFF 

//Flag values that describe the type of tracking to do
//These can be passed to the constructor to allow different levels of 
//tracking for different instances.
enum
{
    SHARE_LOCK_INST_TRACK_CONTENTION        = 0x00000001,
    SHARE_LOCK_INST_TRACK_SHARED_THREADS    = 0x00000002,
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS = 0x00000004,
    SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS = 0x00000008,
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST    = 0x00000010,
    SHARE_LOCK_INST_TRACK_NOTHING           = 0x80000000,
};

//Define some useful flag combinations

//This combination of flags has minimal perf impact, but does
//allow easier exclusive deadlock detection 
#define SHARE_LOCK_INST_TRACK_MINIMALS ( \
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS | \
    SHARE_LOCK_INST_TRACK_SHARED_THREADS | \
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST )

//This combination of flags uses all of the tracking functionality of
//this class.
#define SHARE_LOCK_INST_TRACK_ALL (\
    SHARE_LOCK_INST_TRACK_CONTENTION | \
    SHARE_LOCK_INST_TRACK_SHARED_THREADS | \
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS | \
    SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS | \
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST )

//A user can define their own defaults before including this file
//$$TODO - scale back the defaults for debug builds
#ifndef SHARE_LOCK_INST_TRACK_DEFAULTS
#ifdef DEBUG
#define SHARE_LOCK_INST_TRACK_DEFAULTS SHARE_LOCK_INST_TRACK_ALL
#else //not DEBUG
#define SHARE_LOCK_INST_TRACK_DEFAULTS SHARE_LOCK_INST_TRACK_MINIMALS
#endif //not DEBUG
#endif //SHARE_LOCK_INST_TRACK_DEFAULTS

#ifndef SHARE_LOCK_INST_DEFAULT_MAX_THREADS
#define SHARE_LOCK_INST_DEFAULT_MAX_THREADS 200
#endif //SHARE_LOCK_INST_DEFAULT_MAX_THREADS

//---[ CThreadIdBlock ]--------------------------------------------------------
//
//
//  Description: 
//      An structure that represents a thread and the required info to
//      hash it.
//  Hungarian: 
//      tblk, ptblk
//  
//-----------------------------------------------------------------------------
class CThreadIdBlock
{
  protected:
    DWORD            m_dwSignature;
    DWORD            m_dwThreadId;
    DWORD            m_cThreadRecursionCount;
    CThreadIdBlock  *m_ptblkNext;
  public:
    CThreadIdBlock()
    {
        m_dwSignature = THREAD_ID_BLOCK_SIG;
        m_dwThreadId = THREAD_ID_BLOCK_UNUSED;
        m_cThreadRecursionCount = 0;
        m_ptblkNext = NULL;
    };
    ~CThreadIdBlock()
    {
        m_dwSignature = THREAD_ID_BLOCK_SIG_FREE;
        if (m_ptblkNext)
            delete m_ptblkNext;
        m_ptblkNext = NULL;
    };

    DWORD   cIncThreadCount(DWORD dwThreadId);
    DWORD   cDecThreadCount(DWORD dwThreadId);
    DWORD   cMatchesId(DWORD dwThreadId);
};

//---[ dwHashThreadId ]--------------------------------------------------------
//
//
//  Description: 
//      Given a thread ID (return by GetCurrentThreadId()) it returns a hashed
//      index.  This is designed to be used in conjuction with a array (of
//      size dwMax) of CThreadIdBlock's.  Each CThreadIdBlock will implement
//      linear chaining.  A hash lookup can be implemented by somehthing as
//      simple as:
//          rgtblk[dwhashThreadId(GetCurrentThreadId()), 
//                                sizeof(rgtblk)].cIncThreadCount();
//  Parameters:
//      dwThreadId      Thread Id to hash
//      dwMax           Max hash value (actual max value +1)
//  Returns:
//      Hashed thread Id
//  History:
//      8/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline DWORD dwHashThreadId(DWORD dwThreadId, DWORD dwMax)
{
    //Typically IDs are between 0x100 and 0xFFF
    //Also, the handles are multiples of 4 (ie end in 0, 4, 8, or C)
    //For these conditions, this hash will give unique results for
    //dwMax of 1000. (0xFFF-0x100)/4 < 1000
    const   DWORD   dwMinExpectedThread = 0x100;
    DWORD   dwHash = dwThreadId;

    dwHash -= dwMinExpectedThread;
    dwHash >>= 2;
    dwHash %= dwMax;
    return dwHash;
};

typedef CShareLockNH  CShareLockInstBase;
//---[ CShareLockInst ]--------------------------------------------------------
//
//
//  Description: 
//      An intstramented version of CShareLockInstBase
//  Hungarian: 
//      sli, psli
//  
//-----------------------------------------------------------------------------
class CShareLockInst : public CShareLockInstBase
{
  protected:
    //Static lock-tracking variables
    static              LIST_ENTRY  s_liLocks;
    static volatile     DWORD       s_dwLock;
    static              DWORD       s_cLockSpins;
    static              DWORD       s_dwSignature;

    static inline void AcquireStaticSpinLock();
    static inline void ReleaseStaticSpinLock();
  protected:
    DWORD               m_dwSignature;

    //Flags describing types of tracking to be performed
    DWORD               m_dwFlags;

    //List entry for list of all locks  - used by a debugger extension
    LIST_ENTRY          m_liLocks;

    //The total number of attempts to enter this lock in a shared mode
    DWORD               m_cShareAttempts;

    //The total number of attempts to enter shared that blocked
    DWORD               m_cShareAttemptsBlocked;

    //The total number ot attempts to enter this lock exclusively
    DWORD               m_cExclusiveAttempts;

    //The total number ot attempts to enter this lock exclusively that blocked
    DWORD               m_cExclusiveAttemptsBlocked;

    //Constant string descrition passed in 
    LPCSTR              m_szDescription;

    //ID of the thread that holds this lock exclusively
    DWORD               m_dwExclusiveThread;

    //Array of thread IDs that hold this lock shared
    CThreadIdBlock     *m_rgtblkSharedThreadIDs;

    //Maximum number of shared threads that can be tracked
    DWORD               m_cMaxTrackedSharedThreadIDs;

    //The current number of shared threads
    DWORD               m_cCurrentSharedThreads;

    //The most theads that have ever held this lock shared
    DWORD               m_cMaxConcurrentSharedThreads;

    //Used internally, to see if the private functions need to be called
    inline BOOL    fTrackingEnabled();
    

    BOOL    fTrackContention() 
        {return (SHARE_LOCK_INST_TRACK_CONTENTION & m_dwFlags);};

    BOOL    fTrackSharedThreads()
        {return (m_cMaxTrackedSharedThreadIDs && 
                (SHARE_LOCK_INST_TRACK_SHARED_THREADS & m_dwFlags));};

    BOOL    fTrackExclusiveThreads() 
        {return (SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS & m_dwFlags);};

    BOOL    fAssertSharedDeadlocks() 
        {return (fTrackSharedThreads() && 
                (SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS & m_dwFlags));};

    BOOL    fTrackInGlobalList()
        {return (SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST & m_dwFlags);};

    //statisics helper functions
    void LogAcquireShareLock(BOOL fTry);
    void LogReleaseShareLock();

    void PrvShareLock();
    void PrvShareUnlock();
    BOOL PrvTryShareLock();
    void PrvExclusiveLock();
    void PrvExclusiveUnlock();
    BOOL PrvTryExclusiveLock();

    void PrvAssertIsLocked();
  public:
    CShareLockInst(
        LPCSTR szDescription = NULL,
        DWORD dwFlags = SHARE_LOCK_INST_TRACK_DEFAULTS, 
        DWORD cMaxTrackedSharedThreadIDs = SHARE_LOCK_INST_DEFAULT_MAX_THREADS);

    ~CShareLockInst();

    //wrappers for sharelock functions
    inline void ShareLock();
    inline void ShareUnlock();
    inline BOOL TryShareLock();
    inline void ExclusiveLock();
    inline void ExclusiveUnlock();
    inline BOOL TryExclusiveLock();

    inline void AssertIsLocked();

};

//---[ inline ShareLock wrapper functions ]------------------------------------
//
//
//  Description: 
//      These functions are all thin wrappers for the sharelock wrapper 
//      functions.  If there is any tracking enabled for this object, then 
//      the private (non-inline) functions are called.
//
//      The idea is that you should be able to have these sharelocks in your
//      code with minimal perf-impact when logging is turned off.
//  Parameters:
//      
//  Returns:
//
//  History:
//      5/24/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::ShareLock()
{
    if (fTrackContention() || fTrackSharedThreads() || fAssertSharedDeadlocks())
        PrvShareLock();
    else
        CShareLockInstBase::ShareLock();
};


void CShareLockInst::ShareUnlock()
{
    if (fTrackSharedThreads() || fAssertSharedDeadlocks())
        PrvShareUnlock();
    else
        CShareLockInstBase::ShareUnlock();
};

BOOL CShareLockInst::TryShareLock()
{
    if (fTrackContention() || fTrackSharedThreads() || fAssertSharedDeadlocks())
        return PrvTryShareLock();
    else
        return CShareLockInstBase::TryShareLock();
};

void CShareLockInst::ExclusiveLock()
{
    if (fTrackContention() || fTrackExclusiveThreads())
        PrvExclusiveLock();
    else
        CShareLockInstBase::ExclusiveLock();
};

void CShareLockInst::ExclusiveUnlock()
{
    if (fTrackExclusiveThreads())
        PrvExclusiveUnlock();
    else
        CShareLockInstBase::ExclusiveUnlock();
};

BOOL CShareLockInst::TryExclusiveLock()
{
    if (fTrackContention() || fTrackExclusiveThreads())
        return PrvTryExclusiveLock();
    else
        return CShareLockInstBase::TryExclusiveLock();
};


//---[ AssertIsLocked ]--------------------------------------------------------
//
//
//  Description: 
//      In Debug code, will assert if this is not locked by the calling thread.
//      NOTE: This requires the following flags are specified at object
//      creation time:
//          SHARE_LOCK_INST_TRACK_SHARED_THREADS
//          SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/24/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::AssertIsLocked()
{
#ifdef DEBUG
    if ((SHARE_LOCK_INST_TRACK_SHARED_THREADS & m_dwFlags) &&
        (SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS & m_dwFlags))
    {
        PrvAssertIsLocked();
    }
#endif //DEBUG
};

#endif //__PTRWINST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\randfail.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    randfail.h

Abstract :

    This module contains macros used to instrument code for random failures

Author :

    Sam Neely

Revision History :

--*/

#if !defined(_WINDOWS_) && !defined(_WINBASE_)
#error This file must be included after other header files
#endif

#ifdef __cplusplus
extern "C" {
#endif

// If this is a debug build, expose the fTimeToFail(g_TestTrace) entry
// and a handful of utility macros

#if defined(DEBUG)
extern int __stdcall g_TestTrace(void);
extern void __stdcall g_TestTraceEnable();
extern void __stdcall g_TestTraceDisable();

#define FAILURE_MACRO0(api,err,ret) \
	(g_TestTrace() ? SetLastError(err), ret : api())

#define FAILURE_MACRO1(api,err,ret,arg1) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1))

#define FAILURE_MACRO2(api,err,ret,arg1,arg2) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2))

#define FAILURE_MACRO3(api,err,ret,arg1,arg2,arg3) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3))

#define FAILURE_MACRO4(api,err,ret,arg1,arg2,arg3,arg4) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4))

#define FAILURE_MACRO5(api,err,ret,arg1,arg2,arg3,arg4,arg5) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5))

#define FAILURE_MACRO6(api,err,ret,arg1,arg2,arg3,arg4,arg5,arg6) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6))

#define FAILURE_MACRO7(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7))

#define FAILURE_MACRO8(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7,arg8) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7,arg8))

#define FAILURE_MACRO9(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7,arg8,arg9) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7,arg8,arg9))

#define FAILURE_MACRO10(api,err,ret,arg1,arg2,arg3,arg4,arg5, \
		arg6,arg7,arg8,arg9,arg10) \
	(g_TestTrace() ? SetLastError(err), ret : api(arg1,arg2,arg3,arg4,arg5,\
		arg6,arg7,arg8,arg9,arg10))

#define RandFailDisable() g_TestTraceDisable()
#define RandFailEnable() g_TestTraceEnable()

#else			// !DEBUG
#define RandFailDisable() (void)0
#define RandFailEnable() (void)0

#endif


#if defined(DEBUG) && !defined(NOFAIL_WIN32API)

#define CreateDirectoryA(arg1,arg2) \
	FAILURE_MACRO2(CreateDirectoryA, ERROR_ARENA_TRASHED, 0, arg1, arg2)
#define CreateDirectoryW(arg1,arg2) \
	FAILURE_MACRO2(CreateDirectoryW, ERROR_ARENA_TRASHED, 0, arg1, arg2)

#define CreateDirectoryExA(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateDirectoryExA, ERROR_ARENA_TRASHED, 0, \
		       arg1,arg2,arg3)
#define CreateDirectoryExW(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateDirectoryExW, ERROR_ARENA_TRASHED, 0, \
		       arg1,arg2,arg3)

#define CreateEventA(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateEventA, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3,arg4)
#define CreateEventW(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateEventW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3,arg4)

#define CreateFileA(arg1,arg2,arg3,arg4,arg5,arg6,arg7) \
	FAILURE_MACRO7(CreateFileA, ERROR_ARENA_TRASHED, INVALID_HANDLE_VALUE,\
		       arg1,arg2,arg3,arg4,arg5,arg6,arg7)
#define CreateFileW(arg1,arg2,arg3,arg4,arg5,arg6,arg7) \
	FAILURE_MACRO7(CreateFileW, ERROR_ARENA_TRASHED, INVALID_HANDLE_VALUE,\
		       arg1,arg2,arg3,arg4,arg5,arg6,arg7)

#define CreateFileMappingA(arg1,arg2,arg3,arg4,arg5,arg6) \
	FAILURE_MACRO6(CreateFileMappingA, ERROR_ARENA_TRASHED, NULL,\
		       arg1,arg2,arg3,arg4,arg5,arg6)
#define CreateFileMappingW(arg1,arg2,arg3,arg4,arg5,arg6) \
	FAILURE_MACRO6(CreateFileMappingW, ERROR_ARENA_TRASHED, NULL,\
		       arg1,arg2,arg3,arg4,arg5,arg6)

#define CreateIoCompletionPort(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateIoCompletionPort, ERROR_ARENA_TRASHED, NULL,\
		      arg1,arg2,arg3,arg4)

#define CreateMutexA(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateMutexA, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)
#define CreateMutexW(arg1,arg2,arg3) \
	FAILURE_MACRO3(CreateMutexW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define CreateProcessA(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) \
	FAILURE_MACRO10(CreateProcessA, ERROR_ARENA_TRASHED, 0, \
		      arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)
#define CreateProcessW(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) \
	FAILURE_MACRO10(CreateProcessW, ERROR_ARENA_TRASHED, 0, \
			arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)

#define CreateSemaphoreA(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateSemaphoreA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3,arg4)
#define CreateSemaphoreW(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(CreateSemaphoreW, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3,arg4)

#define CreateThread(arg1,arg2,arg3,arg4,arg5,arg6) \
	FAILURE_MACRO6(CreateThread, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3,arg4,arg5,arg6)

#define GetQueuedCompletionStatus(arg1,arg2,arg3,arg4,arg5) \
	FAILURE_MACRO5(GetQueuedCompletionStatus, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3,arg4,arg5)

#define OpenEventA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenEventA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3)
#define OpenEventW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenEventW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenFileMappingA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenFileMappingA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3)
#define OpenFileMappingW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenFileMappingW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenMutexA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenMutexA, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)
#define OpenMutexW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenMutexW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenProcess(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenProcess, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define OpenSemaphoreA(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenSemaphoreA, ERROR_ARENA_TRASHED, NULL, \
		      arg1,arg2,arg3)
#define OpenSemaphoreW(arg1,arg2,arg3) \
	FAILURE_MACRO3(OpenSemaphoreW, ERROR_ARENA_TRASHED, NULL, \
		       arg1,arg2,arg3)

#define PostQueuedCompletionStatus(arg1,arg2,arg3,arg4) \
	FAILURE_MACRO4(PostQueuedCompletionStatus, ERROR_ARENA_TRASHED, 0, \
		      arg1,arg2,arg3,arg4)

#define ReadFile(arg1,arg2,arg3,arg4,arg5) \
	FAILURE_MACRO5(ReadFile, ERROR_ARENA_TRASHED, 0, \
		      arg1,arg2,arg3,arg4,arg5)

#define WriteFile(arg1,arg2,arg3,arg4,arg5) \
	FAILURE_MACRO5(WriteFile, ERROR_ARENA_TRASHED, 0, \
		       arg1,arg2,arg3,arg4,arg5)



#endif

#if defined(DEBUG) && !defined(NOFAIL_RANDOM)
#define fTimeToFail() g_TestTrace()
#else
#define fTimeToFail() (0)
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\rwexport.h ===
/*++

	rwexport.h

	This file defines a reader/writer lock implemented in rwnh.dll.
	We define the locks so that none of their internal workings is exposed.

--*/


#ifndef	_RWEXPORT_H
#define	_RWEXPORT_H

#ifdef	_RW_IMPLEMENTATION_
#define	_RW_INTERFACE_ __declspec( dllexport ) 
#else
#define	_RW_INTERFACE_	__declspec( dllimport ) 
#endif


class	_RW_INTERFACE_	CShareLockExport	{
private : 
	DWORD	m_dwSignature ;

	enum	constants	{
		//
		//	Signature in our objects !
		//
		SIGNATURE = (DWORD)'opxE'
	} ;

	//
	//	Reserved space for the implementation !
	//
	DWORD	m_dwReserved[16] ;

public : 

	CShareLockExport() ;
	~CShareLockExport() ;

	//
	//	Grab the lock Shared - other threads may pass through ShareLock() as well
	//
	void	ShareLock() ;

	//
	//	Releases the lock - if we are the last reader to leave writers may
	//	start to enter the lock !
	//
	void	ShareUnlock() ;

	//
	//	Grab the lock Exclusively - no other readers or writers may enter !!
	//
	void	ExclusiveLock() ;

	//
	//	Release the Exclusive Locks - if there are readers waiting they 
	//	will enter before other waiting writers !
	//
	void	ExclusiveUnlock() ;

	//
	//	Convert an ExclusiveLock to a Shared - this cannot fail !
	//
	void	ExclusiveToShared() ;

	//
	//	Convert a Shared Lock to an Exclusive one - this can fail - returns
	//	TRUE if successfull !
	//
	BOOL	SharedToExclusive() ;

	BOOL	TryShareLock() ;
	BOOL	TryExclusiveLock() ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\rwintrnl.h ===
/*++

	rwintrnl.h

	Reader/Writer locks internal header file

	This file defines several objects used to implement
	reader/writer locks, however these objects should
	not be directly used by any client of rw.h



--*/


#ifndef	_RWINTRNL_H_
#define	_RWINTRNL_H_



class	CHandleInfo	{
/*++

	This class keeps track of all the handles we've allocated for
	use by various threads.  We can't use Thread Local Storage
	directly because we can be dynamically unloaded, in which case
	we need to free all of our HANDLES !

--*/
private :
	//
	//	Signature for our
	//
	DWORD	m_dwSignature ;
	class	CHandleInfo*	m_pNext ;
	class	CHandleInfo*	m_pPrev ;

	CHandleInfo( CHandleInfo& ) ;
	CHandleInfo&	operator=( CHandleInfo& ) ;

	//
	//	Global lock to protect free and allocated lists !
	//
	static	CRITICAL_SECTION	s_InUseList ;
	//
	//	Allocated CHandleInfo objects !
	//
	static	CHandleInfo			s_Head ;
	//
	//	Free CHandleInfo objects
	//
	static	CHandleInfo			s_FreeHead ;
	//
	//	Number of Free CHandleInfo objects in the s_FreeHead list
	//
	static	DWORD	s_cFreeList ;

	enum	constants	{
		//
		//	Maximum number of CHandleInfo objects we'll hold onto !
		//
		MAX_FREE = 64,		
		//
		//	Initial number of CHandleInfo objects we'll allocate !
		//
		INITIAL_FREE = 32,
		//
		//	Signature in our objects !
		//
		SIGNATURE = (DWORD)'hnwR'
	} ;

	//
	//	Memory Allocation is done the hard way !
	//
	void*	operator new( size_t size ) ;
	void	operator delete( void *pv ) ;

	//
	//	List Manipulation routines !
	//
	void	
	InsertAtHead( CHandleInfo*	pHead	)	;

	//
	//	Remove the element from the list - returns this pointer !
	//
	CHandleInfo*
	RemoveList( )  ;

public :

	//
	//	Constructor and Destructor !
	//
	CHandleInfo() ;
	~CHandleInfo() ;

	//
	//	This is public for all to use !
	//
	HANDLE	m_hSemaphore ;

    //
    //  This is an auto-reset event handle available for anybody
    //  and retrievable through GetPerThreadEvent() ;
    //
    HANDLE  m_hEvent ;

	//
	//	Initialize the class
	//
	static	BOOL
	InitClass() ;
	
	//
	//	Terminate the class - release all outstanding handles !
	//
	static	void
	TermClass() ;

	//
	//	Get a CHandleInfo object !
	//
	static	CHandleInfo*
	AllocHandleInfo() ;

	//
	//	release a CHandleInfo object !
	//
	static	void
	ReleaseHandleInfo( CHandleInfo* ) ;

	//
	//	Check that the object is valid !
	//
	BOOL
	IsValid()	{
		return	m_dwSignature == SIGNATURE &&
				m_pNext != 0 &&
				m_pPrev != 0 ;
	}

} ;


//
//	This class serves two purposes : to provide for a linkable object
//	on which we can queue threads blocked upon semaphore handles, and
//	a mechanism to get and set semaphore handles for reader/writer locks etc...
//
class	CWaitingThread : public	CQElement	{
private :

	enum	{
		POOL_HANDLES = 64,
	} ;

	//
	//	Semaphore that we can use to block the thread !
	//
	CHandleInfo	*m_pInfo ;

	//
	//	Var to hold error that may have occurred manipulating the lock !
	//
	DWORD	m_dwError ;

	//
	//	Thread Local Storage offset for holding the handles !
	//
	static	DWORD	g_dwThreadHandle ;

	//
	//	Array of Handles to Semaphores which we stash away in case
	//	we have to release the handle being used by a thread at some point !
	//
	static	HANDLE	g_rghHandlePool[ POOL_HANDLES ] ;

	//
	//	No copying of these objects allowed !!!
	//
	CWaitingThread( CWaitingThread& ) ;
	CWaitingThread&	operator=( CWaitingThread& ) ;

public :

#ifdef	DEBUG

	//
	//	Thread Id - handy for debuggiing
	//
	DWORD	m_dwThreadId ;
#endif

	CWaitingThread() ;


	//
	//	Functions to be called from the DllEntryProc function !
	//
	static	BOOL	
	InitClass() ;

	static	BOOL	
	TermClass() ;

	//
	//	Thread Entry/Exit routines which can allocate semaphore handles for us !
	//
	static	void	
	ThreadEnter() ;

	static	void	
	ThreadExit() ;

    //
    //  Function which gives us our Event Handle
    //
    inline  HANDLE
    GetThreadEvent()    const ;

	//
	//	Function which gives us our thread handle !
	//
	inline	HANDLE	
	GetThreadHandle()	const ;

	//
	//	Function which will release a HANDLE to the Pool of available
	//	semaphore handles !
	//
	inline	void
	PoolHandle(
				HANDLE	h
				)	const ;

	//
	//	Function which will remove a handle from our thread's TLS !
	//	The argument must originally be from the calling thread's TLS
	//
	inline	void
	ClearHandle(	
				HANDLE	h
				) ;
	

	//
	//	Function which blocks the calling thread !!
	//
	inline	BOOL	
	Wait() const ;

	//
	//	Function which can release a thread !!
	//
	inline	BOOL	
	Release() const	;

	//
	//	This function is used in debug builds to check the state of our semaphore handles !
	//
	static	inline
	BOOL	ValidateHandle(
				HANDLE	h
				) ;

} ;

typedef	TLockQueue< CWaitingThread >	TThreadQueue ;	

class	CSingleReleaseQueue {
private :
	//
	//	Queue of threads waiting to own the lock !
	//
	TThreadQueue	m_Waiting ;

public :

#ifdef	DEBUG
	DWORD			m_ThreadIdNext ;
#endif

	CSingleReleaseQueue(	
				BOOL	IsSignalled = TRUE
				) ;

	//
	//	Release a single waiting thread !
	//
	void	Release( ) ;

	//
	//	Wait for the queue to become signalled !
	//
	void	WaitForIt(
				CWaitingThread&	myself
				) ;

	//
	//	Wait for the queue to become signalled
	//
	void	WaitForIt( ) ;

} ;

//
//	This class is similar to a semaphore -
//	Threads block indefinately on WaitForIt() and another
//	thread may release as many threads as required by calling
//	Release().
//	
class	CEventQueue	{
private :

	//
	//	Number of threads that should be allowed to pass
	//	through the event !!!
	//
	long			m_ReleaseCount ;

	//
	//	Queue of threads blocked on this event !
	//
	TThreadQueue	m_WaitingThreads ;

	//
	//	Any thread may call this to release threads from the queue
	//
	BOOL	ResumeThreads(	
					CWaitingThread*
					) ;

public :

	//
	//	Create an event queue object
	//
	CEventQueue(	
				long	cInitial = 0
				) ;

	~CEventQueue() ;

	void	Release(	
				long	NumberToRelease
				) ;

	void	WaitForIt(
				CWaitingThread&	myself
				) ;

	void	WaitForIt() ;

	void	Reset() ;
} ;




//
//	Function which gives us our thread handle !
//
inline	HANDLE	
CWaitingThread::GetThreadHandle()	const	{

	_ASSERT( ValidateHandle( m_pInfo->m_hSemaphore ) ) ;

	return	m_pInfo->m_hSemaphore ;	
}

//
//	Function which takes a handle (must not be ours)
//	and places it into a pool of handles available for other threads !
//
inline	void
CWaitingThread::PoolHandle(	HANDLE	h )	const	{

	_ASSERT( h != m_pInfo->m_hSemaphore && h != 0 ) ;
	_ASSERT( ValidateHandle( h ) ) ;

	for( int i=0;
			i < sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] ) &&
			h != 0;
			i++ ) {
		h = (HANDLE)InterlockedExchangePointer( (PVOID*)&g_rghHandlePool[i], h ) ;
	}

	if( h != 0 ) {
		_VERIFY( CloseHandle( h ) ) ;
	}
}

//
//	Release our Handle from TLS, somebody else is going to use it !
//
inline	void
CWaitingThread::ClearHandle(	HANDLE	h )		{

	_ASSERT( h != 0 && h == m_pInfo->m_hSemaphore ) ;

	m_pInfo->m_hSemaphore = 0 ;
	//TlsSetValue( g_dwThreadHandle, (LPVOID) 0 ) ;

}



//
//	Block on the handle held within our object !
//
inline	BOOL	
CWaitingThread::Wait()	const	{	

	_ASSERT( m_pInfo->m_hSemaphore != 0 ) ;
	
	return	WAIT_OBJECT_0 == WaitForSingleObject( m_pInfo->m_hSemaphore, INFINITE ) ;	
}

//
//	Release a thread which is blocked on the semaphore within !!
//
inline	BOOL	
CWaitingThread::Release()	const	{	

	_ASSERT( m_pInfo->m_hSemaphore != 0 ) ;
	_ASSERT( ValidateHandle( m_pInfo->m_hSemaphore ) ) ;

	return	ReleaseSemaphore( m_pInfo->m_hSemaphore, 1, NULL ) ;	
}

//
//
//
inline	BOOL
CWaitingThread::ValidateHandle( HANDLE	h )	{

	DWORD	dw = WaitForSingleObject( h, 0 ) ;
	_ASSERT( dw == WAIT_TIMEOUT ) ;

	return	dw == WAIT_TIMEOUT ;
}

inline  HANDLE
CWaitingThread::GetThreadEvent() const   {
   return   m_pInfo->m_hEvent ;
}














#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\rw.h ===
/*++

	rw.h

	This file defines some locks with the following performance characteristics : 

	* A constant number of handles is used per lock instance 
	* The lock entry/exit protocols use Interlocked operations and do not 
		cause context switches in themselves.


--*/

#ifndef	_CRW_H
#define	_CRW_H
						
#include	<limits.h>

//
// This class contains the meat - does actual locking etc...
//
class	CShareLock {
/*++

Class Description : 

	This class implements a reader writer lock.
	
	Multiple threads can successfully enter the lock by calling
	ShareLock().  Once any thread has entered the lock through
	ShareLock(), all threads calling ExclusiveLock() are blocked 
	untill ShareUnlock() is called for each successfull ShareLock().

	This lock is fair - If multiple threads have passed through
	ShareLock(), and a thread calls ExclusiveLock(), all threads
	that arrive after the call to ExclusiveLock() will block untill
	the ExclusiveLock() thread has acquired and released the lock.
	This property is symetrical with ShareLock() and ExclusiveLock().


--*/
private : 

	//
	// Number of Readers who have passed through the lock OR 
	// the number of readers waiting for the lock (will be negative).
	// A value of 0 means nobody in the lock
	//
	volatile	long	cReadLock ;			

	//
	// The number of readers remainin in the lock if 
	// there is a writer waiting.  This can become temporarily negative
	//
	volatile	long	cOutRdrs ;			

	//
	// Critical section to allow only one writer into the lock at a time
	//
	CRITICAL_SECTION	critWriters ; 	

	//
	// Semaphore for waiting writers to block on (Only 1 ever, others will 
	// be queued on critWriters)
	//
	HANDLE	hWaitingWriters ;	

	//
	// Semaphore for waiting readers to block on 
	//
	HANDLE	hWaitingReaders ;	

	//
	//	You may not copy these objects - so this lock is private !
	//
	CShareLock( CShareLock& ) ;

	//
	//	You may not copy through assignment - so this operator is private !
	//
	CShareLock&	operator=( CShareLock& ) ;

public : 

	//
	//	Construct and Destroy a CShareLock !
	//
	CShareLock( ) ;
	~CShareLock( ) ;

	//
	//	Check that the lock is correctly initialized - call only
	//	after construction !
	//
	BOOL
	IsValid() ;

	//
	//	Grab the lock for shared mode.
	//	each call to ShareLock() must be paired with exactly 1 call
	//	to ShareUnlock().  A thread that successfully calls ShareLock()
	//	can only call ShareUnlock(), otherwise a deadlock can occur.
	//	( the sequence ShareLock(); ShareLock(); ShareUnlock(); ShareUnlock();
	//	can also deadlock)
	//
	void	
	ShareLock( ) ;
	
	//
	//	Release the lock from shared mode !	
	//
	void	
	ShareUnlock( ) ;

	//
	//	Grab the lock for Exclusive mode.
	//	each call to ExclusiveLock() must be paired with exactly 1 call
	//	to ExclusiveUnlock().  A thread that successfully calls ExclusiveLock()
	//	can only call ExclusiveUnlock(), otherwise a deadlock can occur.
	//	( the sequence ExclusiveLock(); ExclusiveLock(); ExclusiveUnlock(); ExclusiveUnlock();
	//	can also deadlock)
	//
	void	
	ExclusiveLock( ) ;

	//
	//	Release the lock from Exclusive mode !
	//
	void	
	ExclusiveUnlock( ) ;

	//
	//	Given that we've already acquired the lock Exclusively, convert to 
	//	Shared.  This cannot fail.  ShareUnlock() must be called after 
	//	we have done this.
	//
	void
	ExclusiveToShared() ;

	//
	//	Given that we've acquired the lock in shared mode try to get 
	//	it exclusively.
	//	This can fail for two reasons : 
	//		Another thread is trying to get the lock Exclusively
	//		A bunch of other threads are also in the lock in shared mode.
	//	
	//	The function will return FALSE if it fails, in which case the 
	//	Shared lock is still held !
	//
	BOOL
	SharedToExclusive() ;

	//
	//	Try to acquire the lock in shared mode.
	//	This will only fail if an ExclusiveLock is held or being 
	//	waited for.
	//	TRUE is returned if we get the lock Shared, FALSE otherwise !
	//
	BOOL
	TryShareLock() ;

	//	
	//	Try to acquire the lock in Exclusive mode.
	//	This will fail if another thread is in the ExclusiveLock()
	//	or ShareLock's are held.
	//	TRUE is returned if we get the Exclusive Lock, FALSE otherwise !
	//
	BOOL
	TryExclusiveLock() ;


	//
	//	PartialLocks - 
	//
	//	Partial Locks are similar to Exclusive Locks - only one thread
	//	can successfully call PartialLock(), any other threads calling
	//	PartialLock() or ExclusiveLock() will block.
	//	HOWEVER - while a PartialLock() is held, Readers (threads calling
	//	ShareLock()) may enter the lock.
	//
	void	PartialLock() ;

	//
	//	Release the PartialLock - Other Exclusive() or Partial lock acquirers
	//	may now enter.
	//
	void	PartialUnlock() ;

	//
	//	Convert a Partial Lock to an Exclusive Lock.  This function is 
	//	guaranteed to succeed, HOWEVER a lock can only be converted with 
	//	this function once, i.e. a thread doing
	//		PartialLock() ;
	//		FirstPartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		FirstPartialToExclusive() ;
	//	will have problems - the second call to FirstPartialToExclusive()
	//	may mess up the lock state and cause the lock to fail horribly.
	//	If a user wishes to convert as above they must have a call sequence like : 
	//
	//		PartialLock() ;
	//		FirstPartialToExclusive() or PartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		PartialToExclusive() ;
	//
	//	If you change lock states more than once - you take your chances !
	//
	void	FirstPartialToExclusive() ;

	//
	//	Returns TRUE if we can get the lock Exclusively, otherwise
	//	we return FALSE with the lock remaining in the Partially held state.
	//
	//	NOTE : This function will fail in CShareLockNH, but will always
	//	succeed for CShareLock() locks !
	//
	BOOL	PartialToExclusive() ;

	//
	//	We can always go from an ExclusiveLock() to a PartialLock() state.
	//
	void	ExclusiveToPartial() ;

	//
	//	We can always go from a PartialLock() state to a SharedLock() state
	//
	void	PartialToShared() ;

	//
	//	Returns TRUE if we can get the lock Partially !
	//	If it returns FALSE we remain with the lock held Shared()
	//
	BOOL	SharedToPartial() ;

	//
	//	Returns TRUE only if no other threads are trying to get the lock
	//	ExclusiveLy or Partially !
	//
	BOOL	TryPartialLock() ;
	
} ;



class	CSymLock	{
/*++

Class Description : 

	This class implements a symmetric lock, where multiple threads can simultaneously 
	acquire the lock if they are all of the same group.

	For instance, multiple threads can call Group1Lock() and all enter the lock.
	Any thread successfully acquiring the lock through Group1Lock() blocks all threads
	trying to acquire the lock through Group2Lock(), and vice versa.	

--*/
private : 

	//
	//	Main lock point where all acquiring threads determine who gets the lock !
	//
	volatile	long	m_lock ;

	//
	//	Two variables for the lock exit procotol - used to determine the last thread
	//	to leave the lock !
	//
	volatile	long	m_Departures ;
	volatile	long	m_left ;

	//
	//	Handles for blocking threads !
	//
	HANDLE	m_hSema4Group1 ;
	HANDLE	m_hSema4Group2 ;

	//
	//	Utility function - implements lock exit protocol when there
	//	is no contention for the lock !
	//
	BOOL
	InterlockedDecWordAndMask(	volatile	long*	plong,	
								long	mask,	
								long	decrement 
								) ;

	//
	//	Utility functions - implement lock exit protocol for case where
	//	InterlockedDecWordAndMask determines that there is contention for the lock !
	//

	//
	//	How Group1 Leaves the lock under contention
	//	
	BOOL
	Group1Departures(	long	bump	) ;

	//
	//	How Group2 Leaves the lock under contention 
	//
	BOOL
	Group2Departures(	long	bump	) ;

	//
	//	You may not copy these objects - so the copy constructor is private !
	//
	CSymLock( CSymLock& ) ;

	//
	//	You may not copy through assignment - so this operator is private !
	//
	CSymLock&	operator=( CSymLock& ) ;

public : 

	//
	//	Construct and Destruct the asymetric lock !
	//
	CSymLock() ;
	~CSymLock() ;

	//
	//	Check that the lock is correctly initialized - call only
	//	after construction !
	//
	BOOL
	IsValid() ;

	//
	//	Grab the lock for a group1 thread.
	//	This function may not be called again on the same
	//	thread until Group1Unlock() is called.
	//	Group1Unlock() must be called exactly once for each
	//	Group1Lock() !
	//
	void
	Group1Lock() ;

	//
	//	Release the lock for a group1 thread.
	//
	void
	Group1Unlock() ;

	//
	//	Grab the lock for a group2 thread.
	//	This function may not be called again on the same
	//	thread until Group2Unlock() is called.
	//	Group2Unlock() must be called exactly once for each
	//	Group2Lock() !
	//
	void
	Group2Lock() ;

	//
	//	Release the lock for a Group2 thread !
	//
	void
	Group2Unlock() ;

} ;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\smtpguid.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: smtpguid.h
//
// Contents: Event related GUIDS published from SMTPSVC
//
// Instructions: Include this file to declare the various
//               GUIDS/strings as external global variables.
//               To actually define these global variables,
//               #define SMTPINITGUID and #include <initguid.h> before this
//               header file.
//
// History:
// Jeffrey C Stamerjohn 1998/07/14 15:22:29: Created.
//
//-------------------------------------------------------------
#ifndef __SMTPGUID_H__
#define __SMTPGUID_H__

#ifdef SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    CONST WCHAR Name##[] = L##Value

#else //SMTPINITGUID
#define DECLARE_EVENTGUID_STRING( Name, Value ) \
    extern CONST WCHAR Name##[]

#endif //SMTPINITGUID

// SMTP SourceType GUID
// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSourceType, "{fb65c4dc-e468-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTP_SOURCE_TYPE, 0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
** SMTP Source GUID
*/
// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szGuidSmtpSvcSource, "{1b3c0666-e470-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(GUID_SMTPSVC_SOURCE, 0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

/*
**  Protocol Events
*/
// SMTP OnInboundCommand
// {F6628C8D-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnInboundCommand, "{F6628C8D-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_INBOUND_COMMAND, 0xf6628c8d, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnServerResponse
// {F6628C8E-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnServerResponse, "{F6628C8E-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SERVER_RESPONSE, 0xf6628c8e, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionStart
// {F6628C8F-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionStart, "{F6628C8F-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_START, 0xf6628c8f, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnMessageStart
// {F6628C90-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnMessageStart, "{F6628C90-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_MESSAGE_START, 0xf6628c90, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnPerRecipient
// {F6628C91-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPerRecipient, "{F6628C91-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_PER_RECIPIENT, 0xf6628c91, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// Smtp OnBeforeData
// {F6628C92-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnBeforeData, "{F6628C92-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_BEFORE_DATA, 0xf6628c92, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

// SMTP OnSessionEnd
// {F6628C93-0D5E-11d2-AA68-00C04FA35B82}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnSessionEnd, "{F6628C93-0D5E-11d2-AA68-00C04FA35B82}");
DEFINE_GUID(CATID_SMTP_ON_SESSION_END, 0xf6628c93, 0xd5e, 0x11d2, 0xaa, 0x68, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);


/*
** Transport Events
*/

// SMTP Store Events
// {59175850-e533-11d1-aa67-00c04fa345f6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpStoreDriver, "{59175850-e533-11d1-aa67-00c04fa345f6}");
DEFINE_GUID(CATID_SMTP_STORE_DRIVER, 0x59175850, 0xe533, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// SMTP OnTransportSubmission
// {FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportSubmission, "{FF3CAA23-00B9-11d2-9DFB-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_SUBMISSION, 0xff3caa23, 0xb9, 0x11d2, 0x9d, 0xfb, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP onPrecategorize
// {A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPrecategorize, "{A3ACFB0D-83FF-11d2-9E14-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_PRECATEGORIZE, 0xa3acfb0d, 0x83ff, 0x11d2, 0x9e, 0x14, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP Categorizer events
// {960252A3-0A3A-11d2-9E00-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnCategorize, "{960252A3-0A3A-11d2-9E00-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_CATEGORIZE, 0x960252a3, 0xa3a, 0x11d2, 0x9e, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP onPostcategorize
// {76719654-05A6-11d2-9DFD-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnPostcategorize, "{76719654-05A6-11d2-9dfd-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_POSTCATEGORIZE,
0x76719654, 0x5a6, 0x11d2, 0x9d, 0xfd, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);


// SMTP OnTransportRouter
// {283430C9-1850-11d2-9E03-00C04FA322BA}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpOnTransportRouter, "{283430C9-1850-11d2-9E03-00C04FA322BA}");
DEFINE_GUID(CATID_SMTP_TRANSPORT_ROUTER, 0x283430c9, 0x1850, 0x11d2, 0x9e, 0x3, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

// SMTP MsgTrackLog
// {c6df52aa-7db0-11d2-94f4-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMsgTrackLog, "{c6df52aa-7db0-11d2-94f4-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MSGTRACKLOG, 0xc6df52aa, 0x7db0, 0x11d2, 0x94, 0xf4, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP DnsResolver
// {bd0b4366-8e03-11d2-94f6-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpDnsResolver, "{bd0b4366-8e03-11d2-94f6-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_DNSRESOLVERRECORDSINK, 0xbd0b4366, 0x8e03, 0x11d2, 0x94, 0xf6, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP MaxMsgSize
// {ebf159de-a67e-11d2-94f7-00c04f79f1d6}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpMaxMsgSize, "{ebf159de-a67e-11d2-94f7-00c04f79f1d6}");
DEFINE_GUID(CATID_SMTP_MAXMSGSIZE, 0xebf159de, 0xa67e, 0x11d2, 0x94, 0xf7, 0x0, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);

// SMTP Log
// {93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpLog, "{93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97}");
DEFINE_GUID(CATID_SMTP_LOG, 0x93d0a538, 0x2c1e, 0x4b68, 0xa7, 0xc9, 0xd7, 0x3a, 0x8a, 0xa6, 0xee, 0x97);

// SMTP GET_AUX_DOMAIN_INFO_FLAGS
// {84ff368a-fab3-43d7-bcdf-692c5b46e6b1}
DECLARE_EVENTGUID_STRING( g_szcatidSmtpGetAuxDomainInfoFlags, "{84ff368a-fab3-43d7-bcdf-692c5b46e6b1}");
DEFINE_GUID(CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS, 0x84ff368a, 0xfab3, 0x43d7, 0xbc, 0xdf, 0x69, 0x2c, 0x5b, 0x46, 0xe6, 0xb1);

//
// CLSID of the CoCreateable categorizer
//
// {B23C35B7-9219-11d2-9E17-00C04FA322BA}"
DEFINE_GUID(CLSID_SmtpCat,
            0xb23c35b7, 0x9219, 0x11d2, 0x9e, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

#define SZ_PROGID_SMTPCAT   "Smtp.Cat"


#endif //__SMTPGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\rwnew.h ===
/*++
	
	rwnew.h

	This file defines several variations of Reader/Writer locks
	with different properties regarding handles used, and other 
	implementation details.

	Also defined are some variations of CRITICAL_SECTIONS which use
	fewer or no handles.

--*/



#ifndef	_RWNEW_H
#define	_RWNEW_H

#ifdef	_RW_IMPLEMENTATION_
#define	_RW_INTERFACE_ __declspec( dllexport ) 
#else
#define	_RW_INTERFACE_	__declspec( dllimport ) 
#endif

#pragma	warning( disable:4251 )
						
#include	<limits.h>
#include	"lockq.h"
#include	"rwintrnl.h"


class	_RW_INTERFACE_	CCritSection	{
private :

	//
	//	Handle of thread owning the lock !
	//
	HANDLE		m_hOwner ;

	//
	//	Count of Recursive Calls 
	//
	long	m_RecursionCount ;	

	//
	//	Count used to see who gets the lock next !
	//
	long	m_lock ;

	//
	//	Queue of waiting threads 
	//
	CSingleReleaseQueue		m_queue ;

	//
	//	Copying of these objects is not allowed !!!!
	//
	CCritSection( CCritSection& ) ;
	CCritSection&	operator=( CCritSection& ) ;

public : 

#ifdef	DEBUG
	DWORD	m_dwThreadOwner ;
#endif	

	//
	//	Construct a critical section object
	//
	CCritSection( ) :	
		m_queue( FALSE ),
		m_hOwner( INVALID_HANDLE_VALUE ), 
		m_RecursionCount( 0 ), 
		m_lock( -1 ) {
	}

	//
	//	Acquire the critical section
	//
	void	
	Enter(	
			CWaitingThread&	myself 
			) ;

	//
	//	Another version which acquires the critical section - 
	//	creates its own CWaitingThread object !
	//
	void	
	Enter() ;

	//
	//	REturns TRUE if the lock is available right now !
	//
	BOOL
	TryEnter(
			CWaitingThread&	myself 
			) ;

	//
	//	Returns TRUE if we can get the lock right now !
	//
	BOOL
	TryEnter()	{
		CWaitingThread	myself ;
		return	TryEnter( myself ) ;
	}

	//
	//	Release the critical section !
	//
	void
	Leave() ;

		
} ;


//
//	This version of critical section is more like an event - doesn't
//	care who releases locks - and doesn't handle recursive grabs !
//
class	_RW_INTERFACE_	CSimpleCritSection	{
private :

	//
	//	Count used to see who gets the lock next !
	//
	long	m_lock ;

	//
	//	Queue of waiting threads 
	//
	CSingleReleaseQueue		m_queue ;

	//
	//	Copying of these objects is not allowed !!!!
	//
	CSimpleCritSection( CCritSection& ) ;
	CSimpleCritSection&	operator=( CCritSection& ) ;

public : 

#ifdef	DEBUG
	DWORD	m_dwThreadOwner ;
#endif	

	//
	//	Construct a critical section object
	//
	CSimpleCritSection( ) :	
		m_queue( FALSE ),
#ifdef	DEBUG
		m_dwThreadOwner( 0 ),
#endif
		m_lock( -1 ) {
	}

	//
	//	Acquire the critical section
	//
	void	
	Enter(	
			CWaitingThread&	myself 
			) ;

	//
	//	Another version which acquires the critical section - 
	//	creates its own CWaitingThread object !
	//
	void	
	Enter() ;

	//
	//	REturns TRUE if the lock is available right now !
	//
	BOOL
	TryEnter(
			CWaitingThread&	myself 
			) ;

	//
	//	Returns TRUE if we can get the lock right now !
	//
	BOOL
	TryEnter()	{
		CWaitingThread	myself ;
		return	TryEnter( myself ) ;
	}

	//
	//	Release the critical section !
	//
	void
	Leave() ;
	
} ;

//
//	Another class which tries to create Reader/Write locks with
//	no handles !!
//

class	_RW_INTERFACE_	CShareLockNH	{
private : 

	//	
	//	Lock grabbed by writers to have exclusive access
	//
	CSimpleCritSection	m_lock ;

	//
	//	Number of readers who have grabbed the Read Lock - 
	//	Negative if a writer is waiting !
	//
	volatile	long	m_cReadLock ;

	//
	//	Number of Readers who have left the lock since a 
	//	writer tried to grab it !
	//
	volatile	long	m_cOutReaders ;

	//
	//	Number of readers who are entering the lock after 
	//	being blocked !!!
	//
	volatile	long	m_cOutAcquiringReaders ;

	//
	//	Number of threads needing m_lock to be held right now !
	//
	volatile	long	m_cExclusiveRefs ;

	//
	//	Handle that all the readers who are waiting try to grab !
	//
	volatile	HANDLE	m_hWaitingReaders ;

	//
	//	Handle that the single writer waiting for the lock is trying
	//	to grab !
	//
	volatile	HANDLE	m_hWaitingWriters ;

	void	inline
	WakeReaders() ;

	//
	//	The internal work of ShareLock - does a lot more of the stuff required
	//	when a writer is present !!!
	//
	void
	ShareLockInternal() ;

	//
	//	The internal work of ShareLock - does a lot more of the stuff required
	//	when a writer is present !!!
	//
	void
	ShareUnlockInternal() ;
	

	//
	//	You may not copy these objects - so this lock is private !
	//
	CShareLockNH( CShareLockNH& ) ;

	//
	//	You may not copy through assignment - so this operator is private !
	//
	CShareLockNH&	operator=( CShareLockNH& ) ;
	
public : 

	//
	//	Construction of CShareLockNH() objects always succeeds and there
	//	are no error cases !
	//
	CShareLockNH() ;

	//
	//	Grab the lock Shared - other threads may pass through ShareLock() as well
	//
	void	ShareLock() ;

	//
	//	Releases the lock - if we are the last reader to leave writers may
	//	start to enter the lock !
	//
	void	ShareUnlock() ;

	//
	//	Grab the lock Exclusively - no other readers or writers may enter !!
	//
	void	ExclusiveLock() ;

	//
	//	Release the Exclusive Locks - if there are readers waiting they 
	//	will enter before other waiting writers !
	//
	void	ExclusiveUnlock() ;

	//
	//	Convert an ExclusiveLock to a Shared - this cannot fail !
	//
	void	ExclusiveToShared() ;

	//
	//	Convert a Shared Lock to an Exclusive one - this can fail - returns
	//	TRUE if successfull !
	//
	BOOL	SharedToExclusive() ;

	//
	//	Return TRUE if we can get the lock shared.  Only fails when 
	//	somebody is attempting or has the lock exclusively, we will enter
	//	if there are only other readers in the lock.
	//
	BOOL	TryShareLock() ;

	//
	//	Return TRUE if we can get the lock Exclusively.  Only succeeds
	//	when nobody else is near the lock.
	//
	BOOL	TryExclusiveLock() ;

	//
	//	PartialLocks - 
	//
	//	Partial Locks are similar to Exclusive Locks - only one thread
	//	can successfully call PartialLock(), any other threads calling
	//	PartialLock() or ExclusiveLock() will block.
	//	HOWEVER - while a PartialLock() is held, Readers (threads calling
	//	ShareLock()) may enter the lock.
	//
	void	PartialLock() ;

	//
	//	Release the PartialLock - Other Exclusive() or Partial lock acquirers
	//	may now enter.
	//
	void	PartialUnlock() ;

	//
	//	Convert a Partial Lock to an Exclusive Lock.  This function is 
	//	guaranteed to succeed, HOWEVER a lock can only be converted with 
	//	this function once, i.e. a thread doing
	//		PartialLock() ;
	//		FirstPartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		FirstPartialToExclusive() ;
	//	will have problems - the second call to FirstPartialToExclusive()
	//	may mess up the lock state and cause the lock to fail horribly.
	//	If a user wishes to convert as above they must have a call sequence like : 
	//
	//		PartialLock() ;
	//		FirstPartialToExclusive() or PartialToExclusive() ;
	//		ExclusiveToPartial() ;
	//		PartialToExclusive() ;
	//
	//	If you change lock states more than once - you take your chances !
	//
	void	FirstPartialToExclusive() ;

	//
	//	Returns TRUE if we can get the lock Exclusively, otherwise
	//	we return FALSE with the lock remaining in the Partially held state.
	//
	//	NOTE : NYI in CShareLockNH - will always return FALSE !
	//
	BOOL	PartialToExclusive() ;

	//
	//	We can always go from an ExclusiveLock() to a PartialLock() state.
	//
	void	ExclusiveToPartial() ;

	//
	//	We can always go from a PartialLock() state to a SharedLock() state
	//
	void	PartialToShared() ;

	//
	//	Returns TRUE if we can get the lock Partially !
	//	If it returns FALSE we remain with the lock held Shared()
	//
	BOOL	SharedToPartial() ;

	//
	//	Returns TRUE only if no other threads are trying to get the lock
	//	ExclusiveLy or Partially !
	//
	BOOL	TryPartialLock() ;

} ;

//
//  This is a utility function to get an Event Handle we save 
//  for each thread - the handle is Created as: 
//      CreateEvent( NULL, 
//                  FALSE, 
//                  FALSE,
//                  NULL ) ;
//  This results in an auto-reset event which goes back to non signalled whenever a thread
//  is released.
//
HANDLE
_RW_INTERFACE_
GetPerThreadEvent() ;



#endif	//	_RWNEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\signatur.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	signatur.h

Abstract:

	This module contains the definition of object signatures

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/03/98	created

--*/

#ifndef _SIGNATUR_H_
#define _SIGNATUR_H_

// =================================================================
// Signatures
//

//
// CMailMsg
//
#define CMAILMSG_SIGNATURE_VALID						((DWORD)'MMCv')
#define CMAILMSG_SIGNATURE_INVALID						((DWORD)'MMCi')

//
// Block manager
//
#define BLOCK_HEAP_SIGNATURE_VALID						((DWORD)'SHPv')
#define BLOCK_HEAP_SIGNATURE_INVALID					((DWORD)'SHPi')

#define BLOCK_CONTEXT_SIGNATURE_VALID					((DWORD)'SBCv')
#define BLOCK_CONTEXT_SIGNATURE_INVALID					((DWORD)'SBCi')

//
// Property table
//
#define CPROPERTY_TABLE_SIGNATURE_VALID					((DWORD)'TPCv')
#define CPROPERTY_TABLE_SIGNATURE_INVALID				((DWORD)'TPCi')

#define GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID			((DWORD)'TPGv')
#define RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID		((DWORD)'TPLv')
#define RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID		((DWORD)'TPRv')
#define PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID		((DWORD)'TPMv')
#define PTABLE_INSTANCE_SIGNATURE_INVALID				((DWORD)'TPXi')

#define PROPERTY_FRAGMENT_SIGNATURE_VALID				((DWORD)'SFPv')
#define PROPERTY_FRAGMENT_SIGNATURE_INVALID				((DWORD)'SFPi')



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\smtpseo.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: smtpseo.h
//
// Contents:
//   Common types definitions needed across projects for SMTP's seo
//   dispatcher
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980608 12:29:40: Created.
//
//-------------------------------------------------------------
#ifndef __SMTPSEO_H__
#define __SMTPSEO_H__

#include <mailmsg.h>
#include <smtpevent.h>

//+------------------------------------------------------------
//
// Function: SMTP SEO completion function
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 16:13:28: Created.
//
//-------------------------------------------------------------
typedef HRESULT (*PFN_SMTPEVENT_CALLBACK)(HRESULT hrStatus,
                                          PVOID pvContext);


typedef enum _SMTP_DISPATCH_EVENT_TYPE
{
    SMTP_EVENT_NONE = 0,
    SMTP_MAIL_DROP_EVENT,
    SMTP_STOREDRV_DELIVERY_EVENT,
    SMTP_STOREDRV_ALLOC_EVENT,
    SMTP_STOREDRV_STARTUP_EVENT,
    SMTP_STOREDRV_PREPSHUTDOWN_EVENT,
    SMTP_STOREDRV_SHUTDOWN_EVENT,
    SMTP_MAILTRANSPORT_SUBMISSION_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT,
    SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT,
    SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT,
    SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT,
    SMTP_STOREDRV_ENUMMESS_EVENT,
    SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT,
    SMTP_MSGTRACKLOG_EVENT,
    SMTP_DNSRESOLVERRECORDSINK_EVENT,
    SMTP_MAXMSGSIZE_EVENT,
    SMTP_LOG_EVENT,
    SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT
} SMTP_DISPATCH_EVENT_TYPE;

typedef struct _EVENTPARAMS_SUBMISSION {
    IMailMsgProperties *pIMailMsgProperties;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatMsgQueue;
} EVENTPARAMS_SUBMISSION, *PEVENTPARAMS_SUBMISSION;

typedef struct _EVENTPARAMS_PRECATEGORIZE {
    IMailMsgProperties *pIMailMsgProperties;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatMsgQueue;
} EVENTPARAMS_PRECATEGORIZE, *PEVENTPARAMS_PRECATEGORIZE;

typedef struct _EVENTPARAMS_POSTCATEGORIZE {
    IMailMsgProperties *pIMailMsgProperties;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatMsgQueue;
} EVENTPARAMS_POSTCATEGORIZE, *PEVENTPARAMS_POSTCATEGORIZE;

typedef struct _EVENTPARAMS_CATREGISTER {
    ICategorizerParameters *pICatParams;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    LPSTR pszSourceLine;
    LPVOID pvCCategorizer;
    HRESULT hrSinkStatus;
} EVENTPARAMS_CATREGISTER, *PEVENTPARAMS_CATREGISTER;

typedef struct _EVENTPARAMS_CATBEGIN {
    ICategorizerMailMsgs *pICatMailMsgs;
} EVENTPARAMS_CATBEGIN, *PEVENTPARAMS_CATBEGIN;

typedef struct _EVENTPARAMS_CATEND {
    ICategorizerMailMsgs *pICatMailMsgs;
    HRESULT hrStatus;
} EVENTPARAMS_CATEND, *PEVENTPARAMS_CATEND;

typedef struct _EVENTPARAMS_CATBUILDQUERY {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pCCatAddr;
} EVENTPARAMS_CATBUILDQUERY, *PEVENTPARAMS_CATBUILDQUERY;

typedef struct _EVENTPARAMS_CATBUILDQUERIES {
    ICategorizerParameters *pICatParams;
    DWORD dwcAddresses;
    ICategorizerItem **rgpICatItems;
    ICategorizerQueries *pICatQueries;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pblk;
} EVENTPARAMS_CATBUILDQUERIES, *PEVENTPARAMS_CATBUILDQUERIES;

typedef struct _EVENTPARAMS_CATSENDQUERY {
    //
    // Params needed to call real sinks
    //
    ICategorizerParameters *pICatParams;
    ICategorizerQueries *pICatQueries;
    ICategorizerAsyncContext *pICatAsyncContext;
    //
    // Params needed by our implementation of ICategorizerAsyncContext
    //
    IMailTransportNotify *pIMailTransportNotify;
    PVOID pvNotifyContext;
    HRESULT hrResolutionStatus;
    PVOID pblk;
    //
    // Default/completion processing functions
    //
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;

} EVENTPARAMS_CATSENDQUERY, *PEVENTPARAMS_CATSENDQUERY;

typedef struct _EVENTPARAMS_CATSORTQUERYRESULT {
    ICategorizerParameters *pICatParams;
    HRESULT hrResolutionStatus;
    DWORD dwcAddresses;
    ICategorizerItem **rgpICatItems;
    DWORD dwcResults;
    ICategorizerItemAttributes **rgpICatItemAttributes;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pblk;
} EVENTPARAMS_CATSORTQUERYRESULT, *PEVENTPARAMS_CATSORTQUERYRESULT;

typedef struct _EVENTPARAMS_CATPROCESSITEM {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pCCatAddr;
} EVENTPARAMS_CATPROCESSITEM, *PEVENTPARAMS_CATPROCESSITEM;

typedef struct _EVENTPARAMS_CATEXPANDITEM {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PFN_SMTPEVENT_CALLBACK pfnCompletion;
    PVOID pCCatAddr;
    IMailTransportNotify *pIMailTransportNotify;
    PVOID pvNotifyContext;
} EVENTPARAMS_CATEXPANDITEM, *PEVENTPARAMS_CATEXPANDITEM;

typedef struct _EVENTPARAMS_CATCOMPLETEITEM {
    ICategorizerParameters *pICatParams;
    ICategorizerItem *pICatItem;
    PFN_SMTPEVENT_CALLBACK pfnDefault;
    PVOID pCCatAddr;
} EVENTPARAMS_CATCOMPLETEITEM, *PEVENTPARAMS_CATCOMPLETEITEM;

typedef struct _EVENTPARAMS_ROUTER {
    DWORD dwVirtualServerID;
    IMailMsgProperties *pIMailMsgProperties;
    IMessageRouter *pIMessageRouter;
    IMailTransportRouterReset *pIRouterReset;
    IMailTransportRoutingEngine *pIRoutingEngineDefault;
} EVENTPARAMS_ROUTER, *PEVENTPARAMS_ROUTER;


typedef struct _EVENTPARAMS_MSGTRACKLOG
{
    IUnknown           *pIServer;
    IMailMsgProperties *pIMailMsgProperties;
    LPMSG_TRACK_INFO    pMsgTrackInfo;
} EVENTPARAMS_MSGTRACKLOG, *PEVENTPARAMS_MSGTRACKLOG;


typedef struct _EVENTPARAMS_DNSRESOLVERRECORD {
    LPSTR                  pszHostName;
    LPSTR                  pszFQDN;
    DWORD                  dwVirtualServerId;
    IDnsResolverRecord   **ppIDnsResolverRecord;
} EVENTPARAMS_DNSRESOLVERRECORD, *PEVENTPARAMS_DNSRESOLVERRECORD;

typedef struct _EVENTPARAMS_MAXMSGSIZE
{
    IUnknown           *pIUnknown;
    IMailMsgProperties *pIMailMsg;
    BOOL               *pfShouldImposeLimit;
} EVENTPARAMS_MAXMSGSIZE, *PEVENTPARAMS_MAXMSGSIZE;

typedef struct _EVENTPARAMS_LOG
{
    LPSMTP_LOG_EVENT_INFO   pSmtpEventLogInfo;
    PVOID                   pDefaultEventLogHandler;
    DWORD                   iSelectedDebugLevel;
} EVENTPARAMS_LOG, *PEVENTPARAMS_LOG;

typedef struct _EVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS
{
    IUnknown               *pIServer;
    LPCSTR                  pszDomainName;
    DWORD                  *pdwDomainInfoFlags;
} EVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS, *PEVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS;

#endif //__SMTPSEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\seolib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolib.h

Abstract:

	This module contains definitions for useful utility
	classes and functions for the Server Extentions Object
	system.

Author:

	Don Dumitru (dondu@microsoft.com)

Revision History:

	dondu	05/20/97	Created.
	dondu	07/03/97	Rewrite.

--*/

#include "rwnew.h"
#include "seoexports.h"

/*

	See the ddrop2 test program for an example of how to
	use the CEventBaseDispatcher class.

*/


template<class T, DWORD dwGrowBy=4>
class CSEOGrowableList {
	public:

		CSEOGrowableList() {
			m_dwCount = 0;
			m_dwAlloc = 0;
			m_apData = NULL;
		};

		~CSEOGrowableList() {
			RemoveAll();
		};

		DWORD Count() {
			return (m_dwCount);
		};

		T* Index(DWORD dwIdx) {
		    T *pRet = NULL;

		    m_slData.ShareLock();

			if (dwIdx<m_dwCount) {
			    pRet = m_apData[dwIdx];
			}

			m_slData.ShareUnlock();

			return pRet;
		};

		T& operator[](DWORD dwIdx) {
		    T *pRet = Index(dwIdx);
		    _ASSERTE(pRet);
		    return *pRet;
		};

		virtual int Compare(T* p1, T* p2) {
			// don't sort by default
			return (1);
		};

		HRESULT Add(T* pNewData) {

			if (!pNewData) {
				return (E_POINTER);
			}

			m_slData.ExclusiveLock();

			// Check if we have space for the new item and allocate more memory if necessary
			if (m_dwCount == m_dwAlloc) {

			    // Allocate
			    T** pNewData = (T**)realloc(m_apData,sizeof(T*)*(m_dwAlloc+dwGrowBy));
			    if (!pNewData) {
				    m_slData.ExclusiveUnlock();
					return(E_OUTOFMEMORY);
			    }
			    m_apData = pNewData;
			    m_dwAlloc += dwGrowBy;

			    // Clear new memory
			    memset(m_apData+m_dwCount,0,sizeof(T*)*dwGrowBy);
			}

			// Now find the position for the new item - we loop from the
			// end to the start so that we can minimize the cost inserting
			// unsorted items
			for (DWORD dwIdx=m_dwCount;dwIdx>0;dwIdx--) {
				int iCmpRes = Compare(pNewData,m_apData[dwIdx-1]);
				if (iCmpRes < 0) {
					continue;
				}
				break;
			}

            // Now move the items past the new item and insert it
            memmove(m_apData+dwIdx+1,m_apData+dwIdx,sizeof(T*)*(m_dwCount-dwIdx));
			m_apData[dwIdx] = pNewData;
			m_dwCount++;

			m_slData.ExclusiveUnlock();

			return (S_OK);
		};

		void Remove(DWORD dwIdx, T **ppT) {
			if (!ppT) {
				_ASSERTE(FALSE);
				return;
			}

			m_slData.ExclusiveLock();

			if (dwIdx >= m_dwCount) {
				_ASSERTE(FALSE);
				*ppT = NULL;
				return;
			}
			*ppT = m_apData[dwIdx];
			memmove(&m_apData[dwIdx],&m_apData[dwIdx+1],sizeof(m_apData[0])*(m_dwCount-dwIdx-1));
			m_dwCount--;

			m_slData.ExclusiveUnlock();
		};

		void Remove(DWORD dwIdx) {
			T *pT;
			Remove(dwIdx,&pT);
			delete pT;
		};

		void RemoveAll() {

		    m_slData.ExclusiveLock();

			if (m_apData) {
				for (DWORD dwIdx=0;dwIdx<m_dwCount;dwIdx++) {
					delete m_apData[dwIdx];
				}
				free(m_apData);
			}
			m_dwCount = 0;
			m_dwAlloc = 0;
			m_apData = NULL;

			m_slData.ExclusiveUnlock();
		}

	protected:
		DWORD           m_dwCount;
		DWORD           m_dwAlloc;
		T**             m_apData;
		CShareLockNH    m_slData;
};


class CEventBaseDispatcher : public IEventDispatcher {
	public:

		CEventBaseDispatcher();

		virtual ~CEventBaseDispatcher();

		class CBinding {
			public:
				CBinding();
				virtual ~CBinding();
				virtual HRESULT Init(IEventBinding *piBinding);
				virtual int Compare(const CBinding& b) const;
				static HRESULT InitRuleEngine(IEventBinding *piBinding, REFIID iidDesired, IUnknown **ppUnkRuleEngine);
				virtual HRESULT InitRuleEngine();
			public:
				BOOL m_bIsValid;
				CComPtr<IEventBinding> m_piBinding;
				BOOL m_bExclusive;
				DWORD m_dwPriority;
		};

		class CBindingList : public CSEOGrowableList<CBinding> {
			public:
				virtual int Compare(CBinding* p1, CBinding* p2);
		};

		class CParams {
			public:
				virtual HRESULT CheckRule(CBinding& bBinding);
					// returns S_OK if the object should be called
					// returns S_FALSE if the object should not be called
					// any other return value causes the object to not be called
				virtual HRESULT CallObject(IEventManager *piManager, CBinding& bBinding);
					// returns S_OK if the object was called
					// returns S_FALSE if the object was called and if no other objects should be called
					// returns FAILED() if the object was not called
				virtual HRESULT CallObject(CBinding& bBinding, IUnknown *pUnkSink);
					// returns S_OK if the object was called
					// returns S_FALSE if the object was called and if no other objects should be called
					// returns FAILED() if the object was not called
				virtual HRESULT Abort();
					// returns S_OK if processing should end
					// returns S_FALSE if processing should continue
					// any other return value causes processing to continue
		};

		virtual HRESULT Dispatcher(REFGUID rguidEventType, CParams *pParams);
		// returns S_OK if at least one sink was called
		// returns S_FALSE if no sinks were called
		// returns FAILED() if some super-catastrophic error happened

	// IEventDispatcher
	public:
		HRESULT STDMETHODCALLTYPE SetContext(REFGUID rguidEventType,
											 IEventRouter *piRouter,
											 IEventBindings *piBindings);

	public:

		class CETData : public CBindingList {
			public:
				CETData();
				virtual ~CETData();
			public:
				GUID m_guidEventType;
		};

		class CETDataList : public CSEOGrowableList<CETData> {
			public:
				CETData* Find(REFGUID guidEventType);
		};

		virtual HRESULT AllocBinding(REFGUID rguidEventType,
									 IEventBinding *pBinding,
									 CBinding **ppNewBinding);
		virtual HRESULT AllocETData(REFGUID rguidEventType,
									IEventBindings *piBindings,
									CETData **ppNewETData);

		CComPtr<IEventRouter> m_piRouter;
		CETDataList m_Data;
		CComPtr<IEventManager> m_piEventManager;
};

class CEventCreateOptionsBase : public IEventCreateOptions {
	HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riidDesired, LPVOID *ppvResult) {

		if (ppvResult) {
			*ppvResult = NULL;
		}
		if (!ppvResult) {
			return (E_NOTIMPL);
		}
		if (riidDesired == IID_IUnknown) {
			*ppvResult = (IUnknown *) this;
		} else if (riidDesired == IID_IDispatch) {
			*ppvResult = (IDispatch *) this;
		} else if (riidDesired == IID_IEventCreateOptions) {
			*ppvResult = (IEventCreateOptions *) this;
		}
		return ((*ppvResult)?S_OK:E_NOINTERFACE);
	};
	ULONG STDMETHODCALLTYPE AddRef() {
		return (2);
	};
	ULONG STDMETHODCALLTYPE Release() {
		return (1);
	};
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE GetTypeInfo(unsigned int, LCID, ITypeInfo **) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID, LPOLESTR *, unsigned int, LCID, DISPID *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, unsigned int *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE CreateBindCtx(DWORD, IBindCtx **) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE MkParseDisplayName(IBindCtx *, LPCOLESTR, ULONG *, IMoniker **) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE BindToObject(IMoniker *, IBindCtx *, IMoniker *, REFIID, LPVOID *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE CoCreateInstance(REFCLSID, IUnknown *, DWORD, REFIID, LPVOID *) {
		return (E_NOTIMPL);
	};
	HRESULT STDMETHODCALLTYPE Init(REFIID riidDesired, IUnknown **ppObject, IEventBinding *pBinding, IUnknown *pInitProps) {
		return (E_NOTIMPL);
	};
};


// All these functions return S_OK if they succeed, and S_FALSE if the source type or source is
// not present.  They return FAILED() on various catastrophic errors.
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSource, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventSource **ppSource);
STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventSource **ppSource);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSource, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventRouter **ppRouter);
STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventRouter **ppRouter);

STDMETHODIMP SEOGetServiceHandle(IUnknown **ppUnkHandle);

STDMETHODIMP SEOCreateObject(VARIANT *pvarClass, IEventBinding *pBinding, IUnknown *pInitProperties, REFIID iidDesired, IUnknown **ppUnkObject);
STDMETHODIMP SEOCreateObjectEx(VARIANT *pvarClass, IEventBinding *pBinding, IUnknown *pInitProperties, REFIID iidDesired, IUnknown *pUnkCreateOptions, IUnknown **ppUnkObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\smtpinet.h ===
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  SMTP specific items                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//  Service name.
//

# define SMTP_SERVICE_NAME          TEXT("SMTPSVC")
# define SMTP_SERVICE_NAME_A        "SMTPSVC"
# define SMTP_SERVICE_NAME_W        L"SMTPSVC"
# define SMTP_MD_ROOT_PATH          "/LM/SmtpSvc/"
# define SMTP_MD_LOCAL_DOMAINS_PATH "/LocalDomains"
# define SMTP_MD_DOMAIN_ROUTES_PATH "/DomainRoutes"

//
//   Client Interface Name for RPC connections over named pipes
//

# define  SMTP_INTERFACE_NAME     SMTP_SERVICE_NAME
# define  SMTP_NAMED_PIPE         TEXT("\\PIPE\\") ## SMTP_INTERFACE_NAME
# define  SMTP_NAMED_PIPE_W       L"\\PIPE\\" ## SMTP_SERVICE_NAME_W


//service location junk
#define INET_SMTP_SVCLOC_ID         (ULONGLONG)(0x2000000000000000)

//Domain routing table bit fields
typedef DWORD DOMAIN_ROUTE_ACTION_TYPE;

#define SMTP_NO_ACTION      ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000000))
#define SMTP_DROP           ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000001))
#define SMTP_SMARTHOST      ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000002))
#define SMTP_SSL            ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000004))
#define SMTP_SASL           ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000008))
#define SMTP_ALIAS          ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000010))
#define SMTP_DELIVER        ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000020))
#define SMTP_DEFAULT        ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000040))
#define SMTP_AUTH_NTLM      ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000080))
#define SMTP_AUTH_CLEARTEXT ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000100))
#define SMTP_ETRN_CMD       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000200))
#define SMTP_IP_RELAY       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000400))
#define SMTP_AUTH_RELAY     ((DOMAIN_ROUTE_ACTION_TYPE)(0x00000800))
#define SMTP_DOMAIN_RELAY   ((DOMAIN_ROUTE_ACTION_TYPE)(0x00001000))
#define SMTP_CSIDE_TURN     ((DOMAIN_ROUTE_ACTION_TYPE)(0x00002000))
#define SMTP_CSIDE_ETRN     ((DOMAIN_ROUTE_ACTION_TYPE)(0x00004000))
#define SMTP_DISABLE_ETRN   ((DOMAIN_ROUTE_ACTION_TYPE)(0x00008000))
#define SMTP_CHUNKING       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00010000))
#define SMTP_DISABLE_CHUNK  ((DOMAIN_ROUTE_ACTION_TYPE)(0x00020000))
#define SMTP_DISABLE_BMIME  ((DOMAIN_ROUTE_ACTION_TYPE)(0x00040000))
#define SMTP_DISABLE_DSN    ((DOMAIN_ROUTE_ACTION_TYPE)(0x00080000))
#define SMTP_DISABLE_PIPELINE ((DOMAIN_ROUTE_ACTION_TYPE)(0x00100000))
#define SMTP_AUTH_KERBEROS  ((DOMAIN_ROUTE_ACTION_TYPE)(0x00200000))
#define SMTP_USE_HELO       ((DOMAIN_ROUTE_ACTION_TYPE)(0x00400000))
#define SMTP_DISABLE_DROP_QUOTA ((DOMAIN_ROUTE_ACTION_TYPE)(0x00800000))

#define SMTP_ALL_ROUTE_FLAGS    ( \
                                SMTP_NO_ACTION |\
                                SMTP_DROP   |\
                                SMTP_SMARTHOST |\
                                SMTP_SSL |\
                                SMTP_SASL |\
                                SMTP_ALIAS |\
                                SMTP_DELIVER |\
                                SMTP_DEFAULT |\
                                SMTP_AUTH_NTLM |\
                                SMTP_AUTH_CLEARTEXT |\
                                SMTP_ETRN_CMD |\
                                SMTP_IP_RELAY |\
                                SMTP_AUTH_RELAY |\
                                SMTP_CSIDE_TURN |\
                                SMTP_CSIDE_ETRN |\
                                SMTP_DOMAIN_RELAY |\
                                SMTP_DISABLE_ETRN |\
                                SMTP_CHUNKING |\
                                SMTP_AUTH_KERBEROS |\
                                SMTP_USE_HELO)

#define SMTP_ALL_AUTH_FLAGS ( \
                            SMTP_AUTH_NTLM |\
                            SMTP_AUTH_CLEARTEXT \
                            )
//

typedef DWORD INBOUND_COMMAND_SUPPORT_OPTIONS;

#define SMTP_I_SUPPORT_VRFY         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000001))
#define SMTP_I_SUPPORT_VRFY_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000002))
#define SMTP_I_SUPPORT_VRFY_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000004))
#define SMTP_I_SUPPORT_EXPN         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000008))
#define SMTP_I_SUPPORT_EXPN_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000010))
#define SMTP_I_SUPPORT_EXPN_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000020))
#define SMTP_I_SUPPORT_DSN          ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000040))
#define SMTP_I_SUPPORT_ETRN         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000080))
#define SMTP_I_SUPPORT_ETRN_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000100))
#define SMTP_I_SUPPORT_ETRN_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000200))
#define SMTP_I_SUPPORT_TURN         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000400))
#define SMTP_I_SUPPORT_TURN_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000800))
#define SMTP_I_SUPPORT_ECODES       ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00001000))
#define SMTP_I_SUPPORT_PIPELINING   ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00002000))
#define SMTP_I_SUPPORT_AUTH         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00004000))
#define SMTP_I_SUPPORT_AUTH_ON_SSL  ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00008000))
#define SMTP_I_SUPPORT_LOGIN        ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00010000))
#define SMTP_I_SUPPORT_LOGIN_ON_SSL ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00020000))
#define SMTP_I_SUPPORT_HELP         ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00040000))
#define SMTP_I_SUPPORT_HELP_ON_AUTH ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00080000))
#define SMTP_I_SUPPORT_CHUNK        ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00100000))
#define SMTP_I_SUPPORT_BMIME        ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00200000))
#define SMTP_I_SUPPORT_8BITMIME    ((INBOUND_COMMAND_SUPPORT_OPTIONS)(0x00400000))

#define SMTP_DEFAULT_CMD_SUPPORT    ( \
                                SMTP_I_SUPPORT_VRFY |\
                                SMTP_I_SUPPORT_DSN |\
                                SMTP_I_SUPPORT_TURN |\
                                SMTP_I_SUPPORT_ETRN |\
                                SMTP_I_SUPPORT_AUTH |\
                                SMTP_I_SUPPORT_LOGIN |\
                                SMTP_I_SUPPORT_HELP |\
                                SMTP_I_SUPPORT_CHUNK |\
                                SMTP_I_SUPPORT_BMIME |\
                                SMTP_I_SUPPORT_ECODES |\
                                SMTP_I_SUPPORT_PIPELINING |\
                                SMTP_I_SUPPORT_8BITMIME )

#define SMTP_IS_SSL_CONNECTION (0x00000001)
#define SMTP_IS_AUTH_CONNECTION (0x00000002)

//

typedef DWORD OUTBOUND_COMMAND_SUPPORT_OPTIONS;

#define SMTP_0_SUPPORT_DSN      ((OUTBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000001))
#define SMTP_0_FORCE_CHUNK    ((OUTBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000002))
#define SMTP_0_SUPPORT_BMIME    ((OUTBOUND_COMMAND_SUPPORT_OPTIONS)(0x00000004))

#define SMTP_DEFAULT_OUTBOUND_SUPPORT   ( \
                                    SMTP_0_SUPPORT_DSN )

typedef DWORD REVERSE_DNS_OPTIONS;

#define SMTP_I_HELOEHLO_RDNS            ((REVERSE_DNS_OPTIONS)(0x00000001))
#define SMTP_I_HELOEHLO_RDNS_DISCONNECT ((REVERSE_DNS_OPTIONS)(0x00000002))
#define SMTP_I_MAILFROM_RDNS            ((REVERSE_DNS_OPTIONS)(0x00000004))
#define SMTP_I_MAILFROM_RDNS_DISCONNECT ((REVERSE_DNS_OPTIONS)(0x00000008))


//  these should be added in the
//  metabase with a user type of IIS_MD_UT_SERVER
//

#define MD_COMMAND_LOG_MASK             (SMTP_MD_ID_BEGIN_RESERVED )			// 36864
#define MD_FLUSH_MAIL_FILE              (SMTP_MD_ID_BEGIN_RESERVED+2 )
#define MD_BATCH_MSG_LIMIT              (SMTP_MD_ID_BEGIN_RESERVED+7 )
#define MD_MAX_MAIL_OBJECTS             (SMTP_MD_ID_BEGIN_RESERVED+9 )
#define MD_ROUTING_THREADS              (SMTP_MD_ID_BEGIN_RESERVED+10 )
#define MD_MAIL_QUEUE_DIR               (SMTP_MD_ID_BEGIN_RESERVED+11 )
#define MD_SHOULD_PICKUP_MAIL           (SMTP_MD_ID_BEGIN_RESERVED+12 )
#define MD_MAX_DIR_BUFFERS              (SMTP_MD_ID_BEGIN_RESERVED+13 )
#define MD_MAX_DIR_CHANGE_IO_SIZE       (SMTP_MD_ID_BEGIN_RESERVED+14 )
#define MD_MAX_DIR_PENDING_IOS          (SMTP_MD_ID_BEGIN_RESERVED+15 )
#define MD_MAIL_PICKUP_DIR              (SMTP_MD_ID_BEGIN_RESERVED+16 )			// 36880
#define MD_SHOULD_DELIVER               (SMTP_MD_ID_BEGIN_RESERVED+17 )
#define MD_MAIL_DROP_DIR                (SMTP_MD_ID_BEGIN_RESERVED+18 )
#define MD_ROUTING_DLL                  (SMTP_MD_ID_BEGIN_RESERVED+19 )
#define MD_REVERSE_NAME_LOOKUP          (SMTP_MD_ID_BEGIN_RESERVED+20 )
#define MD_NAME_RESOLUTION_TYPE         (SMTP_MD_ID_BEGIN_RESERVED+21 )
#define MD_HOP_COUNT                    (SMTP_MD_ID_BEGIN_RESERVED+22 )
#define MD_MAX_SMTP_ERRORS              (SMTP_MD_ID_BEGIN_RESERVED+23 )
#define MD_MAX_MSG_SIZE                 (SMTP_MD_ID_BEGIN_RESERVED+27 )
#define MD_MAX_MSG_SIZE_B4_CLOSE        (SMTP_MD_ID_BEGIN_RESERVED+28 )
//#define MD_OUTBOUND_TIMEOUT             (SMTP_MD_ID_BEGIN_RESERVED+29 )
#define MD_MAX_OUTBOUND_CONNECTION      (SMTP_MD_ID_BEGIN_RESERVED+30 )
#define MD_MAX_RECIPIENTS               (SMTP_MD_ID_BEGIN_RESERVED+31 )
#define MD_LOCAL_RETRY_ATTEMPTS         (SMTP_MD_ID_BEGIN_RESERVED+32 )
#define MD_LOCAL_RETRY_MINUTES          (SMTP_MD_ID_BEGIN_RESERVED+33 )
#define MD_REMOTE_RETRY_ATTEMPTS        (SMTP_MD_ID_BEGIN_RESERVED+34 )
#define MD_REMOTE_RETRY_MINUTES         (SMTP_MD_ID_BEGIN_RESERVED+35 )
//#define MD_SHARE_RETRY_MINUTES          (SMTP_MD_ID_BEGIN_RESERVED+36 )			// 36900
#define MD_SHOULD_PIPELINE_OUT          (SMTP_MD_ID_BEGIN_RESERVED+37 )
#define MD_SHOULD_PIPELINE_IN           (SMTP_MD_ID_BEGIN_RESERVED+38 )
#define MD_SMARTHOST_TYPE               (SMTP_MD_ID_BEGIN_RESERVED+41 )
#define MD_SMARTHOST_NAME               (SMTP_MD_ID_BEGIN_RESERVED+42 )
#define MD_CONNECT_RESPONSE             (SMTP_MD_ID_BEGIN_RESERVED+43 )
#define MD_DEFAULT_DOMAIN_VALUE         (SMTP_MD_ID_BEGIN_RESERVED+44 )
#define MD_BAD_MAIL_DIR                 (SMTP_MD_ID_BEGIN_RESERVED+45 )
#define MD_ROUTING_SOURCES              (SMTP_MD_ID_BEGIN_RESERVED+46 )
//#define MD_REMOTE_HANG_TIME             (SMTP_MD_ID_BEGIN_RESERVED+47 )
#define MD_MASQUERADE_NAME              (SMTP_MD_ID_BEGIN_RESERVED+48 )
#define MD_DO_MASQUERADE                (SMTP_MD_ID_BEGIN_RESERVED+49 )
#define MD_REMOTE_SMTP_PORT             (SMTP_MD_ID_BEGIN_RESERVED+50 )

// added by feisu
//#define MD_SSLPORT                      (SMTP_MD_ID_BEGIN_RESERVED+51 )
#define MD_POSTMASTER_EMAIL             (SMTP_MD_ID_BEGIN_RESERVED+52 )
#define MD_POSTMASTER_NAME              (SMTP_MD_ID_BEGIN_RESERVED+53 )
#define MD_ETRN_DAYS                    (SMTP_MD_ID_BEGIN_RESERVED+54 )
// end added by feisu

#define MD_LOCAL_DOMAINS                (SMTP_MD_ID_BEGIN_RESERVED+55)
#define MD_DOMAIN_ROUTING               (SMTP_MD_ID_BEGIN_RESERVED+56)			// 36920
#define MD_REMOTE_TIMEOUT               (SMTP_MD_ID_BEGIN_RESERVED+57)

#define MD_SEND_NDR_TO                  (SMTP_MD_ID_BEGIN_RESERVED+58)
#define MD_SEND_BAD_TO                  (SMTP_MD_ID_BEGIN_RESERVED+59)
#define MD_ALWAYS_USE_SSL               (SMTP_MD_ID_BEGIN_RESERVED+60)
#define MD_MAX_OUT_CONN_PER_DOMAIN      (SMTP_MD_ID_BEGIN_RESERVED+61)
#define MD_LIMIT_REMOTE_CONNECTIONS     (SMTP_MD_ID_BEGIN_RESERVED+62)
#define MD_REMOTE_SECURE_PORT           (SMTP_MD_ID_BEGIN_RESERVED+65)
//#define MD_SORT_TEMP_DIR                (SMTP_MD_ID_BEGIN_RESERVED+66)
#define MD_SMTP_SERVICE_VERSION         (SMTP_MD_ID_BEGIN_RESERVED+67)

//#define MD_SMTP_EXTENSION_DLLS          (SMTP_MD_ID_BEGIN_RESERVED+68)
//#define MD_SMTP_NUM_RESOLVER_SOCKETS    (SMTP_MD_ID_BEGIN_RESERVED+69)
//#define MD_SMTP_USE_MX_RESOLVER         (SMTP_MD_ID_BEGIN_RESERVED+70)
#define MD_FQDN_VALUE                   (SMTP_MD_ID_BEGIN_RESERVED+71)
#define MD_UPDATED_FQDN                 (SMTP_MD_ID_BEGIN_RESERVED+72)
#define MD_UPDATED_DEFAULT_DOMAIN       (SMTP_MD_ID_BEGIN_RESERVED+73)
#define MD_ETRN_SUBDOMAINS              (SMTP_MD_ID_BEGIN_RESERVED+74)
//#define MD_MAX_POOL_THREADS             (SMTP_MD_ID_BEGIN_RESERVED+75)
#define MD_SASL_LOGON_DOMAIN            (SMTP_MD_ID_BEGIN_RESERVED+76)			// 36940
//#define MD_SERVER_SS_AUTH_MAPPING       (SMTP_MD_ID_BEGIN_RESERVED+77)
#define MD_SMTP_CLEARTEXT_AUTH_PROVIDER (SMTP_MD_ID_BEGIN_RESERVED+78)
//#define MD_ALWAYS_USE_SASL              (SMTP_MD_ID_BEGIN_RESERVED+79)
//#define MD_SMTP_AUTHORIZATION           (SMTP_MD_ID_BEGIN_RESERVED+80)
#define MD_MAX_SMTP_AUTHLOGON_ERRORS    (SMTP_MD_ID_BEGIN_RESERVED+81)

#define MD_ROUTE_ACTION                 (SMTP_MD_ID_BEGIN_RESERVED+82)
#define MD_ROUTE_ACTION_TYPE            (SMTP_MD_ID_BEGIN_RESERVED+83)
#define MD_ROUTE_USER_NAME              (SMTP_MD_ID_BEGIN_RESERVED+84)
#define MD_ROUTE_PASSWORD               (SMTP_MD_ID_BEGIN_RESERVED+85)

#define MD_SMTP_DS_TYPE                 (SMTP_MD_ID_BEGIN_RESERVED+86)
#define MD_SMTP_DS_DATA_DIRECTORY       (SMTP_MD_ID_BEGIN_RESERVED+87)
#define MD_SMTP_DS_DEFAULT_MAIL_ROOT    (SMTP_MD_ID_BEGIN_RESERVED+88)
#define MD_SMTP_DS_BIND_TYPE            (SMTP_MD_ID_BEGIN_RESERVED+89)
#define MD_SMTP_DS_SCHEMA_TYPE          (SMTP_MD_ID_BEGIN_RESERVED+90)
#define MD_SMTP_DS_HOST                 (SMTP_MD_ID_BEGIN_RESERVED+91)
#define MD_SMTP_DS_NAMING_CONTEXT       (SMTP_MD_ID_BEGIN_RESERVED+92)
#define MD_SMTP_DS_ACCOUNT              (SMTP_MD_ID_BEGIN_RESERVED+93)
#define MD_SMTP_DS_PASSWORD             (SMTP_MD_ID_BEGIN_RESERVED+94)
//#define MD_SMTP_DS_MAX_RESOLVE_BUFFERS  (SMTP_MD_ID_BEGIN_RESERVED+95)
//#define MD_SMTP_DS_MAX_VIRTUAL_SERVERS  (SMTP_MD_ID_BEGIN_RESERVED+96)			// 36960
//#define MD_SMTP_DS_MAX_HANDLE_CACHE_ENTRIES  (SMTP_MD_ID_BEGIN_RESERVED+97)
//#define MD_SMTP_DS_SORT_THRESHOLD       (SMTP_MD_ID_BEGIN_RESERVED+98)
//#define MD_SMTP_PREFERRED_AUTH          (SMTP_MD_ID_BEGIN_RESERVED+99)
#define MD_SMTP_MAX_REMOTEQ_THREADS     (SMTP_MD_ID_BEGIN_RESERVED+100)
#define MD_SMTP_MAX_LOCALQ_THREADS      (SMTP_MD_ID_BEGIN_RESERVED+101)
#define MD_SMTP_AUTHORIZED_TURN_LIST    (SMTP_MD_ID_BEGIN_RESERVED+102)
#define MD_SMTP_CSIDE_ETRN_DELAY        (SMTP_MD_ID_BEGIN_RESERVED+103)
#define MD_SMTP_CSIDE_ETRN_DOMAIN       (SMTP_MD_ID_BEGIN_RESERVED+104)
//#define MD_SMTP_VALIDATE_HELO_ARG       (SMTP_MD_ID_BEGIN_RESERVED+105)
#define MD_SMTP_IP_RELAY_ADDRESSES      (SMTP_MD_ID_BEGIN_RESERVED+106)

//#define MD_SYSTEM_ROUTING_THREADS       (SMTP_MD_ID_BEGIN_RESERVED+108)
#define MD_SMTP_RELAY_FOR_AUTH_USERS    (SMTP_MD_ID_BEGIN_RESERVED+109)
#define MD_SMTP_DISABLE_RELAY           (SMTP_MD_ID_BEGIN_RESERVED+110)

//Chunking advertisement flags
//#define MD_SHOW_BINARY_MIME             (SMTP_MD_ID_BEGIN_RESERVED+111)
//#define MD_SHOW_CHUNKING                (SMTP_MD_ID_BEGIN_RESERVED+112)

//#define MD_SMTP_RDNS_OPTIONS            (SMTP_MD_ID_BEGIN_RESERVED+113)
//#define MD_SMTP_DSN_DELAY               (SMTP_MD_ID_BEGIN_RESERVED+114)
#define MD_ROUTE_AUTHTARGET             (SMTP_MD_ID_BEGIN_RESERVED+115)
																				// (+116) 36980
#define MD_SMTP_HELO_NODOMAIN           (SMTP_MD_ID_BEGIN_RESERVED+117)
#define MD_SMTP_MAIL_NO_HELO            (SMTP_MD_ID_BEGIN_RESERVED+118)
#define MD_SMTP_INBOUND_NAGLE           (SMTP_MD_ID_BEGIN_RESERVED+119)
#define MD_SMTP_OUTBOUND_NAGLE          (SMTP_MD_ID_BEGIN_RESERVED+120)
#define MD_SMTP_INBOUND_SND_BUFF        (SMTP_MD_ID_BEGIN_RESERVED+121)
#define MD_SMTP_INBOUND_RCV_BUFF        (SMTP_MD_ID_BEGIN_RESERVED+122)

//DLL specifiers flags
#define MD_AQUEUE_DLL                   (SMTP_MD_ID_BEGIN_RESERVED+123)
//#define MD_MAPIDRV_DLL                  (SMTP_MD_ID_BEGIN_RESERVED+124)
//#define MD_CAT_DLL                      (SMTP_MD_ID_BEGIN_RESERVED+125)
#define MD_SMTP_AQUEUE_WAIT             (SMTP_MD_ID_BEGIN_RESERVED+126)
//#define MD_SMTP_USE_REMOTE_DS           (SMTP_MD_ID_BEGIN_RESERVED+127)

//Address validation flags
#define MD_DOMAIN_VALIDATION_FLAGS      (SMTP_MD_ID_BEGIN_RESERVED+128)
#define MD_SMTP_DS_DOMAIN               (SMTP_MD_ID_BEGIN_RESERVED+129)
#define MD_SMTP_DS_USE_CAT              (SMTP_MD_ID_BEGIN_RESERVED+130)


//New Retry related flags
#define MD_SMTP_REMOTE_RETRY_THRESHOLD           (SMTP_MD_ID_BEGIN_RESERVED+131)
#define MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES (SMTP_MD_ID_BEGIN_RESERVED+132)

#define MD_SMTP_USE_TCP_DNS             (SMTP_MD_ID_BEGIN_RESERVED+133)

#define MD_INBOUND_COMMAND_SUPPORT_OPTIONS  (SMTP_MD_ID_BEGIN_RESERVED+134)
#define MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS  (SMTP_MD_ID_BEGIN_RESERVED+135)
#define MD_ADD_NOHEADERS                (SMTP_MD_ID_BEGIN_RESERVED+136)			// 37000


//Relocated due to ID conflict
#define MD_SMTP_CONNECT_TIMEOUT         (SMTP_MD_ID_BEGIN_RESERVED+137)
#define MD_SMTP_MAILFROM_TIMEOUT        (SMTP_MD_ID_BEGIN_RESERVED+138)
#define MD_SMTP_RCPTTO_TIMEOUT          (SMTP_MD_ID_BEGIN_RESERVED+139)
#define MD_SMTP_DATA_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+140)
#define MD_SMTP_BDAT_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+141)
#define MD_SMTP_AUTH_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+142)
#define MD_SMTP_SASL_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+143)
//#define MD_SMTP_ETRN_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+144)
#define MD_SMTP_TURN_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+145)
#define MD_SMTP_RSET_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+146)
//#define MD_SMTP_QUIT_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+147)
#define MD_SMTP_HELO_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+148)
//#define MD_SMTP_EHLO_TIMEOUT            (SMTP_MD_ID_BEGIN_RESERVED+149)
//#define MD_SMTP_DATATERMINATION_TIMEOUT (SMTP_MD_ID_BEGIN_RESERVED+150)
//#define MD_SMTP_BDATTERMINATION_TIMEOUT (SMTP_MD_ID_BEGIN_RESERVED+151)
//#define MD_SMTP_TLS_TIMEOUT             (SMTP_MD_ID_BEGIN_RESERVED+152)

//For setting DSN expire intervals (in minutes)
#define MD_SMTP_EXPIRE_LOCAL_DELAY_MIN  (SMTP_MD_ID_BEGIN_RESERVED+153)
#define MD_SMTP_EXPIRE_LOCAL_NDR_MIN    (SMTP_MD_ID_BEGIN_RESERVED+154)
#define MD_SMTP_EXPIRE_REMOTE_DELAY_MIN (SMTP_MD_ID_BEGIN_RESERVED+155)
#define MD_SMTP_EXPIRE_REMOTE_NDR_MIN   (SMTP_MD_ID_BEGIN_RESERVED+156)			// 37020

//DSN specific keys
#define MD_SMTP_DSN_OPTIONS             (SMTP_MD_ID_BEGIN_RESERVED+157)
#define MD_SMTP_DSN_LANGUAGE_ID         (SMTP_MD_ID_BEGIN_RESERVED+158)

//
// jstamerj 1998/10/27 08:36:59: To specify the remote ldap tcp port
//
#define MD_SMTP_DS_PORT                 (SMTP_MD_ID_BEGIN_RESERVED+159)
#define MD_SMTP_DS_FLAGS                (SMTP_MD_ID_BEGIN_RESERVED+160)

// SSL keys
#define MD_SMTP_SSL_REQUIRE_TRUSTED_CA       (SMTP_MD_ID_BEGIN_RESERVED+161)
#define MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION (SMTP_MD_ID_BEGIN_RESERVED+162)

// logging level
#define MD_SMTP_EVENTLOG_LEVEL          (SMTP_MD_ID_BEGIN_RESERVED+163)

//#define MD_SMTP_MAX_INBOUND_CONNECTIONS_PER_IP (SMTP_MD_ID_BEGIN_RESERVED+164 )
//#define MD_SMTP_SSL_CERT_HOSTNAME_OVERRIDE  (SMTP_MD_ID_BEGIN_RESERVED+165)

#define MD_SMTP_DISABLE_PICKUP_DOT_STUFF     (SMTP_MD_ID_BEGIN_RESERVED+166)
//
// Flags for the MD_SMTP_DS_FLAGS DWORD key:
//
#define SMTPDSFLAG_RESOLVELOCAL         0x00000001
#define SMTPDSFLAG_RESOLVEREMOTE        0x00000002
#define SMTPDSFLAG_RESOLVESENDER        0x00000004
#define SMTPDSFLAG_RESOLVERECIPIENTS    0x00000008
#define SMTPDSFLAG_ALLFLAGS             0x0000000F
//
//Flags for the MD_SMTP_DS_USE_CAT DWORD key:
//
#define SMTPDSUSECAT_ENABLED            0xFFFFFFFF
#define SMTPDSUSECAT_DISABLED           0x00000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\seolib2.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	seolib2.h

Abstract:

	This module contains definitions for useful utility
	classes and functions for the Server Extentions Object
	system.

Author:

	Don Dumitru (dondu@microsoft.com)

Revision History:

	dondu	06/22/98	Created.

--*/


class __declspec(uuid("208DB171-097B-11d2-A011-00C04FA37348")) CEDEnumGUID :
	public IEnumGUID,	// list this first
	public CComObjectRootEx<CComMultiThreadModelNoCS>
{
	public:
	    DECLARE_PROTECT_FINAL_CONSTRUCT();
	    
	    DECLARE_GET_CONTROLLING_UNKNOWN();

	    DECLARE_NOT_AGGREGATABLE(CEDEnumGUID);

	    BEGIN_COM_MAP(CEDEnumGUID)
	        COM_INTERFACE_ENTRY(IEnumGUID)
			COM_INTERFACE_ENTRY_IID(__uuidof(CEDEnumGUID),CEDEnumGUID)
	    END_COM_MAP()

	public:
		CEDEnumGUID() {
			m_dwIdx = 0;
			m_ppGUID = NULL;
		};
		static HRESULT CreateNew(IUnknown **ppUnkNew, const GUID **ppGUID, DWORD dwIdx=0) {
			HRESULT hrRes;
			CComQIPtr<CEDEnumGUID,&__uuidof(CEDEnumGUID)> pInit;

			if (ppUnkNew) {
				*ppUnkNew = NULL;
			}
			if (!ppUnkNew) {
				return (E_POINTER);
			}
			if (!ppGUID) {
				return E_INVALIDARG;
			}
			hrRes = CComObject<CEDEnumGUID>::_CreatorClass::CreateInstance(NULL,
																		   __uuidof(IEnumGUID),
																		   (LPVOID *) ppUnkNew);
			if (SUCCEEDED(hrRes)) {
				pInit = *ppUnkNew;
				if (!pInit) {
					hrRes = E_NOINTERFACE;
				}
			}
			if (SUCCEEDED(hrRes)) {
				hrRes = pInit->InitNew(dwIdx,ppGUID);
			}
			if (!SUCCEEDED(hrRes) && *ppUnkNew) {
				(*ppUnkNew)->Release();
				*ppUnkNew = NULL;
			}
			return (hrRes);
		};

	// IEnumGUID
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, GUID *pelt, ULONG *pceltFetched) {
			HRESULT hrRes = S_FALSE;

			if (!m_ppGUID) {
				return (E_FAIL);
			}
			if (pceltFetched) {
				*pceltFetched = 0;
			}
			if (!pelt) {
				return (E_POINTER);
			}
			if ((celt > 1) && !pceltFetched) {
				return (E_INVALIDARG);
			}
			while (celt && (*(m_ppGUID[m_dwIdx]) != GUID_NULL)) {
				*pelt = *(m_ppGUID[m_dwIdx]);
				pelt++;
				celt--;
				m_dwIdx++;
				if (pceltFetched) {
					(*pceltFetched)++;
				}
			}
			if (!celt) {
				hrRes = S_OK;
			}
			return (hrRes);
		};
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt) {
			HRESULT hrRes = S_FALSE;

			if (!m_ppGUID) {
				return (E_FAIL);
			}
			while (celt && (*(m_ppGUID[m_dwIdx]) != GUID_NULL)) {
				celt--;
				m_dwIdx++;
			}
			if (!celt) {
				hrRes = S_OK;
			}
			return (hrRes);
		};
		HRESULT STDMETHODCALLTYPE Reset() {
			m_dwIdx = 0;
			return (S_OK);
		};
		HRESULT STDMETHODCALLTYPE Clone(IEnumGUID **ppClone) {
			return (CreateNew((IUnknown **) ppClone,m_ppGUID,m_dwIdx));
		};

	private:
		HRESULT InitNew(DWORD dwIdx, const GUID **ppGUID) {
			m_dwIdx = dwIdx;
			m_ppGUID = ppGUID;
			return (S_OK);
		};
		DWORD m_dwIdx;
		const GUID **m_ppGUID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\seoexports.h ===
//-----------------------------------------------------------------------------
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Description:
//      This header file defines stuff published by SEO to other (Microsoft
//      internal) projects in additon to the seo.idl file.
//
//-----------------------------------------------------------------------------

#ifndef __SEOEXPORTS_H__
#define __SEOEXPORTS_H__

class CStringGUID {
	public:
		CStringGUID() { m_bValid=FALSE; };
		CStringGUID(const CStringGUID& objGuid) { m_bValid=FALSE; Assign(objGuid); };
		CStringGUID(REFGUID rGuid) { m_bValid=FALSE; Assign(rGuid); };
		CStringGUID(LPCOLESTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(LPCSTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(const VARIANT *pvarGuid) { m_bValid=FALSE; Assign(pvarGuid); };
		CStringGUID(const VARIANT& varGuid) { m_bValid=FALSE; Assign(varGuid); };
		CStringGUID(REFGUID rGuid, DWORD dwIndex) {
			GUID tmp = rGuid;
			tmp.Data4[7] |= 0x80;
			tmp.Data2 = (WORD) (dwIndex >> 16);
			tmp.Data3 = (WORD) dwIndex;
			Assign(rGuid,dwIndex); };
		BOOL ReCalcFromGuid() {
			m_bValid = FALSE;
			if (SUCCEEDED(StringFromGUID2(m_guid,m_szGuidW,sizeof(m_szGuidW)/sizeof(m_szGuidW[0])))) {
				ATLW2AHELPER(m_szGuidA,m_szGuidW,sizeof(m_szGuidA)/sizeof(m_szGuidA[0])); m_bValid=TRUE; };
#ifdef DEBUG
			USES_CONVERSION;
			_ASSERTE(!m_bValid||(!strcmp(W2A(m_szGuidW),m_szGuidA)&&!wcscmp(m_szGuidW,A2W(m_szGuidA))));
#endif
			return (m_bValid); };
		BOOL CalcNew() {
			if (!SUCCEEDED(CoCreateGuid(&m_guid))) { m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCOLESTR pszProgID) {
			if (!pszProgID || !SUCCEEDED(CLSIDFromProgID(pszProgID,&m_guid))) {
				m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCSTR pszProgID) {
			USES_CONVERSION; return (CalcFromProgID(pszProgID?A2W(pszProgID):NULL)); };
		BOOL Assign(const CStringGUID& objGuid) { operator =(objGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid) { operator =(rGuid); return (m_bValid); };
		BOOL Assign(LPCOLESTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(LPCSTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(const VARIANT *pvarGuid) { operator =(pvarGuid); return (m_bValid); };
		BOOL Assign(const VARIANT& varGuid) { operator =(varGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid, DWORD dwIndex) {
			// For index'ed GUID's, we set the high-bit of the MAC-address in the GUID - this
			// is the multicast bit, and will never be set for any real MAC-address.  Then we
			// XOR the index value over the Data2 and Data 3 fields of the GUID.  Since we
			// leave the timestamp fields completely untouched, confidence is "high" that this
			// algorithm will never create collisions with any other GUID's.
			GUID tmp = rGuid;
			tmp.Data4[2] |= 0x80;
			tmp.Data2 ^= (WORD) (dwIndex >> 16);
			tmp.Data3 ^= (WORD) dwIndex;
			operator =(tmp);
			return (m_bValid); };
		BOOL GetIndex(REFGUID rGuid, DWORD *dwIndex) {
			// check to see if this is an indexed GUID by seeing if the
			// multicast bit is set to 1
			if ((m_guid.Data4[2] & 0x80) != 0x80) return FALSE;
			*dwIndex = 0;
			// get the high part
			*dwIndex = ((WORD) (rGuid.Data2) ^ (m_guid.Data2)) << 16;
			// get the low part
			*dwIndex += (WORD) ((rGuid.Data3) ^ (m_guid.Data3));
			// This does not check that rGuid mangles into m_guid
			// if you run it through the index function with dwIndex
			return TRUE;
		}
		operator REFGUID() { _ASSERTE(m_bValid); return (m_guid); };
		operator LPCOLESTR() { _ASSERTE(m_bValid); return (m_szGuidW); };
		operator LPCSTR() { _ASSERTE(m_bValid); return (m_szGuidA); };
		const CStringGUID& operator =(const CStringGUID& objGuid) {
			if (!objGuid) { m_bValid=FALSE; return (*this); };
			return (operator=((REFGUID) objGuid)); };
		const CStringGUID& operator =(REFGUID rGuid) {
			m_guid = rGuid; ReCalcFromGuid(); return (*this); };
		const CStringGUID& operator =(LPCOLESTR pszGuid) {
			m_bValid=FALSE;
			if (pszGuid && SUCCEEDED(CLSIDFromString((LPOLESTR) pszGuid,&m_guid))) ReCalcFromGuid();
			return (*this); };
		const CStringGUID& operator =(LPCSTR pszGuid) {
			USES_CONVERSION; return (operator=(pszGuid?A2W(pszGuid):NULL)); };
		const CStringGUID& operator =(const VARIANT *pvarGuid) {
			if (!pvarGuid) { m_bValid=FALSE; return (*this); } return (operator =(*pvarGuid)); };
		const CStringGUID& operator =(const VARIANT& varGuid) {
				CComVariant varTmp(varGuid);
				if (!SUCCEEDED(varTmp.ChangeType(VT_BSTR))) { m_bValid=FALSE; return (*this); };
				return (operator =(varTmp.bstrVal)); };
		GUID* operator &() { _ASSERTE(!m_bValid); return (&m_guid); };
		BOOL operator !() const { return (!m_bValid); };
	private:
		BOOL m_bValid;
		GUID m_guid;
		WCHAR m_szGuidW[40];
		CHAR m_szGuidA[40];
};

#endif // __SEOEXPORTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\webhlpr.h ===
#ifndef _WEBHELP_INCLUDED_
#define _WEBHELP_INCLUDED_

HRESULT
EnumerateTrustedDomains (
    LPCWSTR     wszComputer,
    LPWSTR *    pmszDomains
    );

HRESULT
GetPrimaryDomain (
    LPCWSTR     wszComputer,
    LPWSTR *    pwszPrimaryDomain
    );

HRESULT
CheckNTAccount (
    LPCWSTR     wszComputer,
    LPCWSTR     wszUsername,
    BOOL *      pfExists
    );

HRESULT
CreateNTAccount (
    LPCWSTR     wszComputer,
    LPCWSTR     wszDomain,
    LPCWSTR     wszUsername,
    LPCWSTR     wszPassword
    );

BOOL
IsValidEmailAddress (
    LPCWSTR     wszEmailAddress
    );

void
StringToUpper (
    LPWSTR      wsz
    );

#if 0

HRESULT
DeleteMailbox (
    LPCWSTR     wszServer,
    LPCWSTR     wszAlias,
    LPCWSTR     wszVirtualDirectoryPath,
    LPCWSTR     wszUsername,    // OPTIONAL
    LPCWSTR     wszPassword     // OPTIONAL
    );

#endif

#endif // _WEBHELP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\writebuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    writebuf.h

Abstract:

    This module contains class declarations/definitions for

        CFlatFileWriteBuf
        
    **** Overview ****

    The write buffer that buffers up a batch of writes for flatfile.
    Using sequential scan is good for reads, but may not be sufficient
    for sequential writes.  This buffer is only enabled when data
    being written to the file is not critical ( meaning losing of data
    is OK if the system crashes ).
    
Author:

    Kangrong Yan    ( KangYan )     5-6-1999

Revision History:

--*/
#ifndef _WRITEBUF_H_
#define _WRITEBUF_H_

class CFlatFile;

class CFlatFileWriteBuf {   //wb

public:

    //
    // Constructor, destructor
    //

    CFlatFileWriteBuf( CFlatFile* pParentFile );
    ~CFlatFileWriteBuf();

    //
    // Write the byte range
    //
    
    HRESULT WriteFileBuffer( 
                const DWORD   dwOffset, 
                const PBYTE   pb, 
                const DWORD   cb,
                PDWORD  pdwOffset,
                PDWORD  pcbWritten );
    
    //
    // Flush the buffer into the file
    //

    HRESULT FlushFile();

    //
    // Tell the outside world if we are enabled
    //

    BOOL IsEnabled() const;

    //
    // Enable the write buffer and give it the buffer size
    //

    VOID Enable( const DWORD cbBuffer );

    //
    // Check to see if the buffer needs flush
    //

    BOOL NeedFlush() const;

private:

    //
    // Private functions
    //

    HRESULT WriteFileReal(
                    const DWORD dwOffset,
                    const PBYTE pbBuffer,
                    const DWORD cbBuffer,
                    PDWORD      pdwOffset,
                    PDWORD      pcbWritten
                    );

    DWORD BufferAvail() const;

    VOID FillBuffer(
                    const DWORD     dwOffset,
                    const PBYTE     pbBuffer,
                    const DWORD     cbBuffer,
                    PDWORD          pdwOffset,
                    PDWORD          pcbWritten
                    );

    BOOL NeedFlush( 
                    const DWORD dwOffset,
                    const DWORD cbData 
                    ) const;

    //
    // Back pointer to parent flat file
    //

    CFlatFile*  m_pParentFile;

    //
    // Buffer pointer
    //

    PBYTE m_pbBuffer;

    //
    // Buffer size
    //

    DWORD m_cbBuffer;

    //
    // Starting offset that we have buffered
    //

    DWORD m_iStart;

    //
    // Ending offset that we have buffered
    //

    DWORD m_iEnd;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\admex\interfac\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    DLL startup routine.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>

}   // extern "C"

#include <admex.h>


//
// Private globals.
//

//DECLARE_DEBUG_PRINTS_OBJECT();


//
// Private prototypes.
//


//
// DLL Entrypoint.
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    BOOL status = TRUE;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH :
//        CREATE_DEBUG_PRINT_OBJECT( "admxprox" );
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH :
//        DELETE_DEBUG_PRINT_OBJECT();
        break;

    }

    return status;

}   // DLLEntry

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\synconst.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

        synconst.h

Abstract:

        This module contains the definition of some of the definitions for
		synchronization

Author:

        Keith Lau       (keithlau@microsoft.com)

Revision History:

        keithlau        03/02/98        created

--*/

#ifndef __SYNCONST_H__
#define __SYNCONST_H__

// Lock ranks
extern int		rankBlockMgr;
extern int		rankRecipientHash;
extern int		rankLoggingPropertyBag;

// Instance names
extern TCHAR 			*szBlockMgr;
extern TCHAR			*szRecipientHash;
extern TCHAR			*szLoggingPropertyBag;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\admex\interfac\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = admex
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc /I ..\..\metadata\interfac -DREGISTER_PROXY_DLL


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I..\..\..\inc

CLIENT_STUB     = $(O)\$(IDL_FILE_NAME)_i.c
SERVER_STUB     = $(O)\$(IDL_FILE_NAME)_p.c
DLL_STUB        = $(O)\dlldata.c
HEADER_FILE     = ..\..\..\inc\$(O)\$(IDL_FILE_NAME).h

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

DLL_TARGETS     = $(DLL_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(DLL_TARGETS)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES) -DMIDL_PASS

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc

delsrc:
        -erase $(TARGETS) $(BASEDIR)\public\sdk\inc\$(IDL_FILE_NAME).h

obj\$(TARGETCPU)\admexxp.obj: admex_p.c

#
#  MIDL Compile stuff
#
$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS) $(DLL_TARGETS) :  .\$(IDL_FILE_NAME).idl
    midl -Oi -no_stamp -error allocation -error ref -h $(HEADER_FILE) -iid $(CLIENT_STUB) -proxy $(SERVER_STUB) -dlldata $(DLL_STUB) $(IDL_FLAGS) $(CPP) .\$(IDL_FILE_NAME).idl  $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\export\thrdpl2.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpl2.h
//
//  Contents:    definitions needed for clients of the thrdpool2 lib
//
//	Description: The thrdpool library defines the CThreadPool base class.
//				 Users of this lib should define their own derived class
//				 that inherits from CThreadPool. A CThreadPool object
//				 has a set of threads that is used to do some work. It also
//				 has a common completion port that is used to queue work items.
//               All worker threads will normally block on 
//               GetQueuedCompletionStatus(). Clients of the CThreadPool 
//				 object will call PostWork() to get work done. This will
//				 result in one of the worker threads returning from 
//				 GetQueuedCompletionStatus() and calling the derived class'
//				 WorkCompletion() routine with a pvContext.
//
//               CThreadPool provides the following features:
//               -  creation with an initial number of threads
//               -  deletion
//               -  ability to submit work items
//               -  grow pool of threads
//               -  shrink pool of threads
//
//				 NOTE: the base class has no knowledge of the type of work
//				 getting done. It just manages the details of getting work
//				 requests and distributing it to threads in its pool. This 
//				 allows the derived class to focus on processing the actual
//				 work item without bothering about queueing etc.
//
//				 Completion ports are used merely to leverage its queueing
//				 semantics and not for I/O. If the work done by each thread
//				 is fairly small, LIFO semantics of completion ports will 
//				 reduce context switches.
//
//  Functions:  
//
//  History:     09/18/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------

#ifndef THRDPL2_H
#define THRDPL2_H

//
//	Base thread pool class
//
class CThreadPool
{
public:
	//
	//	Constructor, destructor
	//
	CThreadPool();
	virtual ~CThreadPool();

	//
	//	creates the required number of worker threads and completion port
	//
	BOOL Initialize( DWORD dwConcurrency, DWORD dwMaxThreads, DWORD dwInitThreads );

	//
	//	shutdown the thread pool
	//
	BOOL Terminate( BOOL fFailedInit = FALSE, BOOL fShrinkPool = TRUE );

	//
	//	clients should call this to post work items
	//
	BOOL 						PostWork(PVOID pvWorkContext);

	//
	//	expose shutdown event
	//
	HANDLE QueryShutdownEvent() { return m_hShutdownEvent; }

    //
    //  A job represents a series of PostWork() items
    //
    VOID  BeginJob( PVOID pvContext );

    //
    //  Wait for job to complete ie all PostWork() items are done
    //
    DWORD  WaitForJob( DWORD dwTimeout );

    //
    //  Job context is used to process all work items in a job
    //
    PVOID  QueryJobContext() { return m_pvContext; }

    //
    //  shrink pool by dwNumThreads
    //
    BOOL ShrinkPool( DWORD dwNumThreads );

    //
    //  grow pool by dwNumThreads
    //
    BOOL GrowPool( DWORD dwNumThreads );

    //
    // Shrink all the existing threads
    //
    VOID ShrinkAll();

protected:

	//
	//	derived method called when work items are posted
	//
	virtual VOID 				WorkCompletion(PVOID pvWorkContext) = 0;

	//
	//  For those who has knowledge about automatic shutdown of the thread
	//  pool, this function is used as an interface for implementing 
	//  shutting down the thread pool for itself.  The function is called
	//  when the last thread in the pool goes away because of shutdown
	//  event has been fired.  
	//
	//  The reason for this interface is: in some scenarios the shutting
	//  down thread is from the same thread pool and it will cause deadlock.
	//  Users of thread pool who expects this will happen should not call
	//  WaitForJob, and should call Terminate and delete in this call back.
	//
	virtual VOID                AutoShutdown() {
        // 
        // People who doesn't care about this function does a no-op 
        //
    };
    
private:

	friend DWORD __stdcall 		ThreadDispatcher(PVOID pvWorkerThread);

	//
	//	check for matching Init(), Term() calls
	//
	LONG				        m_lInitCount;

	//
	//	handle to completion port
	//
	HANDLE				        m_hCompletionPort;

	//
	//	shutdown event
	//
	HANDLE						m_hShutdownEvent;

    //
    //  array of worker thread handles
    //
    HANDLE*                     m_rgThrdpool;

    //
    //  array of thread id's. BUGBUG: may be able to get rid of this if
    //  we have per thread handle
    //
    DWORD*                      m_rgdwThreadId;

    //
    //  number of worker threads
    //
    DWORD                       m_dwNumThreads;

    //
    //  max number of worker threads
    //
    DWORD                       m_dwMaxThreads;

    //
    //  count work items in current job
    //
    LONG                        m_lWorkItems;

    //
    //  event used to sync job completion
    //
    HANDLE                      m_hJobDone;

    //
    //  context for current job
    //
    PVOID                       m_pvContext;

    //
    //  crit sect to protect incs/decs to m_lWorkItems
    //
    CRITICAL_SECTION            m_csCritItems;

    //
    //  access completion port - needed by worker threads
    //
	HANDLE QueryCompletionPort() { return m_hCompletionPort; }

	//
	//	thread function
	//
	static DWORD __stdcall 		ThreadDispatcher(PVOID pvWorkerThread);
};

#endif		// #ifndef THRDPL2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\admex\cmdline\admext.cxx ===
#define INITGUID
#include    <windows.h>
#include    <stdio.h>
#include    <ole2.h>
#define USE_CAPI2
#if defined(USE_CAPI2)
#include    <wincrypt.h>
#endif
#include    "admex.h"

//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

#define PAD4(a) (((a)+3)&~3)

VOID
DisplayErrorMessage(
    DWORD   dwErr,
    DWORD   dwMsg = 0
    );

/////////////////////////////////////////////////////

VOID
DisplayErrorMessage(
    DWORD   dwErr,
    DWORD   dwMsg
    )
{
    LPSTR   pErr;
    CHAR    achMsg[2048];

    if ( dwMsg != 0 )
    {
        if ( LoadString( NULL, dwMsg, achMsg, sizeof(achMsg) ) )
        {
            printf( achMsg );
        }
    }

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPSTR)&pErr,
            0,
            NULL ) )
    {
        puts( pErr );

        LocalFree( pErr );
    }
}


VOID
Dump(
    LPSTR   pszMsg,
    LPBYTE  pb,
    DWORD   dw
    )
{
    printf( "%s size is %d\n", pszMsg, dw );

    for ( UINT x = 0 ; x < dw ; ++x )
    {
        printf( "%02x ", pb[x] );
    }

    if ( dw )
    {
        printf( "\n" );
    }
}


int __cdecl main( int argc, char*argv[] )
{
    IMSAdminReplication*        pIf;
    IMSAdminCryptoCapabilities* pIfS;
    IClassFactory*              pcsfFactory = NULL;
    int                         iA;
    HRESULT                     hRes;
    COSERVERINFO                csiMachineName;
    WCHAR                       awchComputer[64];
    BYTE                        abBuf[32768];
    DWORD                       dwReqSize;
    MULTI_QI                    rgmq;
    LPSTR                       pszMachineName = NULL;
    int                         arg;
    BOOL                        fDoTest = FALSE;
    HKEY                        hKey;
    CHAR                        achName[128];
    DWORD                       dwNameLen;
    DWORD                       dwValueLen;
    DWORD                       dwType;
    int                         iV, iV2;
    LPBYTE                      pbSerial;
    DWORD                       dwSerialLen, dwSerialLen2;
    DWORD                       dwErr;

    for ( arg = 1 ; arg < argc ; ++arg )
    {
        if ( argv[arg][0] == '-' )
        {
            switch ( argv[arg][1] )
            {
                case 'm':
                    pszMachineName = argv[arg]+2;
                    break;

                case 't':
                    fDoTest = TRUE;
                    break;
            }
        } 
    }

    if ( argc < 1 )
    {
        CHAR    achMsg[2048];

        if ( LoadString( NULL, 100, achMsg, sizeof(achMsg) ) )
        {
            printf( achMsg );
        }
        return 3;
    }

    //fill the structure for CoCreateInstanceEx
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;

    if ( pszMachineName )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszMachineName,
                                   -1,
                                   awchComputer,
                                   sizeof(awchComputer) ) )
        {
            return FALSE;
        }

        csiMachineName.pwszName =  awchComputer;
    }
    else
    {
        csiMachineName.pwszName =  NULL;
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( fDoTest )
    {
        hRes = CoGetClassObject(CLSID_MSCryptoAdmEx, CLSCTX_SERVER, &csiMachineName,
                                IID_IClassFactory, (void**) &pcsfFactory);
        if ( SUCCEEDED( hRes ) )
        {
            hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminReplication, (void **) &rgmq.pItf);
            if ( SUCCEEDED( hRes ) )
            {
                rgmq.pItf->Release();
            }
            else
            {
                DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
            }
            pcsfFactory->Release();
        }
        else
        {
            DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
        }

        //
        // call replication I/F
        //

        rgmq.pIID = &IID_IMSAdminReplication;
        rgmq.pItf = NULL;
        rgmq.hr = 0;

        if ( SUCCEEDED( hRes = CoCreateInstanceEx( CLSID_MSCryptoAdmEx,
                                                   NULL,
                                                   CLSCTX_SERVER,
                                                   &csiMachineName,
                                                   1,
                                                   &rgmq ) ) &&
             SUCCEEDED( hRes = rgmq.hr ) )
        {
            pIf = (IMSAdminReplication*)rgmq.pItf;

            hRes = pIf->GetSignature( sizeof(abBuf), abBuf, &dwReqSize );
            if ( SUCCEEDED( hRes ) )
            {
                Dump( "GetSignature:", abBuf, dwReqSize );

                hRes = pIf->Serialize( sizeof(abBuf), abBuf, &dwReqSize );
            }

            if ( SUCCEEDED( hRes ) )
            {
                Dump( "Serialize:", abBuf, dwReqSize );

                hRes = pIf->DeSerialize( dwReqSize, abBuf );
            }

            pIf->Release();

            if ( FAILED( hRes ) )
            {
                DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
            }
        }
        else
        {
            DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
        }

        //
        // call crypto capabilities I/F
        //

        rgmq.pIID = &IID_IMSAdminCryptoCapabilities;
        rgmq.pItf = NULL;
        rgmq.hr = 0;

        if ( SUCCEEDED( hRes = CoCreateInstanceEx( CLSID_MSCryptoAdmEx,
                                                   NULL,
                                                   CLSCTX_SERVER,
                                                   &csiMachineName,
                                                   1,
                                                   &rgmq ) ) &&
             SUCCEEDED( hRes = rgmq.hr ) )
        {
            pIfS = (IMSAdminCryptoCapabilities*)rgmq.pItf;

            hRes = pIfS->GetProtocols( sizeof(abBuf), abBuf, &dwReqSize );

            if ( SUCCEEDED(hRes) )
            {
                Dump( "Protocols:", abBuf, dwReqSize );

                hRes = pIfS->GetSupportedAlgs( sizeof(abBuf), (LPDWORD)abBuf, &dwReqSize );
            }

            if ( SUCCEEDED(hRes) )
            {
                Dump( "Algs:", abBuf, dwReqSize );

                hRes = pIfS->GetRootCertificates( sizeof(abBuf), abBuf, &dwReqSize );
            }

            if ( SUCCEEDED(hRes) )
            {
                Dump( "CAs:", abBuf, dwReqSize );

                hRes = pIfS->GetMaximumCipherStrength( &dwReqSize );
            }

            if ( SUCCEEDED(hRes) )
            {
                Dump( "Cipher strength:", (LPBYTE)&dwReqSize, sizeof(DWORD) );
            }

            pIfS->Release();

            if ( FAILED( hRes ) )
            {
                DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
            }
        }
        else
        {
            DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
        }
    }
    else
    {
        //
        // Check full access to registry ( granted only to administrators )
        //

        if ( (dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           "SYSTEM\\CurrentControlSet\\Services\\InetInfo\\Parameters",
                           0,
                           KEY_ALL_ACCESS,
                           &hKey )) == ERROR_SUCCESS )
        {
            RegCloseKey( hKey );
        }
        else
        {
            hRes = RETURNCODETOHRESULT( dwErr );
        }

        if ( SUCCEEDED( hRes ) )
        {
            hRes = CoGetClassObject(CLSID_MSCryptoAdmEx, CLSCTX_SERVER, &csiMachineName,
                                    IID_IClassFactory, (void**) &pcsfFactory);
        }

        if ( SUCCEEDED( hRes ) )
        {
            hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminCryptoCapabilities, (void **) &pIfS);
            if ( FAILED( hRes ) )
            {
                DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
            }
            else
            {
                //
                // get CA list
                //

#if defined(USE_CAPI2)

                HCERTSTORE  hStore = NULL;
                BOOL fReturn = FALSE;
                PCCERT_CONTEXT  pCtx;

                hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                    0,
                    NULL,
                    CERT_SYSTEM_STORE_CURRENT_USER,
                    "ROOT" );

                if ( hStore )
                {
                    for ( pCtx = NULL, dwSerialLen = 0 ;
                          pCtx = CertEnumCertificatesInStore(  hStore, pCtx ) ; )
                    {
                        // CertDeleteCertificateFromStore, CertAddSerializedElementToStore
                        dwValueLen = sizeof(abBuf);
                        if ( CertSerializeCertificateStoreElement( pCtx, 0, NULL, &dwValueLen ) )
                        {
                            dwSerialLen += sizeof(DWORD) + PAD4(dwValueLen);
                        }
                        else
                        {
                            hRes = RETURNCODETOHRESULT( GetLastError() );
                            break;
                        }
                    }
                }
                else
                {
                    hRes = RETURNCODETOHRESULT( GetLastError() );
                }

                if ( SUCCEEDED( hRes ) )
                {
                    if ( pbSerial = (LPBYTE)LocalAlloc( LMEM_FIXED, dwSerialLen ) )
                    {
                        for ( pCtx = NULL, dwSerialLen2 = 0 ;
                              pCtx = CertEnumCertificatesInStore(  hStore, pCtx ) ; )
                        {
                            dwValueLen = dwSerialLen - dwSerialLen2 - sizeof(DWORD);
                            if ( CertSerializeCertificateStoreElement( pCtx, 0, pbSerial + dwSerialLen2 + sizeof(DWORD), &dwValueLen ) )
                            {
                                *(LPDWORD)(pbSerial+dwSerialLen2) = dwValueLen;
                                dwSerialLen2 += sizeof(DWORD) + PAD4(dwValueLen);
                            }
                            else
                            {
                                hRes = RETURNCODETOHRESULT( GetLastError() );
                                break;
                            }
                        }

                        if ( SUCCEEDED( hRes ) )
                        {
                            //
                            // call deserialize. This will be invoked in IIS SYSTEM context
                            //

                            hRes = pIfS->SetCAList( dwSerialLen2, pbSerial );
                        }

                        LocalFree( pbSerial );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                    }
                }

                if ( hStore )
                {
                    CertCloseStore( hStore, CERT_CLOSE_STORE_FORCE_FLAG );
                }

#else

                if ( (dwErr = RegOpenKeyEx( HKEY_CURRENT_USER,
                                   "Software\\Microsoft\\SystemCertificates\\ROOT\\Certificates",
                                   0,
                                   KEY_READ,
                                   &hKey )) == ERROR_SUCCESS )
                {
                    //
                    // compute length of serialized CA list
                    //

                    for ( iV = 0, dwSerialLen = 0 ; ; ++iV )
                    {
                        dwNameLen = sizeof( achName );
                        dwValueLen = sizeof(abBuf);
                        if ( RegEnumValue( hKey,
                                           iV,
                                           achName,
                                           &dwNameLen,
                                           NULL,
                                           &dwType,
                                           abBuf,
                                           &dwValueLen ) != ERROR_SUCCESS )
                        {
                            break;
                        }
                        ++dwNameLen;
                        dwSerialLen += sizeof(DWORD) + PAD4(dwNameLen) + sizeof(DWORD) + PAD4(dwValueLen);
                    }

                    if ( pbSerial = (LPBYTE)LocalAlloc( LMEM_FIXED, dwSerialLen ) )
                    {
                        //
                        // build serialized list
                        //

                        for ( iV2 = 0, dwSerialLen2 = 0 ;; ++iV2 )
                        {
                            dwNameLen = sizeof( achName );
                            dwValueLen = sizeof(abBuf);
                            if ( RegEnumValue( hKey,
                                               iV2,
                                               achName,
                                               &dwNameLen,
                                               NULL,
                                               &dwType,
                                               abBuf,
                                               &dwValueLen ) != ERROR_SUCCESS )
                            {
                                break;
                            }
                            ++dwNameLen;

                            if ( iV2 == iV || 
                                 dwSerialLen2 + sizeof(DWORD) + PAD4(dwNameLen) + sizeof(DWORD) + PAD4(dwValueLen) > dwSerialLen )
                            {
                                hRes = E_OUTOFMEMORY;
                                break;
                            }

                            // each element ( name or content ) is stored prefixed by
                            // a DWORD length. element actual storage is padded
                            // so that length is multiple of 4, to make sure following
                            // DWORDs are DWORD aligned.

                            // store value name ( includes zero byte delimiter )

                            *(LPDWORD)(pbSerial+dwSerialLen2) = dwNameLen;
                            dwSerialLen2 += sizeof(DWORD);
                            memcpy( pbSerial+dwSerialLen2, achName, dwNameLen );
                            dwSerialLen2 += PAD4(dwNameLen);

                            // store value content

                            *(LPDWORD)(pbSerial+dwSerialLen2) = dwValueLen;
                            dwSerialLen2 += sizeof(DWORD);
                            memcpy( pbSerial+dwSerialLen2, abBuf, dwValueLen );
                            dwSerialLen2 += PAD4(dwValueLen);
                        }

                        if ( SUCCEEDED( hRes ) )
                        {
                            //
                            // call deserialize. This will be invoked in IIS SYSTEM context
                            //

                            hRes = pIfS->SetCAList( dwSerialLen2, pbSerial );
                        }

                        LocalFree( pbSerial );
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                    }

                    RegCloseKey( hKey );
                }
                else
                {
                    hRes = RETURNCODETOHRESULT( dwErr );
                }

#endif
                if ( FAILED(hRes) )
                {
                    DisplayErrorMessage( HRESULTTOWIN32( hRes ), 102 );
                }
                else
                {
                    CHAR    achMsg[2048];

                    if ( LoadString( NULL, 101, achMsg, sizeof(achMsg) ) )
                    {
                        printf( achMsg );
                    }
                }

                pIfS->Release();
            }
            pcsfFactory->Release();
        }
        else
        {
            DisplayErrorMessage( HRESULTTOWIN32( hRes ), 102 );
        }

    }

    CoUninitialize();

    return SUCCEEDED(hRes) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\admex\secex\loadadm.cxx ===
// %%Includes: ---------------------------------------------------------------
#define INITGUID
#define INC_OLE2
#define STRICT
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#define SECURITY_WIN32
#include <sspi.h>

#include <admex.h>
#include "comobj.hxx"
#include "bootimp.hxx"

DECLARE_PLATFORM_TYPE();

DWORD   g_dwComRegister;
DWORD   g_bInitialized = FALSE;

// ---------------------------------------------------------------------------
// %%Function: main
// ---------------------------------------------------------------------------

BOOL
InitComAdmindata(BOOL bRunAsExe)
{

    HRESULT hr;
    BOOL bReturn = TRUE;

    //
    // if win95, then don't register as service
    //

    INITIALIZE_PLATFORM_TYPE();

    if ( IISGetPlatformType() == PtWindows95 ) {

        DBG_ASSERT(bRunAsExe);
        DBGPRINTF((DBG_CONTEXT,
            "[InitComAdminData] Win95 - not registering as exe\n"));

        bRunAsExe = FALSE;
    }

    {
        CADMEXCOMSrvFactory   *pADMClassFactory = new CADMEXCOMSrvFactory;

        if ( pADMClassFactory == NULL ) {
            DBGERROR((DBG_CONTEXT, "[InitComAdmindata] CADMEXCOMSrvFactory failed, error %lx\n",
                      GetLastError() ));
            bReturn = FALSE;
        }
        else {
            // register the class-object with OLE
            hr = CoRegisterClassObject(CLSID_MSCryptoAdmEx, pADMClassFactory,
                CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &g_dwComRegister);
            if (FAILED(hr)) {
                DBGERROR((DBG_CONTEXT, "[InitComAdmindata] CoRegisterClassObject failed, error %lx\n",
                          GetLastError() ));
                bReturn = FALSE;
                delete pADMClassFactory;
            }
        }
    }
    g_bInitialized = bReturn;

    if ( bReturn ) {
        DBGPRINTF((DBG_CONTEXT, "[InitComAdmindata] success, bRunAsExe=%d\n", bRunAsExe ));
    }

    return bReturn;

}  // main


BOOL
TerminateComAdmindata()
{

    DBGPRINTF((DBG_CONTEXT, "[TerminateComAdmindata]\n" ));

    if (g_bInitialized) {
        g_bInitialized = FALSE;
        (VOID)CoRevokeClassObject(g_dwComRegister);
    }

    return TRUE;
}

// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\accslib.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    accslib.h

Abstract:

    Proto type definitions for access product lib functions.

Author:

    Madan Appiah (madana) 11-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _ACCSLIB_
#define _ACCSLIB_

#ifdef __cplusplus
extern "C" {
#endif

PVOID
MIDL_user_allocate(
    size_t Size
    );

VOID
MIDL_user_free(
    PVOID MemoryPtr
    );

#ifdef __cplusplus
}
#endif

#endif  // _ACCSLIB_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\admex\secex\cofact.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#define SECURITY_WIN32
#include <sspi.h>

#include <admex.h>
#include "comobj.hxx"
#include "bootimp.hxx"
#include <stdio.h>

extern ULONG g_dwRefCount;

CAdmExtSrvFactory g_aesFactory;


CADMEXCOMSrvFactory::CADMEXCOMSrvFactory()
{
    m_dwRefCount=0;
}


CADMEXCOMSrvFactory::~CADMEXCOMSrvFactory()
{
}


HRESULT
CADMEXCOMSrvFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void ** ppObject
    )
{
    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactory::CreateInstance]\n"));

    HRESULT hresReturn = E_NOINTERFACE;

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    if ( IID_IUnknown==riid || 
         IID_IMSAdminReplication==riid || 
         IID_IMSAdminCryptoCapabilities==riid ) 
    {
        CADMEXCOM *padmcom = new CADMEXCOM();

        if( padmcom == NULL ) 
        {
            hresReturn = E_OUTOFMEMORY;
        }
        else 
        {
            hresReturn = padmcom->QueryInterface(riid, ppObject);

            if( FAILED(hresReturn) ) 
            {
                DBGPRINTF( (DBG_CONTEXT, "[CADMEXCOMSrvFactory::CreateInstance] no I/F\n"));
                delete padmcom;
            }
        }
    }

    return hresReturn;
}


HRESULT
CADMEXCOMSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}


HRESULT
CADMEXCOMSrvFactory::QueryInterface(
    REFIID riid,
    void **ppObject
    )
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}


ULONG
CADMEXCOMSrvFactory::AddRef(
    )
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}


ULONG
CADMEXCOMSrvFactory::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}



STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppObject)
{
    if ( rclsid == CLSID_MSCryptoAdmEx ) {
        CADMEXCOMSrvFactory *pFactory = new CADMEXCOMSrvFactory;
        if (FAILED(pFactory->QueryInterface(riid, ppObject))) {
            delete pFactory;
            *ppObject = NULL;
            DBGPRINTF( (DBG_CONTEXT, "[CADMEXCOMSrvFactory::DllGetClassObject] no I/F for CLSID_MSCryptoAdmEx\n" ) );
            return E_INVALIDARG;
        }
        return NO_ERROR;
    }
    else if ( rclsid == CLSID_ADMEXT) {
        if (FAILED(g_aesFactory.QueryInterface(riid, ppObject))) {
            *ppObject = NULL;
            DBGPRINTF( (DBG_CONTEXT, "[CADMEXCOMSrvFactory::DllGetClassObject] no I/F for CLSID_ADMEXT\n" ) );
            return E_INVALIDARG;
        }
        return NO_ERROR;
    }
    else {
        DBGPRINTF( (DBG_CONTEXT, "[CADMEXCOMSrvFactory::DllGetClassObject] bad class\n" ) );
        return CLASS_E_CLASSNOTAVAILABLE;
    }
}


HRESULT _stdcall DllCanUnloadNow(
    )
{
   if (g_dwRefCount) {
        return S_FALSE;
    }
    else {
        return S_OK;
    }
}


STDAPI DllRegisterServer(
    )
{
    HKEY hKeyCLSID, hKeyInproc32;
    HKEY hKeyIF, hKeyStub32;
    HKEY hKeyAppExe, hKeyAppID, hKeyTemp;
    DWORD dwDisposition;
    BOOL bIsWin95 = FALSE;
    char pszName[MAX_PATH+1 + sizeof("inetinfo.exe -e iisadmin")];


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        bIsWin95 = TRUE;
    }

    //
    // register AppExe
    //

    HRESULT hr;


    if (bIsWin95) {

        HMODULE hModule=GetModuleHandle(TEXT("ADMEXS.DLL"));
        if (!hModule) {
                return E_UNEXPECTED;
                }

        WCHAR wchName[MAX_PATH + 1];
        if (GetModuleFileName(hModule, pszName, sizeof(pszName))==0) {
                return E_UNEXPECTED;
                }

        int i;

        //
        // Set pszName to the command to start the web server
        //

        for (i = strlen(pszName) -1; (i >= 0) && (pszName[i] != '/') & (pszName[i] != '\\'); i--) {
        }

        pszName[i + 1] = '\0';
        strcat(pszName, "inetinfo.exe -e iisadmin");
    }

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{9f0bd3a0-ec01-11d0-a6a0-00a0c922e752}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Crypto Extension"), sizeof(TEXT("IIS Admin Crypto Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT("AppID"), NULL, REG_SZ, (BYTE*) TEXT("{9f0bd3a0-ec01-11d0-a6a0-00a0c922e752}"), sizeof(TEXT("{9f0bd3a0-ec01-11d0-a6a0-00a0c922e752}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (bIsWin95) {
        if (RegCreateKeyEx(hKeyCLSID,
                           TEXT("LocalServer32"),
                           NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                            &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
        if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) pszName, strlen(pszName) + 1)!=ERROR_SUCCESS) {
                    RegCloseKey(hKeyTemp);
                    RegCloseKey(hKeyCLSID);
                    return E_UNEXPECTED;
                    }
        RegCloseKey(hKeyTemp);
    }
    else {
        if (RegSetValueEx(hKeyCLSID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT("IISADMIN"), sizeof(TEXT("IISADMIN")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
    }

    RegCloseKey(hKeyCLSID);


    //
    // AppID
    //
    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("AppID\\{9f0bd3a0-ec01-11d0-a6a0-00a0c922e752}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("IIS Admin Crypto Extension"), sizeof(TEXT("IIS Admin Crypto Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (bIsWin95) {
        if (RegCreateKeyEx(hKeyCLSID,
                           TEXT("LocalServer32"),
                           NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                            &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
        if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ, (BYTE*) pszName, strlen(pszName) + 1)!=ERROR_SUCCESS) {
                    RegCloseKey(hKeyTemp);
                    RegCloseKey(hKeyCLSID);
                    return E_UNEXPECTED;
                    }
        RegCloseKey(hKeyTemp);
    }
    else {
        if (RegSetValueEx(hKeyCLSID, TEXT("LocalService"), NULL, REG_SZ, (BYTE*) TEXT("IISADMIN"), sizeof(TEXT("IISADMIN")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
        }
    }

    RegCloseKey(hKeyCLSID);

    //
    // Main Interfaces
    //

    //
    // ANSI Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{c804d980-ebec-11d0-a6a0-00a0c922e752}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("PSFactoryBuffer"), sizeof(TEXT("PSFactoryBuffer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "ADMXPROX.DLL", sizeof(TEXT("ADMPROX.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // Crypto Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{78b64540-f26d-11d0-a6a3-00a0c922e752}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("PSFactoryBuffer"), sizeof(TEXT("PSFactoryBuffer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       "InprocServer32",
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) "ADMXPROX.DLL", sizeof(TEXT("ADMPROX.DLL")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // register Interfaces
    //

    //
    // ANSI Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{c804d980-ebec-11d0-a6a0-00a0c922e752}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("ADMEX"), sizeof(TEXT("ADMEX")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{c804d980-ebec-11d0-a6a0-00a0c922e752}", sizeof("{CBA424F0-483A-11D0-9D2A-00A0C922E703}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    //
    // Crypto Main Interface
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{78b64540-f26d-11d0-a6a3-00a0c922e752}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("ADMEX"), sizeof(TEXT("ADMEX")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{78b64540-f26d-11d0-a6a3-00a0c922e752}", sizeof("{78b64540-f26d-11d0-a6a3-00a0c922e752}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    return BootDllRegisterServer();;
}

STDAPI DllUnregisterServer(void) {

    BOOL bIsWin95 = FALSE;


    //
    // if win95, then don't register as service
    //

    if ( IISGetPlatformType() == PtWindows95 ) {

        bIsWin95 = TRUE;
    }

    //
    // register AppID
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("AppID\\{9f0bd3a0-ec01-11d0-a6a0-00a0c922e752}"));

    //
    // register CLSID
    //

    if (bIsWin95) {
        RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9f0bd3a0-ec01-11d0-a6a0-00a0c922e752}\\LocalServer32"));
    }

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9f0bd3a0-ec01-11d0-a6a0-00a0c922e752}"));

    //
    // Main Interfaces
    //

    //
    // Crypto Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{78b64540-f26d-11d0-a6a3-00a0c922e752}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{78b64540-f26d-11d0-a6a3-00a0c922e752}"));

    //
    // Replication Interface
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c804d980-ebec-11d0-a6a0-00a0c922e752}\\InprocServer32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c804d980-ebec-11d0-a6a0-00a0c922e752}"));

    //
    // deregister Interfaces
    //

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{78b64540-f26d-11d0-a6a3-00a0c922e752}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{78b64540-f26d-11d0-a6a3-00a0c922e752}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{c804d980-ebec-11d0-a6a0-00a0c922e752}\\ProxyStubClsid32"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Interface\\{c804d980-ebec-11d0-a6a0-00a0c922e752}"));

    return BootDllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\admex\secex\comobj.cxx ===
/*++



   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       comobj.cxx

   Abstract:

       This module defines DCOM Admin Ex APIs used for certificate information replication.

   Author:

       Philippe Choquier ( Phillich ) 23-Jun-97
       Alex Mallet (amallet) 17-Feb-1998 

--*/

#define UNICODE 

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
#define USE_CAPI2
#if defined(USE_CAPI2)
#include <wincrypt.h>
#endif

extern "C" {
#define SECURITY_WIN32
#include <sspi.h>
}
#include <spseal.h>
#include <issperr.h>
#include <schnlsp.h>
#include <md5.h>

#include <iadmw.h>
#include <admex.h>
#include <iiscnfgp.h>
#include <mdcommsg.h>
#include <replseed.hxx>
#include <iis64.h>

#include "comobj.hxx"

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

#define PAD4(a) (((a)+3)&~3)

#define MSB(a) (BYTE) (((a) & 0xFF00) >> 8)
#define LSB(a) (BYTE) ((a) & 0xFF)
#define LENGTH( msb, lsb ) (DWORD) ( (msb << 8) + lsb )
//
// Globals
//

DECLARE_DEBUG_PRINTS_OBJECT();
ULONG g_dwRefCount = 0;

#include <initguid.h>
DEFINE_GUID(IisADMExsGuid, 
0x784d8905, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

CADMEXCOM::CADMEXCOM()
{
    m_dwRefCount = 0;
    m_pIMSAdminReplication = new CADMEXCOM_IMSAdminReplication(this);
    m_pIMSAdminCryptoCapabilities = new CADMEXCOM_IMSAdminCryptoCapabilities( this );
}


CADMEXCOM::~CADMEXCOM()
{
    if ( m_pIMSAdminReplication )
    {
        delete m_pIMSAdminReplication;
    }

    if ( m_pIMSAdminCryptoCapabilities )
    {
        delete m_pIMSAdminCryptoCapabilities;
    }
}


HRESULT
CADMEXCOM::QueryInterface(
    REFIID riid,
    void **ppObject)
{
    if (riid==IID_IUnknown ) {
        *ppObject = (IUnknown *) this;
        AddRef();
    }
    else if ( riid==IID_IMSAdminReplication) {
        *ppObject = (IMSAdminReplication *)m_pIMSAdminReplication;
        AddRef();
    }
    else if ( riid==IID_IMSAdminCryptoCapabilities) {
        *ppObject = (IMSAdminCryptoCapabilities *)m_pIMSAdminCryptoCapabilities;
        AddRef();
    }
    else {
        return E_NOINTERFACE;
    }

    return NO_ERROR;
}


ULONG
CADMEXCOM::AddRef(
    )
{
    DWORD dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}


ULONG
CADMEXCOM::Release(
    )
{
    DWORD dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

    if( dwRefCount == 0 ) {
        delete this;
        return 0;
    }

    return dwRefCount;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                       SSL Information Replication Interface 

  In order to determine whether information needs to be replicated between two machines,
  the GetSignature() method is called; this is expected to return a "signature" that can be
  compared with the "signature" on the other machine - if the signatures match, they
  have the same information, else replication needs to occur. 

  To replicate, the Serialize() method is called to serialize all the config information
  into a buffer; this buffer is encrypted with a generated session key [because it contains
  the private keys for all the server certificates]. The data to generate the session key
  is stored in the metabase, in encrypted format.

  Propagate() doesn't do anything.

  DeSerialize() on the target machine regenerates the session key out of the metabase, uses it
  to decrypt the buffer generated by Serialize() and creates server certificates and
  CTLs in the appropriate places.

  The actual configuration information in the metabase itself is replicated during
  the (separate) metabase replication process.

  Each server instance has the following SSL information associated with it that 
  needs to be replicated :

  1. Server certificate, server private key, cert chain for server certificate

  2. Certificate Trust List, signing cert for CTL
  

  GetSignature() : 
  ----------------
  Identifying info for server certificates :
  <hash of cert stored under LM/W3SVC>:(instance_cert_information)?
  where instance_cert_information =  <instance #>=<hash of leaf cert>,<hash of issuer 1>,
                                      <hash of issuer of issuer 1> .... |
  End of instance cert information is marked by "|"
  
  Identifying info for CTL :
  [CTL_INFO for CTL stored under /LM/W3SVC]:(<instance #>=CTL_INFO)?
  where CTL_INFO = <CTL list identifier>,(<hash of cert in ctl>)+,<hash of CTL signer>
  
  Signature : MD5(Info for server certificates : Info for CTLs)


-----------------------------------------------------------------------------------------------*/

#define MB_ROOT_PATH L"/LM/W3SVC"

#define TIMEOUT_VALUE 30000 //NOTE - magic number !
#define INITIAL_BUFFER_SIZE 2048

#define MY_STORE_NAME L"MY"
#define CA_STORE_NAME L"CA"
#define ROOT_STORE_NAME L"ROOT"
#define TRUST_STORE_NAME L"TRUST"

#define COLON ':'
#define INSTANCE_TRAILER_BYTE '|'

#define CERT_HEADER "CERTS="
#define CERT_HEADER_SIZE (sizeof(CERT_HEADER) - 1)
#define CTL_HEADER "CTL="
#define CTL_HEADER_SIZE (sizeof(CTL_HEADER) - 1)

#define SIGNATURE 0
#define CONFIGURATION 1

#define REPLICATION_SESSION_KEY_CONTAINER L"IIS Replication Session Key"

#define MIN_REPLICATION_INFO_SIZE 4 //> <MSB><LSB>":"<some info>"|"

#define REPL_INTERNAL_ERROR RETURNCODETOHRESULT( ERROR_INVALID_PARAMETER )


// Array holding properties required to reconstruct cert context
static DWORD adwMetabaseCertProperties[] = { MD_SSL_CERT_HASH, BINARY_METADATA,
                                             MD_SSL_CERT_STORE_NAME, STRING_METADATA };

#define cNumCertMetabaseProperties sizeof(adwMetabaseCertProperties)/sizeof(DWORD)

// Array holding properties necessary to reconstruct CTL context
static DWORD adwMetabaseCTLProperties[] = { MD_SSL_CTL_IDENTIFIER, BINARY_METADATA,
                                            MD_SSL_CTL_STORE_NAME, STRING_METADATA };

#define cNumCTLMetabaseProperties sizeof(adwMetabaseCTLProperties)/sizeof(DWORD)

#if DBG
VOID
Dump(
    CHAR    *pchMessage,
    LPBYTE  pb,
    DWORD   dw
    )
{
    for ( UINT x = 0 ; x < dw ; ++x )
    {
        sprintf(pchMessage + x*3, "%02x ", pb[x] );
    }

    sprintf(pchMessage + x*3,"\n");
}
#endif

CADMEXCOM_IMSAdminReplication::CADMEXCOM_IMSAdminReplication( CADMEXCOM *pAdmExCom ) :
m_pAdmExCom( pAdmExCom ),
m_pMB( NULL ),
m_fGotSeed( FALSE )
{
    HRESULT hRes;
    COSERVERINFO *pcsiParam = NULL;
    IClassFactory * pcsfFactory = NULL;

    //
    // Retrieve class factory for metabase object
    //
    hRes = CoGetClassObject(CLSID_MSAdminBase_W, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, ( void ** ) &pcsfFactory );

    if ( FAILED(hRes) )
    {
        DBGPRINTF((DBG_CONTEXT, "CoGetClassObject failed : hRes : %x, Win32 : 0x%x\n",
                   hRes, HRESULTTOWIN32(hRes)));
        return;
    }

    //
    // Retrieve the actual metabase object interface
    //
    hRes = pcsfFactory->CreateInstance( NULL,
                                        IID_IMSAdminBase,
                                        (void **) &m_pMB );

    if ( FAILED(hRes) )
    {
        DBGPRINTF((DBG_CONTEXT, "CreateInstance failed : hRes : %x, Win32 : 0x%x\n",
                   hRes, HRESULTTOWIN32(hRes)));
        return;
    }
    pcsfFactory->Release();
}



CADMEXCOM_IMSAdminReplication::~CADMEXCOM_IMSAdminReplication()
{
    if ( m_pMB )
    {
        m_pMB->Release();
        m_pMB = NULL;
    }
}

HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminReplication::GetSignature( 
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
/*++

Routine Description:

    Used to retrieve a "signature" for the certificate information to be retrieved; if the 
    signatures on two machines match, then it can be assumed that they have identical 
    SSL configurations.

Arguments:

    dwBufferSize - size of buffer passed in
    pbBuffer - buffer to be filled in with signature
    *pdwMDRequiredBufferSize - size of buffer required for data

Returns:

    HRESULT indicating success/failure.

--*/

{
    DBGPRINTF((DBG_CONTEXT,
               "GetSignature() called for SSL info replication\n"));

    HRESULT hRes = S_OK;
    hRes = GetConfigurationInformation( SIGNATURE,
                                        NULL,
                                        m_pMB,
                                        pbBuffer,
                                        dwBufferSize,
                                        pdwMDRequiredBufferSize );

#if DBG
    if ( FAILED( hRes ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "GetSignature() failed with Win32 error : 0x%x\n",
                   HRESULTTOWIN32( hRes )));
    }
    else
    {
        CHAR achSig[200];
        Dump( achSig, pbBuffer, *pdwMDRequiredBufferSize );
        DBGPRINTF((DBG_CONTEXT,
                   "GetSignature() returned %s\n",
                   achSig));
    }
#endif

    return hRes;
} //::GetSignature

HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminReplication::Serialize( 
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
/*++

Routine Description:

    Serializes the SSL information for IIS.

Arguments:

    dwBufferSize - size of buffer pointed to by pbBuffer
    pbBuffer - buffer to receive serialized SSL configuration; can be NULL if
    caller wants to determine size of buffer necessary 
    pdwMDRequiredBufferSize - pointer to size of buffer necessary to hold the
    information; updated if pbBuffer is too small to hold the information

Returns:

    HRESULT indicating success/failure.

--*/

{
    HRESULT hRes = S_OK;
    HCRYPTKEY hSessionKey = NULL;

    DBGPRINTF((DBG_CONTEXT,
               "Serialize() called for SSL info replication\n"));
    hRes = RegenerateSessionKey( m_pMB,
                                 &hSessionKey );
    if ( S_OK == hRes )
    {
        m_fGotSeed = TRUE;

        hRes = GetConfigurationInformation( CONFIGURATION,
                                            &hSessionKey,
                                            m_pMB,
                                            pbBuffer,
                                            dwBufferSize,
                                            pdwMDRequiredBufferSize );
        
#if DBG
        if ( FAILED( hRes ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Serialize() failed with Win32 error : 0x%x\n",
                       HRESULTTOWIN32( hRes )));
        }
#endif
    }

    return hRes;
} //::Serialize

HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminReplication::Propagate(
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer)
/*++

Routine Description:

   Propagates data necessary to re-generate session key from metabase on source machine
   to metabase on target machine

Arguments:

    dwBufferSize - size of buffer pointed to by pbBuffer
    pbBuffer - name of target machine

Returns:

    HRESULT indicating success/failure.

--*/

{
    DBGPRINTF((DBG_CONTEXT,
               "Propagate() called for SSL info replication\n"));

    if ( !m_fGotSeed )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }

}//::Propagate

HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminReplication::Propagate2(
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][in] */ unsigned char __RPC_FAR *pszBuffer,
    /* [in] */ DWORD dwSignatureMismatch )
{
    return S_OK;
}

        
HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminReplication::DeSerialize( 
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][in] */ unsigned char __RPC_FAR *pbBuffer)
/*++

Routine Description:

    Deserializes the SSL information produced by Serialize()

Arguments:

    dwBufferSize - size of buffer pointed to by pbBuffer
    pbBuffer - buffer holding serialized SSL configuration

Returns:

    HRESULT indicating success/failure.

Extended Description :

       The information for each instance is separate, with instance data being in the
       form 

       <Instance Data> = <MSB of instance #><LSB of instance #>":"<instance SSL info>"|"

       <Instance SSL Info> = <server certificate information><CTL information>

       <Server certificate information>  =  "" | 
       "CERTS="<SHA1 hash of first cert in chain><MSB of length of private key blob>
       <LSB of length of private key blob><private key blob of first cert>
       <MSB of length of serialized store containing chain><LSB of length of serialized store
       containing chain><serialized store>

        The SHA1 hash is added so that it's possible to figure out which cert in the store
        is the leaf cert when unserializing the buffer.

        <CTL information> = "" |
        "CTL="<hash of CTL signer><MSB of length of serialized store><LSB of length of serialized
        store><serialized store>

        The serialized store contains the CTL, the certs in the CTL and the signer of the CTL.
--*/
{
    HRESULT hRes = S_OK;
    BYTE *pbReplicationInfo = NULL;
    BYTE *pbPosition = NULL;
    BYTE *pbEnd = NULL;
    DWORD dwInstance = 0;
    HCRYPTKEY hSessionKey = NULL;

    DBGPRINTF((DBG_CONTEXT,
               "DeSerialize() called for SSL info replication\n"));

    //
    // No information to serialize
    //
    if ( dwBufferSize == 0 )
    {
        return S_OK;
    }

    //
    // Invalid buffer or buffer size 
    //
    if ( !pbBuffer  || dwBufferSize < MIN_REPLICATION_INFO_SIZE )
    {
        return REPL_INTERNAL_ERROR;
    }

    //
    // Extract the data for the session key under which the buffer is encrypted
    //

    hRes = RegenerateSessionKey( m_pMB, &hSessionKey );

    if ( hSessionKey )
    {
        //
        // Decrypt the buffer
        //
        hRes = DecryptBuffer( hSessionKey,
                              pbBuffer,
                              dwBufferSize,
                              &pbReplicationInfo,
                              &pbEnd );
        
        if( FAILED(hRes) )
        {
            DeleteSessionKey( &hSessionKey );
            hSessionKey = NULL;
        }
    }

    if( !hSessionKey )
    {
        //
        // Some of these functions return S_FALSE for some reason, 
        // preserve this behavior.
        //
        return (hRes != S_OK) ? hRes : E_FAIL;
    }
        
    //
    // Deserialize away
    //
    pbPosition = pbReplicationInfo;
    while ( pbPosition < pbEnd &&
            !FAILED( hRes = DeserializeInstanceInfo( &pbPosition,
                                                     pbEnd,
                                                     &dwInstance ) ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Successfully deserialized information for instance %d\n",
                   dwInstance));
    }

    if ( FAILED( hRes ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed deserializing information for instance %d\n",
                   dwInstance));
    }

    //
    // Cleanup
    //
    if ( pbReplicationInfo )
    {
        memset( pbReplicationInfo, 0, DIFF(pbEnd - pbReplicationInfo) );
        delete [] pbReplicationInfo;
    }

    DeleteSessionKey( &hSessionKey );

    //
    // Q : when should we delete the MB info ? Only on successful DeSerialize ?
    //
    if ( SUCCEEDED( hRes ) )
    {
        DeleteMBSessionKeyInfo( m_pMB );
    }

    return hRes;
}//::DeSerialize


HRESULT
GetConfigurationInformation( DWORD dwInfoType,
                             HCRYPTKEY *phSessionKey,
                             IMSAdminBase *pMB,
                             unsigned char __RPC_FAR *pbBuffer,
                             DWORD dwBufferSize,
                             DWORD __RPC_FAR *pdwMDRequiredBufferSize )
/*++

Routine Description:

    Used to retrieve replication information 

Arguments:

    dwInfoType - which kind of information to retrieve - signature or configuration
    phSessionKey - pointer to session key to be used to encrypt replication info; not
    used if dwInfoType == SIGNATURE
    pMB - pointer to metabase object
    pbBuffer - buffer to be filled in with information
    dwBufferSize - size of pbBuffer
    *pdwMDRequiredBufferSize - size of buffer required for data

Returns:

    HRESULT indicating success/failure.

--*/

{
    HRESULT hRes = S_OK;
    METADATA_HANDLE hMDHandle;
    DWORD dwObjectIndex = 0;
    TCHAR achMDName[METADATA_MAX_NAME_LEN];
    DWORD dwRepBufferSize = 0;
    PBYTE pbReplicationInfo = NULL;
    DWORD dwPosition = 0;
    BYTE *pbHashBuffer = NULL;
    DWORD cbHashSize = 0;

    if ( !pMB )
    {
        return S_FALSE;
    }

    //
    // Make sure we have a pointer to a session key if we need to use it
    //
    if ( dwInfoType != SIGNATURE && !phSessionKey )
    {
        return S_FALSE;
    }

    //
    // Signature is MD5 hash of information, so we know the buffer has to be at least
    // MD5_HASH_SIZE bytes in size
    //
    if ( dwInfoType == SIGNATURE )
    {
        if ( !pbBuffer || dwBufferSize < MD5_HASH_SIZE )
        {
            *pdwMDRequiredBufferSize = MD5_HASH_SIZE;
            return RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
        }
    }

    hRes = pMB->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         MB_ROOT_PATH,
                         METADATA_PERMISSION_READ,
                         TIMEOUT_VALUE,
                         &hMDHandle );

    if ( FAILED(hRes) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to open mb path"));
        return hRes;
    }

    //
    // Try to retrieve default information stored at /LM/W3SVC
    //
    
    //
    // Bogus report of null pointer dereference of pbReplicationInfo
    // Windows Bug - 117759
    //
    /* INTRINSA suppress=null_pointers */
    if ( FAILED( hRes = GetInstanceReplicationInfo( dwInfoType,
                                                    L"",
                                                    pMB,
                                                    hMDHandle,
                                                    &pbReplicationInfo,
                                                    &dwRepBufferSize,
                                                    &dwPosition ) ) )
    {
        if ( pbReplicationInfo )
        {
            delete [] pbReplicationInfo;
        }
        pMB->CloseKey( hMDHandle );
        return hRes;
    }


    //
    // Iterate through all the subkeys of /LM/W3SVC
    //
    HRESULT hRes2 = S_OK;
    while ( SUCCEEDED(hRes2 = pMB->EnumKeys( hMDHandle,
                                             L"",
                                             achMDName,
                                             dwObjectIndex) ) )
    {
        //
        // If the name of the subkey is a number, it's a server instance.
        // Construct cert and CTL information
        //
        if ( IsNumber( achMDName ) )
        {
            if ( FAILED( hRes = GetInstanceReplicationInfo( dwInfoType,
                                                            achMDName,
                                                            pMB,
                                                            hMDHandle,
                                                            &pbReplicationInfo,
                                                            &dwRepBufferSize,
                                                            &dwPosition ) ) )
            {
                if ( pbReplicationInfo )
                {
                    memset( pbReplicationInfo, 0, dwRepBufferSize );
                    delete [] pbReplicationInfo;
                }
                pMB->CloseKey( hMDHandle );
                return hRes;
            }
        }
        dwObjectIndex++;
    }

    //
    // Error while iterating over keys
    //
    if ( hRes2 != RETURNCODETOHRESULT( ERROR_NO_MORE_ITEMS ) )
    {
        if ( pbReplicationInfo )
        {
            memset( pbReplicationInfo, 0, dwRepBufferSize );
            delete [] pbReplicationInfo;
        }
        pMB->CloseKey( hMDHandle );

        return hRes2;
    }

    if ( dwInfoType == SIGNATURE )
    {
        //
        // We have a buffer containing all the information that needs to be converted
        // into a signature by applying the MD5 hash algorithm to it
        //
        if ( !FAILED( hRes = GenerateHash( NULL,
                                           CALG_MD5,
                                           pbReplicationInfo,
                                           dwPosition, 
                                           &pbHashBuffer,
                                           &cbHashSize,
                                           NULL ) ) )
        {
            DBG_ASSERT( cbHashSize == MD5_HASH_SIZE );

            memcpy( pbBuffer, pbHashBuffer, cbHashSize );

            *pdwMDRequiredBufferSize = cbHashSize;
        }
    }
    else
    {
        //
        // Because the cert information contains a private key, use the
        // session key to encrypt the replication buffer

        if ( !FAILED( hRes = EncryptBuffer( *phSessionKey,
                                            &pbReplicationInfo,
                                            &dwRepBufferSize,
                                            &dwPosition ) ) )
        {
            //
            // check that output buffer is big enough to hold the encrypted data
            //
            if ( dwBufferSize >= dwPosition )
            {
                memcpy( pbBuffer, pbReplicationInfo, dwPosition );
                *pdwMDRequiredBufferSize = dwPosition;
            }
            else
            {
                *pdwMDRequiredBufferSize = dwPosition;
                hRes = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
            }
        }
    }
                    
    if ( pbReplicationInfo )
    {
        //
        // zero it out, just to be paranoid
        //
        memset( pbReplicationInfo, 0, dwRepBufferSize );
        delete [] pbReplicationInfo;
    }

    if ( pbHashBuffer )
    {
        //
        // zero it out, just to be paranoid
        //
        memset( pbHashBuffer, 0, cbHashSize );
        delete [] pbHashBuffer;
    }

    pMB->CloseKey( hMDHandle );

    return hRes;
}

        
HRESULT GetInstanceReplicationInfo( DWORD dwInfoType,
                                    LPCWSTR pszInstanceNum,
                                    IN IMSAdminBase *pMB,
                                    IN METADATA_HANDLE hHandle,
                                    OUT BYTE **ppbReplicationBuffer,
                                    IN OUT DWORD *pdwBufferSize,
                                    IN OUT DWORD *pdwPosition )
/*++

Routine Description:

    Used to retrieve a replication information for a particular server instance. 
    Format of information : 
   
    <MSB of instance #><LSB of instance #>:<instance info>|

Arguments:

    dwInfoType - type of information - either signature or configuration
    pszInstanceNum - string rep of instance number
    pMB - metabase object
    hHandle - handle to path open for reading
    ppbReplicationBuffer - pointer to pointer to buffer that is filled in with info
    pdwBufferSize - pointer to current buffer size, updated on success
    pdwPosition - pointer to end of data in buffer, updated on success

Returns:

    HRESULT indicating success/failure.

--*/
{

#define INSTANCE_HEADER_LEN 3 // <MSB> <LSB> ':' 
#define INSTANCE_TRAILER_LEN 1 // '|'

    HRESULT hRes = NOERROR;
    DWORD dwInstance;
    BOOL fHasCTL = FALSE;
    BOOL fHasCert = FALSE;

    if ( !pMB )
    {
        return S_FALSE;
    }

    //
    // Special case : null instance string means instance zero ( = /LM/W3SVC )
    //
    if ( !wcscmp(L"", pszInstanceNum) )
    {
        dwInstance = 0;
    }
    else
    {
        dwInstance = _wtoi( pszInstanceNum );
    }

    
    fHasCert = MBPathHasCAPIInfo( pMB,
                                  hHandle,
                                  pszInstanceNum,
                                  adwMetabaseCertProperties,
                                  cNumCertMetabaseProperties );
    fHasCTL = MBPathHasCAPIInfo( pMB,
                                 hHandle,
                                 pszInstanceNum,
                                 adwMetabaseCTLProperties,
                                 cNumCTLMetabaseProperties );

    if ( fHasCTL || fHasCert )
    {
        //
        // Copy instance information into the buffer
        //
        if ( ( ( *pdwBufferSize - *pdwPosition ) > INSTANCE_HEADER_LEN ) || 
             ResizeBuffer( ppbReplicationBuffer, INSTANCE_HEADER_LEN , pdwBufferSize ) )
        {
            //
            // Instance header 
            //
            (*ppbReplicationBuffer)[(*pdwPosition)++] = MSB(dwInstance);
            (*ppbReplicationBuffer)[(*pdwPosition)++] = LSB(dwInstance);
            (*ppbReplicationBuffer)[(*pdwPosition)++] = COLON;
            
            //
            // Server certificate information
            //
            if ( fHasCert )
            {
                if ( FAILED( hRes = GetCertReplicationInfo( dwInfoType,
                                                            pMB,
                                                            hHandle,
                                                            pszInstanceNum,
                                                            ppbReplicationBuffer,
                                                            pdwBufferSize,
                                                            pdwPosition ) ) )
                {
                    return hRes;
                }
            }

            //
            // CTL information
            //
            if ( fHasCTL )
            {
                if ( FAILED( hRes = GetCTLReplicationInfo( dwInfoType,
                                                           pMB,
                                                           hHandle,
                                                           pszInstanceNum,
                                                           ppbReplicationBuffer,
                                                           pdwBufferSize,
                                                           pdwPosition ) ) )
                {
                    return hRes;
                }
            }
            
            if ( ( ( *pdwBufferSize - *pdwPosition ) > INSTANCE_TRAILER_LEN ) ||
                 ResizeBuffer( ppbReplicationBuffer, INSTANCE_TRAILER_LEN, pdwBufferSize ) )
            {
                //
                //Instance trailer
                //
                (*ppbReplicationBuffer)[(*pdwPosition)++] = INSTANCE_TRAILER_BYTE;
            }
            else
            {
                hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
            }
        }
        else
        {
            hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
        }
    }

    return (hRes);
}

HRESULT GetCertReplicationInfo( DWORD dwInfoType,
                                IN IMSAdminBase *pMB,
                                IN METADATA_HANDLE hHandle,
                                IN LPCWSTR pszPath,
                                OUT BYTE **ppbReplicationBuffer,
                                IN OUT DWORD *pdwBufferSize,
                                IN OUT DWORD *pdwPosition )
/*++

Routine Description:

    Used to retrieve replication information for a certificate 

Arguments:

    dwInfoType - type of information to retrieve - signature or configuration
    pMB - metabase object
    hHandle - handle to path open for reading
    pszPath - cert info path relative to hHandle
    ppbReplicationBuffer - pointer to pointer to buffer that is filled in with info
    pdwBufferSize - pointer to current buffer size, updated on success
    pdwPosition - pointer to end of data in buffer, updated on success

Returns:

    HRESULT indicating success/failure.

--*/
{
    PCCERT_CONTEXT pcServerCert = NULL;
    DWORD dwNumCerts = 0;
    LIST_ENTRY CertChain;
    BOOL fCompleteChain = FALSE;
    OPEN_CERT_STORE_INFO *pStoreInfo = NULL;
    HRESULT hRes = S_OK;

    if ( !pMB )
    {
        return S_FALSE;
    }

    InitializeListHead( &CertChain );

    //
    // try to retrieve the server certificate and its complete cert chain
    //
    if ( !FAILED( hRes = ReadServerCert( pMB,
                                         hHandle,
                                         pszPath,
                                         &pcServerCert,
                                         &pStoreInfo ) ) && 
         pcServerCert &&
         IsReplicableCert( pcServerCert ) && 
         !FAILED( hRes = ConstructCertChain( pcServerCert,
                                             pStoreInfo->pszStoreName,
                                             &CertChain,
                                             &fCompleteChain ) ) )

    {
        if ( dwInfoType == SIGNATURE )
        {
            hRes =  GetCertChainSignature( &CertChain,
                                           ppbReplicationBuffer,
                                           pdwBufferSize,
                                           pdwPosition );
        }
        else
        {
            hRes = SerializeCertChain( &CertChain,
                                       pStoreInfo,
                                       ppbReplicationBuffer,
                                       pdwBufferSize,
                                       pdwPosition );
        }
    }

    //
    // Clean up
    //
    if ( pcServerCert )
    {
        CertFreeCertificateContext( pcServerCert );
    }

    FreeCertChain( &CertChain );

    return hRes;
}



HRESULT GetCTLReplicationInfo( DWORD dwInfoType,
                                IN IMSAdminBase *pMB,
                                IN METADATA_HANDLE hHandle,
                                IN LPCWSTR pszPath,
                                OUT BYTE **ppbReplicationBuffer,
                                IN OUT DWORD *pdwBufferSize,
                                IN OUT DWORD *pdwPosition )
/*++

Routine Description:

    Used to retrieve replication information for a CTL

Arguments:

    dwInfoType - type of information to retrieve - signature or configuration
    pMB - metabase object
    hHandle - handle to path open for reading
    pszPath - cert info path relative to hHandle
    ppbReplicationBuffer - pointer to pointer to buffer that is filled in with info
    pdwBufferSize - pointer to current buffer size, updated on success
    pdwPosition - pointer to end of data in buffer, updated on success

Returns:

    HRESULT indicating success/failure.

--*/
{
    OPEN_CERT_STORE_INFO *pStoreInfo = NULL;
    HRESULT hRes;
    PCCTL_CONTEXT pcCTL = NULL;
    LIST_ENTRY CtlCerts;
    PCCERT_CONTEXT pcSignerCert = NULL;

    InitializeListHead( &CtlCerts );

    if ( S_OK == ( hRes = ReadServerCTL( pMB,
                                         hHandle,
                                         pszPath,
                                         &pcCTL ) ) &&
         !FAILED( hRes = BuildCTLDescription( pcCTL,
                                              &CtlCerts,
                                              &pcSignerCert ) ) )
    {
        if ( dwInfoType == SIGNATURE )
        {
            hRes = GetCTLSignature( pcCTL,
                                    &CtlCerts,
                                    pcSignerCert,
                                    ppbReplicationBuffer,
                                    pdwBufferSize,
                                    pdwPosition );
        }
        else
        {
            hRes = SerializeCTL( pcCTL,
                                 &CtlCerts,
                                 pcSignerCert,
                                 ppbReplicationBuffer,
                                 pdwBufferSize,
                                 pdwPosition );
        }
    }

    //
    // Cleanup
    //
    if ( pcCTL )
    {
        CertFreeCTLContext( pcCTL );
    }

    if ( pcSignerCert )
    {
        CertFreeCertificateContext( pcSignerCert );
    }

    FreeCertChain( &CtlCerts );

    return (hRes);
}

HRESULT SerializeCertChain( IN LIST_ENTRY *pChain,
                            IN OPEN_CERT_STORE_INFO *pStoreInfo,
                            OUT PBYTE *ppbChainBuffer,
                            IN OUT DWORD *pdwBufferSize,
                            IN OUT DWORD *pdwPosition )
/*++

Routine Description:

    Serializes the metabase information and certificate chain belonging to a server 
    certificate into a buffer. The first certificate in the chain is the actual server
    certificate. It does this by copying the chain into a CAPI store and serializing 
    the store.

    Format of buffer : 

    CERTS=<SHA1 hash of first cert in chain><MSB of length of private key blob><LSB of length of 
    private key blob><private key blob of first cert><key container info of private key>
    <MSB of length of serialized store containg chain><LSB of length of serialized store 
    containing chain><serialized store>

    The SHA1 hash is added so that it's possible to figure out which cert in the store
    is the leaf cert when unserializing the buffer.

Arguments:

    pChain - chain of CertChainEntry structures
    pStoreInfo - structure containing cert-related metabase information
    ppbChainBuffer - pointer to pointer to buffer that will hold the serialized store 
    on success
    pdwBufferSize - pointer to present size of buffer, updated if buffer is resized
    pdwPosition - pointer to where information is to be written to in buffer, updated
    on success

Returns:

    HRESULT indicating success/failure

--*/
{
    HCERTSTORE hMemStore;
    HRESULT hRes;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    DWORD cbPrivateKey = 0;
    DWORD cbSpaceLeft = 0;
    DWORD cbSpaceRequired = 0;
    DWORD dwProvSize = 0;

    if ( !pChain )
    {
        return S_FALSE;
    }

    //
    // The certificates are stuffed into an in-memory store, which is then serialized
    //
    if ( !( hMemStore = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                       0,
                                       NULL,
                                       0,
                                       0 ) ) )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Go through the list and add each cert to the store
    //
    LIST_ENTRY *pLink;
    CertChainEntry *pChainEntry;
    DWORD dwSizeNeeded = 0;
    DWORD cCerts = 0;
    PCCERT_CONTEXT pcFirstCert = NULL;

    for ( pLink = pChain->Flink;
          pLink != pChain;
          pLink = pLink->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pLink, CertChainEntry, ListEntry );

        if ( !CertAddCertificateContextToStore( hMemStore,
                                                pChainEntry->pcCert,
                                                CERT_STORE_ADD_REPLACE_EXISTING,
                                                NULL ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto EndSerializeChain;
        }
        cCerts++;
        if ( cCerts == 1 )
        {
            pcFirstCert = pChainEntry->pcCert;
        }
    }

    if ( !pcFirstCert )
    {
        CertCloseStore( hMemStore,
                        0 );
        return S_FALSE;
    }

    //
    // Calculate space requirements
    //
    cbSpaceLeft = *pdwBufferSize - *pdwPosition;
    cbSpaceRequired = CERT_HEADER_SIZE + SHA1_HASH_SIZE;

    if ( cbSpaceRequired > cbSpaceLeft &&
         !ResizeBuffer( ppbChainBuffer,
                        cbSpaceRequired,
                        pdwBufferSize ) )
    {
        CertCloseStore( hMemStore,
                        0 );

        return RETURNCODETOHRESULT(ERROR_OUTOFMEMORY);
    }


    //
    // Append cert header
    //
    memcpy( *ppbChainBuffer + *pdwPosition, CERT_HEADER, CERT_HEADER_SIZE );
    (*pdwPosition) += CERT_HEADER_SIZE;

    //
    // Append the hash of the first cert
    //
    cbSpaceLeft = *pdwBufferSize - *pdwPosition;
    if ( !CertGetCertificateContextProperty( pcFirstCert,
                                             CERT_SHA1_HASH_PROP_ID,
                                             (*ppbChainBuffer) + *pdwPosition,
                                             &cbSpaceLeft ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializeChain;
    }
    (*pdwPosition) += cbSpaceLeft;


    //
    // Serialize the private key for the cert
    //
    if ( FAILED( hRes = ExportAndSerializeServerPK( pcFirstCert,
                                                    ppbChainBuffer,
                                                    pdwBufferSize,
                                                    pdwPosition ) ) )
    {
        CertCloseStore( hMemStore,
                        0 );
        return (hRes);
    }

    //
    // Figure out how much space we need for the serialized store
    //
    CRYPT_DATA_BLOB StoreBlob;
    StoreBlob.pbData = NULL;
    StoreBlob.cbData = 0;
    if ( !CertSaveStore( hMemStore,
                         0,
                         CERT_STORE_SAVE_AS_STORE,
                         CERT_STORE_SAVE_TO_MEMORY,
                         (VOID *) &StoreBlob,
                         0 ) &&
         GetLastError() != ERROR_MORE_DATA )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializeChain;
    }


    //
    // Resize the buffer if necessary - space for bytes indicating length of 
    // serialized store, serialized store itself
    //
    cbSpaceRequired = 2 + StoreBlob.cbData;
    cbSpaceLeft = *pdwBufferSize - *pdwPosition;

    if ( cbSpaceRequired > cbSpaceLeft )
    {
        if ( !ResizeBuffer( ppbChainBuffer,
                            cbSpaceRequired,
                            pdwBufferSize ) )
        {
            hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
            goto EndSerializeChain;
        }
    }


    //
    // Append the length of the serialized store
    //
    (*ppbChainBuffer)[(*pdwPosition)++] = MSB(StoreBlob.cbData);
    (*ppbChainBuffer)[(*pdwPosition)++] = LSB(StoreBlob.cbData);

    //
    // Actually serialize the store
    //
    StoreBlob.cbData = *pdwBufferSize - *pdwPosition;
    StoreBlob.pbData = *ppbChainBuffer + *pdwPosition;

    if ( !CertSaveStore( hMemStore,
                         0,
                         CERT_STORE_SAVE_AS_STORE,
                         CERT_STORE_SAVE_TO_MEMORY,
                         (VOID *) &StoreBlob,
                         0 ) )
    {
        hRes =  RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializeChain;
    }
    (*pdwPosition) += StoreBlob.cbData;


EndSerializeChain:

    CertCloseStore( hMemStore,
                    0 );

    return (hRes);
}


HRESULT SerializeCTL( PCCTL_CONTEXT pcCTL,
                      LIST_ENTRY *pCTLCertChain,
                      PCCERT_CONTEXT pcSigner,
                      PBYTE *ppbReplicationBuffer,
                      DWORD *pdwBufferSize,
                      DWORD *pdwPosition )
/*++

Routine Description:

    Serializes a CTL for replication. First, the CTL, the certs in the CTL and the CTL
    signer are added to an in-memory CAPI store; the store is then serialized to memory. 
    Format of buffer :

    CTL=<MSB of length of serialized store><LSB of length of serialized
    store><serialized store>

Arguments:

    pcCTL - CTL to serialize
    pCTLCertChain - chain of certs in CTL
    pcSigner - cert that signed the CTL
    ppbSignature - pointer to pointer to buffer that will hold the signature on success
    pdwBufferSize - pointer to present size of buffer, updated if buffer is resized
    pdwPosition - pointer to where information is to be written to in buffer, updated
    on success

Returns:

    HRESULT indicating success/failure

--*/
{
    HRESULT hRes = S_OK;
    HCERTSTORE hMemStore = NULL;

    //
    // Create the memory store
    //
    if ( !(hMemStore = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                      0,
                                      NULL,
                                      0,
                                      0 ) ) )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Add the CTL to the store
    //
    if ( !CertAddCTLContextToStore( hMemStore,
                                    pcCTL,
                                    CERT_STORE_ADD_ALWAYS,
                                    NULL ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        CertCloseStore( hMemStore,
                        0 );
        return hRes;
    }

    //
    // Add the signer to the store
    //
    if ( !CertAddCertificateContextToStore( hMemStore,
                                            pcSigner,
                                            CERT_STORE_ADD_ALWAYS,
                                            NULL ) ) 
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        CertCloseStore( hMemStore,
                        0 );
        return hRes;
    }


    //
    // Add all the certs in the chain to the store
    //
    LIST_ENTRY *pLink;
    CertChainEntry *pChainEntry;
    PCCERT_CONTEXT pcFirstCert = NULL;

    for ( pLink = pCTLCertChain->Flink;
          pLink != pCTLCertChain;
          pLink = pLink->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pLink, CertChainEntry, ListEntry );

        if ( !CertAddCertificateContextToStore( hMemStore,
                                                pChainEntry->pcCert,
                                                CERT_STORE_ADD_REPLACE_EXISTING,
                                                NULL ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            CertCloseStore( hMemStore,
                            0 );
            return ( hRes );
        }
    }


    //
    // Figure out the size of the serialized store
    //
    CRYPT_DATA_BLOB StoreBlob;
    DWORD cbSpaceLeft = 0;
    DWORD cbSpaceNeeded = 0;
    
    StoreBlob.pbData = NULL;
    StoreBlob.cbData = 0;
    
    if ( !CertSaveStore( hMemStore,
                         0,
                         CERT_STORE_SAVE_AS_STORE,
                         CERT_STORE_SAVE_TO_MEMORY,
                         (VOID *) &StoreBlob,
                         0 ) &&
         GetLastError() != ERROR_MORE_DATA )
    {
        CertCloseStore( hMemStore,
                        0 );
        return RETURNCODETOHRESULT( GetLastError() );
    }
    

    //
    // need space for the CTL header, the bytes indicating the size of the store
    // and the store itself
    //
    cbSpaceNeeded = StoreBlob.cbData + CTL_HEADER_SIZE + 2;
    cbSpaceLeft = *pdwBufferSize - *pdwPosition;
    
    if ( ( cbSpaceLeft > cbSpaceNeeded ) ||
         ResizeBuffer( ppbReplicationBuffer,
                       cbSpaceNeeded,
                       pdwBufferSize ) )
    {
        //
        // CTL header
        //
        memcpy( *ppbReplicationBuffer + *pdwPosition, CTL_HEADER, CTL_HEADER_SIZE );
        (*pdwPosition) += CTL_HEADER_SIZE;
        
        //
        // Bytes indicating length of serialized store
        //
        (*ppbReplicationBuffer)[(*pdwPosition)++] = MSB(StoreBlob.cbData);
        (*ppbReplicationBuffer)[(*pdwPosition)++] = LSB(StoreBlob.cbData);
        
        //
        // Actually serialize the store
        //
        StoreBlob.cbData = *pdwBufferSize - *pdwPosition;
        StoreBlob.pbData = *ppbReplicationBuffer + *pdwPosition;
        
        if ( CertSaveStore( hMemStore,
                            0,
                            CERT_STORE_SAVE_AS_STORE,
                            CERT_STORE_SAVE_TO_MEMORY,
                            (VOID *) &StoreBlob,
                            0 ) )
        {
            (*pdwPosition) += StoreBlob.cbData;
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Error 0x%x\n", GetLastError()));
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }
    }
    else
    {
        hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
    }

    if ( hMemStore )
    {
        CertCloseStore( hMemStore,
                        0 );
    }

    return (hRes);
}


HRESULT GetCertChainSignature( IN LIST_ENTRY *pChain,
                               OUT PBYTE *ppbSignature,
                               IN OUT DWORD *pdwBufferSize,
                               IN OUT DWORD *pdwPosition )
/*++

Routine Description:

    Constructs the signature for a chain of certificates. Signature for a chain is :
    CERTS=<# of certs><hash of C1><hash of C2>...<hash of CN>

Arguments:

    pChain - chain of CertChainEntry structures
    ppbSignature - pointer to pointer to buffer that will hold the signature on success
    pdwBufferSize - pointer to present size of buffer, updated if buffer is resized
    pdwPosition - pointer to where information is to be written to in buffer, updated
    on success

Returns:

    HRESULT indicating success/failure

--*/
{
    if ( !pChain )
    {
        return S_FALSE;
    }
    
    //
    // Go through the list and figure out how much space is needed
    //
    LIST_ENTRY *pLink;
    CertChainEntry *pChainEntry;
    DWORD dwSizeNeeded = 0;
    DWORD cCerts = 0;

    for ( pLink = pChain->Flink;
          pLink != pChain;
          pLink = pLink->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pLink, CertChainEntry, ListEntry );

        dwSizeNeeded += SHA1_HASH_SIZE;
        cCerts++;
    }
    dwSizeNeeded += 1; //extra byte to hold # of certs 
    dwSizeNeeded += CERT_HEADER_SIZE;

    //
    // Resize the buffer if necessary 
    //
    if ( (*pdwBufferSize - *pdwPosition) < dwSizeNeeded )
    {
        if ( !ResizeBuffer( ppbSignature,
                            dwSizeNeeded,
                            pdwBufferSize ) )
        {
            return RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
        }
    }

    //
    // First few bytes are cert header
    //
    memcpy(*ppbSignature + *pdwPosition, CERT_HEADER, CERT_HEADER_SIZE );
    (*pdwPosition) += CERT_HEADER_SIZE;

    //
    // Next byte is # of cert hashes 
    //
    (*ppbSignature)[(*pdwPosition)++] = (BYTE) cCerts;

    //
    // Walk the chain and stuff in all the cert hashes
    //
    DWORD dwSize = SHA1_HASH_SIZE;
    DWORD cPresentCert = 0;
    for ( pLink = pChain->Flink;
          pLink != pChain;
          pLink = pLink->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pLink, CertChainEntry, ListEntry );

        if ( !CertGetCertificateContextProperty( pChainEntry->pcCert, 
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 (*ppbSignature) + *pdwPosition,
                                                 &dwSize ) )
        {
            return RETURNCODETOHRESULT( GetLastError() );
        }

        cPresentCert++;
        (*pdwPosition) += SHA1_HASH_SIZE;        
    }
      
    return S_OK;
}


HRESULT GetCTLSignature( PCCTL_CONTEXT pcCTL,
                         LIST_ENTRY *pCTLCertsChain,
                         PCCERT_CONTEXT pcSignerCert,
                         PBYTE *ppbReplicationBuffer,
                         DWORD *pdwBufferSize,
                         DWORD *pdwPosition )
/*++

Routine Description:

    Constructs the signature for a CTL. Signature for CTL is
    CTL=<hash of signer><hash of CTL>

Arguments:

    pcCTL - CTL whose signature is to be generated
    pCTLCertsChain - chain of certificates in CTL
    pcSignerCert - certificate that signed the CTL
    ppbReplicationBuffer - pointer to pointer to buffer that will hold the signature on success
    pdwBufferSize - pointer to present size of buffer, updated if buffer is resized
    pdwPosition - pointer to where information is to be written to in buffer, updated
    on success

Returns:

    HRESULT indicating success/failure

--*/
{
    DWORD cbSpaceLeft = *pdwBufferSize - *pdwPosition;
    DWORD cbSpaceNeeded = 2*SHA1_HASH_SIZE + CTL_HEADER_SIZE;

    HRESULT hRes = S_OK;

    if ( cbSpaceLeft > cbSpaceNeeded ||
         ResizeBuffer( ppbReplicationBuffer,
                       cbSpaceNeeded,
                       pdwBufferSize ) )
    {
        //
        //CTL header
        //
        memcpy( *ppbReplicationBuffer + *pdwPosition, CTL_HEADER, CTL_HEADER_SIZE );
        (*pdwPosition) += CTL_HEADER_SIZE;

        //
        // Hash of signer
        //
        cbSpaceLeft = *pdwBufferSize - *pdwPosition;
        if ( !CertGetCertificateContextProperty( pcSignerCert,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 *ppbReplicationBuffer + *pdwPosition,
                                                 &cbSpaceLeft ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }
        else 
        {
            DBG_ASSERT( cbSpaceLeft == SHA1_HASH_SIZE );

            (*pdwPosition) += cbSpaceLeft;

            //
            // Hash of CTL itself
            //
            cbSpaceLeft = *pdwBufferSize - *pdwPosition;
            if ( !CertGetCTLContextProperty( pcCTL,
                                             CERT_SHA1_HASH_PROP_ID,
                                             *ppbReplicationBuffer + *pdwPosition,
                                             &cbSpaceLeft ) )
            {
                hRes = RETURNCODETOHRESULT( GetLastError() );
            }
            else
            {
                DBG_ASSERT( cbSpaceLeft == SHA1_HASH_SIZE );

                (*pdwPosition) += cbSpaceLeft;
            }
        }
    }
    else
    {
        hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
    }

    return (hRes);
}






HRESULT DeserializeInstanceInfo( IN OUT BYTE **ppbPosition,
                                 IN BYTE *pbEnd,
                                 OUT DWORD *pdwInstance )
/*++

Routine Description:

    Deserializes the SSL information for a single server instance

Arguments:

    ppbPosition - pointer to pointer to buffer to deserialize; updated after info for
    instance has been deserialized
    pbEnd - pointer to end of serialized information, to avoid running off the end
    pdwInstance - pointer to instance for which info is being deserialized; updated on
    success

Returns:

    HRESULT indicating success/failure.

--*/
{
    HRESULT hRes = S_OK;
    BYTE *pbPresent = NULL;
    BOOL fHasCertInfo = FALSE;
    BOOL fHasCTLInfo = FALSE;

    //
    // Sanity checks on arguments
    //
    if ( !ppbPosition || !*ppbPosition || !pbEnd ||
         pbEnd < *ppbPosition + MIN_REPLICATION_INFO_SIZE )
    {
        return REPL_INTERNAL_ERROR;
    }
    
    pbPresent = *ppbPosition;
    BYTE bMSB = *(pbPresent++);
    BYTE bLSB = *(pbPresent++);

    *pdwInstance = (DWORD) ( (bMSB << 8) + bLSB );

    DBGPRINTF((DBG_CONTEXT,
               "Deserializing info for instance %d\n",
               *pdwInstance));

    //
    // Next byte should be colon
    //
    if ( !(*pbPresent == COLON) )
    {
        return REPL_INTERNAL_ERROR;
    }
    pbPresent++;

    //
    // Next bit should either be CERT_HEADER or CTL_HEADER
    //
    if ( ( pbEnd > pbPresent + CERT_HEADER_SIZE ) && 
         !memcmp( pbPresent, CERT_HEADER, CERT_HEADER_SIZE ) )
    {
        fHasCertInfo = TRUE;

        //
        //deserialize cert
        //
        if ( FAILED( hRes = DeserializeServerCert( &pbPresent,
                                                   pbEnd ) ) )
        {
            return hRes;
        }
    }

    if ( ( pbEnd > pbPresent + CTL_HEADER_SIZE ) &&
         !memcmp( pbPresent, CTL_HEADER, CTL_HEADER_SIZE ) )
    {
        fHasCTLInfo = TRUE;

        //
        //deserialize CTL
        //
        if ( FAILED( hRes = DeserializeServerCTL( &pbPresent,
                                                  pbEnd ) ) )
        {
            return hRes;
        }
    }


    if ( !fHasCertInfo && !fHasCTLInfo )
    {
        return REPL_INTERNAL_ERROR;
    }

    //
    // Check for trailer byte
    //
    if ( !( *pbPresent == INSTANCE_TRAILER_BYTE ) )
    {
        return REPL_INTERNAL_ERROR;
    }
    pbPresent++;

    //
    // Update pointer to indicate where next deserialization has to
    // start
    //
    *ppbPosition = pbPresent;

    return hRes;
}

//
// This should be more focused, but the current prefix docs are quite vague
// about some of the suppression options.
//
// The error being suppressed is a memory leak on the internal error path
// see windows bug 48010 for details. Suppressing now, because this is 
// a broken an rarely used code path. And the error case is a virtual
// impossibility.
//
/* #pragma INTRINSA suppress=all */
HRESULT DeserializeServerCert( IN OUT BYTE **ppbBuffer,
                               IN BYTE *pbEnd )
/*++

Routine Description:

    Deserializes a server certificate [and its attendant chain] and puts the certs in
    the appropriate stores

Format of buffer :

    "CERTS="<SHA1 hash of first cert in chain><MSB of length of private key blob>
     <LSB of length of private key blob><private key info of first cert>
     <MSB of length of serialized store containing chain><LSB of length of serialized store 
     containing chain><serialized store>

Arguments:

     ppbBuffer - pointer to pointer to serialized info, updated on success
     pbEnd - pointer to end of buffer, to avoid overruns

Returns:

    HRESULT indicating success/failure


--*/

{
    HRESULT hRes = S_OK;
    BYTE *pbPresent = *ppbBuffer;
    BYTE rgbHash[SHA1_HASH_SIZE];
    DWORD cbPrivateKey = 0;
    DWORD cbStore = 0;
    BYTE bMSB = 0;
    BYTE bLSB = 0;
    HCERTSTORE hMemStore = NULL;
    CRYPT_KEY_PROV_INFO CKPI;

    pbPresent += CERT_HEADER_SIZE;

    if ( pbEnd <= pbPresent + SHA1_HASH_SIZE )
    {
        return REPL_INTERNAL_ERROR;
    }

    //
    // get the hash of the first cert in the chain [server cert]
    //
    memcpy( rgbHash, pbPresent, SHA1_HASH_SIZE );
    pbPresent += SHA1_HASH_SIZE;

    //
    // eXtract the private key
    //
    HCRYPTKEY hPrivateKey = NULL;

    if ( FAILED( hRes = DeserializeAndImportServerPK( &pbPresent,
                                                      pbEnd,
                                                      &hPrivateKey,
                                                      &CKPI ) ) )
    {
        return hRes;
    }


    //
    // figure out length of serialized store
    //
    if ( pbEnd <= pbPresent + 2 ) //two byte header indicating length of serialized store
    {
        return REPL_INTERNAL_ERROR;
    }
    bMSB = *(pbPresent++);
    bLSB = *(pbPresent++);

    cbStore = (DWORD) ( (bMSB << 8 ) + bLSB );

    if ( cbStore <= 0 || pbEnd <= pbPresent + cbStore )
    {
        return REPL_INTERNAL_ERROR;
    }

    //
    // Unserialize the store containing the certs in the chain
    //
    CRYPT_DATA_BLOB cdbSerializedStore;
    cdbSerializedStore.cbData = cbStore;
    cdbSerializedStore.pbData = pbPresent;

    if ( !( hMemStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                                       0,
                                       NULL,
                                       0,
                                       (PVOID) &cdbSerializedStore ) ) )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }
    pbPresent += cbStore;

    //
    // Deal with certs in the store
    //
    if ( FAILED( hRes = DistributeCerts( hMemStore,
                                         rgbHash,
                                         &CKPI ) ) )
    {
        CertCloseStore( hMemStore,
                        0 );
        return hRes;
    }

    //
    // Update 
    //
    *ppbBuffer = pbPresent;

    //
    // cleanup
    //
    if ( hPrivateKey )
    {
        CryptDestroyKey( hPrivateKey );
    }

    if ( hMemStore )
    {
        CertCloseStore( hMemStore,
                        0 );
    }

    if ( CKPI.cProvParam && CKPI.rgProvParam )
    {
        delete [] CKPI.rgProvParam;
    }

    return hRes;
}


HRESULT DeserializeServerCTL( IN OUT BYTE **ppbBuffer,
                              IN BYTE *pbEnd )
/*++

Routine Description:

    Deserializes a CTL, the certs in the CTL and the CTL signer and places them into the 
    appropriate stores. 
    CTL goes into the TRUST store. Signer goes into ROOT store if self-signed
    and MY store if not. Certs in CTL go into CA store.

    NOTE : currently, the signer will always be the IIS server cert, which is replicated
    separately, so we won't bother doing anything with the signer cert

Format of buffer :

    CTL=<MSB of length of serialized store><LSB of length of serialized
    store><serialized store>

Arguments:

     ppbBuffer - pointer to pointer to serialized info, updated on success
     pbEnd - pointer to end of buffer, to avoid overruns

Returns:

    HRESULT indicating success/failure
--*/

{
    HRESULT hRes = S_OK;
    BYTE *pbPresent = *ppbBuffer;
    DWORD cbStore = 0;
    BYTE bMSB = 0;
    BYTE bLSB = 0;
    HCERTSTORE hMemStore = NULL;
    HCERTSTORE hTrustStore = NULL;
    HCERTSTORE hCAStore = NULL;
    PCCTL_CONTEXT pCTL = NULL;
    PCCTL_CONTEXT pPrevCTL = NULL;
    DWORD dwNumCTLs = 0;
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pPrevCert = NULL;

    pbPresent += CTL_HEADER_SIZE;

    if ( pbEnd <= pbPresent + 2 ) //bytes indicating length of serialized store
    {
        return REPL_INTERNAL_ERROR;
    }

    //
    // figure out length of serialized store
    //
    bMSB = *(pbPresent++);
    bLSB = *(pbPresent++);

    cbStore = (DWORD) ( (bMSB << 8 ) + bLSB );

    if ( cbStore <= 0 || pbEnd <= pbPresent + cbStore )
    {
        return REPL_INTERNAL_ERROR;
    }

    //
    // Unserialize the store containing the CTL, certs in the CTL and signer
    //
    CRYPT_DATA_BLOB cdbSerializedStore;
    cdbSerializedStore.cbData = cbStore;
    cdbSerializedStore.pbData = pbPresent;

    if ( !( hMemStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                                       0,
                                       NULL,
                                       0,
                                       (PVOID) &cdbSerializedStore ) ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto end_deserialize_ctl;
    }
    pbPresent += cbStore;

    if ( !( hTrustStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                         0,
                                         NULL,
                                         CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                         TRUST_STORE_NAME ) ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto end_deserialize_ctl;
    }        


    if ( !( hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                      0,
                                      NULL,
                                      CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                      CA_STORE_NAME ) ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto end_deserialize_ctl;
    }

                        
    //
    // Add all the CTLs in the deserialized store to the TRUST store
    //

    while ( ( pCTL = CertEnumCTLsInStore( hMemStore,
                                          pPrevCTL ) ) )
    {
        if ( !CertAddCTLContextToStore(  hTrustStore,
                                         pCTL,
                                         CERT_STORE_ADD_REPLACE_EXISTING,
                                         NULL ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto end_deserialize_ctl;
        }
        pPrevCTL = pCTL;
        dwNumCTLs++;
    }

    DBG_ASSERT( dwNumCTLs == 1 );


    //
    // Add all the certs in the CTL to the CA store
    //
    while ( pCert = CertEnumCertificatesInStore( hMemStore,
                                                 pPrevCert ) )
    {
        if ( !CertAddCertificateContextToStore( hCAStore,
                                                pCert,
                                                CERT_STORE_ADD_NEW,
                                                NULL ) &&
             GetLastError() != CRYPT_E_EXISTS )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto end_deserialize_ctl;
        }
        pPrevCert = pCert;
    }

    //
    // NOTE : in future may want to deal with signer cert as well
    //

    //
    // Update 
    //
    *ppbBuffer = pbPresent;

end_deserialize_ctl:
    //
    // cleanup
    //
    if ( hMemStore )
    {
        CertCloseStore( hMemStore,
                        0 );
    }

    if ( hTrustStore )
    {
        CertCloseStore( hTrustStore,
                        0 );
    }

    if ( hCAStore )
    {
        CertCloseStore( hCAStore,
                        0 );
    }

    return (hRes);
}

HRESULT ConstructCertChain( PCCERT_CONTEXT pcLeafCert,
                            LPWSTR pszLeafCertStore,
                            LIST_ENTRY *pCertChain,
                            PBOOL pfCompleteChain )
/*++

Routine Description:

    Constructs the complete cert chain for the leaf cert passed in

Arguments:

    pcLeafCert - cert for which chain is to be constructed
    pszLeafCertStore - name of store from which pcLeafCert came
    pCertChain - pointer to linked list containing cert chain. The first cert in the 
    list is pcLeafCert.
    pfCompleteChain - set to TRUE if we constructed a full cert chain ie the constructed chain
    ends with a self-signed cert

Returns:

    HRESULT indicating success/failure

Note: 2/18/98 - CAPI2 is supposed to have an API Real Soon Now that will construct a cert chain; 
      until then, we'll roll our own. 

--*/
{
    DBG_ASSERT( pcLeafCert );
    DBG_ASSERT( pCertChain );

    HCERTSTORE hMyStore = NULL;
    HCERTSTORE hCAStore = NULL;
    HCERTSTORE hRootStore = NULL;

    HRESULT    hr = NOERROR;

    CertChainEntry * pLink = NULL;

    PCCERT_CONTEXT pcIssuer = NULL;
    PCCERT_CONTEXT pcPresentLeaf = pcLeafCert;

    DWORD       dwFlags = 0;
    DWORD       dwStoresTried = 0;
    HCERTSTORE  hPresentStore = pcPresentLeaf->hCertStore;
    BOOL        fSystemStore = FALSE;
    LPWSTR      pszPresentStore = pszLeafCertStore;

    *pfCompleteChain = FALSE;

    //
    // Open all the stores we'll search for issuers - MY, CA and ROOT
    //
    hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                              0,
                              NULL,
                              CERT_SYSTEM_STORE_LOCAL_MACHINE,
                              MY_STORE_NAME );

    if ( !hMyStore )
    {
        hr = RETURNCODETOHRESULT( GetLastError() );
        goto cleanup;
    }


    hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                             0,
                             NULL,
                             CERT_SYSTEM_STORE_LOCAL_MACHINE,
                             CA_STORE_NAME );

    if ( !hCAStore )
    {
        hr = RETURNCODETOHRESULT( GetLastError() );
        goto cleanup;
    }

    hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                               0,
                               NULL,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE,
                               ROOT_STORE_NAME );

    if ( !hRootStore )
    {
        hr = RETURNCODETOHRESULT( GetLastError() );
        goto cleanup;
    }


    //
    // First link in the chain is the leaf cert
    //
    pLink = new CertChainEntry;
    if( pLink == NULL )
    {
        hr = RETURNCODETOHRESULT( GetLastError() );
        goto cleanup;
    }

    pLink->pcCert = CertDuplicateCertificateContext( pcLeafCert );
    pLink->pszStoreName = mystrdup( pszLeafCertStore );

    InsertHeadList( pCertChain, &pLink->ListEntry );


    //
    // To build the chain, look for issuers in 4 stores : the store the cert came from,
    // and the "MY", "CA" and "ROOT" stores, cycling through the stores as necessary
    //
    *pfCompleteChain = FALSE;

    DBG_ASSERT( SUCCEEDED(hr) );

    while ( 1 )
    {
        //
        // Bail when we get to the top of a chain
        //
        if ( IsSelfSignedCert( pcPresentLeaf ) )
        {
            *pfCompleteChain = TRUE;
            break;
        }

        pcIssuer = CertGetIssuerCertificateFromStore( hPresentStore,
                                                      pcPresentLeaf,
                                                      NULL,
                                                      &dwFlags );

        //
        // Got an issuer in this store
        //
        if ( pcIssuer )
        {
            //
            // Add it to the list
            //
            pLink = new CertChainEntry;
            if( pLink == NULL )
            {
                hr = RETURNCODETOHRESULT( GetLastError() );
                goto cleanup;
            }

            pLink->pcCert = CertDuplicateCertificateContext( pcIssuer );
            pLink->pszStoreName = (fSystemStore ? pszPresentStore : 
                                   mystrdup( pszPresentStore ) );
            pLink->fDynName = !fSystemStore;

            //
            // Need to insert at the -end- of the list to keep ordering, where
            // first cert is the actual server cert
            //
            InsertTailList( pCertChain, &pLink->ListEntry );

            //
            // Set up for next round
            //
            dwStoresTried = 0;
            pcPresentLeaf = pLink->pcCert;
        }
        //
        // No issuer in this store, switch to next store to look in
        //
        else
        {

            dwStoresTried++;

            if ( dwStoresTried == 4 ) //we've tried all the stores, time to bail
            {
                break;
            }

            if ( hPresentStore == hMyStore )
            {
                hPresentStore = hCAStore;
                pszPresentStore = CA_STORE_NAME;
                fSystemStore = TRUE;
            }
            else if ( hPresentStore == hCAStore )
            {
                hPresentStore = hRootStore;
                pszPresentStore = ROOT_STORE_NAME;
                fSystemStore = TRUE;
            }
            else if ( hPresentStore == hRootStore )
            {
                hPresentStore = pcPresentLeaf->hCertStore;
                pszPresentStore = pszLeafCertStore;
                fSystemStore = FALSE;
            }
            else
            {
                hPresentStore = hMyStore;
                pszPresentStore = MY_STORE_NAME;
                fSystemStore = TRUE;
            }
        }
    } //while ( 1 )

    DBG_ASSERT( SUCCEEDED(hr) );

cleanup:

    //
    // Cleanup
    //
    if( hMyStore != NULL )
    {
        CertCloseStore( hMyStore, 0 );
    }

    if( hCAStore != NULL )
    {
        CertCloseStore( hCAStore, 0 );
    }

    if( hRootStore != NULL )
    {
        CertCloseStore( hRootStore, 0 );
    }

    return hr;
}


HRESULT BuildCTLDescription( IN PCCTL_CONTEXT pcCTL,
                             OUT LIST_ENTRY *pCTLCerts,
                             OUT PCCERT_CONTEXT *ppcSigner )
/*++

Routine Description:

   Builds a full description of a CTL - all the certs in the CTL as well as the CTL
   signer

Arguments:

   pcCTL - CTL whose description is to be built
   pCTLCerts - linked list that will have the certs in the CTL inserted into it
   ppcSigner - pointer to pointer to cert that signed the CTL

Returns:

   HRESULT indicating success/failure

--*/
{
    //
    // First try to get all the certs in the CTL
    //
    PCTL_INFO pCtlInfo = pcCTL->pCtlInfo;
    HRESULT hRes;

    if ( !pCtlInfo->cCTLEntry )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Herm. Nothing in CTL ? \n"));

        return S_FALSE;
    }
    else
    {
        HCERTSTORE ahStores[3];
        memset( ahStores, 0, sizeof(ahStores) );
        DWORD dwNumStores = sizeof(ahStores)/sizeof(HCERTSTORE);
        PCCERT_CONTEXT pcCert = NULL;
        BOOL fFoundCert = FALSE;
        DWORD dwIndex = 0;
        DWORD dwStoreIndex = 0;

        //
        // Try the MY, CA and ROOT stores for local machine
        //
        if ( !(ahStores[0] = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                         0,
                                         NULL,
                                         CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                         MY_STORE_NAME ) ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to open MY store : 0x%x\n", GetLastError()));
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto ctl_cleanup;
        }


        if ( !(ahStores[1] = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                         0,
                                         NULL,
                                         CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                         CA_STORE_NAME ) ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to open CA store : 0x%x\n", GetLastError()));
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto ctl_cleanup;
        }

        if ( !(ahStores[2] = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                         0,
                                         NULL,
                                         CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                         ROOT_STORE_NAME ) ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to open ROOT store : 0x%x\n", GetLastError()));
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto ctl_cleanup;
        }

        //
        // Iterate through the certs in the CTL. For each cert, try to find it
        // by SHA1 hash in the supplied stores. 
        //
        
        for ( dwIndex = 0; dwIndex < pCtlInfo->cCTLEntry; dwIndex++ )
        {
            fFoundCert = FALSE;
            for ( dwStoreIndex = 0; dwStoreIndex < dwNumStores; dwStoreIndex++ )
            {
                if ( pcCert = CertFindCertificateInStore( ahStores[dwStoreIndex],
                                                          X509_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_SHA1_HASH,
                                   (VOID *) &(pCtlInfo->rgCTLEntry[dwIndex].SubjectIdentifier),
                                                          NULL ) )
                {
                    fFoundCert = TRUE;
                    break;
                }
            }

            //
            // Couldn't find one of the certs in the CTL, error
            //
            if ( !fFoundCert )
            {
                hRes = RETURNCODETOHRESULT( GetLastError() );
                goto ctl_cleanup; 
            }
            else
            {
                CertChainEntry *pEntry = new CertChainEntry;
                
                if( pEntry == NULL )
                {
                    hRes = RETURNCODETOHRESULT( GetLastError() );
                    goto ctl_cleanup;
                }

                pEntry->pcCert = pcCert;
                pEntry->fDynName = FALSE;

                switch( dwStoreIndex )
                {
                case 0:
                    pEntry->pszStoreName = MY_STORE_NAME;
                    break;
                case 1:
                    pEntry->pszStoreName = CA_STORE_NAME;
                    break;
                case 2:
                    pEntry->pszStoreName = ROOT_STORE_NAME;
                    break;
                default:
                    //
                    // should never get here
                    DBG_ASSERT( TRUE );
                    break;
                }

                InsertTailList( pCTLCerts, &pEntry->ListEntry );
            }
        }

        //
        // Find the CTL signer
        //
        if ( !CryptMsgGetAndVerifySigner( (HCRYPTMSG) pcCTL->hCryptMsg,
                                          dwNumStores,
                                          ahStores,
                                          CMSG_TRUSTED_SIGNER_FLAG | CMSG_SIGNER_ONLY_FLAG,
                                          ppcSigner,
                                          NULL ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }

    ctl_cleanup:
        for ( dwStoreIndex = 0; dwStoreIndex < dwNumStores; dwStoreIndex++ )
        {
            if ( ahStores[dwStoreIndex] )
            {
                CertCloseStore( ahStores[dwStoreIndex],
                                0 );
            }
        }
    } //else 

    return (hRes);
}


VOID FreeCertChain( IN OUT LIST_ENTRY *pChain )
/*++

Routine Description:

    Free resources associated with a cert chain

Arguments:

    pChain - chain to be cleaned up

Returns:

    Nothing

--*/
{
    if ( !pChain )
    {
        return;
    }

    CertChainEntry *pChainEntry;

    while ( !IsListEmpty( pChain ) )
    {
        pChainEntry = CONTAINING_RECORD ( pChain->Flink,
                                          CertChainEntry,
                                          ListEntry );
        RemoveEntryList( &(pChainEntry->ListEntry) );

        if ( pChainEntry->pcCert )
        {
            CertFreeCertificateContext( pChainEntry->pcCert );
        }
        
        if ( pChainEntry->pszStoreName && pChainEntry->fDynName )
        {
            delete [] pChainEntry->pszStoreName;
        }
    }
}


BOOL IsSelfSignedCert( IN PCCERT_CONTEXT pCertContext )
/*++

Routine Description:

    Determines whether a cert is self-signed ie the top of a hierarchy

Arguments:

    pCertContext - cert to be checked

Returns:

    TRUE if cert is self-signed, FALSE otherwise

--*/

{
    //
    // Compare subject and issuer.
    //
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsReplicableCert( IN PCCERT_CONTEXT pCert )
/*++

Routine Description:

   Checks whether a cert can be replicated or not. Eg Fortezza certs can't be replicated
   because they use a machine-specific hardware token

Arguments:

    pCert - cert to be checked

Returns:

    TRUE if cert can be replicated, FALSE if not

--*/
{
    if ( IsFortezzaCert( pCert ) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL IsFortezzaCert( IN PCCERT_CONTEXT pCert )
/*++

Routine Description:

   Checks whether a cert is a Fortezza certificate.

Arguments:

    pCert - cert to be checked

Returns:

    TRUE if it is, FALSE if not 

--*/
{
    PSTR pszOid = NULL;

    // Q - is there a better way to do this?

    pszOid = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    if(pszOid)
    {
        if(strcmp(pszOid, szOID_INFOSEC_mosaicUpdatedSig)  == 0 ||
           strcmp(pszOid, szOID_INFOSEC_mosaicKMandUpdSig) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT ReadServerCTL( IN IMSAdminBase *pMB,
                       IN METADATA_HANDLE hHandle,
                       IN LPCWSTR pszPath,
                       OUT PCCTL_CONTEXT *ppcCTL )
/*++

Routine Description:

    Tries to construct a certificate based on information in metabase

Arguments:

    pMB - pointer to MB object
    hHandle - handle opened for reading
    pszPath - path under which info is stored, relative to hHandle
    ppcCTL - pointer to pointer to CTL context, updated if CTL was found


Returns:

    HRESULT indicating success/failure

--*/

{
    DBG_ASSERT( pMB );

    METADATA_RECORD mdr;
    HRESULT hRes;
    LPWSTR pwszListIdentifier = NULL;
    DWORD dwIdentifierSize = 0;
    OPEN_CERT_STORE_INFO *pCertStoreInfo = NULL;
    HCERTSTORE hStore = NULL;

    //
    // Read CTL list identifier out of metabase
    //
    MD_SET_DATA_RECORD( &mdr, MD_SSL_CTL_IDENTIFIER,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER, BINARY_METADATA, NULL,
                        0 );

    if ( FAILED( hRes = RetrieveBlobFromMetabase( pMB,
                                                  hHandle,
                                                  pszPath,
                                                  &mdr,
                                                  0 ) ) )
    {
        return hRes;
    }
    else
    {
        pwszListIdentifier = (LPWSTR) mdr.pbMDData;
        dwIdentifierSize = mdr.dwMDDataLen;

#if DBG
        CHAR achListId[255];
        if ( WideCharToMultiByte( CP_ACP,
                                  0,
                                  pwszListIdentifier,
                                  -1,
                                  achListId,
                                  254,
                                  NULL,
                                  NULL ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "List id : %s\n", achListId));
        }
#endif
    }

    //
    // Read cert store info out of MB, and try to reconstruct CTL context
    //
    if ( (pCertStoreInfo = ReadCertStoreInfoFromMB( pMB,
                                                    hHandle,
                                                    pszPath,
                                                    TRUE ) ) )
    {
        if ( !( hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                        0,
                                        NULL,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        pCertStoreInfo->pszStoreName ) ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }            
        else
        {
            CTL_FIND_USAGE_PARA CtlFindUsagePara;
            memset(&CtlFindUsagePara, 0, sizeof(CtlFindUsagePara));
            
            CtlFindUsagePara.cbSize = sizeof(CtlFindUsagePara);
            CtlFindUsagePara.ListIdentifier.cbData = dwIdentifierSize;
            CtlFindUsagePara.ListIdentifier.pbData = (PBYTE) pwszListIdentifier;

            //
            // Try to find CTL in specified store
            //
            *ppcCTL = CertFindCTLInStore( hStore,
                                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                          0,
                                          CTL_FIND_USAGE,
                                          (LPVOID) &CtlFindUsagePara,
                                          NULL );
            
            if ( !*ppcCTL )
            {
                hRes = RETURNCODETOHRESULT( GetLastError() );
            }
        }
    }
    else
    {
        hRes = S_FALSE;
    }


    if ( hStore )
    {
        CertCloseStore( hStore,
                        0 );
    }

    if ( pCertStoreInfo )
    {
        DeallocateCertStoreInfo( pCertStoreInfo );
    }

    if ( pwszListIdentifier )
    {
        delete [] pwszListIdentifier;
    }

    return hRes;

}

HRESULT ReadServerCert( IN IMSAdminBase *pMB,
                        IN METADATA_HANDLE hHandle,
                        IN LPCWSTR pszPath,
                        OUT PCCERT_CONTEXT *ppcCertContext,
                        OUT OPEN_CERT_STORE_INFO **ppStoreInfo )
/*++

Routine Description:

    Tries to construct a certificate based on information in metabase

Arguments:

    pMB - pointer to MB object
    hHandle - handle opened for reading
    pszPath - path under which info is stored, relative to hHandle
    ppcCertContext - pointer to pointer to cert context, updated if cert was found
    ppStoreInfo - pointer to pointer to cert store information stored in metabase; updated if
    successful

Returns:

    HRESULT indicating success/failure

--*/

{
    DBG_ASSERT( pMB );

    METADATA_RECORD mdr;
    PBYTE pbCertHash = NULL;
    DWORD dwHashSize = 0;
    HRESULT hRes;

    //
    // Get the hash of the cert
    //
    MD_SET_DATA_RECORD( &mdr, MD_SSL_CERT_HASH, METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER, BINARY_METADATA, NULL, 0 );
    

    if ( FAILED( hRes = RetrieveBlobFromMetabase( pMB,
                                                  hHandle,
                                                  pszPath,
                                                  &mdr,
                                                  SHA1_HASH_SIZE ) ) )
    {
        return hRes;
    }
    else
    {
        DBG_ASSERT( mdr.dwMDDataLen == SHA1_HASH_SIZE );

        pbCertHash = mdr.pbMDData;
        dwHashSize = mdr.dwMDDataLen;
    }

    //
    // Get all the info necessary to open the store in which the cert is
    //
    *ppStoreInfo = ReadCertStoreInfoFromMB( pMB,
                                            hHandle,
                                            pszPath,
                                            FALSE );

    if ( !*ppStoreInfo )
    {
        delete [] pbCertHash;
        return S_FALSE;
    }

    //
    // Got all the info, reconstruct the certificate
    //

#if 0
    //
    // Open the appropriate store
    //
    if ( !CryptAcquireContext( &m_hCryptProv,
                               m_pszContainer,
                               m_pszProvider,
                               m_dwProvType,
                               m_dwFlags ) )
    {
        goto EndReadServerCert;
    }
    
    
    if ( !(m_hCertStore = CertOpenSystemStore( m_hCryptProv,
                                               m_pszStoreName )))
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndRetrieveCertContext;
    }
#else
    if ( !((*ppStoreInfo)->hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                                       0,
                                                       NULL,
                                                       CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                                       (*ppStoreInfo)->pszStoreName ) ) )

    {
        DeallocateCertStoreInfo( *ppStoreInfo );
        delete [] pbCertHash;
        return S_FALSE;
    }

#endif 


    //
    // Try to find the cert in the store
    //
    CRYPT_HASH_BLOB HashBlob;
    HashBlob.cbData = dwHashSize;
    HashBlob.pbData = pbCertHash;
    
    *ppcCertContext = CertFindCertificateInStore( (*ppStoreInfo)->hCertStore,
                                                 X509_ASN_ENCODING,
                                                 0,
                                                 CERT_FIND_SHA1_HASH,
                                                 (VOID *) &HashBlob,
                                                 NULL );
    

    if ( !*ppcCertContext )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
    }
    else
    {
        hRes = S_OK;
    }

    //
    // Clean up
    //
    delete [] pbCertHash;

    return hRes;
}

BOOL ResizeBuffer( IN OUT BYTE **ppbBuffer,
                   IN DWORD dwMinResize,
                   IN OUT DWORD *pdwPresentSize )
/*++

Routine Description:

    Used to resize a buffer

Arguments:

    ppbBuffer - pointer to pointer to buffer to be resized, updated on success
    dwMinResize - minimum amount to resize by
    pdwPresentSize - pointer to buffer size, updated on success

Returns:

    TRUE if resize succeeds, FALSE if it fails

--*/

{
    DWORD dwActualResize = 0;
    DWORD dwDoubleSize = 2* (*pdwPresentSize);
    DWORD dwExtendedSize = *pdwPresentSize + dwMinResize;
    BYTE *pbNewBuffer = NULL;

    //
    // Amt of memory to resize to is maximum of
    // present size + dwMinResize, 2 * present size, INITIAL_BUFFER_SIZE
    //

    dwActualResize = ( INITIAL_BUFFER_SIZE > dwDoubleSize ? 
                      ( INITIAL_BUFFER_SIZE > dwExtendedSize ? 
                        INITIAL_BUFFER_SIZE : dwExtendedSize ) :
                       ( dwExtendedSize > dwDoubleSize  ? dwExtendedSize : dwDoubleSize ) );

    //
    // totally new buffer
    //
    if ( !*ppbBuffer )
    {
        
        *ppbBuffer = new BYTE[ dwActualResize ];

        if ( !*ppbBuffer )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }
        
    }
    else // resize of existing buffer
    {

        pbNewBuffer = new BYTE[ dwActualResize ];

        if ( !pbNewBuffer )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        //
        // Copy the old buffer
        //
        memcpy( pbNewBuffer, *ppbBuffer, *pdwPresentSize );

        //
        // Zero out the old buffer and delete it
        //
        memset( *ppbBuffer, 0, *pdwPresentSize );
        delete [] *ppbBuffer;


        *ppbBuffer = pbNewBuffer;
    }
    
    *pdwPresentSize = dwActualResize;
    
    return TRUE;
}


HRESULT RetrieveBlobFromMetabase( IN IMSAdminBase *pMB,
                                  IN METADATA_HANDLE hHandle,
                                  IN LPCWSTR pszPath,
                                  IN OUT PMETADATA_RECORD pMDR,
                                  IN DWORD dwSizeHint OPTIONAL)
/*++

Routine Description:

    Tries to retrieve a value of variable length from the metabase

Arguments:

    pMB - pointer to MB object
    hHandle - handle open for reading
    pszPath - path relative to hHandle
    pMDR - pointer to metadata record to be used when reading the value. The pbMDData member
    will be updated on success
    dwSizeHint - if caller has idea of how big value might be, can set this to number of 
    bytes to try first retrieval call with

Returns:

   HRESULT indicating whether value was read successfully

--*/
{
    HRESULT hRes = S_OK;
    DWORD dwRequiredSize = 0;

    //
    // If caller has a hint about how big the buffer might need to be, let's use it
    //
    if ( dwSizeHint )
    {
        pMDR->pbMDData = new UCHAR[dwSizeHint];

        if ( !(pMDR->pbMDData) )
        {
            return RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
        }
    }

    pMDR->dwMDDataLen = (dwSizeHint ? dwSizeHint : 0);

    hRes = pMB->GetData( hHandle,
                         pszPath,
                         pMDR,
                         &dwRequiredSize );
                             
                             
    if ( FAILED(hRes) )
    {
        //
        // If buffer wasn't big enough, let's try again ...
        //
        if ( HRESULTTOWIN32(hRes) ==  ERROR_INSUFFICIENT_BUFFER )
        {
            //
            // We were brought up well, so we'll clean stuff up
            //
            if ( dwSizeHint )
            {
                delete [] pMDR->pbMDData;
            }

            pMDR->pbMDData = new UCHAR[dwRequiredSize];
            if ( !(pMDR->pbMDData) )
            {
                return RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
            }
            pMDR->dwMDDataLen = dwRequiredSize;

            hRes = pMB->GetData( hHandle,
                                 pszPath,
                                 pMDR,
                                 &dwRequiredSize );

            if ( FAILED(hRes) )
            {
                //ah, sod it, can't do anymore
                delete [] pMDR->pbMDData;
                return hRes;
            }
        }
    }

    if ( FAILED(hRes) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "RetrieveBlobFromMB failed, 0x%x\n", HRESULTTOWIN32( hRes )));
    }

    return (hRes);
} //RetrieveBlobFromMetabase

OPEN_CERT_STORE_INFO* ReadCertStoreInfoFromMB( IN IMSAdminBase *pMB,
                                               IN METADATA_HANDLE hHandle,
                                               IN LPCWSTR pszPath,
                                               IN BOOL fCTL )
/*++

Routine Description:

    Read all the information necessary to open a CAPI store out of the metabase

Arguments:

    pMDObject - pointer to metabase object 
    hHandle - handle opened for reading
    pszPath - path relative to hHandle
    fCTL - bool indicating whether info is to be used to reconstruct a CTL or a cert 

Returns:

   Pointer to filled out OPEN_CERT_STORE_INFO structure on success, NULL on failure.
   Note that only some of the OPEN_CERT_STORE_INFO fields are -required-; currently,
   only the store name is required. 

--*/

{
    DBG_ASSERT( pMB );
    DBG_ASSERT( pszPath );

    BOOL fSuccess = FALSE;
    OPEN_CERT_STORE_INFO *pCertStoreInfo = NULL;

    pCertStoreInfo = AllocateCertStoreInfo();

    if ( !pCertStoreInfo )
    {
        return NULL;
    }

    DWORD dwReqDataLen = 0;
    METADATA_RECORD mdr;
     
    //
    //Try to retrieve container
    //
    MD_SET_DATA_RECORD(&mdr, 
                       (fCTL ? MD_SSL_CTL_CONTAINER : MD_SSL_CERT_CONTAINER), 
                       METADATA_NO_ATTRIBUTES, 
                       IIS_MD_UT_SERVER, STRING_METADATA, 
                       NULL,
                       0);
        
    if ( !FAILED( RetrieveBlobFromMetabase(pMB,
                                           hHandle,
                                           pszPath,
                                           &mdr) ) )
        
    {
        //
        // Metabase will return empty string if NULL string is stored
        //
        if ( !wcscmp( (LPWSTR) mdr.pbMDData, TEXT("")) )
        {
            delete [] mdr.pbMDData;
            pCertStoreInfo->pszContainer = NULL;
        }
        else
        {
            pCertStoreInfo->pszContainer = (LPWSTR) mdr.pbMDData;
        }
    }

    //
    //Try to retrieve cert provider
    //
    MD_SET_DATA_RECORD(&mdr, 
                       (fCTL ? MD_SSL_CTL_PROVIDER : MD_SSL_CERT_PROVIDER), 
                       METADATA_NO_ATTRIBUTES, 
                       IIS_MD_UT_SERVER, STRING_METADATA, 
                       NULL,
                       0);
        
    if ( !FAILED( RetrieveBlobFromMetabase(pMB,
                                           hHandle,
                                           pszPath,
                                           &mdr) ) )
         
    {
        //
        // Metabase will return empty string if NULL string is stored
        //
        if ( !wcscmp( (LPWSTR) mdr.pbMDData, TEXT("")) )
        {
            delete [] mdr.pbMDData;
            pCertStoreInfo->pszProvider = NULL;
        }
        else
        {
            pCertStoreInfo->pszProvider = (LPWSTR) mdr.pbMDData;
        }
    }

    //
    //Try to retrieve provider type
    //
    MD_SET_DATA_RECORD(&mdr,
                       (fCTL ? MD_SSL_CTL_PROVIDER_TYPE : MD_SSL_CERT_PROVIDER_TYPE),
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER, DWORD_METADATA,
                       NULL,
                       0);

    if ( !FAILED( RetrieveBlobFromMetabase( pMB,
                                            hHandle,
                                            pszPath,
                                            &mdr ) ) )
    {
        pCertStoreInfo->dwProvType = * ( (DWORD * ) mdr.pbMDData );
    }

    //
    //Retrieve open flags
    //
    MD_SET_DATA_RECORD( &mdr,
                        (fCTL ? MD_SSL_CTL_OPEN_FLAGS : MD_SSL_CERT_OPEN_FLAGS),
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER, DWORD_METADATA,
                        NULL,
                        0 );

    if ( !FAILED( RetrieveBlobFromMetabase( pMB,
                                            hHandle,
                                            pszPath,
                                            &mdr ) ) )
    {
        pCertStoreInfo->dwFlags = * ( (DWORD * ) mdr.pbMDData );
    }

    //
    //Try to retrieve store name
    //
    MD_SET_DATA_RECORD(&mdr, 
                       (fCTL ? MD_SSL_CTL_STORE_NAME : MD_SSL_CERT_STORE_NAME), 
                       METADATA_NO_ATTRIBUTES, 
                       IIS_MD_UT_SERVER, STRING_METADATA, 
                       NULL,
                       0);
    
    if ( FAILED( RetrieveBlobFromMetabase( pMB,
                                           hHandle,
                                           pszPath,
                                           &mdr ) ) )
    {
        goto EndReadStoreInfo;
    }
    else
    {
        //
        // Metabase will return empty string if NULL string is stored, but
        // empty name is -NOT- valid !
        //
        if ( !wcscmp( (LPWSTR) mdr.pbMDData, TEXT("")) )
        {
            delete [] mdr.pbMDData;
            goto EndReadStoreInfo;
        }
        else
        {
            pCertStoreInfo->pszStoreName = (LPWSTR) mdr.pbMDData;
        }
    }

    //
    // Everything succeeded
    //
    fSuccess = TRUE;

EndReadStoreInfo:

    if ( !fSuccess )
    {
        DeallocateCertStoreInfo( pCertStoreInfo );
        pCertStoreInfo = NULL;
    }

    return ( pCertStoreInfo );
}

HRESULT RegenerateSessionKey( IMSAdminBase *pMB,
                              OUT HCRYPTKEY *phKey )
/*++

Routine Description:

   Generate a session key to encrypt/decrypt replication information

Arguments:

   pMB - pointer to metabase object 
   phKey - pointer to key, filled in on success

Returns:

   HRESULT indicating success/failure

--*/

{
#ifdef NO_ENCRYPTION

    return S_OK;

#else 

    HCRYPTPROV hProv = NULL;
    HRESULT hRes = S_OK;
    BYTE *pbHash = NULL;
    DWORD cbHashSize = 0;
    HCRYPTHASH hHash = NULL;
    BOOL fOk = TRUE;
    METADATA_HANDLE hMDHandle;
    ALG_ID aiAlg = 0;
    BYTE *pbSeed = NULL;
    DWORD cbSeed = 0;
    DWORD cbRandomSize = 0;
    BYTE *pbRandom = NULL;
    BYTE bMajor = 0;
    BYTE bMinor = 0;
    DWORD i = 0;
    //
    // Retrieve the key seed
    //
    if ( FAILED( hRes = ReadSessionKeySeed( pMB,
                                            &pbSeed,
                                            &cbSeed ) ) ||
         !cbSeed ||
         cbSeed < SEED_HEADER_SIZE + 1 ) //total length must be greater than header

    {
        hRes = S_FALSE;
        goto regenerate_exit;
    }
    

    bMajor = pbSeed[i++];
    bMinor = pbSeed[i++];
    memcpy( &aiAlg, pbSeed + i, sizeof(ALG_ID) );
    i += sizeof(ALG_ID);
    cbRandomSize = (DWORD) pbSeed[i++];
    pbRandom = pbSeed + i;

    DBG_ASSERT( i == SEED_HEADER_SIZE );

    //
    // Make sure encoded size of random seed is same as the random seed we're actually going
    // to use, and non-zero
    if ( cbRandomSize <= 0 ||
         cbRandomSize != (cbSeed - SEED_HEADER_SIZE) )
    {
        hRes = S_FALSE;
        goto regenerate_exit;
        
    }
            
    //
    // clear out any old session keys
    //
    CryptAcquireContext( &hProv,
                         REPLICATION_SESSION_KEY_CONTAINER,
                         NULL,
                         PROV_RSA_FULL,
                         CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET );

    if ( fOk = CryptAcquireContext( &hProv,
                                    REPLICATION_SESSION_KEY_CONTAINER,
                                    NULL,
                                    PROV_RSA_FULL,
                                    CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET ) )
    {
        if ( SUCCEEDED( hRes = GenerateHash( &hProv,
                                             aiAlg,
                                             pbRandom,
                                             cbRandomSize,
                                             &pbHash,
                                             &cbHashSize,
                                             &hHash ) ) )
        {
            fOk = CryptDeriveKey( hProv,
                                  CALG_RC4,
                                  hHash,
                                  0,
                                  phKey );
        }
    }

    if ( SUCCEEDED(hRes) && !fOk )
    {
        hRes = (GetLastError() != ERROR_SUCCESS) ? 
                    RETURNCODETOHRESULT( GetLastError() ) : E_FAIL;
    }


#if 0
    //
    // Releasing the hProv will invalidate the key
    //
    if ( hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }
#endif

regenerate_exit:

    if ( hHash )
    {
        CryptDestroyHash( hHash );
    }

    //
    // Clean out seed used to derive key
    //
    if ( pbSeed )
    {
        memset( pbSeed, 0, cbSeed );
        delete [] pbSeed;
    }

    //
    // Hash buffer contains hash of seed used to derive key, so zero it out as well
    //
    if ( pbHash )
    {
        memset( pbHash, 0, cbHashSize );
        delete [] pbHash;
    }

    return hRes;

#endif // NO_ENCRYPTION
}

VOID DeleteSessionKey( IN HCRYPTKEY *phKey )
{
#ifndef NO_ENCRYPTION
    DeleteKey( phKey,
               REPLICATION_SESSION_KEY_CONTAINER );
#endif
}

VOID DeleteKey( IN HCRYPTKEY *phKey,
                IN LPCWSTR pszContainer )
/*++

Routine Description:

   Delete a key

Arguments:

   phKey - pointer to key to delete 
   pszContainer - name of key container
Returns:

   Nothing

--*/

{
    //
    // delete the key container
    //
    HCRYPTPROV hProv;
    CryptAcquireContext( &hProv,
                         pszContainer,
                         NULL,
                         PROV_RSA_FULL,
                         CRYPT_DELETE_KEYSET | CRYPT_MACHINE_KEYSET );

    //
    // delete the actual key
    //
    if ( phKey )
    {
        CryptDestroyKey( *phKey );
        *phKey = NULL;
    }

}


HRESULT ReadSessionKeySeed( IN IMSAdminBase *pMB,
                            OUT BYTE **ppbSeed,
                            OUT DWORD *pcbSeed )
/*++

Routine Description:

    Reads session key seed information out of metabase

Arguments:

    pMB - pointer to metabase interface to use
    ppbSeed - pointer to pointer to buffer updated with session key seed
    pcbSeed - pointer to DWORD holding size of seed 

Returns:

    HRESULT status

--*/
{
    HRESULT hRes = S_OK;
    METADATA_HANDLE hMDHandle;
    *pcbSeed = 0;
    
    if ( FAILED( hRes = pMB->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                      MB_ROOT_PATH,
                                      METADATA_PERMISSION_READ,
                                      TIMEOUT_VALUE,
                                      &hMDHandle ) ) )
    {
        return hRes;
    }

    //
    // Figure out the size of the seed
    //
    METADATA_RECORD mdr;    
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_REPLICATION_INFO,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        0,
                        NULL );

    hRes = pMB->GetData( hMDHandle,
                         MB_REPLICATION_PATH,
                         &mdr,
                         pcbSeed );

    if ( HRESULTTOWIN32( hRes ) != ERROR_INSUFFICIENT_BUFFER )
    {
        return hRes;
    }

    //
    // We know the size, allocate some memory
    //
    DBG_ASSERT( *pcbSeed );

    *ppbSeed = NULL;
    *ppbSeed = new BYTE[*pcbSeed];

    if ( !(*ppbSeed) )
    {
        return RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
    }

    //
    // Get the random seed out of the metabase
    //

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_REPLICATION_INFO,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        *pcbSeed,
                        *ppbSeed );

    hRes = pMB->GetData( hMDHandle,
                         MB_REPLICATION_PATH,
                         &mdr,
                         pcbSeed );

    //
    // cleanup
    //
    pMB->CloseKey( hMDHandle );

    return hRes;
}

HRESULT DeleteMBSessionKeyInfo ( IN IMSAdminBase *pMB )
/*++

Routine Description:

   Delete the metabase information used to derive a session key

Arguments:

    None

Returns:

    HRESULT status

--*/
{
#ifdef NO_ENCRYPTION
    
    return S_OK;

#else

    METADATA_HANDLE hMDHandle;
    HRESULT hRes = S_OK;

    if ( FAILED( hRes = pMB->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                      MB_ROOT_PATH,
                                      METADATA_PERMISSION_WRITE,
                                      TIMEOUT_VALUE,
                                      &hMDHandle ) ) )
    {
        return hRes;
    }


    hRes = pMB->DeleteKey( hMDHandle,
                           MB_REPLICATION_PATH );


    pMB->CloseKey( hMDHandle );

    return hRes;

#endif //NO_ENCRYPTION

}

HRESULT ExportAndSerializeServerPK( IN PCCERT_CONTEXT pcCert,
                                    IN OUT BYTE **ppbChainBuffer,
                                    IN OUT DWORD *pdwBufferSize,
                                    IN OUT DWORD *pdwPosition )
/*++

Routine Description:

   Export and serialize a private key for a server certificate. Format of serialized buffer :

   <MSB of private key length><LSB of private key length><private key><key container info>

Arguments:

   pcCert - certificate whose private key is to be exported
   ppbChainBuffer - pointer to pointer to buffer that is to hold serialized key
   pdwBufferSize - size of buffer pointed to by *ppbChainBuffer
   pdwPosition - position in buffer 

Returns:

   HRESULT indicating success/failure

--*/

{
    HCRYPTKEY hKey = NULL;
    HCRYPTPROV hProv = NULL;
    DWORD cbSpaceLeft = 0;
    DWORD cbPrivateKey = 0;
    DWORD cbPKInfo = 0;
    DWORD cbSpaceRequired = 0;
    HRESULT hRes = S_OK;

    //
    // Figure out how much space we need for the private key blob; bit of a lengthy
    // procedure - first get the arguments needed to get a handle to the key container,
    // get a handle to the key container, get a handle to the exchange key in the key
    // container and finally figure out the key size. 
    //
    CRYPT_KEY_PROV_INFO *pKeyProvInfo = NULL;
    DWORD dwProvSize = 0;
    BYTE *pbPKInfo = NULL;

    //
    // Determine how much space we need
    //
    if ( !CertGetCertificateContextProperty( pcCert,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             NULL,
                                             &dwProvSize ) &&
         GetLastError() != ERROR_MORE_DATA )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializePK;
    }

    pbPKInfo = new BYTE[dwProvSize];

    if ( !pbPKInfo )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializePK;
    }
    pKeyProvInfo = ( CRYPT_KEY_PROV_INFO *) pbPKInfo;

    //
    // Get the private key info
    //
    if ( !CertGetCertificateContextProperty( pcCert,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             pKeyProvInfo,
                                             &dwProvSize ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error getting key info : 0x%x\n", GetLastError() ) );
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializePK;
    }

    if ( !CryptAcquireContext( &hProv,
                               pKeyProvInfo->pwszContainerName,
                               pKeyProvInfo->pwszProvName,
                               pKeyProvInfo->dwProvType,
                               pKeyProvInfo->dwFlags ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error getting handle to CSP : 0x%x\n", GetLastError() ) );
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializePK;
    }

    if ( !CryptGetUserKey( hProv,
                           pKeyProvInfo->dwKeySpec,
                           &hKey ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error getting user key : 0x%x\n", GetLastError() ) );
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializePK;

    }

    if ( !CryptExportKey( hKey,
                          NULL, //BUGBUGBUG - this needs to be a real session key !
                          PRIVATEKEYBLOB,
                          0,
                          NULL,
                          &cbPrivateKey ) &&
         GetLastError() != ERROR_MORE_DATA )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error exporting key : 0x%x\n", GetLastError() ) );
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializePK;
    }

    
    cbPKInfo = SizeOfCKPI( pKeyProvInfo );


    cbSpaceRequired =  cbPrivateKey + 2 + //private key + bytes indicating length of key
                       cbPKInfo  + 2 ;  //private key container info + bytes indicating length
                
    cbSpaceLeft = *pdwBufferSize - *pdwPosition;


    if ( cbSpaceLeft < cbSpaceRequired && !ResizeBuffer( ppbChainBuffer,
                                                         cbSpaceRequired,
                                                         pdwPosition ) )
    {
        hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
        goto EndSerializePK;
    }

    //
    // Append the length of the private key blob
    //
    (*ppbChainBuffer)[(*pdwPosition)++] = MSB(cbPrivateKey);
    (*ppbChainBuffer)[(*pdwPosition)++] = LSB(cbPrivateKey);

    //
    // Add the private key
    //
    cbSpaceLeft = *pdwBufferSize - *pdwPosition;
    if ( !CryptExportKey( hKey,
                          NULL, //BUGBUG - this should be a real session key !
                          PRIVATEKEYBLOB,
                          0,
                          *ppbChainBuffer + *pdwPosition,
                          &cbSpaceLeft ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error exporting key : 0x%x\n", GetLastError() ) );
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndSerializePK;
    }
    (*pdwPosition) += cbSpaceLeft;

    //
    // Length of serialized CRYPT_KEY_PROV_INFO structure
    //
    (*ppbChainBuffer)[(*pdwPosition)++] = MSB(cbPKInfo);
    (*ppbChainBuffer)[(*pdwPosition)++] = LSB(cbPKInfo);
    
    //
    // Add CRYPT_KEY_PROV_INFO structure
    //
    SerializeCKPI( *ppbChainBuffer + *pdwPosition,
                   pKeyProvInfo,
                   pdwPosition );


EndSerializePK:
    //
    //Cleanup
    //
    if ( hKey )
    {
        CryptDestroyKey( hKey );
    }

    if ( hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    if ( pbPKInfo )
    {
        delete [] pbPKInfo;
    }

    return hRes;
}


HRESULT DeserializeAndImportServerPK( IN OUT BYTE **ppbBuffer,
                                      IN BYTE *pbEnd,
                                      OUT HCRYPTKEY *phKey,
                                      OUT CRYPT_KEY_PROV_INFO *pCKPI )
/*++

Routine Description:

    Deserialize and import the private key for a server certificate.  

Arguments:

   ppbBuffer - pointer to pointer to buffer containing serialized private key; updated on success
   pbEnd - pointer to end of buffer, to avoid overruns
   phKey - pointer to key handle, updated on success
   pCKPI - pointer to CRYPT_KEY_PROV_INFO structure, updated on success
Returns:

   HRESULT indicating success/failure

--*/

{
    HRESULT hRes = S_OK;
    BYTE *pbPresent = *ppbBuffer;
    BYTE bMSB = 0;
    BYTE bLSB = 0;
    DWORD cbPrivateKey = 0;
    DWORD cbPKInfo = 0;
    BYTE *pbPrivateKey = NULL;
    HCRYPTPROV hProv = NULL;

    //
    // figure out length of private key
    //
    if ( pbEnd <= pbPresent + 2 ) //two byte header indicating length of private key
    {
        return REPL_INTERNAL_ERROR;
    }
    bMSB = *(pbPresent++);
    bLSB = *(pbPresent++);
    cbPrivateKey =  (DWORD) ( ( bMSB << 8 ) + bLSB );
    
    if ( cbPrivateKey <= 0  || pbEnd <= pbPresent + cbPrivateKey )
    {
        return REPL_INTERNAL_ERROR;
    }
    pbPrivateKey = pbPresent;
    pbPresent += cbPrivateKey;

    //
    //  extract private key container info
    //

    bMSB = *(pbPresent++);
    bLSB = *(pbPresent++);
    cbPKInfo =  (DWORD) ( ( bMSB << 8 ) + bLSB );

    if ( cbPKInfo <= 0 || pbEnd <= pbPresent + cbPKInfo )
    {
        return REPL_INTERNAL_ERROR;
    }

    if ( !DeserializeCKPI( &pbPresent,
                           pCKPI ) )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // clean out old key container
    //
    CryptAcquireContext( &hProv,
                         pCKPI->pwszContainerName,
                         pCKPI->pwszProvName,
                         pCKPI->dwProvType,
                         pCKPI->dwFlags | CRYPT_DELETEKEYSET );

    //
    // import private key
    //
    if ( CryptAcquireContext( &hProv,
                              pCKPI->pwszContainerName,
                              pCKPI->pwszProvName,
                              pCKPI->dwProvType,
                              pCKPI->dwFlags | CRYPT_NEWKEYSET ) )
    {
        if ( !CryptImportKey( hProv,
                              pbPrivateKey,
                              cbPrivateKey,
                              NULL,
                              CRYPT_EXPORTABLE,
                              phKey ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Error : 0x%x\n", GetLastError()));
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }
        else
        {
            //
            // Set the ACL on the private key
            //
            if ( !SetLocalSystemSecurityOnKeyContainer( hProv ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Error : 0x%x\n", GetLastError()));
                hRes = RETURNCODETOHRESULT( GetLastError() );
            }
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error : 0x%x\n", GetLastError()));
        hRes = RETURNCODETOHRESULT( GetLastError() );
    }

    //
    // Update
    //
    *ppbBuffer = pbPresent;

    return hRes;
}




HRESULT EncryptBuffer( IN HCRYPTKEY hKey,
                       IN OUT PBYTE *ppbReplicationInfo,
                       IN OUT DWORD *pdwBufferSize,
                       IN OUT DWORD *pdwPosition )
/*++

Routine Description:

   Encrypt the replication information

Arguments:

   hKey - handle to key used to encrypt the data
   ppbReplicationInfo - pointer to pointer to buffer that holds data to be encrypted
   pdwBufferSize - pointer to present buffer size
   pdwPosition - pointer to position in buffer

Returns:

   HRESULT indicating success/failure

--*/
{
#ifdef NO_ENCRYPTION

    return S_OK;

#else

    DWORD cbOut = *pdwPosition;
    HRESULT hRes = S_OK;

    //
    // Figure out the size of the buffer we need
    //
    CryptEncrypt( hKey,
                  NULL,
                  TRUE,
                  0,
                  NULL,
                  &cbOut,
                  0 );

    if ( *pdwBufferSize > cbOut ||
         ResizeBuffer( ppbReplicationInfo, cbOut, pdwBufferSize ) )
    {
        cbOut = *pdwPosition;

        if ( !CryptEncrypt( hKey,
                            NULL,
                            TRUE,
                            0,
                            *ppbReplicationInfo, //encryption is in-place
                            &cbOut,
                            *pdwPosition ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
        }
        else
        {
            *pdwPosition = cbOut;
        }
    }
    else
    {
        hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
    }

    return hRes;
#endif // NO_ENCRYPTION
}


HRESULT DecryptBuffer( IN HCRYPTKEY hKey,
                       IN PBYTE pbEncrypted,
                       IN DWORD cbEncrypted,
                       OUT BYTE **ppbDecrypted,
                       OUT BYTE **ppbEndDecrypted )
/*++

Routine Description:

   Encrypt the replication information

Arguments:

   hKey - handle to key to be used to decrypt the data
   pbEncrypted - buffer holding encrypted data
   cbEncrypted - size of buffer pointed to by pbEncrypted
   ppbDecrypted - pointer to pointer to buffer to hold decrypted data. Allocated by
   this function, caller has to clean it up by calling delete []
   ppbEndDecrypted - pointer to pointer to end of ppbDecrypted

Returns:

   HRESULT indicating success/failure

--*/
{
#ifdef NO_ENCRYPTION

    *ppbDecrypted = new BYTE[cbEncrypted];
    memcpy( *ppbDecrypted, pbEncrypted, cbEncrypted );
    *ppbEndDecrypted = (*ppbDecrypted) + cbEncrypted;
    return S_OK;

#else

    HRESULT hRes = S_OK;
    *ppbDecrypted = NULL;
    DWORD cbDecrypted = 0;

    //
    // Decryption is done in-place, so make a copy of the encrypted buffer
    //
    *ppbDecrypted = new BYTE[cbEncrypted];

    if ( !*ppbDecrypted )
    {
        return ( RETURNCODETOHRESULT( ERROR_OUTOFMEMORY ) );
    }
    memcpy( *ppbDecrypted, pbEncrypted, cbEncrypted );
    cbDecrypted = cbEncrypted;

    //
    // Decrypt the data
    //
    if ( !CryptDecrypt( hKey,
                        NULL,
                        TRUE,
                        0,
                        *ppbDecrypted,
                        &cbDecrypted ) )
    {
        memset( *ppbDecrypted, 0, cbEncrypted );
        delete [] *ppbDecrypted;

        return (GetLastError() != ERROR_SUCCESS) ? 
                    RETURNCODETOHRESULT( GetLastError() ) : E_FAIL;
    }
    else
    {
        *ppbEndDecrypted = *ppbDecrypted + cbDecrypted;
    }

    return hRes;
#endif //NO_ENCRYPTION
}



OPEN_CERT_STORE_INFO* AllocateCertStoreInfo()
/*++

Routine Description:

   Allocate and initialize the structure used to hold info about cert stores

Arguments:

   None

Returns:

   Allocated and initialized structure that should be cleaned up with a call to 
   DeallocateCertStoreInfo()

--*/
{
    OPEN_CERT_STORE_INFO *pStoreInfo = new OPEN_CERT_STORE_INFO;

    if ( pStoreInfo )
    {
        memset(pStoreInfo, 0, sizeof(OPEN_CERT_STORE_INFO));
    }

    return pStoreInfo;
}

VOID DeallocateCertStoreInfo( OPEN_CERT_STORE_INFO *pInfo )
/*++

Routine Description:

    Clean up the structure used to track information about a cert store

Arguments:

    pInfo - pointer to OPEN_CERT_STORE_INFO structure to be cleaned up

Returns:

   Nothing

--*/

{
    if ( !pInfo )
    {
        return ;
    }

    if ( pInfo->pszContainer )
    {
        delete [] pInfo->pszContainer;
        pInfo->pszContainer = NULL;
    }

    if ( pInfo->pszProvider )
    {
        delete [] pInfo->pszProvider;
        pInfo->pszProvider = NULL;
    }

    if ( pInfo->pszStoreName )
    {
        delete [] pInfo->pszStoreName;
        pInfo->pszStoreName = NULL;
    }

    if ( pInfo->hCertStore )
    {
        CertCloseStore( pInfo->hCertStore,
                        0 );
        pInfo->hCertStore = NULL;
    }

    delete pInfo;
}

LPWSTR mystrdup(LPWSTR pszIn IN)
/*++

Routine Description:

    Makes a copy of string passed in using new[]


Arguments:

    pszIn - string to be copied

Returns:

    Pointer to copy of string on success, NULL on failure

--*/
{
    DBG_ASSERT( pszIn );

    LPWSTR pszOut = new WCHAR[ (wcslen(pszIn) + 1 ) * sizeof(WCHAR)];

    if ( !pszOut )
    {
        return NULL;
    }

    memcpy( pszOut, pszIn, ( wcslen(pszIn) + 1 ) * sizeof( WCHAR ) );
    
    return ( pszOut );
} //mystrdup


BOOL MBPathHasCAPIInfo( IN IMSAdminBase *pMB,
                        METADATA_HANDLE hHandle,
                        IN LPCWSTR pszPath,
                        IN DWORD *adwProperties,
                        IN DWORD cProperties )
/*++

Routine Description:

    Checks whether the given MB path has info associated with it necessary to 
    reconstruct a particular CAPI structure eg certificate context, CTL context

Arguments:

     pMB - pointer to metabase object 
     hHandle - handle open for reading
     pszPath - path to where CAPI info would be stored, relative to hHandle
     adwProperties - array of metabase properties that must exist and be readable for the
     given CAPI object 
     cProperties - number of elements in pdwProperties array [ = 2 * # of properties]
Returns:

    TRUE if cert info exists, FALSE if not

--*/
{

    DBG_ASSERT( pMB );
    DBG_ASSERT( pszPath );

    BOOL fAllData = TRUE;
    HRESULT hRes;

    //
    // Iterate through each property, trying to retrieve it with a buffer size of zero;
    // If retrieving a property fails for any reason other than a buffer that's too 
    // small, assume the property doesn't exist
    //
    for (DWORD i = 0; i < cProperties/2; i++)
    {
        DWORD dwSize = 0;
        METADATA_RECORD mdr;

        MD_SET_DATA_RECORD( &mdr,
                            adwProperties[2 * i],
                            METADATA_NO_ATTRIBUTES,
                            IIS_MD_UT_SERVER,
                            adwProperties[2*i + 1],
                            NULL,
                            0 );

        hRes = pMB->GetData( hHandle,
                             pszPath,
                             &mdr,
                             &dwSize );

        if ( HRESULTTOWIN32(hRes) !=  ERROR_INSUFFICIENT_BUFFER  )
        {
            fAllData = FALSE;
            break;
        }
    }

    return fAllData;
}


HRESULT GenerateHash( IN OPTIONAL HCRYPTPROV *phProv,
                      IN ALG_ID aiAlg,
                      IN PBYTE pbData,
                      IN DWORD cbData,
                      OUT BYTE **ppbHashBuffer,
                      OUT DWORD *pcbHash,
                      OUT OPTIONAL HCRYPTHASH *phHash )
/*++

Routine Description:

    Generates a hash of input data

Arguments:

     phProv - pointer to provider to be used; can be set to NULL
     aiAlg - hash algorithm to use
     pbData - buffer of data to be hashed
     cbData - size of data to be hashed
     ppbHashBuffer - pointer to pointer to buffer that receives the actual hash
     pcbHash - pointer to size of *ppbHashBuffer
     phHash - pointer to CRYPTHASH object, updated on sucess, ignored if NULL

Returns:

     HRESULT indicating success/failure

--*/

{
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    HRESULT hRes = S_OK;
    DWORD cbSize = 0;

    if ( !phProv )
    {
        //
        // Get a handle to the CSP that will create the
        // hash
        if ( !CryptAcquireContext( &hProv,
                                   NULL,
                                   NULL,
                                   PROV_RSA_FULL,
                                   CRYPT_VERIFYCONTEXT ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto EndCreateHash;
        }
    }
    else
    {
        hProv = *phProv;
    }

    //
    // Get a handle to a  hash object
    //
    if ( !CryptCreateHash( hProv,
                           aiAlg,
                           0,
                           0,
                           &hHash ) )
    {
      hRes = RETURNCODETOHRESULT( GetLastError() );  
      goto EndCreateHash;
    }

    //
    // Hash the data
    //
    if ( !CryptHashData( hHash,
                         pbData,
                         cbData,
                         0 ) )
    {
        hRes =  RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }


    //
    // Retrieve the size of the hash
    //
    cbSize = sizeof(DWORD);
    if ( !CryptGetHashParam( hHash,
                             HP_HASHSIZE,
                             (BYTE *) pcbHash,
                             &cbSize,
                             0 ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }

    DBG_ASSERT( *pcbHash > 0 );

    *ppbHashBuffer = new BYTE[*pcbHash];

    if ( !*ppbHashBuffer )
    {
        hRes = RETURNCODETOHRESULT( ERROR_OUTOFMEMORY );
        goto EndCreateHash;
    }


    //
    // Retrieve the actual hashed data 
    //
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             *ppbHashBuffer,
                             pcbHash,
                             0 ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }

    if ( phHash )
    {
        *phHash = hHash;
    }

EndCreateHash:

    //
    //Cleanup
    //
    if ( hRes != S_OK )
    {
        if ( *ppbHashBuffer )
        {
            delete [] *ppbHashBuffer;
        }
    }

    if ( !phHash && hHash )
    {
        CryptDestroyHash( hHash );
    }

    if ( !phProv && hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    return hRes;
}


HRESULT GenerateMD5Hash( IN OPTIONAL HCRYPTPROV *phProv,
                         IN PBYTE pbData,
                         IN DWORD cbData,
                         OUT PBYTE pbHashBuffer,
                         IN OUT DWORD *pdwHashBufferSize,
                         OUT OPTIONAL HCRYPTHASH *pHashObj )
/*++

Routine Description:

     Generates MD5 hash of data 

Arguments:

     phProv - pointer to provider to be used; can be set to NULL
     pbData - buffer of data to be hashed
     cbData - size of data to be hashed
     pbHashBuffer - buffer to receive hash
     pdwHashBufferSize - size of pbHashBuffer
     pHashObj - pointer to CRYPTHASH object, updated on sucess, ignored if NULL

Returns:

     HRESULT indicating success/failure

--*/

{
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    HRESULT hRes = S_OK;


    if ( !phProv )
    {
        //
        // Get a handle to the CSP that will create the
        // hash
        if ( !CryptAcquireContext( &hProv,
                                   NULL,
                                   NULL,
                                   PROV_RSA_FULL,
                                   CRYPT_VERIFYCONTEXT ) )
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            goto EndCreateHash;
        }
    }
    else
    {
        hProv = *phProv;
    }

    //
    // Get a handle to an MD5 hash object
    //
    if ( !CryptCreateHash( hProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
      hRes = RETURNCODETOHRESULT( GetLastError() );  
      goto EndCreateHash;
    }

    //
    // Hash the data
    //
    if ( !CryptHashData( hHash,
                         pbData,
                         cbData,
                         0 ) )
    {
        hRes =  RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }

    //
    // Retrieve the hash
    //
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pbHashBuffer,
                             pdwHashBufferSize,
                             0 ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }

    if ( pHashObj )
    {
        *pHashObj = hHash;
    }

EndCreateHash:

    //
    //Cleanup
    //
    if ( !pHashObj && hHash )
    {
        CryptDestroyHash( hHash );
    }

    if ( !phProv && hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    return hRes;
}
         

BOOL IsNumber( LPCWSTR pszName )
{
    return ( _wtoi( pszName) > 0 ? TRUE : FALSE );
}

VOID SerializeCKPI( OUT BYTE *pbBuffer,
                    IN CRYPT_KEY_PROV_INFO *pInfo,
                    OUT DWORD *pdwPosition )
/*++

Routine Description:

     Serializes a CRYPT_KEY_PROV_INFO structure 

Arguments:

    pbBuffer - pointer to buffer that holds serialized info
    pInfo - pointer to CRYPT_KEY_PROV_INFO structure to be serialized
    pdwPosition - position in pbBuffer, updated after serialization

Returns:

    Nothing

--*/
{
    DWORD cbPos = 0;
    BYTE bMSB = 0;
    BYTE bLSB = 0;
    DWORD cbStr = 0;

    //
    // First bit : [MSB of length][LSB of length][pwszContainerName]
    //
    if ( pInfo->pwszContainerName )
    {
        cbStr = wcslen( pInfo->pwszContainerName ) * sizeof(WCHAR) + 2 ; //trailing nulls
        pbBuffer[cbPos++] = MSB(cbStr);
        pbBuffer[cbPos++] = LSB(cbStr);
        memcpy( pbBuffer + cbPos, pInfo->pwszContainerName, cbStr);
        cbPos += cbStr;
    }
    else
    {
        pbBuffer[cbPos++] = 0;
        pbBuffer[cbPos++] = 0;
    }

    //
    // [MSB of length][LSB of length][pwszProvName]
    //
    if ( pInfo->pwszProvName )
    {
        cbStr = wcslen( pInfo->pwszProvName ) * sizeof(WCHAR) + 2 ; //trailing nulls
        pbBuffer[cbPos++] = MSB(cbStr);
        pbBuffer[cbPos++] = LSB(cbStr);
        memcpy( pbBuffer + cbPos, pInfo->pwszProvName, cbStr);
        cbPos += cbStr;
    }
    else
    {
        pbBuffer[cbPos++] = 0;
        pbBuffer[cbPos++] = 0;
    }
    
    
    //
    // dwProvType
    //
    memcpy( pbBuffer + cbPos, &(pInfo->dwProvType), sizeof(DWORD) );
    cbPos += sizeof(DWORD);

    //
    // dwFlags
    //
    memcpy( pbBuffer + cbPos, &(pInfo->dwFlags), sizeof(DWORD) );
    cbPos += sizeof(DWORD);
    
    //
    // cProvParam
    //
    memcpy( pbBuffer + cbPos, &(pInfo->cProvParam), sizeof(DWORD) );
    cbPos += sizeof(DWORD);

    //
    // Each of the rgProvParam entries
    //
    for ( DWORD dwIndex = 0; dwIndex < pInfo->cProvParam; dwIndex++ )
    {
        CRYPT_KEY_PROV_PARAM ckpParam = pInfo->rgProvParam[dwIndex];

        //
        // dwParam
        //
        memcpy( pbBuffer + cbPos, &(ckpParam.dwParam), sizeof(DWORD) );
        cbPos += sizeof(DWORD);

        //
        // cbData
        //
        memcpy( pbBuffer + cbPos, &(ckpParam.cbData), sizeof(DWORD) );
        cbPos += sizeof(DWORD);
        
        //
        // pbData
        //
        memcpy( pbBuffer + cbPos, ckpParam.pbData, ckpParam.cbData );
        cbPos += ckpParam.cbData;

        //
        // dwFlags
        //
        memcpy( pbBuffer + cbPos, &(ckpParam.dwFlags), sizeof(DWORD) );
        cbPos += sizeof(DWORD);
    }

    //
    // dwKeySpec
    //
    memcpy( pbBuffer + cbPos, &(pInfo->dwKeySpec), sizeof(DWORD) );
    cbPos += sizeof(DWORD);
    
    (*pdwPosition) += cbPos;
}

BOOL DeserializeCKPI( IN OUT BYTE **ppbBuffer,
                      OUT CRYPT_KEY_PROV_INFO *pInfo )
/*++

Routine Description:

     Deserializes a CRYPT_KEY_PROV_INFO structure

Arguments:

     pBuffer - pointer to pointer to buffer containing serialized information, updated while
     processing occurs
     ppInfo - pointer to CRYPT_KEY_PROV_INFO structure to be deserialized, updated during
     processing
     

Returns:

     TRUE if successful, FALSE if not

--*/

{
    BYTE bMSB = 0;
    BYTE bLSB = 0;
    DWORD dwLength;
    BYTE *pbPresent = *ppbBuffer;

    //
    // [MSB of length][LSB of length][pwszContainerName]
    //
    bMSB = *(pbPresent++);
    bLSB = *(pbPresent++);
    dwLength = LENGTH( bMSB, bLSB );

    if ( dwLength )
    {
        pInfo->pwszContainerName = (LPWSTR) pbPresent;
        pbPresent += dwLength;
    }
    else
    {
        pInfo->pwszContainerName = NULL;
    }

    //
    // [MSB of length][LSB of length][pwszProvName]
    //
    bMSB = *(pbPresent++);
    bLSB = *(pbPresent++);
    dwLength = LENGTH( bMSB, bLSB );

    if ( dwLength )
    {
        pInfo->pwszProvName = (LPWSTR) pbPresent;
        pbPresent += dwLength;
    }
    else
    {
        pInfo->pwszProvName = NULL;
    }
    
    //
    // dwProvType
    //
    pInfo->dwProvType = *( (DWORD *) pbPresent );
    pbPresent += sizeof(DWORD);


    //
    // dwFlags
    //
    pInfo->dwFlags = *( (DWORD *) pbPresent );
    pbPresent += sizeof(DWORD);

    //
    // cProvParam
    //
    pInfo->cProvParam = *( (DWORD *) pbPresent );
    pbPresent += sizeof(DWORD);


    //
    // Each of the rgProvParam entries
    //
    if ( pInfo->cProvParam )
    {
        pInfo->rgProvParam = new CRYPT_KEY_PROV_PARAM[pInfo->cProvParam];

        if ( !pInfo->rgProvParam )
        {
            return FALSE;
        }

        for ( DWORD dwIndex = 0; dwIndex < pInfo->cProvParam; dwIndex++ )
        {
            CRYPT_KEY_PROV_PARAM ckpParam = pInfo->rgProvParam[dwIndex];
            
            ckpParam.dwParam = *((DWORD *) pbPresent);
            pbPresent += sizeof(DWORD);

            ckpParam.cbData = *((DWORD *) pbPresent);
            pbPresent += sizeof(DWORD);

            ckpParam.pbData = pbPresent;
            pbPresent += ckpParam.cbData;

            ckpParam.dwFlags = *((DWORD *) pbPresent);
            pbPresent += sizeof(DWORD);
        }
    }
    else
    {
        pInfo->rgProvParam = NULL;
    }

    //
    // dwKeySpec
    //
    pInfo->dwKeySpec = *( (DWORD *) pbPresent);
    pbPresent += sizeof(DWORD);

    //
    // Update
    //
    *ppbBuffer = pbPresent;
    return TRUE;
}


DWORD SizeOfCKPI( IN CRYPT_KEY_PROV_INFO *pInfo )
/*++

Routine Description:

     Calculates the amount of space needed to contain the information for 
     a key container 

Arguments:

     pInfo - pointer to CRYPT_KEY_PROV_INFO structure whose space requirements are to
     be calculated

Returns:

     Number of bytes required to hold CRYPT_KEY_PROV_INFO structure 

--*/

{
    if ( !pInfo )
    {
        return 0;
    }

    DWORD cb = 0;
    
    if ( pInfo->pwszContainerName )
    {
        //trailing nulls, length bytes
        cb += ( wcslen(pInfo->pwszContainerName) * sizeof(WCHAR) ) + 2 + 2; 
    }
    else
    {
        cb += 2; //length bytes
    }

    if ( pInfo->pwszProvName )
    {
        //trailing nulls, length bytes
        cb += ( wcslen(pInfo->pwszProvName) * sizeof(WCHAR) ) + 2 + 2; 
    }
    else
    {
        cb += 2; //length bytes
    }

    cb += 4*sizeof(DWORD); // cProvParam, dwProvType, dwFlags, dwKeySpec

    for ( DWORD dwIndex = 0 ; dwIndex < pInfo->cProvParam; dwIndex++ )
    {
        cb += ( pInfo->rgProvParam[dwIndex].cbData + 3 * sizeof(DWORD) ); 
    }

    return cb;
}

HRESULT DistributeCerts( IN HCERTSTORE hMemStore,
                         IN BYTE *rgbCertHash,
                         IN PCRYPT_KEY_PROV_INFO pCKPI )
/*++

Routine Description:

     Takes the certs in an in-memory store and distributes them to the appropriate 
     system stores.
     
     Self-signed certs go into the ROOT store, intermediate certs into the CA store and the 
     server cert into the MY store. It's possible that the server cert is self-signed, in 
     which case it goes into both the ROOT and MY stores.

Arguments:

     hMemStore - handle to in-memory store containing certs to be distributed
     rgbCertHash - buffer containing hash of server cert
     hServerPK - private key for server certificate

Returns:

     HRESULT indicating success/failure

--*/

{
    HCERTSTORE hMyStore = NULL;
    HCERTSTORE hCAStore = NULL;
    HCERTSTORE hRootStore = NULL;
    HRESULT hRes = S_OK;

    //
    // Open all the stores we'll use
    //
    hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                              0,
                              NULL,
                              CERT_SYSTEM_STORE_LOCAL_MACHINE,
                              MY_STORE_NAME );

    if ( !hMyStore )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }


    hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                              0,
                              NULL,
                              CERT_SYSTEM_STORE_LOCAL_MACHINE,
                              CA_STORE_NAME );
    
    if ( !hCAStore )
    {
        CertCloseStore( hMyStore,
                        0 );
        return RETURNCODETOHRESULT( GetLastError() );
    }
    
    hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                ROOT_STORE_NAME );
    
    if ( !hRootStore )
    {
        CertCloseStore( hMyStore,
                        0 );
        
        CertCloseStore( hCAStore,
                        0 );
        return RETURNCODETOHRESULT( GetLastError() );
    }
    

    //
    // Iterate through all the certs in the in-memory store, putting them into the 
    // appropriate place 
    //
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pPrevCert = NULL;
    
    while ( pCert = CertEnumCertificatesInStore( hMemStore,
                                                 pPrevCert ) )
    {
        BOOL fSelfSigned = FALSE;
        BOOL fServerCert = FALSE;
        
        //
        // Self-signed certs go into the Root store
        //
        if ( IsSelfSignedCert( pCert ) )
        {
            fSelfSigned = TRUE;
            
            if ( !CertAddCertificateContextToStore( hRootStore,
                                                    pCert,
                                                    CERT_STORE_ADD_NEW,
                                                    NULL ) &&
                 GetLastError() != CRYPT_E_EXISTS )
            {
                hRes = RETURNCODETOHRESULT( GetLastError() );
                break;
            }
        }
        
        //
        // Server cert goes into MY store
        //
        if ( CertMatchesHash( pCert, 
                              rgbCertHash,
                              &fServerCert) )
        {
            if ( fServerCert )
            {
                //
                // Add private key to cert context and stuff cert into MY store
                //
                if ( !CertSetCertificateContextProperty( pCert,
                                                         CERT_KEY_PROV_INFO_PROP_ID,
                                                         0,
                                                         (PVOID) pCKPI ) ||
                     !CertAddCertificateContextToStore( hMyStore,
                                                        pCert,
                                                        CERT_STORE_ADD_REPLACE_EXISTING,
                                                        NULL ) )
                {
                    hRes = RETURNCODETOHRESULT( GetLastError() );
                    break;
                }
            }
        }
        else
        {
            hRes = RETURNCODETOHRESULT( GetLastError() );
            break;
        }    
        
        //
        // Everything else goes into the CA store
        //
        if ( !fSelfSigned && !fServerCert )
        {
            if ( !CertAddCertificateContextToStore( hCAStore,
                                                    pCert,
                                                    CERT_STORE_ADD_NEW,
                                                    NULL ) &&
                 GetLastError() != CRYPT_E_EXISTS )
            {
                hRes = RETURNCODETOHRESULT( GetLastError() );
                break;
            }
        }
        
        pPrevCert = pCert;
    }
    
    //
    // clean up
    //
    if ( hMyStore )
    {
        CertCloseStore( hMyStore,
                        0 );
    }
    
    if ( hCAStore )
    {
        CertCloseStore( hCAStore,
                        0 );
    }
    
    if ( hRootStore )
    {
        CertCloseStore( hRootStore,
                        0 );
    }
    
    return hRes;
}


BOOL CertMatchesHash( IN PCCERT_CONTEXT pCert,
                      IN BYTE *rgbHash,
                      OUT BOOL *pfMatch)
/*++

Routine Description:

     Checks whether a cert has the same hash as the hash passed in

Arguments:

     pCert - cert to be checked
     rgbHash - hash pCert is to be checked against 
     pfMatch - bool that is set to TRUE if cert matches, FALSE if not

Returns:
 
     TRUE if check was successful, FALSE if not    

--*/
{
    *pfMatch = FALSE;
    BYTE rgbCertHash[SHA1_HASH_SIZE];
    DWORD dwSize = SHA1_HASH_SIZE;

    if ( CertGetCertificateContextProperty( pCert,
                                            CERT_SHA1_HASH_PROP_ID,
                                            rgbCertHash,
                                            &dwSize ) )
    {
        *pfMatch = ( memcmp( rgbCertHash, rgbHash, SHA1_HASH_SIZE ) ? FALSE : TRUE );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//////////////

CADMEXCOM_IMSAdminCryptoCapabilities::CADMEXCOM_IMSAdminCryptoCapabilities( 
    CADMEXCOM*  pAdmExCom
    )
{
    m_pAdmExCom = pAdmExCom;
    m_hSchannel = NULL;
    m_hSspi = NULL;
    m_fHasCredHandle = FALSE;
}


CADMEXCOM_IMSAdminCryptoCapabilities::~CADMEXCOM_IMSAdminCryptoCapabilities( )
{
    if ( m_fHasCredHandle )
    {
        m_pfnFreeCredentialsHandle( &m_hCred );
    }

    if ( m_hSchannel != NULL )
    {
        FreeLibrary( m_hSchannel );
    }

    if ( m_hSspi != NULL )
    {
        FreeLibrary( m_hSspi );
    }
}


HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminCryptoCapabilities::GetProtocols( 
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    SecPkgCred_SupportedProtocols   SupportedProtocols;
    SECURITY_STATUS                 scRet;

    *pdwMDRequiredBufferSize = sizeof(DWORD);

    if ( dwBufferSize < sizeof(DWORD) )
    {
        return RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
    }

    if ( !LoadSchannel() )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    if ( FAILED( scRet = m_pfnQueryCredentialsAttributes( &m_hCred, 
                                                      SECPKG_ATTR_SUPPORTED_PROTOCOLS, 
                                                      &SupportedProtocols ) ) )
    {
        return scRet;
    }

    *(LPDWORD)pbBuffer = SupportedProtocols.grbitProtocol;

    return S_OK;
}


BOOL 
CADMEXCOM_IMSAdminCryptoCapabilities::LoadSchannel()
{
    SECURITY_STATUS             scRet;
    TimeStamp                   tsExpiry;
    OSVERSIONINFO               osv;
    BOOL                        fT;
    BOOL                        fWinNT;

    if ( m_hSchannel == NULL )
    {
        // Check the OS we are running on
        osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        fT = GetVersionEx( &osv );
        fWinNT = ( osv.dwPlatformId == VER_PLATFORM_WIN32_NT );

        if ( (m_hSchannel = LoadLibrary(L"schannel.dll")) != NULL )
        {
            m_pfnGetDefaultIssuers = (PFN_SSLGETDEFAULTISSUERS)GetProcAddress( m_hSchannel, 
                    "SslGetDefaultIssuers" );

            if ( m_pfnGetDefaultIssuers &&
                 ((m_hSspi = LoadLibrary( fWinNT ? L"security.dll" : L"secur32.dll" )) != NULL) )
            {
                m_pfnAcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN_W)
                            GetProcAddress( m_hSspi, "AcquireCredentialsHandleW" );
                m_pfnFreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN)
                            GetProcAddress( m_hSspi, "FreeCredentialsHandle" );
                m_pfnFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)
                            GetProcAddress( m_hSspi, "FreeContextBuffer" );
                m_pfnQueryCredentialsAttributes = (QUERY_CREDENTIALS_ATTRIBUTES_FN)
                            GetProcAddress( m_hSspi, "QueryCredentialsAttributesA" );

                if ( m_pfnAcquireCredentialsHandle &&
                     m_pfnFreeCredentialsHandle &&
                     m_pfnFreeContextBuffer &&
                     m_pfnQueryCredentialsAttributes )
                {
                    scRet = m_pfnAcquireCredentialsHandle(  
                                                        NULL,               // My name (ignored)
                                                        UNISP_NAME_W,       // Package
                                                        SECPKG_CRED_INBOUND,// Use
                                                        NULL,               // Logon Id (ign.)
                                                        NULL,               // auth data
                                                        NULL,               // dce-stuff
                                                        NULL,               // dce-stuff
                                                        &m_hCred,           // Handle
                                                        &tsExpiry );

                    if ( !FAILED(scRet) )
                    {
                        m_fHasCredHandle = TRUE;
                        return TRUE;
                    }
                }

                FreeLibrary( m_hSspi );
                m_hSspi = NULL;
            }

            FreeLibrary( m_hSchannel );
            m_hSchannel = NULL;
        }

        return FALSE;
    }

    return TRUE;
}


HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminCryptoCapabilities::GetMaximumCipherStrength( 
    /* [out] */ LPDWORD pdwMaximumCipherStrength )
{
    SecPkgCred_CipherStrengths  CipherStrengths;
    SECURITY_STATUS             scRet;

    if ( !LoadSchannel() )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    if ( FAILED( scRet = m_pfnQueryCredentialsAttributes( &m_hCred, 
                                                      SECPKG_ATTR_CIPHER_STRENGTHS, 
                                                      &CipherStrengths ) ) )
    {
        return scRet;
    }

    *pdwMaximumCipherStrength = CipherStrengths.dwMaximumCipherStrength;

    return S_OK;
}


HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminCryptoCapabilities::GetRootCertificates( 
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    DWORD   dwLen;

    if ( !LoadSchannel() ||
         !m_pfnGetDefaultIssuers( NULL, &dwLen ) )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    if ( dwBufferSize < dwLen )
    {
        *pdwMDRequiredBufferSize = dwLen;
        return RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
    }

    if ( m_pfnGetDefaultIssuers( pbBuffer, &dwLen ) )
    {
        *pdwMDRequiredBufferSize = dwLen;
        return S_OK;
    }

    return RETURNCODETOHRESULT( GetLastError() );
}


HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminCryptoCapabilities::GetSupportedAlgs( 
    /* [in] */ DWORD dwBufferSize,
    /* [size_is][out] */ DWORD __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    DWORD                       dwLen;
    SecPkgCred_SupportedAlgs    SupportedAlgs;
    SECURITY_STATUS             scRet;

    if ( !LoadSchannel() )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    if ( FAILED( scRet = m_pfnQueryCredentialsAttributes( &m_hCred, 
                                                      SECPKG_ATTR_SUPPORTED_ALGS, 
                                                      &SupportedAlgs ) ) )
    {
        return scRet;
    }

    *pdwMDRequiredBufferSize = sizeof(ALG_ID) * SupportedAlgs.cSupportedAlgs;

    if ( dwBufferSize < *pdwMDRequiredBufferSize )
    {
        return RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
    }

    memcpy( pbBuffer, SupportedAlgs.palgSupportedAlgs, *pdwMDRequiredBufferSize );

    return S_OK;
}


HRESULT STDMETHODCALLTYPE 
CADMEXCOM_IMSAdminCryptoCapabilities::SetCAList( 
        /*[in] */ DWORD dwBufferSize,
        /*[in, size_is(dwBufferSize)] */ unsigned char __RPC_FAR *pbBuffer )
{
#if defined(USE_CAPI2)

    HCERTSTORE      hStore = NULL;
    HKEY            hKey = NULL;
    PCCERT_CONTEXT  pCtx;
    DWORD           cCert;
    PCCERT_CONTEXT* rgpCert;
    HRESULT         hRes = S_OK;
    DWORD           dwValueLen;

    //
    //  WARNING: this relies on a security hole in CAPI2, as we want to add certs to 
    //  ROOT store w/o any UI, and the only way to do this ( at least currently ) is
    //  to access the ROOT store as a registry store instead of system store.
    //  CAPI2 team may change this in the future, but they MUST provide a way to control
    //  the CA list used by schannel, currently in HKCU ROOT store.
    //

    if ( RegOpenKeyEx(
              HKEY_CURRENT_USER,
              L"Software\\Microsoft\\SystemCertificates\\ROOT",
              0,
              KEY_ALL_ACCESS,
              &hKey ) == ERROR_SUCCESS )
    {
        if ( (hStore = CertOpenStore( CERT_STORE_PROV_REG,
            0,
            NULL,
            0,
            (const void*)hKey )) == NULL )
        {
            RegCloseKey( hKey );
            hKey = NULL;
        }
    }

    if ( hStore )
    {
        //
        // delete existing certs
        //

        for ( pCtx = NULL, cCert = 0 ;
              pCtx = CertEnumCertificatesInStore( hStore, pCtx ) ; )
        {
            ++cCert;
        }
        if ( cCert && ( rgpCert = (PCCERT_CONTEXT*)LocalAlloc( LMEM_FIXED, 
                    cCert * sizeof(PCCERT_CONTEXT) ) ) )
        {
            for ( pCtx = NULL, cCert = 0 ;
                  pCtx = CertEnumCertificatesInStore( hStore, pCtx ) ; )
            {
                rgpCert[cCert++] = pCtx;
            }
            while ( cCert-- )
            {
                CertDeleteCertificateFromStore( rgpCert[cCert] );
            }
            LocalFree( rgpCert );
        }
    }
    else
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
    }

    if ( SUCCEEDED( hRes ) )
    {
        //
        // deserialize certs
        //

        for ( ; dwBufferSize ; )
        {
            dwValueLen = *(LPDWORD)pbBuffer;

            if ( CertAddSerializedElementToStore( hStore,
                pbBuffer + sizeof(DWORD),
                dwValueLen,
                CERT_STORE_ADD_REPLACE_EXISTING,
                0,
                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                NULL,
                NULL ) == FALSE )
            {
                hRes = RETURNCODETOHRESULT( GetLastError() );
                break;
            }

            pbBuffer += sizeof(DWORD) + PAD4(dwValueLen);

            dwBufferSize -= sizeof(DWORD) + PAD4(dwValueLen);
        }
    }

    if ( hStore )
    {
        CertCloseStore( hStore, CERT_CLOSE_STORE_FORCE_FLAG );
        RegCloseKey( hKey );
    }

#else

    HKEY        hKey;
    int         iV;
    CHAR        achName[128];
    DWORD       dwNameLen;
    DWORD       dwValueLen;
    LPSTR       pszName;
    DWORD       dwType;
    HRESULT     hRes = S_OK;
    DWORD       dwErr;

    if ( (dwErr = RegOpenKeyEx( HKEY_CURRENT_USER,
                       "Software\\Microsoft\\SystemCertificates\\ROOT\\Certificates",
                       0,
                       KEY_WRITE|KEY_READ,
                       &hKey )) == ERROR_SUCCESS )
    {
        //
        // delete existing values
        //

        for ( iV = 0 ; ; /*++iV*/ )
        {
            dwNameLen = sizeof( achName );
            if ( RegEnumValue( hKey,
                               iV,
                               achName,
                               &dwNameLen,
                               NULL,
                               &dwType,
                               NULL,
                               NULL ) != ERROR_SUCCESS )
            {
                break;
            }

            if ( RegDeleteValue( hKey, achName ) != ERROR_SUCCESS )
            {
                hRes = RETURNCODETOHRESULT( GetLastError() );
                break;
            }
        }

        if ( SUCCEEDED( hRes ) )
        {
            for ( ; dwBufferSize ; )
            {
                dwNameLen = *(LPDWORD)pbBuffer;
                pszName = (LPSTR)(pbBuffer + sizeof(DWORD));
                dwValueLen = *(LPDWORD)(pbBuffer += sizeof(DWORD) + PAD4(dwNameLen));

                if ( RegSetValueEx( hKey, 
                                    (LPSTR)pszName,
                                    NULL,
                                    REG_BINARY,
                                    pbBuffer + sizeof(DWORD),
                                    dwValueLen ) != ERROR_SUCCESS )
                {
                    hRes = RETURNCODETOHRESULT( GetLastError() );
                    break;
                }

                pbBuffer += sizeof(DWORD) + PAD4(dwValueLen);

                dwBufferSize -= sizeof(DWORD) + PAD4(dwNameLen) + sizeof(DWORD) + PAD4(dwValueLen);
            }
        }

        RegCloseKey( hKey );
    }
    else
    {
        hRes = RETURNCODETOHRESULT( dwErr );
    }

#endif

    return hRes;
}


BOOL
SetLocalSystemSecurityOnKeyContainer( IN HCRYPTPROV hProv )
/*++

    The function applies security to the key containers associated
    with the HCRYPTPROV which is passed in such that only
    Local System has Full Control.  Note that the owner
    is not set, which results in a default owner of Administrators.

    NB : This function was inherited wholesale from Jeff Spelman [jeffspel] in the CAPI
    group.

--*/
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pLocalSystemSid = NULL;
    SECURITY_DESCRIPTOR sd;
    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce = NULL;
    DWORD dwAclSize = 0;
    LONG lRetCode = 0;
    BOOL bSuccess = FALSE; // assume this function fails

    //
    // prepare a Sid representing the Local System account
    //

    if( !AllocateAndInitializeSid( &sia,
                                   1,
                                   SECURITY_LOCAL_SYSTEM_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &pLocalSystemSid ) )
    {
        goto cleanup;
    }

    //
    // compute size of new acl
    //

    dwAclSize = sizeof(ACL) +
        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pLocalSystemSid) ;

    //
    // allocate storage for Acl
    //

    if ( !(pDacl = (PACL) new BYTE [dwAclSize]) )
    {
        goto cleanup;
    }

    if( !InitializeAcl( pDacl, 
                        dwAclSize, 
                        ACL_REVISION ) )
    {
        goto cleanup;
    }

    if( !AddAccessAllowedAce( pDacl,
                              ACL_REVISION,
                              KEY_ALL_ACCESS,
                              pLocalSystemSid ) )
    {
        goto cleanup;
    }

    //
    // make it container inherit.
    //

    if( !GetAce( pDacl, 
                 0, 
                 (LPVOID *) &pAce ) )
    {
        goto cleanup;
    }

    pAce->Header.AceFlags = CONTAINER_INHERIT_ACE;

    if( !InitializeSecurityDescriptor( &sd, 
                                       SECURITY_DESCRIPTOR_REVISION ) )
    {
        goto cleanup;
    }

    if( !SetSecurityDescriptorDacl( &sd, 
                                    TRUE, 
                                    pDacl, 
                                    FALSE ) ) 
    {
        goto cleanup;
    }

    //
    // apply the security descriptor to the key container
    //

    if ( !CryptSetProvParam( hProv,
                             PP_KEYSET_SEC_DESCR,
                             (BYTE*)&sd,
                             (DWORD)DACL_SECURITY_INFORMATION ) )  
    {
        goto cleanup;
    }

    bSuccess = TRUE; // indicate success

cleanup:

    //
    // free allocated resources
    //

    if( pDacl != NULL )
    {
        delete [] pDacl;
    }

    if( pLocalSystemSid != NULL )
    {
        FreeSid( pLocalSystemSid );
    }

    return bSuccess;
}


extern "C" BOOL WINAPI 
DllMain( 
    HANDLE hModule, 
    DWORD dwReason, 
    LPVOID pV
    )
/*++

Routine Description:

    DLL init/terminate notification function

Arguments:

    hModule  - DLL handle
    dwReason - notification type
    LPVOID   - not used

Returns:

    TRUE if success, FALSE if failure

--*/
{
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
#ifdef _NO_TRACING_
            CREATE_DEBUG_PRINT_OBJECT( "ADMEXS" );
#else
            CREATE_DEBUG_PRINT_OBJECT( "ADMEXS" , IisADMExsGuid);
#endif
            break;

        case DLL_PROCESS_DETACH:
            DELETE_DEBUG_PRINT_OBJECT( );
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Contains debug functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#if DBG

#include <windows.h>
#include <winnt.h>

#include <stdlib.h>
#include <stdio.h>
#include <debug.h>

DWORD GlobalDebugFlag = 0;
CRITICAL_SECTION GlobalDebugCritSect;

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    static BeginningOfLine = TRUE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //

    if ( DebugFlag != 0 && (GlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        length += (ULONG) sprintf( &OutputBuffer[length], "[Cache] "
    );

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP ) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
        case DEBUG_ERRORS:
            Text = "ERROR";
            break;

        case DEBUG_REGISTRY:
            Text = "LEASE";
            break;

        case DEBUG_MISC:
            Text = "MISC";
            break;

        case DEBUG_SCAVENGER:
            Text = "SCAVENGER";
            break;

        case DEBUG_SORT:
            Text = "SORT";
            break;

        case DEBUG_CONTAINER:
            Text = "CONTAINER";
            break;

        case DEBUG_APIS:
            Text = "APIS";
            break;

        case DEBUG_FILE_VALIDATE:
            Text = "FILE_VALIDATE";
            break;

        case DEBUG_MEM_ALLOC:
            Text = "MEM_ALLOC";
            break;

        default:
            Text = NULL;
            break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &GlobalDebugCritSect );

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    TcpsvcsDbgAssert(length <= MAX_PRINTF_LEN);


    //
    // Output to the debug terminal,
    //

    (void) DEBUG_PRINT( (PCH) OutputBuffer);

    LeaveCriticalSection( &GlobalDebugCritSect );
}

VOID
TcpsvcsDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    TcpsvcsDbgPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    TcpsvcsDbgPrint(( 0, "Assert Filename, %s \n", FileName ));
    TcpsvcsDbgPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    TcpsvcsDbgPrint(( 0, "Message is %s\n", Message ));

    DebugBreak();
}

#endif // DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\admex\secex\boot.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <admex.h>
#include <bootimp.hxx>


CAdmExt::CAdmExt()
{
}

CAdmExt::~CAdmExt()
{
}

HRESULT
CAdmExt::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IADMEXT) {
        *ppObject = (IADMEXT *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExt::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExt::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}


HRESULT STDMETHODCALLTYPE
CAdmExt::Initialize(void)
{
    InitComAdmindata( FALSE );

    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE
CAdmExt::EnumDcomCLSIDs(
    /* [size_is][out] */ CLSID *pclsid,
    /* [in] */ DWORD dwEnumIIDIndex)
{
    if ( dwEnumIIDIndex == 0 )
    {
        *pclsid = CLSID_MSCryptoAdmEx;
        return ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Terminate(void)
{
    TerminateComAdmindata();

    return ERROR_SUCCESS;
}


CAdmExtSrvFactory::CAdmExtSrvFactory()
    :m_admextObject()
{
    m_dwRefCount=0;
    g_dwRefCount = 0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_admextObject.AddRef();
}

CAdmExtSrvFactory::~CAdmExtSrvFactory()
{
    m_admextObject.Release();
}
HRESULT
CAdmExtSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_admextObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
            *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExtSrvFactory::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExtSrvFactory::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
    //    if (dwRefCount == 0) {
    //        delete this;
    //    }
    return dwRefCount;
}

STDAPI BootDllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{c4376b00-f87b-11d0-a6a6-00a0c922e752}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("IISAdmin Security Extension"),
                                 sizeof(TEXT("IISAdmin Security Extension")));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                "InprocServer32",
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(TEXT("ADMEXS.DLL"));
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if (dwReturn == ERROR_SUCCESS) {

        dwReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  IISADMIN_EXTENSIONS_REG_KEY
                                      TEXT("\\{c4376b00-f87b-11d0-a6a6-00a0c922e752}"),
                                  NULL,
                                  TEXT(""),
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);
        if (dwReturn == ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
        }

    }

    return HRESULT_FROM_WIN32(dwReturn);
}

STDAPI BootDllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwTemp;

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\{c4376b00-f87b-11d0-a6a6-00a0c922e752}\\InprocServer32"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                            TEXT("CLSID\\{c4376b00-f87b-11d0-a6a6-00a0c922e752}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
                          IISADMIN_EXTENSIONS_REG_KEY
                              TEXT("\\{c4376b00-f87b-11d0-a6a6-00a0c922e752}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    return HRESULT_FROM_WIN32(dwReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Contains data definitions for debug code.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

#ifdef __cplusplus
extern "C" {
#endif

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//
#define DEBUG_ERRORS            0x00000001  // hard errors.
#define DEBUG_REGISTRY          0x00000002  // debug registry calls
#define DEBUG_MISC              0x00000004  // misc info.
#define DEBUG_SCAVENGER         0x00000008  // scavenger debug info.

#define DEBUG_SORT              0x00000010  // debug B-TREE functions
#define DEBUG_CONTAINER         0x00000020  // debug container
#define DEBUG_APIS              0x00000040  // debug tcpsvcs apis
#define DEBUG_FILE_VALIDATE     0x00000080 // validate file map file
#define DEBUG_SVCLOC_MESSAGE    0x00000100  // discovery messages



//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_TIMESTAMP         0x00010000  // print time stamps
#define DEBUG_MEM_ALLOC         0x00020000 // memory alloc
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.

#if DBG

#define DEBUG_PRINT OutputDebugString

//
// debug functions.
//

extern DWORD GlobalDebugFlag;
extern CRITICAL_SECTION GlobalDebugCritSect;

#define IF_DEBUG(flag) if (GlobalDebugFlag & (DEBUG_ ## flag))
#define TcpsvcsDbgPrint(_x_) TcpsvcsDbgPrintRoutine _x_

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

VOID
TcpsvcsDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define TcpsvcsDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TcpsvcsDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

#else

#define IF_DEBUG(flag) if (FALSE)

#define TcpsvcsDbgPrint(_x_)
#define TcpsvcsDbgAssert(_x_)

#endif // DBG

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

#ifdef __cplusplus
}
#endif

#endif  // _DEBUG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\dllinit.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    accslib.h

Abstract:

    Proto type definitions for access product lib functions.

Author:

    Madan Appiah (madana) 11-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DLLINIT_
#define _DLLINIT_


DWORD
DllProcessAttachDomainFilter(
    VOID
    );

DWORD
DllProcessDetachDomainFilter(
    VOID
    );

DWORD
DllProcessAttachDiskCache(
    VOID
    );

DWORD
DllProcessDetachDiskCache(
    VOID
    );

#endif _DLLINIT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif


//
// global variables.
//

extern MEMORY *CacheHeap;


//
// svccom.cxx will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef  GLOBAL_SVC_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN BOOL GlobalSrvRegistered;
EXTERN MEMORY *SvclocHeap;
EXTERN EMBED_SERVER_INFO *GlobalSrvInfoObj;
EXTERN CRITICAL_SECTION GlobalSvclocCritSect;

EXTERN LPBYTE GlobalSrvRespMsg;
EXTERN DWORD GlobalSrvRespMsgLength;
EXTERN DWORD GlobalSrvAllotedRespMsgLen;

EXTERN LPBYTE GlobalSrvRecvBuf;
EXTERN DWORD GlobalSrvRecvBufLength;

EXTERN CHAR GlobalComputerName[MAX_COMPUTERNAME_LENGTH + 1 + 1];
    //
    // additional CHAR for win95, GetComputerName on win95
    // expects 16 char buffer always.
    //

//
// winsock data.
//

EXTERN WSADATA GlobalWinsockStartupData;
EXTERN BOOL GlobalWinsockStarted;
EXTERN BOOL GlobalRNRRegistered;

EXTERN HANDLE GlobalSrvListenThreadHandle;

EXTERN GUID GlobalSapGuid;
EXTERN fd_set GlobalSrvSockets;

EXTERN HANDLE GlobalCliDiscoverThreadHandle;

EXTERN LPBYTE GlobalCliQueryMsg;
EXTERN DWORD GlobalCliQueryMsgLen;

EXTERN fd_set GlobalCliSockets;
EXTERN fd_set GlobalCliNBSockets;
EXTERN SOCKET GlobalCliIpxSocket;

EXTERN LIST_ENTRY GlobalCliQueryRespList;

EXTERN HANDLE GlobalDiscoveryInProgressEvent;
EXTERN time_t GlobalLastDiscoveryTime;

EXTERN BYTE GlobalSapBroadcastAddress[];

EXTERN DWORD GlobalPlatformType;

EXTERN DWORD GlobalNumNBPendingRecvs;
EXTERN NCB *GlobalNBPendingRecvs;

EXTERN LIST_ENTRY GlobalWin31NBRespList;
EXTERN DWORD GlobalWin31NumNBResps;

#ifdef __cplusplus
}
#endif

#endif  // _GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_
#define _PROTO_

#ifdef __cplusplus
extern "C" {
#endif

//
// svccom.cxx
//

DWORD
MakeSapServiceName(
    LPSTR SapNameBuffer,
    DWORD SapNameBufferLen
    );

VOID
MakeUniqueServerName(
    LPBYTE StrBuffer,
    DWORD StrBufferLen,
    LPSTR ComputerName
    );

DWORD
ComputeCheckSum(
    LPBYTE Buffer,
    DWORD BufferLength
    );

BOOL
DLLSvclocEntry(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );

DWORD
DllProcessAttachSvcloc(
    VOID
    );

DWORD
DllProcessDetachSvcloc(
    VOID
    );

VOID
FreeServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    );

VOID
FreeServerInfo(
    LPINET_SERVER_INFO ServerInfo
    );

VOID
FreeServersList(
    LPINET_SERVERS_LIST ServersList
    );

BOOL
GetNetBiosLana(
    PLANA_ENUM pLanas
    );

BOOL
GetEnumNBLana(
    PLANA_ENUM pLanas
    );

BOOL
MakeNBSocketForLana(
    UCHAR Lana,
    PSOCKADDR  pSocketAddress,
    SOCKET *pNBSocket
    );

//
// svccli.cxx
//

DWORD
DiscoverIpxServers(
    LPSTR ServerName
    );

DWORD
DiscoverIpServers(
    LPSTR ServerName
    );

DWORD
ProcessSvclocQueryResponse(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    SOCKADDR *SourcesAddress,
    DWORD SourcesAddressLength
    );

VOID
ServerDiscoverThread(
    LPVOID Parameter
    );

DWORD
MakeClientQueryMesage(
    ULONGLONG ServicesMask
    );

DWORD
CleanupOldResponses(
    VOID
    );

DWORD
GetDiscoveredServerInfo(
    LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    LPINET_SERVER_INFO *ServerInfo
    );

DWORD
ProcessDiscoveryResponses(
    IN ULONGLONG ServicesMask,
    OUT LPINET_SERVERS_LIST *INetServersList
    );

DWORD
ReceiveResponses(
    WORD Timeout,
    BOOL WaitForAllResponses
    );

DWORD
DiscoverNetBiosServers(
    LPSTR ServerName
    );

DWORD
ReceiveNetBiosResponses(
    LPSVCLOC_NETBIOS_RESPONSE *NetBiosResponses,
    DWORD *NumResponses,
    DWORD TimeoutinMSecs,
    BOOL WaitForAllResponses
    );

//
// svcsrv.cxx
//

DWORD
MakeResponseBuffer(
    VOID
    );

DWORD
ServerRegisterAndListen(
    VOID
    );

DWORD
ProcessSvclocQuery(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    struct sockaddr *SourcesAddress,
    DWORD SourcesAddressLength
    );

VOID
SocketListenThread(
    LPVOID Parameter
    );

DWORD
ServerDeregisterAndStopListen(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif  // _PROTO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\reg.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    reg.cxx

Abstract:

    Contains code that implements REGISTRY_OBJ class defined in reg.hxx.

Author:

    Madan Appiah (madana)  19-Dec-1994

Environment:

    User Mode - Win32

Revision History:
    Sean Woodward (t-seanwo) 26-October-1997    ADSI Update

--*/

#include <svcloc.hxx>

MEMORY *CacheHeap = NULL;

INLINE
DWORD
REGISTRY_OBJ::GetValueSizeAndType(
    LPWSTR ValueName,
    LPDWORD ValueSize,
    LPDWORD ValueType
    )
/*++

Routine Description:

    This function returns the size and type of a value of this key.

Arguments:

    ValueName : name of the value whose size and type returned.

    ValueSize : pointer to a location where the value size is returned.

    ValueType : pointer to a location where the value type is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                ValueType,
                NULL,
                ValueSize );

    return( Error );
}


REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY Handle,
    DWORD Error
    )
/*++

Routine Description:

    This function is a inline function that initialize the registry
    object with given handle and status.

Arguments:

    Handle : registry object handle value.

    Error : registry object status value.

Return Value:

    None.

--*/
{
    _RegHandle = Handle;
    _Status = Error;
    _Index = 0;
    _ValIndex = 0;
    return;
};


REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY ParentHandle,
    LPWSTR KeyName
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry key
    handle and this object's keyname.

Arguments:

    ParentHandle : registry handle of the parent key.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    _Index = 0;
    _ValIndex = 0;
    _Status = RegOpenKeyExW(
                ParentHandle,
                KeyName,
                0,
                DEFAULT_KEY_ACCESS,
                &_RegHandle );

    if( _Status != ERROR_SUCCESS ) {
        _RegHandle = NULL;
    }

    return;
}

REGISTRY_OBJ::REGISTRY_OBJ(
    REGISTRY_OBJ *ParentObj,
    LPWSTR KeyName
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry object
    and this object's keyname.

Arguments:

    ParentObj : registry object of the parent.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    _Index = 0;
    _ValIndex = 0;
    _Status = RegOpenKeyExW(
                ParentObj->_RegHandle,
                KeyName,
                0,
                DEFAULT_KEY_ACCESS,
                &_RegHandle );

    if( _Status != ERROR_SUCCESS ) {
        _RegHandle = NULL;
    }

    return;
}

DWORD
REGISTRY_OBJ::Create(
    LPWSTR ChildName
    )
/*++

Routine Description:

    Creates a new subkey under this key.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    HKEY ChildHandle;
    DWORD KeyDisposition;

    _Status = RegCreateKeyExW(
               _RegHandle,
               ChildName,
               0,
               DEFAULT_CLASS,
               REG_OPTION_NON_VOLATILE,
               DEFAULT_KEY_ACCESS,
               NULL,
               &ChildHandle,
               &KeyDisposition );

    if( _Status != ERROR_SUCCESS ) {
        return( _Status );
    }

    if( KeyDisposition == REG_CREATED_NEW_KEY ) {
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%ws) is created.\n", ChildName ));
    }

    //
    // close the child handle before return.
    //

    RegCloseKey( ChildHandle );
    return( ERROR_SUCCESS );
}


DWORD
REGISTRY_OBJ::Create(
    LPWSTR ChildName,
    REGISTRY_OBJ **ChildObj
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;
    DWORD KeyDisposition;

    Error = RegCreateKeyExW(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                &KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( KeyDisposition == REG_CREATED_NEW_KEY ) {
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::Create(
    LPWSTR ChildName,
    REGISTRY_OBJ **ChildObj,
    DWORD *KeyDisposition
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

    ChildObj : pointer to a location where the child registry object
        pointer is returned.

    KeyDisposition : pointer to a location where the child KeyDisposition
        value is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;

    Error = RegCreateKeyExW(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    DWORD *Data
    )
/*++

Routine Description:

    Gets a REG_DWORD value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                (LPBYTE)Data,
                &ValueSize );

    TcpsvcsDbgAssert( ValueSize == sizeof( DWORD ) );
    TcpsvcsDbgAssert( ValueType == REG_DWORD );

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    LPWSTR *Data,
    DWORD *NumStrings
    )
/*++

Routine Description:

    Gets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE StringData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert(
        (ValueType == REG_SZ) ||
        (ValueType == REG_EXPAND_SZ) ||
        (ValueType == REG_MULTI_SZ) );

    StringData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( StringData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                StringData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( StringData );
        return( Error );
    }

    *Data = (LPWSTR)StringData;

    if( (ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ) ) {
        *NumStrings = 1;
    }
    else {

        DWORD Strings = 0;
        LPWSTR StrPtr = (LPWSTR)StringData;
        DWORD Len;

        while( (Len = wcslen(StrPtr)) != 0 ) {
            Strings++;
            StrPtr = StrPtr + Len + 1;
        }

        *NumStrings = Strings;
    }

    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    LPBYTE *Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE BinaryData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueType == REG_BINARY );

    BinaryData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( BinaryData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                BinaryData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( BinaryData );
        return( Error );
    }

    *Data = BinaryData;
    *DataLen = ValueSize;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

    Data : pointer to a buffer where the data will be read.

    Datalen : pointer to location where length of the above buffer is
        passed. On return this location will have the length of the
        data read.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPWSTR ValueName,
    LPDWORD Data
    )
/*++

Routine Description:

    Sets a REG_DWORD value.

Arguments:

    ValueName : name of the value being set.

    Date : pointer to a DWORD data.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueExW(
                _RegHandle,
                ValueName,
                0,
                REG_DWORD,
                (LPBYTE)Data,
                sizeof(DWORD) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPWSTR ValueName,
    LPWSTR Data,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueExW(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                sizeof(WCHAR) * (wcslen(Data) + 1) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPSTR ValueName,
    LPSTR Data,
    DWORD DataLen,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    DataLen : data length

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPWSTR ValueName,
    LPBYTE Data,
    DWORD DataLen
    )
/*++

Routine Description:

    Sets a REG_BINARY value.

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueExW(
                _RegHandle,
                ValueName,
                0,
                REG_BINARY,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextKey(
    LPWSTR Key,
    DWORD KeySize
    )
/*++

Routine Description:

    Retrieves the Next subkey name of this key.

Arguments:

    Key - pointer to a buffer that receives the subkey name.

    KeySize - size of the above buffer in CHARS.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD KeyLength;
    FILETIME KeyLastWrite;

    KeyLength = KeySize * sizeof(WCHAR);
    Error = RegEnumKeyExW(
                _RegHandle,
                _Index,
                Key,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( KeyLength <= KeySize );

    //
    // increament the index to point to the next key.
    //

    _Index++;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::DeleteKey(
    LPWSTR ChildKeyName
    )
/*++

Routine Description:

    Deletes a subkey node.

Arguments:

    ChildKeyName : name of the subkey to be deleted.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPWSTR GChildKeyName[MAX_KEY_SIZE];
    REGISTRY_OBJ ChildObj( _RegHandle, ChildKeyName );

    Error = ChildObj.GetStatus();

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // delete all its subkeys.
    //

    Error = ChildObj.FindFirstKey(
                (LPWSTR)GChildKeyName,
                MAX_KEY_SIZE );

    while( Error == ERROR_SUCCESS ) {

        Error = ChildObj.DeleteKey( (LPWSTR)GChildKeyName );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        Error = ChildObj.FindFirstKey(
                    (LPWSTR)GChildKeyName,
                    MAX_KEY_SIZE );
    }

    if( Error != ERROR_NO_MORE_ITEMS ) {
        return( Error );
    }

    //
    // delete this key.
    //

    Error = RegDeleteKeyW( _RegHandle, (LPWSTR)ChildKeyName );
    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextValue(
    LPSTR ValueName,
    DWORD ValueSize,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Retrieves the Next value name of this key.

Arguments:

    ValueName - pointer to a buffer that receives the Value name.

    ValueSize - size of the above buffer in CHARS.
    Data - pointer to a buffer that receives the Value data.
    DataLen - pointer to a buffer that receives data size.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueLength;
    DWORD ValueType;

    ValueLength = ValueSize * sizeof(CHAR);

    Error = RegEnumValue(
                _RegHandle,
                _ValIndex,
                ValueName,
                &ValueLength,
                NULL,                  // reserved.
                &ValueType,
                Data,
                DataLen );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueLength <= ValueSize );

    //
    // increment the value index to point to the next value.
    //

    _ValIndex++;
    return( ERROR_SUCCESS );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\svcapis.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcapis.cxx

Abstract:

    Contains code that implements the service location apis.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    Sean Woodward (t-seanwo) 26-October-1997    ADSI Update

--*/

#include <svcloc.hxx>

DWORD
WINAPI
INetDiscoverServers(
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API discovers all servers on the network that support and run the
    internet services  specified.

    This API is called by the client side code, such as the internet admin
    tool or wininet.dll.

Arguments:

    SevicesMask : A bit mask that specifies to discover servers with the
        these services running.

        ex: 0x0000000E, will discovers all servers running any of the
            following services :

                1. FTP_SERVICE
                2. GOPHER_SERVICE
                3. WEB_SERVICE

    DiscoverBindings : if this flag is set, this API talks to each of the
        discovered server and queries the services and bindings
        supported. If the flag is set to FALSE, it quickly returns with
        the list of servers only.

    WaitTime : Response wait time in secs. If this value is zero, it
        returns what ever discovered so far by the previous invocation of
        this APIs, otherwise it waits for the specified secs to collect
        responses from the servers.

    ServersList : Pointer to a location where the pointer to list of
        servers info is returned. The API allocates dynamic memory for
        this return data, the caller should free it by calling
        INetFreeDiscoverServerList after it has been used.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL SvcLockLocked = FALSE;

    //
    // WSAStartup().
    //

    LOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = TRUE;

    if ( !GlobalWinsockStarted ) {

        Error = WSAStartup( WS_VERSION_REQUIRED, &GlobalWinsockStartupData );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalWinsockStarted = TRUE;
    }

    //
    // make a discovery message, if it is not made before.
    //

    Error = MakeClientQueryMesage( ServicesMask );

    if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
    }

    //
    // now check to see the discovery is in progress.
    //

    DWORD EventState;
    EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, 0 );

    switch( EventState ) {
    case WAIT_OBJECT_0:
        break;

    case WAIT_TIMEOUT:

        //
        // discovery is in progress.
        //

        if( WaitTime == 0 ) {

            //
            // the caller does not want to wait, return available data.
            //

            goto ProcessResponse;

        }

        //
        // wait until the discovery is done or the specified delay is
        // over. Release global lock before wait, otherwise it will
        // get into a dead lock.
        //

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;

        EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, WaitTime * 1000 );

        switch( EventState ) {
        case WAIT_OBJECT_0:
        case WAIT_TIMEOUT:

            goto ProcessResponse;

        default:

            Error = GetLastError();
            goto Cleanup;
        }

    default:
        Error = GetLastError();
        goto Cleanup;
    }


    //
    // now check to see we have done the discovery recently. if so, don't
    // do discovery again, just return the available data.
    //

    time_t CurrentTime;

    CurrentTime = time( NULL );
    if( CurrentTime <
            GlobalLastDiscoveryTime + INET_DISCOVERY_RETRY_TIMEOUT ) {

        goto ProcessResponse;
    }

    //
    // reset GlobalDiscoveryInProgressEvent to signal that discovery is in
    // progress.
    //

    if( !ResetEvent( GlobalDiscoveryInProgressEvent ) ) {
        Error = GetLastError();
        goto Cleanup;
    }

    UNLOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = FALSE;

    //
    // send discovery query message to all IPX servers.
    //

    Error = DiscoverIpxServers( NULL );

    //
    // now send a message to IP servers.
    //

    DWORD Error1;

    if( GlobalPlatformType == VER_PLATFORM_WIN32_NT ) {

        Error1 = DiscoverIpServers( NULL );
            // discover using 1C group name.
    }
    else {

        Error1 = DiscoverNetBiosServers( NULL );
            // discover using 1C group name.
    }

    TcpsvcsDbgAssert( Error1 == ERROR_SUCCESS );

    //
    // if we have not successfully sent query message in either of the
    // protocol, simply bail out.
    //

    if( (Error != ERROR_SUCCESS) && (Error1 != ERROR_SUCCESS) ) {
         goto Cleanup;
    }

    if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

        //
        // for windows 3.1 we can't create thread so we discover in user
        // thread.
        //

        WaitTime = RESPONSE_WAIT_TIMEOUT;
    }

    if( WaitTime == 0 ) {

        //
        // if the client is not willing to wait, setup a thread that
        // receives query response.
        //

        LOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = TRUE;

        if( GlobalCliDiscoverThreadHandle == NULL ) {

            DWORD ThreadId;

            GlobalCliDiscoverThreadHandle =
                CreateThread(
                    NULL,       // default security
                    0,          // default stack size
                    (LPTHREAD_START_ROUTINE)ServerDiscoverThread,
                    NULL,          // no parameter
                    0,          // create flag, no suspend
                    &ThreadId );

            if( GlobalCliDiscoverThreadHandle  == NULL ) {
                Error = GetLastError();
                goto Cleanup;
            }

        }

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;
    }
    else {

        //
        // Wait for WaitTime secs for query responses
        // to arrive.
        //

        Error = ReceiveResponses( (WORD)WaitTime, TRUE );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

ProcessResponse:

    Error = ProcessDiscoveryResponses( ServicesMask, ServersList );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    if( SvcLockLocked ) {
        UNLOCK_SVC_GLOBAL_DATA();
    }

    return( Error );
}

DWORD
WINAPI
INetGetServerInfo(
    IN LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API returns the server info and a list of services supported by
    the server and lists of bindings supported by each of the services.

Arguments:

    ServerName : name of the server whose info to be queried.

    ServicesMask : services to be queried

    WaitTime : Time in secs to wait.

    ServerInfo : pointer to a location where the pointer to the server
        info structure will be returned. The caller should  call
        INetFreeServerInfo to free up the list after use.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL SvcLockLocked = FALSE;
    CHAR NBServerName[NETBIOS_NAME_LENGTH + 1];

    //
    // WSAStartup().
    //

    LOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = TRUE;

    if ( !GlobalWinsockStarted ) {

        Error = WSAStartup( WS_VERSION_REQUIRED, &GlobalWinsockStartupData );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalWinsockStarted = TRUE;
    }

    //
    // make a discovery message, if it is not made before.
    //

    Error = MakeClientQueryMesage( ServicesMask );

    if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
    }

    //
    // now check to see the discovery is in progress.
    //

    DWORD EventState;
    EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, 0 );

    switch( EventState ) {
    case WAIT_OBJECT_0:
        break;

    case WAIT_TIMEOUT:

        //
        // discovery is in progress.
        //

        if( WaitTime == 0 ) {

            //
            // the caller does not want to wait, return available data.
            //

            goto GetServerResponse;

        }

        //
        // wait until the discovery is done or the specified delay is
        // over. Release global lock before wait, otherwise it will
        // get into a dead lock.
        //

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;

        EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, WaitTime * 1000 );

        switch( EventState ) {
        case WAIT_OBJECT_0:
        case WAIT_TIMEOUT:

            goto GetServerResponse;

        default:

            Error = GetLastError();
            goto Cleanup;
        }

    default:
        Error = GetLastError();
        goto Cleanup;
    }


    //
    // now check to see we have done the discovery recently. if so, don't
    // do discovery again, just return the available data.
    //

    time_t CurrentTime;

    CurrentTime = time( NULL );
    if( CurrentTime <
            GlobalLastDiscoveryTime + INET_DISCOVERY_RETRY_TIMEOUT ) {

        goto GetServerResponse;
    }

    //
    // reset GlobalDiscoveryInProgressEvent to signal that discovery is in
    // progress.
    //

    if( !ResetEvent( GlobalDiscoveryInProgressEvent ) ) {
        Error = GetLastError();
        goto Cleanup;
    }

    UNLOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = FALSE;

    //
    // upper case the server name.
    //

    _strupr( ServerName );

    //
    // make unique server name.
    //

    MakeUniqueServerName(
        (LPBYTE)NBServerName,
        NETBIOS_NAME_LENGTH,
        ServerName );

    //
    // terminate the string.
    //

    NBServerName[ NETBIOS_NAME_LENGTH ] = '\0';

    //
    // send discovery query message to all IPX servers.
    //

    Error = DiscoverIpxServers( ServerName );

    //
    // now send a message to IP servers.
    //

    DWORD Error1;

    if( GlobalPlatformType == VER_PLATFORM_WIN32_NT ) {

        Error1 = DiscoverIpServers( NBServerName );
            // discover using specified server name.
    }
    else {

        Error1 = DiscoverNetBiosServers( NBServerName );
            // discover using specified server name.
    }

    TcpsvcsDbgAssert( Error1 == ERROR_SUCCESS );

    //
    // if we have successfully sent query message in either of the
    // protocol, simply bail out.
    //

    if( (Error != ERROR_SUCCESS) && (Error1 != ERROR_SUCCESS) ) {
         goto Cleanup;
    }

    if( WaitTime == 0 ) {

        //
        // if the client is not willing to wait, setup a thread that
        // receives query response.
        //

        LOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = TRUE;

        if( GlobalCliDiscoverThreadHandle == NULL ) {

            DWORD ThreadId;

            GlobalCliDiscoverThreadHandle =
                CreateThread(
                    NULL,       // default security
                    0,          // default stack size
                    (LPTHREAD_START_ROUTINE)ServerDiscoverThread,
                    NULL,          // no parameter
                    0,          // create flag, no suspend
                    &ThreadId );

            if( GlobalCliDiscoverThreadHandle  == NULL ) {
                Error = GetLastError();
                goto Cleanup;
            }

        }

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;
    }
    else {

        //
        // Wait for WaitTime secs for query responses
        // to arrive.
        //

        Error = ReceiveResponses( (WORD)WaitTime, FALSE );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

GetServerResponse:

    Error = GetDiscoveredServerInfo( ServerName, ServicesMask, ServerInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    if( SvcLockLocked ) {
        UNLOCK_SVC_GLOBAL_DATA();
    }

    return( Error );
}

VOID
WINAPI
INetFreeDiscoverServersList(
    IN OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the servers
    list by the INetDiscoverServers call.

Arguments:

    ServersList : pointer to a location where the pointer to the server
        list to be freed is stored.

Return Value:

    NONE.

--*/
{
    FreeServersList( *ServersList );
    *ServersList = NULL;
    return;
}

VOID
WINAPI
INetFreeServerInfo(
    IN OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the server
    info structure by the INetGetServerInfo call.

Arguments:

    ServerInfo : pointer to a location where the pointer to the server
        info structure to be freed is stored.

Return Value:

    NONE.

--*/
{
    FreeServerInfo( *ServerInfo );
    *ServerInfo = NULL;
    return;
}

DWORD
WINAPI
INetRegisterService(
    IN ULONGLONG ServiceMask,
    IN INET_SERVICE_STATE ServiceState,
    IN LPSTR ServiceComment,
    IN LPINET_BINDINGS Bindings
    )
/*++

Routine Description:

    This API registers an internet service.  The service writers should
    call this API just after successfully started the service and the
    service is ready to accept incoming RPC calls.  This API accepts an
    array of RPC binding strings that the service is listening on for the
    incoming RPC connections.  This list will be distributed to the
    clients that are discovering this service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

    ServiceState : State of the service, INetServiceRunning and
        INetServicePaused are valid states to pass.

    ServiceComment : Service comment specified by the admin.

    Bindings : list of bindings that are supported by the service. The
        bindings can be binding strings are those returned by the
        RpcBindingToStringBinding call or the sockaddrs.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    INET_SERVICE_INFO ServiceInfo;

    //
    // if the server object is not created, do so.
    //

    LOCK_SVC_GLOBAL_DATA();
#if 0
    if( GlobalSrvInfoObj ==  NULL ) {

        DWORD ComputerNameLength =  MAX_COMPUTERNAME_LENGTH + 1;

        //
        // read computer name.
        //

        if( !GetComputerNameA(
                GlobalComputerName,
                &ComputerNameLength ) ) {

            Error = GetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "GetComputerNameA failed, %ld.\n", Error ));
            goto Cleanup;
        }

        GlobalComputerName[ComputerNameLength] = '\0';

        GlobalSrvInfoObj = new EMBED_SERVER_INFO(
                                INET_MAJOR_VERSION, // major version number,
                                INET_MINOR_VERSION, // minor version number
                                GlobalComputerName );

        if( GlobalSrvInfoObj == NULL ) {
            goto Cleanup;
        }

        Error = GlobalSrvInfoObj->GetStatus();

        if( Error != ERROR_SUCCESS ) {

            delete GlobalSrvInfoObj;
            GlobalSrvInfoObj = NULL;

            goto Cleanup;
        }
    }
#endif // GlobalServerInfo object created

    //
    // allocate memory for the receive buffer, if it is not alotted before.
    //

    if( GlobalSrvRecvBuf == NULL ) {

        GlobalSrvRecvBuf =
            (LPBYTE)SvclocHeap->Alloc( SVCLOC_SRV_RECV_BUFFER_SIZE );

        if( GlobalSrvRecvBuf == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        GlobalSrvRecvBufLength = SVCLOC_SRV_RECV_BUFFER_SIZE;
    }

    //
    // check to see the server registered its location and it is listening
    // to the client discovery. If not do so.
    //

    if( !GlobalSrvRegistered ) {
        Error = ServerRegisterAndListen();

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalSrvRegistered = TRUE;
    }

    //
    // make a new service info.
    //

    ServiceInfo.ServiceMask = ServiceMask;
    ServiceInfo.ServiceState = ServiceState;
    ServiceInfo.ServiceComment = ServiceComment;
    ServiceInfo.Bindings = *Bindings;

    //
    // add this new service to server list.
    //

    Error = GlobalSrvInfoObj->AddService( &ServiceInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // make response buffer.
    //

    Error = MakeResponseBuffer();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

DWORD
WINAPI
INetDeregisterService(
    IN ULONGLONG ServiceMask
    )
/*++

Routine Description:

    This API de-registers an internet service from being announced to the
    discovering clients. The service writers should call this API just
    before shutting down the service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    INET_SERVICE_INFO ServiceInfo;

    //
    // remove the service if exists.
    //

    Error = GlobalSrvInfoObj->RemoveService( ServiceMask );

    if( Error != ERROR_SUCCESS ) {
        if( Error != ERROR_SERVICE_NOT_FOUND ) {
            return( Error );
        }

        Error = ERROR_SUCCESS;
    }

    //
    // add the service back to the list with service state set to
    // INetServiceStopped and no bindings.
    //

    ServiceInfo.ServiceMask = ServiceMask;
    ServiceInfo.ServiceState = INetServiceStopped;
    ServiceInfo.ServiceComment = NULL;
    ServiceInfo.Bindings.NumBindings = 0;
    ServiceInfo.Bindings.BindingsInfo = NULL;

    //
    // readd the service to server list.
    //

    Error = GlobalSrvInfoObj->AddService( &ServiceInfo );

    if( Error != ERROR_SUCCESS ) {

        DWORD LocalError;

        //
        // recreate response buffer.
        //

        LocalError = MakeResponseBuffer();
        TcpsvcsDbgAssert( LocalError == ERROR_SUCCESS );

        return( Error );
    }

    //
    // recreate response buffer.
    //

    Error = MakeResponseBuffer();

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\svcdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains data definitions for cache code.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <iisver.h>
#include <spxinfo.h>

#ifndef _SVCDEF_
#define _SVCDEF_

#ifdef __cplusplus
extern "C" {
#endif

//
// defines.
//

#define INET_MAJOR_VERSION       VER_IISMAJORVERSION
#define INET_MINOR_VERSION       VER_IISMINORVERSION

#define LOCK_SVC_GLOBAL_DATA()        EnterCriticalSection( &GlobalSvclocCritSect )
#define UNLOCK_SVC_GLOBAL_DATA()      LeaveCriticalSection( &GlobalSvclocCritSect )

#define SVCLOC_SRV_RECV_BUFFER_SIZE     0x400   // 1k buffer.
#define SVCLOC_SRV_ADDRESS_BUFFER       0x1000  // 4k buffer

#define SVCLOC_CLI_QUERY_RESP_BUF_SIZE  0x400   // 1 buffer

//
// service location thread shutdown timeout.
//

#define THREAD_TERMINATION_TIMEOUT      60000           // in msecs. 60 secs
#define RESPONSE_WAIT_TIMEOUT           60000           // in msecs. 60 secs


#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// the fields of the GUID, generated using uuidgen
//

#define ssgData1        0xa5569b20
#define ssgData2        0xabe5
#define ssgData3        0x11ce
#define ssgData41       0x9c
#define ssgData42       0xa4
#define ssgData43       0x00
#define ssgData44       0x00
#define ssgData45       0x4c
#define ssgData46       0x75
#define ssgData47       0x27
#define ssgData48       0x31

#define SERVICE_GUID_STR "A5569B20ABE511CE9CA400004C762832"

#define NETBIOS_INET_GROUP_NAME "INet~Services  \034"
#define NETBIOS_INET_GROUP_NAME_LEN \
    (sizeof(NETBIOS_INET_GROUP_NAME) - 1)

#define NETBIOS_INET_UNIQUE_NAME    "I~"
#define NETBIOS_INET_UNIQUE_NAME_LEN    \
    (sizeof(NETBIOS_INET_UNIQUE_NAME) - 1)

#define NETBIOS_INET_SERVER_UNIQUE_NAME    "IS~"
#define NETBIOS_INET_SERVER_UNIQUE_NAME_LEN    \
    (sizeof(NETBIOS_INET_SERVER_UNIQUE_NAME) - 1)

#define INET_SERVER_RESPONSE_TIMEOUT    15 * 60 // in secs.
#define INET_DISCOVERY_RETRY_TIMEOUT    5 * 60 // in secs.
#define SVCLOC_NB_RECV_TIMEOUT          2 * 60 // in secs.

#define SAP_SERVICE_NAME_LEN    (MAX_COMPUTERNAME_LENGTH + 32)
#define SAP_ADDRESS_LENGTH      15
#define IPX_ADDRESS_LENGTH      12
#define SAP_MAXRECV_LENGTH      544 // ??

//
// typedefs
//

//
// to form a list of server list.
//

typedef struct _LIST_SERVER_INFO {
    LIST_ENTRY NextEntry;
    INET_SERVER_INFO ServerInfo;
} LIST_SERVER_INFO, *LPLIST_SERVER_INFO;


typedef struct _CLIENT_QUERY_RESPONSE {
    LIST_ENTRY NextEntry;
    SOCKET ReceivedSocket;
    LPBYTE ResponseBuffer;
    DWORD ResponseBufferLength;
    SOCKADDR *SourcesAddress;
    DWORD SourcesAddressLength;
    time_t TimeStamp;
} CLIENT_QUERY_RESPONSE, *LPCLIENT_QUERY_RESPONSE;

typedef struct _CLIENT_QUERY_MESSAGE {
    DWORD MsgLength;
    DWORD MsgVersion;
    ULONGLONG ServicesMask;
    CHAR ClientName[1];    // embedded string.
} CLIENT_QUERY_MESSAGE, *LPCLIENT_QUERY_MESSAGE;

//
// Sap service query packet format
//

typedef struct _SAP_REQUEST {
    WORD QueryType;
    WORD ServerType;
} SAP_REQUEST, *PSAP_REQUEST;

//
// Sap server identification packet format
//

typedef struct _SAP_IDENT_HEADER {
    WORD ServerType;
    BYTE  ServerName[48];
    BYTE  Address[IPX_ADDRESS_LENGTH];
    WORD HopCount;
} SAP_IDENT_HEADER, *LPSAP_IDENT_HEADER;

typedef struct _SAP_ADDRESS_INFO {
    CHAR  ServerName[MAX_COMPUTERNAME_LENGTH+1];
    BYTE  Address[IPX_ADDRESS_LENGTH];
    WORD HopCount;
} SAP_ADDRESS_INFO, *LPSAP_ADDRESS_INFO;

typedef struct _SAP_ADDRESS_ENTRY {
    LIST_ENTRY Next;
    SAP_ADDRESS_INFO Address;
} SAP_ADDRESS_ENTRY, *LPSAP_ADDRESS_ENTRY;

typedef struct _SVCLOC_NETBIOS_RESPONSE {
    LPBYTE ResponseBuffer;
    DWORD ResponseBufLen;
    SOCKADDR_NB SourcesAddress;
    DWORD SourcesAddrLen;
} SVCLOC_NETBIOS_RESPONSE, *LPSVCLOC_NETBIOS_RESPONSE;

typedef struct _SVCLOC_NETBIOS_RESP_ENTRY {
    LIST_ENTRY Next;
    SVCLOC_NETBIOS_RESPONSE Resp;
} SVCLOC_NETBIOS_RESP_ENTRY, *LPSVCLOC_NETBIOS_RESP_ENTRY;

#ifdef __cplusplus
}
#endif


#endif  // _SVCDEF_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\svccli.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svccli.cxx

Abstract:

    Contains client side code of service location protocol.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    Sean Woodward (t-seanwo) 26-October-1997    ADSI Update

--*/

#include <svcloc.hxx>

//
// This is the IPX address we send to
//

BYTE GlobalSapBroadcastAddress[] = {
    AF_IPX, 0,                          // Address Family
    0x00, 0x00, 0x00, 0x00,             // Dest. Net Number
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Dest. Node Number
    0x04, 0x52,                         // Dest. Socket
    0x04                                // Packet type
};

VOID
GetNBUniqueName(
    LPSTR NBNameBuf,
    DWORD NBNameBufLen
    )
{
    LPSTR NamePtr =  NBNameBuf;
    LPSTR NameEndPtr =  NBNameBuf + NBNameBufLen;

    TcpsvcsDbgAssert( NBNameBufLen >
        sizeof(NETBIOS_INET_UNIQUE_NAME) + 1 );

    memcpy(
        NamePtr,
        NETBIOS_INET_UNIQUE_NAME,
        NETBIOS_INET_UNIQUE_NAME_LEN
        );

    NamePtr += NETBIOS_INET_UNIQUE_NAME_LEN;

    //
    // now append a random char.
    //

    DWORD RandNum;
    RandNum = (DWORD)rand();

    RandNum = RandNum % (26 + 10);  // 26 alphabets, and 10 numerics

    if( RandNum < 10 ) {
        *NamePtr = (CHAR)('0'+ RandNum);
    }
    else {
        *NamePtr = (CHAR)('A'+ RandNum - 10);
    }

    NamePtr++;

    TcpsvcsDbgAssert( GlobalComputerName[0] != '\0' );

    //
    // append computer name.
    //

    DWORD ComputerNameLen = strlen( GlobalComputerName );

    if( ComputerNameLen < (DWORD)(NameEndPtr - NamePtr) ) {

        memcpy(
            NamePtr,
            GlobalComputerName,
            ComputerNameLen );

        NamePtr += ComputerNameLen;

        //
        // fill the trailing chars with spaces.
        //

        memset( NamePtr, ' ', (NameEndPtr - NamePtr) );
    }
    else {

        memcpy(
            NamePtr,
            GlobalComputerName,
            (NameEndPtr - NamePtr) );
    }

    return;
}

DWORD
ProcessSapResponses(
    PLIST_ENTRY ResponseList,
    LPSAP_ADDRESS_INFO *SapAddresses,
    DWORD *NumSapAddresses
    )
{
    DWORD Error;
    PLIST_ENTRY Response;
    DWORD NumResponses;

    DWORD Size;
    LPSAP_ADDRESS_INFO Addresses = NULL;
    LPSAP_ADDRESS_INFO Address;

    //
    // compute number of entries in the list.
    //

    NumResponses = 0;
    for( Response = ResponseList->Flink;
            Response != ResponseList;
                Response = Response->Flink ) {
        NumResponses++;
    }

    TcpsvcsDbgAssert( NumResponses != 0 );

    if( NumResponses == 0 ) {

        *SapAddresses = NULL;
        *NumSapAddresses = 0;
        return( ERROR_SUCCESS );
    }

    //
    // allocate memory for return buffer.
    //

    Size = sizeof( SAP_ADDRESS_INFO ) * NumResponses;

    Addresses = (LPSAP_ADDRESS_INFO)
        SvclocHeap->Alloc( Size );

    if( Addresses == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    for( Address = Addresses, Response = ResponseList->Flink;
            Response != ResponseList;
                Address++, Response = Response->Flink ) {

        TcpsvcsDbgAssert( (LPBYTE)Address < (LPBYTE)Addresses + Size );

        *Address = ((LPSAP_ADDRESS_ENTRY)Response)->Address;
    }

    *SapAddresses = Addresses;
    *NumSapAddresses = NumResponses;
    Addresses = NULL;

    Error = ERROR_SUCCESS;

Cleanup:

    if( Addresses != NULL ) {
        SvclocHeap->Free( Addresses );
    }

    return( Error );
}

DWORD
ProcessSingleSapResponse(
    LPSAP_IDENT_HEADER SapResponse,
    PLIST_ENTRY ResponsesList
    )
{
    PLIST_ENTRY Response;
    CHAR ServerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPSTR ServerNamePtr;
    LPBYTE ServerAddress;

    TcpsvcsDbgAssert(SapResponse->ServerType == htons(INTERNET_SERVICE_SAP_ID));

    //
    // check GUID portion of the server name.
    //

    if( memcmp(
            SapResponse->ServerName +
                MAX_COMPUTERNAME_LENGTH,
            SERVICE_GUID_STR,
            32 ) != 0 ) {

        //
        // ignore this response.
        //

        TcpsvcsDbgPrint((
            DEBUG_ERRORS,
                "GetSapAddress() received unknown (GUID) response.\n" ));

        return( ERROR_SUCCESS );
    }

    //
    // server name portion.
    //

    memcpy(
        ServerName,
        SapResponse->ServerName,
        MAX_COMPUTERNAME_LENGTH );
    ServerName[MAX_COMPUTERNAME_LENGTH] = '\0';

    //
    // chop off padding.
    //

    ServerNamePtr = ServerName;
    while ( *ServerNamePtr != '\0' ) {
        if( *ServerNamePtr == '!' ) {
            *ServerNamePtr = '\0';
            break;
        }
        ServerNamePtr++;
    }

    ServerAddress = SapResponse->Address;

    //
    // find out if the server entry is already in the existing list.
    //

    for( Response = ResponsesList->Flink;
            Response != ResponsesList;
                Response = Response->Flink ) {

        LPSAP_ADDRESS_ENTRY ResponseEntry;

        ResponseEntry = (LPSAP_ADDRESS_ENTRY)Response;

        if( memcmp(
                ResponseEntry->Address.Address,
                ServerAddress,
                IPX_ADDRESS_LENGTH ) == 0 ) {

            return( ERROR_SUCCESS );
        }

        if( strcmp(
                ResponseEntry->Address.ServerName,
                ServerName ) == 0 ) {

            return( ERROR_SUCCESS );
        }
    }

    //
    // we have unique new entry.
    //

    //
    // allocate memory for the new response.
    //

    LPSAP_ADDRESS_ENTRY NewResponse;
    NewResponse = (LPSAP_ADDRESS_ENTRY)
        SvclocHeap->Alloc( sizeof(SAP_ADDRESS_ENTRY) );

    if( NewResponse == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    strcpy( (LPSTR)NewResponse->Address.ServerName, ServerName );

    memcpy(
        NewResponse->Address.Address,
        ServerAddress,
        IPX_ADDRESS_LENGTH );

    NewResponse->Address.HopCount = ntohs(SapResponse->HopCount);

    //
    // add this new entry to the list.
    //

    InsertTailList( ResponsesList, &NewResponse->Next );

    return( ERROR_SUCCESS );
}

DWORD
GetSapAddress(
    LPSAP_ADDRESS_INFO *SapAddresses,
    DWORD *NumSapAddresses
    )
/*++

Routine Description:

    This routine discovers all IPX servers by sending sap broadcast and
    filtering responses that match our GUID.

Arguments:

    SapAddresses - pointer to a location where the pointer to the
        addresses buffer is returned. The caller should free this buffer
        after use.

    NumSapAddresses - pointer a location where the number of addresses
        returned in the above buffer is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SOCKET SapSocket;
    SOCKADDR_IPX SapSocketAddr;
    SAP_REQUEST SapRequest;
    BYTE DestAddr[SAP_ADDRESS_LENGTH];
    LIST_ENTRY ResponsesList;

    InitializeListHead(&ResponsesList);

    //
    // create an IPX socket.
    //

    SapSocket = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );

    if ( SapSocket == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Set the socket to non-blocking
    //

    DWORD NonBlocking;
    NonBlocking = 1;

    if ( ioctlsocket( SapSocket, FIONBIO, &NonBlocking ) ==
            SOCKET_ERROR ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }
    //
    // Allow sending of broadcasts
    //

    DWORD Value;
    Value = 1;

    if ( setsockopt( SapSocket,
                SOL_SOCKET,
                SO_BROADCAST,
                (PCHAR) &Value,
                sizeof(INT)) == SOCKET_ERROR ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Bind the socket
    //

    memset( &SapSocketAddr, 0, sizeof( SOCKADDR_IPX));

    SapSocketAddr.sa_family = AF_IPX;
    SapSocketAddr.sa_socket = 0;      // no specific port

    if ( bind( SapSocket,
               (PSOCKADDR) &SapSocketAddr,
               sizeof( SOCKADDR_IPX)) == SOCKET_ERROR ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Set the extended address option
    //

    Value = 1;
    if ( setsockopt( SapSocket,                     // Socket Handle
                     NSPROTO_IPX,                   // Option Level
                     IPX_EXTENDED_ADDRESS,          // Option Name
                     (PCHAR)&Value,               // Ptr to on/off flag
                     sizeof(INT)) == SOCKET_ERROR ) {
                            // Length of flag
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Send the Sap query service packet
    //

    SapRequest.QueryType  = htons( 1 );  // General Service Query
    SapRequest.ServerType = htons(INTERNET_SERVICE_SAP_ID);

    //
    // Set the address to send to
    //

    memcpy( DestAddr, GlobalSapBroadcastAddress, SAP_ADDRESS_LENGTH );

    //
    // We will send out SAP requests 3 times and wait 1 sec for
    // Sap responses the first time, 1 sec the second and 3 sec the
    // third time. Once we get MAXSITES responses, we give up.
    // We also give up if after processing all replies from a send,
    // we find at least one DC in the search domain.
    //

    DWORD i;

#define SAP_DISCOVERY_RETRIES   1

    for ( i = 0; i < SAP_DISCOVERY_RETRIES; i++ ) {

        DWORD StartTickCount;
        DWORD TimeOut = (i + 1) * 1000;

        //
        // Send the packet out
        //

        if ( sendto( SapSocket,
                     (PCHAR) &SapRequest,
                     sizeof( SapRequest ),
                     0,
                     (PSOCKADDR) DestAddr,
                     SAP_ADDRESS_LENGTH ) == SOCKET_ERROR ) {
            Error = WSAGetLastError();
            goto Cleanup;
        }

        //
        // Loop for incoming packets
        //

        StartTickCount = GetTickCount();

        do {

            LPSAP_IDENT_HEADER SapResponse;
            DWORD BytesReceived;
            BYTE RecvBuffer[SAP_MAXRECV_LENGTH];

            Sleep(50);             // take a deep breath

            BytesReceived =
                recvfrom( SapSocket,
                        (PCHAR)RecvBuffer,
                        SAP_MAXRECV_LENGTH,
                        0,
                        NULL,
                        NULL );

            if ( BytesReceived == SOCKET_ERROR ) {

                Error = WSAGetLastError();

                if ( Error == WSAEWOULDBLOCK ) {

                    //
                    // no data on socket, continue looping
                    //

                    Error = ERROR_SUCCESS;
                    continue;
                }
            }

            if ( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // if socket closed, return.
            //

            if (  BytesReceived == 0 ) {
                goto ProcessResponse;
            }

            //
            // Skip over query type
            //

            BytesReceived -= sizeof(USHORT);
            SapResponse = (LPSAP_IDENT_HEADER)
                    ((LPBYTE)RecvBuffer + sizeof(USHORT));

            //
            // loop through and check all addresses.
            //

            while ( BytesReceived >= sizeof( SAP_IDENT_HEADER )) {

                Error = ProcessSingleSapResponse(
                                SapResponse,
                                &ResponsesList );

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                BytesReceived -= sizeof( SAP_IDENT_HEADER );
                SapResponse++;
            }

        } while((GetTickCount() - StartTickCount) < TimeOut );
    }

    //
    // Process response list.
    //

ProcessResponse :

    Error = ProcessSapResponses(
                    &ResponsesList,
                    SapAddresses,
                    NumSapAddresses );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // we are done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    closesocket( SapSocket );

    //
    // free response list if any.
    //

    while( !IsListEmpty( &ResponsesList ) ) {

        PLIST_ENTRY ListEntry;

        //
        // remove the head entry and free.
        //

        ListEntry = RemoveHeadList( &ResponsesList );
        SvclocHeap->Free( ListEntry );
    }

    return( Error );
}



DWORD
DiscoverIpxServers(
    LPSTR ServerName
    )
/*++

Routine Description:

    This routine discovers all IPX servers using RNR GetAddressByName.

    Assume : WSAStartup is called before calling this function.

Arguments:

    ServerName : if this value is set non-NULL then discover only the
        specified server otherwise diescover all.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD NumSapAddresses = 0;
    LPSAP_ADDRESS_INFO SapAddresses = NULL;
    SOCKADDR DestAddr;

    //
    // first find out all servers running IPX only.
    // performed by doing SAP broadcast.
    //

    Error  = GetSapAddress( &SapAddresses, &NumSapAddresses );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now process returned buffer entries.
    //

    DWORD i;

    TcpsvcsDbgAssert( NumSapAddresses > 0 );

    //
    // create a IPX socket to send query message, if it is not created
    // before.
    //

    LOCK_SVC_GLOBAL_DATA();
    if( GlobalCliIpxSocket == INVALID_SOCKET ) {

        SOCKADDR_IPX IpxSocketAddr;
        DWORD Arg;

        GlobalCliIpxSocket = socket( PF_IPX, SOCK_DGRAM, NSPROTO_IPX );

        if( GlobalCliIpxSocket == INVALID_SOCKET ) {

            Error = WSAGetLastError();
            UNLOCK_SVC_GLOBAL_DATA();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "socket() failed, %ld\n", Error ));

            goto Cleanup;
        }

        //
        // make this socket non blocking.
        //

        Arg = 1;
        if( (ioctlsocket( GlobalCliIpxSocket, FIONBIO, &Arg )) == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            UNLOCK_SVC_GLOBAL_DATA();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "ioctlsocket() failed, %ld\n", Error ));

            goto Cleanup;
        }

        //
        // Bind the socket
        //

        memset( &IpxSocketAddr, 0, sizeof( SOCKADDR_IPX));

        IpxSocketAddr.sa_family = AF_IPX;
        IpxSocketAddr.sa_socket = 0;      // no specific port

        if ( bind( GlobalCliIpxSocket,
                   (PSOCKADDR) &IpxSocketAddr,
                   sizeof( SOCKADDR_IPX)) == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            UNLOCK_SVC_GLOBAL_DATA();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "bind() failed, %ld\n", Error ));

            goto Cleanup;
        }

        //
        // add this socket to global list.
        //

        FD_SET( GlobalCliIpxSocket, &GlobalCliSockets );
    }
    UNLOCK_SVC_GLOBAL_DATA();

    LPSAP_ADDRESS_INFO SapAddressInfo;

    SapAddressInfo = SapAddresses;
    DestAddr.sa_family = AF_IPX;
    for( i = 0; i < (DWORD)NumSapAddresses; i++, SapAddressInfo++ ) {

        //
        // if we are asked to discover only specific server
        // check the server name first before sending the query
        // message.
        //

        if( ServerName != NULL ) {
            if( _stricmp(
                    ServerName,
                    SapAddressInfo->ServerName ) != 0 ) {
                continue;
            }
        }

        //
        // send query message to each discovered server.
        //

        memcpy(
            DestAddr.sa_data,
            SapAddressInfo->Address,
            IPX_ADDRESS_LENGTH );

        Error = sendto(
                    GlobalCliIpxSocket,
                    (LPCSTR)GlobalCliQueryMsg,
                    GlobalCliQueryMsgLen,
                    0,
                    &DestAddr,
                    2 + IPX_ADDRESS_LENGTH );

        if( Error == SOCKET_ERROR ) {
            Error = WSAGetLastError();

            TcpsvcsDbgPrint(( DEBUG_ERRORS, "sendto() failed, %ld\n", Error ));
            continue;
        }
    }

    //
    // DONE.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    if( SapAddresses != NULL ) {
        SvclocHeap->Free( SapAddresses );
    }

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "DiscoverIpxServers failed, %ld\n", Error ));
    }

    return( Error );
}

DWORD
DiscoverIpServers(
    LPSTR ServerName
    )
/*++

Routine Description:

    This function sends out a discovery message to all netbios lanas.

Arguments:

    UniqueServerName : pointer to a server name string. If this pointer is
        NULL, it uses IC group name to discover all IP servers, otherwise
        it discovers the bindings of the specified server.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    SOCKADDR_NB RemoteSocketAddress;

    LOCK_SVC_GLOBAL_DATA();
    if( GlobalCliNBSockets.fd_count == 0 ) {

        SOCKET s;
        DWORD Lana;
        SOCKADDR_NB SocketAddress;

        // make netbios source address.
        //

        memset( &SocketAddress, 0x0, sizeof(SOCKADDR_NB) );

        SocketAddress.snb_family = AF_NETBIOS;
        SocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        GetNBUniqueName(
            SocketAddress.snb_name,
            sizeof(SocketAddress.snb_name) );

        //
        // enumurate lanas first.
        //

        LANA_ENUM Lanas;

        if( GetEnumNBLana( &Lanas ) ) {

            //
            // try only the lanas that are returned.
            //

            DWORD i;
            for( i = 0; i < Lanas.length; i++ ) {

                if ( MakeNBSocketForLana(
                        Lanas.lana[i],
                        (PSOCKADDR)&SocketAddress,
                        &s ) ) {

                    //
                    // successfully made another socket, add to global list.
                    //

                    FD_SET( s, &GlobalCliNBSockets );
                    FD_SET( s, &GlobalCliSockets );
                }
            }
        }
        else {

            UCHAR Lana;

            //
            // try all possible lanas and accept all valid lana sockets.
            //

            for( Lana = 0; Lana < MAX_LANA ; Lana-- ) {

                if ( MakeNBSocketForLana(
                        Lana,
                        (PSOCKADDR)&SocketAddress,
                        &s ) ) {

                    //
                    // successfully made another socket, add to global
                    // lists.
                    //

                    FD_SET( s, &GlobalCliNBSockets );
                    FD_SET( s, &GlobalCliSockets );
                }
            }
        }
    }

    UNLOCK_SVC_GLOBAL_DATA();

    if( GlobalCliNBSockets.fd_count == 0 ) {
        return( ERROR_SUCCESS );
    }

    //
    //
    // make netbios destination address.
    //

    memset( &RemoteSocketAddress, 0x0, sizeof(SOCKADDR_NB) );

    if( ServerName == NULL ) {

        //
        // if no server name is specified, then send the discovery message
        // to IC group name.
        //

        RemoteSocketAddress.snb_family = AF_NETBIOS;
        RemoteSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_GROUP;

        TcpsvcsDbgAssert(
            sizeof(RemoteSocketAddress.snb_name) >=
                NETBIOS_INET_GROUP_NAME_LEN );

        memcpy(
            RemoteSocketAddress.snb_name,
            NETBIOS_INET_GROUP_NAME,
            NETBIOS_INET_GROUP_NAME_LEN );
    }
    else {

        DWORD ServerNameLen;

        //
        // send the discovery message to the specified server.
        //

        RemoteSocketAddress.snb_family = AF_NETBIOS;
        RemoteSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        ServerNameLen = strlen(ServerName);

        TcpsvcsDbgAssert(
            ServerNameLen <=
            sizeof(RemoteSocketAddress.snb_name) );

        memcpy(
            RemoteSocketAddress.snb_name,
            ServerName,
            (ServerNameLen >= sizeof(RemoteSocketAddress.snb_name)) ?
                sizeof(RemoteSocketAddress.snb_name) :
                ServerNameLen );
    }

    //
    // send message to all lanas.
    //

    DWORD i;
    for( i = 0; i < GlobalCliNBSockets.fd_count ; i++ ) {

        //
        // now send query message.
        //

        Error = sendto(
                    GlobalCliNBSockets.fd_array[i],
                    (LPCSTR)GlobalCliQueryMsg,
                    GlobalCliQueryMsgLen,
                    0,
                    (PSOCKADDR)&RemoteSocketAddress,
                    sizeof(RemoteSocketAddress) );

        if( Error == SOCKET_ERROR ) {
            Error = WSAGetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "sendto() failed, %ld\n", Error ));
        }
    }

    return( ERROR_SUCCESS );
}

DWORD
ProcessSvclocQueryResponse(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    SOCKADDR *SourcesAddress,
    DWORD SourcesAddressLength
    )
/*++

Routine Description:

    This function processes the query response message and queues them to
    the global list.

Arguments:

    ReceivedSocket - socket the message came from.

    ReceivedMessage - pointer to a message buffer.

    ReceivedMessageLength - length of the above message.

    SourcesAddress - address of the sender.

    SourcesAddressLength - length of the above address.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD NodeLength;
    LPCLIENT_QUERY_RESPONSE ResponseNode;
    PLIST_ENTRY NextResponse;
    LPBYTE EndReceiveMessage;

    //
    // validate this message.
    //

    //
    // first DWORD in the message is the length of the message.
    //

    if( *(DWORD *)ReceivedMessage != ReceivedMessageLength ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // last DWORD is terminating char.
    //

    EndReceiveMessage = ReceivedMessage + ReceivedMessageLength;

    if( *(DWORD *) (EndReceiveMessage - sizeof(DWORD)) != 0xFFFFFFFF ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // validate check sum.
    // last but one DWORD is check of the message.
    //

    DWORD CheckSum;

    CheckSum =  *(DWORD *) (EndReceiveMessage - 2 * sizeof(DWORD));

    DWORD ComputedCheckSum;

    ComputedCheckSum =
        ComputeCheckSum(
            ReceivedMessage + sizeof(DWORD),    // skip length field.
            ReceivedMessageLength - 3 * sizeof(DWORD) );
                // skip last 2 DWORDS too.

    if( ComputedCheckSum != CheckSum ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // check version number.
    //

    INET_VERSION_NUM *VersionNum;

    VersionNum = (INET_VERSION_NUM *)(ReceivedMessage + sizeof(DWORD));

    if( VersionNum->Version.Major != INET_MAJOR_VERSION ) {
        return( ERROR_INVALID_PARAMETER );
    }

    LOCK_SVC_GLOBAL_DATA();

    //
    // check to see, there is already a response from this server, if so
    // update the response message, otherwise add a new entry.
    //

    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {

        LPCLIENT_QUERY_RESPONSE QueryResponse;

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;

        //
        // if either the server addresses match or
        // the server names in the message field match, then this
        // must be duplicate, so replace with old one.
        //

        if(
#if 0
        //
        // this check always succeseed for group name.
        //

            ( (SourcesAddressLength == QueryResponse->SourcesAddressLength ) && (memcmp(
                    SourcesAddress,
                    QueryResponse->SourcesAddress,
                    SourcesAddressLength ) == 0 ) ) ||
#endif // 0
            ( strcmp(
                (LPSTR)ReceivedMessage + 2 * sizeof(DWORD),
                        // skip length and version DWORDS.
                (LPSTR)QueryResponse->ResponseBuffer + 2 * sizeof(DWORD) )
                    == 0 ) ) {

            //
            // free old response buffer.
            //

            SvclocHeap->Free( QueryResponse->ResponseBuffer );

            //
            // copy new response pointer.
            //

            QueryResponse->ResponseBuffer = ReceivedMessage;
            QueryResponse->ResponseBufferLength = ReceivedMessageLength;
            QueryResponse->TimeStamp = time( NULL );

            //
            // done.
            //

            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
    }

    //
    // brand new response.
    //

    NodeLength = sizeof(CLIENT_QUERY_RESPONSE) + SourcesAddressLength;

    ResponseNode = (LPCLIENT_QUERY_RESPONSE)SvclocHeap->Alloc( NodeLength );

    if( ResponseNode == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // setup sock address pointer.
    //

    ResponseNode->SourcesAddress = (SOCKADDR *)(ResponseNode + 1);

    //
    // copy address data.
    //

    memcpy(
        ResponseNode->SourcesAddress,
        SourcesAddress,
        SourcesAddressLength );

    //
    // copy other fields.
    //

    ResponseNode->ReceivedSocket = ReceivedSocket;
    ResponseNode->ResponseBuffer = ReceivedMessage;
    ResponseNode->ResponseBufferLength = ReceivedMessageLength;
    ResponseNode->SourcesAddressLength = SourcesAddressLength;
    ResponseNode->TimeStamp = time( NULL );

    //
    // link this entry to global list.
    //

    InsertTailList( &GlobalCliQueryRespList, &ResponseNode->NextEntry );

    //
    // done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

DWORD
ReceiveResponses(
    WORD Timeout,
    BOOL WaitForAllResponses
    )
/*++

Routine Description:

    This routine receives responses for the query messages sent out to the
    servers.

Arguments:

    Time - Time to wait for the response messages in secs.

    WaitForAllResponses : If this flag is set TRUE, this function wait
        complete 'Time' secs for all responses to arrive. Otherwise it
        will return after a succcessful response is received.

Return Value:

    None.

--*/
{
    DWORD Error;
    struct timeval SockTimeout;
    struct timeval *pSockTimeout;
    DWORD TimeoutinMSecs = INFINITE;
    DWORD TickCountStart;

    if( Timeout != 0 ) {
        TimeoutinMSecs = Timeout * 1000;
        pSockTimeout = &SockTimeout;
    }
    else {
        pSockTimeout = NULL;
    }

    //
    // now loop for incoming messages.
    //

    //
    // remember current tick out.
    //

    TickCountStart = GetTickCount();

    for( ;; ) {

        fd_set ReadSockets;
        INT NumReadySockets;
        DWORD NumSockets;
        DWORD i;

        LOCK_SVC_GLOBAL_DATA();
        NumSockets = GlobalCliSockets.fd_count;
        UNLOCK_SVC_GLOBAL_DATA();

        if( NumSockets != 0 ) {

            //
            // select
            //

            LOCK_SVC_GLOBAL_DATA();
            memcpy( &ReadSockets, &GlobalCliSockets, sizeof(fd_set) );
            UNLOCK_SVC_GLOBAL_DATA();



            //
            // compute time out, if it is not infinity.
            //

            if( pSockTimeout != NULL ) {
                SockTimeout.tv_sec = TimeoutinMSecs / 1000;
                SockTimeout.tv_usec = TimeoutinMSecs % 1000;
            }

            NumReadySockets =
                select(
                    0,  // compatibility argument, ignored.
                    &ReadSockets, // sockets to test for readability.
                    NULL,   // no write wait
                    NULL,   // no error check.
                    pSockTimeout ); // NO timeout.

            if( NumReadySockets == SOCKET_ERROR ) {

                //
                // when all sockets are closed, we are asked to return or
                // something else has happpened which we can't handle.
                //

                Error = WSAGetLastError();
                goto Cleanup;
            }

            TcpsvcsDbgAssert( (DWORD)NumReadySockets == ReadSockets.fd_count );

            for( i = 0; i < (DWORD)NumReadySockets; i++ ) {

                DWORD ReadMessageLength;
                struct sockaddr_nb SourcesAddress;
                int SourcesAddressLength;
                LPBYTE RecvBuffer;
                DWORD RecvBufferLength;

                RecvBufferLength = SVCLOC_CLI_QUERY_RESP_BUF_SIZE;
                RecvBuffer = (LPBYTE)SvclocHeap->Alloc( RecvBufferLength );

                if( RecvBuffer == NULL ) {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                //
                // read next message.
                //

                SourcesAddressLength = sizeof(SourcesAddress);

                ReadMessageLength =
                    recvfrom(
                        ReadSockets.fd_array[i],
                        (LPSTR)RecvBuffer,
                        RecvBufferLength,
                        0,
                        (struct sockaddr *)&SourcesAddress,
                        &SourcesAddressLength );

                if( ReadMessageLength == SOCKET_ERROR ) {

                    //
                    // when all sockets are closed, we are asked to return
                    // or  something else has happpened which we can't
                    // handle.
                    //

                    Error = WSAGetLastError();

                    //
                    // free receive  buffer.
                    //

                    SvclocHeap->Free( RecvBuffer );
                    RecvBuffer = NULL;

                    if( Error == WSAEMSGSIZE ) {

                        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                            "recvfrom() received a too large message (%ld).\n",
                                ReadMessageLength ));

                        continue;   // process next message.
                    }

                    goto Cleanup;
                }

                TcpsvcsDbgAssert( ReadMessageLength <= RecvBufferLength );

                //
                // received a message.
                //

                TcpsvcsDbgPrint((
                    DEBUG_SVCLOC_MESSAGE,
                        "Received an query response message, %ld.\n",
                            ReadMessageLength ));

                Error = ProcessSvclocQueryResponse(
                                ReadSockets.fd_array[i],
                                RecvBuffer,
                                (DWORD)ReadMessageLength,
                                (struct sockaddr *)&SourcesAddress,
                                (DWORD)SourcesAddressLength );

                if( Error != ERROR_SUCCESS ) {

                    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "ProcessSvclocQueryResponse failed, %ld.\n", Error ));

                    //
                    // free receive buffer.
                    //

                    SvclocHeap->Free( RecvBuffer );
                    RecvBuffer = NULL;
                }
            }

        }

        //
        // otherthan NT platform, receive NetBios responses also.
        //

        if( GlobalPlatformType != VER_PLATFORM_WIN32_NT ) {

            LPSVCLOC_NETBIOS_RESPONSE NetBiosResponses = NULL;
            DWORD NumResponses;

            //
            // compute remaining time.
            //

            if( pSockTimeout != NULL ) {

                DWORD NewTickCountStart;
                DWORD Elapse;

                NewTickCountStart = GetTickCount();

                //
                // subtract elapse time.
                //

                Elapse = NewTickCountStart - TickCountStart;

                if( Elapse > TimeoutinMSecs ) {
                    TimeoutinMSecs = 0;
                }
                else {

                    TimeoutinMSecs -= Elapse;
                    TickCountStart = NewTickCountStart;
                }
            }

            //
            // receive netbios responses.
            //

            Error = ReceiveNetBiosResponses(
                        &NetBiosResponses,
                        &NumResponses,
                        TimeoutinMSecs,
                        WaitForAllResponses );

            if( Error != ERROR_SUCCESS ) {

                TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "ReceiveNetBiosResponses failed, %ld.\n", Error ));

                //
                // ignore this error and continue.
                //
            }
            else {


                LPSVCLOC_NETBIOS_RESPONSE NBResp = NetBiosResponses;

                for( i = 0; i < NumResponses; i++, NBResp++ ) {

                    Error = ProcessSvclocQueryResponse(
                                    0,
                                    NBResp->ResponseBuffer,
                                    NBResp->ResponseBufLen,
                                    (struct sockaddr *)
                                        &NBResp->SourcesAddress,
                                    NBResp->SourcesAddrLen );

                    if( Error != ERROR_SUCCESS ) {
                        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                            "ProcessSvclocQueryResponse failed, %ld.\n",
                                Error ));

                        //
                        // free response receive buffer.
                        //

                        SvclocHeap->Free( NBResp->ResponseBuffer );

                        //
                        // ignore this error and continue.
                        //
                    }
                }

                //
                // free up response buffer.
                //

                if( NetBiosResponses != NULL ) {
                    SvclocHeap->Free( NetBiosResponses );
                }
            }
        }
        else {

            //
            // if we have timed out.
            //

            if( NumReadySockets == 0 ) {
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }

        }

        if( WaitForAllResponses == FALSE ) {

            //
            // return after the first set of responses received.
            //

            Error = ERROR_SUCCESS;
            break;
        }

        //
        // compute remaining time.
        //

        if( pSockTimeout != NULL ) {

            DWORD NewTickCountStart;
            DWORD Elapse;

            NewTickCountStart = GetTickCount();

            //
            // subtract elapse time.
            //

            Elapse = NewTickCountStart - TickCountStart;

            if( Elapse > TimeoutinMSecs ) {
                TimeoutinMSecs = 0;
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }
            else {

                TimeoutinMSecs -= Elapse;
                TickCountStart = NewTickCountStart;
            }
        }
    }

Cleanup:

    //
    // discovery is completed (successfully or not), indicate so.
    //

    LOCK_SVC_GLOBAL_DATA();
    SetEvent( GlobalDiscoveryInProgressEvent );
    GlobalLastDiscoveryTime = time( NULL );
    UNLOCK_SVC_GLOBAL_DATA();

    return( Error );
}

VOID
ServerDiscoverThread(
    LPVOID Parameter
    )
/*++

Routine Description:

    This thread waits for query responses to arrive, when they arrive it
    queues them in them in the global list.

Arguments:

    Parameter - not used..

Return Value:

    None.

--*/
{
    DWORD Error;
    Error = ReceiveResponses( RESPONSE_WAIT_TIMEOUT, TRUE );

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "ReceiveResponses returned error (%ld) .\n", Error ));
    }

    LOCK_SVC_GLOBAL_DATA();

    //
    // close thread handle.
    //

    CloseHandle( GlobalCliDiscoverThreadHandle );
    GlobalCliDiscoverThreadHandle = NULL;

    UNLOCK_SVC_GLOBAL_DATA();

    return;
}

DWORD
MakeClientQueryMesage(
    ULONGLONG ServicesMask
    )
/*++

Routine Description:

    This function makes client query message and stores it in the global
    data buffer for future use.

    The query message format.

    1st DWORD : message length.
    2nd DWORD : message version.
    3rd ULONGLONG : services mask the client interested in.
    4th WCHAR[] : client name
    ..
    ..

    Last but one DWORD : check sum.
    LAST DWORD : terminating DWORD 0xFFFFFFFF

    Assume: Global data is locked.

Arguments:

    ServicesMask - services to query for.

Return Value:

    Windows Error Code.

--*/
{
    LPCLIENT_QUERY_MESSAGE QueryMsg;

    //
    // Test to see query message is already made.
    //

    if( GlobalCliQueryMsg == NULL ) {

        //
        // check to computer name is initilaized.
        //

        if( GlobalComputerName[0] == '\0' ) {

            DWORD ComputerNameLength =
                MAX_COMPUTERNAME_LENGTH + 1;

            //
            // read computer name.
            //

            if( !GetComputerNameA(
                    GlobalComputerName,
                    &ComputerNameLength ) ) {

                DWORD Error = GetLastError();

                TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "GetComputerNameA failed, %ld.\n", Error ));

                return( Error );
            }

            GlobalComputerName[ComputerNameLength] = '\0';
        }

        //
        // compute the space required for the query message.
        //

        DWORD MsgLen;

        MsgLen = sizeof(CLIENT_QUERY_MESSAGE) +
            strlen(GlobalComputerName)  * sizeof(CHAR);
                // note the terminating char is included as part of
                // CLIENT_QUERY_MESSAGE size.

        //
        // Ceil to next DWORD.
        //

        MsgLen = ROUND_UP_COUNT(MsgLen, ALIGN_DWORD);

        //
        // add space for checksum and terminating DWORD.
        //

        MsgLen += sizeof(DWORD);

        QueryMsg = (LPCLIENT_QUERY_MESSAGE) SvclocHeap->Alloc( MsgLen );

        if( QueryMsg == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        memset( QueryMsg, 0x0, MsgLen );

        //
        // init fields.
        //

        INET_VERSION_NUM MessageVersion;

        MessageVersion.Version.Major = INET_MAJOR_VERSION;
        MessageVersion.Version.Minor = INET_MINOR_VERSION;

        QueryMsg->MsgLength = MsgLen;
        QueryMsg->MsgVersion = MessageVersion.VersionNumber;
        QueryMsg->ServicesMask = ServicesMask;
        strcpy( QueryMsg->ClientName, GlobalComputerName );

        //
        // compute check sum.
        //

        DWORD Checksum;

        Checksum  = ComputeCheckSum(
                                (LPBYTE)QueryMsg + sizeof(DWORD), // skip length field.
                                MsgLen - 3 * sizeof(DWORD) );

        *(LPDWORD)((LPBYTE)QueryMsg + MsgLen - 2 * sizeof(DWORD)) = Checksum;
        *(LPDWORD)((LPBYTE)QueryMsg + MsgLen - sizeof(DWORD)) = 0xFFFFFFFF;

        GlobalCliQueryMsg = (LPBYTE)QueryMsg;
        GlobalCliQueryMsgLen = MsgLen;
    }
    else {

        //
        // set the requested service mask in the message.
        //

        QueryMsg = (LPCLIENT_QUERY_MESSAGE)GlobalCliQueryMsg;
        QueryMsg->ServicesMask |= ServicesMask;
    }

    return( ERROR_SUCCESS );
}

DWORD
CleanupOldResponses(
    VOID
    )
/*++

Routine Description:

    This function removes and deletes the server responses that are older
    than INET_SERVER_RESPONSE_TIMEOUT (15 mins).

    ASSUME : the global lock is locked.

Arguments:

    none.

Return Value:

    Windows Error Code.

--*/
{
    PLIST_ENTRY NextResponse;
    LPCLIENT_QUERY_RESPONSE QueryResponse;
    time_t CurrentTime;

    CurrentTime = time( NULL );
    NextResponse =  GlobalCliQueryRespList.Flink;

    while( NextResponse != &GlobalCliQueryRespList ) {

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;
        NextResponse = NextResponse->Flink;

        if( CurrentTime > QueryResponse->TimeStamp +
                                    INET_SERVER_RESPONSE_TIMEOUT ) {

            RemoveEntryList( (PLIST_ENTRY)QueryResponse );

            //
            // free up resources.
            //

            //
            // free response buffer.
            //

            SvclocHeap->Free( QueryResponse->ResponseBuffer );

            //
            // free this node.
            //

            SvclocHeap->Free( QueryResponse );
        }
    }

    return( ERROR_SUCCESS );
}

DWORD
GetDiscoveredServerInfo(
    LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This function processes the responses received from the servers so far
    and returns the response received from the specified server.

    ASSUME : the global lock is locked.

Arguments:

    ServerName : name of the server whose info to be queried.

    ServicesMask : services to be queried

    INetServerInfo : pointer to a location where the pointer to a
        INET_SERVER_INFO structure is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    PLIST_ENTRY NextResponse;
    LPCLIENT_QUERY_RESPONSE QueryResponse;

    LOCK_SVC_GLOBAL_DATA();

    //
    // first clean up timeout server records.
    //

    Error = CleanupOldResponses();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now loop through the list of responses and findout the response
    // from the specified server.
    //

    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {


        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;

        //
        // check to see this entry is from the specified server.
        //

        if( _stricmp(
                ServerName,
                (LPSTR)QueryResponse->ResponseBuffer + 2 * sizeof(DWORD) )
                        // skip length and version DWORDS.
                    == 0 ) {

            EMBED_SERVER_INFO *ServerInfoObj;

            ServerInfoObj = new EMBED_SERVER_INFO(
                QueryResponse->ResponseBuffer + sizeof(DWORD),    // skip length field.
                QueryResponse->ResponseBufferLength - 3 * sizeof(DWORD) );
                    // skip last 2 DWORDS too.

            if( ServerInfoObj == NULL ) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            Error =  ServerInfoObj->GetStatus();

            if( Error != ERROR_SUCCESS ) {
                delete ServerInfoObj;
                goto Cleanup;
            }

            //
            // check services quaried.
            //

            if( ServicesMask &  ServerInfoObj->GetServicesMask() ) {

                //
                // now make server info structure;
                //

                Error = ServerInfoObj->GetServerInfo( ServerInfo );
            }
            else {

                //
                // the server does not support the service(s) quaried.
                //

                Error = ERROR_BAD_NETPATH;
            }

            //
            // delete the object which we don't require anymore.
            //

            delete ServerInfoObj;

            //
            // we are done.
            //

            goto Cleanup;
        }
    }

    //
    // unable to find the specified server.
    //

    Error = ERROR_BAD_NETPATH;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

DWORD
ProcessDiscoveryResponses(
    IN ULONGLONG ServicesMask,
    OUT LPINET_SERVERS_LIST *INetServersList
    )
/*++

Routine Description:

    This function processes the responses received from the servers so far
    and makes INET_SERVERS_LIST.

Arguments:

    ServicesMask : services to be queried

    INetServersList : pointer to a location where the pointer to a
        INET_SERVERS_LIST structure is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    PLIST_ENTRY NextResponse;
    LPCLIENT_QUERY_RESPONSE QueryResponse;
    DWORD NumServers;
    LPINET_SERVERS_LIST ServersList;

    LOCK_SVC_GLOBAL_DATA();

    //
    // first clean up timeout server records.
    //

    Error = CleanupOldResponses();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // compute number of responses we have.
    //

    NumServers = 0;
    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {
        NumServers++;
    }

    //
    // allocate memory for servers list structure.
    //

    ServersList = (LPINET_SERVERS_LIST)
        SvclocHeap->Alloc( sizeof(INET_SERVERS_LIST) );

    if( ServersList == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ServersList->NumServers = 0;
    ServersList->Servers = NULL;

    //
    // now allocate memory for the servers info structure pointers array.
    //

    ServersList->Servers = (LPINET_SERVER_INFO *)
        SvclocHeap->Alloc(NumServers * sizeof(LPINET_SERVER_INFO) );

    if( ServersList->Servers == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // loop through the list of responses and make response structures.
    //

    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {

        EMBED_SERVER_INFO *ServerInfoObj;

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;

        ServerInfoObj = new EMBED_SERVER_INFO(
            QueryResponse->ResponseBuffer + sizeof(DWORD),    // skip length field.
            QueryResponse->ResponseBufferLength - 3 * sizeof(DWORD) );
                // skip last 2 DWORDS too.

        if( ServerInfoObj == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        Error =  ServerInfoObj->GetStatus();

        if( Error != ERROR_SUCCESS ) {
            delete ServerInfoObj;
            goto Cleanup;
        }

        //
        // check services quaried.
        //

        if( ServicesMask &  ServerInfoObj->GetServicesMask() ) {

            //
            // the server has the one or more of the services quaried.
            // add an entry in the return buffer.
            //

            DWORD i;
            i = ServersList->NumServers;

            //
            // now make server info structure;
            //

            Error = ServerInfoObj->GetServerInfo( &ServersList->Servers[i] );

            if( Error != ERROR_SUCCESS ) {
                TcpsvcsDbgAssert( ServersList->Servers[i] == NULL );

                delete ServerInfoObj;
                ServerInfoObj = NULL;
                goto Cleanup;
            }

            //
            // allocate space for server address.
            //

            LPVOID ServerAddress;

            ServerAddress = SvclocHeap->Alloc( QueryResponse->SourcesAddressLength );

            if( ServerAddress != NULL ) {

                //
                // copy server address.
                //

               TcpsvcsDbgAssert( ServersList->Servers[i]->ServerAddress.BindData == NULL );
               TcpsvcsDbgAssert( ServersList->Servers[i]->ServerAddress.Length == 0 );

                memcpy(
                   ServerAddress,
                   QueryResponse->SourcesAddress,
                   QueryResponse->SourcesAddressLength );

                ServersList->Servers[i]->ServerAddress.BindData = ServerAddress;
                ServersList->Servers[i]->ServerAddress.Length =
                    QueryResponse->SourcesAddressLength;
            }

            //
            // we success fully added another server info, indicate so.
            //

            ServersList->NumServers++;
        }

        //
        // delete the object which we don't require anymore.
        //

        delete ServerInfoObj;
        ServerInfoObj = NULL;
    }

    //
    // now set up return pointer.
    //

    *INetServersList = ServersList;
    ServersList = NULL;
    Error = ERROR_SUCCESS;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();

    if( ServersList != NULL ) {

        //
        // free server info structures first.
        //

        if( ServersList->NumServers > 0 ) {
            TcpsvcsDbgAssert( ServersList->Servers != NULL );
        }

        DWORD Index;
        for (Index = 0; Index < ServersList->NumServers; Index++) {

            TcpsvcsDbgAssert( ServersList->Servers[Index] != NULL );
            FreeServerInfo( ServersList->Servers[Index] );
        }

        if( ServersList->Servers != NULL ) {
            SvclocHeap->Free( ServersList->Servers );
        }

        SvclocHeap->Free( ServersList );
    }

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "ProcessDiscoveryResponses returning error, %ld.", Error ));
    }

    return( Error );
}

DWORD
ProcessNcbResponse(
    NCB *Ncb,
    PLIST_ENTRY RespList,
    DWORD *NumEntries
    )
{
    LPBYTE RespBuffer;
    DWORD RespBufferLen;

    if ( Ncb->ncb_retcode ==  NRC_GOODRET ) {

        // DebugBreak();

        //
        // copy response buffer pointer.
        //

        RespBuffer = Ncb->ncb_buffer;
        RespBufferLen = Ncb->ncb_length;

        //
        // allocate a new buffer.
        //

        LPBYTE RecvBuffer;

        RecvBuffer = (LPBYTE )
            SvclocHeap->Alloc( SVCLOC_CLI_QUERY_RESP_BUF_SIZE );

        if( RecvBuffer == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        Ncb->ncb_buffer = RecvBuffer;
        Ncb->ncb_length = SVCLOC_CLI_QUERY_RESP_BUF_SIZE;

        //
        // resubmit the NCB with different buffer.
        //

        UCHAR NBErrorCode;

        NBErrorCode = Netbios( Ncb );

        if( (NBErrorCode != NRC_GOODRET) ||
            (Ncb->ncb_retcode != NRC_PENDING) ) {

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "Netbios() failed, %ld, %ld \n",
                        NBErrorCode, Ncb->ncb_retcode ));

            return( ERROR_BAD_NETPATH );
        }

    }
    else {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "Netbios() failed, %ld\n", Ncb->ncb_retcode ));

        return( ERROR_BAD_NETPATH ); // ??
    }

    //
    // create a response entry and add to the list.
    //

    LPSVCLOC_NETBIOS_RESP_ENTRY RespEntry;

    RespEntry = (LPSVCLOC_NETBIOS_RESP_ENTRY)
        SvclocHeap->Alloc( sizeof(SVCLOC_NETBIOS_RESP_ENTRY) );

    if( RespEntry == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );;
    }

    RespEntry->Resp.ResponseBuffer = RespBuffer;
    RespEntry->Resp.ResponseBufLen = RespBufferLen;

    RespEntry->Resp.SourcesAddress.snb_family = AF_NETBIOS;
    RespEntry->Resp.SourcesAddress.snb_type =
        TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    memcpy(
        RespEntry->Resp.SourcesAddress.snb_name,
        Ncb->ncb_callname,
        sizeof(Ncb->ncb_callname) );

    RespEntry->Resp.SourcesAddrLen = sizeof(SOCKADDR_NB);

    (*NumEntries)++;
    InsertTailList( RespList, (PLIST_ENTRY)RespEntry );

    return( ERROR_SUCCESS );
}

VOID
NcbPostHandler(
    NCB *Ncb
    )
{
    ProcessNcbResponse(
        Ncb,
        &GlobalWin31NBRespList,
        &GlobalWin31NumNBResps
        );

    return;
}

DWORD
DiscoverNetBiosServers(
    LPSTR ServerName
    )
/*++

Routine Description:

    This function sends out discovery message over netbios NBCs

Arguments:

    ServerName : name of the specific server to discover.

Return Value:

    Windows Error Code.

--*/
{
    NCB *Ncbs = NULL;
    LANA_ENUM Lanas;
    DWORD Error = ERROR_SUCCESS;
    UCHAR NBErrorCode = NRC_GOODRET;
    UCHAR UniqueName[NCBNAMSZ];

    // DebugBreak();

    LOCK_SVC_GLOBAL_DATA();

    if( !GetNetBiosLana( &Lanas ) ) {
        return( ERROR_BAD_NETPATH );
    }

    TcpsvcsDbgAssert( Lanas.length != 0 );

    if( Lanas.length == 0 ) {
        return( ERROR_BAD_NETPATH );
    }

    Ncbs = (NCB *) SvclocHeap->Alloc( sizeof(NCB ) * Lanas.length );

    if( Ncbs == NULL ) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memset( Ncbs, 0x0, sizeof(NCB) * Lanas.length );

    GetNBUniqueName( (LPSTR)UniqueName, NCBNAMSZ );

    //
    // alloc memory for the pending recvs.
    //

#define NUM_RECV_PENDING_NCBS_PER_LANA   3

    GlobalNumNBPendingRecvs = 0;
    GlobalNBPendingRecvs = (NCB *)
        SvclocHeap->Alloc(
            sizeof(NCB ) *
                Lanas.length  *
                    NUM_RECV_PENDING_NCBS_PER_LANA );

    if( GlobalNBPendingRecvs == NULL ) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DWORD i;
    for( i = 0; i < Lanas.length; i++ ) {

        NCB *PendingRecv;
        LPBYTE RecvBuffer;
        HANDLE EventHandle;

        Ncbs[i].ncb_command = NCBADDNAME;
        memcpy( Ncbs[i].ncb_name, UniqueName, NCBNAMSZ );

        //
        // add name.
        //

        Ncbs[i].ncb_lana_num = Lanas.lana[i];

        // DebugBreak();
        NBErrorCode = Netbios( &Ncbs[i] );

        if( Ncbs[i].ncb_retcode != NRC_GOODRET ) {
            NBErrorCode = Ncbs[i].ncb_retcode;
        }

        if( NBErrorCode != NRC_GOODRET ) {
            goto Cleanup;
        }

        //
        // post pending receives.
        //

        DWORD j;

        for( j = 0; j < NUM_RECV_PENDING_NCBS_PER_LANA; j++ ) {

            TcpsvcsDbgAssert(
                GlobalNumNBPendingRecvs <
                    ( (DWORD)Lanas.length  *
                        NUM_RECV_PENDING_NCBS_PER_LANA) );

            PendingRecv =
                &GlobalNBPendingRecvs[GlobalNumNBPendingRecvs];

            memset( PendingRecv, 0x0, sizeof(NCB) );

            memcpy(
                PendingRecv->ncb_name,
                Ncbs[i].ncb_name,
                NCBNAMSZ );

            PendingRecv->ncb_lana_num = Lanas.lana[i];
            PendingRecv->ncb_command = NCBDGRECV | ASYNCH;
            PendingRecv->ncb_rto = SVCLOC_NB_RECV_TIMEOUT / 2;

            PendingRecv->ncb_num = Ncbs[i].ncb_num;

            RecvBuffer = (LPBYTE)
                SvclocHeap->Alloc( SVCLOC_CLI_QUERY_RESP_BUF_SIZE );

            if( RecvBuffer == NULL ) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            PendingRecv->ncb_buffer = RecvBuffer;
            PendingRecv->ncb_length = SVCLOC_CLI_QUERY_RESP_BUF_SIZE;

            if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

                PendingRecv->ncb_post = NcbPostHandler ;
            }
            else {

                //
                // create an event.
                //

                EventHandle = IIS_CREATE_EVENT(
                                  "NCB::ncb_event",
                                  PendingRecv,
                                  FALSE,        // automatic reset
                                  FALSE         // initial state: NOT signalled
                                  );

                if( EventHandle == NULL ) {
                    Error = GetLastError();
                    SvclocHeap->Free( RecvBuffer );
                    goto Cleanup;
                }

                PendingRecv->ncb_event = EventHandle;
            }

            // DebugBreak();
            NBErrorCode = Netbios( PendingRecv );

            if( (PendingRecv->ncb_retcode != NRC_PENDING) &&
                (PendingRecv->ncb_retcode != NRC_GOODRET) ) {
                NBErrorCode = PendingRecv->ncb_retcode;
            }

            if( NBErrorCode != NRC_GOODRET ) {
                SvclocHeap->Free( RecvBuffer );
                CloseHandle( EventHandle );
                goto Cleanup;
            }

            GlobalNumNBPendingRecvs++;
        }
    }

    //
    // send discovery message to all lanas.
    //

    for( i = 0; i < Lanas.length; i++ ) {

        Ncbs[i].ncb_command = NCBDGSEND;
        Ncbs[i].ncb_lana_num = Lanas.lana[i];
        Ncbs[i].ncb_retcode = NRC_GOODRET;

        //
        // setup sender's name.
        //

        if( ServerName == NULL ) {

            //
            // if no server name is specified, then send the discovery message
            // to IC group name.
            //

            TcpsvcsDbgAssert(
                    NETBIOS_INET_GROUP_NAME_LEN ==
                        NCBNAMSZ );

            memcpy(
                Ncbs[i].ncb_callname,
                NETBIOS_INET_GROUP_NAME,
                NETBIOS_INET_GROUP_NAME_LEN );
        }
        else {

            DWORD ServerNameLen;

            //
            // send the discovery message to the specified server.
            //

            ServerNameLen = strlen(ServerName);

            TcpsvcsDbgAssert( ServerNameLen <= NCBNAMSZ );

            memset(
                Ncbs[i].ncb_callname,
                0x0,
                NCBNAMSZ );

            memcpy(
                Ncbs[i].ncb_callname,
                ServerName,
                (ServerNameLen >= NCBNAMSZ) ? NCBNAMSZ : ServerNameLen );
        }

        //
        // setup message buffer.
        //

        Ncbs[i].ncb_buffer = GlobalCliQueryMsg;
        Ncbs[i].ncb_length = (WORD)GlobalCliQueryMsgLen;

        // DebugBreak();
        NBErrorCode = Netbios( &Ncbs[i] );

        if( Ncbs[i].ncb_retcode != NRC_GOODRET ) {
            NBErrorCode = Ncbs[i].ncb_retcode;
        }

        if( NBErrorCode != NRC_GOODRET ) {
            // DebugBreak();
            goto Cleanup;
        }
    }

Cleanup:

    if( (Error != ERROR_SUCCESS) ||
            (NBErrorCode != NRC_GOODRET) ) {


        for( i = 0; i < GlobalNumNBPendingRecvs; i++ ) {

            NCB Ncb;
            NCB *PendingEntry;
            BOOL CancelNcb;

            memset( &Ncb, 0x0, sizeof(NCB) );

            //
            // cancel pending receives and free resources.
            //

            Ncb.ncb_command = NCBCANCEL;
            Ncb.ncb_length = sizeof( NCB );

            PendingEntry = &GlobalNBPendingRecvs[i];

            CancelNcb = FALSE;
            if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

                if( PendingEntry->ncb_retcode == NRC_PENDING ) {
                    CancelNcb = TRUE;
                }
            }
            else {

                //
                // check to see the event is signalled.
                //

                DWORD Wait;

                Wait = WaitForSingleObject(
                                PendingEntry->ncb_event,
                                0 );

                    if( Wait == WAIT_TIMEOUT ) {
                        CancelNcb = TRUE;
                    }
            }

            if( CancelNcb == TRUE ) {

                UCHAR NcbError;

                Ncb.ncb_retcode = NRC_GOODRET;
                Ncb.ncb_buffer = (LPBYTE)PendingEntry;
                Ncb.ncb_lana_num = PendingEntry->ncb_lana_num;

                // DebugBreak();
                NcbError = Netbios( &Ncb );

                if( (NcbError != NRC_GOODRET) ||
                    (Ncb.ncb_retcode != NRC_GOODRET) ) {

                    TcpsvcsDbgPrint((
                        DEBUG_ERRORS,
                            "Netbios() failed, %ld, %ld \n",
                                (DWORD)NcbError,
                                (DWORD)Ncb.ncb_retcode ));
                }
            }

            //
            // free receive buffer.
            //

            SvclocHeap->Free( PendingEntry->ncb_buffer );
            CloseHandle( PendingEntry->ncb_event );
        }

        if( GlobalNBPendingRecvs != NULL ) {
            SvclocHeap->Free( GlobalNBPendingRecvs );
            GlobalNBPendingRecvs = NULL;
        }

        GlobalNumNBPendingRecvs = 0;

        UNLOCK_SVC_GLOBAL_DATA();

        TcpsvcsDbgPrint((
            DEBUG_ERRORS,
                "DiscoveryNetBiosServers failed,"
                    "NBErrorCode = %ld, Error = %ld \n",
                            (DWORD)NBErrorCode, Error ));

        return( ERROR_BAD_NETPATH );
    }

    if( Ncbs != NULL ) {
        SvclocHeap->Free(Ncbs);
    }

    UNLOCK_SVC_GLOBAL_DATA();
    return( ERROR_SUCCESS );
}

DWORD
ReceiveNetBiosResponses(
    LPSVCLOC_NETBIOS_RESPONSE *NetBiosResponses,
    DWORD *NumResponses,
    DWORD TimeoutinMSecs,
    BOOL WaitForAllResponses
    )
/*++

Routine Description:

    This function collects all responses that are received for the NetBios
    discovery.

Arguments:

    NetBiosResponses : pointer to a location where the responses buffer
        is returned.

    NumResponses : pointer to a location where the number of responses in
        the above buffer is returned

    TimeoutinMSecs : wait timeout for responses.

    WaitForAllResponses : If this flag is set TRUE, this function wait
        complete 'Time' secs for all responses to arrive. Otherwise it
        will return after a succcessful response is received.


Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    NCB *PendingRecvs;
    DWORD NumPendingRecvs;

    HANDLE *WaitHandles = NULL;

    LIST_ENTRY RespListHead;

    PLIST_ENTRY RespList;
    DWORD NumResps;

    // DebugBreak();

    *NumResponses = 0;

    //
    // init.
    //

    InitializeListHead( &RespListHead );
    RespList = &RespListHead;
    NumResps = 0;

    //
    // copy receive list.
    //

    LOCK_SVC_GLOBAL_DATA();
    PendingRecvs = GlobalNBPendingRecvs;
    NumPendingRecvs = GlobalNumNBPendingRecvs;
    GlobalNBPendingRecvs = NULL;
    GlobalNumNBPendingRecvs = 0;
    UNLOCK_SVC_GLOBAL_DATA();

    if( NumPendingRecvs == 0 ) {

        //
        // we are done.
        //

        Error =  ERROR_SUCCESS;
        goto Cleanup;
    }

    if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

        //
        // wait for responses to arrive.
        //

        Sleep( TimeoutinMSecs );

        //
        // get the list of responses that have been gathered by the
        // handler routine.
        //

        RespList = &GlobalWin31NBRespList;
        NumResps = GlobalWin31NumNBResps;
    }
    else {

        WaitHandles = (HANDLE *)
            SvclocHeap->Alloc( NumPendingRecvs * sizeof(HANDLE) );

        if( WaitHandles == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        HANDLE *WaitHandleEntry;
        WaitHandleEntry = WaitHandles;
        for( i = 0; i < NumPendingRecvs; i++ ) {

            *WaitHandleEntry = PendingRecvs[i].ncb_event;
            WaitHandleEntry++;
        }

        //
        // wait for all pending receives.
        //

        DWORD StartTime;
        StartTime = GetTickCount();

        for( ;; ) {

            DWORD Wait;
            NCB *SignalledNcb;

            Wait = WaitForMultipleObjects(
                            NumPendingRecvs,
                            WaitHandles,
                            FALSE, // wait for one.
                            TimeoutinMSecs );

            if( Wait == WAIT_FAILED ) {
                Error = GetLastError();
                goto Cleanup;
            }

            if( Wait == WAIT_TIMEOUT ) {
                break;
            }

            //
            // one of the handle has been signalled.
            //

            Wait -= WAIT_OBJECT_0; // index to the handle.

            TcpsvcsDbgAssert( Wait < NumPendingRecvs );

            SignalledNcb = &PendingRecvs[Wait];

            Error = ProcessNcbResponse(
                        &PendingRecvs[Wait],
                        RespList,
                        &NumResps );

            TcpsvcsDbgAssert(  Error == ERROR_SUCCESS );

            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // recompute wait time.
            //

            DWORD EndTime;
            DWORD Elapse;

            EndTime = GetTickCount();
            Elapse = EndTime - StartTime;

            //
            // set TIMEOUT to zero if we are asked to return after a first
            // set of responses received or if the given time elapses.
            //

            if( (WaitForAllResponses == FALSE) ||
                    (Elapse > TimeoutinMSecs) ) {

                TimeoutinMSecs = 0;
            }
            else {
                TimeoutinMSecs -= Elapse;
            }

            StartTime = EndTime;
        }
    }

    if( NumResps == 0 ) {

        //
        // we are done.
        //

        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate space for return structures.
    //

    LPSVCLOC_NETBIOS_RESPONSE RetResps;

    RetResps = (LPSVCLOC_NETBIOS_RESPONSE)
        SvclocHeap->Alloc(
            NumResps * sizeof(SVCLOC_NETBIOS_RESPONSE) );

    if( RetResps == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // copy entries from list to return array.
    //

    DWORD NumRetEntries;
    PLIST_ENTRY RetEntry;

    NumRetEntries = 0;
    for( RetEntry = RespList->Flink;
            RetEntry != RespList;
                RetEntry = RetEntry->Flink ) {

        LPSVCLOC_NETBIOS_RESP_ENTRY REntry;

        REntry = (LPSVCLOC_NETBIOS_RESP_ENTRY)RetEntry;

        RetResps[NumRetEntries] = REntry->Resp;

        //
        // don't free up the returned response buffer.
        //

        REntry->Resp.ResponseBuffer = NULL;

        NumRetEntries++;
    }

    TcpsvcsDbgAssert( NumRetEntries == NumResps );

    *NumResponses = NumRetEntries;
    *NetBiosResponses = RetResps;
    Error = ERROR_SUCCESS;

Cleanup:

    if( WaitHandles != NULL ) {
        SvclocHeap->Free( WaitHandles );
    }

    //
    // free response list.
    //

    while ( !IsListEmpty(RespList) ) {

        PLIST_ENTRY Entry;

        Entry = RemoveHeadList( RespList );

        //
        // free response buffer if it is not used.
        //

        if( ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                Entry)->Resp.ResponseBuffer != NULL ) {

            SvclocHeap->Free(
                ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                    Entry)->Resp.ResponseBuffer );
        }

        SvclocHeap->Free( Entry );
    }

    //
    // cancel all pending recvs and delete names.
    //

    if( NumPendingRecvs != 0 ) {

        NCB Ncb;

        memset( &Ncb, 0x0, sizeof(NCB) );
        Ncb.ncb_command = NCBCANCEL;
        Ncb.ncb_length = sizeof( NCB );

        for( i = 0; i < NumPendingRecvs; i++ ) {

            NCB *PendingEntry;
            UCHAR NcbError;
            DWORD Wait;
            BOOL CancelNcb;

            PendingEntry = &PendingRecvs[i];

            CancelNcb = FALSE;
            if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

                if( PendingEntry->ncb_retcode == NRC_PENDING ) {
                    CancelNcb = TRUE;
                }
            }
            else {

                //
                // check to see the event is signalled.
                //

                DWORD Wait;

                Wait = WaitForSingleObject(
                                PendingEntry->ncb_event,
                                0 );

                    if( Wait == WAIT_TIMEOUT ) {
                        CancelNcb = TRUE;
                    }
            }

            if( CancelNcb == TRUE ) {

                Ncb.ncb_retcode = NRC_GOODRET;
                Ncb.ncb_buffer = (LPBYTE)PendingEntry;
                Ncb.ncb_length = sizeof( NCB );
                Ncb.ncb_lana_num = PendingEntry->ncb_lana_num;

                Ncb.ncb_command = NCBCANCEL;

                NcbError = Netbios( &Ncb );

                if( (NcbError != NRC_GOODRET) ||
                    (Ncb.ncb_retcode != NRC_GOODRET) ) {

                    TcpsvcsDbgPrint((
                        DEBUG_ERRORS,
                            "Netbios() failed, %ld, %ld \n",
                                (DWORD)NcbError,
                                (DWORD)Ncb.ncb_retcode ));
                }
            }

            //
            // delete name.
            //

            Ncb.ncb_retcode = NRC_GOODRET;
            memcpy(
                Ncb.ncb_name,
                PendingEntry->ncb_name,
                sizeof( Ncb.ncb_name ) );

            Ncb.ncb_lana_num = PendingEntry->ncb_lana_num;
            Ncb.ncb_command = NCBDELNAME;

            NcbError = Netbios( &Ncb );

            if( (NcbError != NRC_GOODRET) ||
                (Ncb.ncb_retcode != NRC_GOODRET) ) {

                TcpsvcsDbgPrint((
                    DEBUG_ERRORS,
                        "Netbios() failed, %ld, %ld \n",
                            (DWORD)NcbError,
                            (DWORD)Ncb.ncb_retcode ));
            }

            //
            // free receive buffer.
            //

            SvclocHeap->Free( PendingEntry->ncb_buffer );
            CloseHandle( PendingEntry->ncb_event );
        }

        SvclocHeap->Free( PendingRecvs );
    }

    return( Error  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\svccom.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svccom.cxx

Abstract:

    Contains code that is common to both client and server side of
    the service location protocol..

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    Sean Woodward (t-seanwo) 26-October-1997    ADSI Update

--*/

#include <svcloc.hxx>

DWORD g_cInitializers = 0;

//
// include global.h one more time to alloc global data.
//

//
// to enable second time include.
//

#undef _GLOBAL_
#undef EXTERN

//
// to allocate data
//

#define GLOBAL_SVC_DATA_ALLOCATE

#include <global.h>

DWORD
MakeSapServiceName(
    LPSTR SapNameBuffer,
    DWORD SapNameBufferLen
    )
/*++

Routine Description:

    This routine generates a sap service name. The first part of the name
    is computername and last part is the string version of service guid.

Arguments:

    SapNameBuffer - pointer to a sap name buffer where sap name is
        returned.

    SapNameBufferLen - length of the above buffer.

Return Value:

    pointer to sap service name..

--*/
{
    TcpsvcsDbgAssert( SapNameBufferLen >= (SAP_SERVICE_NAME_LEN + 1));

    if( SapNameBufferLen < SAP_SERVICE_NAME_LEN + 1) {
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    //
    // Get Computername.
    //


    DWORD Len = SapNameBufferLen;

    if( !GetComputerNameA( SapNameBuffer, &Len ) ) {

        DWORD Error = GetLastError();

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "GetComputerNameA failed, %ld.\n", Error ));

        return( Error );
    }

    TcpsvcsDbgAssert( Len <= MAX_COMPUTERNAME_LENGTH );

    while( Len < MAX_COMPUTERNAME_LENGTH ) {
        SapNameBuffer[Len++] = '!';
    }

    //
    // append GUID.
    //

    strcpy( SapNameBuffer + Len, SERVICE_GUID_STR );

     return( ERROR_SUCCESS );
}

VOID
MakeUniqueServerName(
    LPBYTE StrBuffer,
    DWORD StrBufferLen,
    LPSTR ComputerName
    )
/*++

Routine Description:

    This routine makes an unique name used by the server to listen to
    the client discovery requests.

Arguments:

    StrBuffer : pointer to a buffer where the unique name is returned.

    StrBufferLen : length of the above buffer.

    ComputerName : pointer to the computer that is used to form the unique
        name.

Return Value:

    none.

--*/
{
    DWORD ComputerNameLen = strlen(ComputerName);
    DWORD BufLen = StrBufferLen;
    LPBYTE Buffer = StrBuffer;

    memset( Buffer, 0x0, BufLen );

    memcpy(
        Buffer,
        NETBIOS_INET_SERVER_UNIQUE_NAME,
        NETBIOS_INET_SERVER_UNIQUE_NAME_LEN );

    BufLen -= NETBIOS_INET_SERVER_UNIQUE_NAME_LEN;
    Buffer += NETBIOS_INET_SERVER_UNIQUE_NAME_LEN;

    if( BufLen >= ComputerNameLen  ) {

        //
        // we enough space in the buffer to append computername.
        //

        memcpy( Buffer,ComputerName, ComputerNameLen );
        return;
    }

    //
    // buffer does not have enough space, chop off few chars from the
    // begining of the computername.
    //

    memcpy( Buffer, ComputerName + (ComputerNameLen - BufLen), BufLen );
    return;
}

#if 0

VOID
AppendRandomChar(
    LPSTR String
    )
/*++

Routine Description:

    This routine adds a random char to the end of the given string. It is
    assumed that the given string has a space for the new char.

Arguments:

    String : pointer to a string where a random char is added.

Return Value:

    none.

--*/
{
    CHAR RandChar;
    DWORD RandNum;

    RandNum = (DWORD)rand();

    RandNum = RandNum % (26 + 10);  // 26 alphabets, and 10 numerics

    if( RandNum < 10 ) {
        RandChar = (CHAR)('0'+ RandNum);
    }
    else {
        RandChar = (CHAR)('A'+ RandNum - 10);
    }

    DWORD Len = strlen(String);

    //
    // append random char.
    //

    String[Len] = RandChar;
    String[Len + 1] = '\0';
    return;
}

#endif //0

DWORD
ComputeCheckSum(
    LPBYTE Buffer,
    DWORD BufferLength
    )
/*++

Routine Description:

    This function computes the check sum of the given buffer by ex-or'ing
    the dwords. It is assumed that the buffer DWORD aligned and the buffer
    length is multiples of DWORD.

Arguments:

    Buffer : pointer to a buffer whose check sum to be computed.

    BufferLength : length of the above buffer.

Return Value:

    Check sum.

--*/
{
    DWORD CheckSum = 0;
    LPDWORD BufferPtr = (LPDWORD)Buffer;
    LPBYTE EndBuffer = Buffer + BufferLength;

    TcpsvcsDbgAssert( (DWORD)Buffer % sizeof(DWORD) == 0 );
        // alignment check.

    TcpsvcsDbgAssert( BufferLength % sizeof(DWORD) == 0 );
        // multiple DWORD check.

    while( (LPBYTE)BufferPtr < EndBuffer ) {
        CheckSum ^= *BufferPtr;
        BufferPtr++;
    }

    return( CheckSum );
}

BOOL
DLLSvclocEntry(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    BOOL ok;
    DWORD error;

    UNREFERENCED_PARAMETER(DllHandle);

    //
    // perform global dll initialization, if any.
    //

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

        //
        // we switch off thread library calls to avoid taking a hit for every
        // thread creation/termination that happens in this process, regardless
        // of whether Internet APIs are called in the thread.
        //
        // If a new thread does make Internet API calls that require a per-thread
        // structure then the individual API will create one
        //

        DisableThreadLibraryCalls(DllHandle);

        //
        //  Old Normandy servers that are in our process are assuming the
        //  service locator is initialized by DLL_PROCESS_ATTACH and terminated
        //  by PROCESS_DETACH.  Since the service locator has a thread we
        //  can't safely cleanup during process_detach so we do an extra
        //  loadlibrary on ourselves and remain in process.  When the Normandy
        //  servers are updated, remove this.
        //

        if ( !InitSvcLocator() ||
             !LoadLibrary( "inetsloc.dll" ))
        {
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return (TRUE);
}

BOOL
InitSvcLocator(
    VOID
    )
{
    //
    //  We assume the caller is serializing access from multiple initializers.
    //  The callers will presumably be just infocomm.dll that does do the
    //  serialization.
    //
    //

    if ( g_cInitializers++ ) {
        return TRUE;
    }

    if ( DllProcessAttachSvcloc() != ERROR_SUCCESS ) {
        return FALSE;
    }

    return TRUE;
}

BOOL
TerminateSvcLocator(
    VOID
    )
{
    if ( --g_cInitializers )
        return TRUE;

    DllProcessDetachSvcloc();

    return TRUE;
}



DWORD
DllProcessAttachSvcloc(
    VOID
    )
/*++

Routine Description:

    This dll init function initializes service location global variables.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    //
    // initialize global variables.
    //

    // DebugBreak();

#if DBG

    //
    // initialize dbg crit sect.
    //

    INITIALIZE_CRITICAL_SECTION( &GlobalDebugCritSect );
    GlobalDebugFlag = DEBUG_ERRORS;

#endif // DBG

    INITIALIZE_CRITICAL_SECTION( &GlobalSvclocCritSect );

    LOCK_SVC_GLOBAL_DATA();
    GlobalComputerName[0] = '\0';

    GlobalSrvRegistered = FALSE;
    SvclocHeap = new MEMORY;

    if( SvclocHeap == NULL ) {
        UNLOCK_SVC_GLOBAL_DATA();
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    GlobalSrvInfoObj = NULL;

    GlobalSrvRespMsg = NULL;
    GlobalSrvRespMsgLength = 0;
    GlobalSrvAllotedRespMsgLen = 0;

    GlobalWinsockStarted = FALSE;
    GlobalRNRRegistered = FALSE;

    GlobalSrvListenThreadHandle = NULL;

    memset( &GlobalSrvSockets, 0x0, sizeof(GlobalSrvSockets) );

    GlobalCliDiscoverThreadHandle = NULL;

    GlobalCliQueryMsg = NULL;
    GlobalCliQueryMsgLen = 0;

    GlobalSapGuid.Data1 = ssgData1;
    GlobalSapGuid.Data2 = ssgData2;
    GlobalSapGuid.Data3 = ssgData3;
    GlobalSapGuid.Data4[0] = ssgData41;
    GlobalSapGuid.Data4[1] = ssgData42;
    GlobalSapGuid.Data4[2] = ssgData43;
    GlobalSapGuid.Data4[3] = ssgData44;
    GlobalSapGuid.Data4[4] = ssgData45;
    GlobalSapGuid.Data4[5] = ssgData46;
    GlobalSapGuid.Data4[6] = ssgData47;
    GlobalSapGuid.Data4[7] = ssgData48;

    InitializeListHead( &GlobalCliQueryRespList );

    memset( &GlobalCliSockets, 0x0, sizeof(GlobalCliSockets) );
    memset( &GlobalCliNBSockets, 0x0, sizeof(GlobalCliNBSockets) );
    GlobalCliIpxSocket = INVALID_SOCKET;

    GlobalDiscoveryInProgressEvent =
        IIS_CREATE_EVENT(
            "GlobalDiscoveryInProgressEvent",
            &GlobalDiscoveryInProgressEvent,
            TRUE,       // MANUAL reset
            TRUE        // initial state: signalled
            );

    if ( GlobalDiscoveryInProgressEvent == NULL ) {
        Error = GetLastError();
        UNLOCK_SVC_GLOBAL_DATA();
        return(Error);
    }

    GlobalLastDiscoveryTime = 0;

    //
    // get platform type.
    //

    OSVERSIONINFO VersionInfo;

    VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);

    if ( (GetVersionEx(&VersionInfo)) ) {
        GlobalPlatformType = VersionInfo.dwPlatformId;
    }
    else {
        UNLOCK_SVC_GLOBAL_DATA();
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    GlobalNumNBPendingRecvs = 0;
    GlobalNBPendingRecvs = NULL;

    InitializeListHead( &GlobalWin31NBRespList );
    GlobalWin31NumNBResps = 0;

    UNLOCK_SVC_GLOBAL_DATA();
    srand( (unsigned)time(NULL));

    return( ERROR_SUCCESS );
}

DWORD
DllProcessDetachSvcloc(
    VOID
    )
/*++

Routine Description:

    This fundtion frees the global service location objects.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    LOCK_SVC_GLOBAL_DATA();

    if( GlobalSrvRegistered ) {
        ServerDeregisterAndStopListen();
    }

    if( GlobalSrvInfoObj != NULL ) {
        delete GlobalSrvInfoObj;
        GlobalSrvInfoObj = NULL;
    }

    if( GlobalSrvRespMsg != NULL ) {
        SvclocHeap->Free( GlobalSrvRespMsg );
        GlobalSrvRespMsg = NULL;
        GlobalSrvRespMsgLength = 0;
        GlobalSrvAllotedRespMsgLen = 0;
    }

    if( GlobalSrvRecvBuf != NULL ) {
        SvclocHeap->Free( GlobalSrvRecvBuf );
        GlobalSrvRecvBuf = NULL;
        GlobalSrvRecvBufLength = 0;
    }

    if( GlobalCliQueryMsg != NULL ) {
        SvclocHeap->Free( GlobalCliQueryMsg );
        GlobalCliQueryMsg = NULL;
        GlobalCliQueryMsgLen = 0;
    }

    InitializeListHead( &GlobalCliQueryRespList );

    while( !IsListEmpty( &GlobalCliQueryRespList ) ) {

        LPCLIENT_QUERY_RESPONSE QueryResponse;

        //
        // remove head entry and free it up.
        //

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)
            RemoveHeadList( &GlobalCliQueryRespList );

        //
        // free response buffer.
        //

        SvclocHeap->Free( QueryResponse->ResponseBuffer );

        //
        // free this node.
        //

        SvclocHeap->Free( QueryResponse );
    }

    //
    // close client sockets.
    //

    DWORD i;

    for( i = 0; i <  GlobalCliSockets.fd_count; i++ ) {
        closesocket( GlobalCliSockets.fd_array[i] );
    }

    //
    // invalidate client handles.
    //

    memset( &GlobalCliSockets, 0x0, sizeof(GlobalCliSockets) );
    memset( &GlobalCliNBSockets, 0x0, sizeof(GlobalCliNBSockets) );
    GlobalCliIpxSocket = INVALID_SOCKET;


    //
    // stop client discovery thread.
    //

    if( GlobalCliDiscoverThreadHandle != NULL ) {

        //
        // Wait for the client discovery thread to stop, but don't wait
        // for longer than THREAD_TERMINATION_TIMEOUT msecs (60 secs)
        //

        DWORD WaitStatus =
            WaitForSingleObject(
                    GlobalCliDiscoverThreadHandle,
                    THREAD_TERMINATION_TIMEOUT );

        TcpsvcsDbgAssert( WaitStatus != WAIT_FAILED );

        if(  WaitStatus == WAIT_FAILED ) {
            TcpsvcsDbgPrint((DEBUG_ERRORS,
                "WaitForSingleObject call failed, %ld\n", GetLastError() ));
        }

        CloseHandle( GlobalCliDiscoverThreadHandle );
        GlobalCliDiscoverThreadHandle = NULL;
    }

    if( GlobalWinsockStarted ) {
        WSACleanup();
        GlobalWinsockStarted = FALSE;
    }

    TcpsvcsDbgAssert( GlobalNumNBPendingRecvs == 0)
    TcpsvcsDbgAssert( GlobalNBPendingRecvs == NULL );

    if( GlobalNBPendingRecvs != NULL ) {
        SvclocHeap->Free( GlobalNBPendingRecvs );
    }

    TcpsvcsDbgAssert( GlobalWin31NumNBResps == 0)
    TcpsvcsDbgAssert( IsListEmpty( &GlobalWin31NBRespList ) == TRUE );

    //
    // free response list.
    //

    while ( !IsListEmpty( &GlobalWin31NBRespList ) ) {

        PLIST_ENTRY Entry;

        Entry = RemoveHeadList( &GlobalWin31NBRespList );

        //
        // free response buffer if it is not used.
        //

        if( ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                Entry)->Resp.ResponseBuffer != NULL ) {

            SvclocHeap->Free(
                ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                    Entry)->Resp.ResponseBuffer );
        }

        SvclocHeap->Free( Entry );
    }

    if( SvclocHeap != NULL ) {
        delete SvclocHeap;
        SvclocHeap = NULL;
    }

    if( GlobalDiscoveryInProgressEvent != NULL ) {
        CloseHandle( GlobalDiscoveryInProgressEvent );
        GlobalDiscoveryInProgressEvent = NULL;
    }

    GlobalLastDiscoveryTime = 0;

    UNLOCK_SVC_GLOBAL_DATA();

    DeleteCriticalSection( &GlobalSvclocCritSect );

#if DBG

    //
    // Delete dbg crit sect.
    //

    DeleteCriticalSection( &GlobalDebugCritSect );

#endif // DBG


    return( ERROR_SUCCESS );
}

VOID
FreeServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This function frees the memory blocks consumed by the service info
    structure.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    None.

--*/
{
    TcpsvcsDbgAssert( ServiceInfo != NULL );

    if( ServiceInfo == NULL ) {
        return;
    }

    //
    // free all leaves of the tree first and then branches.
    //

    //
    // free service comment.
    //

    if( ServiceInfo->ServiceComment != NULL ) {
        SvclocHeap->Free(  ServiceInfo->ServiceComment );
    }

    if( ServiceInfo->Bindings.NumBindings ) {

        TcpsvcsDbgAssert( ServiceInfo->Bindings.BindingsInfo != NULL );

        if(  ServiceInfo->Bindings.BindingsInfo != NULL ) {
            DWORD i;

            for( i = 0; i < ServiceInfo->Bindings.NumBindings; i++ ) {

                if( ServiceInfo->Bindings.BindingsInfo[i].BindData != NULL ) {
                    SvclocHeap->Free( ServiceInfo->Bindings.BindingsInfo[i].BindData );
                }
            }

            SvclocHeap->Free(  ServiceInfo->Bindings.BindingsInfo );
        }
    }
    else {
        TcpsvcsDbgAssert( ServiceInfo->Bindings.BindingsInfo == NULL );
    }

    SvclocHeap->Free( ServiceInfo );

    return;
}

VOID
FreeServerInfo(
    LPINET_SERVER_INFO ServerInfo
    )
/*++

Routine Description:

    This function frees the memory blocks consumed by the server info
    structure.

Arguments:

    ServerInfo : pointer to a server info structure.

Return Value:

    None.

--*/
{
    DWORD i;

    if( ServerInfo != NULL ) {

        //
        // first free all service info.
        //

        if( ServerInfo->Services.NumServices > 0 ) {
            TcpsvcsDbgAssert( ServerInfo->Services.Services != NULL );
        }
        for ( i = 0; i < ServerInfo->Services.NumServices; i++) {

            FreeServiceInfo( ServerInfo->Services.Services[i] );
        }

        //
        // now free services pointer array.
        //

        if( ServerInfo->Services.Services != NULL ) {
            SvclocHeap->Free( ServerInfo->Services.Services );
        }

        //
        // free server address.
        //

        if( ServerInfo->ServerAddress.BindData != NULL ) {
            SvclocHeap->Free( ServerInfo->ServerAddress.BindData );
        }

        //
        // free server name.
        //

        if( ServerInfo->ServerName != NULL ) {
            SvclocHeap->Free( ServerInfo->ServerName );
        }

        //
        // now server info structure.
        //

        SvclocHeap->Free( ServerInfo );
    }

    return;
}

VOID
FreeServersList(
    LPINET_SERVERS_LIST ServersList
    )
/*++

Routine Description:

    This function frees the memory blocks consumed by the servers list
    structure.

Arguments:

    ServersList : pointer to a servers liststructure.

Return Value:

    None.

--*/
{
    if( ServersList != NULL ) {

        //
        // free server info structures.
        //

        if( ServersList->NumServers > 0 ) {
            TcpsvcsDbgAssert( ServersList->Servers != NULL );
        }

        DWORD i;

        for( i = 0; i < ServersList->NumServers; i++ ) {
            FreeServerInfo( ServersList->Servers[i] );
        }

        //
        // free servers info pointer array.
        //
        if( ServersList->Servers != NULL ) {
            SvclocHeap->Free( ServersList->Servers );
        }


        //
        // servers list structure.
        //

        SvclocHeap->Free( ServersList );
    }

    return;
}

BOOL
GetNetBiosLana(
    PLANA_ENUM pLanas
    )
/*++

Routine Description:

    This function enumurate all netbios lana on the system.

Arguments:

    pLanas - pointer to LANA_ENUM structure where enum is returned.

Return Value:

    TRUE - if successed.
    FALSE - otherwise.

--*/
{
    NCB NetBiosNCB;
    UCHAR NBErrorCode;

    memset( &NetBiosNCB, 0,  sizeof(NetBiosNCB) );
    NetBiosNCB.ncb_command = NCBENUM;
    NetBiosNCB.ncb_buffer = (PUCHAR)pLanas;
    NetBiosNCB.ncb_length = sizeof(LANA_ENUM);

    NBErrorCode = Netbios( &NetBiosNCB );

    if( (NBErrorCode == NRC_GOODRET) &&
        (NetBiosNCB.ncb_retcode == NRC_GOODRET) ) {

        return( TRUE );
    }

    TcpsvcsDbgPrint(( DEBUG_ERRORS, "NetBios() failed, %ld, %ld \n",
        NBErrorCode, NetBiosNCB.ncb_retcode ));

    return( FALSE );
}


BOOL
GetEnumNBLana(
    PLANA_ENUM pLanas
    )
/*++

Routine Description:

    This function enumurate all netbios lana on the system.

Arguments:

    pLanas - pointer to LANA_ENUM structure where enum is returned.

Return Value:

    TRUE - if successed.
    FALSE - otherwise.

--*/
{
    DWORD Error;
    INT ProtocolCount;
    PPROTOCOL_INFO ProtocolBuffer = NULL;
    DWORD ProtocolBufferSize = 0;

    //
    // init return value.
    //

    pLanas->length = 0;

    //
    // determine the enum buffer size required.
    //

    ProtocolCount = EnumProtocols(
                        NULL,
                        NULL,
                        &ProtocolBufferSize );

    if( ProtocolCount == SOCKET_ERROR ) {

        Error = WSAGetLastError();

        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            goto Cleanup;
        }
    }

    if( (ProtocolBufferSize == 0) || (ProtocolCount == 0) ) {

        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate memory for the protocol buffer.
    //

    ProtocolBuffer =
        (PPROTOCOL_INFO)SvclocHeap->Alloc( ProtocolBufferSize );

    if( ProtocolBuffer == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // now enum protocols.
    //

    ProtocolCount = EnumProtocols(
                        NULL,
                        ProtocolBuffer,
                        &ProtocolBufferSize );

    if( ProtocolCount == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    TcpsvcsDbgAssert( ProtocolCount > 0 );

    //
    // now filter net bios protcols only and get the corresponding lana
    // values.
    //

    DWORD i;
    for ( i = 0; i < (DWORD)ProtocolCount; i++ ) {

        if( ProtocolBuffer[i].iAddressFamily == AF_NETBIOS ) {

            if( pLanas->length < MAX_LANA ) {

                UCHAR Lana;
                DWORD j;

                Lana = (UCHAR)((INT)ProtocolBuffer[i].iProtocol * (-1));

                //
                // if this is a new lana add to list.
                //

                for ( j = 0; j < pLanas->length ; j++ ) {
                    if( pLanas->lana[j] == Lana ) {
                        break;
                    }
                }

                if( j >= pLanas->length ) {
                    pLanas->lana[pLanas->length] = Lana;
                    pLanas->length++;
                }
            }
        }
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( ProtocolBuffer != NULL ) {
        SvclocHeap->Free( ProtocolBuffer );
    }

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "GetNetBiosLana failed, %ld\n", Error ));
        return( FALSE );
    }

    return( TRUE );
}


BOOL
MakeNBSocketForLana(
    UCHAR Lana,
    PSOCKADDR  pSocketAddress,
    SOCKET *pNBSocket
    )
/*++

Routine Description:

    This function possibly creates a socket for the given lana and binds
    to the given socket address.

    ASSUME : global data crit sect is locked.

Arguments:

    Lana : lana number for the new sockets.

    pSocketAddress : pointer to a socket address to bind to.

    pNBSocket : pointer to a location where the new socket is returned.

Return Value:

    TRUE : if successfully created a socket and bound to the given nb
        addresse.
    FALSE : otherwise.

--*/
{
    DWORD Error;
    SOCKET NBSocket;
    DWORD Arg = 1;

    *pNBSocket = INVALID_SOCKET;

    //
    // create a socket for this lana.
    //

    NBSocket = socket( AF_NETBIOS, SOCK_DGRAM, Lana );

    if( NBSocket == INVALID_SOCKET ) {

        Error = WSAGetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "socket() failed, %ld\n", Error ));

        //
        // something wrong with this lana, try rest.
        //

        return( FALSE );
    }

    //
    // make this socket non blocking.
    //

    if( (ioctlsocket( NBSocket, FIONBIO, &Arg )) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "ioctlsocket() failed, %ld\n", Error ));

        //
        // something wrong with this lana, try rest.
        //

        closesocket( NBSocket );
        return( FALSE );
    }

    //
    // bind to this socket.
    //

    if( bind(
            NBSocket,
            pSocketAddress,
            sizeof(SOCKADDR_NB) ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "ioctlsocket() failed, %ld\n", Error ));

        //
        // something wrong with this lana, try rest.
        //

        closesocket( NBSocket );
        return( FALSE );
    }

    *pNBSocket = NBSocket;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\svcinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcinfo.cxx

Abstract:

    contains class implementation of service location classes.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    Sean Woodward (t-seanwo) 26-October-1997    ADSI Update

--*/

#include <svcloc.hxx>

DWORD
EMBED_SERVICE_INFO::ComputeServiceInfoSize(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This private member function computes the size of the embedded service
    info buffer.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    size of the embedded service info buffer.

--*/
{
    DWORD Size;
    DWORD NumBindings;
    LPINET_BIND_INFO BindingsInfo;
    DWORD i;
    DWORD ServiceCommentLen;

    if( ServiceInfo->ServiceComment != NULL) {
        ServiceCommentLen =
            ROUND_UP_COUNT(
                (strlen(ServiceInfo->ServiceComment) + 1) * sizeof(CHAR),
                            ALIGN_DWORD);
    }
    else {
        ServiceCommentLen = ROUND_UP_COUNT( 1, ALIGN_DWORD );
    }

    Size =
        sizeof(ULONGLONG) + // service mask
        sizeof(INET_SERVICE_STATE) + // service state
        ServiceCommentLen + // service comment
        sizeof(DWORD); // NumBindings

    NumBindings = ServiceInfo->Bindings.NumBindings;
    BindingsInfo = ServiceInfo->Bindings.BindingsInfo;

    if( NumBindings != 0 ) {

        TcpsvcsDbgAssert( BindingsInfo != NULL )

        for( i = 0; i < NumBindings; i++ ) {

            Size += sizeof(DWORD);

            if( BindingsInfo[i].Length != 0 ) {

                Size += ROUND_UP_COUNT(BindingsInfo[i].Length, ALIGN_DWORD);
                TcpsvcsDbgAssert( BindingsInfo[i].BindData != NULL );
            }
        }
    }

    return( Size );
}

VOID
EMBED_SERVICE_INFO::CopyServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This private member function copies service info to the embedded service info buffer.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    NONE.

--*/
{
    DWORD NumBindings;
    LPINET_BIND_INFO BindingsInfo;
    DWORD i;
    LPBYTE EndofBuffer;
    LPBYTE BufferPtr;

    NumBindings = ServiceInfo->Bindings.NumBindings;
    BindingsInfo = ServiceInfo->Bindings.BindingsInfo;

    BufferPtr = _ServiceInfoBuffer;
    EndofBuffer = _ServiceInfoBuffer + _ServiceInfoLength;

    //
    // copy header.
    //

    *(ULONGLONG UNALIGNED *)BufferPtr = ServiceInfo->ServiceMask;
    _ServiceMask = (ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    *(INET_SERVICE_STATE *)BufferPtr = ServiceInfo->ServiceState;
    _ServiceState = (INET_SERVICE_STATE *)BufferPtr;
    BufferPtr += sizeof(INET_SERVICE_STATE);

    //
    // copy service comment.
    //

    DWORD CommentLen;

    if( ServiceInfo->ServiceComment != NULL) {
        CommentLen =
            ROUND_UP_COUNT(
                (strlen(ServiceInfo->ServiceComment) + 1) * sizeof(CHAR),
                            ALIGN_DWORD);
    }
    else {
        CommentLen = ROUND_UP_COUNT( 1, ALIGN_DWORD );
    }

    TcpsvcsDbgAssert( (BufferPtr + CommentLen) < EndofBuffer );

    if( ServiceInfo->ServiceComment != NULL) {
        strcpy( (LPSTR)BufferPtr, ServiceInfo->ServiceComment );
    }
    else {
        *(LPSTR)BufferPtr = '\0';
    }

    BufferPtr += CommentLen;

    *(DWORD *)BufferPtr = ServiceInfo->Bindings.NumBindings;
    BufferPtr += sizeof(DWORD);

    //
    // copy bindings.
    //

    if( NumBindings != 0 ) {

        for( i = 0; i < NumBindings; i++ ) {

            TcpsvcsDbgAssert( BufferPtr < EndofBuffer );

            *(DWORD *)BufferPtr = BindingsInfo[i].Length;
            BufferPtr += sizeof(DWORD);

            if( BindingsInfo[i].Length != 0 ) {

                memcpy( BufferPtr, BindingsInfo[i].BindData, BindingsInfo[i].Length );
                BufferPtr += ROUND_UP_COUNT( BindingsInfo[i].Length, ALIGN_DWORD );
            }
        }
    }

    TcpsvcsDbgAssert( BufferPtr == EndofBuffer );

    return;
}

EMBED_SERVICE_INFO::EMBED_SERVICE_INFO(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This function constructs an embedded service info object.

    Note : embedded service info buffer layout :

    dword 1 : ServiceMask
              2 : ServiceState
              3 : NumBindings
              4 : Binding1 Length
              5 : Binding1
              6 :     ..
              7 :     ..
              8 :     ..
              9 :  Binding2 Length
              10 : Binding2
              11 : ..
              12 : ..

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    NONE.

--*/
{
    DWORD Size;

    //
    // initialize the object elements.
    //

    INITIALIZE_CRITICAL_SECTION( &_ServiceObjCritSect );

    _ServiceInfoLength = 0;
    _ServiceInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _ServiceState = NULL;
    _ServiceComment = NULL;
    _ServiceMask = NULL;

    TcpsvcsDbgAssert( ServiceInfo != NULL );

    if( ServiceInfo == NULL ) {
        _Status = ERROR_INVALID_PARAMETER;
        return;
    }

    //
    // compute the embedded buffer length.
    //

    Size = ComputeServiceInfoSize( ServiceInfo );
    TcpsvcsDbgAssert( Size != 0 );

    //
    // allocate memory.
    //

    _ServiceInfoBuffer = (LPBYTE) SvclocHeap->Alloc( Size );

    if( _ServiceInfoBuffer == NULL ) {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _ServiceInfoLength = Size;
    _AllottedBufferSize = Size;

    //
    // copy service info.
    //

    CopyServiceInfo( ServiceInfo );

    _Status = ERROR_SUCCESS;
    return;
}


EMBED_SERVICE_INFO::EMBED_SERVICE_INFO(
    LPBYTE InfoBuffer,
    DWORD InfoBufferLength
    )
/*++

Routine Description:

    This function constructs an embedded service info object from a given
        embedded buffer.

Arguments:

    InfoBuffer : pointer to a embedded buffer.

    InfoBufferLength : length of the embedded buffer.

Return Value:

    NONE.

--*/
{
    TcpsvcsDbgAssert( InfoBuffer != NULL );
    TcpsvcsDbgAssert( InfoBufferLength != 0 );

    INITIALIZE_CRITICAL_SECTION( &_ServiceObjCritSect );
    _ServiceInfoLength = InfoBufferLength;
    _ServiceInfoBuffer = InfoBuffer;
    _AllottedBufferSize = 0;

    _ServiceMask = (ULONGLONG UNALIGNED *)InfoBuffer;
    _ServiceState = (INET_SERVICE_STATE *)(InfoBuffer + sizeof(ULONGLONG));
    _ServiceComment = (LPSTR)
        (InfoBuffer +
            sizeof(ULONGLONG)
                sizeof(INET_SERVICE_STATE) );

    _Status = ERROR_SUCCESS;
}

EMBED_SERVICE_INFO::~EMBED_SERVICE_INFO(
    VOID
    )
/*++

Routine Description:

    This function destructs a embedded service info object.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    if( _AllottedBufferSize != 0 ) {

        TcpsvcsDbgAssert( _ServiceInfoBuffer != NULL );

        SvclocHeap->Free( _ServiceInfoBuffer );
    }

#if DBG

    _ServiceInfoLength = 0;
    _ServiceInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _ServiceState = NULL;
    _ServiceComment = NULL;
    _ServiceMask = NULL;

#endif // DBG

    DeleteCriticalSection( &_ServiceObjCritSect );
    _Status = ERROR_SUCCESS;
    return;
}

DWORD
EMBED_SERVICE_INFO::SetServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This member function sets the new service info to the embedded service
    info buffer.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    Windows error code.

--*/
{
    DWORD Size;

    TcpsvcsDbgAssert( ServiceInfo != NULL );

    LockServiceObj();

    if( ServiceInfo == NULL ) {
        UnlockServiceObj();
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // compute the size of the new service info buffer.
    //

    Size = ComputeServiceInfoSize( ServiceInfo ) ;

    TcpsvcsDbgAssert( Size != 0 );

    if( Size > _AllottedBufferSize ) {

        LPBYTE NewServiceInfoBuffer;

        //
        // free the old buffer and reallocate a new one.
        //

        NewServiceInfoBuffer = (LPBYTE) SvclocHeap->Alloc( Size );

        if( NewServiceInfoBuffer == NULL ) {
            UnlockServiceObj();
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        SvclocHeap->Free( _ServiceInfoBuffer );
        _ServiceInfoBuffer = NewServiceInfoBuffer;

        _AllottedBufferSize = Size;
    }

    _ServiceInfoLength = Size;

    //
    // now copy buffer.
    //

    CopyServiceInfo( ServiceInfo );

    UnlockServiceObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVICE_INFO::GetServiceInfo(
    LPINET_SERVICE_INFO *ServiceInfo
    )
/*++

Routine Description:

    This member function allocates memory for service info structure and
    copies service info from embedded service info buffer.

Arguments:

    ServiceInfo : pointer to a location where the server info structure
        pointer is returned. The caller should free the structure after
        use.

Return Value:

    Windows error code.

--*/
{
    DWORD Error;
    LPBYTE BufferPtr = _ServiceInfoBuffer;
    LPBYTE EndBufferPtr = _ServiceInfoBuffer + _ServiceInfoLength;
    DWORD NumBindings;
    DWORD i;

    LPINET_SERVICE_INFO LocalServiceInfo = NULL;

    LockServiceObj();

    //
    // allocate memory for the service info structure.
    //

    LocalServiceInfo = (LPINET_SERVICE_INFO)
        SvclocHeap->Alloc( sizeof( INET_SERVICE_INFO ) );

    if( LocalServiceInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // copy main structure first.
    //

    LocalServiceInfo->ServiceMask = *(ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    LocalServiceInfo->ServiceState = *(INET_SERVICE_STATE *)BufferPtr;
    BufferPtr += sizeof(INET_SERVICE_STATE);

    //
    // allocate memory for the service comment.
    //

    DWORD CommentLen;

    CommentLen =
        ROUND_UP_COUNT(
            (strlen((LPSTR)BufferPtr) + 1) * sizeof(CHAR),
                ALIGN_DWORD );

     LocalServiceInfo->ServiceComment = (LPSTR)
         SvclocHeap->Alloc( CommentLen );

     if( LocalServiceInfo->ServiceComment == NULL ) {
         Error = ERROR_NOT_ENOUGH_MEMORY;
         goto Cleanup;
     }

     //
     // copy service comment.
     //

     strcpy(
         LocalServiceInfo->ServiceComment,
         (LPSTR)BufferPtr );

    BufferPtr += CommentLen;

    NumBindings = *(DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    LocalServiceInfo->Bindings.NumBindings = 0;
    LocalServiceInfo->Bindings.BindingsInfo =  NULL;

    if( NumBindings != 0 ) {

        LPINET_BIND_INFO Bindings;

        //
        // allocate memory for bindingsinfo array.
        //

        Bindings = (LPINET_BIND_INFO)
            SvclocHeap->Alloc( sizeof( INET_BIND_INFO )  * NumBindings );

        if( Bindings == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        LocalServiceInfo->Bindings.BindingsInfo = Bindings;

        for( i = 0; i < NumBindings; i++ ) {

            LPBYTE BindData;

            TcpsvcsDbgAssert( BufferPtr < EndBufferPtr );

            Bindings[i].Length = *(DWORD *)BufferPtr;
            BufferPtr += sizeof(DWORD);

            //
            // allocate memory for the bind data.
            //

            BindData = (LPBYTE)SvclocHeap->Alloc( Bindings[i].Length );

            if( BindData == NULL ) {

                //
                // free the bindings structure memory only if NumBindings
                // is zero, otherwise it will be freed later on along
                // with some other memory blocks.
                //

                if( LocalServiceInfo->Bindings.NumBindings == 0 ) {

                    if( LocalServiceInfo->Bindings.BindingsInfo != NULL ) {
                        SvclocHeap->Free( LocalServiceInfo->Bindings.BindingsInfo );
                        LocalServiceInfo->Bindings.BindingsInfo = NULL;
                    }
                }

                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            //
            // copy bind data.
            //

            memcpy( BindData, BufferPtr, Bindings[i].Length );
            BufferPtr += ROUND_UP_COUNT( Bindings[i].Length, ALIGN_DWORD );

            //
            // successfully copied one more bind data.
            //

            Bindings[i].BindData = BindData;
            LocalServiceInfo->Bindings.NumBindings++;
        }
    }

    //
    // all done.
    //

    *ServiceInfo = LocalServiceInfo;
    LocalServiceInfo = NULL;
    Error = ERROR_SUCCESS;

Cleanup:

    if( LocalServiceInfo != NULL ) {
        FreeServiceInfo( LocalServiceInfo );
    }

    UnlockServiceObj();
    return( Error );
}

/*---------------------------------------------------------------------*/

BOOL
EMBED_SERVER_INFO::IsServiceEntryExist(
    ULONGLONG ServiceMask,
    LPEMBED_SERVICE_ENTRY *ServiceEntry
    )
/*++

Routine Description:

    This private member function looks up a service entry in the service
    list.

Arguments:

    ServiceMask : mask of the service to look at.

    ServiceEntry : pointer to location where the service entry pointer is
        returned if found.

Return Value:

    TRUE : if the service entry is found in the service list.
    FALSE : otherwise.

--*/
{

    PLIST_ENTRY SList;
    LPEMBED_SERVICE_ENTRY SEntry;
    ULONGLONG SMask;

    //
    // Scan service list.
    //

    for( SList = _ServicesList.Flink; SList != &_ServicesList; SList = SList->Flink ) {

        SEntry = (LPEMBED_SERVICE_ENTRY)SList;

        //
        // Get Service Mask.
        //

        SMask =  (SEntry->ServiceObject)->GetServiceMask();

        if( SMask == ServiceMask ) {

            //
            // found the service entry.
            //

            *ServiceEntry = SEntry;
            return( TRUE );
        }
    }

    return( FALSE );
}

EMBED_SERVER_INFO::EMBED_SERVER_INFO(
    WORD MajorVersion,
    WORD MinorVersion,
    LPSTR ServerName
    )
/*++

Routine Description:

    This member function constructs a server info object.

Arguments:

    MajorVersion :  major version number of the server software.

    MinorVersion :  minor version number of the server software.

    ServerName : computer name of the server.

Return Value:

    None.

--*/
{
    DWORD Size;
    LPBYTE BufferPtr;
    DWORD ServerNameLen;

    //
    // init object fields.
    //

    INITIALIZE_CRITICAL_SECTION( &_ServerObjCritSect );

    _ServerInfoLength = 0;
    _ServerInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _VersionNum = NULL;
    _ServerLoad = NULL;
    _ServicesMask = NULL;
    _ServerName = NULL;
    _NumServices = NULL;

    InitializeListHead( &_ServicesList );

    //
    // compute Server Info Size.
    //

    ServerNameLen = ROUND_UP_COUNT(
                        (strlen(ServerName) + 1) * sizeof(CHAR),
                            ALIGN_DWORD);

    Size = sizeof(INET_VERSION_NUM) +   // for version number
                    ServerNameLen +     // for server name
                    sizeof(DWORD) +     // for load factor
                    sizeof(ULONGLONG) +  // for services mask.
                    sizeof(DWORD);      // for number of services.

    _ServerInfoBuffer = (LPBYTE)SvclocHeap->Alloc( Size );

    if( _ServerInfoBuffer == NULL ) {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _ServerInfoLength = Size;
    _AllottedBufferSize = Size;

    BufferPtr = _ServerInfoBuffer;

    ((INET_VERSION_NUM *)BufferPtr)->Version.Major = MajorVersion;
    ((INET_VERSION_NUM *)BufferPtr)->Version.Minor = MinorVersion;

    _VersionNum = (INET_VERSION_NUM *)BufferPtr;
    BufferPtr += sizeof(INET_VERSION_NUM);

   strcpy( (LPSTR)BufferPtr, ServerName );
    _ServerName = (LPSTR)BufferPtr;
    BufferPtr += ServerNameLen;

    *(DWORD *)BufferPtr  = 0; // load factor
    _ServerLoad = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    *(ULONGLONG UNALIGNED *)BufferPtr  = 0; // services mask;
    _ServicesMask = (ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    *(DWORD *)BufferPtr  = 0; // num services.
    _NumServices = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    TcpsvcsDbgAssert( BufferPtr == (_ServerInfoBuffer + _ServerInfoLength) );

    _Status = ERROR_SUCCESS;
    return;
}

EMBED_SERVER_INFO::EMBED_SERVER_INFO(
    LPBYTE ResponseBuffer,
    DWORD ResponseBufferLength
    )
/*++

Routine Description:

    This member function constructs a server info object from embedded
    server info buffer (received from the server).

Arguments:

    ResponseBuffer : pointer to the embedded server info buffer.

    ResponseBufferLength : length of the above buffer.

Return Value:

--*/
{
    LPBYTE BufferPtr;
    DWORD ServerNameLen;
    DWORD nServices;
    DWORD i;

    INITIALIZE_CRITICAL_SECTION( &_ServerObjCritSect );

    //
    // set object fields.
    //

    BufferPtr = _ServerInfoBuffer = ResponseBuffer;

    _VersionNum = (INET_VERSION_NUM *)BufferPtr;
    BufferPtr += sizeof(INET_VERSION_NUM); // skip version number.

    _ServerName = (LPSTR)BufferPtr;
    ServerNameLen =
        ROUND_UP_COUNT(
                (strlen((LPSTR)BufferPtr) + 1) * sizeof(CHAR),
                ALIGN_DWORD);

    BufferPtr += ServerNameLen;

    _ServerLoad = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    _ServicesMask = (ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    _NumServices = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    _ServerInfoLength = BufferPtr - _ServerInfoBuffer;
    _AllottedBufferSize = 0;

    nServices = *_NumServices;

    InitializeListHead( &_ServicesList );

    //
    // now make service objects.
    //

    for( i = 0; i < nServices; i++) {

        DWORD ServiceBufferLength;
        LPSERVICE_OBJECT ServiceObject;
        DWORD ObjStatus;
        LPEMBED_SERVICE_ENTRY ServiceEntry;

        ServiceBufferLength = *(DWORD * )BufferPtr;
        BufferPtr += sizeof(DWORD);

        //
        // make another service object.
        //

        ServiceObject =
            new EMBED_SERVICE_INFO( BufferPtr, ServiceBufferLength );

        if( ServiceObject == NULL ) {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            return;
        }

        ObjStatus = ServiceObject->GetStatus();

        if( ObjStatus != ERROR_SUCCESS ) {
            _Status = ObjStatus;
            delete ServiceObject;
            return;
        }

        //
        // allocate space for a new service entry.
        //

        ServiceEntry = (LPEMBED_SERVICE_ENTRY)
            SvclocHeap->Alloc( sizeof(EMBED_SERVICE_ENTRY) );

        if( ServiceEntry == NULL ) {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            delete ServiceObject;
            return;
        }

        ServiceEntry->ServiceObject = ServiceObject;

        //
        // add this new entry to the list.
        //

        InsertTailList( &_ServicesList, &ServiceEntry->NextEntry );

        //
        // point to the next service record.
        //

        BufferPtr += ServiceBufferLength;
    }

    _Status = ERROR_SUCCESS;
    return;
}

EMBED_SERVER_INFO::~EMBED_SERVER_INFO(
    VOID
    )
/*++

Routine Description:

    This member function destructs a server info object.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    //
    // delete all service objects first.
    //

    while( !IsListEmpty( &_ServicesList ) ) {

        LPEMBED_SERVICE_ENTRY ServiceEntry;

        //
        // remove an entry from the tail of the list.
        //

        ServiceEntry =
            (LPEMBED_SERVICE_ENTRY)RemoveTailList( &_ServicesList );

        //
        // delete service object.
        //

        delete ServiceEntry->ServiceObject;

        //
        // free the entry memory.
        //

        SvclocHeap->Free( ServiceEntry );
    }

    //
    // free up server info buffer.
    //

    if( _AllottedBufferSize != 0 ) {

        TcpsvcsDbgAssert( _ServerInfoBuffer != NULL );
        SvclocHeap->Free( _ServerInfoBuffer );
    }


#if DBG

    _ServerInfoLength = 0;
    _ServerInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _VersionNum = NULL;
    _ServerLoad = NULL;
    _ServicesMask = NULL;
    _ServerName = NULL;

    _NumServices = NULL;

#endif // DBG

    DeleteCriticalSection( &_ServerObjCritSect );

    _Status = ERROR_SUCCESS;
    return;
}

DWORD
EMBED_SERVER_INFO::AddService (
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This member function adds or replaces a service info object to the
    server info object.

Arguments:

    ServiceInfo : pointer to the service info structure.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPSERVICE_OBJECT ServiceObj;
    LPEMBED_SERVICE_ENTRY ServiceEntry = NULL;
    ULONGLONG SMask;

    LockServerObj();

    SMask = ServiceInfo->ServiceMask;

    if( IsServiceEntryExist( SMask, &ServiceEntry ) ) {

        //
        // this service already exists, so just update the content.
        //

        TcpsvcsDbgAssert( ServiceEntry != NULL );
        TcpsvcsDbgAssert( (*_ServicesMask & SMask) == SMask );

        //
        // set service info.
        //

        Error = (ServiceEntry->ServiceObject)->SetServiceInfo( ServiceInfo );

        UnlockServerObj();
        return( Error );
    }

    //
    // new entry.
    //

    TcpsvcsDbgAssert( (*_ServicesMask & SMask)  == 0 );

    //
    // make a service object.
    //

    ServiceObj = new EMBED_SERVICE_INFO( ServiceInfo );

    if( ServiceObj == NULL ) {
        UnlockServerObj();
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = ServiceObj->GetStatus();

    if( Error != ERROR_SUCCESS ) {
        delete ServiceObj;
        UnlockServerObj();
        return( Error );
    }

    //
    // allocate memory for the new service entry.
    //

    ServiceEntry = (LPEMBED_SERVICE_ENTRY)
        SvclocHeap->Alloc( sizeof(EMBED_SERVICE_ENTRY) );

    if( ServiceEntry == NULL ) {
        delete ServiceObj;
        UnlockServerObj();
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    ServiceEntry->ServiceObject = ServiceObj;

    //
    // Adjust parameters.
    //

    *_ServicesMask |= SMask;
    (*_NumServices)++;

    //
    // add this entry to the service list.
    //

    InsertTailList(&_ServicesList, &ServiceEntry->NextEntry);

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::RemoveService(
    ULONGLONG SMask
    )
/*++

Routine Description:

    This member function removes a service info object from the server
    info object.

Arguments:

    SMask : Service mask of the service to be removed from the
        server object.

Return Value:

    Windows Error Code.

--*/
{

    LPEMBED_SERVICE_ENTRY ServiceEntry = NULL;

    LockServerObj();

    //
    // check the service is in the service list.
    //

    if( IsServiceEntryExist( SMask, &ServiceEntry )  == FALSE ) {

        TcpsvcsDbgAssert( (*_ServicesMask &  SMask) == 0);
        UnlockServerObj();
        return( ERROR_SERVICE_NOT_FOUND );
    }

    TcpsvcsDbgAssert( ServiceEntry != NULL );
    TcpsvcsDbgAssert( *_ServicesMask & SMask );

    //
    // adjust parameters.
    //

    *_ServicesMask &= ~SMask;
    (*_NumServices)--;

    //
    // remove entry from list.
    //

    RemoveEntryList( &ServiceEntry->NextEntry );

    //
    // delete service object.
    //

    delete ServiceEntry->ServiceObject;

    //
    // free entry memory.
    //

    SvclocHeap->Free( ServiceEntry );

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::SetServiceState(
    ULONGLONG SMask,
    INET_SERVICE_STATE ServiceState
    )
/*++

Routine Description:

    This member function sets the state of a service.

Arguments:

    SMask : Service Mask of the service whose state to be set.

    ServiceState : New state of the service.

Return Value:

    None.

--*/
{
    LPEMBED_SERVICE_ENTRY ServiceEntry = NULL;

    LockServerObj();
    //
    // check the service is in the service list.
    //

    if( IsServiceEntryExist( SMask, &ServiceEntry )  == FALSE ) {

        TcpsvcsDbgAssert( (*_ServicesMask &  SMask) == 0);
        UnlockServerObj();
        return( ERROR_SERVICE_NOT_FOUND );
    }

    TcpsvcsDbgAssert( ServiceEntry != NULL );
    TcpsvcsDbgAssert( *_ServicesMask & SMask );

    //
    // set service state.
    //

    (ServiceEntry->ServiceObject)->SetServiceState( ServiceState );

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::ComputeResponseLength(
    VOID
    )
/*++

Routine Description:

    This member function computes the length of the response message
    (containing server info and all services info in the embedded
    formatted)  sent to a client.

Arguments:

    None.

Return Value:

    Length of the response.

--*/
{
    DWORD Size = 0;
    PLIST_ENTRY SList;
    LPEMBED_SERVICE_ENTRY SEntry;

    LockServerObj();
    //
    // Compute response length of  the services.
    //

    for( SList = _ServicesList.Flink; SList != &_ServicesList; SList = SList->Flink ) {

        SEntry = (LPEMBED_SERVICE_ENTRY)SList;

        //
        // Get Service info buffer size.
        //

        Size +=  (SEntry->ServiceObject)->GetServiceInfoLength();
        Size += sizeof(DWORD); // for service length info itself.
    }

    //
    // server info size.
    //

    Size += _ServerInfoLength;

    UnlockServerObj();
    return( Size );
}

DWORD
EMBED_SERVER_INFO::MakeResponseMessage(
    LPBYTE MessageBuffer,
    DWORD BufferLength
    )
/*++

Routine Description:

    This member function builds a response message sent to a client.

Arguments:

    MessageBuffer : pointer to a buffer where the response message is
        built.

    BufferLength : length of the message.

Return Value:

    Windows Error Code.

--*/
{
    LPBYTE BufferPtr = MessageBuffer;
    LPBYTE EndBufferPtr = MessageBuffer + BufferLength;
    LPEMBED_SERVICE_ENTRY SEntry;
    ULONGLONG SMask;
    DWORD Error;
    DWORD RequiredBufferLength;
    PLIST_ENTRY SList;

    LockServerObj();

    RequiredBufferLength = ComputeResponseLength();

    if( RequiredBufferLength > BufferLength ) {
        UnlockServerObj();
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    //
    // copy server info first.
    //

    memcpy( BufferPtr, _ServerInfoBuffer, _ServerInfoLength );
    BufferPtr += _ServerInfoLength;

    //
    // copy all service info buffers.
    //

    for( SList = _ServicesList.Flink; SList != &_ServicesList; SList = SList->Flink ) {

        DWORD *_ServiceInfoLength;

        TcpsvcsDbgAssert( BufferPtr < EndBufferPtr );

        _ServiceInfoLength = (DWORD *)BufferPtr;
        BufferPtr += sizeof(DWORD);

        SEntry = (LPEMBED_SERVICE_ENTRY)SList;

        //
        // Get Service Mask.
        //

        Error = (SEntry->ServiceObject)->GetServiceInfoBuffer(
                        BufferPtr,
                        (EndBufferPtr - BufferPtr),
                        _ServiceInfoLength );

        if( Error != ERROR_SUCCESS ) {
            UnlockServerObj();
            return( Error );
        }

        BufferPtr += *_ServiceInfoLength;
    }

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::GetServerInfo(
    LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This member function retrieves the server info structure.

Arguments:

    ServerInfo : pointer to a location where the pointer to the server
        info structure is returned. The member function allots memory for
        the structure, the caller should free the mmeory after use.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPINET_SERVER_INFO LocalServerInfo = NULL;
    LPINET_SERVICE_INFO *ServicesInfoArray = NULL;
    PLIST_ENTRY SList;
    DWORD i;

    LockServerObj();

    //
    // allocate memory for the server info structure.
    //

    LocalServerInfo = (LPINET_SERVER_INFO)SvclocHeap->Alloc(sizeof(INET_SERVER_INFO) );

    if( LocalServerInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // initialize all fields.
    //

    memset( LocalServerInfo, 0x0, sizeof(INET_SERVER_INFO) );

    //
    // fill in the fields.
    //

    //
    // server info field is fill by some one else !!
    // leave it empty for now.
    //

    LocalServerInfo->ServerAddress.Length = 0;
    LocalServerInfo->ServerAddress.BindData = NULL;

    LocalServerInfo->VersionNum = *_VersionNum;

    //
    // alloc memory for the server name.
    //

    LocalServerInfo->ServerName = (LPSTR)
        SvclocHeap->Alloc( (strlen(_ServerName) + 1) * sizeof(CHAR) );

    if( LocalServerInfo->ServerName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    strcpy( LocalServerInfo->ServerName, _ServerName );
    LocalServerInfo->LoadFactor = *_ServerLoad;
    LocalServerInfo->ServicesMask = *_ServicesMask;
    LocalServerInfo->Services.NumServices = 0;
    LocalServerInfo->Services.Services = NULL;

    //
    // allocate memory for the service struct. array pointers.
    //

    ServicesInfoArray = (LPINET_SERVICE_INFO *)
        SvclocHeap->Alloc( (*_NumServices) * sizeof(LPINET_SERVICE_INFO ) );

    if(ServicesInfoArray == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memset( ServicesInfoArray, 0x0, (*_NumServices) * sizeof(LPINET_SERVICE_INFO) );

    //
    // now get services info.
    //

    for ( SList = _ServicesList.Flink, i = 0;
            (SList != &_ServicesList) && (i < *_NumServices);
                SList = SList->Flink, i++ ) {

        LPSERVICE_OBJECT SObj;

        SObj = ((LPEMBED_SERVICE_ENTRY)SList)->ServiceObject;

        Error = SObj->GetServiceInfo( &ServicesInfoArray[i] );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    TcpsvcsDbgAssert( i <= (*_NumServices) );

    LocalServerInfo->Services.NumServices = i;
    LocalServerInfo->Services.Services = ServicesInfoArray;
    ServicesInfoArray = NULL;

    *ServerInfo = LocalServerInfo;
    LocalServerInfo = NULL;

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // Cleanup allotted data.
        //

        if( ServicesInfoArray != NULL ) {

            for ( i = 0; i < (*_NumServices) && ServicesInfoArray[i] != NULL; i++) {
                FreeServiceInfo( ServicesInfoArray[i] );
            }

            SvclocHeap->Free( ServicesInfoArray );
        }

        if( LocalServerInfo != NULL ) {

            if( LocalServerInfo->ServerName != NULL ) {

                SvclocHeap->Free( LocalServerInfo->ServerName );
            }

            SvclocHeap->Free( LocalServerInfo );
        }
    }

    UnlockServerObj();
    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\svcsrv.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcsrv.cxx

Abstract:

    Contains server side code of service location protocol.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    Sean Woodward (t-seanwo) 26-October-1997    ADSI Update

--*/

#include <svcloc.hxx>

DWORD
MakeResponseBuffer(
    VOID
    )
/*++

Routine Description:

    This function sets up the response buffer sent to the client.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD ReqMsgLength;

    //
    // compute space required for all services info and server info.
    //

    ReqMsgLength = GlobalSrvInfoObj->ComputeResponseLength();

    //
    // add space for the head and tail.
    //

    ReqMsgLength += (
        sizeof(DWORD) + // for message length.
        sizeof(DWORD) + // for check sum
        sizeof(DWORD)); // for termination dword.

    if( ReqMsgLength <= GlobalSrvAllotedRespMsgLen ) {

        //
        // wipe of previous response buffer content.
        //

        TcpsvcsDbgAssert(
            GlobalSrvRespMsgLength <=
                GlobalSrvAllotedRespMsgLen );

        memset( GlobalSrvRespMsg, 0x0, GlobalSrvRespMsgLength );
        GlobalSrvRespMsgLength = ReqMsgLength;
    }
    else {

        LPBYTE NewBuffer;
        DWORD NewBufferLength;

        NewBufferLength = (ReqMsgLength & ~(0x400 - 1)) + 0x400;
            // ceil in KBytes

        NewBuffer = (LPBYTE)SvclocHeap->Alloc( NewBufferLength );

        if( NewBuffer == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // free old buffer.
        //

        SvclocHeap->Free( GlobalSrvRespMsg );
        GlobalSrvRespMsg = NewBuffer;
        GlobalSrvAllotedRespMsgLen = NewBufferLength;
        GlobalSrvRespMsgLength =  ReqMsgLength;
    }

    //
    // copy server and services info.
    //

    DWORD Error;

    Error = GlobalSrvInfoObj->MakeResponseMessage(
                    GlobalSrvRespMsg + sizeof(DWORD),
                    GlobalSrvRespMsgLength - 3 * sizeof(DWORD) );

    if( Error != ERROR_SUCCESS ) {
        GlobalSrvRespMsgLength = 0;
        return( Error );
    }

    *(DWORD *)GlobalSrvRespMsg = GlobalSrvRespMsgLength;

    LPBYTE EndMessageBuffer;

    EndMessageBuffer = GlobalSrvRespMsg + GlobalSrvRespMsgLength;

    //
    // fill in check sum.
    //

    *(DWORD *)(EndMessageBuffer - 2 * sizeof(DWORD) ) =
        ComputeCheckSum(
            GlobalSrvRespMsg + sizeof(DWORD),
            GlobalSrvRespMsgLength - 3 * sizeof(DWORD) );

    *(DWORD *)(EndMessageBuffer - sizeof(DWORD) ) = 0xFFFFFFFF;

    //
    // DONE.
    //

    return( ERROR_SUCCESS );
}

DWORD
ServerRegisterAndListen(
    VOID
    )
/*++

Routine Description:

    This function call registers the server and creates a thread to listen
    to the discovery requests. Also it initializes the winsock data structures.

    ASSUME : global data crit sect is locked.

Arguments:

    none.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    SOCKET IpxSocket;
    int SocketAddressLength;

    SOCKADDR_IPX IpxSocketAddress;
    SERVICE_INFOA ServiceInfo;
    SERVICE_ADDRESSES ServiceAddresses;
    PSERVICE_ADDRESS ServiceAddr;
    DWORD StatusSetService;

    CHAR SapSvcName[SAP_SERVICE_NAME_LEN + 1];

    //
    // init winsock.
    //

    if ( !GlobalWinsockStarted ) {

        Error = WSAStartup( WS_VERSION_REQUIRED, &GlobalWinsockStartupData );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalWinsockStarted = TRUE;
    }

    //
    // cleanup global socket array.
    //

    memset( &GlobalSrvSockets, 0x0, sizeof(GlobalSrvSockets) );

    //
    // make IPX local socket address.
    //

    IpxSocket = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);

    if( IpxSocket == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto NBRegister;
    }

    //
    // make this socket non blocking.
    //

    DWORD Arg;
    Arg = 1;
    if( (ioctlsocket( IpxSocket, FIONBIO, &Arg )) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    //
    // get socket address.
    //

    memset( &IpxSocketAddress, 0x0, sizeof(SOCKADDR_IPX) );

    IpxSocketAddress.sa_family = PF_IPX;

    if( bind(
            IpxSocket,
            (PSOCKADDR)&IpxSocketAddress,
            sizeof(SOCKADDR_IPX) ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    //
    // now query address.
    //

    SocketAddressLength = sizeof( IpxSocketAddress );

    if( getsockname(
            IpxSocket,
            (PSOCKADDR)&IpxSocketAddress,
            &SocketAddressLength ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    Error = MakeSapServiceName( SapSvcName, sizeof(SapSvcName) );

    if( Error != ERROR_SUCCESS ) {
        closesocket( IpxSocket );
        goto NBRegister;
    }

    //
    // prepare service address.
    //

    ServiceAddresses.dwAddressCount = 1;
    ServiceAddr = &ServiceAddresses.Addresses[0];

    ServiceAddr->dwAddressType = PF_IPX;
    ServiceAddr->dwAddressFlags = 0;
    ServiceAddr->dwAddressLength = SocketAddressLength;
    ServiceAddr->dwPrincipalLength = 0;
    ServiceAddr->lpAddress = (LPBYTE)&IpxSocketAddress;
    ServiceAddr->lpPrincipal = NULL;

    //
    // prepare service info.
    //

    ServiceInfo.lpServiceType = &GlobalSapGuid;
    ServiceInfo.lpServiceName = SapSvcName;
    ServiceInfo.lpComment = NULL ;
    ServiceInfo.lpLocale = 0;
    ServiceInfo.dwDisplayHint = 0;
    ServiceInfo.dwVersion =
        MAKEWORD( INET_MAJOR_VERSION, INET_MINOR_VERSION ) ;
    ServiceInfo.dwTime = 0; // ??
    ServiceInfo.lpMachineName = GlobalComputerName;
    ServiceInfo.lpServiceAddress = &ServiceAddresses;
    ServiceInfo.ServiceSpecificInfo.pBlobData = 0;
    ServiceInfo.ServiceSpecificInfo.cbSize = 0;

    //
    // register service info.
    //

    if( SetServiceA(
            NS_SAP,
            SERVICE_REGISTER,
            0,
            &ServiceInfo,
            0,
            &StatusSetService ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    if( StatusSetService != ERROR_SUCCESS ) {
        Error = StatusSetService;
        closesocket( IpxSocket );
        goto NBRegister;
    }

    GlobalRNRRegistered = TRUE;

    //
    // remember this Ipx socket in our global socket array.
    //

    FD_SET( IpxSocket, &GlobalSrvSockets );
    Error = ERROR_SUCCESS;

NBRegister:

    if( Error != ERROR_SUCCESS ) {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Ipx Registration failed, %ld.\n", Error ));
    }

    //
    // now create sockets for NET BIOS 1C group name and UNIQUE server
    // name.
    //

    SOCKADDR_NB NB1CSocketAddress;
    SOCKADDR_NB NBUniqueSocketAddress;
    SOCKET NBSocket;

    memset( &NB1CSocketAddress, 0x0, sizeof(SOCKADDR_NB) );
    NB1CSocketAddress.snb_family = AF_NETBIOS;
    NB1CSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_GROUP;

    TcpsvcsDbgAssert(
        sizeof(NB1CSocketAddress.snb_name) >=
            NETBIOS_INET_GROUP_NAME_LEN );

    memcpy(
        NB1CSocketAddress.snb_name,
        NETBIOS_INET_GROUP_NAME,
        NETBIOS_INET_GROUP_NAME_LEN );

    memset( &NBUniqueSocketAddress, 0x0, sizeof(SOCKADDR_NB) );
    NBUniqueSocketAddress.snb_family = AF_NETBIOS;
    NBUniqueSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    TcpsvcsDbgAssert( GlobalComputerName[0] != '\0' );

    MakeUniqueServerName(
        (LPBYTE)NBUniqueSocketAddress.snb_name,
        sizeof(NBUniqueSocketAddress.snb_name),
        GlobalComputerName );

    //
    // enumurate lanas first.
    //

    LANA_ENUM Lanas;

    if( GetEnumNBLana( &Lanas ) ) {

        //
        // try only the lanas that are returned.
        //

        TcpsvcsDbgAssert( Lanas.length > 0 );

        DWORD i;
        for( i = 0; i < Lanas.length; i++ ) {

            //
            // create a socket for this lana to bind with the IC name.
            //

            if ( MakeNBSocketForLana(
                    Lanas.lana[i],
                    (PSOCKADDR)&NB1CSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }

            //
            // now create a socket for this lana to bind with the unique
            // server name.
            //

            if ( MakeNBSocketForLana(
                    Lanas.lana[i],
                    (PSOCKADDR)&NBUniqueSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }
        }
    }
    else {

        UCHAR Lana;

        //
        // try all possible lanas and accept all valid lana sockets.
        //

        for( Lana = 0; Lana < MAX_LANA ; Lana-- ) {

            //
            // create a socket for this lana to bind with the IC name.
            //

            if ( MakeNBSocketForLana(
                    Lana,
                    (PSOCKADDR)&NB1CSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }

            //
            // now create a socket for this lana to bind with the unique
            // server name.
            //

            if ( MakeNBSocketForLana(
                    Lana,
                    (PSOCKADDR)&NBUniqueSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }
        }
    }

    //
    // we should have at least one socket to listen on, otherwise,
    // it is an error, return so.
    //

    if( GlobalSrvSockets.fd_count == 0 ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Failed to get any Lanas, Service locator disabled\n" ));
        Error = ERROR_NO_NETWORK;
        goto Cleanup;
    }

    //
    // create listen thread.
    //

    DWORD ThreadId;

    GlobalSrvListenThreadHandle =
        CreateThread(
            NULL,       // default security
            0,          // default stack size
            (LPTHREAD_START_ROUTINE)SocketListenThread,
            NULL,          // no parameter
            0,          // creatation flag, no suspend
            &ThreadId );

    if( GlobalSrvListenThreadHandle  == NULL ) {
        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "ServerRegisterAndListen failed, %ld.\n", Error ));

        //
        // if we are not successful, cleanup
        // before we return.
        //

        DWORD LocalError;

        //
        //  The routine is expecting the global lock to be taken
        //

        LOCK_SVC_GLOBAL_DATA();

        LocalError = ServerDeregisterAndStopListen();

        UNLOCK_SVC_GLOBAL_DATA();

        TcpsvcsDbgAssert( LocalError == ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
ProcessSvclocQuery(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    struct sockaddr *SourcesAddress,
    DWORD SourcesAddressLength
    )
/*++

Routine Description:

    This function processes the query message and sends response to the
    query.

    The query message format.

    1st DWORD : message length.
    2nd DWORD : message version.
    3rd DWORD : services mask the client interested in.
    4th DWORD : client name
    ..
    ..

    Last but one DWORD : check sum.
    LAST DWORD : terminating DWORD 0xFFFFFFFF

Arguments:

    ReceivedMessage - pointer to a message buffer.

    ReceivedMessageLength - length of the above message.

    SourcesAddress - address of the sender.

    SourcesAddressLength - length of the above address.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPBYTE MessagePtr;
    LPBYTE MessageEndPtr;

    MessagePtr = ReceivedMessage;
    MessageEndPtr = ReceivedMessage + ReceivedMessageLength;

    //
    // message length should be multiple of sizeof(DWORD).
    //

    if( ReceivedMessageLength % sizeof(DWORD) != 0 ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // message length should match.
    //

    DWORD MsgLength;

    MsgLength = *(DWORD *)MessagePtr;
    MessagePtr += sizeof(DWORD);

    if( MsgLength != ReceivedMessageLength ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // message should terminate with 0xFFFFFFFF
    //

    if( *(DWORD *)(MessageEndPtr - sizeof(DWORD)) != 0xFFFFFFFF ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // verify checksum.
    //

    DWORD CheckSum;

    CheckSum = ComputeCheckSum(
            ReceivedMessage + sizeof(DWORD),
            ReceivedMessageLength - (3 * sizeof(DWORD)) );

    if( CheckSum != *(DWORD *)(MessageEndPtr - 2 * sizeof(DWORD)) ) {
        return( ERROR_INVALID_PARAMETER );
    }

#if 0

    // IIS5.0: We want to respond to all server discovery messages
    // since it is potentially useful to clients to find all versions
    // of IIS.  The server will send back a message specifying it's
    // own version number and it is up to the client to determine
    // if they want this server's information.

    //
    // validate version number.
    //

    INET_VERSION_NUM VersionNumber;

    VersionNumber.VersionNumber = *(DWORD *)MessagePtr;
    MessagePtr += sizeof(DWORD);

    if( (VersionNumber.Version.Major != INET_MAJOR_VERSION) ||
        (VersionNumber.Version.Minor != INET_MINOR_VERSION) ) {

        //
        // in future, we can apply different logic to reject messages with
        // differnet version number.
        //

        return( ERROR_INVALID_PARAMETER );
    }
    
#endif

    //
    // get services mask.
    //

    ULONGLONG ServicesMask;

    ServicesMask = *(ULONGLONG *)MessagePtr;
    MessagePtr += sizeof(ULONGLONG);

    //
    // if we aren't supporting any of the clients requested services,
    // ignore these message.
    //

    if( (ServicesMask & GlobalSrvInfoObj->GetServicesMask()) == 0) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // retrieve the computer name from the message. currently
    // it has been used just for debugging purpose. It can be used for
    // something else in future.
    //

    LPSTR ClientComputerName;
    LPSTR ComputerNamePtr;

    ClientComputerName = (LPSTR)MessagePtr;

    //
    // validate computer name.
    //

    ComputerNamePtr = ClientComputerName;
    while( (*ComputerNamePtr != '\0') &&
                ((LPBYTE)ComputerNamePtr < MessageEndPtr) ) {
        ComputerNamePtr++;
    }

    if( (LPBYTE)ComputerNamePtr >= MessageEndPtr ) {
        return( ERROR_INVALID_PARAMETER );
    }

    TcpsvcsDbgPrint((
        DEBUG_SVCLOC_MESSAGE,
            "Received a valid discovery message from, %ws.\n",
                ClientComputerName ));

    //
    // send response message to client.
    //

    LOCK_SVC_GLOBAL_DATA();

    TcpsvcsDbgAssert( GlobalSrvRespMsgLength != 0 );

    if( GlobalSrvRespMsgLength != 0 ) {
        Error = sendto(
                    ReceivedSocket,
                    (LPCSTR)GlobalSrvRespMsg,
                    GlobalSrvRespMsgLength,
                    0,
                    SourcesAddress,
                    SourcesAddressLength );


        if( Error == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "sendto failed, %ld.\n", Error ));
        }
        else {
            Error = ERROR_SUCCESS;
        }
    }
    else {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "GlobalSrvRespMsgLength is zero.\n" ));
        Error = ERROR_INVALID_PARAMETER;
    }

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

VOID
SocketListenThread(
    LPVOID Parameter
    )
/*++

Routine Description:

    This function is the main thread for the service location protocol. It
    receives messages that arrive from all sockets (that have
    been established by the ServerRegisterAndListen call) and response to
    each of the messages. This thread will stop when all sockets are
    closed by the ServerDeregisterAndStopListen call.

Arguments:

    none.

Return Value:

    none.

--*/
{

    fd_set ReadSockets;
    int NumReadySockets;
    DWORD Error;
    BOOL BoolError;

    //
    // increase the priority of this thread, so that it could handle as
    // many discovery queries as possible.
    //

    BoolError = SetThreadPriority(
                    GetCurrentThread(),
                    THREAD_PRIORITY_ABOVE_NORMAL );

    if(BoolError) {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "SetThreadPriority, %ld.\n", GetLastError() ));
    }

    for( ;; ) {

        //
        // COMMENT
        // select on all above sockets.
        //

        //
        // copy all sockets.
        //

        LOCK_SVC_GLOBAL_DATA();
        memcpy(&ReadSockets, &GlobalSrvSockets, sizeof(GlobalSrvSockets));
        UNLOCK_SVC_GLOBAL_DATA();

        //
        // do select now.
        //

        NumReadySockets =
            select(
                0,  // compatibility argument, ignored.
                &ReadSockets, // sockets to test for readability.
                NULL,   // no write wait
                NULL,   // no error check.
                NULL ); // NO timeout.

        if( NumReadySockets == SOCKET_ERROR ) {

            //
            // ALL sockets are closed and we are asked to return or
            // something else has happpened which we can't handle.
            //

            Error = WSAGetLastError();
            goto Cleanup;
        }

        TcpsvcsDbgAssert( (DWORD)NumReadySockets == ReadSockets.fd_count );

        DWORD i;
        for( i = 0; i < (DWORD)NumReadySockets; i++ ) {

            DWORD ReadMessageLength;
            struct sockaddr_nb SourcesAddress;
            int SourcesAddressLength;

            //
            // read next message.
            //

            SourcesAddressLength = sizeof(SourcesAddress);
            ReadMessageLength =
                recvfrom(
                    ReadSockets.fd_array[i],
                    (LPSTR)GlobalSrvRecvBuf,
                    GlobalSrvRecvBufLength,
                    0,
                    (struct sockaddr *)&SourcesAddress,
                    &SourcesAddressLength );

            if( ReadMessageLength == SOCKET_ERROR ) {

                //
                // ALL sockets are closed and we are asked to return or
                // something else has happpened which we can't handle.
                //

                Error = WSAGetLastError();
                continue;
            }

            TcpsvcsDbgAssert( ReadMessageLength <= GlobalSrvRecvBufLength );

            //
            // received a message.
            //

            TcpsvcsDbgPrint((
                DEBUG_SVCLOC_MESSAGE,
                    "Received a discovery message, %ld.\n",
                        ReadMessageLength ));

            Error = ProcessSvclocQuery(
                            ReadSockets.fd_array[i],
                            GlobalSrvRecvBuf,
                            (DWORD)ReadMessageLength,
                            (struct sockaddr *)&SourcesAddress,
                            (DWORD)SourcesAddressLength );

            if( Error != ERROR_SUCCESS ) {
                TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "SendSvclocResponse failed, %ld.\n", Error ));
            }
        }
    }

Cleanup:

    TcpsvcsDbgPrint(( DEBUG_ERRORS,  "SocketListenThread returning, %ld.\n", Error ));
    return;
}

DWORD
ServerDeregisterAndStopListen(
    VOID
    )
/*++

Routine Description:

    This function call stops the discovery thread and deregisters the
    server name. Also it cleans up the winsock data structures.

    ASSUME : global data crit sect is locked.

Arguments:

    none.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    //
    // close all sockets, if any opened.
    //

    for( i = 0; i < GlobalSrvSockets.fd_count; i++ ) {

        Error = closesocket( GlobalSrvSockets.fd_array[i] );

        if( Error == SOCKET_ERROR ) {
            Error = WSAGetLastError();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "closesocket call failed, %ld\n", Error ));
        }
    }

    //
    // invalidate GlobalSrvSockets count
    //

    GlobalSrvSockets.fd_count = 0;

    //
    // closing all above sockets should stop the service location thread,
    // check to see this is the case and close the thread handle.
    //

    if( GlobalSrvListenThreadHandle != NULL ) {

        //
        //  The thread may take this critical section, release it around
        //  the wait to prevent a deadlock
        //

        UNLOCK_SVC_GLOBAL_DATA();

        //
        // Wait for the service location thread to stop, but don't wait
        // for longer than THREAD_TERMINATION_TIMEOUT msecs (60 secs)
        //

        DWORD WaitStatus =
            WaitForSingleObject(
                    GlobalSrvListenThreadHandle,
                    30000
                    );

        TcpsvcsDbgAssert( WaitStatus != WAIT_FAILED );

        if(  WaitStatus == WAIT_FAILED ) {
            TcpsvcsDbgPrint((DEBUG_ERRORS,
                "WaitForSingleObject call failed, %ld\n", GetLastError() ));
        }

        CloseHandle( GlobalSrvListenThreadHandle );
        GlobalSrvListenThreadHandle = NULL;

        LOCK_SVC_GLOBAL_DATA();


    }

    //
    // deregister rnr.
    //

    if( GlobalRNRRegistered ) {

        SOCKADDR_IPX IpxSocketAddress;
        SERVICE_INFO ServiceInfo;
        SERVICE_ADDRESSES ServiceAddresses;
        PSERVICE_ADDRESS ServiceAddr;
        DWORD StatusSetService;
        CHAR SapSvcName[SAP_SERVICE_NAME_LEN + 1];
        CHAR *SapSvcNamePtr;

        Error = MakeSapServiceName( SapSvcName, sizeof(SapSvcName) );

        if( Error != ERROR_SUCCESS ) {
            SapSvcNamePtr = NULL;
        }
        else {
            SapSvcNamePtr = SapSvcName;
        }

        //
        // prepare service address.
        //

        ServiceAddresses.dwAddressCount = 1;
        ServiceAddr = &ServiceAddresses.Addresses[0];

        memset( &IpxSocketAddress, 0x0, sizeof(IpxSocketAddress) );

        ServiceAddr->dwAddressType = PF_IPX;
        ServiceAddr->dwAddressFlags = 0;
        ServiceAddr->dwAddressLength = sizeof( IpxSocketAddress );
        ServiceAddr->dwPrincipalLength = 0;
        ServiceAddr->lpAddress = (LPBYTE)&IpxSocketAddress;
        ServiceAddr->lpPrincipal = NULL;

        //
        // prepare service info.
        //

        ServiceInfo.lpServiceType = &GlobalSapGuid;
        ServiceInfo.lpServiceName = SapSvcNamePtr;
        ServiceInfo.lpComment = NULL ;
        ServiceInfo.lpLocale = 0;
        ServiceInfo.dwDisplayHint = 0;
        ServiceInfo.dwVersion =
            MAKEWORD( INET_MAJOR_VERSION, INET_MINOR_VERSION ) ;
        ServiceInfo.dwTime = 0; // ??
        ServiceInfo.lpMachineName = GlobalComputerName;
        ServiceInfo.lpServiceAddress = &ServiceAddresses;
        ServiceInfo.ServiceSpecificInfo.pBlobData = 0;
        ServiceInfo.ServiceSpecificInfo.cbSize = 0;

        //
        // register service info.
        //

        if( SetServiceA(
                NS_SAP,
                SERVICE_DEREGISTER,
                0,
                &ServiceInfo,
                0,
                &StatusSetService ) == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "SetServiceW call failed, %ld\n", Error ));
        }

        GlobalRNRRegistered = FALSE;
    }

    //
    // DONE.
    //

     return( ERROR_SUCCESS );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains the class implementation of UTILITY classes.

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

    MuraliK 20-March-1996 modularize within svcloc

--*/


#include <svcloc.hxx>


MEMORY * CacheHeap = NULL;


PVOID
MEMORY::Alloc(
    DWORD Size
    )
/*++

Routine Description:

    This member function allocates memory from the local heap. In debug
    build this function also keeps track of the memory allocations and
    fills up the memory with a known pattern that helps to debug memory
    corruptions.

Arguments:

    Size : size of the memory block in bytes requested.

Return Value:

    Pointer to the alloted memory block. If there is no memory
    available, this pointer will be set to NULL.

--*/
{
    PVOID MemoryPtr;

    MemoryPtr = LocalAlloc(
                    LMEM_FIXED | LMEM_ZEROINIT,
                    Size );

#if DBG

    TcpsvcsDbgAssert( MemoryPtr != NULL );

    _Count++;
    _TotalSize += Size;
    memset( MemoryPtr, 0xAA, Size );

    TcpsvcsDbgPrint(( DEBUG_MEM_ALLOC,
        "MEMORY::Alloc, _Count = %ld, _TotalSize = %ld.\n",
            _Count, _TotalSize ));

#endif // DBG

    return( MemoryPtr );
}

PVOID
MEMORY::ReAlloc(
    PVOID OldMemory,
    DWORD NewSize
    )
/*++

Routine Description:

    This member function reallocates memory from the local heap. In
    debug build this function also keeps track of the memory allocations and
    fills up the memory with a known pattern that helps to debug memory
    corruptions.

Arguments:

    OldMemory - pointer to the old memory block.

    NewSize : size of the new memory block in bytes requested.

Return Value:

    Pointer to the alloted memory block. If there is no memory
    available, this pointer will be set to NULL.

--*/
{
    PVOID NewMemory;
    DWORD OldSize;

    //
    // if there is no previous memory, then alloc a new one.
    //

    if( OldMemory == NULL ) {
        return( Alloc( NewSize ) );
    }

    //
    // get old memory size.
    //

    OldSize = LocalSize( OldMemory );

    TcpsvcsDbgAssert( OldSize != NewSize );

    //
    // if new size is same as old size, simply return.
    //

    if( OldSize == NewSize ){
        return( OldMemory );
    }

    //
    // if the newsize is zero, free old memory and return zero.
    //

    if( NewSize == 0 ) {
        Free( OldMemory );
        return( NULL );
    }

    //
    // realloc.
    //

    NewMemory = LocalReAlloc(
                    OldMemory,
                    NewSize,
                    LMEM_FIXED | LMEM_ZEROINIT | LMEM_MOVEABLE );
                        // block move is OK.

#if DBG

    TcpsvcsDbgAssert( NewMemory != NULL );

    //
    // update total memory consumed size and fillin the extra memory
    // with pattern.
    //

    if( NewSize > OldSize ) {
        DWORD ModSize =  (NewSize - OldSize);
        _TotalSize += ModSize;
        memset( (LPBYTE)NewMemory + OldSize, 0xAA, ModSize );
    }
    else {
        _TotalSize -= (OldSize - NewSize);
    }

    TcpsvcsDbgPrint(( DEBUG_MEM_ALLOC,
        "MEMORY::Alloc, _Count = %ld, _TotalSize = %ld.\n",
            _Count, _TotalSize ));

#endif // DBG

    return( NewMemory );
}

VOID
MEMORY::Free(
    PVOID MemoryPtr
    )
/*++

Routine Description:

    This member function frees the memory block that was allocated by
    the meber function this->Alloc(). In debug build this function also
    keeps track of the memory allocations.

Arguments:

    MemoryPtr : Pointer to a memory block that is freed.

Return Value:

    None.

--*/
{
    PVOID ReturnHandle;
    DWORD Size;


    if( MemoryPtr == NULL ) {
#if DBG
        TcpsvcsDbgPrint(( DEBUG_MISC,
            "MEMORY::Free called with NULL.\n" ));
#endif // DBG
        return;
    }

#if DBG
    Size = LocalSize( MemoryPtr );
#endif // DBG

    ReturnHandle = LocalFree( MemoryPtr );

#if DBG

    TcpsvcsDbgAssert( ReturnHandle == NULL );

    _Count--;
    _TotalSize -= Size;

    TcpsvcsDbgPrint(( DEBUG_MEM_ALLOC,
        "MEMORY::Free, _Count = %ld, _TotalSize = %ld.\n",
            _Count, _TotalSize ));

#endif // DBG

    return;
}

#if 0

void *
operator new(
    size_t Size
    )
/*++

Routine Description:

    Private implemetation of the new operator.

Arguments:

    Size : size of the memory requested.

Return Value:

    Pointer to the alloted memory block.

--*/
{
    if( CacheHeap == NULL ) {

        PVOID MemoryPtr;

        MemoryPtr = LocalAlloc(
                        LMEM_FIXED | LMEM_ZEROINIT,
                        Size );

        return( MemoryPtr );
    }
    else {
        return( CacheHeap->Alloc( DWORD(Size) ) );
    }
}

void
operator delete(
    void *MemoryPtr
    )
/*++

Routine Description:

    Private implemetation of the free operator.

Arguments:

    MemoryPtr : Pointer to a memory block that is freed

Return Value:

    None.

--*/
{
    if( CacheHeap == NULL ) {
        LocalFree( MemoryPtr );
    }
    else {
        CacheHeap->Free( MemoryPtr );
    }

    return;
}

#endif // 0

PVOID
MIDL_user_allocate(
    size_t Size
    )
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    Size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    if( CacheHeap == NULL ) {

        return LocalAlloc( LMEM_FIXED,
                           Size );
    }
    else {
        return( CacheHeap->Alloc( DWORD(Size) ) );
    }
}

VOID
MIDL_user_free(
    PVOID MemoryPtr
    )
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    MmeoryPtr : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    if( CacheHeap == NULL ) {
        LocalFree( MemoryPtr );
    }
    else {
        CacheHeap->Free( MemoryPtr );
    }
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\test\svcdisc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    discover.c

Abstract:

    Contains code that implements the service location apis.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    MuraliK    11-July-1995  Extended to discover any service besides Gateway

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <svcloc.h>

// consists of information map from service name to other details
typedef struct _SERVICE_INFO {
    LPCSTR     pszName;
    ULONGLONG  ulMask;
} SERVICE_INFO;

SERVICE_INFO  g_Services[] = {
    { "gopher",   INET_GOPHER_SERVICE},
    { "http",     INET_W3_SERVICE},
    { "w3",       INET_W3_SERVICE},
    { "ftp",      INET_FTP_SERVICE},
    { "gate",     INET_GATEWAY_SERVICE},
    { "msn",      INET_MSN_SERVICE}
};

# define NUM_SERVICES    ( sizeof(g_Services)/ sizeof( SERVICE_INFO))


ULONGLONG GetUlMaskForService( IN LPSTR pszServiceName)
{
    DWORD i;

    for ( i = 0; i < NUM_SERVICES; i++) {

        if ( !stricmp( pszServiceName, g_Services[i].pszName)) {

            return ( g_Services[i].ulMask);
        }
    }

    return ( 0);
} // GetUlMaskForService()

VOID
PrintServerInfo(
    DWORD Index,
    LPINET_SERVER_INFO ServerInfo
    )
{
    DWORD j, k;

    printf("%ld. ServerName = %s \n ", Index+1, ServerInfo->ServerName );
    printf("  ServicesMask = %lx \n", (DWORD)ServerInfo->ServicesMask );
    printf("   NumServices = %ld \n", ServerInfo->Services.NumServices );

    for( j = 0; j < ServerInfo->Services.NumServices; j++ ) {

        LPINET_SERVICE_INFO ServiceInfo;

        ServiceInfo = ServerInfo->Services.Services[j];

        printf("\n");
        printf(" %ld. ServiceMask = %ld \n",
            j+1, (DWORD)ServiceInfo->ServiceMask );

        printf("    ServiceState = %ld \n",
           (DWORD)ServiceInfo->ServiceState );

        printf("    ServiceComment = %s \n",
           (DWORD)ServiceInfo->ServiceComment );

        printf("    NumBindings  = %ld \n",
            ServiceInfo->Bindings.NumBindings );

        for( k = 0; k < ServiceInfo->Bindings.NumBindings; k++) {

            LPINET_BIND_INFO BindInfo;

            BindInfo = &ServiceInfo->Bindings.BindingsInfo[k];

            printf("     %ld. Bind (%ld) = %s\n",
                   k+1,
                   BindInfo->Length,
                   (LPWSTR)BindInfo->BindData );
        }

    }
    printf("\n");

    return;
}

VOID
PrintServersInfoList( IN LPINET_SERVERS_LIST  pServersList)
{
    DWORD i;

    for( i = 0; i < pServersList->NumServers; i++ ) {

        PrintServerInfo( i, pServersList->Servers[i] );
    }

    return;
}  // PrintServersInfoList()


VOID
PrintUsageMessage(IN LPCSTR pszProgName)
{
    int i;

    printf( "Usage: %s [ -tTimeToWait] [ -sServerName] { service-names }\n",
        pszProgName);

    printf("\t Services supported are:\n");
    for (i = 0; i < NUM_SERVICES; i++) {

        printf( "\t\t %s\n", g_Services[i].pszName);
    }

} // PrintUsageMessage()

DWORD
DiscoverServerInfo(
    LPSTR ServerName,
    ULONGLONG  ulMask,
    DWORD dwWaitTime
    )
{
    DWORD Error;
    LPINET_SERVER_INFO ServerInfo = NULL;

    if( dwWaitTime == 0 ) {

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        SVC_DEFAULT_WAIT_TIME,
                        &ServerInfo );
    } else {

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        0,
                        &ServerInfo );

        if( (Error != ERROR_BAD_NETPATH ) && (Error != ERROR_SUCCESS) ) {
            return( Error );
        }

        //
        // display server info if it is found.
        //

        if( ServerInfo != NULL ) {

            //
            // display server info.
            //

            PrintServerInfo( 0, ServerInfo );
            INetFreeServerInfo( &ServerInfo );
            return( ERROR_SUCCESS );
        }

        //
        // wait for server response.
        //

        Sleep( dwWaitTime * 1000 );

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        0,
                        &ServerInfo );
    }

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( ServerInfo != NULL ) {
        PrintServerInfo( 0, ServerInfo );
    }
    else {
        printf( "INetGetServerInfo found no relevant servers\n");
    }

    //
    // free server info structure.
    //

    INetFreeServerInfo( &ServerInfo );
    return( ERROR_SUCCESS );
}

DWORD
DiscoverInetServers(
    ULONGLONG  ulMask,
    DWORD dwWaitTime
    )
{
    DWORD Error;
    LPINET_SERVERS_LIST ServersList = NULL;

    if( dwWaitTime == 0 ) {

        Error = INetDiscoverServers(
                        ulMask,
                        SVC_DEFAULT_WAIT_TIME,
                        &ServersList );
    } else {

        Error = INetDiscoverServers(
                        ulMask,
                        0,
                        &ServersList );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        //
        // ignore first enum, must have zero entry.
        //

        INetFreeDiscoverServersList( &ServersList );

        Sleep( dwWaitTime * 1000 );

        Error = INetDiscoverServers(
                        ulMask,
                        0,
                        &ServersList );
    }

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // list server info.
    //

    if ( ServersList->NumServers != 0) {

        PrintServersInfoList( ServersList );
    } else {

        printf( "INetDiscoverServers() found no relevant servers\n");
    }

    //
    // free server info structure.
    //

    INetFreeDiscoverServersList( &ServersList );
    return( ERROR_SUCCESS );
}

VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD Error;
    ULONGLONG  ulMask = 0;
    int iArgs = 1;
    DWORD dwWaitTime = 0;
    LPSTR ServerName = NULL;

    while ( argv[iArgs] != NULL ){

        if( argv[iArgs][0] == '-' ) {

            switch ( argv[iArgs][1] ) {
            case 't':
                // get the wait time
                dwWaitTime = strtoul( argv[iArgs] + 2, NULL, 0);
                break;

            case 's':
                // get the server name.
                ServerName = argv[iArgs] + 2;
                break;

            default:
                PrintUsageMessage(argv[0]);
                exit(1);
            }
        }

        iArgs++; // skip one more argument
    }

    //
    // form the mask for all services
    //

    for ( iArgs = 1; iArgs < argc; iArgs++) {

        ulMask = ulMask | GetUlMaskForService( argv[iArgs]);
    } // for

    if ( ulMask == 0) {

        PrintUsageMessage(argv[0]);
        exit(1);
    }

    if( ServerName != NULL ) {
        Error = DiscoverServerInfo(  ServerName, ulMask, dwWaitTime );
    }
    else {
        Error = DiscoverInetServers(  ulMask, dwWaitTime );
    }

    if( Error != ERROR_SUCCESS ) {
        printf("%s failed with error, %ld.\n", argv[0], Error );
        return;
    }

    printf( "Command completed successfully.\n" );
    return;

} // main()

/*************************** End Of File **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\afsvcloc\aftest\svcdisc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    discover.c

Abstract:

    Contains code that implements the service location apis.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    MuraliK    11-July-1995  Extended to discover any service besides Gateway

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <svcloc.h>
#include <string.h>

// consists of information map from service name to other details
typedef struct _SERVICE_INFO {
    LPCSTR     pszName;
    ULONGLONG  ulMask;
} SERVICE_INFO;

SERVICE_INFO  g_Services[] = {
#if 0
    { "gopher",   INET_GOPHER_SERVICE},
    { "http",     INET_W3_SERVICE},
    { "w3",       INET_W3_SERVICE},
    { "ftp",      INET_FTP_SERVICE},
    { "gate",     INET_GATEWAY_SERVICE},
    { "msn",      INET_MSN_SERVICE}
#else
   // using new service masks
    { "ftp",      INET_FTP_SVCLOC_ID},
    { "gopher",   INET_GOPHER_SVCLOC_ID},
    { "w3",       INET_W3_SVCLOC_ID},

#if 0
   // what to do with these?
    { INET_MW3_SVCLOC_ID},
    { INET_MFTP_SVCLOC_ID},
#endif

#endif
};

 

#define NUM_SERVICES    ( sizeof(g_Services)/ sizeof( SERVICE_INFO))


ULONGLONG GetUlMaskForService( IN LPSTR pszServiceName)
{
    DWORD i;

    for ( i = 0; i < NUM_SERVICES; i++) {

        if ( !_stricmp( pszServiceName, g_Services[i].pszName)) {

            return ( g_Services[i].ulMask);
        }
    }

    return ( 0);
} // GetUlMaskForService()

VOID
PrintServerInfo(
    DWORD Index,
    LPINET_SERVER_INFO ServerInfo
    )
{
    DWORD j, k;
    INET_VERSION_NUM VersionNumber;
    WORD MajorVersion;
    WORD MinorVersion;

    printf("%ld. ServerName = %s \n ", Index+1, ServerInfo->ServerName );
    printf("  ServicesMask = %lx \n", (DWORD)ServerInfo->ServicesMask );
    printf("   NumServices = %ld \n", ServerInfo->Services.NumServices );

    VersionNumber = ServerInfo->VersionNum;
    MajorVersion = VersionNumber.Version.Major;
    MinorVersion = VersionNumber.Version.Minor;

    printf("    Version  = %ld.%ld \n", MajorVersion, MinorVersion);

    for( j = 0; j < ServerInfo->Services.NumServices; j++ ) {

        LPINET_SERVICE_INFO ServiceInfo;

        ServiceInfo = ServerInfo->Services.Services[j];

        printf("\n");
        printf(" %ld. ServiceMask = %ld \n",
            j+1, (DWORD)ServiceInfo->ServiceMask );

        printf("    ServiceState = %ld \n",
           (DWORD)ServiceInfo->ServiceState );

        printf("    ServiceComment = %s \n",
           (DWORD)ServiceInfo->ServiceComment );

        printf("    NumBindings  = %ld \n",
            ServiceInfo->Bindings.NumBindings );

        for( k = 0; k < ServiceInfo->Bindings.NumBindings; k++) {

            LPINET_BIND_INFO BindInfo;

            BindInfo = &ServiceInfo->Bindings.BindingsInfo[k];

            printf("     %ld. Bind (%ld) = %s\n",
                   k+1,
                   BindInfo->Length,
                   (LPWSTR)BindInfo->BindData );
        }

    }
    printf("\n");

    return;
}

VOID
PrintServersInfoList( IN LPINET_SERVERS_LIST  pServersList)
{
    DWORD i;

    for( i = 0; i < pServersList->NumServers; i++ ) {

        PrintServerInfo( i, pServersList->Servers[i] );
    }

    return;
}  // PrintServersInfoList()


VOID
PrintUsageMessage(IN LPCSTR pszProgName)
{
    int i;

    printf( "Usage: %s [ -tTimeToWait] [ -sServerName] { service-names }\n",
        pszProgName);

    printf("\t Services supported are:\n");
    for (i = 0; i < NUM_SERVICES; i++) {

        printf( "\t\t %s\n", g_Services[i].pszName);
    }

} // PrintUsageMessage()

DWORD
DiscoverServerInfo(
    LPSTR ServerName,
    ULONGLONG  ulMask,
    DWORD dwWaitTime
    )
{
    DWORD Error;
    LPINET_SERVER_INFO ServerInfo = NULL;

    if( dwWaitTime == 0 ) {

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        SVC_DEFAULT_WAIT_TIME,
                        &ServerInfo );
    } else {

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        0,
                        &ServerInfo );

        if( (Error != ERROR_BAD_NETPATH ) && (Error != ERROR_SUCCESS) ) {
            return( Error );
        }

        //
        // display server info if it is found.
        //

        if( ServerInfo != NULL ) {

            //
            // display server info.
            //

            PrintServerInfo( 0, ServerInfo );
            INetFreeServerInfo( &ServerInfo );
            return( ERROR_SUCCESS );
        }

        //
        // wait for server response.
        //

        Sleep( dwWaitTime * 1000 );

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        0,
                        &ServerInfo );
    }

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( ServerInfo != NULL ) {
        PrintServerInfo( 0, ServerInfo );
    }
    else {
        printf( "INetGetServerInfo found no relevant servers\n");
    }

    //
    // free server info structure.
    //

    INetFreeServerInfo( &ServerInfo );
    return( ERROR_SUCCESS );
}

DWORD
DiscoverInetServers(
    ULONGLONG  ulMask,
    DWORD dwWaitTime
    )
{
    DWORD Error;
    LPINET_SERVERS_LIST ServersList = NULL;

    if( dwWaitTime == 0 ) {

        Error = INetDiscoverServers(
                        ulMask,
                        SVC_DEFAULT_WAIT_TIME,
                        &ServersList );
    } else {

        Error = INetDiscoverServers(
                        ulMask,
                        0,
                        &ServersList );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        //
        // ignore first enum, must have zero entry.
        //

        INetFreeDiscoverServersList( &ServersList );

        Sleep( dwWaitTime * 1000 );

        Error = INetDiscoverServers(
                        ulMask,
                        0,
                        &ServersList );
    }

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // list server info.
    //

    if ( ServersList->NumServers != 0) {

        PrintServersInfoList( ServersList );
    } else {

        printf( "INetDiscoverServers() found no relevant servers\n");
    }

    //
    // free server info structure.
    //

    INetFreeDiscoverServersList( &ServersList );
    return( ERROR_SUCCESS );
}

VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD Error;
    ULONGLONG  ulMask = 0;
    int iArgs = 1;
    DWORD dwWaitTime = 0;
    LPSTR ServerName = NULL;

    while ( argv[iArgs] != NULL ){

        if( argv[iArgs][0] == '-' ) {

            switch ( argv[iArgs][1] ) {
            case 't':
                // get the wait time
                dwWaitTime = strtoul( argv[iArgs] + 2, NULL, 0);
                break;

            case 's':
                // get the server name.
                ServerName = argv[iArgs] + 2;
                break;

            default:
                PrintUsageMessage(argv[0]);
                exit(1);
            }
        }

        iArgs++; // skip one more argument
    }

    //
    // form the mask for all services
    //

    for ( iArgs = 1; iArgs < argc; iArgs++) {

        ulMask = ulMask | GetUlMaskForService( argv[iArgs]);
    } // for

    if ( ulMask == 0) {

        PrintUsageMessage(argv[0]);
        exit(1);
    }

    if( ServerName != NULL ) {
        Error = DiscoverServerInfo(  ServerName, ulMask, dwWaitTime );
    }
    else {
        Error = DiscoverInetServers(  ulMask, dwWaitTime );
    }

    if( Error != ERROR_SUCCESS ) {
        printf("%s failed with error, %ld.\n", argv[0], Error );
        return;
    }

    printf( "Command completed successfully.\n" );
    return;

} // main()

/*************************** End Of File **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\applmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Appln Manager

File: Applmgr.h

Owner: PramodD

This is the application manager header file.
===================================================================*/
#ifndef APPLMGR_H
#define APPLMGR_H

#include "debug.h"
#include "hashing.h"
#include "cachemgr.h"
#include "appcnfg.h"
#include "compcol.h"
#include "fileapp.h"
#include "idhash.h"

#include "memcls.h"
#include "ftm.h"

#include "disptch2.h"

/*===================================================================
  #defines
===================================================================*/

#define    NUM_APPLMGR_HASHING_BUCKETS            17
#define    NOTIFICATION_BUFFER_SIZE            4096

#define    INVALID_THREADID            0xFFFFFFFF

#include "asptlb.h"

// Use to specify which source file name you want (pathInfo or pathTranslated)
#ifndef _SRCPATHTYPE_DEFINED
#define _SRCPATHTYPE_DEFINED

enum SOURCEPATHTYPE
	{
	SOURCEPATHTYPE_VIRTUAL = 0,
	SOURCEPATHTYPE_PHYSICAL = 1
	};

#endif


/*===================================================================
  Forward declarations
===================================================================*/

class CComponentCollection;
class CSessionMgr;
class CViperActivity;
class CActiveScriptEngine;
struct IDebugApplication;
struct IDebugApplicationNode;

/*===================================================================
  C A p p l n V a r i a n t s
===================================================================*/
class CApplnVariants : public IVariantDictionaryImpl
    {
private:
    ULONG               m_cRefs;            // ref count
    CAppln *            m_pAppln;           // pointer to parent object
    CompType            m_ctColType;        // type of components in collection
    CSupportErrorInfo   m_ISupportErrImp;   // implementation of ISupportErr

	HRESULT ObjectNameFromVariant(VARIANT &vKey, WCHAR **ppwszName,
	                              BOOL fVerify = FALSE);

public:
	CApplnVariants();
	~CApplnVariants();

	HRESULT Init(CAppln *pAppln, CompType ctColType);
	HRESULT UnInit();

    // The Big Three

    STDMETHODIMP         QueryInterface(const GUID &, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // OLE Automation Interface

    STDMETHODIMP get_Item(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP put_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP putref_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP get_Key(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
    STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };


/*===================================================================
  C  A p p l n
===================================================================*/

class CAppln : public IApplicationObjectImpl, public CLinkElem, public CFTMImplementation
    {

friend class CApplnMgr;
friend class CApplnCleanupMgr;
friend class CDirMonitorEntry;
friend class CApplnVariants;
    
private:

    //========= Misc flags
    
    DWORD m_fInited : 1;            // Are we initialized?
    DWORD m_fFirstRequestRan : 1;   // 1st request for this app ran?
    DWORD m_fGlobalChanged : 1;     // Global.asa has changed?
    DWORD m_fDeleteInProgress : 1;  // Delete event posted?
    DWORD m_fTombstone : 1;         // ASP is done with the app?
    DWORD m_fDebuggable : 1;        // Debugging enabled for this app?

    //========= Notification flags

    // ReadDirectoryChangesW done?
    DWORD m_fNotificationAdded : 1;    
    // change notification should use impersonation?
    DWORD m_fUseImpersonationHandle : 1;

    //========= Ref counts

    DWORD m_cRefs;
    DWORD        m_cRequests;    // Active requests count
    DWORD        m_cSessions;    // Session count

    //========= Application's key, path, global.asa

    // metabase key (unique app id)
    TCHAR *m_pszMetabaseKey;
    // physical application directory path
    TCHAR *m_pszApplnPath;
    // virtual application directory path
    TCHAR *m_pszApplnVRoot;
    // Path to global.asa for application
    TCHAR *m_pszGlobalAsa;
    // Pointer to compliled template for global.asa
    CTemplate *m_pGlobalTemplate;

    //========= Application's Session Manager

    CSessionMgr *m_pSessionMgr;  // Session manager for this app

    //========= Application's Configuration Settings
    
    CAppConfig  *m_pAppConfig; // Application Configuration object

    //========= Application's Component Collection
    
    CComponentCollection *m_pApplCompCol;      // Application scope objects

    //========= Application's dictionaries for presenting component collection
    CApplnVariants    *m_pProperties;
    CApplnVariants    *m_pTaggedObjects;

    //========= Viper Activity
    
    // Application's activity (for thread-locked appls)

    CViperActivity    *m_pActivity;

    // ======== COM+ Services Config Object

    IUnknown    *m_pServicesConfig;
    
    //========= Critical section for internal lock
    
    CRITICAL_SECTION m_csInternalLock;

    //========= External lock support
    
    CRITICAL_SECTION m_csApplnLock;
    DWORD            m_dwLockThreadID; // thread which locked
    DWORD            m_cLockRefCount;  // lock count

    //========= Notification support    
    
    // Identifiers stored by notification system
    CPtrArray	m_rgpvDME;			// list of directory monitor entries
    CPtrArray	m_rgpvFileAppln;	// list of entries relating files to applications

    // User impersonation handle for UNC change notification
    HANDLE m_hUserImpersonation;

    //========= Type Library wrapper from GLOBAL.ASA
   	IDispatch *m_pdispGlobTypeLibWrapper;

    //========= SupportErrorInfo
    
    // Interface to indicate that we support ErrorInfo reporting
    CSupportErrorInfo m_ISuppErrImp;
    
    //========= Debugging Support

    // root node for browsing of running documents
    IDebugApplicationNode *m_pAppRoot;

    HRESULT InitServicesConfig();

    // proc used to asynchronously cleanup the app

    static  DWORD __stdcall ApplnCleanupProc(VOID  *pArg);

public:
    CAppln();
    ~CAppln();
    
    HRESULT Init
        (
        TCHAR *pszApplnKey, 
        TCHAR *pszApplnPath, 
        CIsapiReqInfo   *pIReq, 
        HANDLE hUserImpersonation
        );

    // cnvert to tombstone state
    HRESULT UnInit();

    // create application's activity as clone of param
    HRESULT BindToActivity(CViperActivity *pActivity = NULL);

    // set (and remember) global.asa for this app
    HRESULT SetGlobalAsa(const TCHAR *pszGlobalAsa);

    // make sure script didn't leave locks
    HRESULT UnLockAfterRequest();

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
    HRESULT CheckForTombstone();

    // Restart an application (such as when global.asa changes)
    HRESULT Restart(BOOL fForceRestart = FALSE);

    // IApplicationObject functions
    STDMETHODIMP Lock();
    STDMETHODIMP UnLock();
    STDMETHODIMP get_Value(BSTR bstr, VARIANT *pvar);
    STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);
    STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);

    // Application config related methods
    CAppConfig *QueryAppConfig();
    BOOL        FConfigNeedsUpdate();
    HRESULT     UpdateConfig(CIsapiReqInfo   *pIReq, BOOL *pfRestart = NULL, BOOL *pfFlushAll = NULL);

    // inline methods to access member properties
    CSessionMgr           *PSessionMgr();
    CComponentCollection  *PCompCol();
    CViperActivity        *PActivity();
	IDebugApplicationNode *PAppRoot();
	CTemplate             *PGlobalTemplate();
	void                   SetGlobalTemplate(CTemplate *);
	TCHAR                 *GetMetabaseKey();
	TCHAR                 *GetApplnPath(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);
	TCHAR                 *GetGlobalAsa();
	DWORD                  GetNumSessions();
	DWORD                  GetNumRequests();
	BOOL                   FGlobalChanged();
	BOOL                   FDebuggable();
	BOOL                   FTombstone();
	BOOL                   FHasGlobalAsa();
	BOOL                   FFirstRequestRun();
   	IDispatch             *PGlobTypeLibWrapper();
    IUnknown              *PServicesConfig();

    void SetFirstRequestRan();
   	void SetGlobTypeLibWrapper(IDispatch *);
    HRESULT AddDirMonitorEntry(CDirMonitorEntry *);
    HRESULT AddFileApplnEntry(CFileApplnList *pFileAppln);

    CASPDirMonitorEntry  *FPathMonitored(LPCTSTR  pszPath);
    
    // Misc inline methods
    void InternalLock();
    void InternalUnLock();
    void IncrementSessionCount();
    void DecrementSessionCount();
    void IncrementRequestCount();
    void DecrementRequestCount();

    // AssertValid()
public:

#ifdef DBG
    virtual void AssertValid() const;
#else
    virtual void AssertValid() const {}
#endif
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

	// Trace Log info -- keep in both free & checked builds so that ntsd extension will work for both builds
	// for FREE build, trace log is always NULL.  Checked builds, it must be enabled.
	static PTRACE_LOG gm_pTraceLog;
    };

/*===================================================================
  C  A p p l n   inlines
===================================================================*/

inline CSessionMgr *CAppln::PSessionMgr()
    {
    return m_pSessionMgr;
    }

inline CComponentCollection *CAppln::PCompCol()
    {
    return m_pApplCompCol;
    }

inline CViperActivity *CAppln::PActivity()
    {
    return m_pActivity;
    }

inline IDebugApplicationNode *CAppln::PAppRoot()
    {
    return m_pAppRoot;
    }

inline TCHAR *CAppln::GetMetabaseKey()
    {
    return m_pszMetabaseKey;
    }

inline TCHAR *CAppln::GetApplnPath(SOURCEPATHTYPE pathtype)
    {
	return (pathtype == SOURCEPATHTYPE_VIRTUAL? m_pszApplnVRoot :
			(pathtype == SOURCEPATHTYPE_PHYSICAL? m_pszApplnPath : NULL));
    }

inline CTemplate *CAppln::PGlobalTemplate()
    {
    return m_pGlobalTemplate;
    }

inline void CAppln::SetGlobalTemplate(CTemplate *pTemplate)
    {
    pTemplate->AddRef();
    m_pGlobalTemplate = pTemplate;
    }

inline TCHAR *CAppln::GetGlobalAsa()
    {
    return m_pszGlobalAsa;
    }

inline DWORD CAppln::GetNumSessions()
    {
    return m_cSessions;
    }

inline DWORD CAppln::GetNumRequests()
    {
    return m_cRequests;
    }

inline BOOL CAppln::FGlobalChanged()
    {
    return m_fGlobalChanged;
    }

inline BOOL CAppln::FDebuggable()
    {
    return m_fDebuggable;
    }

inline BOOL CAppln::FTombstone()
    {
    return m_fTombstone;
    }

inline BOOL CAppln::FHasGlobalAsa()
    {
    return (m_pszGlobalAsa != NULL);
    }

inline BOOL CAppln::FFirstRequestRun()
    {
    return m_fFirstRequestRan;
    }

inline void CAppln::SetFirstRequestRan()
    {
    Assert(m_fInited);
    m_fFirstRequestRan = TRUE;
    }

inline IDispatch *CAppln::PGlobTypeLibWrapper()
    {
    return m_pdispGlobTypeLibWrapper;
    }

inline IUnknown *CAppln::PServicesConfig() {
    return m_pServicesConfig;
}
    
inline void CAppln::SetGlobTypeLibWrapper(IDispatch *pdisp)
    {
    if (m_pdispGlobTypeLibWrapper)
        m_pdispGlobTypeLibWrapper->Release();
        
    m_pdispGlobTypeLibWrapper = pdisp;
    
    if (m_pdispGlobTypeLibWrapper)
        m_pdispGlobTypeLibWrapper->AddRef();
    }

inline void CAppln::IncrementSessionCount()
    {
    Assert(m_fInited);
    InterlockedIncrement((LPLONG)&m_cSessions);
    }
    
inline void CAppln::DecrementSessionCount()
    {
    Assert(m_fInited);
    InterlockedDecrement((LPLONG)&m_cSessions);
    }

inline void CAppln::IncrementRequestCount()
    {
    Assert(m_fInited);
    InterlockedIncrement((LPLONG)&m_cRequests);
    }
    
inline void CAppln::DecrementRequestCount()
    {
    Assert(m_fInited);
    InterlockedDecrement((LPLONG)&m_cRequests);
    }
    
inline void CAppln::InternalLock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csInternalLock);
    }
    
inline void CAppln::InternalUnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection(&m_csInternalLock); 
    }

inline CAppConfig * CAppln::QueryAppConfig()
    {
    return m_pAppConfig;
    }

inline BOOL CAppln::FConfigNeedsUpdate()
    {
    return m_pAppConfig->fNeedUpdate();
    }

/*===================================================================
  C  A p p l n  M g r
===================================================================*/

class CApplnMgr : public CHashTable
    {
private:
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fHashTableInited : 1;       // Need to UnInit hash table?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

    // List of script engines that need to be closed on next request.
    // (See comments in code, esp. CApplnMgr::AddEngine)
    CDblLink m_listEngineCleanup;

public:    
    CApplnMgr();
    ~CApplnMgr();

    HRESULT    Init();
    HRESULT    UnInit();

    // CAppln manipulations
    
    HRESULT AddAppln
        (
        TCHAR *pszApplnKey, 
        TCHAR *pszApplnPath, 
        CIsapiReqInfo   *pIReq,
        HANDLE hUserImpersonation,
        CAppln **ppAppln
        );
    
    HRESULT FindAppln
        (
        TCHAR *pszApplnKey, 
        CAppln **ppAppln
        );
        
    HRESULT DeleteApplicationIfExpired(CAppln *pAppln);
    HRESULT DeleteAllApplications();
    HRESULT RestartApplications(BOOL fRestartAllApplications = FALSE);
    
    // Add an engine to the deferred cleanup list/release engines in the list
	HRESULT AddEngine(CActiveScriptEngine *pEng);
	void CleanupEngines();

    // inlines
    
    void   Lock();
    void   UnLock();
    HANDLE HDeleteEvent();
    void   SetDeleteEvent(void);
    
    };

/*===================================================================
  C  A p p l n  M g r   inlines
===================================================================*/

inline void    CApplnMgr::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void    CApplnMgr::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock ); 
    }
    
/*===================================================================
  C  A p p l n  C l e a n u p M g r
===================================================================*/

class CApplnCleanupMgr
    {
private:
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?
    DWORD m_fThreadAlive : 1;           // worker thread alive?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

    HANDLE m_hAppToCleanup; // event to signal when there is an app to cleanup

    CLinkElem m_List;

    CAppln      *Head();
    void        AddElem(CAppln *pAppln);
    void        RemoveElem(CAppln  *pAppln);

public:    
    CApplnCleanupMgr();
    ~CApplnCleanupMgr();

    HRESULT    Init();
    HRESULT    UnInit();

    // CAppln manipulations
    
    HRESULT AddAppln
        (
        CAppln *ppAppln
        );

    void Wakeup();
    
private:
    // inlines
    
    void   Lock();
    void   UnLock();

    // thread proc used to cleanup deleted applications
    static  DWORD __stdcall ApplnCleanupThread(VOID  *pArg);
    void    ApplnCleanupDoWork();
    
    };

/*===================================================================
  C  A p p l n  C l e a n u p M g r   inlines
===================================================================*/

inline void    CApplnCleanupMgr::Lock()
    {
    Assert(m_fCriticalSectionInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void    CApplnCleanupMgr::UnLock()
    {
    Assert(m_fCriticalSectionInited);
    LeaveCriticalSection( &m_csLock ); 
    }

inline CAppln  *CApplnCleanupMgr::Head()
{
    return ((m_List.m_pNext == &m_List) ? NULL : (CAppln *)m_List.m_pNext);
}
inline void    CApplnCleanupMgr::AddElem(CAppln *pAppln)
{
    pAppln->m_pNext = &m_List;
    pAppln->m_pPrev = m_List.m_pPrev;
    m_List.m_pPrev->m_pNext = pAppln;
    m_List.m_pPrev = pAppln;
}

inline void    CApplnCleanupMgr::RemoveElem(CAppln *pAppln)
{
    pAppln->m_pPrev->m_pNext = pAppln->m_pNext;
    pAppln->m_pNext->m_pPrev = pAppln->m_pPrev;
}

inline void    CApplnCleanupMgr::Wakeup()
{
    SetEvent(m_hAppToCleanup);
}
    
/*===================================================================
C A p p l n M g r thread proc prototype
===================================================================*/
void __cdecl RestartAppsThreadProc(VOID *arg);

/*===================================================================
  Globals
===================================================================*/

extern CApplnMgr    g_ApplnMgr;
extern DWORD        g_nApplications;
extern DWORD        g_nApplicationsRestarting;

/*===================================================================
  C  A p p l n  I t e r a t o r
===================================================================*/

class CApplnIterator
    {
private:
    CApplnMgr   *m_pApplnMgr;
    CAppln      *m_pCurr;
    BOOL         m_fEnded; // iterator ended

public:
                CApplnIterator(void);
    virtual        ~CApplnIterator(void);

public:
    HRESULT            Start(CApplnMgr *pApplnMgr = NULL);
    HRESULT            Stop(void);
    CAppln *        Next(void);
    };

#endif // APPLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\appcnfg.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: AppCnfg.h

Owner: AndrewS

Useful globals
===================================================================*/

#ifndef __APPCNFG_H
#define __APPCNFG_H

#include "util.h"
#include <schnlsp.h>
#include <wincrypt.h>
#include <iadmw.h>

extern "C" {

#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs

}
class CAppln;   // forward declaration
class CAppConfig;

class CMDAppConfigSink : public IMSAdminBaseSinkW
        {
        private:
        INT                     m_cRef;
        CAppConfig      *m_pAppConfig;
        public:

        CMDAppConfigSink (CAppConfig *pAppConfig)                       {m_cRef = 1; m_pAppConfig = pAppConfig;};

        HRESULT STDMETHODCALLTYPE       QueryInterface(REFIID riid, void **ppv);
        ULONG   STDMETHODCALLTYPE       AddRef(void);
        ULONG   STDMETHODCALLTYPE       Release(void);

        HRESULT STDMETHODCALLTYPE       SinkNotify(
                        DWORD   dwMDNumElements,
                        MD_CHANGE_OBJECT        __RPC_FAR       pcoChangeList[]);

        HRESULT STDMETHODCALLTYPE ShutdownNotify( void)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }
        };

//      Index used in ReadPropsfromRegistry().  Also, we can use the same index to enable the global
//      data to be table-driven.

#define IApp_AllowSessionState                                  0x0
#define IApp_BufferingOn                                        0x1
#define IApp_ScriptLanguage                                     0x2
#define IApp_EnableParentPaths                                  0x3
#define IApp_ScriptErrorMessage                                 0x4
#define IApp_SessionTimeout                                     0x5
#define IApp_CodePage                                           0x6
#define IApp_ScriptTimeout                                      0x7
#define IApp_ScriptErrorsSenttoBrowser                          0x8
#define IApp_AllowDebugging                                     0x9
#define IApp_AllowClientDebug                                   0xa
#define IApp_QueueTimeout                                       0xb
#define IApp_EnableApplicationRestart                           0xc
#define IApp_QueueConnectionTestTime                            0xd
#define IApp_SessionMax                                         0xe
#define IApp_ExecuteInMTA                                       0xf
#define IApp_LCID                                               0x10
#define IApp_KeepSessionIDSecure                                0x11 
#define IApp_ServiceFlags                                       0x12
#define IApp_PartitionGUID                                      0x13
#define IApp_SxsName                                            0x14
#define IApp_MAX                                                0x15

// flags within IApp_ServiceFlags
#define IFlag_SF_TrackerEnabled     1
#define IFlag_SF_SxsEnabled         2
#define IFlag_SF_UsePartition       4

//      Index to glob's szMessage array.
#define IAppMsg_SCRIPTERROR             0
#define IAppMsg_SCRIPTLANGUAGE          1
#define IAppMsg_PARTITIONGUID           2
#define IAppMsg_SXSNAME                 3
#define APP_CONFIG_MESSAGEMAX           4

//      Glob data object
class CAppConfig
        {
        friend class CMDAppConfigSink;
        friend HRESULT  ReadConfigFromMD(CIsapiReqInfo *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
        friend HRESULT  SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob);

private:

        CAppln          *m_pAppln;
        BOOL            m_fNeedUpdate;
        BOOL            m_fInited:1;
        BOOL            m_fRestartEnabledUpdated:1;
		BOOL            m_fIsValidProglangCLSID:1;
        BOOL            m_fIsValidPartitionGUID:1;
        /*
         * Configurable values from Metabase
         */
        BOOL            m_fScriptErrorsSentToBrowser;
        BOOL            m_fBufferingOn;                                 // Is buffering on by default?
        BOOL            m_fEnableParentPaths;
        BOOL            m_fAllowSessionState;
        BOOL            m_fAllowOutOfProcCmpnts;
        BOOL            m_fAllowDebugging;
        BOOL            m_fAllowClientDebug;
        BOOL            m_fEnableApplicationRestart;
        BOOL            m_fKeepSessionIDSecure;               
        UINT            m_uCodePage;
        DWORD           m_dwScriptTimeout;
        DWORD           m_dwSessionTimeout;
        DWORD           m_dwQueueTimeout;
        CLSID           m_DefaultScriptEngineProgID;
        DWORD           m_dwQueueConnectionTestTime;
        DWORD           m_dwSessionMax;
        BOOL            m_fExecuteInMTA;
        LCID            m_uLCID;
        CLSID           m_PartitionGUID;
        BOOL            m_fSxsEnabled;
        BOOL            m_fTrackerEnabled;
        BOOL            m_fUsePartition;
        
        IMSAdminBase   *m_pMetabase;
        CMDAppConfigSink *m_pMetabaseSink;
        DWORD           m_dwMDSinkCookie;

        LPSTR           m_szString[APP_CONFIG_MESSAGEMAX];

        //Private functions
        HRESULT         SetValue(unsigned int index, BYTE *lpByte);

public:

        CAppConfig();
        HRESULT         Init(CIsapiReqInfo  *pIReq, CAppln *pAppln);
        HRESULT         UnInit(void);
        void            NotifyNeedUpdate(void);
        BOOL            fNeedUpdate()                           {return m_fNeedUpdate;};
        BOOL            fRestartEnabledUpdated()                {return m_fRestartEnabledUpdated;};
        void            NotifyRestartEnabledUpdated()           { m_fRestartEnabledUpdated = TRUE;};
        HRESULT         Update(CIsapiReqInfo  *pIReq);

        UINT            uCodePage()                             {return m_uCodePage;};
        DWORD           dwSessionTimeout()                      {return m_dwSessionTimeout;};
        DWORD           dwQueueTimeout()                        {return m_dwQueueTimeout;};
        DWORD           dwScriptTimeout()                       {return m_dwScriptTimeout;};
        BOOL            fScriptErrorsSentToBrowser()            {return m_fScriptErrorsSentToBrowser;};
        BOOL            fBufferingOn()                          {return m_fBufferingOn;};
        BOOL            fEnableParentPaths()                    {return !m_fEnableParentPaths;};
        BOOL            fAllowSessionState()                    {return m_fAllowSessionState;};
        BOOL            fAllowOutOfProcCmpnts()                 {return m_fAllowOutOfProcCmpnts;};
        BOOL            fAllowDebugging()                       {return m_fAllowDebugging;};
        BOOL            fAllowClientDebug()                     {return m_fAllowClientDebug;};
        BOOL            fInited()                               {return m_fInited;};
        BOOL            fKeepSessionIDSecure()                  {return m_fKeepSessionIDSecure;};              
        BOOL            fExecuteInMTA()                         {return m_fExecuteInMTA;};
        LCID            uLCID()                                 {return m_uLCID; };
        LPCSTR          szScriptErrorMessage()                  {return (m_szString[IAppMsg_SCRIPTERROR]);};
        LPCSTR          szScriptLanguage()                      {return (m_szString[IAppMsg_SCRIPTLANGUAGE]);};
        CLSID           *pCLSIDDefaultEngine()                  {return m_fIsValidProglangCLSID? &m_DefaultScriptEngineProgID : NULL;};
        BOOL            fSxsEnabled()                           {return m_fSxsEnabled;};
        BOOL            fTrackerEnabled()                       {return m_fTrackerEnabled;};
        BOOL            fUsePartition()                         {return m_fUsePartition;};
        CLSID           *PPartitionGUID()                       {return m_fIsValidPartitionGUID ? & m_PartitionGUID : NULL;};
        LPCSTR          szSxsName()                             {return (m_szString[IAppMsg_SXSNAME]);};
        
        BOOL            fEnableApplicationRestart() { return m_fEnableApplicationRestart; }
        DWORD           dwQueueConnectionTestTime() { return m_dwQueueConnectionTestTime; }
        DWORD           dwSessionMax() { return m_dwSessionMax; }

        LPTSTR           SzMDPath();
        };

inline void CAppConfig::NotifyNeedUpdate(void)
{
        InterlockedExchange((LPLONG)&m_fNeedUpdate, 1);
}
#endif // __APPCNFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\aspdmon.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       aspdirmon.cpp

   Abstract:
       This module includes derivation of class supporting change
       notification for ASP template cache, from abstract class DIR_MON_ENTRY

   Author:

       Charles Grant    ( cgrant )     June-1997 

   Revision History:

--*/
#ifndef _CACHEDIRMON_H
#define _CACHEDIRMON_H

// ASP-customized file notification filter 
// see Winnt.h for valid flags, only valid for NT
#define FILE_NOTIFY_FILTER  (FILE_NOTIFY_CHANGE_FILE_NAME  | \
                               FILE_NOTIFY_CHANGE_DIR_NAME | \
                               FILE_NOTIFY_CHANGE_ATTRIBUTES | \
                               FILE_NOTIFY_CHANGE_SIZE       | \
                               FILE_NOTIFY_CHANGE_LAST_WRITE | \
                               FILE_NOTIFY_CHANGE_SECURITY)

// Number of times we will try to get request notification
#define MAX_NOTIFICATION_FAILURES 3

/************************************************************
 *     Include Headers
 ************************************************************/
# include "dirmon.h"
# include "reftrace.h"

class CASPDirMonitorEntry : public CDirMonitorEntry
{
private:
    DWORD m_cNotificationFailures;

    BOOL ActOnNotification(DWORD dwStatus, DWORD dwBytesWritten);
    void FileChanged(const TCHAR *pszScriptName, bool fFileWasRemoved);

public:
    CASPDirMonitorEntry();
    ~CASPDirMonitorEntry();
    VOID AddRef(VOID);
    BOOL Release(VOID);

    BOOL FPathMonitored(LPCTSTR  pszPath);

    // Trace Log info
	static PTRACE_LOG gm_pTraceLog;

};

BOOL RegisterASPDirMonitorEntry(LPCTSTR pszDirectory, CASPDirMonitorEntry **ppDME, BOOL  fWatchSubDirs = FALSE);

BOOL ConvertToLongFileName(const TCHAR *pszPath, const TCHAR *pszName, WIN32_FIND_DATA *pwfd);

/*===================================================================
  Globals
===================================================================*/

extern CDirMonitor  *g_pDirMonitor;


#endif /* _CACHEDIRMON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\aspdmon.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       aspdirmon.cpp

   Abstract:
       This module includes derivation of class supporting change
       notification for ASP template cache, from abstract class DIR_MON_ENTRY

   Author:

       Charles Grant    ( cgrant )     June-1997 

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "denpre.h"
#pragma hdrstop

#include "aspdmon.h"
#include "ie449.h"
#include "memchk.h"

#ifndef UNICODE
#error "ASPDMON.CPP must be compiled with UNICODE defined"
#endif

/************************************************************
 *    Inlined Documentation on change notification
 *
 * Change Notification:
 *      This module is to used to monitor the file system for changes
 *      to scripts. We need to know about changes to scripts for two 
 *      reasons:
 *      1) To keep the template cache current
 *      2) To manage applications lifetimes. If the GLOBAL.ASA
 *          for an application, or a file included in the GLOBAL.ASA
 *          changes, that application should be restarted.
 *      
 *
 *  Outline of Change Notification System
 *
 *      To obtain change notification we use the ReadDirectoryChangesW
 *      API as wrapped by the CDirMonitor and CDirMonitorEntry classes.
 *      Three hash tables are used by the change notifcation system:
 *
 *      CTemplateCacheManager   g_TemplateCache
 *      CDirMonitor             g_DirMonitor
 *      CFileApplicationMap     g_FileAppMap
 *
 *      When a template is compiled and inserted into the g_TemplateCache
 *      the template is provided with a list of files included in that
 *      template. For each file included in the template, we search the
 *      g_DirMonitor table to see if see if we are already monitoring the
 *      files parent directory for changes. If so we simply addref the 
 *      CDirMonitorEntry instance we obtain, and save a pointer to the
 *      monitor entry in an array in the corresponding file map. If the
 *      directory is not being monitored we create a new CDirMonitorEntry'
 *      instance and add it to g_DirMonitor. When we add the monitor entry
 *      to the g_DirMonitor we launch an asynchronous request to ReadDirectoryChangesW
 *      for that directory.
 *      
 *      Managing the template cache and application life times are logically 
 *      independent activities. We must monitor GLOBAL.ASA for changes even if
 *      the GLOBAL.ASA template is not currently in the template cache.
 *      So, if the template is a GLOBAL.ASA for an application, additional work
 *      must be done. For each file included in the GLOBAL.ASA we add an entry
 *      to g_FileAppMap relating that file to the applications that depend on it.
 *      We store a back pointer to the file/application mappping in the application
 *      instance, so that the application can remove the mapping when it shuts down.
 *      In the application we store a pointer to the GLOBAL.ASA template. For
 *      each file in the GLOBAL.ASA, We check g_DirMonitor to find the monitor entry
 *      for the parent directory for that file, AddRef the monitor entry we find, and
 *      add it to a list of monitor entries in the application.
 *
 *      When a change occurs to a directory we are monitoring, the callback function
 *      DirMontiorCompletionFunction will be invoked, and in turn will invoke the
 *      the ActOnNotification method of the monitor entry for that directory. If a file
 *      has changed we use g_FileAppMap to shut down those applications that depend on
 *      that file and flush the file from the template cache.
 *
 ************************************************************/

#define MAX_BUFFER_SIZE 8192

PTRACE_LOG CASPDirMonitorEntry::gm_pTraceLog = NULL;
CDirMonitor *g_pDirMonitor = NULL;

CASPDirMonitorEntry::CASPDirMonitorEntry() :
    m_cNotificationFailures(0)
/*++

Routine Description:

    Constructor
    
Arguments:

    None

Return Value:

    None
--*/
{
}

CASPDirMonitorEntry::~CASPDirMonitorEntry()
/*++

Routine Description:

    Destructor
    
Arguments:

    None

Return Value:

    None
--*/
{
}


/*++
increment refcount for an entry -- writes to reftrace log if it is defined
--*/
VOID CASPDirMonitorEntry::AddRef(VOID)
{
	CDirMonitorEntry::AddRef();
	IF_DEBUG(FCN)
		WriteRefTraceLogEx(gm_pTraceLog, m_cDirRefCount, this, PVOID(UIntToPtr(m_cIORefCount)), m_pszPath, 0);
}

BOOL CASPDirMonitorEntry::Release(VOID)
/*++

Routine Description:

    Decrement refcount to an entry, we override the base class because
    otherwise Denali's memory manager can't track when we free the object
    and reports  it as a memory leak

Arguments:

    None

Return Value:

    TRUE if object still alive, FALSE if was last release and object
    destroyed

--*/
{
	BOOL fAlive = CDirMonitorEntry::Release();

	IF_DEBUG(FCN)
		WriteRefTraceLogEx(gm_pTraceLog, m_cDirRefCount, this, PVOID(UIntToPtr(m_cIORefCount)), m_pszPath, 0);

	return fAlive;
}


BOOL 
CASPDirMonitorEntry::ActOnNotification(
                        DWORD dwStatus, 
                        DWORD dwBytesWritten)
/*++

Routine Description:

    Do any work associated with a change notification, i.e.

Arguments:

    None

Return Value:

    TRUE if application should continue to be monitored, otherwise FALSE

--*/
{
    FILE_NOTIFY_INFORMATION *pNotify = NULL;
    FILE_NOTIFY_INFORMATION *pNextNotify = NULL;
    WCHAR                   *pwstrFileName = NULL; // Wide file name

    pNextNotify = (FILE_NOTIFY_INFORMATION *) m_pbBuffer;

    // If the status word is not S_OK, then the ReadDirectoryChangesW failed
    if (dwStatus)
    {
        // If the status is ERROR_ACCESS_DENIED the directory may be deleted
        // or secured so we want to stop watching it for changes. The changes to the
        // individual scripts will flush the template cache, but we may also be watching
        // the directory for the addition of a GLOBAL.ASA. By calling FileChanged on 
        // global.asa we will force that handle on the directory to close.

        if (dwStatus == ERROR_ACCESS_DENIED)
            {
            FileChanged(SZ_GLOBAL_ASA, false);
            
            // No further notificaitons desired
            // so return false
            
            return FALSE;
            }
            
        // If we return TRUE, we'll try change notification again
        // If we return FALSE, we give up on any further change notifcation
        // We'll try a MAX_NOTIFICATION_FAILURES times and give up.
        
        if (m_cNotificationFailures < MAX_NOTIFICATION_FAILURES)
        {
            IF_DEBUG(FCN)
				DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed. Status = %d\n", dwStatus));

            m_cNotificationFailures++;
            return TRUE;    // Try to get change notification again
        }
        else
        {
			IF_DEBUG(FCN)
				DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed too many times. Giving up.\n"));
            return FALSE;   // Give up trying to get change notification
        }
    }
    else
    {
        // Reset the number of notification failure
        
        m_cNotificationFailures = 0;
    }

    // If dwBytesWritten is 0, then there were more changes then could be
    // recorded in the buffer we provided. Flush the whole cache just in case
    // CONSIDER: is this the best course of action, or should iterate through the
    // cache and test which files are expired

    if (dwBytesWritten == 0)
    {
        IF_DEBUG(FCN)
			DBGPRINTF((DBG_CONTEXT, "[CASPDirMonitorEntry] ReadDirectoryChange failed, too many changes for buffer\n"));
FlushAll:
        // Flush the 449 response file cache
        
        Do449ChangeNotification();

        // Flush everything in the cache as a precaution
        
        g_TemplateCache.FlushAll();

        // Check all applications to see if they need to be restarted

        g_ApplnMgr.RestartApplications();

		// Flush the script engine cache as a precaution (should be flushed via TemplateCache, but just in case.)

		g_ScriptManager.FlushAll();

        // Try to increase the buffer size so this doesn't happen again
        // Unfortunately the first call to ReadDirectoryChangesW on this
        // file handle establishes the buffer size. We must close and re-open
        // the file handle to change the buffer size

        if (ResetDirectoryHandle() && (GetBufferSize() < MAX_BUFFER_SIZE))
        {
        	SetBufferSize(2 * GetBufferSize());
        }

        return TRUE;
    }

    STACK_BUFFER(filename, MAX_PATH * sizeof(WCHAR));

    while ( pNextNotify != NULL )
    {
        DWORD   cch;

        pNotify        = pNextNotify;            
        pNextNotify = (FILE_NOTIFY_INFORMATION    *) ((PCHAR) pNotify + pNotify->NextEntryOffset);

        // Resize the stack buffer to the size of the filename.  I know it's
        // ugly, but if it fails, jump back up to the flush all logic.

        // NOTE that the FileNameLength in the NOTIFY structure is in Bytes, not chars

        if (!filename.Resize(pNotify->FileNameLength+2)) {
            goto FlushAll;
        }
    
        pwstrFileName = (WCHAR *)filename.QueryPtr();

        memcpy(pwstrFileName, pNotify->FileName, pNotify->FileNameLength);

        cch = pNotify->FileNameLength/sizeof(WCHAR);

        pwstrFileName[cch] = L'\0';

        // Take the appropriate action for the directory change
        switch (pNotify->Action)
        {
            case FILE_ACTION_ADDED:
            case FILE_ACTION_RENAMED_NEW_NAME:
                // 'File Added' only matters for GLOBAL.ASA
				IF_DEBUG(FCN)
					DBGPRINTF((DBG_CONTEXT, "Change Notification: New file added: %S\n", pwstrFileName));

                if (cch != CCH_GLOBAL_ASA || 
                    wcsicmp(pwstrFileName, SZ_GLOBAL_ASA) != 0)
                {
                    break;
                }
            case FILE_ACTION_REMOVED:
            case FILE_ACTION_MODIFIED:
            case FILE_ACTION_RENAMED_OLD_NAME:
				IF_DEBUG(FCN)
					DBGPRINTF((DBG_CONTEXT, "Change Notification: File %s: %S\n", pNotify->Action == FILE_ACTION_MODIFIED? "changed" : "removed", pwstrFileName));

                FileChanged(pwstrFileName, pNotify->Action != FILE_ACTION_MODIFIED);
                break;
            default:
                break;
        }
        
        if(pNotify == pNextNotify)
        {
            break;
        }  
    }
    
    // We should sign up for further change notification
    
    return TRUE;        
}

void 
CASPDirMonitorEntry::FileChanged(const WCHAR *pszScriptName, bool fFileWasRemoved)
/*++

Routine Description:

    An existing file has been modified or deleted
    Flush scripts from cache or mark application as expired

Arguments:

    pszScriptName   Name of file that changed

Return Value:

    None    Fail silently

--*/
{

    // The file name is set by the application that
    // modified the file, so old applications like EDIT
    // may hand us a munged 8.3 file name which we should
    // convert to a long name. All munged 8.3 file names contain '~'
    // We assume the path does not contain any munged names.
    WIN32_FIND_DATA wfd;

    STACK_BUFFER( tempScriptName, MAX_PATH );
    STACK_BUFFER( tempScriptPath, MAX_PATH );
	
	bool fRemoveMultiple = false;
	WCHAR *pT = wcschr(pszScriptName, '~');
    if (pT)
    {
        
        if (ConvertToLongFileName(m_pszPath, pszScriptName, &wfd))
        {
            pszScriptName = (WCHAR *) &wfd.cFileName;
        }
        else
        {
			// It could be a long filename that was deleted, so remove everything in cache past the '~'.
			if (fFileWasRemoved)
			{
				fRemoveMultiple = true;
				DWORD cchToCopy = (DWORD)(pT - pszScriptName)/sizeof(WCHAR);
                if (tempScriptName.Resize((cchToCopy+1)*sizeof(WCHAR)) == FALSE) {
                    return;
                }
                WCHAR *szScriptNameCopy = (WCHAR *)tempScriptName.QueryPtr();

				// copy prefix to delete into local buffer.
				wcsncpy(szScriptNameCopy, pszScriptName, cchToCopy);
				szScriptNameCopy[cchToCopy] = '\0';

				pszScriptName = szScriptNameCopy;
			}
			else
				return;
        }
    }

    // Allocate enough memory to concatentate the 
    // application path and script name

    DWORD cch = m_cPathLength + wcslen(pszScriptName);
    if (tempScriptPath.Resize((cch + 1)*sizeof(WCHAR)) == FALSE) {
        return;
    }
    LPWSTR pszScriptPath = (LPWSTR) tempScriptPath.QueryPtr(); 
    Assert(pszScriptPath != NULL);
    
    // Copy the application path into the script path
    // pT will point to the terminator of the application path

    pT = strcpyEx(pszScriptPath, m_pszPath);

    // Now append the script name. Note that the script name is
    // relative to the directory that we received the notification for

    wcscpy(pT, pszScriptName);
    Normalize(pszScriptPath);

    // It is important that we flush the cache and then shutdown applications
    // The call to shut down applications is asynch, and could result in the 
    // template being delted while we are in the process of flushing it.
    // CONSIDER: Is this really indicative of a ref-counting problem?
    
	if (fRemoveMultiple)
	{
		IF_DEBUG(FCN)
			DBGPRINTF((DBG_CONTEXT, "ChangeNotification: Flushing \"%S*\" from cache.\n", pszScriptPath));

		g_IncFileMap.FlushFiles(pszScriptPath);
		g_TemplateCache.FlushFiles(pszScriptPath);
		Do449ChangeNotification(NULL);   // not used often, no selective delete
	}
	else
	{
		g_IncFileMap.Flush(pszScriptPath);
		g_TemplateCache.Flush(pszScriptPath, MATCH_ALL_INSTANCE_IDS);
		Do449ChangeNotification( pszScriptPath );
	}

    // g_FileAppMap will shutdown any applications
    // that depend on this file.
    g_FileAppMap.ShutdownApplications( pszScriptPath );
}


BOOL CASPDirMonitorEntry::FPathMonitored(LPCWSTR pszPath)
{
    if (m_fWatchSubdirectories && (wcsncmp(m_pszPath,pszPath, m_cPathLength) == 0)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
RegisterASPDirMonitorEntry(
            LPCWSTR pcwszDirectoryName,
            CASPDirMonitorEntry **ppDME,
            BOOL    fWatchSubDirs /* = FALSE */
    )
/*++

Routine Description:

    Find entry and create a new one and start monitoring
    if not found.

Arguments:

    pszDirectory - directory to monitor
    ppDNE - Found (or newly created) entry (optional)

Return Value:

    TRUE if success, otherwise FALSE

Remarks:

    Not compatible with WIN95

--*/
{

    DWORD           cchDirectory;
    WCHAR           *pwszDirectory = (WCHAR *)pcwszDirectoryName;
    
    STACK_BUFFER(tempDirectory, 256);

    cchDirectory = wcslen(pcwszDirectoryName);

    // The directory monitor code requires, or possibly ASP's use of the directory
    // monitor, that the directory contain a trailing backslash

    if( cchDirectory 
        && (pcwszDirectoryName[cchDirectory - 1] != L'\\') ) {

        // we need to add the backslash.  To do this, we'll need to allocate 
        // memory from somewhere to make a copy of the converted string with
        // the trailing backslash.

        if (tempDirectory.Resize((cchDirectory + 2) * sizeof(WCHAR)) == FALSE) {
            return FALSE;
        }

        // copy the converted string to the just allocated buffer and add
        // the trailing backslash and NULL terminator

        wcscpy((WCHAR *)tempDirectory.QueryPtr(), pcwszDirectoryName);
        
        pwszDirectory = (WCHAR *)tempDirectory.QueryPtr();

        pwszDirectory[cchDirectory] = L'\\';
        cchDirectory++;
        pwszDirectory[cchDirectory] = '\0';

    }

    // Don't loop forever
    BOOL fTriedTwice = FALSE;

TryAgain:	

    // Check Existing first
    CASPDirMonitorEntry *pDME = (CASPDirMonitorEntry *)g_pDirMonitor->FindEntry( pwszDirectory );

    if ( pDME == NULL )
    {
        // Not found - create new entry

        pDME = new CASPDirMonitorEntry;
        
        if ( pDME )
        {
            pDME->AddRef();
            pDME->Init(NULL);

            // Start monitoring
            if ( !g_pDirMonitor->Monitor(pDME, pwszDirectory, fWatchSubDirs, FILE_NOTIFY_FILTER) )
            {
                // Cleanup if failed
                pDME->Release();
                pDME = NULL;
                
                //
                // We might still be successful if the monitor failed because
                // someone slipped it into the hash table before we had 
                // a chance
                //
                
                if ( GetLastError() == ERROR_ALREADY_EXISTS &&
                     !fTriedTwice )
                {
                    fTriedTwice = TRUE;
                    goto TryAgain;
                }
            }
        }
    }

    // Return entry if found
    if ( pDME != NULL )
    {
        *ppDME = static_cast<CASPDirMonitorEntry *>(pDME);
        return TRUE;
    }
    else
    {
        *ppDME = NULL;
        return FALSE;
    }
}


BOOL 
ConvertToLongFileName(
                const WCHAR *pszPath, 
                const WCHAR *pszName, 
                WIN32_FIND_DATA *pwfd)
/*++

Routine Description:

    Finds the long filename corresponding to a munged 8.3 filename.
    
Arguments:

    pszPath     The path to the file
    pszName     The 8.3 munged version of the file name
    pwfd        Find data structure used to contain the long
                version of the file name.

Return Value:

    TRUE        if the file is found,
    FALSE       otherwise
--*/
{
    STACK_BUFFER( tempName, MAX_PATH*sizeof(WCHAR) );

    // Allocate enough memory to concatentate the file path and name

    DWORD cb = (wcslen(pszPath) + wcslen(pszName)) * sizeof(WCHAR);

    if (tempName.Resize(cb + sizeof(WCHAR)) == FALSE) {
        return FALSE;
    }
    WCHAR *pszFullName = (WCHAR *) tempName.QueryPtr();
    Assert(pszFullName != NULL);

    // Copy the path into the working string
    // pT will point to the terminator of the application path

    WCHAR* pT = strcpyEx(pszFullName,
                         pszPath);

    // Now append the file name. Note that the script name is
    // relative to the directory that we received the notification for

    wcscpy(pT, pszName);


    // FindFirstFile will find using the short name
    // We can then find the long name from the WIN32_FIND_DATA

    HANDLE hFindFile = FindFirstFile(pszFullName, pwfd);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
           return FALSE;
    }

    // Now that we have the find data we don't need the handle
    FindClose(hFindFile);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\applmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Application Object Manager

File: Applmgr.cpp

Owner: PramodD

This is the Application Manager source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "activdbg.h"
#include "mtacb.h"
#include "debugger.h"
#include "memchk.h"

PTRACE_LOG          CAppln::gm_pTraceLog = NULL;
CApplnMgr           g_ApplnMgr;
CApplnCleanupMgr    g_ApplnCleanupMgr;
DWORD               g_nApplications = 0;
DWORD               g_nApplicationsRestarting = 0;
DWORD               g_nApplicationsRestarted = 0;
LONG                g_nAppRestartThreads = 0;

#define DENALI_FILE_NOTIFY_FILTER 0

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
   S c r i p t E n g i n e C l e a n u p

Node type for linked list of script engines to cleanup
===================================================================*/

struct CScriptEngineCleanupElem : CDblLink
    {
    CActiveScriptEngine *m_pEngine;
    CScriptEngineCleanupElem(CActiveScriptEngine *pEngine) : m_pEngine(pEngine)
        {
        m_pEngine->AddRef();
        }

    ~CScriptEngineCleanupElem()
        {
        m_pEngine->FinalRelease();
        }
    };

/*===================================================================
   C A p p l n V a r i a n t s
===================================================================*/

/*===================================================================
CApplnVariants::CApplnVariants

Constructor

Parameters:

Returns:
===================================================================*/
CApplnVariants::CApplnVariants()
    :
    m_cRefs(1),
    m_pAppln(NULL),
    m_ctColType(ctUnknown),
    m_ISupportErrImp(this, this, IID_IVariantDictionary)
    {
    CDispatch::Init(IID_IVariantDictionary);
    }

/*===================================================================
CApplnVariants::~CApplnVariants

Constructor

Parameters:

Returns:
===================================================================*/
CApplnVariants::~CApplnVariants()
    {
    Assert(!m_pAppln);
    }

/*===================================================================
CApplnVariants::Init

Init ApplnVariants

Parameters:
    CAppln   *pAppln            application
    CompType  ctColType         component collection type

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::Init
(
CAppln *pAppln,
CompType ctColType
)
    {
    Assert(pAppln);
    pAppln->AddRef();

    Assert(!m_pAppln);

    m_pAppln    = pAppln;
    m_ctColType = ctColType;
    return S_OK;
    }

/*===================================================================
CApplnVariants::UnInit

UnInit ApplnVariants

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::UnInit()
    {
    if (m_pAppln)
        {
        m_pAppln->Release();
        m_pAppln = NULL;
        }
    return S_OK;
    }

/*===================================================================
CApplnVariants::QueryInterface
CApplnVariants::AddRef
CApplnVariants::Release

IUnknown members for CApplnVariants object.
===================================================================*/
STDMETHODIMP CApplnVariants::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown || iid == IID_IDispatch ||
        iid == IID_IVariantDictionary)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }
    else if (iid == IID_ISupportErrorInfo)
        {
        m_ISupportErrImp.AddRef();
        *ppvObj = &m_ISupportErrImp;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }

STDMETHODIMP_(ULONG) CApplnVariants::AddRef()
    {
    return InterlockedIncrement((LPLONG)&m_cRefs);
    }

STDMETHODIMP_(ULONG) CApplnVariants::Release()
    {
    if (InterlockedDecrement((LPLONG)&m_cRefs) > 0)
        return m_cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CApplnVariants::ObjectNameFromVariant

Gets name from variant. Resolves operations by index.
Allocates memory for name.

Parameters:
    vKey        VARIANT
    ppwszName   [out] allocated name
    fVerify     flag - check existance if named

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnVariants::ObjectNameFromVariant
(
VARIANT &vKey,
WCHAR **ppwszName,
BOOL fVerify
)
    {
    *ppwszName = NULL;

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    VARIANT *pvarKey = &vKey;
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    if (V_VT(pvarKey) != VT_BSTR && V_VT(pvarKey) != VT_I2 && V_VT(pvarKey) != VT_I4)
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &vKey, IID_IVariantDictionary, IDE_APPLICATION)))
            {
            ExceptionId(IID_IVariantDictionary, IDE_APPLICATION, IDE_EXPECTING_STR);
            VariantClear(&varKeyCopy);
            return E_FAIL;
            }
        pvarKey = &varKeyCopy;
        }

    LPWSTR pwszName = NULL;

    switch (V_VT(pvarKey))
        {
        case VT_BSTR:
            {
            pwszName = V_BSTR(pvarKey);

            if (fVerify && pwszName)
                {
                CComponentObject *pObj = NULL;

                Assert(m_pAppln);
                Assert(m_pAppln->PCompCol());

                if (m_ctColType == ctTagged)
                    m_pAppln->PCompCol()->GetTagged(pwszName, &pObj);
                else
                    m_pAppln->PCompCol()->GetProperty(pwszName, &pObj);

                if (!pObj || pObj->GetType() != m_ctColType)
                    pwszName = NULL; // as if not found
                }
            break;
            }

        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                return E_FAIL;

        // fallthru to VT_I4

        case VT_I4:
            {
            int i;
            // Look up the object by index
            i = V_I4(pvarKey);

            if (i > 0)
                {
                Assert(m_pAppln);
                Assert(m_pAppln->PCompCol());

                m_pAppln->PCompCol()->GetNameByIndex
                    (
                    m_ctColType,
                    i,
                    &pwszName
                    );
                }
            break;
            }
        }

    if (pwszName)
    {
        *ppwszName = StringDupW(pwszName);        
    }

    VariantClear(&varKeyCopy);
    return S_OK;
    
    }

/*===================================================================
CApplnVariants::get_Item

Function called from DispInvoke to get keys from the collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - integers access collection as an array
    pvarReturn    VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::get_Item
(
VARIANT varKey,
VARIANT *pVar
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    // Initialize return value
    VariantInit(pVar);

    if (!m_pAppln->PCompCol())
        return S_OK;

    // Get HitObj from Viper if Tagged Variants
    CHitObj *pHitObj = NULL;
    if (m_ctColType == ctTagged)
        {
        ViperGetHitObjFromContext(&pHitObj);
        if (!pHitObj)
            return S_OK; // return emtpy variant
        }

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        {
        m_pAppln->UnLock();
        return hr;
        }

    // Find object by name
    CComponentObject *pObj = NULL;

    if (m_ctColType == ctTagged)
        {
        Assert(pHitObj);
        // need to go through HitObj for instantiation
        pHitObj->GetComponent(csAppln, pwszName, CbWStr(pwszName), &pObj);
        if (pObj && (pObj->GetType() != ctTagged))
            pObj = NULL;
        }
    else
        {
        m_pAppln->PCompCol()->GetProperty(pwszName, &pObj);
        }

    if (pObj)
        pObj->GetVariant(pVar);

    m_pAppln->UnLock();

    free(pwszName);
    return S_OK;
    }

/*===================================================================
CApplnVariants::put_Item

OLE automation put for Item property

Parameters:
    varKey     key
    Var        value

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::put_Item
(
VARIANT varKey,
VARIANT Var
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    m_pAppln->Lock();

    // Resolve the variant
    VARIANT varResolved;
    HRESULT hr = VariantResolveDispatch
        (
        &varResolved,
        &Var,
        IID_IApplicationObject,
        IDE_APPLICATION
        );
    if (FAILED(hr))
        {
        m_pAppln->UnLock();
        return hr;      // exception already raised
        }

    // Get name
    WCHAR *pwszName = NULL;
    hr = ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        // Set the property
        if (m_pAppln->PCompCol())
            hr = m_pAppln->PCompCol()->AddProperty(pwszName, &varResolved);
        else
            hr = E_FAIL; // not likely if application not UnInited
        }

    VariantClear(&varResolved);
    m_pAppln->UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    free(pwszName);
    return hr;
    }

/*===================================================================
CApplnVariants::putref_Item

OLE automation putref for Item property

Parameters:
    varKey     key
    Var        value

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::putref_Item
(
VARIANT varKey,
VARIANT Var
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    if (FIsIntrinsic(&Var))
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_INTRINSIC);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    if (!m_pAppln->PCompCol())
        return E_FAIL;

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        // Set the property
        if (m_pAppln->PCompCol())
            hr = m_pAppln->PCompCol()->AddProperty(pwszName, &Var);
        else
            hr = E_FAIL; // not likely if application not UnInited
        }

    m_pAppln->UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    if (pwszName)
        free(pwszName);
    return hr;
    }

/*===================================================================
CApplnVariants::get_Key

Function called from DispInvoke to get values from the collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - integers access collection as an array
    pvarReturn    VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::get_Key
(
VARIANT varKey,
VARIANT *pVar
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    VariantInit(pVar);

    if (!m_pAppln->PCompCol())
        return S_OK;

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName, TRUE);

    m_pAppln->UnLock();

    if (!pwszName)
        return hr;

    // Return BSTr
    BSTR bstrT = SysAllocString(pwszName);
    free(pwszName);

    if (!bstrT)
        return E_OUTOFMEMORY;

    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = bstrT;
    return S_OK;
    }

/*===================================================================
CApplnVariants::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/
STDMETHODIMP CApplnVariants::get_Count
(
int *pcValues
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        *pcValues = m_pAppln->m_pApplCompCol->GetTaggedObjectCount();
    else
        *pcValues = m_pAppln->m_pApplCompCol->GetPropertyCount();

    return S_OK;
    }

/*===================================================================
CApplnVariants::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CApplnVariants::get__NewEnum
(
IUnknown **ppEnumReturn
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CVariantsIterator *pIterator = new CVariantsIterator(m_pAppln, m_ctColType);
    if (pIterator == NULL)
        {
        ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CApplnVariants::Remove

Remove item

Parameters:
    varKey     key

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::Remove
(
VARIANT varKey
)
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    m_pAppln->Lock();

    // Get name
    WCHAR *pwszName = NULL;
    ObjectNameFromVariant(varKey, &pwszName);
    if (pwszName)
        {
        CComponentCollection *pCompCol = m_pAppln->PCompCol();

        // Set the property
        if (pCompCol)
            pCompCol->RemoveProperty(pwszName);

        free(pwszName);
        }

    m_pAppln->UnLock();
    return S_OK;
    }

/*===================================================================
CApplnVariants::RemoveAll

Remove all items

Parameters:
    varKey     key

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CApplnVariants::RemoveAll()
    {
    if (!m_pAppln || FAILED(m_pAppln->CheckForTombstone()))
        return E_FAIL;

    if (m_ctColType == ctTagged)
        {
        ExceptionId(IID_IVariantDictionary, IDE_APPLICATION,
                    IDE_CANT_MOD_STATICOBJECTS);
        return E_FAIL;
        }

    Assert(m_ctColType == ctProperty);

    m_pAppln->Lock();

    CComponentCollection *pCompCol = m_pAppln->PCompCol();
        
    if (pCompCol)
        {
        pCompCol->RemoveAllProperties();
        }

    m_pAppln->UnLock();
    return S_OK;
    }


/*===================================================================
  C A p p l n
===================================================================*/

/*===================================================================
CAppln::CAppln

Constructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CAppln::CAppln()
    :
    m_fInited(FALSE),
    m_fFirstRequestRan(FALSE),
    m_fGlobalChanged(FALSE),
    m_fDeleteInProgress(FALSE),
    m_fTombstone(FALSE),
    m_fDebuggable(FALSE),
    m_fNotificationAdded(FALSE),
    m_fUseImpersonationHandle(FALSE),
    m_cRefs(1),
    m_pszMetabaseKey(NULL),
    m_pszApplnPath(NULL),
    m_pszGlobalAsa(NULL),
    m_pGlobalTemplate(NULL),
    m_cSessions(0),
    m_cRequests(0),
    m_pSessionMgr(NULL),
    m_pApplCompCol(NULL),
    m_pProperties(NULL),
    m_pTaggedObjects(NULL),
    m_pAppRoot(NULL),
    m_pActivity(NULL),
    m_dwLockThreadID(INVALID_THREADID),
    m_cLockRefCount(0),
    m_hUserImpersonation(NULL),
    m_pdispGlobTypeLibWrapper(NULL),
    m_pServicesConfig(NULL)
{
    
    // COM stuff
    m_ISuppErrImp.Init(static_cast<IApplicationObject *>(this), 
                        static_cast<IApplicationObject *>(this), 
                        IID_IApplicationObject);
    CDispatch::Init(IID_IApplicationObject);

    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
    }
}

/*===================================================================
CAppln::~CAppln

Destructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CAppln::~CAppln()
    {
    Assert(m_fTombstone);  // must be tombstoned before destructor
    Assert(m_cRefs == 0);  // must have 0 ref count

    #ifdef DBG_NOTIFICATION
    DBGPRINTF((DBG_CONTEXT, "Deleting application %p\n", this));
    #endif // DBG_NOTIFICATION
    }

/*===================================================================
HRESULT CAppln::Init

Initialize object

Parameters:
    char *pszApplnKey           application's metabase key
    char *pszApplnPath          application's directory path
    CIsapiReqInfo  *pIReq       Isapi Req Info
    HANDLE hUserImpersonation   impersonation handle

Returns:
    S_OK              Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory failure
===================================================================*/
HRESULT CAppln::Init
(
TCHAR *pszApplnKey,
TCHAR *pszApplnPath,
CIsapiReqInfo *pIReq,
HANDLE hUserImpersonation
)
    {
    HRESULT         hr = S_OK;
    CMBCSToWChar    convStr;

    InterlockedIncrement((LPLONG)&g_nApplications);

    Assert(pszApplnKey);
    Assert(pszApplnPath);

    void *pHashKey = NULL;
    DWORD dwHashKeyLength = 0;
    DWORD cch;

    // Debugging variables (These are placed here for possible cleanup)
    IDebugApplicationNode *pVirtualServerRoot = NULL;
    CFileNode *pFileNode = NULL;

    // Critical sections created together --
    // they are deleted in the destructor based on m_fInited flag

    ErrInitCriticalSection(&m_csInternalLock, hr);
    if (SUCCEEDED(hr))
        {
        ErrInitCriticalSection(&m_csApplnLock, hr);
        if (FAILED(hr))
            DeleteCriticalSection(&m_csInternalLock);
        }

    if (FAILED(hr))
    	{
    	DBGPRINTF((DBG_CONTEXT, "New Application Failed to acquire Critical Section, hr = %08x\n", hr));
        return hr;
        }

    // Remember (copy of) metabase key

    cch = _tcslen(pszApplnKey);
    m_pszMetabaseKey = new TCHAR[(cch+1) * sizeof(TCHAR)];
    if (!m_pszMetabaseKey)
    	goto LCleanupOOM;
    memcpy(m_pszMetabaseKey, pszApplnKey, (cch+1)*sizeof(TCHAR));

    pHashKey = m_pszMetabaseKey;
    dwHashKeyLength = cch * sizeof(TCHAR);

    // Remember (copy of) appln path
    cch = _tcslen(pszApplnPath);
    m_pszApplnPath = new TCHAR[(cch+1) * sizeof(TCHAR)];
    if (!m_pszApplnPath)
        goto LCleanupOOM;
    memcpy(m_pszApplnPath, pszApplnPath, (cch+1)*sizeof(TCHAR));

    // Get virtual path of appln & remember what it is
    TCHAR szApplnVRoot[256];
    if (FAILED(FindApplicationPath(pIReq, szApplnVRoot, sizeof szApplnVRoot)))
    	{
        DBGWARN((DBG_CONTEXT, "New Application Failed to FindApplicationPath(), hr = %#08x\n", hr));
        goto LCleanup;
        }

    if ((m_pszApplnVRoot = new TCHAR [(_tcslen(szApplnVRoot) + 1)*sizeof(TCHAR)]) == NULL)
        goto LCleanupOOM;
    _tcscpy(m_pszApplnVRoot, szApplnVRoot);

    // Initialize link element with key
    Assert(pHashKey);
    Assert(dwHashKeyLength);

    if (FAILED(CLinkElem::Init(pHashKey, dwHashKeyLength)))
    	goto LCleanupOOM;

    // Setup impersonation

    m_fNotificationAdded = FALSE;
    if (FIsWinNT() && pszApplnPath &&
        pszApplnPath[0] ==_T('\\') && pszApplnPath[1] == _T('\\'))
        {
        m_fUseImpersonationHandle = DuplicateToken
            (
            hUserImpersonation,
            SecurityImpersonation,
            &m_hUserImpersonation
            );
        }

    m_cSessions = 0;
    m_cRequests = 0;

    // Create and init app config
    m_pAppConfig = new CAppConfig();
    if (!m_pAppConfig)
		goto LCleanupOOM;

    hr = m_pAppConfig->Init(pIReq, this);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the AppConfig, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // Create and init application level component collection
    m_pApplCompCol = new CComponentCollection;
    if (!m_pApplCompCol)
        goto LCleanupOOM;

    hr = m_pApplCompCol->Init(csAppln);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Component Collection, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // initialize application properties collection
    m_pProperties = new CApplnVariants;
    if (!m_pProperties)
        goto LCleanupOOM;
    hr = m_pProperties->Init(this, ctProperty);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Application Properties, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // initialize application tagged object collection
    m_pTaggedObjects = new CApplnVariants;
    if (!m_pTaggedObjects)
        goto LCleanupOOM;
    hr = m_pTaggedObjects->Init(this, ctTagged);
    if (FAILED(hr))
        {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init the Application Tagged Objects, hr = %#08x\n", hr));
        goto LCleanup;
        }

    // Initialize the CServicesConfig Object

    hr = InitServicesConfig();
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init ServicesConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    // Debugging support  - Create an application node
    // If PDM does not exist it means debugger not installed or it's Win 95
    //
    if (g_pPDM)
        {
        // Debugging directories are shown as:
        //
        //      <virtual web server>
        //         <application name>
        //              <path to ASP>
        //
        // Get a pointer to the document node containing the virtual web server.
        if (FAILED(hr = GetServerDebugRoot(pIReq, &pVirtualServerRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not GetServerDebugRoot(), hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Create a node for this application
        if (FAILED(hr = g_pDebugApp->CreateApplicationNode(&m_pAppRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not CreateApplicationNode(), hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Create a doc provider for the node
        if ((pFileNode = new CFileNode) == NULL)
            goto LCleanupOOM;

        // Name the application
        TCHAR szDebugApp[256];
        TCHAR *pchEnd = strcpyEx(szDebugApp, m_pszApplnVRoot);
        if (! QueryAppConfig()->fAllowDebugging()) {
#if UNICODE
            CwchLoadStringOfId(
#else
            CchLoadStringOfId(
#endif
            IDS_DEBUGGING_DISABLED, pchEnd, DIFF(&szDebugApp[sizeof (szDebugApp)/sizeof(TCHAR)] - pchEnd));
            m_fDebuggable = FALSE;
        }
        else
            m_fDebuggable = TRUE;
        Assert (_tcslen(szDebugApp) < (sizeof(szDebugApp)/sizeof(TCHAR)));

        WCHAR   *pswzDebugApp;
#if UNICODE
        pswzDebugApp = szDebugApp;
#else
        if (FAILED(hr = convStr.Init(szDebugApp))) {
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Cannot convert szDebugApp to UNICODE, hr = %#08x\n", hr));
            goto LCleanup;
        }
        pswzDebugApp = convStr.GetString();
#endif

        if (FAILED(hr = pFileNode->Init(pswzDebugApp)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Cannot Init CFileNode, hr = %#08x\n", hr));
            goto LCleanup;
            }

        if (FAILED(hr = m_pAppRoot->SetDocumentProvider(pFileNode)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: SetDocumentProvider failed, hr = %#08x\n", hr));
            goto LCleanup;
            }

        // Attach to the UI
        if (FAILED(hr = m_pAppRoot->Attach(pVirtualServerRoot)))
        	{
        	DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Attach to debugger, hr = %#08x\n", hr));
            goto LCleanup;
            }

        // If this application had a previous incarnation (changed global.asa
        // or debugging being flipped on in midstream), then there may be some
        // documents in the cache which should be added to the debugger now.
        if (m_fDebuggable)
            {
            g_TemplateCache.AddApplicationToDebuggerUI(this);

            // create the global debug activity if it hasn't been created already
            if (g_pDebugActivity == NULL) {
                g_pDebugActivity = new CViperActivity;
                if (g_pDebugActivity == NULL) {
                    hr = E_OUTOFMEMORY;
                    goto LCleanup;
                }
                if (FAILED(hr = g_pDebugActivity->Init(m_pServicesConfig))) {
				    DBGWARN((DBG_CONTEXT, "New Application Failed: Could not create global debug activity, hr = %#08x\n", hr));
				    goto LCleanup;
                }
            }

            // In DEBUG mode: all requests run on the same thread
            if (FAILED(hr = BindToActivity(g_pDebugActivity)))
				{
				DBGWARN((DBG_CONTEXT, "New Application Failed: Could not bind application to debugging activity, hr = %#08x\n", hr));
				goto LCleanup;
				}
            }
        }

    // For Win95: all requests run on the same thread

    if (!FIsWinNT())
        {
        if (FAILED(hr = BindToActivity()))
			{
			DBGWARN((DBG_CONTEXT, "New Application Failed: Could not bind application to Win95 activity, hr = %#08x\n", hr));
			goto LCleanup;
			}
        }

    // Create and init session manager
    m_pSessionMgr = new CSessionMgr;
    if (!m_pSessionMgr)
        goto LCleanupOOM;

    hr = m_pSessionMgr->Init(this);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: Could not Init session manager, hr = %#08x\n", hr));
		goto LCleanup;
		}

LCleanup:
    // Release interfaces
    if (pFileNode)
        pFileNode->Release();

    if (pVirtualServerRoot)
        pVirtualServerRoot->Release();

    if (SUCCEEDED(hr))
        m_fInited = TRUE;

    return hr;

LCleanupOOM:
	hr = E_OUTOFMEMORY;
	DBGERROR((DBG_CONTEXT, "New Application Failed: E_OUTOFMEMORY\n"));
	goto LCleanup;
    }

/*===================================================================
CAppln::InitServicesConfig

Initializes the Application scoped CServicesConfig object
===================================================================*/
HRESULT CAppln::InitServicesConfig()
{
    HRESULT                         hr;
    IServiceThreadPoolConfig        *pIThreadPool = NULL;
    IServiceSynchronizationConfig   *pISyncConfig = NULL;
    IServicePartitionConfig         *pIPartitionConfig = NULL;
    IServiceSxsConfig               *pISxsConfig = NULL;

	hr = CoCreateInstance(CLSID_CServiceConfig, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IUnknown, 
                          (void **)&m_pServicesConfig); 
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not CCI ServicesConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = m_pServicesConfig->QueryInterface(IID_IServiceThreadPoolConfig, (void **)&pIThreadPool);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServiceThreadPoolConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = pIThreadPool->SelectThreadPool(m_pAppConfig->fExecuteInMTA() ? CSC_MTAThreadPool : CSC_STAThreadPool);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Failed to SelectThreadPool, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = m_pServicesConfig->QueryInterface(IID_IServiceSynchronizationConfig, (void **)&pISyncConfig);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServiceSynchronizationConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = pISyncConfig->ConfigureSynchronization (CSC_IfContainerIsSynchronized);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not ConfigureSynchronization, hr = %#08x\n", hr));
		goto LCleanup;
    }

    if (m_pAppConfig->fUsePartition() && m_pAppConfig->PPartitionGUID()) {

        hr = m_pServicesConfig->QueryInterface(IID_IServicePartitionConfig, (void **)&pIPartitionConfig);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServicePartitionConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        hr = pIPartitionConfig->PartitionConfig(CSC_NewPartition);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set PartitionConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        hr = pIPartitionConfig->PartitionID(*m_pAppConfig->PPartitionGUID());
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set PartitionID, hr = %#08x\n", hr));
		    goto LCleanup;
        }
    }

    if (m_pAppConfig->fSxsEnabled()) {

        hr = m_pServicesConfig->QueryInterface(IID_IServiceSxsConfig, (void **)&pISxsConfig);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not QI for IServiceSxsConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        hr = pISxsConfig->SxsConfig(CSC_NewSxs);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set SxsConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        LPWSTR  pwszApplnPath;
#if UNICODE
        pwszApplnPath = m_pszApplnPath;
#else
        CMBCSToWChar    convPath;

        hr = convPath.Init(m_pszApplnPath);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not convert ApplnPath to UNICODE, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        pwszApplnPath = convPath.GetString();
#endif
        hr = pISxsConfig->SxsDirectory(pwszApplnPath);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set SxsDirectory, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        if (m_pAppConfig->szSxsName() && *m_pAppConfig->szSxsName()) {
            CMBCSToWChar    convName;

            hr = convName.Init(m_pAppConfig->szSxsName());
            if (FAILED(hr)) {
    		    DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not convert SxsName to UNICODE, hr = %#08x\n", hr));
	    	    goto LCleanup;
            }
            
            hr = pISxsConfig->SxsName(convName.GetString());
            if (FAILED(hr)) {
		        DBGWARN((DBG_CONTEXT, "New Application Failed: InitServicesConfig() - Could not set SxsName, hr = %#08x\n", hr));
		        goto LCleanup;
            }
        }
    }

LCleanup:

    if (pIThreadPool)
        pIThreadPool->Release();
           
    if (pISyncConfig)
        pISyncConfig->Release();
           
    if (pIPartitionConfig)
        pIPartitionConfig->Release();
           
    if (pISxsConfig)
        pISxsConfig->Release();

    return hr;
}

/*===================================================================
CAppln::Restart

Restart an application. (used for when global.asa changes or
debugging enable metabase key changes)
===================================================================*/
HRESULT CAppln::Restart(BOOL  fForceRestart /* = FALSE*/)
    {
    AddRef();  // keep addref'd while restarting

    DBGPRINTF((DBG_CONTEXT, "Restarting  application %S, %p\n", m_pszMetabaseKey, this));
    
    g_ApplnMgr.Lock();

    // If   already restarted or
    //      in the tombstone state or
    //      restart not allowed
    //      shutting down -> don't restart
    if (m_fGlobalChanged || 
        m_fTombstone || 
        (!m_pAppConfig->fEnableApplicationRestart() && !fForceRestart) ||
        IsShutDownInProgress())
        {
        // Give back the lock and refcount
        // since we don't need them
        g_ApplnMgr.UnLock();
        Release();
        return S_OK;
        }

    // remove the application from the global hash

    CLinkElem *pLinkElem = g_ApplnMgr.DeleteElem
        (
        m_pszMetabaseKey,
        _tcslen(m_pszMetabaseKey) * sizeof(TCHAR)
        );
    Assert(pLinkElem);
    Assert(static_cast<CAppln *>(pLinkElem) == this);

    // Unlock
    g_ApplnMgr.UnLock();

    // Indicate to Delete All Sessions
    m_fGlobalChanged = TRUE;

    // Increment the count of restarting applications
    InterlockedIncrement((LPLONG)&g_nApplicationsRestarting);

    // Increment the count of restarted applications
    InterlockedIncrement((LPLONG)&g_nApplicationsRestarted);

    m_pSessionMgr->UnScheduleSessionKiller();

    // cleanup the directory monitor entries

    if (FIsWinNT())
    {
        Lock(); // Place critical Section around access to m_rgpvDME
        while ((m_rgpvDME).Count())
        {
            static_cast<CDirMonitorEntry *>(m_rgpvDME[0])->Release();
            (m_rgpvDME).Remove(0);
        }
        m_rgpvDME.Clear();
        UnLock();
    }

    // add this application to the CleanupManager...
    g_ApplnCleanupMgr.AddAppln(this);

    return S_OK;
}

/*===================================================================
CAppln::ApplnCleanupProc

Called by the g_ApplnCleanupMgr thread to complete cleanup

===================================================================*/
DWORD __stdcall CAppln::ApplnCleanupProc(VOID  *pArg)
{
    CAppln *pAppln = (CAppln *)pArg;

    DBGPRINTF((DBG_CONTEXT, "[ApplnCleanupProc] enterred for %S, %p\n", pAppln->m_pszMetabaseKey, pArg));
    
    // Let the requests to drain while trying to delete sessions
    while (!IsShutDownInProgress() && (pAppln->m_cRequests || pAppln->m_cSessions))
        {
        if (pAppln->m_cSessions)
            pAppln->m_pSessionMgr->DeleteAllSessions(FALSE);

        if (pAppln->m_cSessions || pAppln->m_cRequests)
            Sleep(200);
        }

    g_ApplnMgr.DeleteApplicationIfExpired(pAppln);

    // Decrement the count of restarting applications
    InterlockedDecrement((LPLONG)&g_nApplicationsRestarting);

    // Decrement the count of restart threads
    InterlockedDecrement(&g_nAppRestartThreads);

    // tell the cleanup manager to check for more work
    g_ApplnCleanupMgr.Wakeup();

    pAppln->Release();

    return 0;
}

/*===================================================================
CAppln::UnInit

Convert to tombstone state

Parameters:
    NONE

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CAppln::UnInit()
    {
    Assert(!m_fTombstone);  // don't do it twice

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Uniniting  application %S, %p\n", m_pszApplnPath, this));
#else
    DBGPRINTF((DBG_CONTEXT, "Uniniting  application %s, %p\n", m_pszApplnPath, this));
#endif
#endif // DBG_NOTIFICATION

    // Flush the global.asa from the script engine cache
    if (m_pszGlobalAsa)
        {
        g_ScriptManager.FlushCache(m_pszGlobalAsa);
        }

    if (m_pGlobalTemplate)
        {
        // Keep template (and inc file) cache locked while releasing
        // GLOBAL.ASA template so that it wouldn't step onto Flush logic
        //
        // NOTE: CTemplate::End potentially queues global.asa for cleanup on
        //       our thread!  CleanupEngines() must therefore be called
        //       *after* this step.
        //
        LockTemplateAndIncFileCaches();
        m_pGlobalTemplate->End();
        UnLockTemplateAndIncFileCaches();

        m_pGlobalTemplate = NULL;
        }

    //If NT, remove this app from any file/appln mappings it may be in
    if (FIsWinNT())
        {
        g_FileAppMap.Lock();
        int i = m_rgpvFileAppln.Count();
        while (i > 0)
            {

            #ifdef DBG_NOTIFICATION
            DBGPRINTF((DBG_CONTEXT, "Removing application from File/App mapping\n"));
            #endif // DBG_NOTIFICATION

            static_cast<CFileApplnList *>(m_rgpvFileAppln[0])->RemoveApplication(this);
            m_rgpvFileAppln.Remove(0);
            i--;
            }
        g_FileAppMap.UnLock();
        m_rgpvFileAppln.Clear();

        Lock(); // Protecting m_rqpvDME with a critical section
        m_rgpvDME.Clear();
        UnLock();

        // If debuggable application, clean up pending scripts
        if (m_fDebuggable)
            g_ApplnMgr.CleanupEngines();
        }

    // Free the properties collection
    if (m_pProperties)
        {
        m_pProperties->UnInit();
        m_pProperties->Release();
        m_pProperties = NULL;
        }

    // Free the tagged objects collection
    if (m_pTaggedObjects)
        {
        m_pTaggedObjects->UnInit();
        m_pTaggedObjects->Release();
        m_pTaggedObjects = NULL;
        }

    // Before we close down, debuggable templates need to be made non-debuggable
    if (m_fDebuggable)
        g_TemplateCache.RemoveApplicationFromDebuggerUI(this);

    if (m_pAppRoot)
        {
        m_pAppRoot->Detach();
        m_pAppRoot->Close();
        m_pAppRoot->Release();
        m_pAppRoot = NULL;
        }

    if (m_pApplCompCol)
        {
        delete m_pApplCompCol;
        m_pApplCompCol = NULL;
        }

    if (m_pActivity)
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    if (m_pSessionMgr)
        {
        delete m_pSessionMgr;
        m_pSessionMgr = NULL;
        }

    if (m_pAppConfig)
        {
        /*
         * BUG 89144: Uninit AppConfig but do it from the MTA
         * When AppConfig is inited, it is done on a WAM thread.  WAM
         * threads are MTA threads.  At that time we register an event
         * sink to get Metabase change notifications.  Now, during shutdown,
         * we are running on an ASP worker thread, which is an STA thread.
         * That means we will get an RPC_E_WRONGTHREAD error shutting down.  The
         * fix is to make the uninit call happen on an MTA thread.
         */
        HRESULT hr;
        HRESULT AppConfigUnInit(void *pV1, void *pV2);

		HANDLE hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hr = CallMTACallback
            (
            AppConfigUnInit,
            m_pAppConfig,
            hCompletionEvent
            );
        Assert(SUCCEEDED(hr));
		WaitForSingleObject(hCompletionEvent, INFINITE);

		CloseHandle(hCompletionEvent);
        delete m_pAppConfig;
        m_pAppConfig = NULL;
        }

    if (m_pdispGlobTypeLibWrapper)
        {
        m_pdispGlobTypeLibWrapper->Release();
        m_pdispGlobTypeLibWrapper = NULL;
        }

    if (m_pszGlobalAsa)
        {
        // If there was a change notification on global.asa
        // then flush the template now.
        // UNDONE: flush correct global.asa
        if (m_fGlobalChanged)
            g_TemplateCache.Flush(m_pszGlobalAsa, MATCH_ALL_INSTANCE_IDS);

        delete [] m_pszGlobalAsa;
        m_pszGlobalAsa = NULL;
        }

    if (m_pszMetabaseKey)
        {
        delete [] m_pszMetabaseKey;
        m_pszMetabaseKey = NULL;
        }

    if (m_pszApplnPath)
        {
        delete [] m_pszApplnPath;
        m_pszApplnPath = NULL;
        }

    if (m_pszApplnVRoot)
        {
        delete [] m_pszApplnVRoot;
        m_pszApplnVRoot = NULL;
        }

    if (FIsWinNT() && m_fUseImpersonationHandle)
        {
        CloseHandle(m_hUserImpersonation);
        m_hUserImpersonation = NULL;
        }

    if (m_fInited)
        {
        DeleteCriticalSection(&m_csInternalLock);
        DeleteCriticalSection(&m_csApplnLock);
        }

    if (m_pServicesConfig)
        m_pServicesConfig->Release();

    // Mark this application as Tombstone

    m_fTombstone = TRUE;

    InterlockedDecrement((LPLONG)&g_nApplications);

	// Disconnennect from proxies (in case we are shutting down or will shortly shut down)

	CoDisconnectObject(static_cast<IApplicationObject *>(this), 0);

    return S_OK;
    }

/*===================================================================
CAppln::BindToActivity

Creates application level activity either
    as a clone of the given activity or
    as a brand new activity

Must be called within critical section. Does not lock itself.

Parameters:
    CViperActivity *pActivity       activity to clone (could be NULL)

Returns:
    NONE
===================================================================*/
HRESULT CAppln::BindToActivity
(
CViperActivity *pActivity
)
    {
    if (m_pActivity)
        {
        // multiple requests to bind to new activity are ok
        if (!pActivity)
            return S_OK;
        // but not to clone from an existing activity
        Assert(FALSE);
        return E_FAIL;
        }

    m_pActivity = new CViperActivity;
    if (!m_pActivity)
        return E_OUTOFMEMORY;

    HRESULT hr;

    if (pActivity)
        hr = m_pActivity->InitClone(pActivity);
    else
        hr = m_pActivity->Init(m_pServicesConfig);

    if (FAILED(hr))
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    return hr;
    }

/*===================================================================
CAppln::SetGlobalAsa

Remembers GLOBAL.ASA file path for this application

Parameters:
    const char *pszGlobalAsa    path to (copy and) remember

Returns:
    HRESULT
===================================================================*/
HRESULT CAppln::SetGlobalAsa
(
const TCHAR *pszGlobalAsa
)
    {
    // remove existing
    if (m_pszGlobalAsa)
        {
        delete [] m_pszGlobalAsa;
        m_pszGlobalAsa = NULL;
        }

    // store new
    if (pszGlobalAsa)
        {
        DWORD cch = _tcslen(pszGlobalAsa);
        DWORD cb = (cch + 1) * sizeof(TCHAR);

        m_pszGlobalAsa = new TCHAR[cch+1];
        if (!m_pszGlobalAsa)
            return E_OUTOFMEMORY;

        memcpy(m_pszGlobalAsa, pszGlobalAsa, cb);
        }

    return S_OK;
    }

/*===================================================================
CAppln::AddDirMonitorEntry

Remembers change notifcation monitor entries for this application

Parameters:
    pDirMonitorEntry    pointer to DME

Returns:
    S_OK if the monitor entry was added to the list
===================================================================*/
HRESULT CAppln::AddDirMonitorEntry(CDirMonitorEntry *pDirMonitorEntry)
    {
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pDirMonitorEntry);

    HRESULT hr = S_OK;

   // Add the DME to the list
   Lock(); // Protect m_rgpvDME by critical section
   if (FAILED(hr = m_rgpvDME.Append(pDirMonitorEntry)))
        {
        pDirMonitorEntry->Release();
        }
   UnLock();
    return hr;

    }

/*===================================================================
CAppln::AddFileApplnEntry

Remembers change notifcation monitor entries for this application

Parameters:
    pFileAppln    pointer to FileApplnEntry

Returns:
    S_OK if the monitor entry was added to the list
    S_FALSE if the monitor entry was alread in the list
===================================================================*/
HRESULT CAppln::AddFileApplnEntry(CFileApplnList *pFileAppln)
    {
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pFileAppln);

    HRESULT hr = S_OK;
    int index;

    // See if the file/application entry is alreay in the list
    hr = m_rgpvFileAppln.Find(pFileAppln, &index);
    if (hr == S_FALSE)
        {
       // Add the file/application entry to the list
       hr = m_rgpvFileAppln.Append(pFileAppln);
        }
    else
        {
        // The file/application entry was already in the list
        hr = S_FALSE;
        }
    return hr;

    }

/*===================================================================
CAppln::QueryInterface

QueryInterface() -- IApplicationObject implementation.

Parameters:
    REFIID riid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CAppln::QueryInterface
(
REFIID riid,
void **ppv
)
    {
    *ppv = NULL;

    if (IID_IUnknown           == riid ||
        IID_IDispatch          == riid ||
        IID_IApplicationObject == riid ||
        IID_IDenaliIntrinsic   == riid)
        {
        *ppv = static_cast<IApplicationObject *>(this);
        }
    else if (IID_ISupportErrorInfo == riid)
        {
        *ppv = &m_ISuppErrImp;
        }
    else if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this); 
        }
    if (*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }

/*===================================================================
CAppln::AddRef

AddRef() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CAppln::AddRef() {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);
    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }
    return cRefs;
}

/*===================================================================
CAppln::Release

Release() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CAppln::Release()
    {
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    IF_DEBUG(APPLICATION) {
		WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CAppln::CheckForTombstone

Tombstone stub for IApplicationObject methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CAppln::CheckForTombstone()
    {
    if (!m_fTombstone)
        return S_OK;

    ExceptionId
        (
        IID_IApplicationObject,
        IDE_APPLICATION,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }
/*===================================================================
CAppln::Lock

IApplicationObject method.

Will allow the user to lock the application intrinsic for the
purpose of adding/deleting values.

Parameters:
    NONE

Returns:
    HRESULT        S_OK on success
                E_FAIL otherwise
===================================================================*/
STDMETHODIMP CAppln::Lock()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    Assert(m_fInited);

    DWORD dwId = GetCurrentThreadId();

    // If this thread already has the lock, increment lock ref count

    if (m_dwLockThreadID == dwId)
        {
        m_cLockRefCount++;
        }
    else
        {
        EnterCriticalSection(&m_csApplnLock);
        m_cLockRefCount = 1;
        m_dwLockThreadID = dwId;
        }

    return S_OK;
    }

/*===================================================================
CAppln::UnLock

IApplicationObject method.

Will allow the user to unlock the application intrinsic only
if it has been locked by this user.

Parameters:
    NONE

Returns:
    HRESULT        S_OK
===================================================================*/
STDMETHODIMP CAppln::UnLock()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_dwLockThreadID == GetCurrentThreadId())
        {
        if (--m_cLockRefCount == 0)
            {
            // Unlock the application
            m_dwLockThreadID = INVALID_THREADID;
            LeaveCriticalSection(&m_csApplnLock);
            }
        }

    return S_OK;
    }

/*===================================================================
CAppln::UnLockAfterRequest

Remove any application locks left by the user script

Parameters:
    NONE

Returns:
    HRESULT        S_OK
===================================================================*/
HRESULT CAppln::UnLockAfterRequest()
    {
    Assert(!m_fTombstone);

    if (m_cLockRefCount > 0 && m_dwLockThreadID == GetCurrentThreadId())
        {
        m_cLockRefCount = 0;
        m_dwLockThreadID = INVALID_THREADID;
        LeaveCriticalSection(&m_csApplnLock);
        }
    return S_OK;
    }

/*===================================================================
CAppln::get_Value

IApplicationObject method.

Will allow the user to retreive a application state variable,
the variable will come as a named pair, bstr is the name and
var is the value or object to be returned for that name

Parameters:
    BSTR FAR *     bstrName    Name of the variable to get
    VARIANT *    pVar         Value/object to get for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::get_Value
(
BSTR bstrName,
VARIANT *pVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    VariantInit(pVar); // default variant empty

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        return S_OK; // no name - no value - no error
    //_wcsupr(pwszName);

    Assert(m_pApplCompCol);

    HRESULT           hr   = S_OK;
    CComponentObject *pObj = NULL;

    // Lock the application
    Lock();

    hr = m_pApplCompCol->GetProperty(pwszName, &pObj);

    if (SUCCEEDED(hr))
        {
        Assert(pObj);
        hr = pObj->GetVariant(pVar);
        }

    // UnLock the application
    UnLock();

    return S_OK;
    }

/*===================================================================
CAppln::putref_Value

IApplicationObject method.

Will allow the user to assign a application state variable to be saved
the variable will come as a named pair, bstr is the name and
var is the value or object to be stored for that name

Parameters:
    BSTR     bstrName    Name of the variable to set
    VARIANT Var            Value/object to set for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::putref_Value
(
BSTR bstrName,
VARIANT Var
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FIsIntrinsic(&Var))
        {
        ExceptionId(IID_IApplicationObject, IDE_APPLICATION,
                    IDE_APPLICATION_CANT_STORE_INTRINSIC);
        return E_FAIL;
        }

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    HRESULT hr;

    Assert(m_pApplCompCol);

    // Prepare property name
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }
    //_wcsupr(pwszName);

    // Lock the application
    Lock();

    hr = m_pApplCompCol->AddProperty(pwszName, &Var);

    // Unlock the application
    UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    return hr;
    }

/*===================================================================
CAppln::put_Value

IApplicationObject method.

Implement property put by dereferencing variants before
calling putref.

Parameters:
    BSTR FAR *     bstrName    Name of the variable to set
    VARIANT     Var            Value/object to set for the variable

Returns:
    HRESULT        S_OK on success
===================================================================*/
STDMETHODIMP CAppln::put_Value
(
BSTR bstrName,
VARIANT Var
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    HRESULT hr;

    Assert(m_pApplCompCol);

    // Prepare property name
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

    if (pwszName == NULL)
        {
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_EXPECTING_STR);
        return E_FAIL;
        }
    //_wcsupr(pwszName);

    // Lock the application
    Lock();

    VARIANT varResolved;
    hr = VariantResolveDispatch(&varResolved, &Var,
                                IID_IApplicationObject,
                                IDE_APPLICATION);
    if (SUCCEEDED(hr))
        {
        hr = m_pApplCompCol->AddProperty(pwszName, &varResolved);
        VariantClear(&varResolved);
        }

    // Unlock the application
    UnLock();

    if (hr == RPC_E_WRONG_THREAD)
        {
        // We use RPC_E_WRONG_THREAD to indicate bad model object
        ExceptionId(IID_IApplicationObject,
                    IDE_APPLICATION, IDE_APPLICATION_CANT_STORE_OBJECT);
         hr = E_FAIL;
        }

    return hr;
    }

/*===================================================================
CAppln::get_Contents

Return the application contents dictionary
===================================================================*/

STDMETHODIMP CAppln::get_Contents(IVariantDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()) || !m_pProperties)
        return E_FAIL;

    return m_pProperties->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

/*===================================================================
CAppln::get_StaticObjects

Return the application static objects dictionary
===================================================================*/
STDMETHODIMP CAppln::get_StaticObjects(IVariantDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()) || !m_pTaggedObjects)
        return E_FAIL;

    return m_pTaggedObjects->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

/*===================================================================
CAppln::UpdateConfig

Updates configuration from metabase if needed
===================================================================*/
HRESULT CAppln::UpdateConfig(CIsapiReqInfo  *pIReq, BOOL *pfRestart, BOOL *pfFlushAll)
    {
    BOOL fRestart = FALSE;
    BOOL fFlushAll = FALSE;

    if (m_pAppConfig->fNeedUpdate())
        {
        InternalLock();

        if (m_pAppConfig->fNeedUpdate()) // still need update?
            {
            BOOL fAllowedDebugging   = m_pAppConfig->fAllowDebugging();
            BOOL fAllowedClientDebug = m_pAppConfig->fAllowClientDebug();
            BOOL fAllowedRestart     = m_pAppConfig->fEnableApplicationRestart();
            BOOL fParentPathsEnabled = m_pAppConfig->fEnableParentPaths();
            UINT uLastCodePage       = m_pAppConfig->uCodePage();
            LCID uLastLCID           = m_pAppConfig->uLCID();
            BOOL fPrevSxsEnabled     = m_pAppConfig->fSxsEnabled();
            BOOL fPrevUsePartition   = m_pAppConfig->fUsePartition();
            BOOL fPrevUseTracker     = m_pAppConfig->fTrackerEnabled();

            BOOL fRestartEnabledUpdated = m_pAppConfig->fRestartEnabledUpdated();
			char szLastDefaultEngine[64];
			strncpy(szLastDefaultEngine, m_pAppConfig->szScriptLanguage(), sizeof szLastDefaultEngine);
			szLastDefaultEngine[sizeof(szLastDefaultEngine) - 1] = '\0';

            m_pAppConfig->Update(pIReq);

            BOOL fAllowDebugging     = m_pAppConfig->fAllowDebugging();
            BOOL fAllowClientDebug   = m_pAppConfig->fAllowClientDebug();
            BOOL fAllowRestart       = m_pAppConfig->fEnableApplicationRestart();
            BOOL fEnableParentPaths  = m_pAppConfig->fEnableParentPaths();
            UINT uCodePage           = m_pAppConfig->uCodePage();
            LCID uLCID               = m_pAppConfig->uLCID();
            BOOL fCurSxsEnabled      = m_pAppConfig->fSxsEnabled();
            BOOL fCurUsePartition    = m_pAppConfig->fUsePartition();
            BOOL fCurUseTracker      = m_pAppConfig->fTrackerEnabled();

			const char *szNewDefaultEngine = m_pAppConfig->szScriptLanguage();

            fFlushAll = strcmpi(szLastDefaultEngine, szNewDefaultEngine) != 0
                        || (fParentPathsEnabled != fEnableParentPaths)
                        || (uLastCodePage != uCodePage)
                        || (uLastLCID != uLCID);
            
            fRestart = (fAllowDebugging != fAllowedDebugging) ||
                       (fAllowClientDebug != fAllowedClientDebug) ||
                       ((fAllowRestart  != fAllowedRestart) && fAllowRestart) ||
                       ((fAllowRestart == fAllowedRestart) && fRestartEnabledUpdated) ||
                       (fCurSxsEnabled != fPrevSxsEnabled) ||
                       (fCurUsePartition != fPrevUsePartition) ||
                       (fCurUseTracker != fPrevUseTracker) ||
                       fFlushAll;
            }

        InternalUnLock();
        }

    if (pfRestart)
        *pfRestart = fRestart;

    if (pfFlushAll)
        *pfFlushAll = fFlushAll;

    return S_OK;
    }

/*===================================================================
CAppln::FPathMonitored()

Checks the list of DMEs in application to see if the specified path
is already being monitored.

===================================================================*/
CASPDirMonitorEntry  *CAppln::FPathMonitored(LPCTSTR  pszPath)
{
    int i;

    Lock(); // Protect m_rqpvDME by a critical section
    int cDMEs = m_rgpvDME.Count();
    for (i=0; i < cDMEs; i++) {
        CASPDirMonitorEntry  *pDME = static_cast<CASPDirMonitorEntry *>(m_rgpvDME[i]);
        if (pDME == NULL)
            break;
        if (pDME->FPathMonitored(pszPath))
        {
            UnLock();
            return pDME;
        }
    }

    UnLock();
    return NULL;
}

#ifdef DBG
/*===================================================================
CAppln::AssertValid

Test to make sure that the CAppln object is currently correctly
formed and assert if it is not.

Returns:
    Nothing

Side effects:
    None.
===================================================================*/
void CAppln::AssertValid() const
    {
    Assert(m_fInited);

    Assert(m_pSessionMgr);

    Assert(m_pApplCompCol);
    m_pApplCompCol->AssertValid();
    }
#endif // DBG


/*===================================================================
  C  A p p l n  M g r
===================================================================*/

/*===================================================================
CApplnMgr::CApplnMgr

Application Manager constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnMgr::CApplnMgr()
    : m_fInited(FALSE),
      m_fHashTableInited(FALSE), m_fCriticalSectionInited(FALSE)
    {
    }

/*===================================================================
CApplnMgr::~CApplnMgr

Application Manager destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnMgr::~CApplnMgr()
    {
    if (!m_fInited)
        UnInit();
    }

/*===================================================================
HRESULT CApplnMgr::Init

Initializes the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnMgr::Init( void )
    {
    HRESULT hr = S_OK;

    Assert(!m_fInited);

    // Init hash table

    hr = CHashTable::Init(NUM_APPLMGR_HASHING_BUCKETS);
    if (FAILED(hr))
        return hr;
    m_fHashTableInited = TRUE;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
    m_fCriticalSectionInited = TRUE;

    m_fInited = TRUE;

    return g_ApplnCleanupMgr.Init();
    }

/*===================================================================
HRESULT CApplnMgr::UnInit

UnInitializes the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/
HRESULT CApplnMgr::UnInit( void )
    {
    if (m_fHashTableInited)
        {
        CHashTable::UnInit();
        m_fHashTableInited = FALSE;
        }

    if (m_fCriticalSectionInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
        }

    m_fInited = FALSE;
    return g_ApplnCleanupMgr.UnInit();
    }

/*===================================================================
CApplnMgr::AddAppln

Adds a CAppln element to link list / hash table.
User has to check if Appln already exists before calling this.
Critical sectioning is in CHitObj::BrowserRequestInit().

Parameters:
    char   *pszApplnKey         Application metabase key
    char   *pszApplnPath        Application directory path
    CIsapiReqInfo   *pIReq
    HANDLE  hUserImpersonation  impersonation handle

    CAppln **ppAppln            [out] Application created

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::AddAppln
(
TCHAR    *pszApplnKey,
TCHAR    *pszApplnPath,
CIsapiReqInfo   *pIReq,
HANDLE   hUserImpersonation,
CAppln **ppAppln
)
    {
    *ppAppln = NULL;   // return NULL if failed

    // Create CAppln object

    CAppln *pAppln = new CAppln;

    if (!pAppln)
        return E_OUTOFMEMORY;

    // Init CAppln object

    HRESULT hr;

    hr = pAppln->Init
        (
        pszApplnKey,
        pszApplnPath,
        pIReq,
        hUserImpersonation
        );

    if (FAILED(hr))
        {
        pAppln->UnInit();
        pAppln->Release();
        return hr;
        }

    // Add to hash table

    if (!CHashTable::AddElem(pAppln))
        {
        pAppln->UnInit();
        pAppln->Release();
        return E_FAIL;
        }

    *ppAppln = pAppln;
    return S_OK;
    }

/*===================================================================
CApplnMgr::FindAppln

Finds CAppln in hash table
Critical sectioning must be done outside

Parameters:
    char   *pszApplnKey         Application metabase key
    CAppln **ppAppln            [out] Application found

Returns:
    S_OK            if found
    S_FALSE         if not found
===================================================================*/
HRESULT CApplnMgr::FindAppln
(
TCHAR *pszApplnKey,
CAppln **ppAppln
)
    {
    CLinkElem *pLinkElem = CHashTable::FindElem
        (
        pszApplnKey,
        _tcslen(pszApplnKey)*sizeof(TCHAR)
        );

    if (!pLinkElem)
        {
        *ppAppln = NULL;
        return S_FALSE;
        }

    *ppAppln = static_cast<CAppln *>(pLinkElem);
    return S_OK;
    }

/*===================================================================
CApplnMgr::AddEngine

When a change notification occurs for a file being debugged,
we need to delete its associated scripting engine.  The naive
approach of Releasing the engine during notification won't work
because the engine is on the wrong thread.  Instead of marshaling
to the thread (which raises possibilities of deadlock or starving
the notification thread if debugging is happening on the debug
thread), the engines are added to a queue in the application.
When a request is serviced for debugging (which is now in the
correct thread context), the application object first flushes
this list by releasing the engines
===================================================================*/
HRESULT CApplnMgr::AddEngine(CActiveScriptEngine *pEngine)
    {
    CScriptEngineCleanupElem *pScriptElem = new CScriptEngineCleanupElem(pEngine);
    if (pScriptElem == NULL)
        return E_OUTOFMEMORY;

    pScriptElem->AppendTo(m_listEngineCleanup);
    return S_OK;
    }

/*===================================================================
CApplnMgr::CleanupEngines()

Call Release all engine cleanup list.
===================================================================*/
void CApplnMgr::CleanupEngines()
    {
    while (! m_listEngineCleanup.FIsEmpty())
        delete m_listEngineCleanup.PNext();
    }


/*===================================================================
CApplnMgr::DeleteApplicationIfExpired

Removes CAppln object if exprired
Critical sectioning must be done outside

Parameters:
    CAppln *pAppln      application to delete

Returns:
    NONE
===================================================================*/
HRESULT CApplnMgr::DeleteApplicationIfExpired
(
CAppln *pAppln
)
    {
    if (!pAppln->m_fGlobalChanged)
        return S_OK;

    if (pAppln->m_cSessions || pAppln->m_cRequests)
        return S_OK;

    if (pAppln->m_fDeleteInProgress)
        return S_OK;

    pAppln->m_fDeleteInProgress = TRUE;

    HRESULT hr = S_OK;

    // Queue it up for deletion
    CHitObj *pHitObj = new CHitObj;
    if (!pHitObj)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        pHitObj->ApplicationCleanupInit(pAppln);

        // Ask Viper to queue this request
        hr = pHitObj->PostViperAsyncCall();
        }

    // cleanup
    if (FAILED(hr) && pHitObj)
        delete pHitObj;

    return hr;
    }

/*===================================================================
CApplnMgr::DeleteAllApplications

Removes CAppln objects from the application manager link list
and hash table.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::DeleteAllApplications()
    {
    HRESULT hr = S_OK;

    Lock();

    CLinkElem *pLink = CHashTable::Head();
    CHashTable::ReInit();

    while (pLink)
        {
        CAppln *pAppln = static_cast<CAppln *>(pLink);
        pLink = pLink->m_pNext;

        if (pAppln->m_fDeleteInProgress)
            continue;

        pAppln->m_fDeleteInProgress = TRUE;


        // Queue it up for deletion
        CHitObj *pHitObj = new CHitObj;
        if (!pHitObj)
            {
            hr = E_OUTOFMEMORY;
            break;
            }

        // If NT, Unregister for notifications
        if (FIsWinNT())
            {
            while ((pAppln->m_rgpvDME).Count())
                {
                static_cast<CDirMonitorEntry *>(pAppln->m_rgpvDME[0])->Release();
                (pAppln->m_rgpvDME).Remove(0);
                }
            pAppln->m_rgpvDME.Clear();
            }

        pHitObj->ApplicationCleanupInit(pAppln);

        // Ask Viper to queue this request
        hr = pHitObj->PostViperAsyncCall();
        if (FAILED(hr))
            {
            delete pHitObj;
            break;
            }

        }

    UnLock();
    return hr;
    }

/*===================================================================
CApplnMgr::RestartAllChagnedApplications

Restarts CAppln objects from the application manager link list
We walk the list recording which applications are dependent
on files that have changed since they were compiled. Once we
have the list, we restart each of the applications.

This is a fall back when we may have missed a change notification,
for instance when we had insufficient buffer to record all the changes
that occured.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnMgr::RestartApplications(BOOL fRestartAllApplications)
    {
    HRESULT hr = S_OK;

    Lock();

    CLinkElem *pLink = CHashTable::Head();

    // Find out which applications need restarting

    while (pLink)
    {
        CAppln *pAppln = static_cast<CAppln *>(pLink);
        pLink = pLink->m_pNext;
        if (!pAppln->FTombstone() && (fRestartAllApplications || (pAppln->m_pGlobalTemplate != NULL && pAppln->m_pGlobalTemplate->FTemplateObsolete())))
        {
            pAppln->Restart();
        }
    }

    UnLock();

    return hr;
}

/*===================================================================
  C  A p p l n  C l e a n u p  M g r
===================================================================*/

/*===================================================================
CApplnMgr::CApplnCleanupMgr

Application Cleanup Manager constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnCleanupMgr::CApplnCleanupMgr()
    : m_fInited(FALSE),
      m_fCriticalSectionInited(FALSE),
      m_fThreadAlive(FALSE),
      m_hAppToCleanup(INVALID_HANDLE_VALUE)
    {
    m_List.m_pPrev = &m_List;
    m_List.m_pNext = &m_List;
    }

/*===================================================================
CApplnCleanupMgr::~CApplnCleanupMgr

Application Cleanup Manager destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CApplnCleanupMgr::~CApplnCleanupMgr()
    {
    UnInit();
    }

/*===================================================================
HRESULT CApplnCleanupMgr::Init

Initializes the Appln Cleanup Manager.

Parameters:
    NONE

Returns:
    S_OK            Success
    E_FAIL            Failure
    E_OUTOFMEMORY    Out of memory
===================================================================*/
HRESULT CApplnCleanupMgr::Init( void )
    {
    HRESULT hr = S_OK;

    Assert(!m_fInited);

    // Create delete app event

    m_hAppToCleanup = IIS_CREATE_EVENT(
                              "CApplnCleanupMgr::m_hAppToCleanup",
                              this,
                              FALSE,
                              FALSE
                              );

    if (!m_hAppToCleanup)
        return E_FAIL;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
    m_fCriticalSectionInited = TRUE;

    HANDLE  hThread = CreateThread(NULL, 0, CApplnCleanupMgr::ApplnCleanupThread, 0, 0, NULL);

    if (!hThread) {
        return E_FAIL;
    }

    CloseHandle(hThread);

    m_fInited = TRUE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnCleanupMgr::UnInit

UnInitializes the Appln Cleanup Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/
HRESULT CApplnCleanupMgr::UnInit( void )
{
    // set fInited to FALSE here so that the cleanup thread
    // can safely detect that we're shutting down.

    m_fInited = FALSE;

    if (m_hAppToCleanup != INVALID_HANDLE_VALUE) {
        // Set the event one last time so that the thread
        // wakes up, sees that shutdown is occurring and
        // exits.
        SetEvent(m_hAppToCleanup);
        CloseHandle(m_hAppToCleanup);
        m_hAppToCleanup = INVALID_HANDLE_VALUE;
    }

    // we'll wait for the thread to finish its work

    while(m_fThreadAlive) {
        Sleep(200);
    }

    if (m_fCriticalSectionInited) {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
    }

    return S_OK;
}

/*===================================================================
CApplnCleanupMgr::AddAppln

Adds a CAppln element to link list / hash table.


Parameters:
    CAppln *pAppln            Application to cleanup

Returns:
    HRESULT
===================================================================*/
HRESULT CApplnCleanupMgr::AddAppln
(
CAppln *pAppln
)
{
    HRESULT     hr = S_OK;

#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Adding App (%S)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#else
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Adding App (%s)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#endif

    Lock();

    AddElem(pAppln);

    UnLock();

    if (SUCCEEDED(hr)) {
        Wakeup();
    }

    return hr;
}

/*===================================================================
CApplnCleanupMgr::ApplnCleanupThread

The thread that does the work to cleanup applications

Parameters:

Returns:
    HRESULT
===================================================================*/
DWORD __stdcall CApplnCleanupMgr::ApplnCleanupThread(VOID  *pArg)
{
    g_ApplnCleanupMgr.ApplnCleanupDoWork();

    return 0;
}

/*===================================================================
CApplnCleanupMgr::ApplnCleanupDoWork

Proc that actually does the work

Parameters:

Returns:
    HRESULT
===================================================================*/
void CApplnCleanupMgr::ApplnCleanupDoWork()
{
    m_fThreadAlive = TRUE;

    // this thread will be in a constant loop checking for work

    while(1) {

        // hold the lock while in this loop.  This shouldn't hold it
        // for long as there are no long running operations in this loop.
        // If a thread can't be created and the application cleanup
        // must occur on this thread, then the lock is released.

        Lock();

        // This loop will execute while there is work and there aren't too many
        // threads active or we're in shutdown.  The theory here is that in the
        // non-shutdown case, let's not spin up more than 4 threads at a time to
        // do the cleanup.  If in shutdown, create as many threads as necessary.

        while(Head() && ((g_nAppRestartThreads < 4) || (IsShutDownInProgress()))) {

            CAppln *pAppln = static_cast<CAppln *>(Head());

            RemoveElem(Head());

#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Cleanup Thread working on (%S)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#else
    DBGPRINTF((DBG_CONTEXT, "[CApplnCleanupMgr] Cleanup Thread working on (%s)\n",pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)));
#endif

            HANDLE  hThread = CreateThread(NULL, 0, CAppln::ApplnCleanupProc, pAppln, 0, NULL);

            // failed to create a thread to do the work.  Cleanup the app right here.  
            // Unlock the cleanup manager while we are doing this.

            if (hThread == NULL) {
                UnLock();
                pAppln->ApplnCleanupProc(this);
                Lock();
            }
            else {
                InterlockedIncrement(&g_nAppRestartThreads);
                CloseHandle(hThread);
            }
        }

        UnLock();

        WaitForSingleObject(m_hAppToCleanup, INFINITE);

        // check the work queue under lock here to prevent the
        // 'if' condition below from kicking in and preventing
        // the remaining cleanup during shutdown

        Lock();
        if (Head()) {
            UnLock();
            continue;
        }
        UnLock();

        // check to see if shutdown is occurring...

        if (m_fInited == FALSE) {
            Assert(Head() == NULL);
            m_fThreadAlive = FALSE;
            return;
        }
    }

    return;
}

#define            WSTR_NULL       L"\0"

/*===================================================================
  C  A p p l n  I t e r a t o r
===================================================================*/

/*===================================================================
CApplnIterator::CApplnIterator

Constructor

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CApplnIterator::CApplnIterator()
    : m_pApplnMgr(NULL), m_pCurr(NULL), m_fEnded(FALSE)
    {
    }

/*===================================================================
CApplnIterator::~CApplnIterator

Destructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/

CApplnIterator::~CApplnIterator( void )
    {
    if (m_pApplnMgr != NULL)
        Stop();
    }

/*===================================================================
HRESULT CApplnIterator::Start

Starts iterator on the Appln Manager.

Parameters:
    CApplnMgr * pApplnMgr   Appln Manager
                            (if NULL g_ApplnManager is assumed)

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/

HRESULT CApplnIterator::Start
(
CApplnMgr *pApplnMgr
)
    {
    m_pApplnMgr = pApplnMgr ? m_pApplnMgr : &g_ApplnMgr;

    m_pApplnMgr->Lock();

    m_pCurr  = NULL;
    m_fEnded = FALSE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnIterator::Stop

Stops iterator on the Appln Manager.

Parameters:
    NONE

Returns:
    S_OK        Success
    E_FAIL        Failure
===================================================================*/

HRESULT CApplnIterator::Stop()
    {
    if (m_pApplnMgr)
        {
        m_pApplnMgr->UnLock();
        m_pApplnMgr = NULL;
        }

    m_pCurr  = NULL;
    m_fEnded = FALSE;

    return S_OK;
    }

/*===================================================================
HRESULT CApplnIterator::Next

Iterates to the next Appln.

Parameters:
    NONE

Returns:
    Appln * or NULL
===================================================================*/

CAppln *CApplnIterator::Next( void )
    {
    if (m_pApplnMgr == NULL || m_fEnded)
        return NULL;  // didn't start or already ended

    CLinkElem *pT = m_pCurr ? m_pCurr->m_pNext : m_pApplnMgr->Head();
    if (pT)
        {
        m_pCurr = static_cast<CAppln *>(pT);
        return m_pCurr;
        }

    m_fEnded = TRUE;
    return NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\asperror.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: ASPError object

File: asperror.cpp

Owner: dmitryr

This file contains the code for the implementation of 
the ASPError class.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "asperror.h"

#include "memchk.h"

/*===================================================================
CASPError::CASPError

Constructor for the empty error object

Returns:
===================================================================*/
CASPError::CASPError()
    :
    m_cRefs(1),
    m_szASPCode(NULL),
    m_lNumber(0),
    m_szSource(NULL),
    m_szFileName(NULL),
    m_lLineNumber(0),
    m_szDescription(NULL),
    m_szASPDescription(NULL),
	m_bstrLineText(NULL)
	{
	CDispatch::Init(IID_IASPError);
	}

/*===================================================================
CASPError::CASPError

Constructor for real error object given CErrInfo

Parameters
    pErrInfo        [in] copy data from there

Returns:
===================================================================*/
CASPError::CASPError(CErrInfo *pErrInfo)
    :
    m_cRefs(1),
    m_szASPCode(NULL),
    m_lNumber(0),
    m_szSource(NULL),
    m_szFileName(NULL),
    m_lLineNumber(0),
    m_szDescription(NULL),
    m_szASPDescription(NULL),
	m_bstrLineText(NULL)
	{
	CDispatch::Init(IID_IASPError);

    if (!pErrInfo)
        return;

    // Parse ASP error code and HRESULT from szErrorCode
    CHAR *szErrorCode =  StringDupA(pErrInfo->GetItem(Im_szErrorCode));
    if (szErrorCode != NULL)
        {
        CHAR *szC = strchr(szErrorCode, ':');
        if (szC)
            {
            // format "ASP XXX : HRESULT"
            szC[-1] = '\0';
            m_szASPCode = szErrorCode;
            m_lNumber = strtoul(szC+2, NULL, 16);
            }
        else if (strncmp(szErrorCode, "ASP", 3) == 0)
            {
            // format "ASP XXX"
            m_szASPCode = szErrorCode;
            m_lNumber = E_FAIL;
            }
        else
            {
            // format "HRESULT"
            m_szASPCode = NULL;
            m_lNumber = strtoul(szErrorCode, NULL, 16);
            free(szErrorCode);
            }
        }
    else
        {
        // no error description available
        m_szASPCode = NULL;
        m_lNumber = E_FAIL;
        }

    // Copy the rest
	m_szSource         = StringDupA(pErrInfo->GetItem(Im_szEngine));
	m_szFileName       = StringDupA(pErrInfo->GetItem(Im_szFileName));
	m_szDescription    = StringDupA(pErrInfo->GetItem(Im_szShortDescription));
	m_szASPDescription = StringDupA(pErrInfo->GetItem(Im_szLongDescription));

	// Get line text & column (supplies init. values if not available)
	BSTR bstrLineText;
	pErrInfo->GetLineInfo(&bstrLineText, &m_nColumn);
	m_bstrLineText = SysAllocString(bstrLineText);

    // Line number if present
	if (pErrInfo->GetItem(Im_szLineNum))
    	m_lLineNumber = atoi(pErrInfo->GetItem(Im_szLineNum));
	}

/*===================================================================
CASPError::~CASPError

Destructor

Parameters:
					
Returns:
===================================================================*/
CASPError::~CASPError()
    {
    Assert(m_cRefs == 0);  // must have 0 ref count

    if (m_szASPCode)
        free(m_szASPCode);
    if (m_szSource)
        free(m_szSource);
    if (m_szFileName)
        free(m_szFileName);
    if (m_szDescription)
        free(m_szDescription);
    if (m_szASPDescription)
        free(m_szASPDescription);
	if (m_bstrLineText)
		SysFreeString(m_bstrLineText);
    }

/*===================================================================
CASPError::ToBSTR

Produce a BSTR to be returned by get_XXX methods

Parameters:
    sz      return this string as BSTR
					
Returns:
    BSTR or NULL if FAILED
===================================================================*/
BSTR CASPError::ToBSTR(CHAR *sz)
    {
    BSTR bstr;
    if (sz == NULL || *sz == '\0')
        bstr = SysAllocString(L"");
    else if (FAILED(SysAllocStringFromSz(sz, 0, &bstr)))
        bstr = NULL;
    return bstr;
    }

/*===================================================================
CASPError::QueryInterface
CASPError::AddRef
CASPError::Release

IUnknown members for CASPError object.
===================================================================*/
STDMETHODIMP CASPError::QueryInterface(REFIID riid, VOID **ppv)
	{
	if (IID_IUnknown == riid ||	IID_IDispatch == riid || IID_IASPError == riid)
		{
		AddRef();
		*ppv = this;
		return S_OK;
		}
		
	*ppv = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CASPError::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}

STDMETHODIMP_(ULONG) CASPError::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}

/*===================================================================
CASPError::get_ASPCode
CASPError::get_Number
CASPError::get_Source
CASPError::get_FileName
CASPError::get_LineNumber
CASPError::get_Description
CASPError::get_ASPDescription

IASPError members for CASPError object.
===================================================================*/
STDMETHODIMP CASPError::get_ASPCode(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szASPCode);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_Number(long *plNumber)
    {
    *plNumber = m_lNumber;
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Category(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szSource);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_File(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szFileName);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_Line(long *plLineNumber)
    {
    *plLineNumber = m_lLineNumber;
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Column(long *pnColumn)
    {
    *pnColumn = long(m_nColumn);
    return S_OK;
    }
    
STDMETHODIMP CASPError::get_Source(BSTR *pbstrLineText)
    {
	*pbstrLineText = SysAllocString(m_bstrLineText? m_bstrLineText : L"");
	return S_OK;
    }
    
STDMETHODIMP CASPError::get_Description(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szDescription);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
    
STDMETHODIMP CASPError::get_ASPDescription(BSTR *pbstr)
    {
    *pbstr = ToBSTR(m_szASPDescription);
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\asperror.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: ASPError object

File: asperror.h

Owner: dmitryr

This file contains the definiton of the ASPError class
===================================================================*/

#ifndef _ASPERROR_H
#define _ASPERROR_H

#include "debug.h"
#include "asptlb.h"
#include "disptch2.h"
#include "memcls.h"

// forward decl
class CErrInfo; 


class CASPError : public IASPErrorImpl
	{
private:
    LONG  m_cRefs;

    CHAR *m_szASPCode;
    LONG  m_lNumber;
	int   m_nColumn;
    CHAR *m_szSource;
    CHAR *m_szFileName;
    LONG  m_lLineNumber;
    CHAR *m_szDescription;
    CHAR *m_szASPDescription;
	BSTR  m_bstrLineText;

    BSTR ToBSTR(CHAR *sz);

public:
	// default constructor for 'dummy' error
	CASPError();
	// real constructor
	CASPError(CErrInfo *pErrInfo);
	
	~CASPError();

    // IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IASPError
	STDMETHODIMP get_ASPCode(BSTR *pbstrASPCode);
	STDMETHODIMP get_Number(long *plNumber);
	STDMETHODIMP get_Category(BSTR *pbstrSource);
	STDMETHODIMP get_File(BSTR *pbstrFileName);
	STDMETHODIMP get_Line(long *plLineNumber);
	STDMETHODIMP get_Description(BSTR *pbstrDescription);
	STDMETHODIMP get_ASPDescription(BSTR *pbstrDescription);
	STDMETHODIMP get_Column(long *plColumn);
	STDMETHODIMP get_Source(BSTR *pbstrLineText);

	// Cache on per-class basis
	ACACHE_INCLASS_DEFINITIONS()
	};

#endif //_ASPERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\cachemgr.cpp ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Template Cache Manager

File: CacheMgr.cpp

Owner: DGottner

Template cache manager implementation
-----------------------------------------------------------------------------*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

CTemplateCacheManager   g_TemplateCache;
CIncFileMap             g_IncFileMap;
LONG                    g_nFlushThreads = 0;

BOOL  CTemplateCacheManager::m_fFailedToInitPersistCache = FALSE;
char  CTemplateCacheManager::m_szPersistCacheDir[MAX_PATH];

/*===================================================================
ZapTemplate

Decrement the ref. count of a template to remove it from cache.
If the template is global.asa, that's all we do because application
manager has the last reference.  Otherwise, we Release the template
by calling CTemplate::End() to also free references to it from the
debugger.

Parameters: pTemplate - template pointer to Release() from cache

Returns: new ref. count
===================================================================*/

static inline
ULONG ZapTemplate(CTemplate *pTemplate)
    {
    if (! pTemplate->FGlobalAsa())
        return pTemplate->End();

    else
        return pTemplate->Release();
    }


/*  ****************************************************************************
    CCacheManager member functions
*/

/*===================================================================
CTemplateCacheManager::CTemplateCacheManager

Parameters: N/A

Returns: N/A
===================================================================*/

CTemplateCacheManager::CTemplateCacheManager()
    {
    m_pHashTemplates = NULL;
    m_szPersistCacheDir[0] = '\0';
    m_fFailedToInitPersistCache = FALSE;
    }


/*===================================================================
CTemplateCacheManager::~CTemplateCacheManager

Parameters: N/A

Returns: N/A
===================================================================*/

CTemplateCacheManager::~CTemplateCacheManager()
    {
    }


/*===================================================================
CTemplateCacheManager::Init

Init the template cache manager - phase 1 - that which can be done
with just default values in Glob.

Parameters: None

Returns: Completion Status
===================================================================*/

HRESULT CTemplateCacheManager::Init()
    {
    HRESULT hrInit;
    ErrInitCriticalSection(&m_csUpdate, hrInit);
    if (FAILED(hrInit))
        return(hrInit);

    // allocate the initial CTemplateHashTable

    m_pHashTemplates = new CTemplateHashTable;

    return S_OK;
    }

/*  ****************************************************************************
    CTemplateCacheManager member functions
*/

/*===================================================================
CTemplateCacheManager::UnInit

Parameters: N/A

Returns: Completion status
===================================================================*/

HRESULT CTemplateCacheManager::UnInit()
{

    if (m_pHashTemplates) {
        while (! m_pHashTemplates->FMemoryTemplatesIsEmpty()) {
		    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesBegin());
		    m_pHashTemplates->RemoveTemplate(pTemplate);
		    ZapTemplate(pTemplate);
		}

        while (! m_pHashTemplates->FPersistTemplatesIsEmpty()) {
		    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->PersistTemplatesBegin());
		    m_pHashTemplates->RemoveTemplate(pTemplate);
		    ZapTemplate(pTemplate);
		}
    }
    delete m_pHashTemplates;
    m_pHashTemplates = NULL;

#ifndef PERF_DISABLE
    g_PerfData.Zero_MEMORYTEMPLCACHE();
    g_PerfData.Zero_TEMPLCACHE();
#endif
    DeleteCriticalSection(&m_csUpdate);

    // give any flush threads a chance to finish.  This is necessary
    // to prevent an AV by LKRHash.

    DWORD   maxSecondsToWait = 60;

    while (maxSecondsToWait-- && g_nFlushThreads) {
        Sleep(1000);
    }

    return S_OK;
}

/*===================================================================
CTemplateCacheManager::FindCached

    Get a template from the cache only

Parameters:
    szFile       - file to find in the cache
    ppTemplate   - [out] template object found

Returns:
    HRESULT (S_OK if found, S_FALSE if noe found)
===================================================================*/

HRESULT CTemplateCacheManager::FindCached(const TCHAR *szFile, DWORD dwInstanceID, CTemplate **ppTemplate)
    {
    Assert(IsNormalized(szFile));
    if (!ppTemplate)
    	return E_POINTER;

    LockTemplateCache();

    m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate);
    if (*ppTemplate)
        {
        if (!(*ppTemplate)->m_fReadyForUse)
            *ppTemplate = NULL;         // not ready - as if nor found
        else
            (*ppTemplate)->AddRef();    // addref inside critical section
        }

    UnLockTemplateCache();

    return *ppTemplate? S_OK : S_FALSE;
    }

/*===================================================================
CTemplateCacheManager::Load

    Get a template from the cache, or load it into cache

Parameters:
    szFile - file to load into the cache

Returns: N/A
===================================================================*/

HRESULT CTemplateCacheManager::Load(BOOL fRunGlobalAsp, const TCHAR *szFile, DWORD dwInstanceID, CHitObj *pHitObj, CTemplate **ppTemplate, BOOL *pfTemplateInCache)
    {
    HRESULT hr = S_OK;                   // return value
    HRESULT (CTemplate::*pmAction)(CHitObj *);  // do we need to compile a new template or deliver an existing one?

    Assert(IsNormalized(szFile));

    BOOL fLocked = FALSE;

    // If this is the GLOBAL.ASA we can pick up
    // template directly from the application
    if (fRunGlobalAsp && pHitObj->PAppln()->PGlobalTemplate())
        {
        *ppTemplate = pHitObj->PAppln()->PGlobalTemplate();
        }
    // see if we already have looked up the template on the I/O thread...
    else if (!fRunGlobalAsp && pHitObj->GetTemplate())
        {
        *ppTemplate = pHitObj->GetTemplate();
        pHitObj->SetTemplate(NULL);
        }
    else 
    // Otherwise we have to look for it in the cache
        {
        LockTemplateCache();
        fLocked = TRUE;
        m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate);
        }

    if (*ppTemplate != NULL)
        {
        // Template found in cache -> use it
        (*ppTemplate)->AddRef();
        *pfTemplateInCache = TRUE;

        if (fLocked)    // Global.Asa from App - no lock
            UnLockTemplateCache();

        pmAction = CTemplate::Deliver;
        }
    else
        {
        *pfTemplateInCache = FALSE;

        Assert(fLocked); // only could get here if not found in the hash table
        UnLockTemplateCache();

        // Create and init new template outside of crirical section

        CTemplate *pNewTemplate = new CTemplate;

        if (!pNewTemplate)
            hr = E_OUTOFMEMORY;

        if (SUCCEEDED(hr))
            hr = pNewTemplate->Init(pHitObj, !!fRunGlobalAsp, CTemplateKey(szFile, dwInstanceID));

        if (SUCCEEDED(hr))
            {
            LockTemplateCache();

            // Try to find if inserted by another thread
            m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), ppTemplate);

            if (*ppTemplate != NULL)
                {
                // Template found in cache -> use it
                (*ppTemplate)->AddRef();
                UnLockTemplateCache();
                pmAction = CTemplate::Deliver;
                }
            else
                {

                // since we are creating a new template, call FlushCache to make
                // sure that no script engines are cached with this name

                g_ScriptManager.FlushCache(szFile);

                // Insert the newly created template

                *ppTemplate = pNewTemplate;
                pNewTemplate = NULL; // not to be deleted later

                m_pHashTemplates->InsertTemplate(*ppTemplate);
                (*ppTemplate)->AddRef();

                if (Glob(dwScriptFileCacheSize) == 0) {
                    // This is special case when a valid template
                    // does not get added to the cache
                    // Don't attach such templates to debugger
                    (*ppTemplate)->m_fDontAttach = TRUE;
                }

                UnLockTemplateCache();

                pmAction = CTemplate::Compile;
                }
            }

        // cleanup new template if created but unused
        if (pNewTemplate)
            pNewTemplate->Release();
        }

    if (FAILED(hr))
        return hr;

    // init succeeded: compile or deliver the template, as required
    hr = ((*ppTemplate)->*pmAction)(pHitObj);

    if (pmAction == CTemplate::Compile && (*ppTemplate)->m_fDontCache)
        {
        /*  We were compiling and the compiler alerted us not to cache the failed template.
            Typically, this occurs when compile failure was caused by something other than
            bad template syntax (permissions failure, bad include file reference, etc.).

            We need to roll back to where the template did not exist.
        */

        // de-cache and release the template
        // NOTE we don't nullify template ptr, because we want ExecuteRequest to do the final release

        LockTemplateCache();
        if (m_pHashTemplates->RemoveTemplate(*ppTemplate) == LK_SUCCESS)
            ZapTemplate(*ppTemplate);
        UnLockTemplateCache();

		(*ppTemplate)->Release();
		*ppTemplate = NULL;
        }

    LockTemplateCache();

    // Remove old scripts from cache

    while (!m_pHashTemplates->FMemoryTemplatesIsEmpty()
           && (m_pHashTemplates->InMemoryTemplates() > Glob(dwScriptFileCacheSize))) {
        Assert (!m_pHashTemplates->FMemoryTemplatesIsEmpty());
        CTemplate *pOldTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesEnd());
        m_pHashTemplates->RemoveTemplate(pOldTemplate, TRUE);
        
        // flush the corresponding script engines.  But only if the template
        // is valid.

        if (pOldTemplate->FIsValid()) {
            g_ScriptManager.FlushCache(pOldTemplate->GetSourceFileName());
        }

        // Only Zap the template if it is not persisted.  The result of the above
        // call to RemoveTemplate is that the template may have been moved from the
        // memory cache to the persist cache.  In which case, the template is still
        // effectively cached.  

        if (pOldTemplate->FIsPersisted() == FALSE) {

            ZapTemplate(pOldTemplate);
        }
    }

    UnLockTemplateCache();

    // Store a pointer to the template with the application
    // if we haven't already done so
    if (SUCCEEDED(hr) && fRunGlobalAsp && pHitObj->PAppln()->PGlobalTemplate() == NULL)
        pHitObj->PAppln()->SetGlobalTemplate(*ppTemplate);

    // If we are shutting down, don't request change notification

    if (!IsShutDownInProgress())
        {
        // If running on NT, and we just compiled the template
        // register all the directories used by this template
        // for change notification
        if (FIsWinNT() && pmAction == CTemplate::Compile && SUCCEEDED(hr)) {
            if (!RegisterTemplateForChangeNotification(*ppTemplate, pHitObj->PAppln())) {
                LockTemplateCache();
                if (m_pHashTemplates->RemoveTemplate(*ppTemplate) == LK_SUCCESS)
                    ZapTemplate(*ppTemplate);
                UnLockTemplateCache();
            }

            // also create the services config object

            hr = (*ppTemplate)->CreateTransServiceConfig(pHitObj->PAppln()->QueryAppConfig()->fTrackerEnabled());
        }

        // If running on NT, this is a new application, and the template is a global.asa
        // register this application for file change notifications
        if (FIsWinNT() && SUCCEEDED(hr) && (*ppTemplate)->m_fGlobalAsa && pHitObj->FStartApplication())
            {
            RegisterApplicationForChangeNotification(*ppTemplate, pHitObj->PAppln());
            }
        }

    return hr;
    }



/*===================================================================
CTemplateCacheManager::Flush

Parameters:
    szFile - the file to remove from cache

Returns:
    None
===================================================================*/

void CTemplateCacheManager::Flush(const TCHAR *szFile, DWORD dwInstanceID)
    {
    LockTemplateAndIncFileCaches();

    Assert (IsNormalized(szFile));
    CTemplate *pTemplate;
    m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), &pTemplate);

    while (pTemplate != NULL)
        {
#ifndef PERF_DISABLE
        g_PerfData.Incr_TEMPLFLUSHES();
#endif

		m_pHashTemplates->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Don't flush engines if this is a global.asa file
        // We'll need the engines to run Application_OnEnd
        // The application will flush the engine from the cache
        // when it unints
        if (!FIsGlobalAsa(szFile))
            {
            g_ScriptManager.FlushCache(szFile);
            }

        ZapTemplate(pTemplate);

        // If wildcard was specified in Flush for Instance ID, there may be
        // more templates to remove.
        m_pHashTemplates->FindTemplate(CTemplateKey(szFile, dwInstanceID), &pTemplate);
        }

    UnLockTemplateAndIncFileCaches();
    }

/*===================================================================
CTemplateCacheManager::FlushAll

    Completely empties the template cache

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushAll(VOID)
    {
    LockTemplateAndIncFileCaches();

    CTemplateHashTable  *pNewTable = NULL;
    HANDLE              hnd;
    
    // note that all of the following logic works on the premise that any
    // error causes the code to fall into the old mechanism of flushing
    // the hash table in place...

    // allocate a new table

    if (!(pNewTable = new CTemplateHashTable));

    // Create a thread to clean up the old table

    else if (!(hnd = CreateThread(NULL, 0, CTemplateCacheManager::FlushHashTableThread, m_pHashTemplates, 0, NULL)));

    else {

        // all the above was successful, so note that the new table is the
        // current table in the cache, cleanup and exit.

        DBGPRINTF((DBG_CONTEXT, "[CTemplateCacheManager] Flushing entire cache on another thread.\n"));

        InterlockedIncrement(&g_nFlushThreads);
        m_pHashTemplates = pNewTable;
        CloseHandle(hnd);
        UnLockTemplateAndIncFileCaches();

        return;
    }

    // delete the new table if something above failed.

    if (pNewTable)
        delete pNewTable;

    DBGPRINTF((DBG_CONTEXT, "[CTemplateCacheManager] Flushing entire cache in place\n"));

    FlushHashTable(m_pHashTemplates);

    UnLockTemplateAndIncFileCaches();

    return;
}

/*===================================================================
CTemplateCacheManager::FlushHashTableThread

    Thread spun up by CTemplateCacheMgr::FlushAll() to flush all
    templates in the cache but not while under the critical section
    on the notification thread.  Prevents unwanted contention on the
    cache.

Parameters:
    None

Returns:
    None
===================================================================*/

DWORD CTemplateCacheManager::FlushHashTableThread(VOID  *pArg)
{
    CTemplateHashTable  *pTable = (CTemplateHashTable *)pArg;

    Assert(pTable);

    FlushHashTable(pTable);

    delete pTable;

    InterlockedDecrement(&g_nFlushThreads);

    return S_OK;
}

/*===================================================================
CTemplateCacheManager::FlushHashTable

    Does the actual work of flushing the templates.

    This routine may or may not be under the global cache manager
    crit sec.  It will if the flush is happening on the notification
    thread.  It won't be if it's happening on the FlushHashTableThread.

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushHashTable(CTemplateHashTable  *pTable)
{
    // Delete templates from the cache until there are no more

    while (!pTable->FMemoryTemplatesIsEmpty()) {
        CTemplate *pTemplate = static_cast<CTemplate *>(pTable->MemoryTemplatesEnd());

        // Remove the template from its various data structures
		pTable->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Flush the engine for this template from the script engine cache
		//   (use hash key, in case template was previously a zombie.)
        g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

        ZapTemplate(pTemplate);

    }

    // Delete templates from the cache until there are no more

    while (!pTable->FPersistTemplatesIsEmpty()) {
        CTemplate *pTemplate = static_cast<CTemplate *>(pTable->PersistTemplatesEnd());

        // Remove the template from its various data structures
		pTable->RemoveTemplate(pTemplate);

        // Make sure anyone using this template can tell it is obsolete
        pTemplate->Zombify();

        // Flush the engine for this template from the script engine cache
		//   (use hash key, in case template was previously a zombie.)
        g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

        ZapTemplate(pTemplate);

    }
}


/*===================================================================
CTemplateCacheManager::FlushFiles

    Empties template cache of files that match a prefix

Parameters:
    None

Returns:
    None
===================================================================*/

void CTemplateCacheManager::FlushFiles(const TCHAR *szFilePrefix)
{
    LockTemplateAndIncFileCaches();
    BOOL    fDoingMemoryTemplates = TRUE;

    // Delete templates from the cache until there are no more

	CDblLink *pLink = m_pHashTemplates->MemoryTemplatesBegin();
	while (! (fDoingMemoryTemplates 
                ? m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink)
                : m_pHashTemplates->FPersistTemplatesDblLinkAtEnd(pLink))) {

		CDblLink *pNextLink = pLink->PNext();
		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);

		if (_tcsncmp(pTemplate->ExtractHashKey()->szPathTranslated, szFilePrefix, _tcslen(szFilePrefix)) == 0) {
#if UNICODE
			DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %S\n", pTemplate->ExtractHashKey()->szPathTranslated));
#else
            DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %s\n", pTemplate->ExtractHashKey()->szPathTranslated));
#endif
			// Remove the template from its various data structures
			m_pHashTemplates->RemoveTemplate(pTemplate);

			// Make sure anyone using this template can tell it is obsolete
			pTemplate->Zombify();

			// Flush the engine for this template from the script engine cache
			//   (use hash key, in case template was previously a zombie.)
			g_ScriptManager.FlushCache(pTemplate->ExtractHashKey()->szPathTranslated);

			ZapTemplate(pTemplate);

#ifndef PERF_DISABLE
			g_PerfData.Incr_TEMPLFLUSHES();
#endif
        }

		pLink = pNextLink;

        if (fDoingMemoryTemplates && m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink)) {
            fDoingMemoryTemplates = FALSE;
            pLink = m_pHashTemplates->PersistTemplatesBegin();
        }
    }

    UnLockTemplateAndIncFileCaches();
}


/*===================================================================
CTemplateCacheManager::AddApplicationToDebuggerUI

    Loop through the template cache, and create doc nodes for
    all templates that belong to the application

Parameters:
    pAppln - pointer to application to attach to.

Returns: N/A
===================================================================*/

void CTemplateCacheManager::AddApplicationToDebuggerUI(CAppln *pAppln)
    {
    CDblLink *pLink;
    for (pLink = m_pHashTemplates->MemoryTemplatesBegin(); !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink); pLink = pLink->PNext())
        {
        // Bug  92070:
        //   Determine if the template is a member of pAppln by comparing
        //   the virtual path of the template to the application's virtual
        //   path (previously compared physical paths)  Since a template
        //   can have multiple virtual paths, only the first instance wins.
        //   Thus the template will only appear in the application that first
        //   loaded it.

		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);
        if (_tcscmp(pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL), pTemplate->GetApplnPath(SOURCEPATHTYPE_VIRTUAL)) == 0)
            pTemplate->AttachTo(pAppln);
        }
    }



/*===================================================================
CTemplateCacheManager::RemoveApplicationFromDebuggerUI

    Loop through the template cache, and remove doc nodes for
    all templates that belong to the application

Parameters:
    pAppln - pointer to application to detach from
             if pAppln is NULL, detach from ALL applications


Returns: N/A
===================================================================*/

void CTemplateCacheManager::RemoveApplicationFromDebuggerUI(CAppln *pAppln)
    {
    CDblLink *pLink;
    for (pLink = m_pHashTemplates->MemoryTemplatesBegin(); 
         !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pLink); 
         pLink = pLink->PNext())
        {
		CTemplate *pTemplate = static_cast<CTemplate *>(pLink);
        if (pAppln != NULL)
            pTemplate->DetachFrom(pAppln);
        else
            pTemplate->Detach();
        }
    }

/*===================================================================
void CTemplateCacheManager::RegisterTemplateForChangeNotification

    Request to watch template directories for file changes

Parameters:
    A pointer to the template

Returns:
    BOOL    True if successfully registered for change notification
===================================================================*/
BOOL CTemplateCacheManager::RegisterTemplateForChangeNotification(CTemplate *pTemplate, CAppln  *pApplication)
{

    STACK_BUFFER( tempPath, MAX_PATH );

    // Doesnt happen on Win95
    if (!FIsWinNT()) {
        return FALSE;
    }

    for (DWORD i = 0; i < pTemplate->m_cFilemaps; i++) {
        // Check if this directory is already registered for change notification

        // Pick out the directory portion of the path
        TCHAR *szEndOfPath = _tcsrchr(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, _T('\\'));
        size_t cch = DIFF(szEndOfPath - pTemplate->m_rgpFilemaps[i]->m_szPathTranslated)+1;

        if (tempPath.Resize((cch * sizeof(TCHAR)) + sizeof(TCHAR)) == FALSE) {

            // if failure to resize, continue registering...
            continue;
        }
        TCHAR *szPath = (TCHAR *) tempPath.QueryPtr();
        _tcsncpy(szPath, pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, cch);
        szPath[cch] = 0;

        // if the template is within the application's physical path, then it is
        // already being monitored.

        CASPDirMonitorEntry *pDME = NULL;

        if (pDME = pApplication->FPathMonitored(szPath)) {
            pDME->AddRef();
            pTemplate->m_rgpFilemaps[i]->m_pDME= pDME;
            continue;
        }

        if (RegisterASPDirMonitorEntry(szPath, &pDME)) {
            Assert(pDME);
            pTemplate->m_rgpFilemaps[i]->m_pDME= pDME;
        }
        else {
            // the current file failed to register.  Release all previous DMEs
            // and return FALSE...

            if (i > 0) {
                while (--i) {

                    pTemplate->m_rgpFilemaps[i]->m_pDME->Release();
                    pTemplate->m_rgpFilemaps[i]->m_pDME = NULL;
                }
            }
            return FALSE;

        }
    }
    return TRUE;
}

/*===================================================================
void CTemplateCacheManager::RegisterApplicationForChangeNotification

    Request to watch template directories for file changes

Parameters:
    A pointer to the template

Returns:
    BOOL    True if successfully registered for change notification
===================================================================*/
BOOL CTemplateCacheManager::RegisterApplicationForChangeNotification(CTemplate *pTemplate, CAppln *pApplication)
    {

    STACK_BUFFER( tempPath, MAX_PATH );

    // Doesnt happen on Win95
    if (!FIsWinNT())
        {
        return FALSE;
        }

    // Start with 1 to skip GLOBAL.ASA that is always added
    // in hitobj.cpp when new application gets created

    for (DWORD i = 1; i < pTemplate->m_cFilemaps; i++)
        {

        // Add to list of file-application mappings
        g_FileAppMap.AddFileApplication(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, pApplication);

        // Check if this directory is already registered for change notification
        // Pick out the directory portion of the path
        TCHAR *szEndOfPath = _tcsrchr(pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, _T('\\'));
        size_t cch = DIFF(szEndOfPath - pTemplate->m_rgpFilemaps[i]->m_szPathTranslated) + 1;

        if (tempPath.Resize((cch*sizeof(TCHAR)) + sizeof(TCHAR)) == FALSE) {

            // if failure, continue registering anyway...
            continue;
        }
        TCHAR *szPath = (TCHAR *) tempPath.QueryPtr();
        _tcsncpy(szPath, pTemplate->m_rgpFilemaps[i]->m_szPathTranslated, cch);
        szPath[cch] = 0;

        // if the template is within the application's physical path, then it is
        // already being monitored.

        if (pApplication->FPathMonitored(szPath)) {

            continue;
        }

        // Register directory for monitoring
        CASPDirMonitorEntry *pDME = NULL;
        if (RegisterASPDirMonitorEntry(szPath, &pDME))
            {
            Assert(pDME);
            pApplication->AddDirMonitorEntry(pDME);
            }
        }

    return TRUE;
    }


/*===================================================================
BOOL CTemplateCacheManager::ShutdownCacheChangeNotification

    Turn off change notification for changes to files in the cache

Parameters:
    None

Returns:
    Nothing
===================================================================*/
BOOL CTemplateCacheManager::ShutdownCacheChangeNotification()
    {

    BOOL fDoingMemoryTemplates = TRUE;
    // Doesnt happen on Win95
    if (!FIsWinNT())
        {
        return FALSE;
        }

    LockTemplateCache();

    CTemplate *pTemplate = static_cast<CTemplate *>(m_pHashTemplates->MemoryTemplatesBegin());
    while (fDoingMemoryTemplates
             ? !m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pTemplate)
             : !m_pHashTemplates->FPersistTemplatesDblLinkAtEnd(pTemplate)) {

        if(pTemplate->m_rgpFilemaps)
            {
            for(UINT i = 0; i < pTemplate->m_cFilemaps; i++)
                {
                // Give up our ref count on the directory monitor entry
                if (pTemplate->m_rgpFilemaps[i]->m_pDME)
                    {
                    pTemplate->m_rgpFilemaps[i]->m_pDME->Release();
                    pTemplate->m_rgpFilemaps[i]->m_pDME = NULL;
                    }
                }
            }

        pTemplate = static_cast<CTemplate *>(pTemplate->PNext());
        if (fDoingMemoryTemplates && m_pHashTemplates->FMemoryTemplatesDblLinkAtEnd(pTemplate)) {
            fDoingMemoryTemplates = FALSE;
            pTemplate = static_cast<CTemplate *>(m_pHashTemplates->PersistTemplatesBegin());
        }
    }

    UnLockTemplateCache();
    return TRUE;
    }

/*  ****************************************************************************
    CIncFileMap member functions
*/

/*===================================================================
CIncFileMap::CIncFileMap

Parameters: N/A

Returns: N/A
===================================================================*/

CIncFileMap::CIncFileMap()
    {
    }


/*===================================================================
CIncFileMap::~CIncFileMap

Parameters: N/A

Returns: N/A
===================================================================*/

CIncFileMap::~CIncFileMap()
    {
    }



/*===================================================================
CIncFileMap::Init

Parameters: None

Returns: Completion Status
===================================================================*/

HRESULT CIncFileMap::Init()
    {
    HRESULT hr;
    ErrInitCriticalSection(&m_csUpdate, hr);
    if (FAILED(hr))
        return(hr);
    return m_mpszIncFile.Init(CINCFILEBUCKETS);
    }


/*===================================================================
CIncFileMap::GetIncFile

    Get an inc-file from the cache, first storing it into cache if it is not yet there.

Parameters:
    szIncFile   - file name
    ppIncFile   - ptr-to-ptr to inc-file (out-parameter)

Returns: HRESULT
===================================================================*/

HRESULT CIncFileMap::GetIncFile(const TCHAR *szFile, CIncFile **ppIncFile)
    {
    HRESULT hrInit = S_OK;           // return value

    LockIncFileCache();

    Assert(IsNormalized(szFile));
    *ppIncFile = static_cast<CIncFile *>(m_mpszIncFile.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR)));

    // if we have a cached inc-file at this stage, it must be "reliable," so we use it.
    // else, if we have no cached inc-file, create a new one.
    if (*ppIncFile == NULL)
        {
        if ((*ppIncFile = new CIncFile) == NULL)
            {
            UnLockIncFileCache();
            return E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hrInit = (*ppIncFile)->Init(szFile)))
            {
            // The hash table will hold a reference to the inc file
            (*ppIncFile)->AddRef();
            m_mpszIncFile.AddElem(*ppIncFile);
            }
        else
            *ppIncFile = NULL;

        }

    if (SUCCEEDED(hrInit))
        {
        // The caller will hold a reference to the inc file
        (*ppIncFile)->AddRef();
        }

    UnLockIncFileCache();

    return hrInit;
    }



/*===================================================================
CIncFileMap::UnInit

Parameters: N/A

Returns: Completion status
===================================================================*/

HRESULT CIncFileMap::UnInit()
    {
    CIncFile *pNukeIncFile = static_cast<CIncFile *>(m_mpszIncFile.Head());
    while (pNukeIncFile != NULL)
        {
        CIncFile *pNext = static_cast<CIncFile *>(pNukeIncFile->m_pNext);
        pNukeIncFile->OnIncFileDecache();
        pNukeIncFile->Release();
        pNukeIncFile = pNext;
        }
    DeleteCriticalSection(&m_csUpdate);
    return m_mpszIncFile.UnInit();
    }



/*===================================================================
CIncFileMap::Flush

Parameters:
    szFile - the file to remove from cache

Returns:
    None
===================================================================*/

void CIncFileMap::Flush(const TCHAR *szFile)
    {
    LockTemplateAndIncFileCaches();

    Assert(IsNormalized(szFile));
    CIncFile *pIncFile = static_cast<CIncFile *>(m_mpszIncFile.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR)));

    if (pIncFile != NULL)
        {
        if (pIncFile->FlushTemplates())
            {
            // Remove from hash table
            m_mpszIncFile.DeleteElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
            // The hash table gave up its reference
            // to the incfile
            pIncFile->OnIncFileDecache();
            pIncFile->Release();
            }
        }

    UnLockTemplateAndIncFileCaches();
    }



/*===================================================================
CIncFileMap::FlushFiles

Parameters:
    szFile - the file prefix to search for in cache

Returns:
    None
===================================================================*/

void CIncFileMap::FlushFiles(const TCHAR *szFilePrefix)
    {
    LockTemplateAndIncFileCaches();

    Assert(IsNormalized(szFilePrefix));
    CIncFile *pIncFile = static_cast<CIncFile *>(m_mpszIncFile.Head());

    while (pIncFile != NULL)
        {
		CIncFile *pNextFile = static_cast<CIncFile *>(pIncFile->m_pNext);

		int cchFilePrefix = _tcslen(szFilePrefix);
		if (pIncFile->m_cbKey >= (cchFilePrefix*(int)sizeof(TCHAR)) &&
		    _tcsncmp(reinterpret_cast<TCHAR *>(pIncFile->m_pKey), szFilePrefix, cchFilePrefix) == 0)
			{
#if UNICODE
			DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %S\n", pIncFile->m_pKey));
#else
            DBGPRINTF((DBG_CONTEXT, "FlushFiles: flushing %s\n", pIncFile->m_pKey));
#endif
            if (pIncFile->FlushTemplates())
				{
				// Remove from hash table
				m_mpszIncFile.DeleteElem(pIncFile->m_pKey, pIncFile->m_cbKey);
				// The hash table gave up its reference
				// to the incfile
				pIncFile->OnIncFileDecache();
				pIncFile->Release();
				}
			}

		pIncFile = pNextFile;
        }

    UnLockTemplateAndIncFileCaches();
    }



/*  ****************************************************************************
    Non-class support functions
*/

/*===================================================================
FFileChangedSinceCached
Has the file changed since it was cached?

Parameters:
    szFile          - file name
    ftPrevWriteTime - the file's "previous write time"
                      (its last-write-time value when the file was cached)

Returns:
    TRUE or FALSE
===================================================================*/
BOOL FFileChangedSinceCached(const TCHAR *szFile, FILETIME& ftPrevWriteTime)
    {
    WIN32_FILE_ATTRIBUTE_DATA   fad;            // win32 file attributes data structure
    BOOL                        fRet = FALSE;   // return value

    // This fn doesnt exist on Win95.  On Win95 we do no caching anyway, so we dont care.
    if (!FIsWinNT())
        return(TRUE);

    if (FAILED(AspGetFileAttributes(szFile, &fad)))
        {
        // assume file was changed if get file attributes failed
        fRet = TRUE;
        }

    if( 0 != CompareFileTime( &ftPrevWriteTime, &(fad.ftLastWriteTime) ) )
        {
        // file was changed if file times differ
        fRet = TRUE;
        }

    return fRet;
    }

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::TrimPersistCache

Parameters:
    dwTrimCount - the number of templates to trim from the cache

Returns:
    TRUE - if dwTrimCount was actually trimmed
    FALSE - if exited before dwTrimCount was met

===================================================================*/

BOOL CTemplateCacheManager::CTemplateHashTable::TrimPersistCache(DWORD  dwTrimCount)
{
    // enter a while loop to trim until the count is reached

    while(dwTrimCount--) {

        // if there isn't anything else to trim, we're done.  Return FALSE
        // to indicate that dwTrimCount was not met.

        if (m_dwPersistedTemplates == 0) {
            return(FALSE);
        }
        else {

            CTemplate   *pTemplate;

            // get the oldest template from the list

            pTemplate = static_cast<CTemplate *>(PersistTemplatesEnd());

            // remove the template.

            RemoveTemplate(pTemplate);

            ZapTemplate(pTemplate);

        }
    }

    // return TRUE to indicate that the TrimCount was met.
    return(TRUE);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::ScavengePersistCache

Parameters:
    <NONE>

Returns:
    VOID

===================================================================*/
VOID CTemplateCacheManager::CTemplateHashTable::ScavengePersistCache()
{
    CTemplate   *pTemplate;
    CTemplate   *pTemplateNext;

    // enter a for loop to look at all persisted templates to see if
    // any memory can be freed.  It's memory can be freed only if the
    // ref count is 1 (the sole ref count is for the cache).  Also note
    // that the list is re-ordered to move templates to the head of the
    // list that can't have their memory freed at this time because of
    // the ref count.  

    for (pTemplate = static_cast<CTemplate *>(PersistTemplatesBegin());
         (pTemplate != static_cast<CTemplate *>(&m_listPersistTemplates)) && (pTemplate->m_pbStart != NULL);
         pTemplate = pTemplateNext) {

        pTemplateNext = static_cast<CTemplate *>(pTemplate->PNext());

        // this check should be safe.  The only risk is that we miss a release
        // of the template from 2 to 1, in which case will miss it this time
        // but get it the next time through.  AddRef from 1 to 2 is impossible
        // to interrupt because it couldn't be on this list when it gets AddRef'd
        // from 1 to 2 and moving it from this list is protected by the template
        // cache lock which we should be under.

        if (pTemplate->m_cRefs == 1) {

            // remove the memory

            CTemplate::LargeFree(pTemplate->m_pbStart);
            pTemplate->m_pbStart = NULL;
        }
        else {
            
            // if some is still using it, move the template to the head of the
            // list so that we'll check again later.

            pTemplate->PrependTo(m_listPersistTemplates);
        }
    }
}

/*===================================================================
    GetAggregatedTemplCounter()

    Returns the Template Perf Counter.  To do this, initializes a private
    copy of the perfmainblock and aggregates the stats into it.

===================================================================*/
static DWORD GetAggregatedTemplCounter()
{

    CPerfMainBlock  perfSharedBlk;
    DWORD           pdwCounters[C_PERF_PROC_COUNTERS];
    BOOL            bInited = FALSE;

    memset(pdwCounters, 0, sizeof(pdwCounters));

    if (!(bInited = (perfSharedBlk.Init() == S_OK)));

    else {
        
        perfSharedBlk.GetStats(pdwCounters);
    }

    if (bInited)
        perfSharedBlk.UnInit();

    return(pdwCounters[ID_TEMPLCACHE]);
}

/*===================================================================
 CTemplateCacheManager::InitPersistCache

Parameters:
    [none]

Returns:
    BOOL to indicate if the init was successful

===================================================================*/

BOOL    CTemplateCacheManager::InitPersistCache()
{
    HANDLE      hImpersonationToken = NULL;
    BOOL        fRevertedToSelf = FALSE;
    HANDLE      hThread;

    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,           
                         &hImpersonationToken )) {

       RevertToSelf();
       fRevertedToSelf = TRUE;
    }

    // get the PersistCacheDir from the globals table

    strcpy(m_szPersistCacheDir,Glob(pszPersistTemplateDir));

    // Check to see if the directory exists...

    DWORD   dirAttribs = GetFileAttributesA(m_szPersistCacheDir);

    if ((dirAttribs == 0xffffffff)
        || !(dirAttribs & FILE_ATTRIBUTE_DIRECTORY)) {

        MSG_Error(IDS_CACHE_DIR_MISSING);
        m_fFailedToInitPersistCache = TRUE;
    }
    else {

        // append the trailing slash to the directory name

        strcat(m_szPersistCacheDir,"\\");

        // next, cleanup the temp directory.

        // since asp.dll can execute in many process simultaneously, we'll
        // check the perf counter to see if there are any templates
        // cached anywhere on the system.  

        if (GetAggregatedTemplCounter() == 0) {

            CHAR DirectoryWildcard[MAX_PATH];
            WIN32_FIND_DATAA win32FindData;

            strcpy(DirectoryWildcard, m_szPersistCacheDir);
            strcat(DirectoryWildcard, "ASP*.TMP");

            // use FindFirstFile to begin the enumeration of all files in the 
            // temp directory.

            HANDLE hDirectory = FindFirstFileA( DirectoryWildcard, &win32FindData );

            if ( hDirectory != INVALID_HANDLE_VALUE ) {

                BOOL success = TRUE;

                while ( success ) {

                    char fileName[MAX_PATH];
                
                    // FindFirst/FindNext returns just the filename.  Build up
                    // the entire path and then call DeleteFile.  We'll ignore
                    // errors as there isn't much we could do with the error
                    // except fail the cache init.

                    strcpy( fileName, m_szPersistCacheDir );
                    strcat( fileName, win32FindData.cFileName );

                    DeleteFileA( fileName );

                    success = FindNextFileA( hDirectory, &win32FindData );
                }

                FindClose( hDirectory );
            }
            else {
                GetLastError();
            }
        }
    }

    if (fRevertedToSelf) {
        SetThreadToken(&hThread, hImpersonationToken);
    }

    return(!m_fFailedToInitPersistCache);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::CanPersistTemplate

Parameters:
    pTemplate - The template to test for persistability

Returns:
    BOOL to indicate if template can be persisted.

===================================================================*/

BOOL CTemplateCacheManager::CTemplateHashTable::CanPersistTemplate(CTemplate  *pTemplate)
{

    // if MaxFiles is zero, then the persist cache is disabled

    if (Glob(dwPersistTemplateMaxFiles) == 0) {
        return(FALSE);
    }

    // can't persist if the persist cache failed to init

    if (m_fFailedToInitPersistCache == TRUE) {
        return(FALSE);
    }

    // can't persist templates that are marked as debuggable.  The 
    // script engines need access to the memory.

    if (pTemplate->FDebuggable()) {
        return(FALSE);
    }

    // at this point, we're going to return true.  The next part of the code
    // trims the cache as necessary.

    if (m_dwPersistedTemplates >= Glob(dwPersistTemplateMaxFiles)) {
        TrimPersistCache(m_dwPersistedTemplates - Glob(dwPersistTemplateMaxFiles) + 1);
    }

    return(TRUE);
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::InsertTemplate

Parameters:
    pTemplate - Template to insert into the memory cache

Returns:
    LK_RETCODE indicating the success of the insertion

===================================================================*/

LK_RETCODE CTemplateCacheManager::CTemplateHashTable::InsertTemplate(CTemplate *pTemplate)
{
	LK_RETCODE rcode = InsertRecord(pTemplate, true);

	if (rcode == LK_SUCCESS) {
#ifndef PERF_DISABLE
        g_PerfData.Incr_MEMORYTEMPLCACHE();
        g_PerfData.Incr_TEMPLCACHE();
#endif
        m_dwInMemoryTemplates++;
		pTemplate->PrependTo(m_listMemoryTemplates);
        pTemplate->SetHashTablePtr(this);
    }

    ScavengePersistCache();

	return rcode;
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::RemoveTemplate

Parameters:
    pTemplate - Template to remove from cache
    fPersist - indicate if memory template is a candidate for persist

Returns:
    LK_RETCODE indicating the success of the removal

===================================================================*/

LK_RETCODE CTemplateCacheManager::CTemplateHashTable::RemoveTemplate(CTemplate *pTemplate, BOOL fPersist)
{
	LK_RETCODE rcode = LK_SUCCESS;
#if DBG_PERSTEMPL
    DBGPRINTF((DBG_CONTEXT, 
              "RemoveTemplate entered.\n\tTemplate = %s.\n\tfPersist = %d.\n\tFIsPersisted = %d\n",
              pTemplate->GetSourceFileName(),
              fPersist,
              pTemplate->FIsPersisted()));
#endif

    // if the template isn't in the cache, or if the template isn't on this
    // particular hash table, then just bail.  Nothing to
    // do here.  It may not be on this particular hash table because the entire
    // table may have been torn off the global cache manager and scheduled for
    // cleanup on the flush thread.  In this case, we're checking the wrong
    // table.  The flush thread will eventually clean this one up.

    if (pTemplate->FIsEmpty() || (pTemplate->GetHashTablePtr() != this)) {

        return LK_NO_SUCH_KEY;
    }

    // no matter what, this template is going to be unlinked from it's
    // current CDblLink

    pTemplate->UnLink();

    // update the appropriate counter

    if (pTemplate->FIsPersisted() == FALSE) {

        // decrement the number of InMemoryTemplates...

#ifndef PERF_DISABLE
        g_PerfData.Decr_MEMORYTEMPLCACHE();
#endif
        m_dwInMemoryTemplates--;
    }
    else {
        m_dwPersistedTemplates--;
    }

    // if asked to be persisted, see if it's a candidate to be persisted.

    if (fPersist && CanPersistTemplate(pTemplate)) {

        // so persist it.

        if (pTemplate->PersistData(m_szPersistCacheDir) != S_OK) {

            // a failure will result in the record being deleted.

#ifndef PERF_DISABLE
            g_PerfData.Decr_TEMPLCACHE();
#endif
            rcode = DeleteRecord(pTemplate);

        }
        else {

            // if successfully persisted, then add to the list of
            // persisted templates

            pTemplate->PrependTo(m_listPersistTemplates);

            m_dwPersistedTemplates++;
        }
    }
    else {

#ifndef PERF_DISABLE
            g_PerfData.Decr_TEMPLCACHE();
#endif
        // if not asked to persist, then delete the record.

        rcode = DeleteRecord(pTemplate);
    }

    ScavengePersistCache();

	return rcode;
}

/*===================================================================
 CTemplateCacheManager::CTemplateHashTable::FindTemplate

Parameters:
    rTemplate - the key for the template being looked up

Returns:
    LK_RETCODE indicating the success of the look up

===================================================================*/

LK_RETCODE  CTemplateCacheManager::CTemplateHashTable::FindTemplate(const CTemplateKey &rTemplateKey, CTemplate **ppTemplate)
 {

#if DBG_PERSTEMPL

    DBGPRINTF((DBG_CONTEXT, 
              "FindTemplate entered\n\tLooking for %s\n",
              rTemplateKey.szPathTranslated));
#endif

#ifndef PERF_DISABLE
    g_PerfData.Incr_MEMORYTEMPLCACHETRYS();
    g_PerfData.Incr_TEMPLCACHETRYS();
#endif

    LK_RETCODE rcode = FindKey(&rTemplateKey, ppTemplate);

    // see if we found it.

	if (rcode == LK_SUCCESS) {

#if DBG_PERSTEMPL

        DBGPRINTF((DBG_CONTEXT, 
                   "Template found\n\tfPersisted = %d\n",
                   (*ppTemplate)->FIsPersisted()));
#endif                  

#ifndef PERF_DISABLE
            g_PerfData.Incr_TEMPLCACHEHITS();
#endif
        // found it.  Is it persisted?

        if ((*ppTemplate)->FIsPersisted()) {

            // It is persisted.  Unlink it from the persisted list.

            (*ppTemplate)->UnLink();

            m_dwPersistedTemplates--;

            // unpersist it

            if ((*ppTemplate)->UnPersistData() != S_OK) {

                // error occurred

                // get the template out of the cache

                DeleteRecord(*ppTemplate);

                // release the reference that the cache had on the template

                (*ppTemplate)->Release();

                // NULL out *ppTemplate so that the caller doesn't think they
                // got a valid template

                *ppTemplate = NULL;

#ifndef PERF_DISABLE
                g_PerfData.Decr_TEMPLCACHE();
#endif
                // return NO_SUCH_KEY so that a new template will be built

                return(LK_NO_SUCH_KEY);
            }

            // bump the number of in memory templates

#ifndef PERF_DISABLE
            g_PerfData.Incr_MEMORYTEMPLCACHE();
#endif
            m_dwInMemoryTemplates++;
        }
        else {
#ifndef PERF_DISABLE
            g_PerfData.Incr_MEMORYTEMPLCACHEHITS();
#endif
        }

        // add it to, or move it to the top of, the memory templates

		(*ppTemplate)->PrependTo(m_listMemoryTemplates);
    }

    ScavengePersistCache();

	return rcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\cachemgr.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Template Cache Manager

File: CacheMgr.h

Owner: DGottner

Template cache manager definition
-----------------------------------------------------------------------------*/

#ifndef _CACHEMGR_H
#define _CACHEMGR_H

// Includes -------------------------------------------------------------------

#include "Template.h"
#include "lkrhash.h"
#include "aspdmon.h"

class CHitObj;


// Types and Constants --------------------------------------------------------

#define CTEMPLATEBUCKETS 1021		// size of CTemplate hash table
#define CINCFILEBUCKETS  89			// size of CIncFile hash table


/*	****************************************************************************
	Class:		CTemplateCacheManager
	Synopsis:	A CCacheManager that manages a cache of Denali templates
*/	
class CTemplateCacheManager
	{

private:
    class CTemplateHashTable;
    friend class CTemplateHashTable;

    // since there is only one CTemplateCacheManager object ever available, namely
    // g_TemplateCache, this is safe to call these two members static.

    static BOOL     m_fFailedToInitPersistCache;
    static char     m_szPersistCacheDir[MAX_PATH];

    // The type for a hash table of CTemplates keyed on instance id + name
	//
	// since we provide new methods, make parent methods uncallable
	class CTemplateHashTable :  private CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>
	{
	private:
        CDblLink m_listMemoryTemplates;
        CDblLink m_listPersistTemplates;
        DWORD    m_dwInMemoryTemplates;
        DWORD    m_dwPersistedTemplates;

        VOID     ScavengePersistCache();


	public:
		// export some methods
        DWORD InMemoryTemplates() { return m_dwInMemoryTemplates; };
		//CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>::Size;

        // test to see if the template can be persisted...
        BOOL  CanPersistTemplate(CTemplate *pTemplate);

        // trim some number of templates from the persist cache...
        BOOL  TrimPersistCache(DWORD    dwTrimCount);

		// new methods
		CTemplateHashTable()
			: CTypedHashTable<CTemplateHashTable, CTemplate, const CTemplateKey *>("ASP Template Cache") {
            m_dwInMemoryTemplates = 0;
            m_dwPersistedTemplates = 0;
            }

		static const CTemplateKey *ExtractKey(const CTemplate *pTemplate)
			{
			return pTemplate->ExtractHashKey();
			}

		// NOTE: We don't hash the pTemplateKey->nInstanceID because it can be wildcarded.
		//       if we were to include in the hash, the wildcard won't hash to the same key
		//
		static DWORD CalcKeyHash(const CTemplateKey *pTemplateKey)
			{
			return HashString(pTemplateKey->szPathTranslated, 0);
			}

		static bool EqualKeys(const CTemplateKey *pKey1, const CTemplateKey *pKey2) {
            return (_tcscmp(pKey1->szPathTranslated, pKey2->szPathTranslated) == 0) 
                    && (pKey1->dwInstanceID == pKey2->dwInstanceID 
                            || pKey1->dwInstanceID == MATCH_ALL_INSTANCE_IDS 
                            || pKey2->dwInstanceID == MATCH_ALL_INSTANCE_IDS);
        }

		// NOTE: In theory, the LKHash can help solve our ref. counting problems, by
		//       automatic addref/release.  However, since prior code uses non-refcounting
		//       data structure, it's safer to leave old code alaone in this respect, and
		//       no-op the AddRefRecord method.
		//
		static void AddRefRecord(CTemplate *pTemplate, int nIncr)
			{
			}

    	// Provide new methods to automatically manage the LRU ordering.
    	// NOTE: We used to override the methods but ran into inconsistencies (bugs?)
    	// in VC compiler. Sometimes it would call derived & sometimes the base class
    	// given the same arguemt datatypes.
		//
		LK_RETCODE InsertTemplate(CTemplate *pTemplate);

		LK_RETCODE RemoveTemplate(CTemplate *pTemplate, BOOL fPersist = FALSE);

		// NOTE: Template signature also requires const ptr to const data
		LK_RETCODE FindTemplate(const CTemplateKey &rTemplateKey, CTemplate **ppTemplate);

		// accessor methods for hidden LRU cache
		bool FMemoryTemplatesIsEmpty() const
			{
			return m_listMemoryTemplates.FIsEmpty();
			}

		// you CANNOT compare LRU nodes to NULL to know if you are at the end
		// of the list!  Instead use this member.
		//
		BOOL FMemoryTemplatesDblLinkAtEnd(CDblLink *pElem)
			{
			pElem->AssertValid();
			return pElem == &m_listMemoryTemplates;
			}

		CDblLink *MemoryTemplatesBegin()		// return pointer to last referenced item
			{
			return m_listMemoryTemplates.PNext();
			}

		CDblLink *MemoryTemplatesEnd()			// return pointer to least recently accessed item
			{
			return m_listMemoryTemplates.PPrev();
			}

		// accessor methods for hidden LRU cache
		bool FPersistTemplatesIsEmpty() const
			{
			return m_listPersistTemplates.FIsEmpty();
			}

		// you CANNOT compare LRU nodes to NULL to know if you are at the end
		// of the list!  Instead use this member.
		//
		BOOL FPersistTemplatesDblLinkAtEnd(CDblLink *pElem)
			{
			pElem->AssertValid();
			return pElem == &m_listPersistTemplates;
			}

		CDblLink *PersistTemplatesBegin()		// return pointer to last referenced item
			{
			return m_listPersistTemplates.PNext();
			}

		CDblLink *PersistTemplatesEnd()			// return pointer to least recently accessed item
			{
			return m_listPersistTemplates.PPrev();
			}
		};

	CRITICAL_SECTION	m_csUpdate;			// CS for updating the data structures
	CTemplateHashTable	*m_pHashTemplates;	// the cache data structure
    
    // Initialize the persistant template cache
    BOOL     InitPersistCache();

    // static methods primarily used from a seperate thread to flush
    // the template cache out of band from the FCN thread notification.

    static  void  FlushHashTable(CTemplateHashTable   *pTable);   
    static  DWORD __stdcall FlushHashTableThread(VOID  *pArg);

public:


	CTemplateCacheManager();
	~CTemplateCacheManager();

    inline void LockTemplateCache()   { EnterCriticalSection(&m_csUpdate); }
    inline void UnLockTemplateCache() { LeaveCriticalSection(&m_csUpdate); }

	HRESULT Init();
	HRESULT UnInit();

    HRESULT FirstHitInit() { InitPersistCache(); return S_OK; }

	// Find in cache (don't load) -- for look-aheads
	/////
    HRESULT FindCached(const TCHAR *szFile, DWORD dwInstanceID, CTemplate **ppTemplate);

	// Get a template from the cache, or load it into cache
	/////
	HRESULT Load(BOOL fRunGlobalAsp, const TCHAR *szFile, DWORD dwInstanceID, CHitObj *pHitObj, CTemplate **ppTemplate, BOOL *pfTemplateInCache);

	// Remove a template from the cache
	//   for backward compatibility, "nInstanceID" can be omitted, in which case all instance ID
	//   templates are flushed.
	/////
	void Flush(const TCHAR *szFile, DWORD dwInstanceID);

	// Remove templates from the cache that have a common prefix
	//   Instance ID is ignored.
	/////
	void FlushFiles(const TCHAR *szFilePrefix);

	// Remove all templates from the cache
	/////
	void FlushAll(VOID);

	// Add all templates that form an application to the debugger's list of
	// running documents
	/////
	void AddApplicationToDebuggerUI(CAppln *pAppln);

	// Remove all templates that form an application from the debugger's list of
	// running documents
	/////
	void RemoveApplicationFromDebuggerUI(CAppln *pAppln);

	// Get directory change notification on directories used by template
	BOOL RegisterTemplateForChangeNotification(CTemplate *pTemplate, CAppln  *pApplication);

	// Get directory change notification for applications
	BOOL RegisterApplicationForChangeNotification(CTemplate *pTemplate, CAppln *pApplication);

    // Stop getting change notification for changes to templates in the cache.
	BOOL ShutdownCacheChangeNotification();

	};



/*	****************************************************************************
	Class:		CIncFileMap
	Synopsis:	A database mapping template include files to a list of their users
*/	
class CIncFileMap
	{
	CRITICAL_SECTION	m_csUpdate;			// CS for updating the data structures
	CHashTable			m_mpszIncFile;		// the cache data structure

public:

	CIncFileMap();
	~CIncFileMap();

    inline void LockIncFileCache()   { EnterCriticalSection(&m_csUpdate); }
    inline void UnLockIncFileCache() { LeaveCriticalSection(&m_csUpdate); }

	HRESULT Init();
	HRESULT UnInit();

	HRESULT	GetIncFile(const TCHAR *szIncFile, CIncFile **ppIncFile);
	void Flush(const TCHAR *szIncFile);
	void FlushFiles(const TCHAR *szIncFilePrefix);
	};



/*	****************************************************************************
	Non-class support functions
*/
BOOL FFileChangedSinceCached(const TCHAR *szFile, FILETIME& ftPrevWriteTime);



// Globals --------------------------------------------------------------------

extern CTemplateCacheManager	g_TemplateCache;
extern CIncFileMap 				g_IncFileMap;

inline void LockTemplateAndIncFileCaches()
    {
    g_TemplateCache.LockTemplateCache();
    g_IncFileMap.LockIncFileCache();
    }

inline void UnLockTemplateAndIncFileCaches()
    {
    g_TemplateCache.UnLockTemplateCache();
    g_IncFileMap.UnLockIncFileCache();
    }


// Prototypes -----------------------------------------------------------------

#endif // _CACHEMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\connpt.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: IConnectionPoint implementation

File: ConnPt.h

Owner: DGottner

Implementation of IConnectionPoint
===================================================================*/

#ifndef _ConnPt_H
#define _ConnPt_H

/*
 * C C o n n e c t i o n P o i n t
 *
 * IConnectionPoint interface implementation for OLE objects
 *
 * This class contains the basic five IConnectionPoint members.  The Big Three
 * (QueryInterface, AddRef, Release) are left as pure virtual, as this
 * class is designed as an intermediate class for further derivation.
 *
 * This also means that we no longer need a pointer to the controlling unknown.
 */

#include "DblLink.h"


/*	****************************************************************************
	Class:		CConnectionPoint
	Synopsis:	Provide a reusable implementation of IConnectionPoint

    NOTE: Linked list of sinks is used because we are expecting very
          few connections. (in fact only one (Caesars))
*/

class CConnectionPoint : public IConnectionPoint
	{
	friend class CEnumConnections;

private:
	struct CSinkElem : CDblLink
		{
		DWORD		m_dwCookie;			// cookie that we assigned the connection
		IUnknown *	m_pUnkObj;			// event sink

		CSinkElem(DWORD dwCookie, IUnknown *pUnkObj)
			{
			m_dwCookie = dwCookie;
			if ((m_pUnkObj = pUnkObj) != NULL) m_pUnkObj->AddRef();
			}

		~CSinkElem()
			{
			if (m_pUnkObj) m_pUnkObj->Release();
			}
		};

	CDblLink		m_listSinks;		// list of event sinks
	DWORD			m_dwCookieNext; 	// Next cookie

protected:
	IUnknown *		m_pUnkContainer;	// pointer to parent container
	GUID			m_uidEvent;			// connection point interface

public:
	CConnectionPoint(IUnknown *, const GUID &);
	~CConnectionPoint();

	// IConnectionPoint members
	STDMETHODIMP GetConnectionInterface(GUID *);
	STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer **);
	STDMETHODIMP Advise(IUnknown *, DWORD *);
	STDMETHODIMP Unadvise(DWORD);
	STDMETHODIMP EnumConnections(IEnumConnections **);

	inline BOOL FIsEmpty()			// quick way to check if list is empty w/o allocating enumerator
		{
		return m_listSinks.FIsEmpty();
		}
	};


/*	****************************************************************************
	Class:		CEnumConnections
	Synopsis:	Provide the enumerator for CConnectionPoint
*/

class CEnumConnections : public IEnumConnections
	{
private:
	ULONG				m_cRefs;		// Reference count
	CDblLink *			m_pElemCurr;	// Current element
	CConnectionPoint *	m_pCP;			// pointer to iteratee

public:
	CEnumConnections(CConnectionPoint *pCP);
	~CEnumConnections(void);

	// The Big Three

	STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IEnumConnections members

	STDMETHODIMP Next(ULONG, CONNECTDATA *, ULONG *);
	STDMETHODIMP Skip(ULONG);
	STDMETHODIMP Reset(void);
	STDMETHODIMP Clone(IEnumConnections **);
	};

#endif _ConnPt_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\connpt.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: IConnectionPoint implementation

File: ConnPt.h

Owner: DGottner

This file contains our implementation of IConnectionPoint
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "ConnPt.h"
#include "memchk.h"


/*------------------------------------------------------------------
 * C C o n n e c t i o n P o i n t
 */

/*===================================================================
CConnectionPoint::CConnectionPoint
CConnectionPoint::~CConnectionPoint

Parameters (Constructor):
	pUnkObj			pointer to the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.

NOTE: Code assumes connection point is contained DIRECTLY in the
      container (and thus, does not AddRef 'm_pContainer'
      If not the case, we may be in trouble.
===================================================================*/

CConnectionPoint::CConnectionPoint(IUnknown *pUnkContainer, const GUID &uidEvent)
	{
	m_pUnkContainer = pUnkContainer;
	m_uidEvent = uidEvent;
	m_dwCookieNext = 0xA5B;		// Looks like "ASP"!

	Assert (m_pUnkContainer != NULL);
	}

CConnectionPoint::~CConnectionPoint()
	{
	while (! m_listSinks.FIsEmpty())
		delete m_listSinks.PNext();
	}



/*===================================================================
CConnectionPoint::GetConnectionInterface

Returns the interface of the event source
===================================================================*/

HRESULT
CConnectionPoint::GetConnectionInterface(GUID *puidReturn)
	{
	*puidReturn = m_uidEvent;
	return S_OK;
	}



/*===================================================================
CConnectionPoint::GetConnectionPointContainer

Returns the interface of the event source
===================================================================*/

HRESULT
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppContainer)
	{
	return m_pUnkContainer->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void **>(ppContainer));
	}



/*===================================================================
CConnectionPoint::Advise

Purpose:
 Provides this connection point with a notification sink to
 call whenever the appropriate outgoing function/event occurs.

Parameters:
 pUnkSink        IUnknown to the sink to notify.  The connection
                 point must QueryInterface on this pointer to obtain
                 the proper interface to call.  The connection
                 point must also insure that any pointer held has
                 a reference count (QueryInterface will do it).
 pdwCookie       DWORD * in which to store the connection key for
                 later calls to Unadvise.
===================================================================*/

HRESULT
CConnectionPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
	{
	// Make sure they store the correct interface pointer!
	// NOTE: Storing into the list will AddRef, to we need to Release the
	//       QueryInterface pointer right away.
	//
	void *pvT;
	if (FAILED(pUnkSink->QueryInterface(m_uidEvent, &pvT)))
		return CONNECT_E_CANNOTCONNECT;
	pUnkSink->Release();

	CSinkElem *pSinkElem = new CSinkElem(*pdwCookie = m_dwCookieNext++, pUnkSink);
	if (pSinkElem == NULL)
		return E_OUTOFMEMORY;

	pSinkElem->AppendTo(m_listSinks);
	return S_OK;
	}



/*===================================================================
CConnectionPoint::Unadvise

Purpose:
 Terminates the connection to the notification sink identified
 with dwCookie (that was returned from Advise).  The connection
 point has to Release any held pointers for that sink.

Parameters:
 dwCookie        DWORD connection key from Advise.
===================================================================*/

HRESULT
CConnectionPoint::Unadvise(DWORD dwCookie)
	{
	// Search for the cookie
	for (CSinkElem *pSinkElem = static_cast<CSinkElem *>(m_listSinks.PNext());
		 pSinkElem != &m_listSinks;
		 pSinkElem = static_cast<CSinkElem *>(pSinkElem->PNext()))
		{
		if (dwCookie == pSinkElem->m_dwCookie)
			{
			delete pSinkElem;
			return S_OK;
			}
		}

	return CONNECT_E_NOCONNECTION;
	}



/*===================================================================
CConnectionPoint::EnumConnections

Purpose:
 Creates and returns an enumerator object with the
 IEnumConnections interface that will enumerate the IUnknown
 pointers of each connected sink.

Parameters:
 ppEnum          Output enumerator object
===================================================================*/

HRESULT
CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
	{
	if ((*ppEnum = new CEnumConnections(this)) == NULL)
		return E_OUTOFMEMORY;

	return S_OK;
	}


/*------------------------------------------------------------------
 * C E n u m C o n n e c t i o n s
 */

/*===================================================================
CEnumConnections::CEnumConnections
CEnumConnections::~CEnumConnections

Parameters (Constructor):
	pCP				pointer to object we're in.
===================================================================*/

CEnumConnections::CEnumConnections(CConnectionPoint *pCP)
	{
	Assert (pCP != NULL);

	m_cRefs = 1;
	m_pCP   = pCP;

	m_pCP->AddRef();
	Reset();
	}

CEnumConnections::~CEnumConnections()
	{
	m_pCP->Release();
	}



/*===================================================================
CEnumConnections::QueryInterface
CEnumConnections::AddRef
CEnumConnections::Release

IUnknown members for CEnumConnections object.
===================================================================*/

HRESULT CEnumConnections::QueryInterface(const GUID &iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumConnections)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

ULONG CEnumConnections::AddRef()
	{
	return ++m_cRefs;
	}

ULONG CEnumConnections::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CEnumConnections::Clone

Clone this iterator (standard method)
===================================================================*/

HRESULT CEnumConnections::Clone(IEnumConnections **ppEnumReturn)
	{
	CEnumConnections *pNewIterator = new CEnumConnections(m_pCP);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pElemCurr = m_pElemCurr;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CEnumConnections::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

HRESULT CEnumConnections::Next(unsigned long cElementsRequested, CONNECTDATA *rgConnectData, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pElemCurr != &m_pCP->m_listSinks)
		{
		rgConnectData->dwCookie = static_cast<CConnectionPoint::CSinkElem *>(m_pElemCurr)->m_dwCookie;
		rgConnectData->pUnk = static_cast<CConnectionPoint::CSinkElem *>(m_pElemCurr)->m_pUnkObj;
		rgConnectData->pUnk->AddRef();

		++rgConnectData;
		--cElements;
		++*pcElementsFetched;
		m_pElemCurr = m_pElemCurr->PNext();
		}

	// initialize the remaining structures
	//
	while (cElements-- > 0)
		(rgConnectData++)->pUnk = NULL;

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CEnumConnections::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

HRESULT CEnumConnections::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pElemCurr != &m_pCP->m_listSinks)
		{
		m_pElemCurr = m_pElemCurr->PNext();
		--cElements;
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CEnumConnections::Reset

Reset the iterator (standard method)
===================================================================*/

HRESULT CEnumConnections::Reset()
	{
	m_pElemCurr = m_pCP->m_listSinks.PNext();        
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\clcert.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: clcert.h

Owner: DGottner

This file contains the definiton of the CCookie class, which
contains all of the state for an HTTP cookie
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asptlb.h"
#include "dispatch.h"
#include "hashing.h"
#include "memcls.h"

class CClCert;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


/*
 * C C l C e r t S u p p o r t E r r
 *
 * Implements ISupportErrorInfo for the CClCert class. The CSupportError class
 * is not adequate because it will only report a max of one interface which
 * supports error info. (We have two)
 */
class CClCertSupportErr : public ISupportErrorInfo
	{
private:
	CClCert *	m_pClCert;

public:
	CClCertSupportErr(CClCert *pClCert);

	// IUnknown members that delegate to m_pClCert
	//
	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(const GUID &);
	};


/*
 * C R e a d C l C e r t
 *
 * Implements IClCert which is the interface that Request.ClientCert
 * returns.  It is an IRequestDictionary.
 */
class CReadClCert : public IRequestDictionaryImpl
	{
private:
	CClCert *			m_pClCert;

public:
	CReadClCert(CClCert *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IRequestDictionary implementation
	//
	STDMETHODIMP			get_Item(VARIANT i, VARIANT *pVariantReturn);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get_Key(VARIANT VarKey, VARIANT *pvar);
	};




/*
 * C C l C e r t
 *
 * Implements CClCert, which is the object stored in the Request.Cookies
 * dictionary.
 */
class CClCert : public IUnknown
	{
	friend CReadClCert;

protected:
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CReadClCert			m_ReadClCertInterface;		// implementation of IStringList
	CClCertSupportErr	m_ClCertSupportErrorInfo;	// implementation of ISupportErrorInfo

	char *				m_szValue;					// value of clcert when not a dictionary
    VARENUM             m_veType;
    UINT                m_cLen;

public:
	CClCert(IUnknown * = NULL, PFNDESTROYED = NULL);
	~CClCert();

	HRESULT AddValue(char *szValue, VARENUM ve = VT_BSTR, UINT l = 0 );

	size_t GetHTTPClCertSize();				// return information on how big a buffer should be
	char * GetHTTPClCert(char *szBuffer);	// return the clcert value HTTP encoded

	size_t GetClCertHeaderSize(const char *szName);				// return buffer size for header
	char *GetClCertHeader(const char *szName, char *szBuffer);	// return cookie header

	HRESULT		Init();

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const GUID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

//
// simple class to handle extensible buffer
// It is guaranteed that a portion of the buffer 
// can be appended to itself.
// extension is done on a XBF_EXTEND granularity
//

#define XBF_EXTEND  512

class XBF {

public:
    XBF( LPSTR pB, int cB ) { m_pV = pB; m_cAlloc = cB; m_cSize = 0; }
    ~XBF() {}
    void Reset() { m_cSize = 0; m_cAlloc = 0; m_pV = NULL; }

    // Append a string with '\0' delimiter

    LPSTR AddStringZ( LPSTR pszV, BOOL fXt = FALSE )
    {
        return AddBlob( pszV, strlen(pszV) +1, fXt );
    }

    // Append a string w/o '\0' delimiter

    LPSTR AddString( LPSTR pszV, BOOL fXt = FALSE )
    {
        return AddBlob( pszV, strlen(pszV), fXt );
    }

    // Append a byte range

    LPSTR AddBlob( LPSTR pszV, int cV, BOOL fXt = FALSE )
    {
        if ( m_cSize + cV > m_cAlloc )
        {
            if ( !fXt || !Extend( m_cSize + cV ) )
            {
                return NULL;
            }
        }

        LPSTR pV;
        memcpy( pV = m_pV + m_cSize, pszV, cV );
        m_cSize += cV;

        return pV;
    }

    LPSTR ReserveRange( int cV , int align = 1)
    {
        int curUsed = ((m_cSize + (align - 1)) & ~(align - 1));
        if ( (curUsed + cV) > m_cAlloc )
        {
            return NULL;
        }

        return m_pV + curUsed;
    }

    VOID SkipRange( int cV, int align = 1)
    {
        m_cSize += ((cV + (align - 1)) & ~(align - 1));
    }

    BOOL Extend( int cA );

    // pointer to buffer

    LPSTR QueryBuf() const { return m_pV; }

    // size of buffer

    int QuerySize() { return m_cSize; }

    int QueryAllocSize() { return m_cAlloc; }

private:
    int m_cAlloc;       // allocated memory
    int m_cSize;        // used memory
    LPSTR m_pV;         // buffer
} ;


class CCertRequest {
public:
    CCertRequest( CRequest* Req ) { pReq = Req; }
    ~CCertRequest() {}

    HRESULT AddStringPair( CollectionType Source, LPSTR szName, 
                           LPSTR szValue, XBF *pxbf, BOOL fDuplicate, UINT lCodePage );
    HRESULT AddDatePair( CollectionType Source, LPSTR szName, 
                           FILETIME* pValue, XBF *pxbf );
    HRESULT AddDwordPair( CollectionType Source, LPSTR szName, 
                           LPDWORD pValue, XBF *pxbf );
    HRESULT AddBinaryPair( CollectionType Source, LPSTR szName, 
                           LPBYTE pValue, DWORD cValue, XBF *pxbf, UINT lCodePage );
    HRESULT AddUuBinaryPair( CollectionType Source, LPSTR szName, 
                           LPBYTE pValue, DWORD cValue, XBF *pxbf, UINT lCodePage );
    HRESULT AddName( LPSTR szName, CRequestHit **ppReqHit, XBF *pxbf );
    HRESULT ParseRDNS( CERT_NAME_INFO* pNameInfo, LPSTR pszPrefix, XBF *pxbf, UINT lCodePage );
    HRESULT ParseCertificate( LPBYTE pCert, DWORD cCert, DWORD dwEncoding, DWORD dwFlags, UINT lCodePage );
    HRESULT NoCertificate();

private:
    CRequest *pReq;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\context.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ScriptingContext object

File: Context.cpp

Owner: DmitryR

This file contains the code for the implementation of the 
ScriptingContext object, which is passed to server controls
via the OnStartPage method.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "context.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
CScriptingContext::CScriptingContext

CScriptingContext constructor

Parameters:
    IApplicationObject *pAppln          Application
    ISessionObject     *pSession        Session
    IRequest           *pRequest        Request
    IResponse          *pResponse       Response
    IServer            *pServer         Server

Returns:
===================================================================*/
CScriptingContext::CScriptingContext
(
IApplicationObject *pAppln,
ISessionObject     *pSession,
IRequest           *pRequest,
IResponse          *pResponse,
IServer            *pServer
)
	: m_cRef(1),
	  m_pAppln(pAppln), m_pSession(pSession),
      m_pRequest(pRequest), m_pResponse(pResponse), m_pServer(pServer),
      m_ImpISuppErr(this, NULL, IID_IScriptingContext)
	{
	CDispatch::Init(IID_IScriptingContext);

    // AddRef Intrinsics -- they are now true COM objects
    if (m_pAppln)
        m_pAppln->AddRef();
    if (m_pSession)
        m_pSession->AddRef();
    if (m_pRequest)
        m_pRequest->AddRef();
    if (m_pResponse)
        m_pResponse->AddRef();
    if (m_pServer)
        m_pServer->AddRef();
	}

/*===================================================================
CScriptingContext::~CScriptingContext

CScriptingContext destructor

Parameters:

Returns:
===================================================================*/
CScriptingContext::~CScriptingContext()
    {
    Assert(m_cRef == 0);

    // Release Intrinsics
    if (m_pAppln)
        m_pAppln->Release();
    if (m_pSession)
        m_pSession->Release();
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pResponse)
        m_pResponse->Release();
    if (m_pServer)
        m_pServer->Release();
    }

/*===================================================================
IScriptingContext Interface Methods

CScriptingContext::Application
CScriptingContext::Session
CScriptingContext::Request
CScriptingContext::Response
CScriptingContext::Server

Parameters:
	[out] Intrinsic object pointer

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CScriptingContext::get_Request(IRequest **ppRequest)
	{
	if (m_pRequest)
	    {
    	m_pRequest->AddRef();
    	*ppRequest = m_pRequest;
    	return S_OK;
    	}
    else
        {
    	*ppRequest = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
        }
	}
	
STDMETHODIMP CScriptingContext::get_Response(IResponse **ppResponse)
	{
	if (m_pResponse)
	    {
    	m_pResponse->AddRef();
    	*ppResponse = m_pResponse;
    	return S_OK;
    	}
    else
        {
    	*ppResponse = m_pResponse;
    	return TYPE_E_ELEMENTNOTFOUND;
        }
	}

STDMETHODIMP CScriptingContext::get_Server(IServer **ppServer)
	{
	if (m_pServer)
	    {
	    m_pServer->AddRef();
    	*ppServer = m_pServer;
    	return S_OK;
	    }
	else
	    {
    	*ppServer = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}

STDMETHODIMP CScriptingContext::get_Session(ISessionObject **ppSession)
	{
	if (m_pSession)
	    {
	    m_pSession->AddRef();
    	*ppSession = m_pSession;
    	return S_OK;
	    }
	else
	    {
    	*ppSession = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}

STDMETHODIMP CScriptingContext::get_Application(IApplicationObject **ppAppln)
	{
	if (m_pAppln)
	    {
	    m_pAppln->AddRef();
    	*ppAppln = m_pAppln;
    	return S_OK;
	    }
	else
	    {
    	*ppAppln = NULL;
    	return TYPE_E_ELEMENTNOTFOUND;
	    }
	}


/*===================================================================
IUnknown Interface Methods

CScriptingContext::QueryInterface
CScriptingContext::AddRef
CScriptingContext::Release
===================================================================*/
STDMETHODIMP CScriptingContext::QueryInterface
(
REFIID riid,
PPVOID ppv
)
	{
	if (riid == IID_IUnknown  ||
	    riid == IID_IDispatch ||
	    riid == IID_IScriptingContext)
	    {
        AddRef();
		*ppv = this;
		}
	else if (riid == IID_IRequest)
        {
        if (FAILED(get_Request((IRequest **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IResponse)
        {
        if (FAILED(get_Response((IResponse **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IServer)
        {
        if (FAILED(get_Server((IServer **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_ISessionObject)
        {
        if (FAILED(get_Session((ISessionObject **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_IApplicationObject)
        {
        if (FAILED(get_Application((IApplicationObject **)ppv)))
           	return E_NOINTERFACE;
        }
	else if (riid == IID_ISupportErrorInfo)
	    {
        m_ImpISuppErr.AddRef();
		*ppv = &m_ImpISuppErr;
		}
	else
	    {
    	*ppv = NULL;
    	return E_NOINTERFACE;
        }
	    
	return S_OK;
	}

STDMETHODIMP_(ULONG) CScriptingContext::AddRef()
	{
	return ++m_cRef;
	}

STDMETHODIMP_(ULONG) CScriptingContext::Release()
	{
	if (--m_cRef)
		return m_cRef;
		
	delete this;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\clcert.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: clcert.cpp

Owner: DGottner

This file contains the code for the implementation of the 
Request.ClientCertificate
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include <schnlsp.h>

#include "objbase.h"
#include "request.h"
#include "clcert.h"

#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

#define UUENCODEDSIZE(a)  ((((a)+3)*4)/3+1)

#define BLOB_AS_ARRAY

HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    );

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};
     
char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

/*------------------------------------------------------------------
 * X B F
 */

BOOL XBF::Extend( int cA )
{
    if ( cA > m_cAlloc )
    {
        int cNew = (( cA + XBF_EXTEND )/XBF_EXTEND)*XBF_EXTEND;
        LPSTR pN = (LPSTR)malloc( cNew );
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_cSize )
        {
            memcpy( pN, m_pV, m_cSize );
        }
        if ( m_cAlloc )
        {
            free( m_pV );
        }
        m_pV = pN;
        m_cAlloc = cNew;
    }
    return TRUE;
}

/*------------------------------------------------------------------
 * C C l C e r t S u p p o r t E r r
 */

/*===================================================================
CClCertSupportErr::CClCertSupportErr

constructor
===================================================================*/

CClCertSupportErr::CClCertSupportErr(CClCert *pClCert)
{
    m_pClCert = pClCert;
}



/*===================================================================
CClCertSupportErr::QueryInterface
CClCertSupportErr::AddRef
CClCertSupportErr::Release

Delegating IUnknown members for CClCertSupportErr object.
===================================================================*/

STDMETHODIMP CClCertSupportErr::QueryInterface(const IID &idInterface, void **ppvObj)
{
    return m_pClCert->QueryInterface(idInterface, ppvObj);
}

STDMETHODIMP_(ULONG) CClCertSupportErr::AddRef()
{
    return m_pClCert->AddRef();
}

STDMETHODIMP_(ULONG) CClCertSupportErr::Release()
{
    return m_pClCert->Release();
}



/*===================================================================
CClCertSupportErr::InterfaceSupportsErrorInfo

Report back to OA about which interfaces we support that return
error information
===================================================================*/

STDMETHODIMP CClCertSupportErr::InterfaceSupportsErrorInfo(const GUID &idInterface)
{
    if (idInterface == IID_IDispatch)
        return S_OK;

    return S_FALSE;
}



/*------------------------------------------------------------------
 * C R e a d C l C e r t
 */

/*===================================================================
CReadClCert::CReadClCert

constructor
===================================================================*/

CReadClCert::CReadClCert(CClCert *pClCert)
{
    m_pClCert = pClCert;
    CDispatch::Init(IID_IRequestDictionary);
}



/*===================================================================
CReadClCert::QueryInterface
CReadClCert::AddRef
CReadClCert::Release

Delegating IUnknown members for CReadClCert object.
===================================================================*/

STDMETHODIMP CReadClCert::QueryInterface(const IID &idInterface, void **ppvObj)
{
    return m_pClCert->QueryInterface(idInterface, ppvObj);
}

STDMETHODIMP_(ULONG) CReadClCert::AddRef()
{
    return m_pClCert->AddRef();
}

STDMETHODIMP_(ULONG) CReadClCert::Release()
{
    return m_pClCert->Release();
}


/*===================================================================
CReadClCert::get_Item

Retrieve a value in the clcert dictionary.
===================================================================*/

STDMETHODIMP CReadClCert::get_Item(VARIANT varKey, VARIANT *pVarReturn)
{
    VariantInit(pVarReturn);                // default return value is Empty
    VARIANT *pvarKey = &varKey;
    HRESULT hres;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    if (V_VT(pvarKey) != VT_BSTR) {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
    }

    switch (V_VT(pvarKey)) {
        case VT_BSTR:
            break;
        
        case VT_ERROR:
            if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND) {
                // simple value, URLEncoding NOT a good idea in this case
                if (m_pClCert->m_szValue) {
                    V_VT(pVarReturn) = VT_BSTR;
                    switch( m_pClCert->m_veType ) {
                        case VT_BSTR: {
                            BSTR bstrT;
                            if ( FAILED(SysAllocStringFromSz(m_pClCert->m_szValue, 0, &bstrT )) ) {
                                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                                VariantClear(&varKeyCopy);
                                return E_FAIL;
                            }
                            V_BSTR(pVarReturn) = bstrT;
                            break;
                        }
                                                
                        case VT_DATE:
                            V_VT(pVarReturn) = VT_DATE;
                            V_DATE(pVarReturn) = *(UNALIGNED64 DATE*)m_pClCert->m_szValue;
                            break;

                        case VT_I4:
                            V_VT(pVarReturn) = VT_I4;
                            V_I4(pVarReturn) = *(UNALIGNED64 DWORD*)m_pClCert->m_szValue;
                            break;

                        case VT_BLOB:
#if defined(BLOB_AS_ARRAY)
                            if ( FAILED( hres = SetVariantAsByteArray( pVarReturn, 
                                                                       m_pClCert->m_cLen, 
                                                                       (LPBYTE)m_pClCert->m_szValue ) ) ) {
                                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                                VariantClear(&varKeyCopy);
                                return hres;
                            }
#else
                            V_BSTR(pVarReturn) = SysAllocStringByteLen(m_pClCert->m_szValue, m_pClCert->m_cLen );
#endif
                            break;

                        default:
                            Assert( FALSE );
                    }
                }
                        
                // dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
                else {
                }

                VariantClear(&varKeyCopy);
                return S_OK;
            }

        default:
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
            VariantClear(&varKeyCopy);
            return E_FAIL;
    }
LExit:
    VariantClear(&varKeyCopy);
    return S_OK;
}

/*===================================================================
CReadClCert::get_Key

Function called from DispInvoke to get keys from the QueryString collection.

Parameters:
        vKey            VARIANT [in], which parameter to get the key of
        pvarReturn      VARIANT *, [out] value of the requested parameter

Returns:
        S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CReadClCert::get_Key(VARIANT varKey, VARIANT *pVar)
{
    return E_NOTIMPL;
}

/*===================================================================
CReadClCert::get_Count

Parameters:
        pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CReadClCert::get_Count(int *pcValues)
{
    HRESULT hrReturn = S_OK;

    *pcValues = 0;

    return hrReturn;
}

/*===================================================================
CReadClCert::get__NewEnum

Return an enumerator object.
===================================================================*/

STDMETHODIMP CReadClCert::get__NewEnum(IUnknown **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}



/*------------------------------------------------------------------
 * C C l C e r t
 */

/*===================================================================
CClCert::CClCert

constructor
===================================================================*/

CClCert::CClCert(IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
    : m_ReadClCertInterface(this),
      m_ClCertSupportErrorInfo(this)
{
    m_szValue    = NULL;
    m_veType     = VT_BSTR;
    m_pfnDestroy = pfnDestroy;
    m_cRefs      = 1;
}



/*===================================================================
CClCert::~CClCert

Destructor
===================================================================*/

CClCert::~CClCert()
{
}



/*===================================================================
CClCert::Init

initialize the clcert. This initializes the clcert's value hashing
table
===================================================================*/

HRESULT CClCert::Init()
{
    return S_OK;
}



/*===================================================================
CClCert::QueryInterface
CClCert::AddRef
CClCert::Release

IUnknown members for CClCert object.

Note on CClCert::QueryInterface: The Query for IDispatch is
ambiguous because it can either refer to DIRequestDictionary or
DIWriteClCert.  To resolve this, we resolve requests for IDispatch
to IRequestDictionary.
===================================================================*/

STDMETHODIMP CClCert::QueryInterface(const IID &idInterface, void **ppvObj)
{
    if (idInterface == IID_IUnknown)
        *ppvObj = this;

    else if (idInterface == IID_IRequestDictionary || idInterface == IID_IDispatch)
        *ppvObj = &m_ReadClCertInterface;

    else if (idInterface == IID_ISupportErrorInfo)
        *ppvObj = &m_ClCertSupportErrorInfo;

    else
        *ppvObj = NULL;

    if (*ppvObj != NULL)
    {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CClCert::AddRef()
{
    return ++m_cRefs;
}


STDMETHODIMP_(ULONG) CClCert::Release(void)
{
    if (--m_cRefs != 0)
        return m_cRefs;

    if (m_pfnDestroy != NULL)
        (*m_pfnDestroy)();

    delete this;
    return 0;
}



/*===================================================================
CClCert::AddValue

Set the clcert's primary value. One you set the primary value,
you can't reset it.
===================================================================*/

HRESULT CClCert::AddValue(char *szValue, VARENUM ve, UINT l )
{
    if (m_szValue != NULL)          // clcert already is marked as single-valued
        return E_FAIL;

    m_szValue = szValue;

    m_veType = ve;
    m_cLen = l;
    return S_OK;
}



/*===================================================================
CClCert::GetHTTPClCertSize

Return the number of bytes required for the expansion of the clcert
===================================================================*/

size_t CClCert::GetHTTPClCertSize()
        {
        if (m_szValue)
                return URLEncodeLen(m_szValue);
    else
        return 1;
        }


/*===================================================================
CClCert::GetHTTPClCert

Return the URL Encoded value a single clcert

Parameters:
        szBuffer -  pointer to the destination buffer to store the
                                URL encoded value

Returns:
        Returns a pointer to the terminating NUL character.
===================================================================*/

char *CClCert::GetHTTPClCert(char *szBuffer)
{
    if (m_szValue)
        return URLEncode(szBuffer, m_szValue);

    else
    {
        char *szDest = szBuffer;
        *szDest = '\0';

        return szDest;
    }
}



/*===================================================================
CClCert::GetClCertHeaderSize

Return the number of bytes required to allocate for the "Set-ClCert" header.

Parameters:
        szName - the name of the cookie (the size of the name is added to the value)

Returns:
        Returns 0 if *this does not contain a cookie value.
===================================================================*/

size_t CClCert::GetClCertHeaderSize(const char *szName)
{
    int cbClCert = sizeof "Set-ClCert: ";           // initialize and add NUL terminator now

    // Add size of the URL Encoded name, a character for the '=', and the size
    // of the URL Encoded cookie value.  URLEncodeLen, and GetHttpClCertSize
    // compensate for the NUL terminator, so we actually SUBTRACT 1. (-2 for
    // these two function calls, +1 for the '=' sign
    //
    cbClCert += URLEncodeLen(szName) + GetHTTPClCertSize() - 1;
    
    return cbClCert;
}



/*===================================================================
CClCert::GetClCertHeader

Construct the appropriate "Set-ClCert" header for a clcert.

Parameters:
        szName - the name of the clcert (the size of the name is added to the value)

Returns:
        Returns 0 if *this does not contain a clcert value.
===================================================================*/

char *CClCert::GetClCertHeader(const char *szName, char *szBuffer)
{
    // write out the clcert name and value
    //
    char *szDest = strcpyExA(szBuffer, "Set-ClCert: ");
    szDest = URLEncode(szDest, szName);
    szDest = strcpyExA(szDest, "=");
    szDest = GetHTTPClCert(szDest);
    
    return szDest;
}



/*------------------------------------------------------------------
 * C C e r t R e q u e s t
 */


/*===================================================================
CCertRequest::AddStringPair

Add a string element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    szValue - ptr to value as string
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddStringPair( 
    CollectionType Source, 
    LPSTR szName, 
    LPSTR szValue,
    XBF *pxbf,
    BOOL fDuplicate,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;

    if ( fDuplicate )
    {
        if ( (szValue = pxbf->AddStringZ( szValue )) == NULL )
        {
            return E_OUTOFMEMORY;
        }
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        if ( hResult == E_FAIL )
        {
            // assume duplicate value found
            // if out of memore, OUT_OF_MEMORY would have been returned

            hResult = S_OK;
        }
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddValue( Source, szValue, NULL, lCodePage )))
    {
        return hResult;
    }

    return S_OK;
}


/*===================================================================
CCertRequest::AddDatePair

Add a date element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to date as FILETIME
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddDatePair( 
    CollectionType Source, 
    LPSTR szName, 
    FILETIME* pValue,
    XBF *pxbf
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    DATE Date;
    SYSTEMTIME st;
    LPBYTE pVal;

    if ( !FileTimeToSystemTime( pValue, &st ) )
    {
        return E_FAIL;
    }

    SystemTimeToVariantTime( &st, &Date );

    if ( (pVal = (LPBYTE)pxbf->AddBlob( (LPSTR)&Date, sizeof(Date) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_DATE, pVal, sizeof(Date) )))
    {
        return hResult;
    }

    return S_OK;
}




/*===================================================================
CCertRequest::AddDwordPair

Add a DWORD element in the collection

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to date as DWORD
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddDwordPair( 
    CollectionType Source, 
    LPSTR szName, 
    DWORD* pValue,
    XBF *pxbf
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

    if ( (pVal = (LPBYTE)pxbf->AddBlob( (LPSTR)pValue, sizeof(DWORD) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_I4, pVal, sizeof(DWORD) )))
    {
        return hResult;
    }

    return S_OK;
}




/*===================================================================
CCertRequest::AddBinaryPair

Add a binary element in the collection
Each byte is converted to UNICODE character so that mid() & asc() work

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to value as byte array
    cValue - # of bytes pointed to by pValue
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddBinaryPair( 
    CollectionType Source, 
    LPSTR szName, 
    LPBYTE pValue,
    DWORD cValue,
    XBF *pxbf,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

#if defined(BLOB_AS_ARRAY)

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( cValue )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pVal, pValue, cValue );

    pxbf->SkipRange( cValue );

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_BLOB, pVal, cValue )))
    {
        return hResult;
    }

#else

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( cValue * sizeof(WCHAR), sizeof(WCHAR))) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if ( !(cValue = MultiByteToWideChar( lCodePage, 0, (LPSTR)pValue, cValue, (WCHAR*)pVal, cValue)) )
    {
        return E_FAIL;
    }

    pxbf->SkipRange( cValue * sizeof(WCHAR), sizeof(WCHAR));

    if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
        return hResult;
    }

    if (FAILED(hResult = pReqHit->AddCertValue( VT_BLOB, pVal, cValue * sizeof(WCHAR) )))
    {
            return hResult;
    }

#endif

    return S_OK;
}


BOOL IISuuencode( BYTE *   bufin,
               DWORD    nbytes,
               BYTE *   outptr,
               BOOL     fBase64 )
{
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;

   for (i=0; i<nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if(i == nbytes+1) {
      /* There were only 2 bytes in that last group */
      outptr[-1] = '=';
   } else if(i == nbytes+2) {
      /* There was only 1 byte in that last group */
      outptr[-1] = '=';
      outptr[-2] = '=';
   }

   *outptr = '\0';

   return TRUE;
}

/*===================================================================
CCertRequest::AddUuBinaryPair

Add a binary element in the collection
buffer is uuencoded then converted to UNICODE character so that mid() & asc() work

Parameters:
        Source - variable type ( CLCERT, COOKIE, ... )
    szName - name of element
    pValue - ptr to value as byte array
    cValue - # of bytes pointed to by pValue
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddUuBinaryPair( 
    CollectionType Source, 
    LPSTR szName, 
    LPBYTE pValue,
    DWORD cValue,
    XBF *pxbf,
    UINT lCodePage
    )
{
    HRESULT hResult;
    CRequestHit *pReqHit;
    LPBYTE pVal;

    if ( (pVal = (LPBYTE)pxbf->ReserveRange( UUENCODEDSIZE(cValue) )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if ( !IISuuencode( (LPBYTE)pValue, cValue, pVal, FALSE ) )
    {
        return E_FAIL;
    }

    Assert( (strlen((LPSTR)pVal)+1) <= UUENCODEDSIZE(cValue) );

    pxbf->SkipRange( strlen((LPSTR)pVal)+1 );

        if (FAILED(hResult = AddName( szName, &pReqHit, pxbf)))
    {
                return hResult;
    }

        if (FAILED(hResult = pReqHit->AddValue( Source, (LPSTR)pVal, NULL, lCodePage )))
    {
                return hResult;
    }

    return S_OK;
}


/*===================================================================
CCertRequest::AddName

Add a named entry to the collection

Parameters:
        szName - name of entry
    ppReqHit - updated with ptr to created entry
    pxbf - ptr to buffer where to store name

Returns:
        S_OK if success, E_OUTOFMEMORY or E_FAIL otherwise
===================================================================*/

HRESULT 
CCertRequest::AddName( 
    LPSTR szName, 
    CRequestHit **ppReqHit,
    XBF *pxbf
    )
{
    if ( (szName = pxbf->AddStringZ( szName )) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    // Add this object to the Request
    CRequestHit *pRequestHit = (CRequestHit *)(pReq->CertStoreFindElem(szName, strlen(szName)));
    if (pRequestHit == NULL)
    {
        pRequestHit = new CRequestHit;
        if (pRequestHit == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if (FAILED(pRequestHit->Init(szName)))
        {
            delete pRequestHit;
            return E_FAIL;
        }

        pReq->CertStoreAddElem( (CLinkElem*) pRequestHit );
    }
    else if (pRequestHit->m_pClCertData)    // a clcert by this name already exists
    {
        return E_FAIL;
    }

    if (!pReq->m_pData->m_ClCerts.AddRequestHit(pRequestHit))
    {
        return E_OUTOFMEMORY;
    }

    *ppReqHit = pRequestHit;

    return S_OK;
}


typedef struct _MAP_ASN {
    LPSTR pAsnName;
    LPSTR pTextName;
} MAP_ASN;


//
// definition of ASN.1 <> X.509 name conversion
//

MAP_ASN aMapAsn[] = {
    { szOID_COUNTRY_NAME, "C" },
    { szOID_ORGANIZATION_NAME, "O" },
    { szOID_ORGANIZATIONAL_UNIT_NAME, "OU" },
    { szOID_COMMON_NAME, "CN" },
    { szOID_LOCALITY_NAME, "L" },
    { szOID_STATE_OR_PROVINCE_NAME, "S" },
    { szOID_TITLE, "T" },
    { szOID_GIVEN_NAME, "GN" },
    { szOID_INITIALS, "I" },
    { "1.2.840.113549.1.9.1", "EMAIL" },
} ;


LPSTR MapAsnName(
    LPSTR pAsnName
    )
/*++

Routine Description:

    Convert ASN.1 name ( as ANSI string ) to X.509 member name

Arguments:

    pAsnName - ASN.1 name

Return Value:

    ptr to converted name if ASN.1 name was recognized, else ASN.1 name

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++x )
    {
        if ( !strcmp( pAsnName, aMapAsn[x].pAsnName ) )
        {
            return aMapAsn[x].pTextName;
        }
    }

    return pAsnName;
}


BOOL
DecodeRdn( 
    CERT_NAME_BLOB* pNameBlob,
    PCERT_NAME_INFO* ppNameInfo
    )
/*++

Routine Description:

    Create a PNAME_INFO from PNAME_BLOB

Arguments:

    pNameBlob - ptr to name blob to decode
    ppNameInfo - updated with ptr to name info

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PCERT_NAME_INFO     pNameInfo = NULL;
    DWORD               cbNameInfo;

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                          (LPCSTR)X509_NAME,
                          pNameBlob->pbData,
                          pNameBlob->cbData,
                          0,
                          NULL,
                          &cbNameInfo))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_CERTIFICATE_BAD_CERT);
        return FALSE;
    }

    if (NULL == (pNameInfo = (PCERT_NAME_INFO)malloc(cbNameInfo)))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return FALSE;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           (LPCSTR)X509_NAME,
                           pNameBlob->pbData,
                           pNameBlob->cbData,
                           0,
                           pNameInfo,
                           &cbNameInfo))
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_CERTIFICATE_BAD_CERT);
        free( pNameInfo );
        return FALSE;
    }

    *ppNameInfo = pNameInfo;

    return TRUE;
}


VOID
FreeDecodedRdn(
    PCERT_NAME_INFO pNameInfo
    )
/*++

Routine Description:

    Free a PNAME_BLOB created by DecodeRdn()

Arguments:

    pNameInfo - ptr to name info created by DecodeRdn()

Return Value:

    None

--*/
{
    free( pNameInfo );
}


BOOL
BuildRdnList(
    PCERT_NAME_INFO pNameInfo,
    XBF* pxbf,
    BOOL fXt
    )
/*++

Routine Description:

    Build a clear text representation of the Rdn list in pNameInfo
    Format as "C=US, O=Ms, CN=name"

Arguments:

    pNameInfo - ptr to name info
    pxbf - ptr to buffer receiving output
    fXt - TRUE if buffer to be extended, FALSE does not extend ( buffer 
          must be big enough before calling this function or FALSE will
          be returned )

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD               cRDN;
    DWORD               cAttr;
    PCERT_RDN           pRDN;
    PCERT_RDN_ATTR      pAttr;
    BOOL                fFirst = TRUE;

    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( !fFirst )
            {
                if ( !pxbf->AddBlob( ", ", sizeof(", ")-1, fXt ) )
                {
                    return FALSE;
                }
            }
            else
            {
                fFirst = FALSE;
            }

            if ( pAttr->dwValueType == CERT_RDN_UNICODE_STRING )
            {
                INT                 iRet;
                BYTE                abBuffer[ 512 ];
                DWORD               cbNameBuffer;
                PBYTE               pNameBuffer = NULL;
                
                //
                // Need to convert unicode string to MBCS :(
                //

                iRet = WideCharToMultiByte( CP_ACP,
                                            0,
                                            (LPWSTR) pAttr->Value.pbData,
                                            -1,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL );

                if ( !iRet )
                {
                    return FALSE;
                }
                else
                {
                    cbNameBuffer = (DWORD) iRet;
                    if ( (DWORD) iRet > sizeof( abBuffer ) )
                    {
                        pNameBuffer = (PBYTE) LocalAlloc( LPTR,
                                                          (DWORD) iRet );
                        if ( !pNameBuffer )
                        {
                            return FALSE;
                        }
                    }
                    else
                    {
                        pNameBuffer = abBuffer;
                    }
                }

                iRet = WideCharToMultiByte( CP_ACP,
                                            0,
                                            (LPWSTR) pAttr->Value.pbData,
                                            -1,
                                            (LPSTR) pNameBuffer,
                                            cbNameBuffer,
                                            NULL,
                                            NULL );

                if ( !iRet )
                {
                    if ( pNameBuffer != abBuffer )
                    {
                        LocalFree( pNameBuffer );
                    }
                    return FALSE;
                }

                //
                // Now stuff the MBCS string back into the blob.  I do this
                // because there is other code that re-reads and re-processes
                // the CRYPTAPI blob.  
                //

                if ( cbNameBuffer <= pAttr->Value.cbData )
                {
                    memcpy( pAttr->Value.pbData,
                            pNameBuffer,
                            cbNameBuffer );
                    pAttr->Value.cbData = cbNameBuffer;
                    pAttr->dwValueType = CERT_RDN_OCTET_STRING;
                }

                if ( pNameBuffer != abBuffer )
                {
                    LocalFree( pNameBuffer );
                    pNameBuffer = NULL;
                }
            }
            
            if ( !pxbf->AddString( MapAsnName( pAttr->pszObjId ), fXt ) ||
                 !pxbf->AddBlob( "=", sizeof("=")-1, fXt ) ||
                 !pxbf->AddString( (LPSTR) pAttr->Value.pbData, fXt ) )
            {
                return FALSE;
            }
        }
    }

    return pxbf->AddBlob( "", sizeof(""), fXt ) != NULL;
}
        

/*===================================================================
CCertRequest::ParseRDNS

Function called to parse a certificate into a OA collection

Parameters:
        pNameInfo - ptr to name structure ( cf. CAPI 2 )
    pszPrefix - prefix to prepend to members name
    pxbf - ptr to buffer to hold result

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::ParseRDNS( 
    PCERT_NAME_INFO pNameInfo,
    LPSTR pszPrefix,
    XBF *pxbf,
    UINT lCodePage
    )
{
    DWORD               cRDN;
    DWORD               cAttr;
    PCERT_RDN           pRDN;
    PCERT_RDN_ATTR      pAttr;
    DWORD               cRDNs;
    DWORD               cAttrs;
    PCERT_RDN           pRDNs;
    PCERT_RDN_ATTR      pAttrs;
    LPSTR               pszFullName = NULL;
    HRESULT             hRes = S_OK;
    LPSTR               pName;
    UINT                cL;
    LPSTR               pVal = NULL;


    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( pAttr->dwValueType & 0x80000000 )
            {
                continue;
            }

            // scan for attr of same name

            pAttr->dwValueType |= 0x80000000;
            cL = 0;
            pVal = NULL;
            for ( cRDNs = cRDN, pRDNs = pRDN; 
                  cRDNs > 0; 
                  cRDNs--, pRDNs++)
            {
                for ( cAttrs = pRDNs->cRDNAttr, pAttrs = pRDNs->rgRDNAttr ; 
                      cAttrs > 0 ; 
                      cAttrs--, ++pAttrs )
                {
                    if ( !(pAttrs->dwValueType & 0x80000000) &&
                         !strcmp( pAttr->pszObjId, pAttrs->pszObjId ) )
                    {
                        cL += strlen( (LPSTR)pAttrs->Value.pbData ) + 1;
                    }                    
                }
            }

            //
            // if attributes of the same name found, concatenate their
            // values separated by ';'
            //

            if ( cL )
            {
                pVal = (LPSTR)malloc( cL + strlen((LPSTR)pAttr->Value.pbData) + 1 );
                if ( pVal == NULL )
                {
                    return E_OUTOFMEMORY;
                }
                strcpy( pVal, (LPSTR)pAttr->Value.pbData );
                for ( cRDNs = cRDN, pRDNs = pRDN; 
                      cRDNs > 0; 
                      cRDNs--, pRDNs++)
                {
                    for ( cAttrs = pRDNs->cRDNAttr, pAttrs = pRDNs->rgRDNAttr ; 
                          cAttrs > 0 ; 
                          cAttrs--, ++pAttrs )
                    {
                        if ( !(pAttrs->dwValueType & 0x80000000) &&
                             !strcmp( pAttr->pszObjId, pAttrs->pszObjId ) )
                        {
                            strcat( pVal, ";" );
                            strcat( pVal, (LPSTR)pAttrs->Value.pbData );
                            pAttrs->dwValueType |= 0x80000000;
                        }                    
                    }
                }
            }

            pName = MapAsnName( pAttr->pszObjId );
            if ( (pszFullName = (LPSTR)malloc( strlen(pszPrefix)+strlen(pName)+1 )) == NULL )
            {
                hRes = E_OUTOFMEMORY;
                goto cleanup;
            }
            strcpy( pszFullName, pszPrefix );
            strcat( pszFullName, pName );
            if ( (hRes = AddStringPair( CLCERT, 
                                        pszFullName,
                                        pVal ? pVal : (LPSTR)pAttr->Value.pbData, 
                                        pxbf,
                                        TRUE,
                                        lCodePage )) != S_OK )
            {
                if ( pVal != NULL )
                {
                    free( pVal );
                }
                goto cleanup;
            }
            if ( pVal != NULL )
            {
                free( pVal );
                pVal = NULL;
            }
            free( pszFullName );
            pszFullName = NULL;
        }
    }

cleanup:
    if ( pszFullName != NULL )
    {
        free( pszFullName );
    }

    return hRes;
}
        

/*===================================================================
CCertRequest::ParseCertificate

Function called to parse a certificate into a OA collection

Parameters:
        pspcRCI - client certificate structure

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::ParseCertificate( 
    LPBYTE      pbCert,
    DWORD       cCert,
    DWORD       dwEncoding,
    DWORD       dwFlags,
    UINT        lCodePage
    )
{
    XBF                 xbf( pReq->GetCertStoreBuf(), pReq->GetCertStoreSize() );
    HRESULT             hRes = S_OK;
    PCERT_NAME_INFO     pNameInfo = NULL;
    UINT                cStore;
    UINT                x;
    LPSTR               pVal;
    PCCERT_CONTEXT      pCert;


    if (NULL == (pCert = CertCreateCertificateContext(dwEncoding,
                                                      pbCert,
                                                      cCert))) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }

    // estimate size of buffer holding values

    cStore = pCert->cbCertEncoded +          // for clear text format
             sizeof("ISSUER") +
             sizeof("BINARYISSUER") + (UUENCODEDSIZE(pCert->pCertInfo->Issuer.cbData)*sizeof(WCHAR)) +
             sizeof("BINARYSUBJECT") + (UUENCODEDSIZE(pCert->pCertInfo->Subject.cbData)*sizeof(WCHAR)) +
             sizeof("SUBJECT") + ((pCert->cbCertEncoded + 2) * 2 * sizeof(WCHAR)) +     // store fields
             sizeof("CERTIFICATE") + ((pCert->cbCertEncoded +2)* sizeof(WCHAR)) +
             sizeof("SERIALNUMBER") + (pCert->pCertInfo->SerialNumber.cbData * 3) +
             sizeof("PUBLICKEY") + ((pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData+2) * sizeof(WCHAR)) +
             sizeof("VALIDFROM") + sizeof(DATE) +
             sizeof("VALIDUNTIL") + sizeof(DATE) +
             sizeof("FLAGS") + sizeof(DWORD) +
             sizeof("ENCODING") + sizeof(DWORD);
           ;

    if ( !xbf.Extend( cStore ) ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // Build Issuer clear text format & fields collection
    //

    if ( !DecodeRdn( &pCert->pCertInfo->Issuer, &pNameInfo ) )
    {
        hRes = E_FAIL;
        goto cleanup;
    }
    pVal = xbf.ReserveRange( 0 );
    if ( !BuildRdnList( pNameInfo, &xbf, FALSE ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }
    if ( (hRes = AddStringPair( CLCERT, "ISSUER", pVal, &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddUuBinaryPair( CLCERT, 
                                "BINARYISSUER", 
                                pCert->pCertInfo->Issuer.pbData, 
                                pCert->pCertInfo->Issuer.cbData, 
                                &xbf,
                                lCodePage ))!=S_OK ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=ParseRDNS( pNameInfo, "ISSUER", &xbf, lCodePage )) != S_OK ) {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    FreeDecodedRdn( pNameInfo );

    //
    // Build Subject clear text format & fields collection
    //

    if ( !DecodeRdn( &pCert->pCertInfo->Subject, &pNameInfo ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_FAIL;
    }
    pVal = xbf.ReserveRange( 0 );
    if ( !BuildRdnList( pNameInfo, &xbf, FALSE ) )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hRes = E_FAIL;
        goto cleanup;
    }
    if ( (hRes = AddStringPair( CLCERT, "SUBJECT", pVal, &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddUuBinaryPair( CLCERT, 
                                "BINARYSUBJECT", 
                                pCert->pCertInfo->Subject.pbData, 
                                pCert->pCertInfo->Subject.cbData, 
                                &xbf,
                                lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=ParseRDNS( pNameInfo, "SUBJECT", &xbf, lCodePage )) != S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    FreeDecodedRdn( pNameInfo );

    if ( (hRes=AddBinaryPair( CLCERT, "CERTIFICATE", pCert->pbCertEncoded, pCert->cbCertEncoded, &xbf, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    //
    //  SerialNumber 
    //  The certificate's serial number. (Decoded as a multiple byte integer. 
    //  SerialNumber.pbData[0] is the least significant byte. SerialNumber.pbData[
    //  SerialNumber.cbData - 1] is the most significant byte.)
    //
    char achSerNum[128];
    UINT cbSN;

    DBG_ASSERT(pCert->pCertInfo->SerialNumber.cbData > 1);
    cbSN = pCert->pCertInfo->SerialNumber.cbData;
    if (cbSN > 0)
    {
        cbSN--;
    }
    else
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }
    
    UINT iOffSet;
    for ( x = 0, iOffSet = 0; x < pCert->pCertInfo->SerialNumber.cbData ; ++x )
    {
        iOffSet = (cbSN-x)*3;   // start with the least significant byte
        achSerNum[iOffSet] = "0123456789abcdef"[((LPBYTE)pCert->pCertInfo->SerialNumber.pbData)[x]>>4];
        achSerNum[iOffSet+1] = "0123456789abcdef"[pCert->pCertInfo->SerialNumber.pbData[x]&0x0f];
        if ( x != 0 ) {
            achSerNum[iOffSet+2] = '-';
        }
        else
        {
            achSerNum[iOffSet+2] = '\0';
        }
    }

    if ( (hRes=AddStringPair( CLCERT, "SERIALNUMBER", achSerNum, &xbf, TRUE, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddBinaryPair( CLCERT, "PUBLICKEY", pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData, pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData, &xbf, lCodePage ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDFROM", &pCert->pCertInfo->NotBefore, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDUNTIL", &pCert->pCertInfo->NotAfter, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDwordPair( CLCERT, "FLAGS", &dwFlags, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

    if ( (hRes=AddDwordPair( CLCERT, "ENCODING", &dwEncoding, &xbf ))!=S_OK )
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        goto cleanup;
    }

cleanup:
    if ( pCert )
    {
        CertFreeCertificateContext( pCert );
    }
    
    pReq->SetCertStore( xbf.QueryBuf(), xbf.QueryAllocSize() );

    xbf.Reset();

    return hRes;
}


/*===================================================================
CCertRequest::NoCertificate

Function called to create NULL certificate info into a OA collection

Parameters:
        None

Returns:
        S_OK on success, E_OUTOFMEMORY if out of memory or E_FAIL for
    other errors
===================================================================*/

HRESULT
CCertRequest::NoCertificate( 
    )
{
#if 1

    return S_OK;

#else

    XBF                 xbf( pReq->GetCertStoreBuf(), pReq->GetCertStoreSize() );
    HRESULT             hRes = S_OK;
    UINT                cStore;
    FILETIME            ft;

    // estimate size of buffer holding values

    cStore = 
             sizeof("ISSUER") + 2*sizeof(WCHAR) +
             sizeof("BINARYISSUER") + 2*sizeof(WCHAR) +
             sizeof("BINARYSUBJECT") + 2*sizeof(WCHAR) +
             sizeof("SUBJECT") + 2*sizeof(WCHAR) +
             sizeof("CERTIFICATE") + 2 * sizeof(WCHAR) +
             sizeof("SERIALNUMBER") + 2 * sizeof(WCHAR) +
             sizeof("PUBLICKEY") + 2 * sizeof(WCHAR) +
             sizeof("VALIDFROM") + sizeof(DATE) +
             sizeof("VALIDUNTIL") + sizeof(DATE)
           ;

    if ( !xbf.Extend( cStore ) )
    {
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }

    ft.dwLowDateTime = 0;
    ft.dwHighDateTime = 0;

    //
    // Build Issuer clear text format & fields collection
    //

    if ( (hRes = AddStringPair( CLCERT, "ISSUER", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "BINARYISSUER", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "SUBJECT", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "BINARYSUBJECT", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes = AddStringPair( CLCERT, "CERTIFICATE", "", &xbf, FALSE, lCodePage ))
         != S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddStringPair( CLCERT, "SERIALNUMBER", "", &xbf, TRUE, lCodePage ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddStringPair( CLCERT, "PUBLICKEY", "", &xbf, TRUE, lCodePage ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDFROM", &ft, &xbf ))!=S_OK )
    {
        goto cleanup;
    }

    if ( (hRes=AddDatePair( CLCERT, "VALIDUNTIL", &ft, &xbf ))!=S_OK )
    {
        goto cleanup;
    }

cleanup:

    pReq->SetCertStore( xbf.QueryBuf(), xbf.QueryAllocSize() );

    xbf.Reset();

    return hRes;

#endif
}


/*===================================================================
RequestSupportTerminate

Function called to initialize certificate support

Parameters:
        None

Returns:
        TRUE on success, otherwise FALSE
===================================================================*/

BOOL 
RequestSupportInit(
    )
{
    return TRUE;
}


/*===================================================================
RequestSupportTerminate

Function called to terminate certificate support

Parameters:
        None

Returns:
        Nothing
===================================================================*/

VOID
RequestSupportTerminate(
    )
{
}


HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
/*++

Routine Description:

    Create variant as byte array

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
    HRESULT         hr;
    SAFEARRAYBOUND  rgsabound[1];
    BYTE *          pbData = NULL;

    // Set the variant type of the output parameter

    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    // Allocate a SafeArray for the data

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbLen;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
    {
        return E_UNEXPECTED;
    }

    memcpy(pbData, pbIn, cbLen );

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\compcol.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Component Collection

File: Compcol.cpp

Owner: DmitryR

This is the Component Collection source file.

Component collection replaces:  (used in:)
COleVar, COleVarList            (HitObj, Session, Application)
CObjectCover                    (HitObj, Server, Session)
VariantLink HasTable            (Session, Application)
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Context.h"
#include "MTAcb.h"
#include "Request.h"
#include "Response.h"
#include "Server.h"
#include "tlbcache.h"
#include "memchk.h"

/*===================================================================
  Defines for hash table sizes
===================================================================*/

#define HT_TAGGED_OBJECTS_BUCKETS_MAX   19
#define HT_PROPERTIES_BUCKETS_MAX       17
#define HT_IUNKNOWN_PTRS_BUCKETS_MAX    23

#define HT_PAGE_OBJECTS_BUCKETS_MAX     17

/*===================================================================
  Static utility function prototypes
===================================================================*/

static HRESULT QueryOnPageInfo
    (
    IDispatch *pDisp,
    COnPageInfo *pOnPageInfo
    );

static HRESULT CLSIDToMultibyteString
    (
    CLSID ClsId,
    char *psz,
    int cch
    );

#define REG_MODEL_TEXT_LEN_MAX  20  // big enough for "Apartment"
static CompModel RegStrToCompModel
    (
    BYTE *pb,
    DWORD cb
    );

/*===================================================================
  Static utility functions code
===================================================================*/

/*===================================================================
QueryOnPageInfo

Query dispatch ids for OnStartPage and OnEndPage

Parameters:
    IDispatch   *pDisp              Object to query
    COnPageInfo *pOnPageInfo        Struct to fill in

Returns:
    HRESULT
===================================================================*/
HRESULT QueryOnPageInfo
(
IDispatch   *pDisp,
COnPageInfo *pOnPageInfo
)
    {
    static LPOLESTR BStrEntryPoints[ONPAGE_METHODS_MAX] =
        {
        L"OnStartPage",
        L"OnEndPage"
        };

    HRESULT hr = S_OK;
    for (int i = 0; i < ONPAGE_METHODS_MAX; i++)
        {
        hr = pDisp->GetIDsOfNames
            (
            IID_NULL,
            &BStrEntryPoints[i],
            1,
            LOCALE_SYSTEM_DEFAULT,
            &pOnPageInfo->m_rgDispIds[i]
            );
        if (FAILED(hr))
            {
            if (hr != DISP_E_UNKNOWNNAME &&
                hr != DISP_E_MEMBERNOTFOUND)
                {
                break;
                }

            // If UNKNOWNNAME, set dispid to DISPID_UNKNOWN
            hr = S_OK;
            pOnPageInfo->m_rgDispIds[i] = DISPID_UNKNOWN;
            }
        }
    return hr;
    }

/*===================================================================
CLSIDToMultibyteString

Converts CLSID into multibyte string
Used in CompModelFromCLSID

Parameters:
    CLSID  ClsId     (in) CLSID to convert
    char  *pb        put string into this buffer
    int    cch       of this length

Returns:
    HRESULT
===================================================================*/
HRESULT CLSIDToMultibyteString
(
CLSID  ClsId,
char  *psz,
int    cch
)
    {
    // First convert it to OLECHAR string
    OLECHAR *pszWideClassID = NULL; // temp wide string classid
    HRESULT hr = StringFromCLSID(ClsId, &pszWideClassID);
    if (FAILED(hr))
        return hr;

    // OLECHAR to MultiByte
    BOOL f = WideCharToMultiByte
        (
        CP_ACP,         // code page
        0,              // performance and mapping flags
        pszWideClassID, // address of wide-character string
        -1,             // length (-1 == null-terminated)
        psz,            // address of buffer for new string
        cch,            // size of buffer for new string
        NULL,           // address of default for unmappable
                        //      characters; quickest if null
        NULL            // address of flag set when default
                        //      char. used; quickest if null
        );
    if (f == FALSE)
        hr = E_FAIL;

    if (pszWideClassID)
        CoTaskMemFree(pszWideClassID);
    return hr;
    }

/*===================================================================
RegStrToCompModel

Get CompModel value from a registry string

Parameters:
    char  *pb        string as returned from registry
    int    cb        length returned from registry

Returns:
    HRESULT
===================================================================*/
CompModel RegStrToCompModel
(
BYTE *pb,
DWORD cb
)
    {
    CompModel cmModel = cmSingle; // assume single

    if (cb == 5)  // 5 include '\0'
        {
        if (!(_strnicmp((const char*)pb, "Both", cb)))
            cmModel = cmBoth;
        else if (!(_strnicmp((const char*)pb, "Free", cb)))
            cmModel = cmFree;
        }
    else if (cb == 10)  // 10 include '\0'
        {
        if (!(_strnicmp((const char*)pb, "Apartment", cb)))
            cmModel = cmApartment;
        }

    return cmModel;
    }

/*===================================================================
  Public utility functions code
===================================================================*/

/*===================================================================
CompModelFromCLSID

Get object's model and InProc flag by its CLSID from the registry

Parameters:
    CLSID     &ClsId       (in)
    CompModel *pcmModel    (out) Model (optional)
    BOOL      *pfInProc    (out) InProc flag (optional)

Returns:
    CompModel (cmFree, cmBoth, etc.)
===================================================================*/
HRESULT CompModelFromCLSID
(
const CLSID &ClsId,
CompModel   *pcmModel,
BOOL        *pfInProc
)
    {
    if (!Glob(fTrackThreadingModel) && !pfInProc)
        {
        // ignore registry value for threading model and
        // inproc flag is not requested -> take short return
        if (pcmModel)
            *pcmModel = cmUnknown;
        return S_OK;
        }

    // default returns
    CompModel cmModel  = cmSingle;   // assume single
    BOOL      fInProc  = TRUE;       // assume inproc

    HRESULT hr = S_OK;

    // Convert ClsId to multibyte string

    char szClassID[50];
    hr = CLSIDToMultibyteString(ClsId, szClassID, sizeof(szClassID));
    if (FAILED(hr))
        return hr;

    /*  query the registry; threading model is stored as:
        HKEY_CLASSES_ROOT
          key: CLSID
            key: <object's classid>
              key: InprocServer32
                name: ThreadingModel data: "Both" | "Apartment"
    */

    // Navigate the registry to "InprocServer32" key

    HKEY hKey1 = NULL;  // handle of open reg key
    HKEY hKey2 = NULL;  // handle of open reg key
    HKEY hKey3 = NULL;  // handle of open reg key

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            HKEY_CLASSES_ROOT,
            "CLSID",
            0,
            KEY_READ,
            &hKey1
            );
        if (nRet != ERROR_SUCCESS)
            hr = E_FAIL;
        }

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            hKey1,
            szClassID,
            0,
            KEY_READ,
            &hKey2
            );
        if (nRet != ERROR_SUCCESS)
            hr = E_FAIL;
        }

    // Get the stuff from the registry "InprocServer32" key

    if (SUCCEEDED(hr))
        {
        int nRet = RegOpenKeyExA
            (
            hKey2,
            "InprocServer32",
            0,
            KEY_READ,
            &hKey3
            );
        if (nRet == ERROR_SUCCESS)
            {
            DWORD cbData = REG_MODEL_TEXT_LEN_MAX;
            BYTE  szData[REG_MODEL_TEXT_LEN_MAX];

            nRet = RegQueryValueExA
                (
                hKey3,
                "ThreadingModel",
                NULL,
                NULL,
                szData,
                &cbData
                );
            if (nRet == ERROR_SUCCESS)
                cmModel = RegStrToCompModel(szData, cbData);

            if (cmModel == cmBoth)
                {
                // Some objects marked as "Both" ASP treats as
                // "Apartment". These objects should be marked in
                // the registry as "ASPComponentNonAgile"

                nRet = RegQueryValueExA
                    (
                    hKey3,
                    "ASPComponentNonAgile",
                    NULL,
                    NULL,
                    szData,
                    &cbData
                    );

                // If the key is found pretend it's "apartment"
                if (nRet == ERROR_SUCCESS)
                    cmModel = cmApartment;
                }
            }
        else
            {
            // if there is no InprocServer32 key,
            // then it must be a localserver or remote server.
            fInProc = FALSE;
            }
        }

    // clean up registry keys
    if (hKey3)
        RegCloseKey(hKey3);
    if (hKey2)
        RegCloseKey(hKey2);
    if (hKey1)
        RegCloseKey(hKey1);

    // return values
    if (pcmModel)
        *pcmModel = Glob(fTrackThreadingModel) ? cmModel : cmUnknown;
    if (pfInProc)
        *pfInProc = fInProc;

    return hr;
    }

/*===================================================================
FIsIntrinsic

Checks if the given IDispatch * points to an ASP intrinsic.

Parameters:
    pdisp       pointer to check

Returns:
    TRUE if Intrinsic
===================================================================*/
BOOL FIsIntrinsic
(
IDispatch *pdisp
)
    {
    if (!pdisp)
        return FALSE; // null dispatch pointer - not an intrinsic

    IUnknown *punk = NULL;
    if (FAILED(pdisp->QueryInterface(IID_IDenaliIntrinsic, (void **)&punk)))
        return FALSE;

    Assert(punk);
    punk->Release();
    return TRUE;
    }

/*===================================================================
FIsSimpleVariant

Checks if the given VARIANT is a simple one

Parameters:
    pvar       variant to check

Returns:
    TRUE if [for sure] simple, FALSE if [possibly] not
===================================================================*/
inline FIsSimpleVariant(VARIANT *pvar)
    {
    switch (V_VT(pvar))
        {
    case VT_BSTR:
    case VT_I2:
    case VT_I4:
    case VT_BOOL:
    case VT_DATE:
    case VT_R4:
    case VT_R8:
        return TRUE;
        }
    return FALSE;
    }


/*===================================================================
  C  C o m p o n e n t  O b j e c t
===================================================================*/

/*===================================================================
CComponentObject::CComponentObject

CComponentObject constructor

Parameters:
    CompScope scScope       Object scope
    CompType  ctType        Object type
    CompModel cmModel       Object threading model

Returns:
===================================================================*/
CComponentObject::CComponentObject
(
CompScope scScope,
CompType  ctType,
CompModel cmModel
)
    :
    m_csScope(scScope), m_ctType(ctType), m_cmModel(cmModel),
    m_fAgile(FALSE),
    m_fOnPageInfoCached(FALSE),
    m_fOnPageStarted(FALSE),
    m_fFailedToInstantiate(FALSE), m_fInstantiatedTagged(FALSE),
    m_fInPtrCache(FALSE),
    m_fVariant(FALSE),
    m_fNameAllocated(FALSE),
    m_dwGIPCookie(NULL_GIP_COOKIE),
    m_pDisp(NULL), m_pUnknown(NULL),
    m_pCompNext(NULL), m_pCompPrev(NULL)
    {
    }

#ifdef DBG
/*===================================================================
CComponentObject::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CComponentObject::AssertValid() const
    {
    Assert(m_ctType != ctUnknown);
    }
#endif

/*===================================================================
CComponentObject::~CComponentObject

CComponentObject destructor
Releases interface pointers

Parameters:

Returns:
===================================================================*/
CComponentObject::~CComponentObject()
    {
    // Release all interface pointers
    Clear();

    // Name used in hash (from CLinkElem)
    if (m_fNameAllocated)
        {
        Assert(m_pKey);
        free(m_pKey);
        }
    }

/*===================================================================
CComponentObject::Init

Initialize CLinkElem portion with the object name
Needed to implement string hash

Parameters:
    LPWSTR pwszName      object name
    DWORD  cbName        name length in bytes

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Init
(
LPWSTR pwszName,
DWORD  cbName
)
    {
    Assert(pwszName);
    Assert(*pwszName != L'\0');
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    // required buffer length
    DWORD cbBuffer = cbName + sizeof(WCHAR);
    WCHAR *pwszNameBuffer = (WCHAR *)m_rgbNameBuffer;

    if (cbBuffer > sizeof(m_rgbNameBuffer))
        {
        // the name doesn't fit into the member buffer -> allocate
        pwszNameBuffer = (WCHAR *)malloc(cbBuffer);
        if (!pwszNameBuffer)
            return E_OUTOFMEMORY;
        m_fNameAllocated = TRUE;
        }

    memcpy(pwszNameBuffer, pwszName, cbBuffer);

    // init link with name as the key (length excludes null term)
    return CLinkElem::Init(pwszNameBuffer, cbName);
    }

/*===================================================================
CComponentObject::ReleaseAll

Releases all interface pointers

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::ReleaseAll()
    {
    // Release all other present interface pointers
    if (m_pDisp)
        {
        m_pDisp->Release();
        m_pDisp = NULL;
        }
    if (m_pUnknown)
        {
        m_pUnknown->Release();
        m_pUnknown = NULL;
        }

    // Variant
    if (m_fVariant)
        {
        VariantClear(&m_Variant);
        m_fVariant = FALSE;
        }

    if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        g_GIPAPI.Revoke(m_dwGIPCookie);
        m_dwGIPCookie = NULL_GIP_COOKIE;
        }

    return S_OK;
    }

/*===================================================================
CComponentObject::Clear

Clears out data leaving link alone

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Clear()
    {
    // Release all pointers
    TRY
        ReleaseAll();
    CATCH(nExcept)
        Assert(FALSE);
        m_pDisp = NULL;
        m_pUnknown = NULL;
        m_fVariant = FALSE;
        m_dwGIPCookie = NULL_GIP_COOKIE;
    END_TRY

    // Invalidate cached OnPageInfo
    m_fOnPageInfoCached = FALSE;
    m_fOnPageStarted = FALSE;

    // Mark it as unknown
    m_csScope = csUnknown;
    m_ctType  = ctUnknown;
    m_cmModel = cmUnknown;
    m_fAgile = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentObject::Instantiate

Create object instance if it's not there already
Calls TryInstantiate() from within TRY CATCH

Parameters:
    CHitObj *pHitObj    Hit object for error reporting

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::Instantiate
(
CHitObj *pHitObj
)
    {
    HRESULT hr = S_OK;

    if (Glob(fExceptionCatchEnable))
        {
        TRY
            hr = TryInstantiate(pHitObj);
        CATCH(nExcept)
            HandleErrorMissingFilename(IDE_SCRIPT_OBJ_INSTANTIATE_FAILED,
                                       pHitObj,
                                       TRUE,
                                       GetName(),
                                       nExcept);
            hr = nExcept;
        END_TRY
        }
    else
        {
        hr = TryInstantiate(pHitObj);
        }

    if (FAILED(hr))
        {
        // Something failed -- need to clean-up
        ReleaseAll();

        // mark as "failed to instantiate"
        m_fFailedToInstantiate = TRUE;
        }

    return hr;
    }

/*===================================================================
CComponentObject::TryInstantiate

Create object instance if it's not there already
Called by Instantiate() from within TRY CATCH

Parameters:
    CHitObj *pHitObj    Hit object for error reporting


Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::TryInstantiate
(
CHitObj *pHitObj
)
    {
    // Check if the object already exist
    if (m_pUnknown)
        return S_OK;

    if (m_fFailedToInstantiate)
        return E_FAIL;  // already tried once

    if (m_cmModel == cmUnknown && m_ClsId != CLSID_NULL)
        {
        CompModel cmModel;  // needed because m_cmModel is a bit fld
        HRESULT hr = CompModelFromCLSID(m_ClsId, &cmModel);
		if (FAILED(hr))
			return hr;
        m_cmModel = cmModel;
        }

    HRESULT hr = ViperCreateInstance
        (
        m_ClsId,
        IID_IUnknown,
        (void **)&m_pUnknown
        );

    // If we failed because we incorrectly cached the clsid
    // (could happen for tagged objects) try to get updated
    // cls id and retry
    if (m_ctType == ctTagged && FAILED(hr))
        {
        if (g_TypelibCache.UpdateMappedCLSID(&m_ClsId) == S_OK)
            {
            hr = ViperCreateInstance
                (
                m_ClsId,
                IID_IUnknown,
                (void **)&m_pUnknown
                );
            }
        }

    if (SUCCEEDED(hr))
        {
        if (Glob(fTrackThreadingModel) && m_cmModel == cmBoth)
            m_fAgile = TRUE;
        else
            m_fAgile = ViperCoObjectAggregatesFTM(m_pUnknown);

        hr = m_pUnknown->QueryInterface
            (
            IID_IDispatch,
            (void **)&m_pDisp
            );
        }

    // Check if application level object that
    // restricts threading -> use Global Interface Cookie

    if (SUCCEEDED(hr)
        && (m_csScope == csAppln || m_csScope == csSession)
        && !m_fAgile)
        {
        return ConvertToGIPCookie();
        }

    if (SUCCEEDED(hr) && !m_fOnPageInfoCached)
        {
        // don't really care if the following fails
        GetOnPageInfo();
        }

    return hr;
    }

/*===================================================================
CComponentObject::SetPropertyValue

Sets value from a Variant
Checks agility and possible deadlocks
Does GIP conversion

Parameters:
    VARIANT *pVariant       [in]  Value to set

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::SetPropertyValue
(
VARIANT *pVariant
)
    {
    Assert(m_ctType == ctProperty);

    HRESULT hr = S_OK;

    // Copy the variant value
    VariantInit(&m_Variant);
    m_fVariant = TRUE;

    hr = VariantCopyInd(&m_Variant, pVariant);
    if (FAILED(hr))
        return hr;

    // Get IDispatch pointer
    if (V_VT(&m_Variant) == VT_DISPATCH)
        {
        m_pDisp = V_DISPATCH(&m_Variant);
        }
    else
        {
        m_pDisp = NULL;
        }

    if (!m_pDisp)
        {
        m_fAgile = TRUE; // not VT_DISPATCH VARIANTs are agile
        return S_OK;
        }

    m_pDisp->AddRef();

    // Query (and cache) OnPageInfo inside TRY CATCH
    if (Glob(fExceptionCatchEnable))
        {
        TRY
            hr = GetOnPageInfo();
        CATCH(nExcept)
            hr = E_UNEXPECTED;
        END_TRY
        }
    else
        {
        hr = GetOnPageInfo();
        }

    // Don't really care if failed
    hr = S_OK;

    // Check if the assigned object is agile
    m_fAgile = ViperCoObjectAggregatesFTM(m_pDisp);

    if (Glob(fTrackThreadingModel) && !m_fAgile)
        {
        // doesn't mean it really isn't. could be one of
        // our objects marked as 'both'
        CComponentObject *pObjCopyOf = NULL;

        hr = CPageComponentManager::FindComponentWithoutContext
            (
            m_pDisp,
            &pObjCopyOf
            );

        if (hr == S_OK)
            {
            m_fAgile = pObjCopyOf->FAgile();
            }

        // end of getting of agile flag from the original object
        hr = S_OK; // even if object was not found
        }

    // Decide whether to use GIP and if invalid assignment
    // Applies only to non-agile application objects

    if (!m_fAgile && (m_csScope == csAppln || m_csScope == csSession))
        {
        if (!ViperCoObjectIsaProxy(m_pDisp) && (m_csScope == csAppln)) // deadlocking?
            {
            m_pDisp->Release();
            m_pDisp = NULL;
            VariantClear(&m_Variant);
            hr = RPC_E_WRONG_THREAD; // to tell the caller the error
            }
        else
            {
            // use GIP
            hr = ConvertToGIPCookie();
            }
        }

    return hr;
    }

/*===================================================================
CComponentObject::ConvertToGIPCookie

Convert Object to be GIP cookie. Release all pointers

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::ConvertToGIPCookie()
    {
    Assert(m_pDisp);  // has to have dispatch pointer

    if (!FIsWinNT())
        {
        // No GIPs on Win95
        // On Win95 everything is on the same thread
        // -> it is ok for the objects stay as pointers
        return S_OK;
        }

    DWORD dwCookie = NULL_GIP_COOKIE;
    HRESULT hr = g_GIPAPI.Register(m_pDisp, IID_IDispatch, &dwCookie);

    if (SUCCEEDED(hr))
        {
        Assert(dwCookie != NULL_GIP_COOKIE);

        // Release all pointeres
        ReleaseAll();

        // Store the cookie instead
        m_dwGIPCookie = dwCookie;
        }

    return hr;
    }

/*===================================================================
CComponentObject::GetOnPageInfo

Query dispatch ids for OnStartPage and OnEndPage
Calls static QueryOnPageInfo

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetOnPageInfo()
    {
    Assert(m_pDisp);

    HRESULT hr = QueryOnPageInfo(m_pDisp, &m_OnPageInfo);

    if (SUCCEEDED(hr))
        m_fOnPageInfoCached = TRUE;

    return hr;
    }

/*===================================================================
CComponentObject::GetAddRefdIDispatch

Get AddRef()'d Dispatch *
Handles the Global Interface Ole Cookies

Parameters:
    Dispatch **ppdisp    output

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetAddRefdIDispatch
(
IDispatch **ppdisp
)
    {
    Assert(ppdisp);

    if (m_pDisp)
        {
        *ppdisp = m_pDisp;
        (*ppdisp)->AddRef();
        return S_OK;
        }

    // try to restore from cookie
    if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        // Even if IUnknown * needs to be returned,
        // Ask for IDispatch *, because IDispatch * is the one
        // that was put in by CoGetInterfaceFromGlobal()

        HRESULT hr = g_GIPAPI.Get
            (
            m_dwGIPCookie,
            IID_IDispatch,
            (void **)ppdisp
            );

        if (SUCCEEDED(hr))
            return S_OK;
        }

    *ppdisp = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CComponentObject::GetAddRefdIUnknown

Get AddRef()'d IUnknown *
Handles the Global Interface Ole Cookies

Parameters:
    IUnknown **ppunk    output

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetAddRefdIUnknown
(
IUnknown **ppunk
)
    {
    Assert(ppunk);

    if (m_pUnknown)
        {
        *ppunk = m_pUnknown;
        (*ppunk)->AddRef();
        return S_OK;
        }

    // Use IDispatch (from cookie)

    IDispatch *pDisp = NULL;
    if (SUCCEEDED(GetAddRefdIDispatch(&pDisp)))
        {
        *ppunk = pDisp;  // IDispatch implements IUnknown
        return S_OK;
        }

    *ppunk = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CComponentObject::GetVariant

Get object's values as variant
Handles the Global Interface Ole Cookies

Parameters:
    VARIANT *pVar       [out]  Variant filled in with object value

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentObject::GetVariant
(
VARIANT *pVar
)
    {
    HRESULT hr = S_OK;

    VariantInit(pVar); // default variant empty

    if (m_fVariant)
        {
        // already has variant
        hr = VariantCopyInd(pVar, &m_Variant);
        }
    else if (m_pDisp)
        {
        // create variant from IDispatch*
        m_pDisp->AddRef();

        V_VT(pVar) = VT_DISPATCH;
        V_DISPATCH(pVar) = m_pDisp;
        }
    else if (m_dwGIPCookie != NULL_GIP_COOKIE)
        {
        // create variant from cookie
        IDispatch *pDisp = NULL;
        hr = g_GIPAPI.Get(m_dwGIPCookie, IID_IDispatch, (void **)&pDisp);

        if (SUCCEEDED(hr))
            {
            V_VT(pVar) = VT_DISPATCH;
            V_DISPATCH(pVar) = pDisp;
            }
        }
    else
        {
        // nowhere to get the VARIANT value from
        hr = E_POINTER;
        }

    return hr;
    }


/*===================================================================
  C  P a g e  O b j e c t
===================================================================*/

/*===================================================================
CPageObject::CPageObject

CPageObject constructor

Parameters:

Returns:
===================================================================*/
CPageObject::CPageObject()
    : m_pDisp(NULL),
      m_fStartPageCalled(FALSE), m_fEndPageCalled(FALSE)
    {
    }

#ifdef DBG
/*===================================================================
CPageObject::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CPageObject::AssertValid() const
    {
    Assert(m_pDisp);
    }
#endif

/*===================================================================
CPageObject::~CPageObject

CPageObject destructor

Parameters:

Returns:
===================================================================*/
CPageObject::~CPageObject()
    {
    // Release interface pointer
    if (m_pDisp)
        {
        m_pDisp->Release();
        m_pDisp = NULL;
        }
    }

/*===================================================================
CPageObject::Init

Initialize CLinkElem portion with the IDispatch pointer
Needed to implement string hash

Parameters:
    IDispatch   *pDisp          dispatch pointer (AddRef()ed)
    COnPageInfo *pOnPageInfo    OnStartPage, OnEndPage Ids

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::Init
(
IDispatch   *pDisp,
const COnPageInfo &OnPageInfo
)
    {
    Assert(pDisp);

    m_pDisp = pDisp;
    m_OnPageInfo = OnPageInfo;

    m_fStartPageCalled = FALSE;
    m_fEndPageCalled   = FALSE;

    return S_OK;
    }

/*===================================================================
CPageObject::InvokeMethod

Invokes OnPageStart() or OnPageEnd()

Parameters:
    DWORD iMethod                   which method
    CScriptingContext *pContext     scripting context (for OnStart)
    CHitObj *pHitObj                HitObj for errors

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::InvokeMethod
(
DWORD iMethod,
CScriptingContext *pContext,
CHitObj *pHitObj
)
    {
    BOOL fOnStart = (iMethod == ONPAGEINFO_ONSTARTPAGE);

    // check if method exists
    if (m_OnPageInfo.m_rgDispIds[iMethod] == DISPID_UNKNOWN)
        return S_OK;

    // two OnStart in a row - BAD
    Assert(!(fOnStart && m_fStartPageCalled));

    // two OnEnd in a row - BAD
    Assert(!(!fOnStart && m_fEndPageCalled));

    Assert(m_pDisp);

    HRESULT hr = S_OK;

    if (Glob(fExceptionCatchEnable))
        {
        // Call method inside TRY CATCH
        TRY
            hr = TryInvokeMethod
                (
                m_OnPageInfo.m_rgDispIds[iMethod],
                fOnStart,
                pContext,
                pHitObj
                );
        CATCH(nExcept)
            if (fOnStart)
                ExceptionId
                    (
                    IID_IObjectCover,
                    IDE_COVER,
                    IDE_COVER_ON_START_PAGE_GPF
                    );
            else
                HandleErrorMissingFilename
                    (
                    IDE_COVER_ON_END_PAGE_GPF,
                    pHitObj
                    );
            hr = E_UNEXPECTED;
        END_TRY
        }
    else
        {
        // don't CATCH
        hr = TryInvokeMethod
            (
            m_OnPageInfo.m_rgDispIds[iMethod],
            fOnStart,
            pContext,
            pHitObj
            );
        }

    if (fOnStart)
        m_fStartPageCalled = TRUE;
    else
        m_fEndPageCalled = TRUE;

    return hr;
    }

/*===================================================================
CPageObject::TryInvokeMethod

Invokes OnPageStart() or OnPageEnd()

Parameters:
    DISPID     DispId           method's DISPID
    BOOL       fOnStart         TRUE if invoking OnStart
    IDispatch *pDispContext     scripting context (for OnStart)
    CHitObj   *pHitObj          HitObj for errors

Returns:
    HRESULT
===================================================================*/
HRESULT CPageObject::TryInvokeMethod
(
DISPID     DispId,
BOOL       fOnStart,
IDispatch *pDispContext,
CHitObj   *pHitObj
)
    {
    EXCEPINFO   ExcepInfo;
    DISPPARAMS  DispParams;
    VARIANT     varResult;
    VARIANT     varParam;
    UINT        nArgErr;

    memset(&DispParams, 0, sizeof(DISPPARAMS));
    memset(&ExcepInfo, 0, sizeof(EXCEPINFO));

    if (fOnStart)
        {
        VariantInit(&varParam);
        V_VT(&varParam) = VT_DISPATCH;
        V_DISPATCH(&varParam) = pDispContext;

        DispParams.rgvarg = &varParam;
        DispParams.cArgs = 1;
        }

    VariantInit(&varResult);

    // Invoke it

    HRESULT hr = m_pDisp->Invoke
        (
        DispId,          // Call method
        IID_NULL,        // REFIID - Reserved, must be NULL
        NULL,            // Locale id
        DISPATCH_METHOD, // Calling a method, not a property
        &DispParams,     // pass arguments
        &varResult,      // return value
        &ExcepInfo,      // exeption info on failure
        &nArgErr
        );

    // Ignore errors indicating that this method doesnt exist.
    if (FAILED(hr))
        {
        if (hr == E_NOINTERFACE         ||
            hr == DISP_E_MEMBERNOTFOUND ||
            hr == DISP_E_UNKNOWNNAME)
            {
            // the above errors really aren't
            hr = S_OK;
            }
        }

    /*
     * NOTE: The OnStartPage method is always called while the
     * script is running, so we use ExceptionId and let the
     * scripting engine report the error.  OnEndPage is always
     * called after the engine is gone, so we use HandleError.
     */
    if (FAILED(hr))
        {
        if (ExcepInfo.bstrSource && ExcepInfo.bstrDescription)
            {
            // User supplied error
            Exception
                (
                IID_IObjectCover,
                ExcepInfo.bstrSource,
                ExcepInfo.bstrDescription
                );
            }
        else if (fOnStart)
            {
            // Standard on-start error
            ExceptionId
                (
                IID_IObjectCover,
                IDE_COVER,
                IDE_COVER_ON_START_PAGE_FAILED,
                hr
                );
            }
        else
            {
            // Standard on-end error
            HandleErrorMissingFilename
                (
                IDE_COVER_ON_END_PAGE_FAILED,
                pHitObj
                );
            }
        }

    return hr;
    }

/*===================================================================
  C  C o m p o n e n t  C o l l e c t i o n
===================================================================*/

/*===================================================================
CComponentCollection::CComponentCollection

CComponentCollection constructor

Parameters:

Returns:
===================================================================*/
CComponentCollection::CComponentCollection()
    :
    m_csScope(csUnknown),
    m_fUseTaggedArray(FALSE), m_fUsePropArray(FALSE),
    m_fHasComProperties(FALSE),
    m_cAllTagged(0), m_cInstTagged(0),
    m_cProperties(0), m_cUnnamed(0),
    m_pCompFirst(NULL)
    {
    }

#ifdef DBG
/*===================================================================
CComponentCollection::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CComponentCollection::AssertValid() const
    {
    Assert(m_csScope != csUnknown);
    m_htTaggedObjects.AssertValid();
    m_htTaggedObjects.AssertValid();
    m_htidIUnknownPtrs.AssertValid();
    }
#endif

/*===================================================================
CComponentCollection::~CComponentCollection

CComponentCollection destructor
Deletes all the objects

Parameters:

Returns:
===================================================================*/
CComponentCollection::~CComponentCollection()
    {
    UnInit();
    }

/*===================================================================
CComponentCollection::Init

Sets collection scope
Initializes hash tables

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::Init
(
CompScope scScope
)
    {
    HRESULT hr = S_OK;

    m_csScope = scScope;

    hr = m_htTaggedObjects.Init(HT_TAGGED_OBJECTS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    hr = m_htProperties.Init(HT_PROPERTIES_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    hr = m_htidIUnknownPtrs.Init(HT_IUNKNOWN_PTRS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    return S_OK;
    }

/*===================================================================
CComponentCollection::UnInit

Deletes all the objects

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CComponentCollection::UnInit()
    {
    // clear out pointer arrays
    m_rgpvTaggedObjects.Clear();
    m_rgpvProperties.Clear();
    m_fUseTaggedArray = FALSE;
    m_fUsePropArray = FALSE;

    // clear out name hash tables
    m_htTaggedObjects.UnInit();
    m_htProperties.UnInit();

    // clear out pointers hash table
    m_htidIUnknownPtrs.UnInit();

    // delete all member component objects
    if (m_pCompFirst)
        {
        CComponentObject *pObj = m_pCompFirst;
        while (pObj)
            {
            CComponentObject *pNext = pObj->m_pCompNext;
            delete pObj;
            pObj = pNext;
            }
        m_pCompFirst = NULL;
        }

    // reset the counters
    m_cAllTagged = 0;
    m_cInstTagged = 0;
    m_cProperties = 0;
    m_cUnnamed = 0;
    m_fHasComProperties = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentCollection::AddComponentToNameHash

Adds an object to the proper hash table

Parameters:
    CComponentObject *pObj      object to add
    LPWSTR            pwszName  object's name (hash)
    DWORD             cbName    name length in bytes

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddComponentToNameHash
(
CComponentObject *pObj,
LPWSTR            pwszName,
DWORD             cbName
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    // determine which hash table
    CHashTableStr *pHashTable;

    if (pObj->m_ctType == ctTagged)
        pHashTable = &m_htTaggedObjects;
    else if (pObj->m_ctType == ctProperty)
        pHashTable = &m_htProperties;
    else
        return S_OK; // nowhere to add, OK

    // Initialize object's CLinkElem
    HRESULT hr = pObj->Init(pwszName, cbName);
    if (FAILED(hr))
        return hr;

    // Add to hash table
    CLinkElem *pAddedElem = pHashTable->AddElem(pObj);
    if (!pAddedElem)
        return E_FAIL;  // couldn't add

    if (pObj != static_cast<CComponentObject *>(pAddedElem))
        return E_FAIL;  // another object with the same name
                        // already there

    return S_OK;
    }

/*===================================================================
CComponentCollection::AddComponentToPtrHash

Adds an object to the IUnkown * hash table

Parameters:
    CComponentObject *pObj      object to add

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddComponentToPtrHash
(
CComponentObject *pObj
)
    {
    // If we don't track the threading model, we don't care
    // to add objects to cache by IUnknown * - no need to look them up
    if (!Glob(fTrackThreadingModel))
        return S_OK;

    void *ptr = pObj->m_pUnknown;
    if (!ptr)
        return S_OK; // uninstatiated

    if (FAILED(m_htidIUnknownPtrs.AddObject((DWORD_PTR)ptr, pObj)))
        return E_FAIL;

    pObj->m_fInPtrCache = TRUE;
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentObjectByName

Find tagged object by name

Parameters:
    LPWSTR             pwszName   object's name
    DWORD              cbName     name length
    CComponentObject **ppObj      found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CComponentCollection::FindComponentObjectByName
(
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    CLinkElem *pElem = m_htTaggedObjects.FindElem(pwszName, cbName);
    if (!pElem)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = static_cast<CComponentObject *>(pElem);
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentPropertyByName

Find property by name

Parameters:
    LPWSTR             pwszName   object's name
    DWORD              cbName     name length
    CComponentObject **ppObj      found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CComponentCollection::FindComponentPropertyByName
(
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj
)
    {
    Assert(pwszName);
    Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

    CLinkElem *pElem = m_htProperties.FindElem(pwszName, cbName);
    if (!pElem)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = static_cast<CComponentObject *>(pElem);
    return S_OK;
    }

/*===================================================================
ComponentCollection::FindComponentByIUnknownPtr

Find property by IUnknown *

Parameters:
    IUnknown          *pUnk    find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/

HRESULT CComponentCollection::FindComponentByIUnknownPtr
(
IUnknown *pUnk,
CComponentObject **ppObj
)
    {
    void *pv;
    if (m_htidIUnknownPtrs.FindObject((DWORD_PTR)pUnk, &pv) != S_OK)
        {
        *ppObj = NULL;
        return S_FALSE;
        }

    *ppObj = reinterpret_cast<CComponentObject *>(pv);
    return S_OK;
    }

/*===================================================================
CComponentCollection::AddTagged

Adds a tagged object to the collection. Does not instanciate it yet.

Parameters:
    LPWSTR     pwszName     Object name
    CLSID     &ClsId        Class ID
    CompModel  cmModel      Object model

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddTagged
(
LPWSTR    pwszName,
const CLSID &ClsId,
CompModel cmModel
)
    {
    HRESULT hr = S_OK;

    DWORD cbName = CbWStr(pwszName);    // do strlen once

    if (m_htTaggedObjects.FindElem(pwszName, cbName))
        return E_FAIL;  // duplicate name

    CComponentObject *pObj = new CComponentObject
        (
        m_csScope,
        ctTagged,
        cmModel
        );

    if (pObj == NULL)
        return E_OUTOFMEMORY;

    pObj->m_ClsId = ClsId;

    hr = AddComponentToList(pObj);
    if (FAILED(hr))
        return hr;

    hr = AddComponentToNameHash(pObj, pwszName, cbName);
    if (FAILED(hr))
        return hr;

    if (m_fUseTaggedArray)
        m_rgpvTaggedObjects.Append(pObj);

    m_cAllTagged++;
    return S_OK;
    }

/*===================================================================
CComponentCollection::AddProperty

Adds a property object to the collection.
If property with the same name exists, it changes the value

Parameters:
    LPWSTR             pwszName   Object name
    VARIANT            pVariant   Property value
    CComponentObject **ppObj      [out] Property object could
                                        be NULL if not requested

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddProperty
(
LPWSTR   pwszName,
VARIANT *pVariant,
CComponentObject **ppObj
)
    {
    if (ppObj)
        *ppObj = NULL;

    HRESULT hr = S_OK;

    CComponentObject *pObj = NULL;

    DWORD cbName = CbWStr(pwszName);    // do strlen once

    // Find the existing object first
    CLinkElem *pElem = m_htProperties.FindElem(pwszName, cbName);

    if (pElem)
        {
        // Object already exists - use it
        pObj = static_cast<CComponentObject *>(pElem);
        Assert(pObj->m_ctType == ctProperty);

        // Clear out the object from any data
        hr = pObj->Clear();
        if (FAILED(hr))
            return hr;

        // Reinitialize object
        pObj->m_csScope = m_csScope;
        pObj->m_ctType  = ctProperty;
        pObj->m_cmModel = cmUnknown;
        }
    else
        {
        // Create new object
        pObj = new CComponentObject(m_csScope, ctProperty, cmUnknown);
        if (pObj == NULL)
            return E_OUTOFMEMORY;

        // Add the object to the list
        hr = AddComponentToList(pObj);
        if (FAILED(hr))
            return hr;

        // Add the object to the hash
        hr = AddComponentToNameHash(pObj, pwszName, cbName);
        if (FAILED(hr))
            return hr;

        // Add to properties array if needed
        if (m_fUsePropArray)
            m_rgpvProperties.Append(pObj);

        m_cProperties++;
        }

    // Assign value
    hr = pObj->SetPropertyValue(pVariant);

    if (SUCCEEDED(hr))
        {
        // check if simple variant
        if (!FIsSimpleVariant(&pObj->m_Variant))
            m_fHasComProperties = TRUE;
        }

    // Return object ptr if requested
    if (SUCCEEDED(hr))
        {
        if (ppObj)
            *ppObj = pObj;
        }

    return hr;
    }

/*===================================================================
CComponentCollection::AddUnnamed

Add object to be instantiated using Server.CreateObject

Parameters:
    CLSID             &ClsId    Class ID
    CompModel          cmModel  Object model
    CComponentObject **ppObj    Object Added

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::AddUnnamed
(
const CLSID &ClsId,
CompModel cmModel,
CComponentObject **ppObj
)
    {
    HRESULT hr = S_OK;

    if (cmModel == cmUnknown)
        {
        hr = CompModelFromCLSID(ClsId, &cmModel);
        if (FAILED(hr))
            return hr;
        }

    CComponentObject *pObj = new CComponentObject
        (
        m_csScope,
        ctUnnamed,
        cmModel
        );

    if (pObj == NULL)
        return E_OUTOFMEMORY;

    pObj->m_ClsId = ClsId;

    hr = AddComponentToList(pObj);
    if (FAILED(hr))
        return hr;

    *ppObj = pObj;
    m_cUnnamed++;
    return S_OK;
    }

/*===================================================================
CComponentCollection::GetTagged

Finds tagged object by name

Parameters:
    LPWSTR   pwszName           Object name
    CComponentObject **ppObj    [out] Object Found

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetTagged
(
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentObjectByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj && pObj->m_ctType != ctTagged)
        pObj = NULL;

    if (pObj)
        *ppObj = pObj;
    else
        hr = TYPE_E_ELEMENTNOTFOUND;

    return hr;
    }

/*===================================================================
CComponentCollection::GetProperty

Finds property object by name

Parameters:
    LPWSTR   pwszName           Property name
    CComponentObject **ppObj    [out] Object Found

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetProperty
(
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentPropertyByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj)
        *ppObj = pObj;
    else
        hr = TYPE_E_ELEMENTNOTFOUND;

    return hr;
    }

/*===================================================================
CComponentCollection::GetNameByIndex

Find name of a tagged objects or property by index

Parameters:
    CompType ctType       tagged or property
    int      index        index (1-based)
    LPWSTR  *ppwszName    [out] name (NOT allocated)

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::GetNameByIndex
(
CompType ctType,
int index,
LPWSTR *ppwszName
)
    {
    CPtrArray *pPtrArray;

    if (ctType == ctTagged)
        {
        if (!m_fUseTaggedArray)
            StartUsingTaggedObjectsArray();
        pPtrArray = &m_rgpvTaggedObjects;
        }
    else if (ctType == ctProperty)
        {
        if (!m_fUsePropArray)
            StartUsingPropertiesArray();
        pPtrArray = &m_rgpvProperties;
        }
    else
        {
        Assert(FALSE);
        *ppwszName = NULL;
        return E_FAIL;
        }

    if (index >= 1 && index <= pPtrArray->Count())
        {
        CComponentObject *pObj = (CComponentObject *)pPtrArray->Get(index-1);
        if (pObj)
            {
            Assert(pObj->GetType() == ctType);
            *ppwszName = pObj->GetName();
            if (*ppwszName)
                return S_OK;
            }
        }

    *ppwszName = NULL;
    return E_FAIL;
    }

/*===================================================================
CComponentCollection::RemoveComponent

Remove a known component.
Slow method for a non-recent objects.

Parameters:
    CComponentObject *pObj      -- object to remove

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveComponent
(
CComponentObject *pObj
)
    {
    Assert(pObj);

    // Remove from by-name hash tables and arrays
    if (pObj->m_ctType == ctTagged)
        {
        // tagged cannot be removed
        Assert(FALSE);
        return E_FAIL;
        }
    else if (pObj->m_ctType == ctProperty)
        {
        // hash table
        if (m_htProperties.DeleteElem(pObj->GetName(), CbWStr(pObj->GetName())))
            {
            m_cProperties--;
            }

        // array
        if (m_fUsePropArray)
            {
            m_rgpvProperties.Remove(pObj);
            }
        }
    else
        {
        Assert(pObj->m_ctType == ctUnnamed);
        m_cUnnamed--;
        }

    // Remove from the 'by pointer hash table'
    if (pObj->m_fInPtrCache)
        {
        void *ptr = pObj->m_pUnknown;
        if (ptr)
            m_htidIUnknownPtrs.RemoveObject((DWORD_PTR)ptr);
        pObj->m_fInPtrCache = FALSE;
        }

    // Remove from the list
    RemoveComponentFromList(pObj);

    // Remove
    delete pObj;

    return S_OK;
    }

/*===================================================================
CComponentCollection::RemovePropery

Remove a property by name.

Parameters:
    LPWSTR pwszName -- property name

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveProperty
(
LPWSTR pwszName
)
    {
    CComponentObject *pObj = NULL;
    HRESULT hr = FindComponentPropertyByName
        (
        pwszName,
        CbWStr(pwszName),
        &pObj
        );

    if (FAILED(hr))
        return hr;

    if (pObj)
        hr = RemoveComponent(pObj);

    return hr;
    }

/*===================================================================
CComponentCollection::RemoveAllProperties

Remove all properties.  Faster than iterating.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::RemoveAllProperties()
    {
    // Clear out the properties array
    if (m_fUsePropArray)
        {
        m_rgpvProperties.Clear();
        m_fUsePropArray = FALSE;
        }

    // Walk the object list to remove properties
    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
    {
        CComponentObject *pNextObj = pObj->m_pCompNext;

        if (pObj->m_ctType == ctProperty)
            {
            // remove from the hash table
            m_htProperties.DeleteElem(pObj->GetName(), CbWStr(pObj->GetName()));
            // properties are not in the 'by pointer hash table'
            Assert(!pObj->m_fInPtrCache);
            // remove from the list
            RemoveComponentFromList(pObj);
            // remove
            delete pObj;
            }

        pObj = pNextObj;
    }

    m_cProperties = 0;
    m_fHasComProperties = FALSE;

    return S_OK;
    }

/*===================================================================
CComponentCollection::StartUsingTaggedObjectsArray

Fill in the tagged objects array for access by index for the
first time

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::StartUsingTaggedObjectsArray()
    {
    if (m_fUseTaggedArray)
        return S_OK;

    m_rgpvTaggedObjects.Clear();

    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
        {
        if (pObj->GetType() == ctTagged)
            m_rgpvTaggedObjects.Append(pObj);
        pObj = pObj->m_pCompNext;
        }

    m_fUseTaggedArray = TRUE;
    return S_OK;
    }

/*===================================================================
CComponentCollection::StartUsingPropertiesArray

Fill in the properties array for access by index for the
first time

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentCollection::StartUsingPropertiesArray()
    {
    if (m_fUsePropArray)
        return S_OK;

    m_rgpvProperties.Clear();

    CComponentObject *pObj = m_pCompFirst;
    while (pObj)
        {
        if (pObj->GetType() == ctProperty)
            m_rgpvProperties.Prepend(pObj); // backwards
        pObj = pObj->m_pCompNext;
        }

    m_fUsePropArray = TRUE;
    return S_OK;
    }


/*===================================================================
  C  P a g e  C o m p o n e n t  M a n a g e r
===================================================================*/

/*===================================================================
CPageComponentManager::CPageComponentManager

CPageComponentManager constructor

Parameters:

Returns:
===================================================================*/
CPageComponentManager::CPageComponentManager()
    : m_pHitObj(NULL)
    {
    }

#ifdef DBG
/*===================================================================
CPageComponentManager::AssertValid()

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CPageComponentManager::AssertValid() const
    {
    Assert(m_pHitObj);
    m_pHitObj->AssertValid();
    m_htidPageObjects.AssertValid();
    }
#endif

/*===================================================================
CPageComponentManager::~CPageComponentManager

CPageComponentManager destructor
Deletes all page objects

Parameters:

Returns:
===================================================================*/
CPageComponentManager::~CPageComponentManager()
    {
    // delete all page objects
    m_htidPageObjects.IterateObjects(DeletePageObjectCB);
    }

/*===================================================================
CPageComponentManager::DeletePageObjectCB

Sta