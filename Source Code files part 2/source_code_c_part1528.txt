RE,cbSize);

    if(NULL == pData1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pData2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwi = ExactHeapAllocPtr(
        hHeap,
        GMEM_SHARE|GMEM_FIXED,
        sizeof(WAVEINFO) + 3*sizeof(DWORD));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    dw  = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|INPUT_MAP(gti));

    pwh1->lpData          = pData1;
    pwh1->dwBufferLength  = cbSize;
    pwh1->dwBytesRecorded = 0L;
    pwh1->dwUser          = 0L;
    pwh1->dwFlags         = 0L;

    pwh2->lpData          = pData2;
    pwh2->dwBufferLength  = cbSize;
    pwh2->dwBytesRecorded = 0L;
    pwh2->dwUser          = 0L;
    pwh2->dwFlags         = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
    mmr = call_waveInPrepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveInClose(hWaveIn);

        LogFail(gszFailWIPrepare);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Verify waveInReset works if immediately after open.
    //

    Log_TestCase("Verifying waveInReset works if immediately after open");

    mmr = call_waveInReset(hWaveIn);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("waveInReset works immediately after open");
    }
    else
    {
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        LogFail("waveInReset returned error");

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Verify waveInReset works if device is recording.
    //

    Log_TestCase("Verifying waveInReset works if device is recording");

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInStart(hWaveIn);

    mmr = call_waveInReset(hWaveIn);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("waveInReset works if device is recording");
    }
    else
    {
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        LogFail("waveInReset returned error");

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Clearing DONE bit in header...
    //

    pwh1->dwFlags &= (~WHDR_DONE);

    //
    //  Verify device is stopped after reset.
    //

    Log_TestCase("Verify device is stopped after reset");

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(IsStopped(hWaveIn))
    {
        LogPass("waveInReset stopped device");
    }
    else
    {
        LogFail("waveInReset did not stop device");

        iResult = TST_FAIL;
    }

    //
    //  Verify waveInReset works if device is stopped.
    //

    Log_TestCase("Verifying waveInReset works if device is stopped");

    mmr = call_waveInReset(hWaveIn);
    pwh1->dwFlags &= (~WHDR_DONE);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("waveInReset works if device is stopped");
    }
    else
    {
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        LogFail("waveInReset returned error");

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Verify waveInReset resets waveInGetPosition count.
    //

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInStart(hWaveIn);

    //  Polling...

    while(!(pwh1->dwFlags & WHDR_DONE));

    mmt.wType = TIME_BYTES;
    call_waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));
    dw = GetMSFromMMTIME(gti.pwfxInput,&mmt);

    if(0 == dw)
    {
        LogFail("Position has not moved");

        iResult = TST_FAIL;
    }

    Log_TestCase("Verifying waveInReset resets waveInGetPosition count");

    mmr = call_waveInReset(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Driver failed waveInReset()");

        iResult = TST_FAIL;
    }
    else
    {
        mmt.wType = TIME_BYTES;
        call_waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));
        dw = GetMSFromMMTIME(gti.pwfxInput,&mmt);

        if(0 != dw)
        {
            LogFail("Position was not reset to zero");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Position was reset to zero");
        }
    }

    //
    //  Verify waveInReset forces DATA callbacks.
    //

    Log_TestCase("Verifying waveInReset forces DATA callbacks");

    pwh1->dwFlags &= (~WHDR_DONE);
    pwh2->dwFlags &= (~WHDR_DONE);

    //  Note:  There will be 2 headers we use count of 3 to detect too many
    //          callbacks.

    pwi->dwCount   = 3;
    pwi->dwCurrent = 0L;
    pwi->fdwFlags  = 0L;

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInAddBuffer(hWaveIn,pwh2,sizeof(WAVEHDR));

    mmr = call_waveInReset(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Driver failed waveInReset()");
    }
    else
    {
        if(2 == pwi->dwCurrent)
        {
            LogPass("Driver made correct number of callbacks");
        }
        else
        {
            if(2 < pwi->dwCurrent)
            {
                LogFail("Driver made too many callbacks");
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Driver made %lu callbacks; 2 expected.",
                    pwi->dwCurrent);
            }

            iResult = TST_FAIL;
        }
    }

    call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
    call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInClose(hWaveIn);

    DLL_WaveControl(DLL_END,NULL);
    PageUnlock(pwi);
    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveInReset()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\perf.c ===
//--------------------------------------------------------------------------;
//
//  File: Perf.c
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
//  Abstract:
//
//
//  Contents:
//      Test_waveOutGetPosition_Accuracy()
//      Test_waveInGetPosition_Accuracy()
//      Test_waveOutWrite_TimeAccuracy()
//      Test_waveInAddBuffer_TimeAccuracy()
//      waveOutGetStats()
//      Test_waveOutGetPosition_Performance()
//      waveInGetStats()
//      Test_waveInGetPosition_Performance()
//
//  History:
//      04/24/95    Fwong       Added to segregate performance tests.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include <memgr.h>
#include <inimgr.h>
#include <waveutil.h>
#include <TstsHell.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "MulDiv32.h"
#include "Debug.h"

#if 0
ULONG waveGetTime( VOID )
{
   return timeGetTime() ;
}
#endif

ULONG waveGetTime( VOID )
{
   LARGE_INTEGER  time, frequency ;

   QueryPerformanceCounter( &time ) ;
   QueryPerformanceFrequency( &frequency ) ;

   return (ULONG) (time.QuadPart * (LONGLONG) 1000 / frequency.QuadPart) ;
}

//--------------------------------------------------------------------------;
//
//  int Test_waveOutGetPosition_Accuracy
//
//  Description:
//      Tests the driver accuracy of waveOutGetPosition
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      03/08/95    Fwong       Added to because JonRoss was whining...
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutGetPosition_Accuracy
(
    void
)
{
    HWAVEOUT            hwo;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    HANDLE              hHeap;
    MMTIME              mmtBytes,mmtSample;
    DWORD               cbDMA;
    DWORD               dwTimeBegin,dwTimeEnd,dwTime;
    DWORD               cInitBytes,cInitSamples;
    DWORD               cEndBytes, cEndSamples;
    DWORD               cbFirst,cBytes;
    DWORD               dwThreshold;
    DWORD               dwWarn, dwError;
    DWORD               cbDelta;
    DWORD               cTests,cFails;
    DWORD               dwByteRate,dwSampleRate;
    BOOL                fFails;
    WAVEOUTCAPS         woc;
    int                 iResult = TST_PASS;
    char                szFormat[MAXFMTSTR];
    static char         szTestName[] = "waveOutGetPosition accuracy";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(woc));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_SAMPLEACCURATE)
    {
        tstLog(
            VERBOSE,
            "\nNote: WAVECAPS_SAMPLEACCURATE bit set in WAVEOUTCAPS.\n");

        fFails = TRUE;
    }
    else
    {
        tstLog(
            TERSE,
            "\nNote: WAVECAPS_SAMPLEACCURATE bit not set in WAVEOUTCAPS.\n");

        fFails = FALSE;
    }

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Getting error threshold...
    //      Defaulting to 1% deviation.
    //

    dwThreshold = GetIniDWORD(szTestName,gszPercent,0x10000);

    DPF(1,"Threshold: 0x%08lx",dwThreshold);

    cbDMA = waveOutDMABufferSize(gti.uOutputDevice,gti.pwfxOutput);

    if(0 == cbDMA)
    {
        DPF(1,"DMA size not found.  Using 1/2 second.");

        cbDMA = gti.pwfxOutput->nAvgBytesPerSec / 2;
    }
    else
    {
        tstLog(VERBOSE,"Estimated DMA buffer size: %lu bytes.",cbDMA);
    }

    cInitBytes = cbDMA;
    cEndBytes  = ((DWORD)((gti.wrLong.cbSize - 1) / cbDMA)) * cbDMA;

    //
    //  Opening device...
    //

    mmr = waveOutOpen(
        &hwo,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Preparing Header...
    //

    pwh->lpData             = gti.wrLong.pData;
    pwh->dwBufferLength     = gti.wrLong.cbSize;
    pwh->dwBytesRecorded    = 0L;
    pwh->dwUser             = 0L;
    pwh->dwFlags            = 0L;

    mmr = waveOutPrepareHeader(hwo,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        waveOutReset(hwo);
        waveOutClose(hwo);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmtBytes.wType  = TIME_BYTES;
    mmtSample.wType = TIME_SAMPLES;

    GetFormatName(szFormat,gti.pwfxOutput,sizeof(szFormat));
    tstLog(VERBOSE,"                Format: %s",(LPSTR)szFormat);
    tstLog(VERBOSE,"Ideal initial position: %lu bytes.",cInitBytes);
    tstLog(VERBOSE,"    Ideal end position: %lu bytes.",cEndBytes);
    tstLog(VERBOSE,"         Buffer Length: %lu bytes.",pwh->dwBufferLength);
    tstLogFlush();

    tstLog(VERBOSE,"\nStage 1: Calculating Rates...\n");

    waveOutPause(hwo);
    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));

    cbFirst   = 0;
    dwTimeEnd = 0;
          
    waveOutRestart(hwo);

    for(;;)
    {
        //
        //  Waiting for ms transition for waveGetTime.
        //

//        while(1 == (0x00000001 & waveGetTime()));
//        while(0 == (0x00000001 & waveGetTime()));

        dwTimeBegin = waveGetTime();

        waveOutGetPosition(hwo,&mmtBytes,sizeof(MMTIME));
        waveOutGetPosition(hwo,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTimeBegin)
        {
            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveOutReset(hwo);
            waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
            waveOutClose(hwo);

            LogFail("Could not successfully do two waveOutGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        cbFirst = (0 == cbFirst)?(mmtBytes.u.cb):(cbFirst);

        if(cInitBytes < mmtBytes.u.cb)
        {
            cInitBytes   = mmtBytes.u.cb;
            cInitSamples = mmtSample.u.sample;

            if(cbFirst > (gti.pwfxOutput->nAvgBytesPerSec / 2))
            {
                //
                //  Initial time is > 1/2 a second?!
                //

                waveOutReset(hwo);
                waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
                waveOutClose(hwo);

                tstLog(VERBOSE,"Current byte: %lu",cInitBytes);

                ExactHeapDestroy(hHeap);

                if(fFails)
                {
                    LogFail("waveOutGetPosition has too large granularity");
                    return TST_FAIL;
                }
                else
                {
                    tstLog(
                        TERSE,
                        "\n    WARNING: waveOutGetPosition has too large "
                        "granularity");

                    return TST_OTHER;
                }
            }

            //
            //  From here we break out of this loop.
            //

            break;
        }
    }

    for(;;)
    {
        dwTime = waveGetTime();

        waveOutGetPosition(hwo,&mmtBytes,sizeof(MMTIME));
        waveOutGetPosition(hwo,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveOutReset(hwo);
            waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
            waveOutClose(hwo);

            LogFail("Could not successfully do two waveOutGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(cEndBytes > mmtBytes.u.cb)
        {
            dwTimeEnd   = dwTime;
            cBytes      = mmtBytes.u.cb;
            cEndSamples = mmtSample.u.sample;

            continue;
        }

        if(0 == dwTimeEnd)
        {
            waveOutReset(hwo);
            waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
            waveOutClose(hwo);

            LogFail("Could not successfully do two waveOutGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        cEndBytes = cBytes;

        break;
    }

    tstLog(VERBOSE,"Note: First non-zero position was: %lu bytes",cbFirst);

    dwTime       = dwTimeEnd - dwTimeBegin;

    tstLog(VERBOSE,"\n    Elapsed time: %lu milliseconds.",dwTime);

    tstLog(VERBOSE,"\n\nStatistics for TIME_BYTES:");
    tstLog(VERBOSE,"   Initial Position: %lu bytes.",cInitBytes);
    tstLog(VERBOSE,"       End Position: %lu bytes.",cEndBytes);

    cEndBytes   -= cInitBytes;

    tstLog(VERBOSE,"\nBytes played over elapsed time: %lu bytes.",cEndBytes);

    dwByteRate   = MulDivRN(cEndBytes,1000,dwTime);

    tstLog(
        VERBOSE,
        "\nIdeal Bytes Per Second: %lu",
        gti.pwfxOutput->nAvgBytesPerSec);

    tstLog(VERBOSE," Real Bytes Per Second: %lu",dwByteRate);

    cbDelta = LogPercentOff(dwByteRate,gti.pwfxOutput->nAvgBytesPerSec);

    tstLog(
        VERBOSE,
        "Percent deviation error threshold: +- %u.%04u %%",
        (UINT)(dwThreshold / 0x10000),
        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));

    if(cbDelta > dwThreshold)
    {
        tstLog(TERSE,"    FAIL: Rate is off by too much.");

        iResult = TST_FAIL;
    }
    else
    {
        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
    }

    tstLog(VERBOSE,"\n\nStatistics for TIME_SAMPLES:");
    tstLog(VERBOSE,"   Initial Position: %lu samples.",cInitSamples);
    tstLog(VERBOSE,"       End Position: %lu samples.",cEndSamples);

    cEndSamples -= cInitSamples;

    tstLog(VERBOSE,"\nSamples played over elapsed time: %lu samples.",cEndSamples);

    dwSampleRate = MulDivRN(cEndSamples,1000,dwTime);

    tstLog(
        VERBOSE,
        "Ideal Samples Per Second: %lu",
        gti.pwfxOutput->nSamplesPerSec);

    tstLog(VERBOSE," Real Samples Per Second: %lu",dwSampleRate);

    cbDelta = LogPercentOff(dwSampleRate,gti.pwfxOutput->nSamplesPerSec);

    tstLog(
        VERBOSE,
        "Percent deviation error threshold: +- %u.%04u %%",
        (UINT)(dwThreshold / 0x10000),
        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));

    if(cbDelta > dwThreshold)
    {
        tstLog(TERSE,"    FAIL: Rate is off by too much.");

        iResult = TST_FAIL;
    }
    else
    {
        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
    }

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        //
        //  Aborted!!  Cleaning up...
        //

        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveOutReset(hwo);
        waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
        waveOutClose(hwo);

        ExactHeapDestroy(hHeap);

        return TST_FAIL; 
    }

    pwh->dwFlags &= (~WHDR_DONE);

    waveOutReset(hwo);

    mmtBytes.wType = TIME_BYTES;

    tstLog(VERBOSE,"\n\nStage 2: Testing for drift (bytes)...");

    //
    //  Max drift: 3 ms.
    //

    dwThreshold = 30;  // In 1/10 ms.

    dwWarn  = MulDivRN(dwByteRate,dwThreshold,10000);
    dwError = MulDivRN(dwByteRate,(dwThreshold + 5), 10000);

    tstLog(VERBOSE,"Maximum warning drift: %lu bytes.",dwWarn);
    tstLog(VERBOSE,"  Maximum error drift: %lu bytes.",dwError);

    waveOutPause(hwo);
    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
    waveOutRestart(hwo);

    for(;;)
    {
        //
        //  Waiting for ms transition for waveGetTime.
        //

        while(1 == (0x00000001 & waveGetTime()));
        while(0 == (0x00000001 & waveGetTime()));

        dwTime = waveGetTime();

        waveOutGetPosition(hwo,&mmtBytes,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveOutReset(hwo);
            waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
            waveOutClose(hwo);

            LogFail("Could not successfully do a waveOutGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(0 != mmtBytes.u.cb)
        {
            dwTimeBegin  = dwTime;

            cbFirst      = mmtBytes.u.cb;
            dwTimeBegin -= cbFirst * 1000 / gti.pwfxOutput->nAvgBytesPerSec;

            if(cbFirst > (gti.pwfxOutput->nAvgBytesPerSec / 2))
            {
                waveOutReset(hwo);
                waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
                waveOutClose(hwo);

                tstLog(VERBOSE,"Current bytes: %lu",cbFirst);

                ExactHeapDestroy(hHeap);

                if(fFails)
                {
                    LogFail("waveOutGetPosition has too large granularity");
                    return TST_FAIL;
                }
                else
                {
                    tstLog(
                        TERSE,
                        "\n    WARNING: waveOutGetPosition has too large "
                        "granularity");

                    return TST_OTHER;
                }
            }

            break;
        }
    }

    cTests = 0;
    cFails = 0;

    for(;;)
    {
        dwTime = waveGetTime();

        waveOutGetPosition(hwo,&mmtBytes,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            break;
        }

        if(pwh->dwBufferLength == mmtBytes.u.cb)
        {
            break;
        }

        cTests++;

        cBytes = ((dwTime - dwTimeBegin) * dwByteRate) / 1000;

        cbDelta = (cBytes > mmtBytes.u.cb)?
                  (cBytes - mmtBytes.u.cb):
                  (mmtBytes.u.cb - cBytes);

        if(cbDelta > dwWarn)
        {
            if(cbDelta > dwError)
            {
                if(fFails)
                {
                    tstLog(
                        TERSE,
                        "\n    FAIL: Position is drifting (%lu).",
                        cTests);

                    iResult = TST_FAIL;
                }
                else
                {
                    tstLog(
                        TERSE,
                        "\n    WARNING: Position is drifting (%lu).",
                        cTests);
                }

                cFails++;
                tstLog(TERSE,"     Current position: %lu bytes.",mmtBytes.u.cb);
                tstLog(TERSE,"    Expected position: %lu bytes.",cBytes);
            }
            else
            {
                tstLog(
                    TERSE,
                    "\n    WARNING: Position is drifting (%lu).",
                    cTests);

                tstLog(TERSE,"     Current position: %lu bytes.",mmtBytes.u.cb);
                tstLog(TERSE,"    Expected position: %lu bytes.",cBytes);
            }
        }
    }

    tstLog(VERBOSE,"Note: First non-zero position was: %lu bytes",cbFirst);

    if(0 == cFails)
    {
        LogPass("No drifting occured");
    }

    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
    tstLog(VERBOSE,"   Number of failures: %lu",cFails);

    //
    //  Should be at last sample; getting last sample.
    //

    waveOutGetPosition(hwo,&mmtSample,sizeof(MMTIME));

    dwTimeEnd = mmtSample.u.sample;

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        //
        //  Aborted!!  Cleaning up...
        //

        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveOutReset(hwo);
        waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
        waveOutClose(hwo);

        ExactHeapDestroy(hHeap);

        return TST_FAIL; 
    }

    pwh->dwFlags &= (~WHDR_DONE);

    waveOutReset(hwo);

    mmtSample.wType = TIME_SAMPLES;

    tstLog(VERBOSE,"\n\nStage 3: Testing for drift (samples)...");

    //
    //  Max drift: 3 ms.
    //

    dwThreshold = 30;  // In 1/10 ms.

    dwWarn  = MulDivRN(dwSampleRate,dwThreshold,10000);
    dwError = MulDivRN(dwSampleRate,(dwThreshold + 5), 10000);

    tstLog(VERBOSE,"Maximum warning drift: %lu samples.",dwWarn);
    tstLog(VERBOSE,"  Maximum error drift: %lu samples.",dwError);

    waveOutPause(hwo);
    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
    waveOutRestart(hwo);

    for(;;)
    {
        //
        //  Waiting for ms transition for waveGetTime.
        //

        while(1 == (0x00000001 & waveGetTime()));
        while(0 == (0x00000001 & waveGetTime()));

        dwTime = waveGetTime();

        waveOutGetPosition(hwo,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveOutReset(hwo);
            waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
            waveOutClose(hwo);

            LogFail("Could not successfully do a waveOutGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(0 != mmtSample.u.sample)
        {
            dwTimeBegin  = dwTime;

            cbFirst      = mmtSample.u.sample;
            dwTimeBegin -= cbFirst * 1000 / gti.pwfxOutput->nSamplesPerSec;

            if(cbFirst > (gti.pwfxOutput->nSamplesPerSec / 2))
            {
                waveOutReset(hwo);
                waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
                waveOutClose(hwo);

                tstLog(VERBOSE,"Current samples: %lu",cbFirst);

                ExactHeapDestroy(hHeap);

                if(fFails)
                {
                    LogFail("waveOutGetPosition has too large granularity");
                    return TST_FAIL;
                }
                else
                {
                    tstLog(
                        TERSE,
                        "\n    WARNING: waveOutGetPosition has too large "
                        "granularity");

                    return TST_OTHER;
                }
            }

            break;
        }
    }

    cTests = 0;
    cFails = 0;

    for(;;)
    {
        dwTime = waveGetTime();

        waveOutGetPosition(hwo,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            break;
        }

        if(dwTimeEnd == mmtSample.u.sample)
        {
            break;
        }

        cTests++;

        cBytes = ((dwTime - dwTimeBegin) * dwSampleRate) / 1000;

        cbDelta = (cBytes > mmtSample.u.cb)?
                  (cBytes - mmtSample.u.cb):
                  (mmtSample.u.cb - cBytes);

        if(cbDelta > dwWarn)
        {
            if(cbDelta > dwError)
            {
                if(fFails)
                {
                    tstLog(
                        TERSE,
                        "\n    FAIL: Position is drifting (%lu).",
                        cTests);

                    iResult = TST_FAIL;
                }
                else
                {
                    tstLog(
                        TERSE,
                        "\n    WARNING: Position is drifting (%lu).",
                        cTests);
                }

                cFails++;
                tstLog(TERSE,"     Current position: %lu samples.",mmtSample.u.cb);
                tstLog(TERSE,"    Expected position: %lu samples.",cBytes);
            }
            else
            {
                tstLog(
                    TERSE,
                    "\n    WARNING: Position is drifting (%lu).",
                    cTests);

                tstLog(TERSE,"     Current position: %lu samples.",mmtSample.u.cb);
                tstLog(TERSE,"    Expected position: %lu samples.",cBytes);
            }
        }
    }

    tstLog(VERBOSE,"Note: First non-zero position was: %lu samples",cbFirst);

    if(0 == cFails)
    {
        LogPass("No drifting occured");
    }

    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
    tstLog(VERBOSE,"   Number of failures: %lu\n\n",cFails);

    waveOutReset(hwo);
    waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
    waveOutClose(hwo);

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveOutGetPosition_Accuracy()


//int FNGLOBAL Test_waveOutGetPosition_Accuracy
//(
//    void
//)
//{
//    HWAVEOUT            hwo;
//    MMRESULT            mmr;
//    volatile LPWAVEHDR  pwh;
//    HANDLE              hHeap;
//    MMTIME              mmt;
//    DWORD               dwTime, dwTimeBase;
//    DWORD               dwRealBytesPerSec;
//    DWORD               dwRealSamplesPerSec;
//    DWORD               cbError,cbDelta;
//    DWORD               dwThreshold;
//    DWORD               cSamples,cTests,cFails;
//    DWORD               dwInitial;
//    int                 iResult = TST_PASS;
//    static char         szTestName[] = "waveOutGetPosition accuracy";
//
//    Log_TestName(szTestName);
//
//    if(0 == waveOutGetNumDevs())
//    {
//        tstLog(TERSE,gszMsgNoOutDevs);
//
//        return iResult;
//    }
//
//    //
//    //  Allocating memory...
//    //
//
//    hHeap = ExactHeapCreate(0L);
//
//    if(NULL == hHeap)
//    {
//        LogFail(gszFailNoMem);
//
//        return TST_FAIL;
//    }
//
//    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));
//
//    if(NULL == pwh)
//    {
//        LogFail(gszFailNoMem);
//
//        ExactHeapDestroy(hHeap);
//
//        return TST_FAIL;
//    }
//
//    //
//    //  Getting error threshold...
//    //      Defaulting to 1% deviation.
//    //
//
//    dwThreshold = GetIniDWORD(szTestName,gszPercent,0x10000);
//
//    DPF(1,"Threshold: 0x%08lx",dwThreshold);
//
//    //
//    //  Opening device...
//    //
//
//    mmr = waveOutOpen(
//        &hwo,
//        gti.uOutputDevice,
//        gti.pwfxOutput,
//        0L,
//        0L,
//        OUTPUT_MAP(gti));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailOpen);
//
//        ExactHeapDestroy(hHeap);
//        return TST_FAIL;
//    }
//
//    //
//    //  Preparing Header...
//    //
//
//    pwh->lpData             = gti.wrLong.pData;
//    pwh->dwBufferLength     = gti.wrLong.cbSize;
//    pwh->dwBytesRecorded    = 0L;
//    pwh->dwUser             = 0L;
//    pwh->dwFlags            = 0L;
//
//    mmr = waveOutPrepareHeader(hwo,pwh,sizeof(WAVEHDR));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailWOPrepare);
//
//        waveOutReset(hwo);
//        waveOutClose(hwo);
//
//        ExactHeapDestroy(hHeap);
//        return TST_FAIL;
//    }
//
//    mmt.wType = TIME_BYTES;
//
//    tstLog(VERBOSE,"\nStage 1: Calculating Rates...\n");
//    tstLog(VERBOSE,"    Buffer Length: %lu bytes.",pwh->dwBufferLength);
//
//    waveOutPause(hwo);
//    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
//
//    dwTime = waveGetTime();
//    waveOutRestart(hwo);
//
//    for(;;)
//    {
//        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
//        
//        if(0 != mmt.u.cb)
//        {
//            dwTimeBase = waveGetTime();
//            
//            dwTimeBase -= mmt.u.cb * 1000 / gti.pwfxOutput->nAvgBytesPerSec;
//            dwInitial   = mmt.u.cb;
//
//            if(mmt.u.cb > (gti.pwfxOutput->nAvgBytesPerSec / 2))
//            {
//                waveOutReset(hwo);
//                waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
//                waveOutClose(hwo);
//
//                tstLog(VERBOSE,"Current byte: %lu",mmt.u.cb);
//
//                LogFail("waveOutGetPosition has too large granularity");
//
//                ExactHeapDestroy(hHeap);
//                return TST_FAIL;
//            }
//
//            break;
//        }
//    }
//
//    dwTime = pwh->dwBufferLength * 2000 / gti.pwfxOutput->nAvgBytesPerSec +
//             dwTimeBase;
//
//    for(;;)
//    {
//        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
//
//        if(pwh->dwBufferLength == mmt.u.cb)
//        {
//            dwTime = waveGetTime();
//
//            break;
//        }
//
//        if(dwTime < waveGetTime())
//        {
//            waveOutReset(hwo);
//            waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
//            waveOutClose(hwo);
//
//            LogFail("Timed out waiting for WAVEHDR.");
//
//            ExactHeapDestroy(hHeap);
//            return TST_FAIL;
//        }
//    }
//
//    if(dwInitial > gti.pwfxOutput->nAvgBytesPerSec / 250)
//    {
//        tstLog(
//            VERBOSE,
//            "Note: First non-zero position was: %lu bytes",
//            dwInitial);
//    }
//
//    dwTime -= dwTimeBase;
//
//    dwRealBytesPerSec = MulDivRN(pwh->dwBufferLength,1000,dwTime);
//
//    tstLog(VERBOSE,"     Elapsed Time: %lu milliseconds.",dwTime);
//    tstLog(VERBOSE,"\nBytes Per Second:");
//    tstLog(VERBOSE,"    Real: %lu bytes/second.",dwRealBytesPerSec);
//    tstLog(VERBOSE,"   Ideal: %lu bytes/second.\n",gti.pwfxOutput->nAvgBytesPerSec);
//
//    cbDelta = LogPercentOff(dwRealBytesPerSec,gti.pwfxOutput->nAvgBytesPerSec);
//
//    tstLog(
//        VERBOSE,
//        "Percent deviation error threshold: +- %u.%04u %%",
//        (UINT)(dwThreshold / 0x10000),
//        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));
//
//    if(cbDelta > dwThreshold)
//    {
//        tstLog(TERSE,"    FAIL: Rate is off by too much.");
//
//        iResult = TST_FAIL;
//    }
//    else
//    {
//        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
//    }
//
//    //
//    //  Calculating number of samples...  Note: To avoid rounding error,
//    //  we're measuring time in _microseconds_...
//    //
//
//    dwTimeBase = MulDivRN(
//                pwh->dwBufferLength,
//                1000000,
//                gti.pwfxOutput->nAvgBytesPerSec);
//
//    cSamples = MulDivRN(
//                gti.pwfxOutput->nSamplesPerSec,
//                dwTimeBase,
//                1000000);
//
//    dwRealSamplesPerSec = MulDivRN(cSamples,1000,dwTime);
//    
//    tstLog(VERBOSE,"\n(calculated) Number of samples: %lu samples.",cSamples);
//    tstLog(VERBOSE,"                  Elapsed time: %lu milliseconds.",dwTime);
//    tstLog(VERBOSE,"\nSamples Per Second:");
//    tstLog(VERBOSE,"    Real: %lu samples/second.",dwRealSamplesPerSec);
//    tstLog(VERBOSE,"   Ideal: %lu samples/second.\n",gti.pwfxOutput->nSamplesPerSec);
//
//    cbDelta = LogPercentOff(dwRealSamplesPerSec,gti.pwfxOutput->nSamplesPerSec);
//
//    tstLog(
//        VERBOSE,
//        "Percent deviation error threshold: +- %u.%04u %%",
//        (UINT)(dwThreshold / 0x10000),
//        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));
//
//    if(cbDelta > dwThreshold)
//    {
//        tstLog(TERSE,"    FAIL: Rate is off by too much.");
//
//        iResult = TST_FAIL;
//    }
//    else
//    {
//        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
//    }
//
//    cbError = dwRealBytesPerSec / 333;
//
//    pwh->dwFlags &= (~WHDR_DONE);
//
//    waveOutReset(hwo);
//
//    mmt.wType = TIME_BYTES;
//
//    tstLog(VERBOSE,"\n\nStage 2:Testing for drift (bytes)...");
//
//    tstLog(VERBOSE,"Maximum drift: %lu bytes.",cbError);
//
//    waveOutPause(hwo);
//    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
//    
//    dwTime = waveGetTime();
//    waveOutRestart(hwo);
//
//    for(;;)
//    {
//        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
//        
//        if(0 != mmt.u.cb)
//        {
//            dwTimeBase = waveGetTime();
//            
//            dwTimeBase -= mmt.u.cb * 1000 / gti.pwfxOutput->nAvgBytesPerSec;
//            dwInitial   = mmt.u.cb;
//
//            if(mmt.u.cb > (gti.pwfxOutput->nAvgBytesPerSec / 2))
//            {
//                waveOutReset(hwo);
//                waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
//                waveOutClose(hwo);
//
//                tstLog(VERBOSE,"Current byte: %lu",mmt.u.cb);
//
//                LogFail("waveOutGetPosition has too large granularity");
//
//                ExactHeapDestroy(hHeap);
//                return TST_FAIL;
//            }
//
//            break;
//        }
//    }
//
//    cTests = 0;
//    cFails = 0;
//
//    for(;;)
//    {
//        dwTime = waveGetTime();
//        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
//
//        if(dwTime != waveGetTime())
//        {
//            continue;
//        }
//
//        if(pwh->dwBufferLength == mmt.u.cb)
//        {
//            break;
//        }
//
//        cTests++;
//
//        cbDelta = ((dwTime - dwTimeBase) * dwRealBytesPerSec) / 1000;
//
//        cbDelta = (cbDelta > mmt.u.cb)?(cbDelta - mmt.u.cb):(mmt.u.cb - cbDelta);
//
//        if(cbDelta > cbError)
//        {
//            DPF(1,"cbDelta: %lu bytes; cbError: %lu bytes.",cbDelta,cbError);
//
//            LogFail("Position is drifting");
//            tstLog(TERSE,"     Current position: %lu bytes.",mmt.u.cb);
//
//            cbDelta = ((dwTime - dwTimeBase) * dwRealBytesPerSec) / 1000;
//            tstLog(TERSE,"    Expected position: %lu bytes.",cbDelta);
//
//            iResult = TST_FAIL;
//
//            cFails++;
//        }
//    }
//
//    if(dwInitial > gti.pwfxOutput->nAvgBytesPerSec / 250)
//    {
//        tstLog(
//            VERBOSE,
//            "Note: First non-zero position was: %lu bytes",
//            dwInitial);
//    }
//
//    if(0 == cFails)
//    {
//        LogPass("No drifting occured");
//    }
//
//    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
//    tstLog(VERBOSE,"   Number of failures: %lu",cFails);
//
//    waveOutReset(hwo);
//
//    mmt.wType = TIME_BYTES;
//
//    pwh->dwFlags &= (~WHDR_DONE);
//
//    waveOutReset(hwo);
//
//    mmt.wType = TIME_BYTES;
//
//    tstLog(VERBOSE,"\n\nStage 3:Testing for drift (samples)...");
//
//    cbError = dwRealSamplesPerSec / 333;
//
//    tstLog(VERBOSE,"Maximum drift: %lu samples.",cbError);
//
//    waveOutPause(hwo);
//    pwh->dwFlags &= (~WHDR_DONE);
//    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
//    waveOutRestart(hwo);
//
//    for(;;)
//    {
//        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
//        
//        if(0 != mmt.u.cb)
//        {
//            dwTimeBase = waveGetTime();
//            
//            dwTimeBase -= mmt.u.cb * 1000 / gti.pwfxOutput->nAvgBytesPerSec;
//            dwInitial   = mmt.u.cb;
//
//            if(mmt.u.cb > (gti.pwfxOutput->nAvgBytesPerSec / 2))
//            {
//                waveOutReset(hwo);
//                waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
//                waveOutClose(hwo);
//
//                LogFail("waveOutGetPosition has too large granularity");
//
//                ExactHeapDestroy(hHeap);
//                return TST_FAIL;
//            }
//
//            break;
//        }
//    }
//
//    cTests = 0;
//    cFails = 0;
//
//    mmt.wType  = TIME_SAMPLES;
//
//    for(;;)
//    {
//        dwTime = waveGetTime();
//        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
//
//        if(dwTime != waveGetTime())
//        {
//            continue;
//        }
//
//        if(cSamples < (mmt.u.sample + cbError))
//        {
//            break;
//        }
//
//        cTests++;
//
//        cbDelta = ((dwTime - dwTimeBase) * dwRealSamplesPerSec) / 1000;
//
//        cbDelta = (cbDelta > mmt.u.sample)?
//                  (cbDelta - mmt.u.sample):
//                  (mmt.u.sample - cbDelta);
//
//        if(cbDelta > cbError)
//        {
//            LogFail("Position is drifting");
//            tstLog(TERSE,"     Current position: %lu samples.",mmt.u.sample);
//
//            cbDelta = ((dwTime - dwTimeBase) * dwRealSamplesPerSec) / 1000;
//            tstLog(TERSE,"    Expected position: %lu samples.",cbDelta);
//
//            iResult = TST_FAIL;
//
//            cFails++;
//        }
//    }
//
//    if(dwInitial > gti.pwfxOutput->nAvgBytesPerSec / 250)
//    {
//        tstLog(
//            VERBOSE,
//            "Note: First non-zero position was: %lu bytes",
//            dwInitial);
//    }
//
//    if(0 == cFails)
//    {
//        LogPass("No drifting occured");
//    }
//
//    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
//    tstLog(VERBOSE,"   Number of failures: %lu",cFails);
//
//    waveOutReset(hwo);
//    waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
//    waveOutClose(hwo);
//
//    ExactHeapDestroy(hHeap);
//
//    return iResult;
//} // Test_waveOutGetPosition_Accuracy()


//--------------------------------------------------------------------------;
//
//  int Test_waveInGetPosition_Accuracy
//
//  Description:
//      Tests the accuracy of waveInGetPosition.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      03/16/95    Fwong       Hmmm.... Pizza.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInGetPosition_Accuracy
(
    void
)
{
    HWAVEIN             hwi;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    HANDLE              hHeap;
    MMTIME              mmtBytes,mmtSample;
    DWORD               cbDMA;
    DWORD               dwTimeBegin,dwTimeEnd,dwTime;
    DWORD               cInitBytes,cInitSamples;
    DWORD               cEndBytes, cEndSamples;
    DWORD               cbFirst,cBytes;
    DWORD               dwThreshold;
    DWORD               dwWarn, dwError;
    DWORD               cbDelta;
    DWORD               cTests,cFails;
    DWORD               dwByteRate,dwSampleRate;
    int                 iResult = TST_PASS;
    char                szFormat[MAXFMTSTR];
    static char         szTestName[] = "waveInGetPosition accuracy";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    cbDelta  = GetIniDWORD(szTestName,gszDataLength,15);
    cbDelta *= gti.pwfxInput->nAvgBytesPerSec;
    cbDelta  = ROUNDUP_TO_BLOCK(cbDelta,gti.pwfxInput->nBlockAlign);

    pwh->lpData = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbDelta);
    pwh->dwBufferLength = cbDelta;

    if(NULL == pwh->lpData)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Getting error threshold...
    //      Defaulting to 1% deviation.
    //

    dwThreshold = GetIniDWORD(szTestName,gszPercent,0x10000);

    DPF(1,"Threshold: 0x%08lx",dwThreshold);

    cbDMA = waveInDMABufferSize(gti.uInputDevice,gti.pwfxInput);

    if(0 == cbDMA)
    {
        DPF(1,"DMA size not found.  Using 1/2 second.");

        cbDMA = gti.pwfxInput->nAvgBytesPerSec / 2;
    }
    else
    {
        tstLog(VERBOSE,"Estimated DMA buffer size: %lu bytes.",cbDMA);
    }

    cInitBytes = cbDMA;
    cEndBytes  = ((DWORD)((cbDelta - 1) / cbDMA)) * cbDMA;

    //
    //  Opening device...
    //

    mmr = waveInOpen(
        &hwi,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Preparing Header...
    //

    pwh->dwBytesRecorded    = 0L;
    pwh->dwUser             = 0L;
    pwh->dwFlags            = 0L;

    mmr = waveInPrepareHeader(hwi,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        waveInReset(hwi);
        waveInClose(hwi);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmtBytes.wType  = TIME_BYTES;
    mmtSample.wType = TIME_SAMPLES;

    GetFormatName(szFormat,gti.pwfxInput,sizeof(szFormat));
    tstLog(VERBOSE,"                Format: %s",(LPSTR)szFormat);
    tstLog(VERBOSE,"Ideal initial position: %lu bytes.",cInitBytes);
    tstLog(VERBOSE,"    Ideal end position: %lu bytes.",cEndBytes);
    tstLog(VERBOSE,"         Buffer Length: %lu bytes.",pwh->dwBufferLength);
    tstLogFlush();

    tstLog(VERBOSE,"\nStage 1: Calculating Rates...\n");

    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));

    cbFirst   = 0;
    dwTimeEnd = 0;

    //
    //  Waiting for ms transition for waveGetTime.
    //

    while(0 == (0x00000001 & waveGetTime()));
    while(1 == (0x00000001 & waveGetTime()));

    waveInStart(hwi);

    for(;;)
    {
        dwTimeBegin = waveGetTime();

        waveInGetPosition(hwi,&mmtBytes,sizeof(MMTIME));
        waveInGetPosition(hwi,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTimeBegin)
        {
            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveInReset(hwi);
            waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
            waveInClose(hwi);

            LogFail("Could not successfully do two waveInGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        cbFirst = (0 == cbFirst)?(mmtBytes.u.cb):(cbFirst);

        if(cInitBytes < mmtBytes.u.cb)
        {
            cInitBytes   = mmtBytes.u.cb;
            cInitSamples = mmtSample.u.sample;

            if(cbFirst > (gti.pwfxInput->nAvgBytesPerSec / 2))
            {
                //
                //  Initial time is > 1/2 a second?!
                //

                waveInReset(hwi);
                waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
                waveInClose(hwi);

                tstLog(VERBOSE,"Current byte: %lu",cInitBytes);

                LogFail("waveInGetPosition has too large granularity");

                ExactHeapDestroy(hHeap);
                return TST_FAIL;
            }

            //
            //  From here we break out of this loop.
            //

            break;
        }
    }

    for(;;)
    {
        dwTime = waveGetTime();

        waveInGetPosition(hwi,&mmtBytes,sizeof(MMTIME));
        waveInGetPosition(hwi,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveInReset(hwi);
            waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
            waveInClose(hwi);

            LogFail("Could not successfully do two waveInGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(cEndBytes > mmtBytes.u.cb)
        {
            dwTimeEnd   = dwTime;
            cBytes      = mmtBytes.u.cb;
            cEndSamples = mmtSample.u.sample;

            continue;
        }

        if(0 == dwTimeEnd)
        {
            waveInReset(hwi);
            waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
            waveInClose(hwi);

            LogFail("Could not successfully do two waveInGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        cEndBytes = cBytes;

        break;
    }

    tstLog(VERBOSE,"Note: First non-zero position was: %lu bytes",cbFirst);

    dwTime       = dwTimeEnd - dwTimeBegin;

    tstLog(VERBOSE,"\n    Elapsed time: %lu milliseconds.",dwTime);

    tstLog(VERBOSE,"\n\nStatistics for TIME_BYTES:");
    tstLog(VERBOSE,"   Initial Position: %lu bytes.",cInitBytes);
    tstLog(VERBOSE,"       End Position: %lu bytes.",cEndBytes);

    cEndBytes   -= cInitBytes;

    tstLog(VERBOSE,"\nBytes played over elapsed time: %lu bytes.",cEndBytes);

    dwByteRate   = MulDivRN(cEndBytes,1000,dwTime);

    tstLog(
        VERBOSE,
        "\nIdeal Bytes Per Second: %lu",
        gti.pwfxInput->nAvgBytesPerSec);

    tstLog(VERBOSE," Real Bytes Per Second: %lu",dwByteRate);

    cbDelta = LogPercentOff(dwByteRate,gti.pwfxInput->nAvgBytesPerSec);

    tstLog(
        VERBOSE,
        "Percent deviation error threshold: +- %u.%04u %%",
        (UINT)(dwThreshold / 0x10000),
        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));

    if(cbDelta > dwThreshold)
    {
        tstLog(TERSE,"    FAIL: Rate is off by too much.");

        iResult = TST_FAIL;
    }
    else
    {
        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
    }

    tstLog(VERBOSE,"\n\nStatistics for TIME_SAMPLES:");
    tstLog(VERBOSE,"   Initial Position: %lu samples.",cInitSamples);
    tstLog(VERBOSE,"       End Position: %lu samples.",cEndSamples);

    cEndSamples -= cInitSamples;

    tstLog(VERBOSE,"\nSamples played over elapsed time: %lu samples.",cEndSamples);

    dwSampleRate = MulDivRN(cEndSamples,1000,dwTime);

    tstLog(
        VERBOSE,
        "Ideal Samples Per Second: %lu",
        gti.pwfxInput->nSamplesPerSec);

    tstLog(VERBOSE," Real Samples Per Second: %lu",dwSampleRate);

    cbDelta = LogPercentOff(dwSampleRate,gti.pwfxInput->nSamplesPerSec);

    tstLog(
        VERBOSE,
        "Percent deviation error threshold: +- %u.%04u %%",
        (UINT)(dwThreshold / 0x10000),
        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));

    if(cbDelta > dwThreshold)
    {
        tstLog(TERSE,"    FAIL: Rate is off by too much.");

        iResult = TST_FAIL;
    }
    else
    {
        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
    }

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        //
        //  Aborted!!  Cleaning up...
        //

        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveInReset(hwi);
        waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
        waveInClose(hwi);

        ExactHeapDestroy(hHeap);

        return TST_FAIL; 
    }

    pwh->dwFlags &= (~WHDR_DONE);

    waveInReset(hwi);

    mmtBytes.wType = TIME_BYTES;

    tstLog(VERBOSE,"\n\nStage 2: Testing for drift (bytes)...");

    //
    //  Max drift: 3 ms.
    //

    dwThreshold = 30;  // In 1/10 ms.

    dwWarn  = MulDivRN(dwByteRate,dwThreshold,10000);
    dwError = MulDivRN(dwByteRate,(dwThreshold + 5), 10000);

    tstLog(VERBOSE,"Maximum warning drift: %lu bytes.",dwWarn);
    tstLog(VERBOSE,"  Maximum error drift: %lu bytes.",dwError);

    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));

    //
    //  Waiting for ms transition for waveGetTime.
    //

    while(0 == (0x00000001 & waveGetTime()));
    while(1 == (0x00000001 & waveGetTime()));

    waveInStart(hwi);

    for(;;)
    {
        dwTime = waveGetTime();

        waveInGetPosition(hwi,&mmtBytes,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveInReset(hwi);
            waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
            waveInClose(hwi);

            LogFail("Could not successfully do a waveInGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(0 != mmtBytes.u.cb)
        {
            dwTimeBegin  = dwTime;

            cbFirst      = mmtBytes.u.cb;
            dwTimeBegin -= cbFirst * 1000 / gti.pwfxInput->nAvgBytesPerSec;

            if(cbFirst > (gti.pwfxInput->nAvgBytesPerSec / 2))
            {
                waveInReset(hwi);
                waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
                waveInClose(hwi);

                tstLog(VERBOSE,"Current bytes: %lu",cbFirst);

                LogFail("waveInGetPosition has too large granularity");

                ExactHeapDestroy(hHeap);

                return TST_FAIL;
            }

            break;
        }
    }

    cTests = 0;
    cFails = 0;

    for(;;)
    {
        dwTime = waveGetTime();

        waveInGetPosition(hwi,&mmtBytes,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            break;
        }

        if(pwh->dwBufferLength == mmtBytes.u.cb)
        {
            break;
        }

        cTests++;

        cBytes = ((dwTime - dwTimeBegin) * dwByteRate) / 1000;

        cbDelta = (cBytes > mmtBytes.u.cb)?
                  (cBytes - mmtBytes.u.cb):
                  (mmtBytes.u.cb - cBytes);

        if(cbDelta > dwWarn)
        {
            if(cbDelta > dwError)
            {
                LogFail("Position is drifting");

                iResult = TST_FAIL;

                cFails++;
            }
            else
            {
                tstLog(TERSE,"\n    WARNING: Position is drifting.");
            }

            tstLog(TERSE,"     Current position: %lu bytes.",mmtBytes.u.cb);
            tstLog(TERSE,"    Expected position: %lu bytes.",cBytes);
        }
    }

    tstLog(VERBOSE,"Note: First non-zero position was: %lu bytes",cbFirst);

    if(0 == cFails)
    {
        LogPass("No drifting occured");
    }

    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
    tstLog(VERBOSE,"   Number of failures: %lu",cFails);

    //
    //  Should be at last sample; getting last sample.
    //

    waveInGetPosition(hwi,&mmtSample,sizeof(MMTIME));

    dwTimeEnd = mmtSample.u.sample;

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        //
        //  Aborted!!  Cleaning up...
        //

        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveInReset(hwi);
        waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
        waveInClose(hwi);

        ExactHeapDestroy(hHeap);

        return TST_FAIL; 
    }

    pwh->dwFlags &= (~WHDR_DONE);

    waveInReset(hwi);

    mmtSample.wType = TIME_SAMPLES;

    tstLog(VERBOSE,"\n\nStage 3: Testing for drift (samples)...");

    //
    //  Max drift: 3 ms.
    //

    dwThreshold = 30;  // In 1/10 ms.

    dwWarn  = MulDivRN(dwSampleRate,dwThreshold,10000);
    dwError = MulDivRN(dwSampleRate,(dwThreshold + 5), 10000);

    tstLog(VERBOSE,"Maximum warning drift: %lu samples.",dwWarn);
    tstLog(VERBOSE,"  Maximum error drift: %lu samples.",dwError);

    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));

    //
    //  Waiting for ms transition for waveGetTime.
    //

    while(0 == (0x00000001 & waveGetTime()));
    while(1 == (0x00000001 & waveGetTime()));

    waveInStart(hwi);

    for(;;)
    {
        dwTime = waveGetTime();

        waveInGetPosition(hwi,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            waveInReset(hwi);
            waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
            waveInClose(hwi);

            LogFail("Could not successfully do a waveInGetPosition "
                "within one millisecond");

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(0 != mmtSample.u.sample)
        {
            dwTimeBegin  = dwTime;

            cbFirst      = mmtSample.u.sample;
            dwTimeBegin -= cbFirst * 1000 / gti.pwfxInput->nSamplesPerSec;

            if(cbFirst > (gti.pwfxInput->nSamplesPerSec / 2))
            {
                waveInReset(hwi);
                waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
                waveInClose(hwi);

                tstLog(VERBOSE,"Current samples: %lu",cbFirst);

                LogFail("waveInGetPosition has too large granularity");

                ExactHeapDestroy(hHeap);

                return TST_FAIL;
            }

            break;
        }
    }

    cTests = 0;
    cFails = 0;

    for(;;)
    {
        dwTime = waveGetTime();

        waveInGetPosition(hwi,&mmtSample,sizeof(MMTIME));

        if(waveGetTime() != dwTime)
        {
            //
            //  We want to make sure the time stamps map to a millisecond.
            //

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                continue;
            }

            break;
        }

        if(dwTimeEnd == mmtSample.u.sample)
        {
            break;
        }

        cTests++;

        cBytes = ((dwTime - dwTimeBegin) * dwSampleRate) / 1000;

        cbDelta = (cBytes > mmtSample.u.cb)?
                  (cBytes - mmtSample.u.cb):
                  (mmtSample.u.cb - cBytes);

        if(cbDelta > dwWarn)
        {
            if(cbDelta > dwError)
            {
                LogFail("Position is drifting");
                iResult = TST_FAIL;
                cFails++;
            }
            else
            {
                tstLog(TERSE,"\n    WARNING: Position is drifting.");
            }

            tstLog(
                TERSE,
                "     Current position: %lu samples.",
                mmtSample.u.sample);

            tstLog(TERSE,"    Expected position: %lu samples.",cBytes);
        }
    }

    tstLog(VERBOSE,"Note: First non-zero position was: %lu samples",cbFirst);

    if(0 == cFails)
    {
        LogPass("No drifting occured");
    }

    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
    tstLog(VERBOSE,"   Number of failures: %lu\n\n",cFails);

    waveInReset(hwi);
    waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
    waveInClose(hwi);

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveInGetPosition_Accuracy()


//int FNGLOBAL Test_waveInGetPosition_Accuracy
//(
//    void
//)
//{
//    HWAVEIN             hwi;
//    MMRESULT            mmr;
//    volatile LPWAVEHDR  pwh;
//    HANDLE              hHeap;
//    MMTIME              mmt;
//    DWORD               dwTime, dwTimeBase;
//    DWORD               dwRealBytesPerSec;
//    DWORD               dwRealSamplesPerSec;
//    DWORD               cbError,cbDelta;
//    DWORD               dwThreshold, dwInitial;
//    DWORD               cSamples,cTests,cFails;
//    int                 iResult = TST_PASS;
//    static char         szTestName[] = "waveInGetPosition accuracy";
//
//    Log_TestName(szTestName);
//
//    if(0 == waveInGetNumDevs())
//    {
//        tstLog(TERSE,gszMsgNoInDevs);
//
//        return iResult;
//    }
//
//    //
//    //  Allocating memory...
//    //
//
//    hHeap = ExactHeapCreate(0L);
//
//    if(NULL == hHeap)
//    {
//        LogFail(gszFailNoMem);
//
//        return TST_FAIL;
//    }
//
//    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));
//
//    if(NULL == pwh)
//    {
//        LogFail(gszFailNoMem);
//
//        ExactHeapDestroy(hHeap);
//
//        return TST_FAIL;
//    }
//
//    cbSize  = GetIniDWORD(szTestName,gszDataLength,5);
//    cbSize *= gti.pwfxInput->nAvgBytesPerSec;
//    cbSize  = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);
//
//    pwh->lpData = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbDelta);
//
//    if(NULL == pwh->lpData)
//    {
//        LogFail(gszFailNoMem);
//
//        ExactHeapDestroy(hHeap);
//
//        return TST_FAIL;
//    }
//
//    pwh->dwBufferLength = cbDelta;
//
//    //
//    //  Getting error threshold...
//    //      Defaulting to 1% deviation.
//    //
//
//    dwThreshold = GetIniDWORD(szTestName,gszPercent,0x10000);
//
//    //
//    //  Opening device...
//    //
//
//    mmr = waveInOpen(
//        &hwi,
//        gti.uInputDevice,
//        gti.pwfxInput,
//        0L,
//        0L,
//        INPUT_MAP(gti));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailOpen);
//
//        ExactHeapDestroy(hHeap);
//        return TST_FAIL;
//    }
//
//    //
//    //  Preparing Header...
//    //
//
//    pwh->dwBytesRecorded    = 0L;
//    pwh->dwUser             = 0L;
//    pwh->dwFlags            = 0L;
//
//    mmr = waveInPrepareHeader(hwi,pwh,sizeof(WAVEHDR));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailWOPrepare);
//
//        waveInReset(hwi);
//        waveInClose(hwi);
//
//        ExactHeapDestroy(hHeap);
//        return TST_FAIL;
//    }
//
//    mmt.wType = TIME_BYTES;
//
//    tstLog(VERBOSE,"\nStage 1: Calculating Rates...\n");
//    tstLog(VERBOSE,"    Buffer Length: %lu bytes.",pwh->dwBufferLength);
//
//    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));
//
//    dwTime = waveGetTime();
//    waveInStart(hwi);
//
//    for(;;)
//    {
//        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));
//        
//        if(0 != mmt.u.cb)
//        {
//            dwTimeBase = waveGetTime();
//            
//            dwTimeBase -= mmt.u.cb * 1000 / gti.pwfxInput->nAvgBytesPerSec;
//            dwInitial   = mmt.u.cb;
//
//            if(mmt.u.cb > (gti.pwfxInput->nAvgBytesPerSec / 2))
//            {
//                waveInReset(hwi);
//                waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
//                waveInClose(hwi);
//
//                tstLog(VERBOSE,"Current byte: %lu",mmt.u.cb);
//
//                LogFail("waveInGetPosition has too large granularity");
//
//                ExactHeapDestroy(hHeap);
//                return TST_FAIL;
//            }
//
//            break;
//        }
//    }
//
//    dwTime = pwh->dwBufferLength * 2000 / gti.pwfxInput->nAvgBytesPerSec +
//             dwTimeBase;
//
//    for(;;)
//    {
//        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));
//
//        if(pwh->dwBufferLength == mmt.u.cb)
//        {
//            dwTime = waveGetTime();
//
//            break;
//        }
//
//        if(dwTime < waveGetTime())
//        {
//            waveInReset(hwi);
//            waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
//            waveInClose(hwi);
//
//            LogFail("Timed out waiting for WAVEHDR.");
//
//            ExactHeapDestroy(hHeap);
//            return TST_FAIL;
//        }
//    }
//
//    dwTime -= dwTimeBase;
//
//    dwRealBytesPerSec = MulDivRN(pwh->dwBufferLength,1000,dwTime);
//
//    if(dwInitial > gti.pwfxInput->nAvgBytesPerSec / 250)
//    {
//        tstLog(
//            VERBOSE,
//            "Note: First non-zero position was: %lu bytes",
//            dwInitial);
//    }
//
//    tstLog(VERBOSE,"     Elapsed Time: %lu milliseconds.",dwTime);
//    tstLog(VERBOSE,"\nBytes Per Second:");
//    tstLog(VERBOSE,"    Real: %lu bytes/second.",dwRealBytesPerSec);
//    tstLog(VERBOSE,"   Ideal: %lu bytes/second.\n",gti.pwfxInput->nAvgBytesPerSec);
//
//    cbDelta = LogPercentOff(dwRealBytesPerSec,gti.pwfxInput->nAvgBytesPerSec);
//
//    tstLog(
//        VERBOSE,
//        "Percent deviation error threshold: +- %u.%04u %%",
//        (UINT)(dwThreshold / 0x10000),
//        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));
//
//    if(cbDelta > dwThreshold)
//    {
//        tstLog(TERSE,"    FAIL: Rate is off by too much.");
//
//        iResult = TST_FAIL;
//    }
//    else
//    {
//        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
//    }
//
//    //
//    //  Calculating number of samples...  Note: To avoid rounding error,
//    //  we're measuring time in _microseconds_...
//    //
//
//    dwTimeBase = MulDivRN(
//                pwh->dwBufferLength,
//                1000000,
//                gti.pwfxInput->nAvgBytesPerSec);
//
//    cSamples = MulDivRN(
//                gti.pwfxInput->nSamplesPerSec,
//                dwTimeBase,
//                1000000);
//
//    dwRealSamplesPerSec = MulDivRN(cSamples,1000,dwTime);
//    
//    tstLog(VERBOSE,"\n(calculated) Number of samples: %lu samples.",cSamples);
//    tstLog(VERBOSE,"                  Elapsed time: %lu milliseconds.",dwTime);
//    tstLog(VERBOSE,"\nSamples Per Second:");
//    tstLog(VERBOSE,"    Real: %lu samples/second.",dwRealSamplesPerSec);
//    tstLog(VERBOSE,"   Ideal: %lu samples/second.\n",gti.pwfxInput->nSamplesPerSec);
//
//    cbDelta = LogPercentOff(dwRealSamplesPerSec,gti.pwfxInput->nSamplesPerSec);
//
//    tstLog(
//        VERBOSE,
//        "Percent deviation error threshold: +- %u.%04u %%",
//        (UINT)(dwThreshold / 0x10000),
//        (UINT)((dwThreshold & 0xffff) * 10000 / 0x10000));
//
//    if(cbDelta > dwThreshold)
//    {
//        tstLog(TERSE,"    FAIL: Rate is off by too much.");
//
//        iResult = TST_FAIL;
//    }
//    else
//    {
//        tstLog(VERBOSE,"    PASS: Rate is off by acceptable limits.");
//    }
//
//    cbError = dwRealBytesPerSec / 333;
//
//    pwh->dwFlags &= (~WHDR_DONE);
//
//    waveInReset(hwi);
//
//    mmt.wType = TIME_BYTES;
//
//    tstLog(VERBOSE,"\n\nStage 2:Testing for drift (bytes)...");
//
//    tstLog(VERBOSE,"Maximum drift: %lu bytes.",cbError);
//
//    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));
//    
//    dwTime = waveGetTime();
//    waveInStart(hwi);
//
//    for(;;)
//    {
//        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));
//        
//        if(0 != mmt.u.cb)
//        {
//            dwTimeBase = waveGetTime();
//            
//            dwTimeBase -= mmt.u.cb * 1000 / gti.pwfxInput->nAvgBytesPerSec;
//            dwInitial   = mmt.u.cb;
//
//            if(mmt.u.cb > (gti.pwfxInput->nAvgBytesPerSec / 2))
//            {
//                waveInReset(hwi);
//                waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
//                waveInClose(hwi);
//
//                tstLog(VERBOSE,"Current byte: %lu",mmt.u.cb);
//
//                LogFail("waveInGetPosition has too large granularity");
//
//                ExactHeapDestroy(hHeap);
//                return TST_FAIL;
//            }
//
//            break;
//        }
//    }
//
//    cTests = 0;
//    cFails = 0;
//
//    for(;;)
//    {
//        dwTime = waveGetTime();
//        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));
//
//        if(dwTime != waveGetTime())
//        {
//            continue;
//        }
//
//        if(pwh->dwBufferLength == mmt.u.cb)
//        {
//            break;
//        }
//
//        cTests++;
//
//        cbDelta = ((dwTime - dwTimeBase) * dwRealBytesPerSec) / 1000;
//
//        cbDelta = (cbDelta > mmt.u.cb)?(cbDelta - mmt.u.cb):(mmt.u.cb - cbDelta);
//
//        if(cbDelta > cbError)
//        {
//            DPF(1,"cbDelta: %lu bytes; cbError: %lu bytes.",cbDelta,cbError);
//
//            LogFail("Position is drifting");
//            tstLog(TERSE,"     Current position: %lu bytes.",mmt.u.cb);
//
//            cbDelta = ((dwTime - dwTimeBase) * dwRealBytesPerSec) / 1000;
//            tstLog(TERSE,"    Expected position: %lu bytes.",cbDelta);
//
//            iResult = TST_FAIL;
//
//            cFails++;
//        }
//    }
//
//    if(dwInitial > gti.pwfxInput->nAvgBytesPerSec / 250)
//    {
//        tstLog(
//            VERBOSE,
//            "Note: First non-zero position was: %lu bytes",
//            dwInitial);
//    }
//
//    if(0 == cFails)
//    {
//        LogPass("No drifting occured");
//    }
//
//    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
//    tstLog(VERBOSE,"   Number of failures: %lu",cFails);
//
//    waveInReset(hwi);
//
//    mmt.wType = TIME_BYTES;
//
//    pwh->dwFlags &= (~WHDR_DONE);
//
//    waveInReset(hwi);
//
//    mmt.wType = TIME_BYTES;
//
//    tstLog(VERBOSE,"\n\nStage 3:Testing for drift (samples)...");
//
//    cbError = dwRealSamplesPerSec / 333;
//
//    tstLog(VERBOSE,"Maximum drift: %lu samples.",cbError);
//
//    pwh->dwFlags &= (~WHDR_DONE);
//    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));
//    waveInStart(hwi);
//
//    for(;;)
//    {
//        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));
//        
//        if(0 != mmt.u.cb)
//        {
//            dwTimeBase = waveGetTime();
//            
//            dwTimeBase -= mmt.u.cb * 1000 / gti.pwfxInput->nAvgBytesPerSec;
//            dwInitial   = mmt.u.cb;
//
//            if(mmt.u.cb > (gti.pwfxInput->nAvgBytesPerSec / 2))
//            {
//                waveInReset(hwi);
//                waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
//                waveInClose(hwi);
//
//                LogFail("waveInGetPosition has too large granularity");
//
//                ExactHeapDestroy(hHeap);
//                return TST_FAIL;
//            }
//
//            break;
//        }
//    }
//
//    cTests = 0;
//    cFails = 0;
//
//    mmt.wType  = TIME_SAMPLES;
//
//    for(;;)
//    {
//        dwTime = waveGetTime();
//        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));
//
//        if(dwTime != waveGetTime())
//        {
//            continue;
//        }
//
//        if(cSamples < (mmt.u.sample + cbError))
//        {
//            break;
//        }
//
//        cTests++;
//
//        cbDelta = ((dwTime - dwTimeBase) * dwRealSamplesPerSec) / 1000;
//
//        cbDelta = (cbDelta > mmt.u.sample)?
//                  (cbDelta - mmt.u.sample):
//                  (mmt.u.sample - cbDelta);
//
//        if(cbDelta > cbError)
//        {
//            LogFail("Position is drifting");
//            tstLog(TERSE,"     Current position: %lu samples.",mmt.u.sample);
//
//            cbDelta = ((dwTime - dwTimeBase) * dwRealSamplesPerSec) / 1000;
//            tstLog(TERSE,"    Expected position: %lu samples.",cbDelta);
//
//            iResult = TST_FAIL;
//
//            cFails++;
//        }
//    }
//
//    if(dwInitial > gti.pwfxInput->nAvgBytesPerSec / 250)
//    {
//        tstLog(
//            VERBOSE,
//            "Note: First non-zero position was: %lu bytes",
//            dwInitial);
//    }
//
//    if(0 == cFails)
//    {
//        LogPass("No drifting occured");
//    }
//
//    tstLog(VERBOSE,"\nNumber of comparisons: %lu",cTests);
//    tstLog(VERBOSE,"   Number of failures: %lu",cFails);
//
//    waveInReset(hwi);
//    waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
//    waveInClose(hwi);
//
//    ExactHeapDestroy(hHeap);
//
//    return iResult;
//} // Test_waveInGetPosition_Accuracy()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutWrite_TimeAccuracy
//
//  Description:
//      Tests the driver for time accuracy of callbacks.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      11/16/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutWrite_TimeAccuracy
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    DWORD               dw;
    DWORD               dwOffset;
    DWORD               cbSize;
    DWORD               dwTime;
    DWORD               cNumBuffers;
    DWORD               dwError;
    HANDLE              hHeap;
    LPWAVEINFO          pwi;
    WAVEOUTCAPS         woc;
    MMTIME              mmt;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutWrite callback accuracy";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_SYNC)
    {
        LogPass("Device is synchronous.  Test not valid");

        return TST_PASS;
    }

    //
    //  Getting number of buffers...
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(
            hHeap,
            GMEM_MOVEABLE|GMEM_SHARE,
            cNumBuffers * sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwi = ExactHeapAllocPtr(
            hHeap,
            GMEM_MOVEABLE|GMEM_SHARE,
            sizeof(WAVEINFO) + cNumBuffers*sizeof(DWORD));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Making buffers 1/60 second for now.
    //

    cbSize = gti.pwfxOutput->nAvgBytesPerSec / 60;
    cbSize = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxOutput->nBlockAlign);

    PageLock(pwi);

    pwi->dwInstance = 0L;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = cNumBuffers;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        (DWORD)(FARPROC)pfnCallBack,
        0L,
        CALLBACK_FUNCTION|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Preparing headers...
    //

    for(dw = cNumBuffers,dwOffset = 0;dw;dw--)
    {
        //
        //  Put stuff here...
        //

        pwh[dw-1].lpData          = (LPBYTE)(&gti.wrLong.pData[dwOffset]);
        pwh[dw-1].dwBufferLength  = cbSize;
        pwh[dw-1].dwBytesRecorded = 0L;
        pwh[dw-1].dwUser          = 0L;
        pwh[dw-1].dwFlags         = 0L;
        pwh[dw-1].dwLoops         = 0L;
        pwh[dw-1].lpNext          = NULL;
        pwh[dw-1].reserved        = 0L;

        mmr = waveOutPrepareHeader(hWaveOut,&(pwh[dw-1]),sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail(gszFailWOPrepare);

            for(;dw < cNumBuffers;dw++)
            {
                waveOutUnprepareHeader(hWaveOut,&(pwh[dw]),sizeof(WAVEHDR));
            }

            call_waveOutClose(hWaveOut);

            PageUnlock(pwi);

            ExactHeapDestroy(hHeap);
        
            return TST_FAIL;
        }

        dwOffset += cbSize;

        dwOffset = (dwOffset > gti.wrLong.cbSize)?0:dwOffset;
    }

    waveOutPause(hWaveOut);

    //
    //  Writing headers...
    //

    for(dw = cNumBuffers;dw;dw--)
    {
        waveOutWrite(hWaveOut,&(pwh[dw-1]),sizeof(WAVEHDR));
    }

    mmt.wType = TIME_BYTES;

    waveOutRestart(hWaveOut);

    for(;;)
    {
        waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(mmt.u.cb)
        {
            dwTime = waveGetTime();
            break;
        }
    }

    //
    //  Unpreparing headers...
    //

    for(dw = cNumBuffers;dw;dw--)
    {
        while(!(WHDR_DONE & pwh[dw-1].dwFlags));
    }

    for(dw = cNumBuffers;dw;dw--)
    {
        waveOutUnprepareHeader(hWaveOut,&(pwh[dw-1]),sizeof(WAVEHDR));
    }

    Log_TestCase("~Verifying callback accuracy");

    //
    //  Defaults to 1/15th of a second.
    //

    dwError = 1000 / 15;

    dwError = GetIniDWORD(szTestName,gszDelta,dwError);

    for(dw = cNumBuffers;dw;dw--)
    {
        pwi->adwTime[dw-1] -= dwTime;
        dwOffset = (cbSize * dw * 1000) / (gti.pwfxOutput->nAvgBytesPerSec);

        if(pwi->adwTime[dw-1] >= (dwOffset + dwError))
        {
            tstLog(TERSE,"    FAIL: Callback time not within %lu ms.",dwError);

            tstLog(
                TERSE,
                "Callback Time: %lu\nExpected Time: %lu",
                pwi->adwTime[dw-1],
                dwOffset);

            iResult = TST_FAIL;
        }
        else
        {
            tstLog(VERBOSE,"    PASS: Callback time within %lu ms.",dwError);
        }
    }

    if(pwi->fdwFlags & WHDR_DONE_ERROR)
    {
        LogFail("WHDR_DONE bit not set before callback");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("WHDR_DONE bit set before callback");
    }

    call_waveOutClose(hWaveOut);

    DLL_WaveControl(DLL_END,NULL);

    PageUnlock(pwi);

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveOutWrite_TimeAccuracy()


int FNGLOBAL Test_waveInAddBuffer_TimeAccuracy
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    DWORD               dw;
    DWORD               dwOffset;
    DWORD               cbSize;
    DWORD               dwTime;
    DWORD               cNumBuffers;
    DWORD               dwError;
    HANDLE              hHeap;
    LPWAVEINFO          pwi;
    WAVEINCAPS          wic;
    LPBYTE              pData;
    MMTIME              mmt;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInAddBuffer callback accuracy";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    mmr = call_waveInGetDevCaps(gti.uInputDevice,&wic,sizeof(WAVEINCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    //
    //  Getting number of buffers...
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(
            hHeap,
            GMEM_MOVEABLE|GMEM_SHARE,
            cNumBuffers * sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwi = ExactHeapAllocPtr(
            hHeap,
            GMEM_MOVEABLE|GMEM_SHARE,
            sizeof(WAVEINFO) + cNumBuffers*sizeof(DWORD));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Making buffers 1/60 second for now.
    //

    cbSize = gti.pwfxInput->nAvgBytesPerSec / 60;
    cbSize = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);

    pData = ExactHeapAllocPtr(
            hHeap,
            GMEM_MOVEABLE|GMEM_SHARE,
            cbSize * cNumBuffers);

    if(NULL == pData)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    PageLock(pwi);

    pwi->dwInstance = 0L;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = cNumBuffers;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        (DWORD)(FARPROC)pfnCallBack,
        0L,
        CALLBACK_FUNCTION|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Preparing headers...
    //

    for(dw = cNumBuffers,dwOffset = 0;dw;dw--)
    {
        //
        //  Put stuff here...
        //

        pwh[dw-1].lpData          = (LPBYTE)(&pData[dwOffset]);
        pwh[dw-1].dwBufferLength  = cbSize;
        pwh[dw-1].dwBytesRecorded = 0L;
        pwh[dw-1].dwUser          = 0L;
        pwh[dw-1].dwFlags         = 0L;
        pwh[dw-1].dwLoops         = 0L;
        pwh[dw-1].lpNext          = NULL;
        pwh[dw-1].reserved        = 0L;

        mmr = waveInPrepareHeader(hWaveIn,&(pwh[dw-1]),sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail(gszFailWIPrepare);

            for(;dw < cNumBuffers;dw++)
            {
                waveInUnprepareHeader(hWaveIn,&(pwh[dw]),sizeof(WAVEHDR));
            }

            call_waveInClose(hWaveIn);

            PageUnlock(pwi);

            ExactHeapDestroy(hHeap);
        
            return TST_FAIL;
        }

        dwOffset += cbSize;
    }

    //
    //  Sending buffers headers...
    //

    for(dw = cNumBuffers;dw;dw--)
    {
        waveInAddBuffer(hWaveIn,&(pwh[dw-1]),sizeof(WAVEHDR));
    }

    mmt.wType = TIME_BYTES;

    waveInStart(hWaveIn);

    for(;;)
    {
        waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

        if(0 != mmt.u.cb)
        {
            dwTime = waveGetTime();

            break;
        }
    }

    //
    //  Unpreparing headers...
    //

    tstLog(VERBOSE,"<< Polling WHDR_DONE bit in header(s). >>");

    for(dw = cNumBuffers;dw;dw--)
    {
        while(!(WHDR_DONE & pwh[dw-1].dwFlags));
    }

    for(dw = cNumBuffers;dw;dw--)
    {
        waveInUnprepareHeader(hWaveIn,&(pwh[dw-1]),sizeof(WAVEHDR));
    }

    Log_TestCase("~Verifying callback accuracy");

    //
    //  Defaults to 1/15th of a second.
    //

    dwError = 1000 / 15;

    dwError = GetIniDWORD(szTestName,gszDelta,dwError);

    for(dw = cNumBuffers;dw;dw--)
    {
        pwi->adwTime[dw-1] -= dwTime;
        dwOffset = (cbSize * dw * 1000) / (gti.pwfxInput->nAvgBytesPerSec);

        if(pwi->adwTime[dw-1] >= (dwOffset + dwError))
        {
            tstLog(TERSE,"    FAIL: Callback time not within %lu ms.",dwError);

            tstLog(
                TERSE,
                "Callback Time: %lu\nExpected Time: %lu",
                pwi->adwTime[dw-1],
                dwOffset);

            iResult = TST_FAIL;
        }
        else
        {
            tstLog(VERBOSE,"    PASS: Callback time within %lu ms.",dwError);
        }
    }

    if(pwi->fdwFlags & WHDR_DONE_ERROR)
    {
        LogFail("WHDR_DONE bit not set before callback");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("WHDR_DONE bit set before callback");
    }

    call_waveInClose(hWaveIn);

    DLL_WaveControl(DLL_END,NULL);

    PageUnlock(pwi);

    //
    //  Playing recorded stuff...
    //

    PlayWaveResource(gti.pwfxInput, pData, cNumBuffers * cbSize);

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveInAddBuffer_TimeAccuracy()


int FNLOCAL waveOutGetStats
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    LPWAVERESOURCE  pwr
)
{
    HWAVEOUT            hwo;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    DWORD               dwTimeBase, dwTimeEnd, dwTimeReset;
    DWORD               dwPos, cbLast, cLastSample;
    DWORD               cLoops, cPositions, cLoopsTGT;
    DWORD               dwDeltaMin, dwDeltaAvg, dwDeltaMax;
    DWORD               dwTestLength;
    MMTIME              mmt;
    HANDLE              hHeap;

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    dwTestLength = GetIniDWORD(gszGlobal,gszTestDuration,30);
    dwTestLength = min(dwTestLength,100);

    mmr = waveOutOpen(
            &hwo,
            uDeviceID,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"waveOutOpen failed: 0x%08lx",(DWORD)mmr);

        LogFail("waveOutOpen failed");

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwh->lpData          = pwr->pData;           
    pwh->dwBufferLength  = pwr->cbSize;   
    pwh->dwBytesRecorded = 0L;  
    pwh->dwUser          = 0L;           
    pwh->dwFlags         = 0L;          
    pwh->dwLoops         = 0L;          
    pwh->lpNext          = 0L;
    pwh->reserved        = 0L;         

    mmr = waveOutPrepareHeader(hwo,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"waveOutPrepareHeader failed: 0x%08lx",(DWORD)mmr);

        LogFail("waveOutOpen failed");

        waveOutClose(hwo);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Reporting size(s) first.
    //

    tstLog(VERBOSE,"  Buffer Size: %lu bytes.",pwr->cbSize);
    tstLog(
        VERBOSE,
        "Buffer Length: %lu ms.",
        MulDivRN(pwr->cbSize,1000,pwfx->nAvgBytesPerSec));

    waveOutPause(hwo);
    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
    waveOutRestart(hwo);

    dwTimeBase = waveGetTime();

    //
    //  Trying to measure the number of waveOutGetPosition's in a millisecond.
    //

    cLoops    = 0;
    mmt.wType = TIME_BYTES;
    
    dwTimeEnd = dwTestLength + 1;

    while(dwTestLength != (waveGetTime() % dwTimeEnd));
    while(dwTestLength == (waveGetTime() % dwTimeEnd));

    while(dwTestLength != (waveGetTime() % dwTimeEnd))
    {
        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
        cLoops++;
    }

    //
    //  Calculating amount of time required to do a waveGetTime.
    //

    cLoopsTGT = 0;

    while(dwTestLength != (waveGetTime() % dwTimeEnd));
    while(dwTestLength == (waveGetTime() % dwTimeEnd));

    while(dwTestLength != (waveGetTime() % dwTimeEnd))
    {
        cLoopsTGT++;
    }

    //
    //  Converting to microseconds.
    //

    cLoopsTGT = MulDivRN(dwTestLength,1000,cLoopsTGT);

    //
    //  Number of microseconds avg time per loop - time for calling
    //  waveGetTime.
    //

    cLoops = MulDivRN(dwTestLength,1000,cLoops) - cLoopsTGT;

    //
    //  Polling WHDR_DONE bit.
    //

    while(!(pwh->dwFlags & WHDR_DONE));

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveOutReset(hwo);
        waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
        waveOutClose(hwo);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    dwTimeEnd = waveGetTime() - dwTimeBase;

    mmt.wType = TIME_BYTES;

    waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

    cbLast = mmt.u.cb;

    mmt.wType = TIME_SAMPLES;

    waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

    cLastSample = mmt.u.sample;

    tstLog(VERBOSE,"\nLast Position: %lu bytes.",cbLast);
    tstLog(VERBOSE,"Last Position: %lu samples.",cLastSample);

    dwTimeBase = waveGetTime();
    waveOutReset(hwo);
    dwTimeReset = waveGetTime() - dwTimeBase;

    tstLog(VERBOSE,"Time for Reset: %lu ms.",dwTimeReset);
    tstLog(VERBOSE,"\nTime Played: %lu ms.",dwTimeEnd);
    tstLog(VERBOSE,"  (Time from waveOutRestart to WHDR_DONE bit set.)");
    tstLog(
        VERBOSE,
        "Avg time for waveOutGetPosition: %lu microseconds.",
        cLoops);

    dwDeltaMin = (DWORD)(-1);
    dwDeltaMax = 0;
    dwDeltaAvg = 0;
    cPositions = 0;

    dwPos      = 0;
    
    mmt.wType  = TIME_BYTES;

    pwh->dwFlags &= ~(WHDR_DONE);

    waveOutPause(hwo);
    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
    waveOutRestart(hwo);

    while(!(pwh->dwFlags & WHDR_DONE))
    {
        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

        if(mmt.u.cb != dwPos)
        {
            dwPos = mmt.u.cb - dwPos;

            dwDeltaMin  = min(dwPos,dwDeltaMin);
            dwDeltaMax  = max(dwPos,dwDeltaMax);
            
            dwDeltaAvg += dwPos;
            cPositions++;

            dwPos = mmt.u.cb;
        }
    }

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveOutReset(hwo);
        waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
        waveOutClose(hwo);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    tstLog(VERBOSE,"\nUsing TIME_BYTES:");
    tstLog(VERBOSE,"  Minimum Delta: %lu bytes.",dwDeltaMin);
    tstLog(VERBOSE,"  Maximum Delta: %lu bytes.",dwDeltaMax);
    tstLog(
        VERBOSE,
        "  Average Delta: %lu.%03lu bytes.",
        dwDeltaAvg/cPositions,
        (MulDivRN(dwDeltaAvg,1000,cPositions)) % 1000);

    waveOutReset(hwo);

    dwDeltaMin = (DWORD)(-1);
    dwDeltaMax = 0;
    dwDeltaAvg = 0;
    cPositions = 0;

    dwPos      = 0;
    
    mmt.wType  = TIME_SAMPLES;

    pwh->dwFlags &= ~(WHDR_DONE);

    waveOutPause(hwo);
    waveOutWrite(hwo,pwh,sizeof(WAVEHDR));
    waveOutRestart(hwo);

    while(!(pwh->dwFlags & WHDR_DONE))
    {
        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

        if(mmt.u.cb != dwPos)
        {
            dwPos = mmt.u.cb - dwPos;

            dwDeltaMin  = min(dwPos,dwDeltaMin);
            dwDeltaMax  = max(dwPos,dwDeltaMax);
            
            dwDeltaAvg += dwPos;
            cPositions++;

            dwPos = mmt.u.cb;
        }
    }

    tstLog(VERBOSE,"\nUsing TIME_SAMPLES:");
    tstLog(VERBOSE,"  Minimum Delta: %lu samples.",dwDeltaMin);
    tstLog(VERBOSE,"  Maximum Delta: %lu samples.",dwDeltaMax);
    tstLog(
        VERBOSE,
        "  Average Delta: %lu.%03lu samples.",
        dwDeltaAvg/cPositions,
        (MulDivRN(dwDeltaAvg,1000,cPositions)) % 1000);


    waveOutReset(hwo);
    waveOutUnprepareHeader(hwo,pwh,sizeof(WAVEHDR));
    waveOutClose(hwo);
     
    ExactHeapDestroy(hHeap);

    return TST_PASS;
} // waveOutGetStats()


int FNGLOBAL Test_waveOutGetPosition_Performance
(
    void
)
{
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               dwFormat;
    HANDLE              hHeap;
    WAVERESOURCE        wr;
    char                szFormat[MAXFMTSTR];
    static char         szTestName[] = "waveOutGetPosition performance";
    int                 iResult = TST_PASS;

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwfx = ExactHeapAllocPtr(
            hHeap,
            GMEM_MOVEABLE|GMEM_SHARE,
            gti.cbMaxFormatSize);

    if(NULL == pwfx)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    for(dwFormat = tstGetNumFormats();dwFormat;dwFormat--)
    {
        if(!tstGetFormat(pwfx,gti.cbMaxFormatSize,dwFormat-1))
        {
            DPF(1,"Couldn't get format #%d.",dwFormat-1);

            continue;
        }

        mmr = waveOutOpen(
            NULL,
            gti.uOutputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_ALLOWSYNC|WAVE_FORMAT_QUERY|OUTPUT_MAP(gti));

        if(MMSYSERR_NOERROR != mmr)
        {
            continue;
        }

        wr.pData = NULL;

        LoadWaveResource(&wr,WR_MEDIUM);

        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        if(!ConvertWaveResource(gti.pwfxOutput,pwfx,&wr))
        {
            DPF(1,"Could not create resource for %s",(LPSTR)szFormat);

            ExactFreePtr(wr.pData);

            continue;
        }

        tstLog(VERBOSE,"\n\nTesting format: %s",(LPSTR)szFormat);
        tstLogFlush();

        tstBeginSection(NULL);
        iResult &= waveOutGetStats(gti.uOutputDevice,pwfx,&wr);
        tstEndSection();

        //
        //  Does user want to abort?
        //

        TestYield();

        if(tstCheckRunStop(VK_ESCAPE))
        {
            tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
            tstLogFlush();

            ExactFreePtr(wr.pData);
            ExactHeapDestroy(hHeap);

            return TST_FAIL;
        }

        ExactFreePtr(wr.pData);
    }

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveOutGetPosition_Performance()


int FNLOCAL waveInGetStats
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    LPWAVERESOURCE  pwr
)
{
    HWAVEIN             hwi;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    DWORD               dwTimeBase, dwTimeEnd, dwTimeReset;
    DWORD               dwPos, cbLast, cLastSample;
    DWORD               cLoops, cPositions, cLoopsTGT;
    DWORD               dwDeltaMin, dwDeltaAvg, dwDeltaMax;
    DWORD               dwTestLength;
    MMTIME              mmt;
    HANDLE              hHeap;

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    dwTestLength = GetIniDWORD(gszGlobal,gszTestDuration,30);
    dwTestLength = min(dwTestLength,100);

    mmr = waveInOpen(
            &hwi,
            uDeviceID,
            (HACK)pwfx,
            0L,
            0L,
            INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"waveInOpen failed: 0x%08lx",(DWORD)mmr);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwh->lpData          = pwr->pData;           
    pwh->dwBufferLength  = pwr->cbSize;   
    pwh->dwBytesRecorded = 0L;  
    pwh->dwUser          = 0L;           
    pwh->dwFlags         = 0L;          
    pwh->dwLoops         = 0L;          
    pwh->lpNext          = 0L;
    pwh->reserved        = 0L;         

    mmr = waveInPrepareHeader(hwi,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"waveInPrepareHeader failed: 0x%08lx",(DWORD)mmr);

        waveInClose(hwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Reporting size(s) first.
    //

    tstLog(VERBOSE,"  Buffer Size: %lu bytes.",pwr->cbSize);
    tstLog(
        VERBOSE,
        "Buffer Length: %lu ms.",
        MulDivRN(pwr->cbSize,1000,pwfx->nAvgBytesPerSec));

    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));
    waveInStart(hwi);

    dwTimeBase = waveGetTime();

    //
    //  Trying to measure the number of waveInGetPosition's in a millisecond.
    //

    cLoops    = 0;
    mmt.wType = TIME_BYTES;
    
    dwTimeEnd = dwTestLength + 1;

    while(dwTestLength != (waveGetTime() % dwTimeEnd));
    while(dwTestLength == (waveGetTime() % dwTimeEnd));

    while(dwTestLength != (waveGetTime() % dwTimeEnd))
    {
        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));
        cLoops++;
    }

    //
    //  Calculating amount of time required to do a waveGetTime.
    //

    cLoopsTGT = 0;

    while(dwTestLength != (waveGetTime() % dwTimeEnd));
    while(dwTestLength == (waveGetTime() % dwTimeEnd));

    while(dwTestLength != (waveGetTime() % dwTimeEnd))
    {
        cLoopsTGT++;
    }

    //
    //  Converting to microseconds.
    //

    cLoopsTGT = MulDivRN(dwTestLength,1000,cLoopsTGT);

    //
    //  Number of microseconds avg time per loop - time for calling
    //  waveGetTime.
    //

    cLoops = MulDivRN(dwTestLength,1000,cLoops) - cLoopsTGT;

    //
    //  Polling WHDR_DONE bit.
    //

    while(!(pwh->dwFlags & WHDR_DONE));

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveInReset(hwi);
        waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
        waveInClose(hwi);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    dwTimeEnd = waveGetTime() - dwTimeBase;

    mmt.wType = TIME_BYTES;

    waveInGetPosition(hwi,&mmt,sizeof(MMTIME));

    cbLast = mmt.u.cb;

    mmt.wType = TIME_SAMPLES;

    waveInGetPosition(hwi,&mmt,sizeof(MMTIME));

    cLastSample = mmt.u.sample;

    tstLog(VERBOSE,"\nLast Position: %lu bytes.",cbLast);
    tstLog(VERBOSE,"Last Position: %lu samples.",cLastSample);

    dwTimeBase = waveGetTime();
    waveInReset(hwi);
    dwTimeReset = waveGetTime() - dwTimeBase;

    tstLog(VERBOSE,"Time for Reset: %lu ms.",dwTimeReset);
    tstLog(VERBOSE,"\nTime Played: %lu ms.",dwTimeEnd);
    tstLog(VERBOSE,"  (Time from waveInStart to WHDR_DONE bit set.)");
    tstLog(
        VERBOSE,
        "Avg time for waveInGetPosition: %lu microseconds.",
        cLoops);

    dwDeltaMin = (DWORD)(-1);
    dwDeltaMax = 0;
    dwDeltaAvg = 0;
    cPositions = 0;

    dwPos      = 0;
    
    mmt.wType  = TIME_BYTES;

    pwh->dwFlags &= ~(WHDR_DONE);

    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));
    waveInStart(hwi);

    while(!(pwh->dwFlags & WHDR_DONE))
    {
        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));

        if(mmt.u.cb != dwPos)
        {
            dwPos = mmt.u.cb - dwPos;

            dwDeltaMin  = min(dwPos,dwDeltaMin);
            dwDeltaMax  = max(dwPos,dwDeltaMax);
            
            dwDeltaAvg += dwPos;
            cPositions++;

            dwPos = mmt.u.cb;
        }
    }

    //
    //  Does user want to abort?
    //

    TestYield();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
        tstLogFlush();

        waveInReset(hwi);
        waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
        waveInClose(hwi);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    tstLog(VERBOSE,"\nUsing TIME_BYTES:");
    tstLog(VERBOSE,"  Minimum Delta: %lu bytes.",dwDeltaMin);
    tstLog(VERBOSE,"  Maximum Delta: %lu bytes.",dwDeltaMax);
    tstLog(
        VERBOSE,
        "  Average Delta: %lu.%03lu bytes.",
        dwDeltaAvg/cPositions,
        (MulDivRN(dwDeltaAvg,1000,cPositions)) % 1000);

    waveInReset(hwi);

    dwDeltaMin = (DWORD)(-1);
    dwDeltaMax = 0;
    dwDeltaAvg = 0;
    cPositions = 0;

    dwPos      = 0;
    
    mmt.wType  = TIME_SAMPLES;

    pwh->dwFlags &= ~(WHDR_DONE);

    waveInAddBuffer(hwi,pwh,sizeof(WAVEHDR));
    waveInStart(hwi);

    while(!(pwh->dwFlags & WHDR_DONE))
    {
        waveInGetPosition(hwi,&mmt,sizeof(MMTIME));

        if(mmt.u.cb != dwPos)
        {
            dwPos = mmt.u.cb - dwPos;

            dwDeltaMin  = min(dwPos,dwDeltaMin);
            dwDeltaMax  = max(dwPos,dwDeltaMax);
            
            dwDeltaAvg += dwPos;
            cPositions++;

            dwPos = mmt.u.cb;
        }
    }

    tstLog(VERBOSE,"\nUsing TIME_SAMPLES:");
    tstLog(VERBOSE,"  Minimum Delta: %lu samples.",dwDeltaMin);
    tstLog(VERBOSE,"  Maximum Delta: %lu samples.",dwDeltaMax);
    tstLog(
        VERBOSE,
        "  Average Delta: %lu.%03lu samples.",
        dwDeltaAvg/cPositions,
        (MulDivRN(dwDeltaAvg,1000,cPositions)) % 1000);


    waveInReset(hwi);
    waveInUnprepareHeader(hwi,pwh,sizeof(WAVEHDR));
    waveInClose(hwi);
     
    ExactHeapDestroy(hHeap);

    return TST_PASS;
} // waveInGetStats()


int FNGLOBAL Test_waveInGetPosition_Performance
(
    void
)
{
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               dwFormat;
    DWORD               dwLength;
    HANDLE              hHeap;
    WAVERESOURCE        wr;
    char                szFormat[MAXFMTSTR];
    static char         szTestName[] = "waveInGetPosition performance";
    int                 iResult = TST_PASS;

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    dwLength = GetIniDWORD(szTestName,gszDataLength,5);

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwfx = ExactHeapAllocPtr(
            hHeap,
            GMEM_MOVEABLE|GMEM_SHARE,
            gti.cbMaxFormatSize);

    if(NULL == pwfx)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    for(dwFormat = tstGetNumFormats();dwFormat;dwFormat--)
    {
        if(!tstGetFormat(pwfx,gti.cbMaxFormatSize,dwFormat-1))
        {
            DPF(1,"Couldn't get format #%d.",dwFormat-1);

            continue;
        }

        mmr = waveInOpen(
            NULL,
            gti.uInputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|INPUT_MAP(gti));

        if(MMSYSERR_NOERROR != mmr)
        {
            continue;
        }

        wr.cbSize = pwfx->nAvgBytesPerSec * dwLength;
        wr.cbSize = ROUNDUP_TO_BLOCK(wr.cbSize,pwfx->nBlockAlign);
        wr.pData  = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,wr.cbSize);

        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        tstLog(VERBOSE,"\n\nTesting format: %s",(LPSTR)szFormat);
        tstLogFlush();

        tstBeginSection(NULL);
        iResult &= waveInGetStats(gti.uInputDevice,pwfx,&wr);
        tstEndSection();

        //
        //  Does user want to abort?
        //

        TestYield();

        if(tstCheckRunStop(VK_ESCAPE))
        {
            tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
            tstLogFlush();

            ExactFreePtr(wr.pData);
            ExactHeapDestroy(hHeap);

            return TST_FAIL;
        }

        ExactFreePtr(wr.pData);
    }

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveInGetPosition_Performance()


int FNGLOBAL Test_waveOutStreaming
(
    void
)
{
    HWAVEOUT            hwo;
    MMRESULT            mmr;
    HANDLE              hHeap;
    DWORD               cBuffers, cBlock, cbBufferSize;
    DWORD               dw,dwOffset;
    DWORD               dwTime;
    volatile LPWAVEHDR  pwh;
    static char         szTestName[] = "waveOutWrite streaming performance";
    int                 iResult = TST_PASS;

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    cBuffers     = GetIniDWORD(szTestName,gszBufferCount,100);
    cBlock       = GetIniDWORD(szTestName,gszDataLength,10);
    cbBufferSize = gti.pwfxOutput->nBlockAlign * cBlock;

    if(cbBufferSize > gti.wrLong.cbSize)
    {
        LogFail("Resources insufficient size");

        return TST_FAIL;
    }

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(
        hHeap,
        GMEM_MOVEABLE|GMEM_SHARE,
        cBuffers * sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    DPF(3,"Before touching memory...");

    for(dw = cBuffers, dwOffset = 0; dw; dw--)
    {
        pwh[dw - 1].lpData          = &(gti.wrLong.pData[dwOffset]);
        pwh[dw - 1].dwBufferLength  = cbBufferSize;
        pwh[dw - 1].dwBytesRecorded = 0L;
        pwh[dw - 1].dwUser          = 0L;
        pwh[dw - 1].dwFlags         = 0L;
        pwh[dw - 1].dwLoops         = 0L;
        pwh[dw - 1].lpNext          = NULL;
        pwh[dw - 1].reserved        = 0L;

        dwOffset += cbBufferSize;

        dwOffset = ((dwOffset + cbBufferSize) > gti.wrLong.cbSize)?0:dwOffset;
    }
    
    tstLog(VERBOSE,"          Number of buffers: %lu.",cBuffers);
    tstLog(VERBOSE,"Number of blocks per buffer: %lu.",cBlock);
    tstLog(VERBOSE,"                Buffer Size: %lu bytes.\n",cbBufferSize);

    mmr = waveOutOpen(
        &hwo,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    DPF(3,"Preparing headers");

    mmr    = 0;
    dwTime = waveGetTime();

    for(dw = cBuffers; dw; dw--)
    {
        mmr |= waveOutPrepareHeader(hwo,&(pwh[dw - 1]),sizeof(WAVEHDR));
    }

    dwTime = waveGetTime() - dwTime;

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        waveOutReset(hwo);

        for(dw = cBuffers; dw; dw--)
        {
            if(pwh[dw - 1].dwFlags & WHDR_PREPARED)
            {
                waveOutUnprepareHeader(hwo,&(pwh[dw - 1]),sizeof(WAVEHDR));
            }
        }

        waveOutClose(hwo);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    tstLog(VERBOSE,"waveOutPrepareHeader Statistics:");
    tstLog(VERBOSE,"      Total Elapsed time: %lu ms",dwTime);

    dwTime = (1000 * dwTime) / cBuffers;

    tstLog(VERBOSE,"    Average time per API: %lu microseconds.\n",dwTime);

    DPF(3,"Writing headers");

    mmr    = 0;
    dwTime = waveGetTime();

    for(dw = cBuffers; dw; dw--)
    {
        mmr |= waveOutWrite(hwo,&(pwh[dw - 1]),sizeof(WAVEHDR));
    }

    dwTime = waveGetTime() - dwTime;

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutWrite failed");

        waveOutReset(hwo);

        for(dw = cBuffers; dw; dw--)
        {
            waveOutUnprepareHeader(hwo,&(pwh[dw - 1]),sizeof(WAVEHDR));
        }

        waveOutClose(hwo);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    tstLog(VERBOSE,"waveOutWrite Statistics:");
    tstLog(VERBOSE,"      Total Elapsed time: %lu ms",dwTime);

    dwTime = (1000 * dwTime) / cBuffers;

    tstLog(VERBOSE,"    Average time per API: %lu microseconds.\n",dwTime);

    //
    //  Spinning on WHDR_DONE bit.
    //

    while (!(pwh[0].dwFlags & WHDR_DONE));

    DPF(3,"Unpreparing headers");

    mmr    = 0;
    dwTime = waveGetTime();

    for(dw = cBuffers; dw; dw--)
    {
        mmr |= waveOutUnprepareHeader(hwo,&(pwh[dw - 1]),sizeof(WAVEHDR));
    }

    dwTime = waveGetTime() - dwTime;

    tstLog(VERBOSE,"waveOutUnprepareHeader Statistics:");
    tstLog(VERBOSE,"      Total Elapsed time: %lu ms",dwTime);

    dwTime = (1000 * dwTime) / cBuffers;

    tstLog(VERBOSE,"    Average time per API: %lu microseconds.\n",dwTime);

    waveOutReset(hwo);
    waveOutClose(hwo);

    ExactHeapDestroy(hHeap);
} // Test_waveOutStreaming()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\wave.c ===
//--------------------------------------------------------------------------;
//
//  File: Wave.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      VerifyOutputFormatFlags()
//      VerifyOutputChannelFlags()
//      VerifyOutputSupport()
//      VerifyInputFormatFlags()
//      VerifyInputChannelFlags()
//      Test_waveOutGetDevCaps()
//      Test_waveInGetDevCaps()
//
//  History:
//      02/21/94    Fwong
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef  WIN32
#include <windowsx.h>
#endif

#ifdef  TEST_UNICODE
#define  UNICODE
#include <mmsystem.h>
#undef   UNICODE
#else
#include <mmsystem.h>
#endif

#ifndef WIN32
#include <mmddk.h>
#endif  // WIN32

#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include <memgr.h>
#include <inimgr.h>
#include <waveutil.h>
#include <TstsHell.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "Debug.h"

//==========================================================================;
//
//                            Prototypes...
//
//==========================================================================;

int VerifyOutputFormatFlags
(
    UINT    uDeviceID,
    DWORD   dwFormats
);

int VerifyOutputChannelFlags
(
    UINT    uDeviceID,
    UINT    uChannels
);

int VerifyOutputSupport
(
    UINT    uDeviceID,
    DWORD   dwSupport
);

int VerifyInputFormatFlags
(
    UINT    uDeviceID,
    DWORD   dwFormats
);

int VerifyInputChannelFlags
(
    UINT    uDeviceID,
    UINT    uChannels
);

//==========================================================================;
//
//                             Functions...
//
//==========================================================================;

#ifndef TEST_UNICODE

//--------------------------------------------------------------------------;
//
//  int VerifyOutputFormatFlags
//
//  Description:
//      Verifies that the format flags on the WAVEOUTCAPS structure are
//          accurate.
//
//  Arguments:
//      UINT uDeviceID: Device ID.
//
//      DWORD dwFormats: Format flags.
//
//  Return (int):
//      TST_PASS if correct, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       For waveOutGetDevCaps testing.
//
//--------------------------------------------------------------------------;

int VerifyOutputFormatFlags
(
    UINT    uDeviceID,
    DWORD   dwFormats
)
{
    int             iResult = TST_PASS;
    LPWAVEFORMATEX  pwfx;
    DWORD           dwMask;
    HWAVEOUT        hWaveOut;
    MMRESULT        mmr;
    MMRESULT        mmrQuery;
    char            szFormat[MAXSTDSTR];

    tstLog(VERBOSE,"  Checking validity of dwFormats field");

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,gti.cbMaxFormatSize);

    if(dwFormats & ((DWORD)~(VALID_FORMAT_FLAGS)))
    {
        //
        //  Note: Valid formats are in VALID_FORMAT_FLAGS
        //

        LogFail("Undefined bits set in dwFormats field");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("All bits in dwFormat are valid");
    }

    for(dwMask = MSB_FORMAT; dwMask; dwMask /= 2)
    {
        FormatFlag_To_Format(dwMask,(LPPCMWAVEFORMAT)pwfx);
        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveOutOpen(
            &hWaveOut,
            uDeviceID,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

        mmrQuery = waveOutOpen(
            NULL,
            uDeviceID,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_ALLOWSYNC|WAVE_FORMAT_QUERY|OUTPUT_MAP(gti));

        if(MMSYSERR_NOERROR == mmr)
        {
            //
            //  No Error...  We should close the device...
            //

            waveOutClose(hWaveOut);
        }

        if(dwFormats & dwMask)
        {
            //
            //  Hmm... We're supposed to support it.
            //

            if(MMSYSERR_NOERROR == mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR == mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }
        else
        {
            //
            //  Hmm... We're NOT supposed to support it.
            //

            if(MMSYSERR_NOERROR != mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR != mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }

        tstLogFlush();
    }

    ExactFreePtr(pwfx);

    return (iResult);
} // VerifyOutputFormatFlags()


//--------------------------------------------------------------------------;
//
//  int VerifyOutputChannelFlags
//
//  Description:
//      Verifies the channel support on the WAVEOUTCAPS structure.
//
//  Arguments:
//      UINT uDeviceID: Device ID.
//
//      UINT uChannels: Number of Channels.
//
//  Return (int):
//      TST_PASS if correct, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       For waveOutGetDevCaps testing.
//
//--------------------------------------------------------------------------;

int VerifyOutputChannelFlags
(
    UINT    uDeviceID,
    UINT    uChannels
)
{
    UINT            uReal = 0;
    DWORD           dwMask;
    MMRESULT        mmr;
    LPWAVEFORMATEX  pwfx;
    char            szFormat[MAXSTDSTR];

    tstLog(VERBOSE,"  Checking validity of wChannels field");

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,gti.cbMaxFormatSize);

    for(dwMask = MSB_FORMAT; dwMask; dwMask /= 2)
    {
        //
        //  Seeing what it can open...
        //

        FormatFlag_To_Format(dwMask,(LPPCMWAVEFORMAT)pwfx);
        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveOutOpen(
            NULL,
            uDeviceID,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_ALLOWSYNC|WAVE_FORMAT_QUERY|OUTPUT_MAP(gti));

        if(MMSYSERR_NOERROR == mmr)
        {
            uReal = max(uReal,pwfx->nChannels);
        }
    }

    ExactFreePtr(pwfx);

    if(uReal == uChannels)
    {
        tstLog(VERBOSE,"    PASS: wChannels [%u] is valid.",uChannels);

        return TST_PASS;
    }
    else
    {
        tstLog(TERSE,"    FAIL: wChannels should be %u.",uReal);

        return TST_FAIL;
    }

} // VerifyOutputChannelFlags()


//--------------------------------------------------------------------------;
//
//  int VerifyOutputSupport
//
//  Description:
//      Verifies the accuracy of the dwSupport field of the WAVEOUTCAPS
//          structure.
//
//  Arguments:
//      UINT uDeviceID: Device ID
//
//      DWORD dwSupport: Support flag.
//
//  Return (int):
//      TST_PASS if accurate, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       For waveOutGetDevCaps testing.
//
//--------------------------------------------------------------------------;

int VerifyOutputSupport
(
    UINT    uDeviceID,
    DWORD   dwSupport
)
{
    int                 iResult = TST_PASS;
    MMRESULT            mmr;
    DWORD               dwPrev;
    HWAVEOUT            hWaveOut;
    volatile LPWAVEHDR  pWaveHdr;

    tstLog(VERBOSE,"  Checking validity of dwSupport field");

    //
    //  Valid flags are 0x0000003f
    //

    dwPrev = (DWORD)(~(0x0000003f));

    if(dwSupport & dwPrev)
    {
        //
        //  Note: Valid dwSupports flags are in dwPrev
        //

        LogFail("Undefined bits set in dwSupport field");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("All bits in dwSupport are valid");
    }

    //
    //  Verify WAVECAPS_SYNC support...
    //

    mmr = waveOutOpen(
        &hWaveOut,
        uDeviceID,
        (HACK)gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(WAVECAPS_SYNC & dwSupport)
    {
        if(WAVERR_SYNC == mmr)
        {
            LogPass("Device failed open w/out WAVE_ALLOWSYNC flag");
        }
        else
        {
            LogFail("Device opened w/out WAVE_ALLOWSYNC flag");

            waveOutClose(hWaveOut);

            iResult = TST_FAIL;
        }
    }
    else
    {
        if(WAVERR_SYNC == mmr)
        {
            LogFail("Device failed open w/out WAVE_ALLOWSYNC flag");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Device opened w/out WAVE_ALLOWSYNC flag");

            waveOutClose(hWaveOut);
        }
    }

    hWaveOut = NULL;
    //DPF(1,"hWaveOut: 0x%08lx, uDeviceID: 0x%04x",hWaveOut, uDeviceID);

    mmr = waveOutOpen(
        &hWaveOut,
        uDeviceID,
        (HACK)gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    pWaveHdr = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);
        
        waveOutClose(hWaveOut);
        return TST_FAIL;
    }

    _fmemset(pWaveHdr,0,sizeof(WAVEHDR));

    pWaveHdr->lpData         = gti.wrMedium.pData;
    pWaveHdr->dwBufferLength = gti.wrMedium.cbSize;

    mmr = waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"hWaveOut: 0x%08lx",hWaveOut); 

        DPF(1,"waveOutPrepareHeader failed.");
        DPF(1,"Error: %s (0x%08lx)",GetErrorText(mmr),mmr);

        ExactFreePtr(pWaveHdr);

        mmr = waveOutClose(hWaveOut);
        DPF(1,"Error for waveOutClose: %s (0x%08lx)",GetErrorText(mmr),mmr);

        return TST_FAIL;
    }

    mmr = waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"waveOutWrite failed.");

        waveOutReset(hWaveOut);
        waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
        ExactFreePtr(pWaveHdr);
        waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    if(WHDR_DONE & pWaveHdr->dwFlags)
    {
        if(WAVECAPS_SYNC & dwSupport)
        {
            LogPass("Device behaves synchronous");
        }
        else
        {
            LogFail("Device behaves synchronous");

            iResult = TST_FAIL;
        }
    }
    else
    {
        if(WAVECAPS_SYNC & dwSupport)
        {
            LogFail("Device behaves asynchronous");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Device behaves asynchronous");
        }
    }

    waveOutReset(hWaveOut);
    waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    waveOutClose(hWaveOut);
    ExactFreePtr(pWaveHdr);

    //
    //  Verify WAVECAPS_VOLUME support...
    //

    if(WAVECAPS_VOLUME & dwSupport)
    {
        mmr = waveOutGetVolume((VOLCTRL)uDeviceID,&dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogPass("Get volume supported");
        }
        else
        {
            LogFail("Get volume not supported");

            iResult = TST_FAIL;
        }

        mmr = waveOutSetVolume((VOLCTRL)uDeviceID,dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogPass("Set volume supported");
        }
        else
        {
            LogFail("Set volume not supported");

            iResult = TST_FAIL;
        }
    }
    else
    {
        mmr = waveOutGetVolume((VOLCTRL)uDeviceID,&dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogFail("Get volume supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Get volume not supported");
        }

        mmr = waveOutSetVolume((VOLCTRL)uDeviceID,dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogFail("Set volume supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Set volume not supported");
        }
    }

#pragma message(REMIND("Think of some more stuff for WAVECAPS_LRVOLUME!!"))

    if(WAVECAPS_LRVOLUME & dwSupport)
    {
        if(WAVECAPS_VOLUME & dwSupport)
        {
            LogPass("WAVECAPS_LRVOLUME set w/ WAVECAPS_VOLUME");
        }
        else
        {
            LogFail("WAVECAPS_LRVOLUME set w/out WAVECAPS_VOLUME");

            iResult = TST_FAIL;
        }
    }

    mmr = waveOutOpen(
        &hWaveOut,
        uDeviceID,
        (HACK)gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    if(WAVECAPS_PITCH & dwSupport)
    {
        mmr = waveOutGetPitch(hWaveOut,&dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogPass("Get pitch supported");
        }
        else
        {
            LogFail("Get pitch not supported");

            iResult = TST_FAIL;
        }

        mmr = waveOutSetPitch(hWaveOut,dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogPass("Set pitch supported");
        }
        else
        {
            LogFail("Set pitch not supported");

            iResult = TST_FAIL;
        }
    }
    else
    {
        mmr = waveOutGetPitch(hWaveOut,&dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogFail("Get pitch supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Get pitch not supported");
        }

        mmr = waveOutSetPitch(hWaveOut,dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogFail("Set pitch supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Set pitch not supported");
        }
    }

    if(WAVECAPS_PLAYBACKRATE & dwSupport)
    {
        mmr = waveOutGetPlaybackRate(hWaveOut,&dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogPass("Get rate supported");
        }
        else
        {
            LogFail("Get rate not supported");

            iResult = TST_FAIL;
        }

        mmr = waveOutSetPlaybackRate(hWaveOut,dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogPass("Set rate supported");
        }
        else
        {
            LogFail("Set rate not supported");

            iResult = TST_FAIL;
        }
    }
    else
    {
        mmr = waveOutGetPlaybackRate(hWaveOut,&dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogFail("Get rate supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Get rate not supported");
        }

        mmr = waveOutSetPlaybackRate(hWaveOut,dwPrev);

        if(MMSYSERR_NOERROR == mmr)
        {
            LogFail("Set rate supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Set rate not supported");
        }
    }

    waveOutClose(hWaveOut);

    return iResult;
} // VerifyOutputSupport()


//--------------------------------------------------------------------------;
//
//  int VerifyInputFormatFlags
//
//  Description:
//      Verifies that the format flags on the WAVEOUTCAPS structure are
//          accurate.
//
//  Arguments:
//      UINT uDeviceID: Device ID.
//
//      DWORD dwFormats: Format flags.
//
//  Return (int):
//      TST_PASS if correct, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       For waveInGetDevCaps testing.
//
//--------------------------------------------------------------------------;

int VerifyInputFormatFlags
(
    UINT    uDeviceID,
    DWORD   dwFormats
)
{
    int             iResult = TST_PASS;
    LPWAVEFORMATEX  pwfx;
    DWORD           dwMask;
    HWAVEIN         hWaveIn;
    MMRESULT        mmr;
    MMRESULT        mmrQuery;
    char            szFormat[MAXSTDSTR];

    tstLog(VERBOSE,"  Checking validity of dwFormats field");

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,gti.cbMaxFormatSize);

    if(dwFormats & ((DWORD)~(VALID_FORMAT_FLAGS)))
    {
        //
        //  Note: Valid formats are in VALID_FORMAT_FLAGS
        //

        LogFail("Undefined bits set in dwFormats field");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("All bits in dwFormat are valid");
    }

    for(dwMask = MSB_FORMAT; dwMask; dwMask /= 2)
    {
        FormatFlag_To_Format(dwMask,(LPPCMWAVEFORMAT)pwfx);
        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveInOpen(&hWaveIn,uDeviceID,(HACK)pwfx,0L,0L,INPUT_MAP(gti));

        mmrQuery = waveInOpen(
            NULL,
            uDeviceID,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|INPUT_MAP(gti));

        if(MMSYSERR_NOERROR == mmr)
        {
            //
            //  No Error...  We should close the device...
            //

            waveInClose(hWaveIn);
        }

        if(dwFormats & dwMask)
        {
            //
            //  Hmm... We're supposed to support it.
            //

            if(MMSYSERR_NOERROR == mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR == mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }
        else
        {
            //
            //  Hmm... We're NOT supposed to support it.
            //

            if(MMSYSERR_NOERROR != mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR != mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }

        tstLogFlush();
    }

    ExactFreePtr(pwfx);

    return (iResult);
} // VerifyInputFormatFlags()


//--------------------------------------------------------------------------;
//
//  int VerifyInputChannelFlags
//
//  Description:
//      Verifies the channel support on the WAVEOUTCAPS structure.
//
//  Arguments:
//      UINT uDeviceID: Device ID.
//
//      UINT uChannels: Number of Channels.
//
//  Return (int):
//      TST_PASS if correct, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       For waveInGetDevCaps testing.
//
//--------------------------------------------------------------------------;

int VerifyInputChannelFlags
(
    UINT    uDeviceID,
    UINT    uChannels
)
{
    UINT            uReal = 0;
    DWORD           dwMask;
    MMRESULT        mmr;
    LPWAVEFORMATEX  pwfx;
    char            szFormat[MAXSTDSTR];

    tstLog(VERBOSE,"  Checking validity of wChannels field");

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,gti.cbMaxFormatSize);

    for(dwMask = MSB_FORMAT; dwMask; dwMask /= 2)
    {
        //
        //  Seeing what it can open...
        //

        FormatFlag_To_Format(dwMask,(LPPCMWAVEFORMAT)pwfx);
        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveInOpen(
            NULL,
            uDeviceID,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|INPUT_MAP(gti));

        if(MMSYSERR_NOERROR == mmr)
        {
            uReal = max(uReal,pwfx->nChannels);
        }
    }

    ExactFreePtr(pwfx);

    if(uReal == uChannels)
    {
        tstLog(VERBOSE,"    PASS: wChannels [%u] is valid.",uChannels);

        return TST_PASS;
    }
    else
    {
        tstLog(TERSE,"    FAIL: wChannels should be %u.",uReal);

        return TST_FAIL;
    }

} // VerifyInputChannelFlags()

#endif  //  TEST_UNICODE


//--------------------------------------------------------------------------;
//
//  int Test_waveOutGetDevCaps
//
//  Description:
//      Tests the driver functionality for waveOutGetDevCaps.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutGetDevCaps
(
    void
)
{
    int             iResult = TST_PASS;
    MMRESULT        mmr;
    LPWAVEOUTCAPS   pwoc,pwoc2;
    LPBYTE          pbyte;
    UINT            cbSize;
    char            szScrap[MAXSTDSTR];

#ifdef  TEST_UNICODE
    static char     szTestName[] = "waveOutGetDevCaps (UNICODE)";
#else
    static char     szTestName[] = "waveOutGetDevCaps";
#endif

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return TST_PASS;
    }

    //
    //  Allocating memory...
    //

    pwoc = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEOUTCAPS));

    if(NULL == pwoc)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Calling API...
    //

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,pwoc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR == mmr)
    {
        //
        //  No Error... Cool!
        //

        LogPass("waveOutGetDevCaps succeeded");
    }
    else
    {
        //
        //  Hmm... What happened?!
        //

        ExactFreePtr(pwoc);

        if(WAVE_MAPPER == gti.uOutputDevice)
        {
            //
            //  waveOutGetDevCaps may fail for mapper....
            //

            LogPass("waveOutGetDevCaps failed for mapper");

            return TST_PASS;
        }

        tstLog(
            TERSE,
            "    FAIL: waveOutGetDevCaps failed for device: %u",
            gti.uOutputDevice);

        return TST_FAIL;
    }

    //
    //  Checking mmreg.ini for wMid.
    //

    Log_TestCase("Verifying WAVEOUTCAPS.wMid registration");

    if(GetRegInfo(
        (DWORD)pwoc->wMid,
        "MM Manufacturer ID",
        szScrap,
        sizeof(szScrap),
        NULL,
        0))
    {
        LogPass("~wMid is registered with Microsoft");

        //
        //  Checking mmreg.ini for wPid.
        //

        Log_TestCase("Verifying WAVEOUTCAPS.wPid registration");

        if(GetRegInfo((DWORD)pwoc->wPid,szScrap,NULL,0,NULL,0))
        {
            LogPass("~wPid is registered with Microsoft");
        }
        else
        {
            LogFail("~wPid is not registered with Microsoft");

            iResult = TST_FAIL;
        }
    }
    else
    {
        LogFail("~wMid is not registered with Microsoft");

        iResult = TST_FAIL;
    }

    //
    //  Verifying support for dwFormats, wChannels and dwSupport fields...
    //

    Log_TestCase("~Verifying accuracy of WAVEOUTCAPS.dwFormats");
    iResult &= VerifyOutputFormatFlags(gti.uOutputDevice,pwoc->dwFormats);

    Log_TestCase("~Verifying accuracy of WAVEOUTCAPS.wChannels");
    iResult &= VerifyOutputChannelFlags(gti.uOutputDevice,pwoc->wChannels);

    Log_TestCase("~Verifying accuracy of WAVEOUTCAPS.dwSupport");
    iResult &= VerifyOutputSupport(gti.uOutputDevice,pwoc->dwSupport);

    cbSize = sizeof(WAVEOUTCAPS);
    pwoc2  = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cbSize);
    pbyte  = (LPBYTE)pwoc2;

    Log_TestCase("~Verifying waveOutGetDevCaps works with partial "
        "WAVEOUTCAPS");

    for(cbSize--;cbSize;cbSize--)
    {
        //
        //  This is expecting a possible fault...
        //

        pbyte++;

        mmr = waveOutGetDevCaps(gti.uOutputDevice,(LPWAVEOUTCAPS)pbyte,cbSize);
    }

#ifndef WIN32
{
    DWORD   dn;

    dn = 0;

    Log_TestCase("~Verifying driver is Windows 95 compatible");

    waveOutMessage(
            (HWAVEOUT)gti.uOutputDevice,
            DRV_QUERYDEVNODE,
            (DWORD)(LPDWORD)&dn,
            0L);

    if(0 != dn)
    {
        tstLog(VERBOSE,"    PASS: Output driver is Windows 95 compatible.\n"
            "          (returns a Dev Node on DRV_QUERYDEVNODE).");

        Log_TestCase("~Verifying driver supports WAVECAPS_SAMPLEACCURATE");

        mmr = waveOutGetDevCaps(gti.uOutputDevice,pwoc,sizeof(WAVEOUTCAPS));

        if(MMSYSERR_NOERROR == mmr)
        {
            if(pwoc->dwSupport & WAVECAPS_SAMPLEACCURATE)
            {
                LogPass("Output driver supports sample accurate positions");
            }
            else
            {
                LogFail("Output driver does not support sample accurate "
                    "positions");

                iResult = TST_FAIL;
            }
        }
    }
    else
    {
        tstLog(TERSE,"    FAIL: Output driver is not Windows 95 compatible.\n"
            "          (does not returns a Dev Node on DRV_QUERYDEVNODE).");

        iResult = TST_FAIL;
    }
}
#endif  // WIN32

    ExactFreePtr(pwoc2);
    ExactFreePtr(pwoc);

    return (iResult);
} // Test_waveOutGetDevCaps()


//--------------------------------------------------------------------------;
//
//  int Test_waveInGetDevCaps
//
//  Description:
//      Tests the driver functionality for waveInGetDevCaps.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInGetDevCaps
(
    void
)
{
    int             iResult = TST_PASS;
    MMRESULT        mmr;
    LPWAVEINCAPS    pwic,pwic2;
    LPBYTE          pbyte;
    UINT            cbSize;
    char            szScrap[MAXSTDSTR];

#ifdef  TEST_UNICODE
    static char     szTestName[] = "waveInGetDevCaps (UNICODE)";
#else
    static char     szTestName[] = "waveInGetDevCaps";
#endif

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return TST_PASS;
    }

    //
    //  Allocating memory...
    //

    pwic = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEINCAPS));

    if(NULL == pwic)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Calling API...
    //

    mmr = call_waveInGetDevCaps(gti.uInputDevice,pwic,sizeof(WAVEINCAPS));

    if(MMSYSERR_NOERROR == mmr)
    {
        //
        //  No Error... Cool!
        //

        LogPass("waveInGetDevCaps succeeded");
    }
    else
    {
        //
        //  Hmm... What happened?!
        //

        ExactFreePtr(pwic);

        if(WAVE_MAPPER == gti.uInputDevice)
        {
            //
            //  waveInGetDevCaps may fail for mapper....
            //

            LogPass("waveInGetDevCaps failed for mapper");

            return TST_PASS;
        }

        tstLog(
            TERSE,
            "    FAIL: waveInGetDevCaps failed for device: %u",
            gti.uInputDevice);

        return TST_FAIL;
    }

    //
    //  Checking mmreg.ini for wMid.
    //

    Log_TestCase("Verifying WAVEINCAPS.wMid registration");

    if(GetRegInfo(
        (DWORD)pwic->wMid,
        "MM Manufacturer ID",
        szScrap,
        sizeof(szScrap),
        NULL,
        0))
    {
        LogPass("~wMid is registered with Microsoft");

        //
        //  Checking mmreg.ini for wPid.
        //

        Log_TestCase("Verifying WAVEINCAPS.wPid registration");

        if(GetRegInfo((DWORD)pwic->wPid,szScrap,NULL,0,NULL,0))
        {
            LogPass("~wPid is registered with Microsoft");
        }
        else
        {
            LogFail("~wPid is not registered with Microsoft");

            iResult = TST_FAIL;
        }
    }
    else
    {
        LogFail("~wMid is not registered with Microsoft");

        iResult = TST_FAIL;
    }

    //
    //  Verifying support for dwFormats, wChannels and dwSupport fields...
    //

    Log_TestCase("~Verifying accuracy of WAVEINCAPS.dwFormats");
    iResult &= VerifyInputFormatFlags(gti.uInputDevice,pwic->dwFormats);

    Log_TestCase("~Verifying accuracy of WAVEINCAPS.wChannels");
    iResult &= VerifyInputChannelFlags(gti.uInputDevice,pwic->wChannels);

    cbSize = sizeof(WAVEINCAPS);
    pwic2  = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cbSize);
    pbyte  = (LPBYTE)pwic2;

    Log_TestCase("Verifying waveInGetDevCaps works with partial WAVEINCAPS");

    for(cbSize--;cbSize;cbSize--)
    {
        //
        //  This is expecting a possible fault...
        //

        pbyte++;

        mmr = waveInGetDevCaps(gti.uInputDevice,(LPWAVEINCAPS)pbyte,cbSize);
    }

    ExactFreePtr(pwic2);
    ExactFreePtr(pwic);

#ifndef WIN32
{
    DWORD   dn;

    Log_TestCase("~Verifying driver is Windows 95 compatible");

    dn = 0;

    waveInMessage(
        (HWAVEIN)gti.uInputDevice,
        DRV_QUERYDEVNODE,
        (DWORD)(LPDWORD)&dn,
        0L);

    if(0 != dn)
    {
        tstLog(VERBOSE,"    PASS: Input driver is Windows 95 compatible.\n"
            "          (returns a Dev Node on DRV_QUERYDEVNODE).");
    }
    else
    {
        tstLog(TERSE,"    FAIL: Input driver is not Windows 95 compatible.\n"
            "          (does not returns a Dev Node on DRV_QUERYDEVNODE).");

        iResult = TST_FAIL;
    }
}
#endif  // WIN32

    return (iResult);
} // Test_waveInGetDevCaps()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\wavetest.c ===
//--------------------------------------------------------------------------;
//
//  File: WaveTest.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      Contains the basic necessities for the shell.
//
//  Contents:
//      tstGetTestInfo()
//      tstInit()
//      IFreeMemory()
//      tstTerminate()
//      TestYield()
//      wait()
//      IsValidACM()
//      DLL_WaveControl()
//      InitSupportFiles()
//      InitDLL()
//      InitDeviceMenu()
//      InitOptions()
//      InitInfo()
//      GetSupportedInputFormat()
//      GetSupportedOutputFormat()
//      InitFormatMenu()
//      MenuProc()
//      SaveSettings()
//      IsGEversion4()
//      dprintf()
//
//  History:
//      11/24/93    Fwong       Re-doing WaveTest.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <memory.h>
#include <mmreg.h>
#include <msacm.h>
#include <TstsHell.h>
#include <memgr.h>
#include <inimgr.h>
#include <waveutil.h>
#include <resmgr.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "Debug.h"

//==========================================================================;
//
//                            Globals...
//
//==========================================================================;

#ifdef  WIN32
char    szAppName[] = "Wave Test Application - Win32";
#else
char    szAppName[] = "Wave Test Application - Win16";
#endif

char    gszSpaces[] = "                                        ";

HWND            ghwndTstsHell;
HINSTANCE       ghinstance;
HINSTANCE       ghinstDLL;
FARPROC         pfnCallBack;
char            gszGlobal[]       = "Global";
char            gszInputDev[]     = "InputDevice";
char            gszOutputDev[]    = "OutputDevice";
char            gszInputFormat[]  = "InputFormat";
char            gszOutputFormat[] = "OutputFormat";
char            gszInputMap[]     = "InputMapped";
char            gszOutputMap[]    = "OutputMapped";
char            gszThreshold[]    = "PauseThreshold";
char            gszTimeThreshold[]= "TimeThreshold";
char            gszFlags[]        = "Flags";
char            gszShort[]        = "Short";
char            gszMedium[]       = "Medium";
char            gszLong[]         = "Long";
char            gszBufferCount[]  = "BufferCount";
char            gszRatio[]        = "Ratio";
char            gszMapper[]       = "Wave Mapper";
char            gszDelta[]        = "Delta";
char            gszDataLength[]   = "DataLength";
char            gszSlowPercent[]  = "SlowPercent";
char            gszFastPercent[]  = "FastPercent";
char            gszPercent[]      = "Percent";
char            gszError[]        = "ErrorThreshold";
char            gszTestDuration[] = "TestDuration";
TESTINFO        gti = { WAVE_MAPPER,
                        WAVE_MAPPER,
                        NULL,
                        NULL,
                        {NULL,0L},
                        {NULL,0L},
                        {NULL,0L},
                        20,
                        20,
                        20,
                        10,
                        0L,
                        3,
                        0L,
                        NULL,
                        NULL,
                        NULL};
char            gszFailNoMem[]      = "Could not allocate memory to run tests";
char            gszFailOpen[]       = "Open failed for device";
char            gszFailGetCaps[]    = "Could not get capabilities for device";
char            gszFailWIPrepare[]  = "waveInPrepareHeader failed";
char            gszFailWOPrepare[]  = "waveOutPrepareHeader failed";
char            gszFailExactAlloc[] = "ExactAllocPtr failed.";
char            gszMsgNoInDevs[]    = "    No input devices installed.";
char            gszMsgNoOutDevs[]   = "    No output devices installed.";


//==========================================================================;
//
//                              Typedef's
//
//==========================================================================;

typedef DWORD (FNGLOBAL* CONTROLPROC)(UINT,LPVOID);

//==========================================================================;
//
//                          Prototypes...
//
//==========================================================================;

LRESULT FAR PASCAL MenuProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
);

BOOL IsValidACM
(
    void
);

void InitDeviceMenu
(
    void
);

void InitInfo
(
    void
);

void InitOptions
(
    void
);

void InitFormatMenu
(
    void
);

void SaveSettings
(
    void
);

void InitDLL
(
    void
);

void InitSupportFiles
(
    HINSTANCE   hinst
);

//--------------------------------------------------------------------------;
//
//  int tstGetTestInfo
//
//  Description:
//      Test shell entry point.  Gets test information.
//
//  Arguments:
//      HINSTANCE hinstance: Passes handle to instance.
//
//      LPSTR lpszTestName: Test Name.
//
//      LPSTR lpszPathSection: Path Section.
//
//      LPWORD lpwPlatform: Platform.
//
//  Return (int):
//
//  History:
//      12/13/93    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

int tstGetTestInfo
(
    HINSTANCE   hinstance,
    LPSTR       lpszTestName,
    LPSTR       lpszPathSection,
    LPWORD      lpwPlatform
)
{
    lstrcpy(lpszTestName,szAppName);
    lstrcpy(lpszPathSection,szAppName);

    ghinstance = hinstance;

    *lpwPlatform = IDP_BASE;

    return TEST_LIST;
} // tstGetTestInfo()


//--------------------------------------------------------------------------;
//
//  BOOL tstInit
//
//  Description:
//      Called by TstsHell when app is initializing.
//
//  Arguments:
//      HWND hwndMain: Handle to TstsHell window.
//
//  Return (BOOL):
//      TRUE is successful, FALSE if initialization failed.
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

BOOL tstInit
(
    HWND    hwndMain
)
{
    ghwndTstsHell = hwndMain;

    DbgInitialize(TRUE);

    tstSetOptions(TST_ENABLEFASTLOGGING,1);
    tstSetOptions(TST_ENABLEEXCEPTIONHANDLING,0);

#ifndef HCT
    if((0 == waveOutGetNumDevs()) && (0 == waveInGetNumDevs()))
    {
        IdiotBox("No wave devices installed.");

        return FALSE;
    }
#endif

    if(FALSE == InitIniFile(ghinstance,"wavetest.ini"))
    {
        DPF(1,"Initializing IniFile failed.");

        return FALSE;
    }

#if 0
    InitSupportFiles(ghinstance);
#endif
    InitDLL();
    InitDeviceMenu();
    InitInfo();
    InitOptions();
    InitFormatMenu();
    tstInitHelpMenu();

    if(IsValidACM())
    {
        gti.fdwFlags |= TESTINFOF_USE_ACM;
    }

    LoadWaveResource(&gti.wrShort,WR_SHORT);
    LoadWaveResource(&gti.wrMedium,WR_MEDIUM);
    LoadWaveResource(&gti.wrLong,WR_LONG);

    //
    //  Setting timer resolution to 1 ms.
    //

//    timeBeginPeriod(1);

    return(TRUE);
} // tstInit()
                                                                                     

void IFreeMemory
(
    void
)
{
    if(NULL != gti.pwfxInput)
    {
        ExactFreePtr(gti.pwfxInput);
    }

    if(NULL != gti.pwfxOutput)
    {
        ExactFreePtr(gti.pwfxOutput);
    }

    if(NULL != gti.pwfx1)
    {
        ExactFreePtr(gti.pwfx1);
    }

    if(NULL != gti.pwfx2)
    {
        ExactFreePtr(gti.pwfx2);
    }

    if(NULL != gti.pdwIndex)
    {
        ExactFreePtr(gti.pdwIndex);
    }

    if(NULL != gti.wrShort.pData)
    {
        ExactFreePtr(gti.wrShort.pData);
    }

    if(NULL != gti.wrMedium.pData)
    {
        ExactFreePtr(gti.wrMedium.pData);
    }

    if(NULL != gti.wrLong.pData)
    {
        ExactFreePtr(gti.wrLong.pData);
    }
} // IFreeMemory()


//--------------------------------------------------------------------------;
//
//  void tstTerminate
//
//  Description:
//      Called when TstsHell ends.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

void tstTerminate
(
    void
)
{
    SaveSettings();

    EndIniFile();
    FreeLibrary(ghinstDLL);

    IFreeMemory();

    //
    //  Restoring time resolution from 1 ms.
    //

//    timeEndPeriod(1);

    return;
} // tstTerminate()


//--------------------------------------------------------------------------;
//
//  void TestYield
//
//  Description:
//      Yields to process window messages.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      03/20/94    Fwong       Added to make tests more LORable.
//
//--------------------------------------------------------------------------;

void FNGLOBAL TestYield
(
    void
)
{
    MSG msgPeek;

    while(PeekMessage(&msgPeek,NULL,0,0,PM_REMOVE))
    {
        TranslateMessage(&msgPeek);
        DispatchMessage(&msgPeek);
    }
} // TestYield()


//--------------------------------------------------------------------------;
//
//  BOOL WaitForMessage
//
//  Description:
//      Waits for message or times out.  Notifies caller if timed out.
//
//  Arguments:
//      HWND hwnd: Window to post WM_TIMER message.
//
//      UINT msg1: Message to monitor.
//
//      DWORD dwTime: The amount of time before time out.  This time is
//          actually extended.
//
//  Return (BOOL):
//      TRUE if msg1 was posted, FALSE otherwise.
//
//  History:
//      07/31/93    Fwong       Taking care of WOM_DONE message.
//
//--------------------------------------------------------------------------;

//BOOL FNGLOBAL WaitForMessage
//(
//    HWND    hwnd,
//    UINT    msg1,
//    DWORD   dwTime
//)
//{
//    MSG     msgDone;
//    UINT    uInterval;
//
//    dwTime += (dwTime/2);
//
//    for (;dwTime;)
//    {
//
//#ifndef WIN32
//        uInterval = (WORD)((dwTime & 0xffff0000)?0xffff:dwTime);
//#else
//        uInterval = dwTime;
//#endif  // WIN32
//
//        dwTime -= uInterval;
//
//        if(!SetTimer(hwnd,TIMER_ID,uInterval,NULL))
//            return (FALSE);
//
//        for (;;)
//        {
//            //
//            //  Hack!!
//            //
//
//            msgDone.hwnd = hwnd;
//
//            PeekMessage(&msgDone,hwnd,0,0,PM_REMOVE);
//
//            if(msgDone.message == msg1)
//            {
//                KillTimer(hwnd,TIMER_ID);
//                return TRUE;
//            }
//
//            if(tstCheckRunStop(VK_ESCAPE))
//            {
//                KillTimer(hwnd,TIMER_ID);
//                return FALSE;
//            }
//
//            if(WM_TIMER == msgDone.message)
//            {
//                break;
//            }
//
//            TranslateMessage(&msgDone);
//            DispatchMessage(&msgDone);
//        }
//
//        KillTimer(hwnd,TIMER_ID);
//    }
//
//#pragma message(REMIND("Remove this..."))
//    tstLog(TERSE,"Timed-Out...");
//    return FALSE;
//} // WaitForMessage()


//--------------------------------------------------------------------------;
//
//  void wait
//
//  Description:
//      Waits for the specified number of milliseconds.
//
//  Arguments:
//      DWORD dwTime: Time to wait (in milliseconds).
//
//  Return (void):
//
//  History:
//      03/06/94    Fwong       Waiting function...
//
//--------------------------------------------------------------------------;

void FNGLOBAL wait
(
    DWORD   dwTime
)
{
    MSG     msgDone;
    UINT    uTime;

#ifndef WIN32
    uTime = (UINT)((dwTime & 0xffff0000)?0xffff:dwTime);
#else
    uTime = dwTime;
#endif  //  WIN32

    dwTime -= uTime;

    if(!SetTimer(ghwndTstsHell,1,uTime,NULL))
        return;

    //
    //  Hack!
    //

    msgDone.hwnd = ghwndTstsHell;

    for(;;)
    {
        if(!PeekMessage(&msgDone,ghwndTstsHell,WM_TIMER,WM_TIMER,PM_REMOVE))
        {
            continue;
        }

        if(0 == dwTime)
        {
            KillTimer(ghwndTstsHell,1);

            break;
        }

        if(dwTime < uTime)
        {
            KillTimer(ghwndTstsHell,1);
            SetTimer(ghwndTstsHell,1,(UINT)dwTime,NULL);

            dwTime = 0;
            continue;
        }

        dwTime -= uTime;
        msgDone.hwnd = ghwndTstsHell;
    }
} // wait()


#pragma message(REMIND("Check for this."))
//--------------------------------------------------------------------------;
//
//  BOOL IsValidACM
//
//  Description:
//      Determines whether or not it is valid to call ACM API's
//
//  Arguments:
//      None.
//
//  Return (BOOL):
//      TRUE if a usable ACM is installed, FALSE otherwise.
//
//  History:
//      12/01/93    Fwong       Making sure wavetest works w/out ACM.
//
//--------------------------------------------------------------------------;

BOOL IsValidACM
(
    void
)
{
    HMODULE hmodACM;
    DWORD   dwVersion;
    DWORD   (FAR PASCAL *lpfn_acmGetVersion)(void);

    hmodACM = GetModuleHandle("MSACM");
    
    if(NULL == hmodACM)
    {
        //
        //  ACM is not even loaded!!
        //

        return FALSE;
    }

    //
    //  Doing dyna-link...
    //

    (FARPROC)lpfn_acmGetVersion = GetProcAddress(hmodACM,"acmGetVersion");

    dwVersion = (lpfn_acmGetVersion());

    if(2 > HIBYTE(HIWORD(dwVersion)))
    {
        //
        //  ACM version less than 2.0...
        //

        return FALSE;
    }

    return TRUE;
} // IsValidACM()


//--------------------------------------------------------------------------;
//
//  DWORD DLL_WaveControl
//
//  Description:
//      Wrapper for DLL control entry point.
//
//  Arguments:
//      UINT uMsg: Type of message.
//
//      LPVOID pvoid: Message dependent.
//
//  Return (DWORD):
//      Message depedent.
//
//  History:
//      06/17/94    Fwong       Building wrapper.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL DLL_WaveControl
(
    UINT    uMsg,
    LPVOID  pvoid
)
{
    static CONTROLPROC  pfnWaveControl;

    if(DLL_LOAD == uMsg)
    {
        HINSTANCE hInst;

        hInst = (HINSTANCE)((UINT)(DWORD)pvoid);
        pfnWaveControl = (CONTROLPROC)GetProcAddress(hInst,"WaveControl");

        return 0L;
    }
    else
    {
        return (pfnWaveControl((UINT)uMsg,(LPVOID)pvoid));
    }
} // DLL_WaveControl()


void InitSupportFiles
(
    HINSTANCE   hinst
)
{
    OFSTRUCT    ofs;
    HRSRC       hrsrc;
    char        szScrap[MAXSTDSTR];

    GetApplicationDir(hinst,szScrap,sizeof(szScrap));
    lstrcat(szScrap,"\\mmreg.ini");

    if(HFILE_ERROR == OpenFile(szScrap,&ofs,OF_EXIST))
    {
        hrsrc = FindResource(
            hinst,
            MAKEINTRESOURCE(ID_INIFILE),
            MAKEINTRESOURCE(BINARY));

        ResourceToFile(hinst,hrsrc,szScrap);
    }

    GetApplicationDir(hinst,szScrap,sizeof(szScrap));
    lstrcat(szScrap,"\\wavecb.dll");

    if(HFILE_ERROR == OpenFile(szScrap,&ofs,OF_EXIST))
    {
        hrsrc = FindResource(
            hinst,
            MAKEINTRESOURCE(ID_CBDLL),
            MAKEINTRESOURCE(BINARY));

        ResourceToFile(hinst,hrsrc,szScrap);
    }
}


void InitDLL
(
    void
)
{
    ghinstDLL = LoadLibrary("wavecb.dll");

    pfnCallBack = GetProcAddress(ghinstDLL,"WaveCallback");
    DLL_WaveControl(DLL_LOAD,(LPVOID)(UINT)ghinstDLL);
}


//--------------------------------------------------------------------------;
//
//  void InitDeviceMenu
//
//  Description:
//      Initializes device menu.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

void InitDeviceMenu
(
    void
)
{
    UINT        u;
    UINT        uDevs;
    MMRESULT    mmr;
    WAVEINCAPS  wic;
    WAVEOUTCAPS woc;
    
    uDevs = waveInGetNumDevs();

    mmr = waveInGetDevCaps(WAVE_MAPPER, &wic, sizeof(WAVEINCAPS));

    tstInstallCustomTest(
        "&Input Device",
        ((MMSYSERR_NOERROR == mmr)?(wic.szPname):(gszMapper)),
        IDM_INPUT_BASE,
        MenuProc);

    for (u = 0; u < uDevs; u++)
    {
        mmr = waveInGetDevCaps(u, &wic, sizeof(WAVEINCAPS));

        if(MMSYSERR_NOERROR == mmr)
        {
            tstInstallCustomTest(
                "&Input Device",
                wic.szPname,
                (u + IDM_INPUT_BASE + 1),
                MenuProc);
        }
        else
        {
            tstLog(TERSE,"Error installing input device (ID = %u)",u);
        }
    }

    AppendMenu(
        GetSubMenu(GetMenu(ghwndTstsHell),4),
        MF_SEPARATOR,
        0,
        NULL);

    tstInstallCustomTest(
        "&Input Device",
        "&Map Device",
        IDM_MAPPED_INPUT,
        MenuProc);

    uDevs = waveOutGetNumDevs();

    mmr = waveOutGetDevCaps(WAVE_MAPPER, &woc, sizeof(WAVEOUTCAPS));

    tstInstallCustomTest(
        "O&utput Device",
        ((MMSYSERR_NOERROR == mmr)?(woc.szPname):(gszMapper)),
        IDM_OUTPUT_BASE,
        MenuProc);

    for (u = 0; u < uDevs; u++)
    {
        mmr = waveOutGetDevCaps(u, &woc, sizeof(WAVEOUTCAPS));

        if(MMSYSERR_NOERROR == mmr)
        {
            tstInstallCustomTest(
                "O&utput Device",
                woc.szPname,
                (u + IDM_OUTPUT_BASE + 1),
                MenuProc);
        }
        else
        {
            tstLog(TERSE,"Error installing output device (ID = %u)",u);
        }
    }

    AppendMenu(
        GetSubMenu(GetMenu(ghwndTstsHell),5),
        MF_SEPARATOR,
        0,
        NULL);

    tstInstallCustomTest(
        "O&utput Device",
        "&Map Device",
        IDM_MAPPED_OUTPUT,
        MenuProc);

} // InitDeviceMenu()


//--------------------------------------------------------------------------;
//
//  void InitOptions
//
//  Description:
//      Initializes Options.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

void InitOptions
(
    void
)
{
    AppendMenu(
        GetSubMenu(GetMenu(ghwndTstsHell),3),
        MF_SEPARATOR,
        0,
        NULL);

    tstInstallCustomTest(
        "&Options",
        "Lo&g Time",
        IDM_OPTIONS_LOGTIME,
        MenuProc);

    if(gti.fdwFlags & TESTINFOF_LOG_TIME)
    {
        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            (UINT)(IDM_OPTIONS_LOGTIME),
            MF_CHECKED);
    }

    tstInstallCustomTest(
        "&Options",
        "Test &All Formats",
        IDM_OPTIONS_ALLFMTS,
        MenuProc);

    if(gti.fdwFlags & TESTINFOF_ALL_FMTS)
    {
        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            (UINT)(IDM_OPTIONS_ALLFMTS),
            MF_CHECKED);
    }

    tstInstallCustomTest(
        "&Options",
        "Test &Special Formats",
        IDM_OPTIONS_SPCFMTS,
        MenuProc);

    if(gti.fdwFlags & TESTINFOF_SPC_FMTS)
    {
        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            (UINT)(IDM_OPTIONS_SPCFMTS),
            MF_CHECKED);
    }

#ifdef  WIN32

    tstInstallCustomTest(
        "&Options",
        "Use Separate T&hreads",
        IDM_OPTIONS_THREAD,
        MenuProc);

    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            (UINT)(IDM_OPTIONS_THREAD),
            MF_CHECKED);
    }

#endif  //  WIN32

} // InitOptions()


//--------------------------------------------------------------------------;
//
//  void InitInfo
//
//  Description:
//      Initializes Information.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

void InitInfo
(
    void
)
{
    UINT        u;
    MMRESULT    mmr;
    WAVEINCAPS  wic;
    WAVEOUTCAPS woc;
    char        szScrap[MAXSTDSTR];

    //
    //  Finding maximum format size...
    //

    mmr = acmMetrics(NULL,ACM_METRIC_MAX_SIZE_FORMAT,&gti.cbMaxFormatSize);

    if(MMSYSERR_NOERROR != mmr)
    {
        gti.cbMaxFormatSize = sizeof(WAVEFORMATEX);
    }

    //
    //  Restoring previous flags...
    //

    gti.fdwFlags  = GetIniDWORD(gszGlobal,gszFlags,0L);
    gti.fdwFlags &= (~TESTINFOF_USE_ACM);

    //
    //  Choosing input device...
    //

    GetIniString(gszGlobal,gszInputDev,szScrap,MAXSTDSTR);
    gti.uInputDevice = (0 == waveInGetNumDevs())?WAVE_MAPPER:0;

    for(u = waveInGetNumDevs() + 1; u; u--)
    {
        mmr = waveInGetDevCaps(u-2,&wic,sizeof(WAVEINCAPS));

        if(MMSYSERR_NOERROR == mmr)
        {
            if(0 == lstrcmp(szScrap,wic.szPname))
            {
                gti.uInputDevice = (u-2);
                break;
            }
        }
        else
        {
            if((WAVE_MAPPER == (u-2)) && (0 == lstrcmp(szScrap,gszMapper)))
            {
                gti.uInputDevice = WAVE_MAPPER;
                break;
            }
        }
    }

    CheckMenuItem(
        GetMenu(ghwndTstsHell),
        IDM_INPUT_BASE + 1 + gti.uInputDevice,
        MF_CHECKED);

    if((WAVE_MAPPER != gti.uInputDevice) && (IsGEversion4()))
    {
        EnableMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_INPUT,
            MF_BYCOMMAND|MF_ENABLED);

        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_INPUT,
            ((gti.fdwFlags & TESTINFOF_MAP_IN)?MF_CHECKED:MF_UNCHECKED));
    }
    else
    {
        gti.fdwFlags &= ~(TESTINFOF_MAP_IN);

        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_INPUT,
            MF_UNCHECKED);

        EnableMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_INPUT,
            MF_BYCOMMAND|MF_GRAYED);
    }

    //
    //  Choosing output device...
    //

    GetIniString(gszGlobal,gszOutputDev,szScrap,MAXSTDSTR);
    gti.uOutputDevice = (0 == waveOutGetNumDevs())?WAVE_MAPPER:0;

    for(u = waveOutGetNumDevs() + 1; u; u--)
    {
        mmr = waveOutGetDevCaps(u-2,&woc,sizeof(WAVEOUTCAPS));

        if(MMSYSERR_NOERROR == mmr)
        {
            if(0 == lstrcmp(szScrap,woc.szPname))
            {
                gti.uOutputDevice = (u-2);
                break;
            }
        }
        else
        {
            if((WAVE_MAPPER == (u-2)) && (0 == lstrcmp(szScrap,gszMapper)))
            {
                gti.uOutputDevice = WAVE_MAPPER;
                break;
            }
        }
    }

    CheckMenuItem(
        GetMenu(ghwndTstsHell),
        IDM_OUTPUT_BASE + 1 + gti.uOutputDevice,
        MF_CHECKED);

    if((WAVE_MAPPER != gti.uOutputDevice) && (IsGEversion4()))
    {
        EnableMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_OUTPUT,
            MF_BYCOMMAND|MF_ENABLED);

        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_OUTPUT,
            ((gti.fdwFlags & TESTINFOF_MAP_OUT)?MF_CHECKED:MF_UNCHECKED));
    }
    else
    {
        gti.fdwFlags &= ~(TESTINFOF_MAP_OUT);

        CheckMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_OUTPUT,
            MF_UNCHECKED);

        EnableMenuItem(
            GetMenu(ghwndTstsHell),
            IDM_MAPPED_OUTPUT,
            MF_BYCOMMAND|MF_GRAYED);
    }

    gti.pwfx1 = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,gti.cbMaxFormatSize);
    gti.pwfx2 = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,gti.cbMaxFormatSize);
    
    gti.pdwIndex = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(DWORD));
    gti.pdwIndex[0] = (DWORD)(-1);

    //
    //  Getting minimum number of milliseconds for pause/stop interval.
    //    See IsStopped(wavein.c) and IsPaused(waveout.c).  This defaults
    //    to 20 milliseconds.
    //

    gti.cMinStopThreshold = GetIniDWORD(gszGlobal,gszThreshold,20L);

    //
    //  Getting maximum number of milliseconds that an API can take before
    //    labeling that API call as an failure.  This is used in 
    //    Log_Error(log.c) which is typically called from wrapper functions
    //    in wrappers.c.  This defaults to 10 ms.
    //

    gti.cMaxTimeThreshold = GetIniDWORD(gszGlobal,gszTimeThreshold,10L);

    //
    //  Getting slow down and speed up percentages for testing special
    //  formats.
    //

    gti.uSlowPercent = (UINT)GetIniDWORD(gszGlobal,gszSlowPercent,20L);
    gti.uFastPercent = (UINT)GetIniDWORD(gszGlobal,gszFastPercent,20L);

    gti.uSlowPercent = (gti.uSlowPercent > 99)?20:gti.uSlowPercent;
    gti.uFastPercent = (gti.uFastPercent > 99)?20:gti.uFastPercent;

} // InitInfo()


//--------------------------------------------------------------------------;
//
//  LPWAVEFORMATEX GetSupportedInputFormat
//
//  Description:
//      Gets supported input format.
//
//  Arguments:
//      UINT uDeviceID: Device ID
//
//  Return (LPWAVEFORMATEX):
//      Pointer to valid pwfx for Input.
//
//  History:
//      02/21/94    Fwong       For initialization purposes.
//
//--------------------------------------------------------------------------;

LPWAVEFORMATEX GetSupportedInputFormat
(
    UINT    uDeviceID
)
{
    WAVEINCAPS      wic;
    MMRESULT        mmr;
    UINT            u;
    DWORD           dwFormats,dwMask;
    LPWAVEFORMATEX  pwfx;

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(PCMWAVEFORMAT));

    mmr = waveInGetDevCaps(uDeviceID, &wic, sizeof(WAVEINCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        if(WAVE_MAPPER == uDeviceID)
        {
            //
            //  Wave Mapper not installed?
            //    Enumerate all devices!
            //
    
            dwFormats = 0L;

            for(u = waveInGetNumDevs(); u; u--)
            {
                mmr = waveInGetDevCaps(u-1, &wic, sizeof(WAVEINCAPS));

                if(MMSYSERR_NOERROR == mmr)
                {
                    dwFormats |= wic.dwFormats;
                }
            }
        }
        else
        {
            //
            //  Huh?!!  How can this happen?
            //  Assigning 11M08
            //

            DPF(1,"Could not get WAVEINCAPS!");
            dwFormats = 0L;
        }
    }
    else
    {
        dwFormats = wic.dwFormats;
    }

    if(0 == dwFormats)
    {
        //
        //  Okay... Something else went nuts!!
        //

        DPF(1,"No format flags were set in WAVEINCAPS!");

        dwFormats = WAVE_FORMAT_1M08;
    }

    for(dwMask = 1;;dwMask *= 2)
    {
        if(dwMask & dwFormats)
        {
            FormatFlag_To_Format(dwMask,(LPPCMWAVEFORMAT)pwfx);

            break;
        }
    }

    return pwfx;
} // GetSupportedInputFormat()


//--------------------------------------------------------------------------;
//
//  LPWAVEFORMATEX GetSupportedOutputFormat
//
//  Description:
//      Gets supported Output format.
//
//  Arguments:
//      UINT uDeviceID: Device ID
//
//  Return (LPWAVEFORMATEX):
//      Pointer to valid pwfx for Output.
//
//  History:
//      02/21/94    Fwong       For initialization purposes.
//
//--------------------------------------------------------------------------;

LPWAVEFORMATEX GetSupportedOutputFormat
(
    UINT    uDeviceID
)
{
    WAVEOUTCAPS     woc;
    MMRESULT        mmr;
    UINT            u;
    DWORD           dwFormats,dwMask;
    LPWAVEFORMATEX  pwfx;

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(PCMWAVEFORMAT));

    mmr = waveOutGetDevCaps(uDeviceID, &woc, sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        if(WAVE_MAPPER == uDeviceID)
        {
            //
            //  Wave Mapper not installed?
            //    Enumerate all devices!
            //
    
            dwFormats = 0L;

            for(u = waveOutGetNumDevs(); u; u--)
            {
                mmr = waveOutGetDevCaps(u-1, &woc, sizeof(WAVEOUTCAPS));

                if(MMSYSERR_NOERROR == mmr)
                {
                    dwFormats |= woc.dwFormats;
                }
            }
        }
        else
        {
            //
            //  Huh?!!  How can this happen?
            //  Assigning 11M08
            //

            DPF(1,"Could not get WAVEOUTCAPS!");
            dwFormats = 0L;
        }
    }
    else
    {
        dwFormats = woc.dwFormats;
    }

    if(0 == dwFormats)
    {
        //
        //  Okay... Something else went nuts!!
        //

        DPF(1,"No format flags were set in WAVEOUTCAPS!");

        dwFormats = WAVE_FORMAT_1M08;
    }

    for(dwMask = 1;;dwMask *= 2)
    {
        if(dwMask & dwFormats)
        {
            FormatFlag_To_Format(dwMask,(LPPCMWAVEFORMAT)pwfx);

            break;
        }
    }

    return pwfx;
} // GetSupportedOutputFormat()


//--------------------------------------------------------------------------;
//
//  void InitFormatMenu
//
//  Description:
//      Initializes format menu.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

void InitFormatMenu
(
    void
)
{
    MMRESULT            mmr;
    DWORD               dw;
    LPACMFORMATDETAILS  pafd;

    tstInstallCustomTest(
        "Fo&rmat",
        "&Input Format...",
        IDM_INPUT_FORMAT,
        MenuProc);

    tstInstallCustomTest(
        "Fo&rmat",
        "&Output Format...",
        IDM_OUTPUT_FORMAT,
        MenuProc);

    tstInstallCustomTest(
        "Fo&rmat",
        "&List Formats...",
        IDM_LIST_FORMAT,
        MenuProc);

    pafd = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(ACMFORMATDETAILS));

    dw = GetIniBinSize(gszGlobal,gszInputFormat);

    if(0 != dw)
    {
        gti.pwfxInput = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,dw);

        if(!GetIniBin(gszGlobal,gszInputFormat,gti.pwfxInput,dw))
        {
            ExactFreePtr(gti.pwfxInput);
            gti.pwfxInput = NULL;
        }
    }

    if(NULL != gti.pwfxInput)
    {
        //
        //  Is format recognized?!
        //

        _fmemset(pafd,0,sizeof(ACMFORMATDETAILS));

        pafd->cbStruct      = sizeof(ACMFORMATDETAILS);
        pafd->dwFormatTag   = (DWORD)gti.pwfxInput->wFormatTag;
        pafd->pwfx          = gti.pwfxInput;
        pafd->cbwfx         = dw;

        mmr = acmFormatDetails(NULL,pafd,ACM_FORMATDETAILSF_FORMAT);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF(1,"Input format not recognized!");
            ExactFreePtr(gti.pwfxInput);
            gti.pwfxInput = NULL;
        }
    }

    if(NULL == gti.pwfxInput)
    {
        gti.pwfxInput = GetSupportedInputFormat(gti.uInputDevice);
    }

    dw = GetIniBinSize(gszGlobal,gszOutputFormat);

    if(0 != dw)
    {
        gti.pwfxOutput = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,dw);

        if(!GetIniBin(gszGlobal,gszOutputFormat,gti.pwfxOutput,dw))
        {
            ExactFreePtr(gti.pwfxOutput);
            gti.pwfxOutput = NULL;
        }
    }

    if(NULL != gti.pwfxOutput)
    {
        //
        //  Is format recognized?!
        //

        _fmemset(pafd,0,sizeof(ACMFORMATDETAILS));

        pafd->cbStruct      = sizeof(ACMFORMATDETAILS);
        pafd->dwFormatTag   = (DWORD)gti.pwfxOutput->wFormatTag;
        pafd->pwfx          = gti.pwfxOutput;
        pafd->cbwfx         = dw;

        mmr = acmFormatDetails(NULL,pafd,ACM_FORMATDETAILSF_FORMAT);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF(1,"Output format not recognized!");
            ExactFreePtr(gti.pwfxOutput);
            gti.pwfxOutput = NULL;
        }
    }

    if(NULL == gti.pwfxOutput)
    {
        gti.pwfxOutput = GetSupportedOutputFormat(gti.uOutputDevice);
    }

    ExactFreePtr(pafd);
} // InitFormatMenu()


//--------------------------------------------------------------------------;
//
//  LRESULT MenuProc
//
//  Description:
//      Basically a WNDPROC that processes menu item message.
//
//  Arguments:
//      HWND hwnd: Typical HWND parameter.
//
//      UINT msg: Typical UINT parameter.
//
//      WPARAM wParam: Typical WPARAM parameter.
//
//      LPARAM lParam: Typical LPARAM parameter.
//
//  Return (LRESULT):
//      Message depedent.
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL MenuProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UINT            u;
    DWORD           dw;
    LPSTR           pszFormat;
    LPWAVEFORMATEX  pwfxTmp;
    MMRESULT        mmr;
    ACMFORMATCHOOSE afc;

    switch (wParam)
    {
        //
        //  Members of "&Format" menu...
        //

        case IDM_INPUT_FORMAT:
            _fmemset(&afc,0,sizeof(ACMFORMATCHOOSE));

            pwfxTmp = ExactAllocPtr(
                          GMEM_SHARE|GMEM_MOVEABLE,
                          gti.cbMaxFormatSize);

            wfxCpy(pwfxTmp,gti.pwfxInput);

            afc.cbStruct  = sizeof(ACMFORMATCHOOSE);
            afc.fdwStyle  = ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT;
            afc.hwndOwner = ghwndTstsHell;
            afc.pwfx      = pwfxTmp;
            afc.cbwfx     = gti.cbMaxFormatSize;
            afc.pszTitle  = "Format Selection";

            mmr = acmFormatChoose(&afc);

            if(MMSYSERR_NOERROR != mmr)
            {
                //
                //  Whoops!! Error!!
                //

                ExactFreePtr(pwfxTmp);
            }
            else
            {
                u   = gti.uInputDevice;

                mmr = waveInOpen(
                    NULL,
                    u,
                    (HACK)pwfxTmp,
                    0L,
                    0L,
                    WAVE_FORMAT_QUERY|INPUT_MAP(gti));

                if(MMSYSERR_NOERROR != mmr)
                {
                    dw        = 3*MAXFMTSTR;
                    pszFormat = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,dw);

                    lstrcpy(
                        pszFormat,
                        "The current input device cannot open:\n\t");

                    GetFormatName(&(pszFormat[39]),pwfxTmp,dw-39);

                    lstrcat(pszFormat,"\n\nReverting back to:\n\t");

                    u = lstrlen(pszFormat);
                    GetFormatName(&(pszFormat[u]),gti.pwfxInput,dw-u);

                    IdiotBox(pszFormat);

                    ExactFreePtr(pszFormat);
                    ExactFreePtr(pwfxTmp);
                }
                else
                {
                    ExactFreePtr(gti.pwfxInput);

                    dw = SIZEOFWAVEFORMAT(pwfxTmp);

                    gti.pwfxInput = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,dw);

                    wfxCpy(gti.pwfxInput,pwfxTmp);

                    ExactFreePtr(pwfxTmp);
                }
            }

            break;

        case IDM_OUTPUT_FORMAT:
            _fmemset(&afc,0,sizeof(ACMFORMATCHOOSE));

            pwfxTmp = ExactAllocPtr(
                          GMEM_SHARE|GMEM_MOVEABLE,
                          gti.cbMaxFormatSize);

            wfxCpy(pwfxTmp,gti.pwfxOutput);

            afc.cbStruct  = sizeof(ACMFORMATCHOOSE);
            afc.fdwStyle  = ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT;
            afc.hwndOwner = ghwndTstsHell;
            afc.pwfx      = pwfxTmp;
            afc.cbwfx     = gti.cbMaxFormatSize;
            afc.pszTitle  = "Format Selection";

            mmr = acmFormatChoose(&afc);

            if(MMSYSERR_NOERROR != mmr)
            {
                //
                //  Whoops!! Error!!
                //

                ExactFreePtr(pwfxTmp);
            }
            else
            {
                u   = gti.uOutputDevice;

                mmr = waveOutOpen(
                    NULL,
                    u,
                    (HACK)pwfxTmp,
                    0L,
                    0L,
                    WAVE_FORMAT_QUERY|OUTPUT_MAP(gti));

                if(MMSYSERR_NOERROR != mmr)
                {
                    DPF(1,"Failing query open. Error %s.",GetErrorText(mmr));
                }

                if(MMSYSERR_NOERROR != mmr)
                {
                    dw        = 3*MAXFMTSTR;
                    pszFormat = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,dw);

                    lstrcpy(
                        pszFormat,
                        "The current output device cannot open:\n\t");

                    GetFormatName(&(pszFormat[40]),pwfxTmp,dw-40);

                    lstrcat(pszFormat,"\n\nReverting back to:\n\t");

                    u = lstrlen(pszFormat);
                    GetFormatName(&(pszFormat[u]),gti.pwfxOutput,dw-u);

                    IdiotBox(pszFormat);

                    ExactFreePtr(pszFormat);
                    ExactFreePtr(pwfxTmp);
                }
                else
                {
                    ExactFreePtr(gti.pwfxOutput);

                    dw = SIZEOFWAVEFORMAT(pwfxTmp);

                    gti.pwfxOutput = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,dw);

                    wfxCpy(gti.pwfxOutput,pwfxTmp);

                    ExactFreePtr(pwfxTmp);

                    //
                    //  Re-loading the resources for new format...
                    //

                    LoadWaveResource(&gti.wrShort,WR_SHORT);
                    LoadWaveResource(&gti.wrMedium,WR_MEDIUM);
                    LoadWaveResource(&gti.wrLong,WR_LONG);
                }
            }

            break;

        case IDM_LIST_FORMAT:

            //
            //  Listing formats...
            //

            dw        = 3*MAXFMTSTR;
            pszFormat = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,dw);

            lstrcpy(pszFormat,"Input: ");
            GetFormatName(&(pszFormat[7]),gti.pwfxInput,dw-7);

            lstrcat(pszFormat,"\n\nOutput: ");
            u = lstrlen(pszFormat);
            GetFormatName(&(pszFormat[u]),gti.pwfxOutput,dw-u);

            MessageBox(
                ghwndTstsHell,
                pszFormat,
                "Current Formats",
                MB_OK|MB_ICONINFORMATION);

            ExactFreePtr(pszFormat);

            break;

        case IDM_OPTIONS_LOGTIME:

            //
            //  Toggle time logging...
            //

            CheckMenuItem(
                GetMenu(ghwndTstsHell),
                (UINT)(IDM_OPTIONS_LOGTIME),
                ((gti.fdwFlags & TESTINFOF_LOG_TIME)?MF_UNCHECKED:MF_CHECKED));

            gti.fdwFlags ^= TESTINFOF_LOG_TIME;

            break;

        case IDM_MAPPED_INPUT:

            //
            //  Toggle mapped input...
            //

            CheckMenuItem(
                GetMenu(ghwndTstsHell),
                (UINT)(IDM_MAPPED_INPUT),
                ((gti.fdwFlags & TESTINFOF_MAP_IN)?MF_UNCHECKED:MF_CHECKED));

            gti.fdwFlags ^= TESTINFOF_MAP_IN;

            break;

        case IDM_MAPPED_OUTPUT:

            //
            //  Toggle mapped output...
            //

            CheckMenuItem(
                GetMenu(ghwndTstsHell),
                (UINT)(IDM_MAPPED_OUTPUT),
                ((gti.fdwFlags & TESTINFOF_MAP_OUT)?MF_UNCHECKED:MF_CHECKED));

            gti.fdwFlags ^= TESTINFOF_MAP_OUT;

            break;

        case IDM_OPTIONS_ALLFMTS:

            //
            //  Toggle testing all formats...
            //

            CheckMenuItem(
                GetMenu(ghwndTstsHell),
                (UINT)(IDM_OPTIONS_ALLFMTS),
                ((gti.fdwFlags & TESTINFOF_ALL_FMTS)?MF_UNCHECKED:MF_CHECKED));

            gti.fdwFlags ^= TESTINFOF_ALL_FMTS;

            break;

        case IDM_OPTIONS_SPCFMTS:

            //
            //  Toggle testing all formats...
            //

            CheckMenuItem(
                GetMenu(ghwndTstsHell),
                (UINT)(IDM_OPTIONS_SPCFMTS),
                ((gti.fdwFlags & TESTINFOF_SPC_FMTS)?MF_UNCHECKED:MF_CHECKED));

            gti.fdwFlags ^= TESTINFOF_SPC_FMTS;

            break;

        case IDM_OPTIONS_THREAD:

            //
            //  Toggle thread spawning...
            //

            CheckMenuItem(
                GetMenu(ghwndTstsHell),
                (UINT)(IDM_OPTIONS_THREAD),
                ((gti.fdwFlags & TESTINFOF_THREAD)?MF_UNCHECKED:MF_CHECKED));

            gti.fdwFlags ^= TESTINFOF_THREAD;

            break;

        default:
            u = waveInGetNumDevs();

            if ((wParam >= (IDM_INPUT_BASE)) &&
                (wParam <= (IDM_INPUT_BASE + u)))
            {
                //
                //  Doing input devices...
                //

                gti.uInputDevice = wParam - IDM_INPUT_BASE - 1;

                if((WAVE_MAPPER != gti.uInputDevice) && (IsGEversion4()))
                {
                    EnableMenuItem(
                        GetMenu(ghwndTstsHell),
                        IDM_MAPPED_INPUT,
                        MF_BYCOMMAND|MF_ENABLED);
                }
                else
                {
                    gti.fdwFlags &= ~(TESTINFOF_MAP_IN);

                    CheckMenuItem(
                        GetMenu(ghwndTstsHell),
                        IDM_MAPPED_INPUT,
                        MF_UNCHECKED);

                    EnableMenuItem(
                        GetMenu(ghwndTstsHell),
                        IDM_MAPPED_INPUT,
                        MF_BYCOMMAND|MF_GRAYED);
                }

                for(u += (IDM_INPUT_BASE + 1);u >= IDM_INPUT_BASE;u--)
                {
                    CheckMenuItem(
                        GetMenu(ghwndTstsHell),
                        u,
                        ((wParam == u)?MF_CHECKED:MF_UNCHECKED));
                }

                u       = gti.uInputDevice;
                pwfxTmp = gti.pwfxInput;

                mmr = waveInOpen(
                    NULL,
                    u,
                    (HACK)pwfxTmp,
                    0L,
                    0L,
                    WAVE_FORMAT_QUERY|INPUT_MAP(gti));

                if(MMSYSERR_NOERROR != mmr)
                {
                    ExactFreePtr(gti.pwfxInput);
                    gti.pwfxInput = GetSupportedInputFormat(u);
                }
            }
            else
            {
                //
                //  Doing output devices...
                //

                u = waveOutGetNumDevs();

                gti.uOutputDevice = wParam - IDM_OUTPUT_BASE - 1;

                for(u += (IDM_OUTPUT_BASE + 1);u >= IDM_OUTPUT_BASE;u--)
                {
                    CheckMenuItem(
                        GetMenu(ghwndTstsHell),
                        u,
                        ((wParam == u)?MF_CHECKED:MF_UNCHECKED));
                }

                if((WAVE_MAPPER != gti.uOutputDevice) && (IsGEversion4()))
                {
                    EnableMenuItem(
                        GetMenu(ghwndTstsHell),
                        IDM_MAPPED_OUTPUT,
                        MF_BYCOMMAND|MF_ENABLED);
                }
                else
                {
                    gti.fdwFlags &= ~(TESTINFOF_MAP_OUT);

                    CheckMenuItem(
                        GetMenu(ghwndTstsHell),
                        IDM_MAPPED_OUTPUT,
                        MF_UNCHECKED);

                    EnableMenuItem(
                        GetMenu(ghwndTstsHell),
                        IDM_MAPPED_OUTPUT,
                        MF_BYCOMMAND|MF_GRAYED);
                }

                u       = gti.uOutputDevice;
                pwfxTmp = gti.pwfxOutput;

                mmr = waveOutOpen(
                    NULL,
                    u,
                    (HACK)pwfxTmp,
                    0L,
                    0L,
                    WAVE_FORMAT_QUERY|OUTPUT_MAP(gti));

                if(MMSYSERR_NOERROR != mmr)
                {
                    ExactFreePtr(gti.pwfxOutput);
                    gti.pwfxOutput = GetSupportedOutputFormat(u);

                    //
                    //  Re-loading the resources for new format...
                    //

                    LoadWaveResource(&gti.wrShort,WR_SHORT);
                    LoadWaveResource(&gti.wrMedium,WR_MEDIUM);
                    LoadWaveResource(&gti.wrLong,WR_LONG);
                }
            }

            break;
    }

    return 0L;
} // MenuProc()


//--------------------------------------------------------------------------;
//
//  void SaveSettings
//
//  Description:
//      Saves settings to .ini file.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

void SaveSettings
(
    void
)
{
    WAVEINCAPS  wic;
    WAVEOUTCAPS woc;
    MMRESULT    mmr;
    DWORD       dw;
    
    //
    //  Saving input device...
    //

    WriteIniString(gszGlobal,gszInputDev,NULL);

    if(0 != gti.uInputDevice)
    {
        mmr = waveInGetDevCaps(gti.uInputDevice,&wic,sizeof(WAVEINCAPS));

        if(MMSYSERR_NOERROR == mmr)
        {
            WriteIniString(gszGlobal,gszInputDev,wic.szPname);
        }
        else
        {
            if(WAVE_MAPPER == gti.uInputDevice)
            {
                WriteIniString(gszGlobal,gszInputDev,gszMapper);
            }
        }
    }

    //
    //  Saving input format...
    //

    dw = SIZEOFWAVEFORMAT(gti.pwfxInput);
    WriteIniBin(gszGlobal,gszInputFormat,gti.pwfxInput,dw);

    //
    //  Saving output device...
    //

    WriteIniString(gszGlobal,gszOutputDev,NULL);

    if(0 != gti.uOutputDevice)
    {
        mmr = waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

        if(MMSYSERR_NOERROR == mmr)
        {
            WriteIniString(gszGlobal,gszOutputDev,woc.szPname);
        }
        else
        {
            if(WAVE_MAPPER == gti.uOutputDevice)
            {
                WriteIniString(gszGlobal,gszOutputDev,gszMapper);
            }
        }
    }

    //
    //  Saving output format...
    //

    dw = SIZEOFWAVEFORMAT(gti.pwfxOutput);
    WriteIniBin(gszGlobal,gszOutputFormat,gti.pwfxOutput,dw);

    //
    //  Saving flags...
    //

    dw  = gti.fdwFlags;
    dw &= (~TESTINFOF_USE_ACM);
    dw &= (~TESTINFOF_THREADAUX);

    WriteIniDWORD(gszGlobal,gszFlags,dw);

} // SaveSettings()


//--------------------------------------------------------------------------;
//
//  BOOL IsGEversion4
//
//  Description:
//      Detects whether it is Windows version 4.
//
//  Arguments:
//      None.
//
//  Return (BOOL):
//      Returns TRUE if version 4, FALSE otherwise.
//
//  History:
//      02/18/94    Fwong       Conditionally checking for different flags.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IsGEversion4
(
    void
)
{
//    UINT    uVersion;
//
//    uVersion = mmsystemGetVersion();
//
//    if(4 == HIBYTE(LOWORD(uVersion)))
//    {
//        return TRUE;
//    }
//    else
//    {
//        return FALSE;
//    }
    return TRUE;
} // IsGEversion4()


/*********************** BEGIN: DEBUGGING ANNEX ****************************/

//#ifdef DEBUG
//
//void FAR cdecl dprintf(LPSTR szFormat,...)
//{
//    char ach[128];
//    int  s,d;
//
//    s = wvsprintf (ach,szFormat,(LPSTR)(&szFormat+1));
//#if 1
//    lstrcat(ach,"\n");
//    s++;
//#endif
//    for (d=sizeof(ach)-1; s>=0; s--)
//    {
//        if ((ach[d--] = ach[s]) == '\n')
//            ach[d--] = '\r';
//    }
//
//    OutputDebugString("WAVETEST: ");
//    OutputDebugString(ach+d+1);
//} // dprintf()
//
//#endif

/************************ END: DEBUGGING ANNEX *****************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\wavetest.h ===
//--------------------------------------------------------------------------;
//
//  File: WaveTest.h
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//
//  History:
//      11/24/93    Fwong
//
//--------------------------------------------------------------------------;

//==========================================================================;
//
//                       Portability Stuff...
//
//==========================================================================;

#ifndef WIN32
#define _HUGE       _huge
#define UINT_FORMAT "0x%04x"
#define PTR_FORMAT  "0x%04x:%04x"
#define MAKEPTR(lp) MAKELONG(HIWORD(lp),LOWORD(lp))
#define SLEEP(a)    // a
#else
#define UINT_FORMAT "0x%08lx"
#define PTR_FORMAT  "0x%08lx"
#define MAKEPTR(lp) (lp)
#define _HUGE
#define LPUINT      PUINT
#define SLEEP(a)    Sleep(a)
#ifndef lstrcpyn
#define lstrcpyn    strncpy
#endif  //  lstrcpyn
#endif  //  WIN32

//
//  PageLock stuff (not needed in Win32)
//

#ifndef WIN32
#define PageLock(a)     GlobalPageLock((HGLOBAL)GetMemoryHandle(a))
#define PageUnlock(a)   GlobalPageUnlock((HGLOBAL)GetMemoryHandle(a))
#else
#define PageLock(a)
#define PageUnlock(a)
#endif  //  WIN32

#if (WINVER >= 0x0400)
#define HACK        LPWAVEFORMATEX
#define VOLCTRL     HWAVEOUT
#else
#define HACK        LPWAVEFORMAT
#define VOLCTRL     UINT
#endif

//==========================================================================;
//
//                        Resource Stuff...
//
//==========================================================================;

#define ICON2               200
#define WAVE                300
#define WR_LONG             301
#define WR_MEDIUM           302
#define WR_SHORT            303
#define BINARY              400
#define ID_INIFILE          401
#define ID_CBDLL            402
#define LWR_MAP             0x0001

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#define SPACES(n)           ((LPSTR)(&gszSpaces[40 - (n)]))
#define Log_FunctionName(p) tstLog(VERBOSE,"\n\n**** %s ****",(LPSTR)p)
#define RATIO_FORMAT        "%u.%03u"

#define RATIO(dw)   (UINT)((dw)/0x10000),(UINT)((((dw)%0x10000)*1000)/0x10000)

#define ROUNDUP_TO_BLOCK(x,ba) ((x)-((x)%(ba))+(((x)%(ba))?(ba):0))

#if (WINVER >= 0x0400)
#define INPUT_MAP(a)        ((TESTINFOF_MAP_IN & a.fdwFlags)?WAVE_MAPPED:0)
#define OUTPUT_MAP(a)       ((TESTINFOF_MAP_OUT & a.fdwFlags)?WAVE_MAPPED:0)
#else
#define INPUT_MAP(a)        0
#define OUTPUT_MAP(a)       0
#endif

#define SET_FLAG(dw,f)      dw |= (f)
#define CLEAR_FLAG(dw,f)    dw &= (~f)
#define CHECK_FLAG(dw,f)    (dw & f)

//==========================================================================;
//
//                        TstsHell Stuff...
//
//==========================================================================;

#define TEST_LIST           300     // List ID as resource.
#define IDP_BASE            301     // Base Platform

#define GRP_DEVINFO         501
#define GRP_OPEN            502
#define GRP_PLAYBACK        503
#define GRP_RECORD          504
#define GRP_CAPSCTRL        505
#define GRP_WRITE           506
#define GRP_ADDBUF          507
#define GRP_PERF            508

#define ID_IDEVCAPS         601
#define ID_ODEVCAPS         602
#define ID_IOPEN            603
#define ID_ICLOSE           604
#define ID_OOPEN            605
#define ID_OCLOSE           606
#define ID_OGETPOS          607
#define ID_OPREPHDR         608
#define ID_OUNPREPHDR       609
#define ID_OBRKLOOP         610
#define ID_OPAUSE           611
#define ID_ORESTART         612
#define ID_ORESET           613
#define ID_IGETPOS          614
#define ID_IPREPHDR         615
#define ID_IUNPREPHDR       616
#define ID_ISTART           617
#define ID_ISTOP            618
#define ID_IRESET           619
#define ID_OGETPITCH        620
#define ID_OGETRATE         621
#define ID_OSETPITCH        622
#define ID_OSETRATE         623
#define ID_OGETVOL          624
#define ID_OSETVOL          625
#define ID_OWRITE           626
#define ID_OW_LTBUF         627
#define ID_OW_EQBUF         628
#define ID_OW_GTBUF         629
#define ID_OW_LOOP          630
#define ID_OW_STARVE        631
#define ID_IADDBUFFER       632
#define ID_IAB_LTBUF        633
#define ID_IAB_EQBUF        634
#define ID_IAB_GTBUF        635
#define ID_OGETPOS_ACC      636
#define ID_IGETPOS_ACC      637
#define ID_OW_TIME          638
#define ID_IAB_TIME         639
#define ID_OPOS_PERF        640
#define ID_IPOS_PERF        641

#define FN_IDEVCAPS         801
#define FN_ODEVCAPS         802
#define FN_IOPEN            803
#define FN_ICLOSE           804
#define FN_OOPEN            805
#define FN_OCLOSE           806
#define FN_OGETPOS          807
#define FN_OPREPHDR         808
#define FN_OUNPREPHDR       809
#define FN_OBRKLOOP         810
#define FN_OPAUSE           811
#define FN_ORESTART         812
#define FN_ORESET           813
#define FN_IGETPOS          814
#define FN_IPREPHDR         815
#define FN_IUNPREPHDR       816
#define FN_ISTART           817
#define FN_ISTOP            818
#define FN_IRESET           819
#define FN_OGETPITCH        820
#define FN_OGETRATE         821
#define FN_OSETPITCH        822
#define FN_OSETRATE         823
#define FN_OGETVOL          824
#define FN_OSETVOL          825
#define FN_OWRITE           826
#define FN_OW_LTBUF         827
#define FN_OW_EQBUF         828
#define FN_OW_GTBUF         829
#define FN_OW_LOOP          830
#define FN_OW_STARVE        831
#define FN_IADDBUFFER       832
#define FN_IAB_LTBUF        833
#define FN_IAB_EQBUF        834
#define FN_IAB_GTBUF        835
#define FN_OGETPOS_ACC      836
#define FN_IGETPOS_ACC      837
#define FN_OW_TIME          838
#define FN_IAB_TIME         839
#define FN_OPOS_PERF        840
#define FN_IPOS_PERF        841


//==========================================================================;
//
//                             DLL Stuff...
//
//==========================================================================;

#define WOM_OPEN_FLAG       0x00000001
#define WOM_CLOSE_FLAG      0x00000002
#define WOM_DONE_FLAG       0x00000004
#define WIM_OPEN_FLAG       0x00000008
#define WIM_CLOSE_FLAG      0x00000010
#define WIM_DATA_FLAG       0x00000020
#define WHDR_DONE_ERROR     0x00000040

#define DLL_INIT            0x00000000
#define DLL_END             0x00000001
#define DLL_LOAD            0x00000002

//==========================================================================;
//
//                        Misc. Constants...
//
//==========================================================================;

#define MAXSTDSTR           144
#define TIMER_ID            1

//==========================================================================;
//
//                        Flags and ID's...
//
//==========================================================================;

#define TESTINFOF_USE_ACM   0x00000001
#define TESTINFOF_LOG_TIME  0x00000002
#define TESTINFOF_MAP_IN    0x00000004
#define TESTINFOF_MAP_OUT   0x00000008
#define TESTINFOF_ALL_FMTS  0x00000010
#define TESTINFOF_SPC_FMTS  0x00000020
#define TESTINFOF_THREAD    0x00000040
#define TESTINFOF_THREADAUX 0x00000080

#define IDM_INPUT_BASE      300
#define IDM_OUTPUT_BASE     400

#define IDM_INPUT_FORMAT    500
#define IDM_OUTPUT_FORMAT   501
#define IDM_LIST_FORMAT     502
#define IDM_MAPPED_INPUT    503
#define IDM_MAPPED_OUTPUT   504
#define IDM_OPTIONS_LOGTIME 505
#define IDM_OPTIONS_ALLFMTS 506
#define IDM_OPTIONS_SPCFMTS 507
#define IDM_OPTIONS_THREAD  508


//==========================================================================;
//
//                          Structures...
//
//==========================================================================;

typedef struct WAVERESOURCE_tag
{
    LPBYTE          pData;
    DWORD           cbSize;
} WAVERESOURCE;
typedef WAVERESOURCE       *PWAVERESOURCE;
typedef WAVERESOURCE NEAR *NPWAVERESOURCE;
typedef WAVERESOURCE FAR  *LPWAVERESOURCE;

typedef struct TESTINFO_tag
{
    UINT            uInputDevice;
    UINT            uOutputDevice;
    LPWAVEFORMATEX  pwfxInput;
    LPWAVEFORMATEX  pwfxOutput;
    WAVERESOURCE    wrShort;
    WAVERESOURCE    wrMedium;
    WAVERESOURCE    wrLong;
    UINT            uSlowPercent;
    UINT            uFastPercent;
    DWORD           cMinStopThreshold;
    DWORD           cMaxTimeThreshold;
    DWORD           cbMaxFormatSize;
    DWORD           dwBufferLength;
    DWORD           fdwFlags;
    LPWAVEFORMATEX  pwfx1;
    LPWAVEFORMATEX  pwfx2;
    LPDWORD         pdwIndex;
} TESTINFO;
typedef TESTINFO       *PTESTINFO;
typedef TESTINFO NEAR *NPTESTINFO;
typedef TESTINFO FAR  *LPTESTINFO;

typedef struct WAVEINFO_tag
{
    DWORD   fdwFlags;
    DWORD   dwInstance;
    DWORD   dwCount;
    DWORD   dwCurrent;
    DWORD   adwTime[];
} WAVEINFO;
typedef WAVEINFO       *PWAVEINFO;
typedef WAVEINFO NEAR *NPWAVEINFO;
typedef WAVEINFO FAR  *LPWAVEINFO;

//==========================================================================;
//
//                            Globals...
//
//==========================================================================;

extern HWND         ghwndTstsHell;        // wavetest.c
extern HINSTANCE    ghinstance;           // wavetest.c
extern TESTINFO     gti;                  // wavetest.c
extern FARPROC      pfnCallBack;          // wavetest.c
extern char         gszSpaces[];          // wavetest.c
extern char         gszGlobal[];          // wavetest.c
extern char         gszInputDev[];        // wavetest.c
extern char         gszOutputDev[];       // wavetest.c
extern char         gszInputFormat[];     // wavetest.c
extern char         gszOutputFormat[];    // wavetest.c
extern char         gszFlags[];           // wavetest.c
extern char         gszShort[];           // wavetest.c
extern char         gszMedium[];          // wavetest.c
extern char         gszLong[];            // wavetest.c
extern char         gszBufferCount[];     // wavetest.c
extern char         gszRatio[];           // wavetest.c
extern char         gszDelta[];           // wavetest.c
extern char         gszDataLength[];      // wavetest.c
extern char         gszPercent[];         // wavetest.c
extern char         gszError[];           // wavetest.c
extern char         gszFailNoMem[];       // wavetest.c
extern char         gszFailOpen[];        // wavetest.c
extern char         gszFailGetCaps[];     // wavetest.c
extern char         gszFailWIPrepare[];   // wavetest.c
extern char         gszFailWOPrepare[];   // wavetest.c
extern char         gszFailExactAlloc[];  // wavetest.c
extern char         gszMsgNoInDevs[];     // wavetest.c
extern char         gszMsgNoOutDevs[];    // wavetest.c
extern char         gszTestDuration[];    // wavetest.c


//==========================================================================;
//
//                      External Prototypes...
//
//==========================================================================;

//
//  Mmsystem
//

#if (WINVER >= 0x0400)

WINMMAPI UINT WINAPI mmsystemGetVersion
(
    void
);

WINMMAPI MMRESULT FAR PASCAL waveOutGetID
(
    HWAVEOUT    hWaveOut,
    UINT FAR*   lpuDeviceID
);

WINMMAPI MMRESULT FAR PASCAL waveInGetID
(
    HWAVEIN     hWaveIn,
    UINT FAR*   lpuDeviceID
);

#endif

//
//  WaveTest.c
//

extern void FNGLOBAL TestYield
(
    void
);

extern BOOL FNGLOBAL WaitForMessage
(
    HWND    hwnd,
    UINT    msg1,
    DWORD   dwTime
);

extern BOOL FNGLOBAL IsGEversion4
(
    void
);

extern void FNGLOBAL wait
(
    DWORD   dwTime
);

extern DWORD FNGLOBAL DLL_WaveControl
(
    UINT    uMsg,
    LPVOID  pvoid
);

//
//  WaveUtil.c
//

extern BOOL FNGLOBAL Volume_SupportStereo
(
    UINT    uDeviceID
);

extern DWORD GetMSFromMMTIME
(
    LPWAVEFORMATEX  pwfx,
    LPMMTIME        pmmt
);

extern DWORD GetValueFromMMTIME
(
    LPMMTIME  pmmt
);

extern BOOL FNGLOBAL ConvertWaveResource
(
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst,
    LPWAVERESOURCE  pwr
);

extern BOOL FNGLOBAL LoadWaveResource
(
    LPWAVERESOURCE  pwr,
    DWORD           dwResource
);

extern BOOL FNGLOBAL PlayWaveResource
(
    LPWAVEFORMATEX  pwfx,
    LPBYTE          pData,
    DWORD           cbSize
);

extern BOOL CreateSilentBuffer
(
    LPWAVEFORMATEX  pwfx,
    LPBYTE          pData,
    DWORD           cbSize
);

extern DWORD FNGLOBAL tstGetNumFormats
(
    void
);

extern BOOL FNGLOBAL tstGetFormat
(
    LPWAVEFORMATEX  pwfx,
    DWORD           cbwfx,
    DWORD           dwIndex
);

//
//  Wave.c
//

extern int FNGLOBAL Test_waveOutGetDevCaps
(
    void
);

extern int FNGLOBAL Test_waveInGetDevCaps
(
    void
);

//
//  WaveOut.c
//

extern int FNGLOBAL Test_waveOutWrite
(
    void
);

extern int FNGLOBAL Test_waveOutOpen
(
    void
);

extern int FNGLOBAL Test_waveOutClose
(
    void
);

extern int FNGLOBAL Test_waveOutGetPosition
(
    void
);

extern int FNGLOBAL Test_waveOutPrepareHeader
(
    void
);

extern int FNGLOBAL Test_waveOutUnprepareHeader
(
    void
);

extern int FNGLOBAL Test_waveOutBreakLoop
(
    void
);

extern int FNGLOBAL Test_waveOutPause
(
    void
);

extern int FNGLOBAL Test_waveOutRestart
(
    void
);

extern int FNGLOBAL Test_waveOutReset
(
    void
);

extern int FNGLOBAL Test_waveOutGetPitch
(
    void
);

extern int FNGLOBAL Test_waveOutGetPlaybackRate
(
    void
);

extern int FNGLOBAL Test_waveOutSetPitch
(
    void
);

extern int FNGLOBAL Test_waveOutSetPlaybackRate
(
    void
);

extern int FNGLOBAL Test_waveOutGetVolume
(
    void
);

extern int FNGLOBAL Test_waveOutSetVolume
(
    void
);


//
//  Write.c
//

extern DWORD FNGLOBAL waveOutDMABufferSize
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx
);

extern int FNGLOBAL Test_waveOutWrite_LTDMABufferSize
(
    void
);

extern int FNGLOBAL Test_waveOutWrite_EQDMABufferSize
(
    void
);

extern int FNGLOBAL Test_waveOutWrite_GTDMABufferSize
(
    void
);

extern int FNGLOBAL Test_waveOutWrite_Loop
(
    void
);

extern int FNGLOBAL Test_waveOutWrite_Starve
(
    void
);

//
//  WaveIn.c
//

extern int FNGLOBAL Test_waveInOpen
(
    void
);

extern int FNGLOBAL Test_waveInClose
(
    void
);

extern int FNGLOBAL Test_waveInGetPosition
(
    void
);

extern int FNGLOBAL Test_waveInAddBuffer
(
    void
);

extern int FNGLOBAL Test_waveInPrepareHeader
(
    void
);

extern int FNGLOBAL Test_waveInUnprepareHeader
(
    void
);

extern int FNGLOBAL Test_waveInStart
(
    void
);

extern int FNGLOBAL Test_waveInStop
(
    void
);

extern int FNGLOBAL Test_waveInReset
(
    void
);

//
//  AddBuffr.c
//

extern DWORD FNGLOBAL waveInDMABufferSize
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx
);

extern int FNGLOBAL Test_waveInAddBuffer
(
    void
);

extern int FNGLOBAL Test_waveInAddBuffer_LTDMABufferSize
(
    void
);

extern int FNGLOBAL Test_waveInAddBuffer_EQDMABufferSize
(
    void
);

extern int FNGLOBAL Test_waveInAddBuffer_GTDMABufferSize
(
    void
);

//
//  Perf.c
//

extern int FNGLOBAL Test_waveOutGetPosition_Accuracy
(
    void
);

extern int FNGLOBAL Test_waveInGetPosition_Accuracy
(
    void
);

extern int FNGLOBAL Test_waveOutWrite_TimeAccuracy
(
    void
);

extern int FNGLOBAL Test_waveInAddBuffer_TimeAccuracy
(
    void
);

extern int FNGLOBAL Test_waveOutGetPosition_Performance
(
    void
);

extern int FNGLOBAL Test_waveInGetPosition_Performance
(
    void
);


extern int FNGLOBAL Test_waveOutStreaming
(
    void
);

//
//  Log.c
//

extern void FNGLOBAL Log_TestName
(
    LPSTR   pszTestName
);

extern void FNGLOBAL Log_TestCase
(
    LPSTR   pszTestCase
);

extern DWORD FNGLOBAL LogPercentOff
(
    DWORD   dwActual,
    DWORD   dwIdeal
);

extern void FNGLOBAL LogPass
(
    LPSTR   pszMsg
);

extern void FNGLOBAL LogFail
(
    LPSTR   pszMsg
);

extern LPSTR GetErrorText
(
    MMRESULT    mmrError
);

extern LPSTR GetTimeTypeText
(
    UINT    uTimeType
);

extern void FNGLOBAL Log_Error
(
    LPSTR       pszFnName,
    MMRESULT    mmrError,
    DWORD       dwTime
);

extern void FNGLOBAL DebugLog_Error
(
    MMRESULT    mmrError
);

extern void IdiotBox
(
    LPSTR   pszMessage
);

extern void FNCGLOBAL Log_WAVEFORMATEX
(
    LPWAVEFORMATEX  pwfx
);

extern void FNCGLOBAL Log_MMTIME
(
    LPMMTIME    pmmtime
);

extern void FNCGLOBAL Log_WAVEHDR
(
    LPWAVEHDR   pWaveHdr
);

extern void FNCGLOBAL Log_WAVEINCAPS
(
    LPWAVEINCAPS    pwic
);

extern void FNCGLOBAL Log_WAVEOUTCAPS
(
    LPWAVEOUTCAPS   pwoc
);

extern void FNGLOBAL Enum_waveOpen_Flags
(
    DWORD   dwFlags,
    UINT    nSpaces
);

//
//  Wrappers.c
//

extern void FNGLOBAL DisableThreadCalls
(
    void
);

extern void FNGLOBAL EnableThreadCalls
(
    void
);

extern MMRESULT FNGLOBAL call_waveOutGetDevCaps
(
    UINT            uDeviceID,
    LPWAVEOUTCAPS   lpCaps,
    UINT            uSize
);

extern MMRESULT FNGLOBAL call_waveOutGetVolume
(
    UINT    uDeviceID,
    LPDWORD lpdwVolume
);

extern MMRESULT FNGLOBAL call_waveOutSetVolume
(
    UINT    uDeviceID,
    DWORD   dwVolume
);

extern MMRESULT FNGLOBAL call_waveOutOpen
(
    LPHWAVEOUT      lphWaveOut,
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    DWORD           dwCallback,
    DWORD           dwInstance,
    DWORD           dwFlags
);

extern MMRESULT FNGLOBAL call_waveOutClose
(
    HWAVEOUT    hWaveOut
);

extern MMRESULT FNGLOBAL call_waveOutPrepareHeader
(
    HWAVEOUT    hWaveOut,
    LPWAVEHDR   lpWaveOutHdr,
    UINT        uSize
);

extern MMRESULT FNGLOBAL call_waveOutUnprepareHeader
(
    HWAVEOUT    hWaveOut,
    LPWAVEHDR   lpWaveOutHdr,
    UINT        uSize
);

extern MMRESULT FNGLOBAL call_waveOutWrite
(
    HWAVEOUT    hWaveOut,
    LPWAVEHDR   lpWaveOutHdr,
    UINT        uSize
);

extern MMRESULT FNGLOBAL call_waveOutPause
(
    HWAVEOUT    hWaveOut
);

extern MMRESULT FNGLOBAL call_waveOutRestart
(
    HWAVEOUT    hWaveOut
);

extern MMRESULT FNGLOBAL time_waveOutRestart
(
    HWAVEOUT    hWaveOut,
    LPDWORD     pdwTime
);

extern MMRESULT FNGLOBAL call_waveOutReset
(
    HWAVEOUT    hWaveOut
);

extern MMRESULT FNGLOBAL call_waveOutBreakLoop
(
    HWAVEOUT    hWaveOut
);

extern MMRESULT FNGLOBAL call_waveOutGetPosition
(
    HWAVEOUT    hWaveOut,
    LPMMTIME    lpInfo,
    UINT        uSize
);

extern MMRESULT FNGLOBAL time_waveOutGetPosition
(
    HWAVEOUT    hWaveOut,
    LPMMTIME    lpInfo,
    UINT        uSize,
    LPDWORD     pdwTime
);

extern MMRESULT FNGLOBAL call_waveOutGetPitch
(
    HWAVEOUT    hWaveOut,
    LPDWORD     lpdwPitch
);

extern MMRESULT FNGLOBAL call_waveOutSetPitch
(
    HWAVEOUT    hWaveOut,
    DWORD       dwPitch
);

extern MMRESULT FNGLOBAL call_waveOutGetPlaybackRate
(
    HWAVEOUT    hWaveOut,
    LPDWORD     lpdwRate
);

extern MMRESULT FNGLOBAL call_waveOutSetPlaybackRate
(
    HWAVEOUT    hWaveOut,
    DWORD       dwRate
);

extern MMRESULT FNGLOBAL call_waveOutGetID
(
    HWAVEOUT    hWaveOut,
    LPUINT      lpuDeviceID
);

extern MMRESULT FNGLOBAL call_waveInGetDevCaps
(
    UINT            uDeviceID,
    LPWAVEINCAPS    lpCaps,
    UINT            uSize
);

extern MMRESULT FNGLOBAL call_waveInOpen
(
    LPHWAVEIN       lphWaveIn,
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    DWORD           dwCallback,
    DWORD           dwInstance,
    DWORD           dwFlags
);

extern MMRESULT FNGLOBAL call_waveInClose
(
    HWAVEIN hWaveIn
);

extern MMRESULT FNGLOBAL call_waveInPrepareHeader
(
    HWAVEIN     hWaveIn,
    LPWAVEHDR   lpWaveInHdr,
    UINT        uSize
);

extern MMRESULT FNGLOBAL call_waveInUnprepareHeader
(
    HWAVEIN     hWaveIn,
    LPWAVEHDR   lpWaveInHdr,
    UINT        uSize
);

extern MMRESULT FNGLOBAL call_waveInAddBuffer
(
    HWAVEIN     hWaveIn,
    LPWAVEHDR   lpWaveInHdr,
    UINT        uSize
);

extern MMRESULT FNGLOBAL call_waveInStart
(
    HWAVEIN hWaveIn
);

extern MMRESULT FNGLOBAL time_waveInStart
(
    HWAVEIN hWaveIn,
    LPDWORD pdwTime
);

extern MMRESULT FNGLOBAL call_waveInStop
(
    HWAVEIN hWaveIn
);

extern MMRESULT FNGLOBAL call_waveInReset
(
    HWAVEIN hWaveIn
);

extern MMRESULT FNGLOBAL call_waveInGetPosition
(
    HWAVEIN     hWaveIn,
    LPMMTIME    lpInfo,
    UINT        uSize
);

extern MMRESULT FNGLOBAL time_waveInGetPosition
(
    HWAVEIN     hWaveIn,
    LPMMTIME    lpInfo,
    UINT        uSize,
    LPDWORD     pdwTime
);

extern MMRESULT FNGLOBAL call_waveInGetID
(
    HWAVEIN hWaveIn,
    LPUINT  lpuDeviceID
);

ULONG waveGetTime( VOID ) ;

//==========================================================================;
//
//                        Debugging Stuff...
//
//==========================================================================;

//#ifdef DEBUG
//    extern void FAR cdecl dprintf(LPSTR szFormat, ...);
//    extern void ErrorBarf(UINT uError);
//
//    #define DPF         dprintf
//    #define DLE         DebugLog_Error
//#else
//    #define DPF         //
//    #define DLE         //
//#endif

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\waveout.c ===
//--------------------------------------------------------------------------;
//
//  File: WaveOut.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      AllocateOutDevice()
//      Test_waveOutOpen()
//      Test_waveOutClose()
//      Test_waveOutGetPosition()
//      Test_waveOutPrepareHeader()
//      Test_waveOutUnprepareHeader()
//       Test_waveOutBreakLoop()
//      IsPaused()
//      Test_waveOutPause()
//      Test_waveOutRestart()
//      GetMSPos()
//      Test_waveOutReset()
//      Test_waveOutGetPitch()
//      Test_waveOutGetPlaybackRate()
//      Test_waveOutSetPitch()
//      Test_waveOutSetPlaybackRate()
//      Test_waveOutGetVolume()
//      Test_waveOutSetVolume()
//
//  History:
//      01/14/94    Fwong       Re-doing WaveTest.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include <memgr.h>
#include <inimgr.h>
#include <waveutil.h>
#include <TstsHell.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "MulDiv32.h"
#include "Debug.h"


//--------------------------------------------------------------------------;
//
//  MMRESULT AllocateOutDevice
//
//  Description:
//      Recursively continues to allocate devices until waveOutOpen returns
//      an error.
//
//  Arguments:
//      UINT uDeviceID: Device ID to allocate.
//
//      LPWAVEFORMATEX pwfx: Format to allocate device with.
//
//      DWORD pdw: Pointer to DWORD to count recursion levels.
//
//  Return (MMRESULT):
//      The actual error value returned by waveOutOpen.
//
//  History:
//      03/14/94    Fwong       Trying to cover MMSYSERR_ALLOCATED case.
//
//--------------------------------------------------------------------------;

MMRESULT AllocateOutDevice
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    LPDWORD         pdw
)
{
    MMRESULT    mmr;
    HWAVEOUT    hWaveOut;

    mmr = waveOutOpen(
        &hWaveOut,
        uDeviceID,
        (HACK)pwfx,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        return mmr;
    }

    (*pdw)++;

    mmr = AllocateOutDevice(uDeviceID,pwfx,pdw);

    waveOutClose(hWaveOut);

    return mmr;
} // AllocateOutDevice()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutOpen
//
//  Description:
//      Tests the driver functionality for waveOutOpen.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutOpen
(
    void
)
{
    HWAVEOUT        hWaveOut;
    LPWAVEFORMATEX  pwfx;
    HANDLE          hHeap;
    MMRESULT        mmr;
    MMRESULT        mmrQuery;
    WAVEOUTCAPS     woc;
    DWORD           dwSync;
    DWORD           dw;
    LPWAVEINFO      pwi;
    char            szFormat[MAXSTDSTR];
    int             iResult = TST_PASS;
    static char     szTestName[] = "waveOutOpen";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    hHeap = ExactHeapCreate(0);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwfx = ExactHeapAllocPtr(
        hHeap,
        GMEM_SHARE|GMEM_MOVEABLE,
        gti.cbMaxFormatSize);

    if(NULL == pwfx)
    {
        DPF(1,"Could not allocate memory for pwfx");

        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  First, verify consistency w/ dwFlags...
    //

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    dwSync = (woc.dwSupport & WAVECAPS_SYNC)?WAVE_ALLOWSYNC:0;

    Log_TestCase("Verifying consistency with WAVEOUTCAPS.dwFormats");

    for(dw = MSB_FORMAT;dw;dw /= 2)
    {
        FormatFlag_To_Format(dw,(LPPCMWAVEFORMAT)pwfx);
        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveOutOpen(
            &hWaveOut,
            gti.uOutputDevice,
            (HACK)pwfx,
            0L,
            0L,
            dwSync|OUTPUT_MAP(gti));

        mmrQuery = waveOutOpen(
            NULL,
            gti.uOutputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|dwSync|OUTPUT_MAP(gti));

        if(MMSYSERR_NOERROR == mmr)
        {
            //
            //  No Error...  We should close the device...
            //

            waveOutClose(hWaveOut);
        }

        if(woc.dwFormats & dw)
        {
            //
            //  Hmm... We're supposed to support it.
            //

            if(MMSYSERR_NOERROR == mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR == mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }
        else
        {
            //
            //  Hmm... We're NOT supposed to support it.
            //

            if(MMSYSERR_NOERROR != mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR != mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }

        mmr = waveOutOpen(
            NULL,
            gti.uOutputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|dwSync|OUTPUT_MAP(gti));

        if(mmr != mmrQuery)
        {
            tstLog(
                TERSE,
                "    FAIL: Query open inconsistent while device allocated [%s].",
                (LPSTR)szFormat);

            iResult = TST_FAIL;
        }
        else
        {
            tstLog(
                VERBOSE,
                "    PASS: Query open consistent while device allocated [%s].",
                (LPSTR)szFormat);
        }

        //
        //  Does user want to abort?
        //

        TestYield();

        if(tstCheckRunStop(VK_ESCAPE))
        {
            //
            //  Aborted!!!  Cleaning up...
            //

            tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
            tstLogFlush();

            ExactHeapDestroy(hHeap);

            return (TST_FAIL);
        }

        tstLogFlush();
    }

    //
    //  Second, verify consistency w/ QUERY flag
    //  across all formats (enumerated by ACM)...
    //

    Log_TestCase(
        "Verifying consistency w/ opens and query opens for all formats");

    for(dw = tstGetNumFormats();dw;dw--)
    {
        if(!tstGetFormat(pwfx,gti.cbMaxFormatSize,dw-1))
        {
            //
            //  Hmm... Couldn't get this format...
            //

            DPF(1,"Couldn't get format #%d.",dw-1);

            continue;
        }

        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveOutOpen(
            &hWaveOut,
            gti.uOutputDevice,
            (HACK)pwfx,
            0L,
            0L,
            dwSync|OUTPUT_MAP(gti));

        mmrQuery = waveOutOpen(
            NULL,
            gti.uOutputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|dwSync|OUTPUT_MAP(gti));

        //
        //  Checking _REAL_ open...
        //

        if(MMSYSERR_NOERROR == mmr)
        {
            //
            //  No Error...  We should close the device...
            //

            waveOutClose(hWaveOut);

            tstLog(VERBOSE,"  Format [%s] supported on open.",(LPSTR)szFormat);
        }
        else
        {
            tstLog(
                VERBOSE,
                "  Format [%s] not supported on open.",
                (LPSTR)szFormat);
        }

        //
        //  Checking query open...
        //

        if(MMSYSERR_NOERROR == mmrQuery)
        {
            tstLog(
                VERBOSE,
                "  Format [%s] supported on query open.",
                (LPSTR)szFormat);
        }
        else
        {
            tstLog(
                VERBOSE,
                "  Format [%s] not supported on query open.",
                (LPSTR)szFormat);
        }

        //
        //  Checking consistency...
        //

        if(mmr != mmrQuery)
        {
            tstLog(TERSE,"    FAIL: Open inconsistent w/ query open.");

            tstLog(
                TERSE,
                "    Errors: %s (for open) and %s (for query open).",
                GetErrorText(mmr),
                GetErrorText(mmrQuery));

            iResult = TST_FAIL;
        }
        else
        {
            tstLog(VERBOSE,"    PASS: Open consistent w/ query open.");
        }

        //
        //  Does user want to abort?
        //

        TestYield();

        if(tstCheckRunStop(VK_ESCAPE))
        {
            //
            //  Aborted!!!  Cleaning up...
            //

            tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
            tstLogFlush();

            ExactHeapDestroy(hHeap);

            return (TST_FAIL);
        }

        tstLogFlush();
    }

    //
    //  Third, verify MMSYSERR_ALLOCATED is (eventually) returned.
    //

    Log_TestCase("~Verifying MMSYSERR_ALLOCATED is (eventually) returned");

    dw = 0;

    mmr = AllocateOutDevice(gti.uOutputDevice,gti.pwfxOutput,&dw);

    DPF(3,"Number of waveOutOpen's: %lu",dw);

    if((MMSYSERR_NOMEM == mmr) && (dw >= 10))
    {
        tstLog(TERSE,"Device ran out of memory w/ too many opens.");
    }
    else
    {
        if(MMSYSERR_ALLOCATED != mmr)
        {
            LogFail("Device doesn't return MMSYSERR_ALLOCATED w/ multiple "
                "opens");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Device returns MMSYSERR_ALLOCATED w/ multiple opens");
        }
    }

    pwi = ExactHeapAllocPtr(hHeap,GMEM_SHARE|GMEM_FIXED,sizeof(WAVEINFO));

    if(NULL == pwi)
    {
        DPF(1,"Could not allocate memory for pwi");

        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Note: passing current time as dwInstance... unique for every
    //  execution.
    //

    dw  = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|dwSync|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR == mmr)
    {
        //
        //  Fourth, verify driver posts a WOM_OPEN message.
        //

        Log_TestCase("~Verifying WOM_OPEN message was received");

        if(WOM_OPEN_FLAG & (pwi->fdwFlags))
        {
            LogPass("Callback received a WOM_OPEN message");
        }
        else
        {
            LogFail("WOM_OPEN message not received by callback");

            iResult = TST_FAIL;
        }

        //
        //  Fifth, verify dwCallbackInstance is passed back.
        //

        Log_TestCase("~Verifying dwInstance is consistent");

        if(dw == pwi->dwInstance)
        {
            LogPass("Callback function got correct dwInstance");
        }
        else
        {
            LogFail("Callback function got incorrect dwInstance");

            iResult = TST_FAIL;
        }

        call_waveOutClose(hWaveOut);
    }
    else
    {
        LogFail("waveOutOpen w/ CALLBACK_FUNCTION failed");

        iResult = TST_FAIL;
    }

    DLL_WaveControl(DLL_END,NULL);

    PageUnlock(pwi);

    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveOutOpen()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutClose
//
//  Description:
//      Tests the driver functionality for waveOutClose.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutClose
(
    void
)
{
    HWAVEOUT            hWaveOut;
    WAVEOUTCAPS         woc;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pWaveHdr;
    LPWAVEINFO          pwi;
    DWORD               dw;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutClose";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    pWaveHdr = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        return TST_FAIL;
    }

    //
    //  First, verify close before playing (w/out buffers) works.
    //

    Log_TestCase("~Verifying close before playing (w/out buffers) works");

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    mmr = call_waveOutClose(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Device failed the close");

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device closed");
    }

    //
    //  Second, verify close after playing works.
    //

    Log_TestCase("~Verifying close after playing works");

    pwi = ExactAllocPtr(GMEM_SHARE|GMEM_FIXED,sizeof(WAVEINFO));

    if(NULL == pwi)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    dw = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);

        ExactFreePtr(pwi);
        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }

    pWaveHdr->lpData            = gti.wrLong.pData;
    pWaveHdr->dwBufferLength    = gti.wrLong.cbSize;
    pWaveHdr->dwBytesRecorded   = 0L;
    pWaveHdr->dwUser            = 0L;
    pWaveHdr->dwFlags           = 0L;
    pWaveHdr->dwLoops           = 0L;
    pWaveHdr->lpNext            = NULL;
    pWaveHdr->reserved          = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutClose(hWaveOut);

        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);

        ExactFreePtr(pwi);
        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }

    call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    //
    //  Spinning on WHDR_DONE bit...
    //

    while(!(pWaveHdr->dwFlags & WHDR_DONE));

    call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;

    mmr = call_waveOutClose(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutClose after playing failed");

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveOutClose successful after playing");
    }

    //
    //  Third, verify driver does a WOM_CLOSE callback.
    //

    Log_TestCase("~Verifying driver does a WOM_CLOSE callback");

    if(pwi->fdwFlags & WOM_CLOSE_FLAG)
    {
        LogPass("Driver does WOM_CLOSE callback");
    }
    else
    {
        LogFail("Driver does not do WOM_CLOSE callback");

        iResult = TST_FAIL;
    }

    //
    //  Fourth, verify dwCallbackInstance is passed back.
    //

    Log_TestCase("~Verifying dwCallbackInstance is passed back");

    if(dw == pwi->dwInstance)
    {
        LogPass("Correct dwInstance on callback");
    }
    else
    {
        LogFail("Incorrect dwInstance on callback");

        iResult = TST_FAIL;
    }

    DLL_WaveControl(DLL_END,NULL);

    PageUnlock(pwi);

    ExactFreePtr(pwi);

    //
    //  Fifth, verify close w/ prepared header fails.
    //

//    Log_TestCase("~Verifying close with prepared header fails");
//
//    mmr = call_waveOutOpen(
//        &hWaveOut,
//        gti.uOutputDevice,
//        gti.pwfxOutput,
//        0L,
//        0L,
//        OUTPUT_MAP(gti));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailOpen);
//
//        ExactFreePtr(pWaveHdr);
//        return TST_FAIL;
//    }
//
//    pWaveHdr->dwBytesRecorded   = 0L;
//    pWaveHdr->dwUser            = 0L;
//    pWaveHdr->dwFlags           = 0L;
//    pWaveHdr->dwLoops           = 0L;
//
//    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
//
//    mmr = call_waveOutClose(hWaveOut);
//
//    if(WAVERR_STILLPLAYING != mmr)
//    {
//        LogFail("Close did not fail w/ prepared header");
//
//        iResult = TST_FAIL;
//    }
//    else
//    {
//        LogPass("Close failed w/ prepared header");
//
//        call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
//        call_waveOutClose(hWaveOut);
//    }
//
//    //
//    //  Only asynchronous drivers from now on...
//    //
//
//    if(woc.dwSupport & WAVECAPS_SYNC)
//    {
//        ExactFreePtr(pWaveHdr);
//
//        return (iResult);
//    }

    //
    //  Sixth, verify close paused device (w/out buffers) works.
    //

    Log_TestCase("~Verifying close paused device (w/out buffers) works");

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    //
    //  Note: Only possible error for waveOutPause is MMSYSERR_INVALHANDLE.
    //        Not possible here...
    //

    call_waveOutPause(hWaveOut);

    mmr = call_waveOutClose(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Device failed the close");

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device closed");
    }

    //
    //  Seventh, verify close paused device (w/ buffers) fails.
    //

    Log_TestCase("~Verifying close paused device (w/ buffers) fails");

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    pWaveHdr->dwBytesRecorded   = 0L;
    pWaveHdr->dwUser            = 0L;
    pWaveHdr->dwFlags           = WHDR_BEGINLOOP|WHDR_ENDLOOP;
    pWaveHdr->dwLoops           = ((DWORD)(-1));

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }

    //
    //  Note: The following API's can only fail w/ invalid parameters
    //        or conditions.
    //

    call_waveOutPause(hWaveOut);
    call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    
    mmr = call_waveOutClose(hWaveOut);

    if(WAVERR_STILLPLAYING != mmr)
    {
        LogFail("Close did not fail w/ WAVERR_STILLPLAYING");

        iResult = TST_FAIL;

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);
        }
    }
    else
    {
        LogPass("Close failed w/ WAVERR_STILLPLAYING");

        call_waveOutReset(hWaveOut);
        call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);
    }

    //
    //  Eighth, verify close while playing fails.
    //

    Log_TestCase("Verifying close while playing fails");

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    pWaveHdr->dwBytesRecorded   = 0L;
    pWaveHdr->dwUser            = 0L;
    pWaveHdr->dwFlags           = WHDR_BEGINLOOP|WHDR_ENDLOOP;
    pWaveHdr->dwLoops           = ((DWORD)(-1));

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    //
    //  Note: The following API's can only fail w/ invalid parameters
    //        or conditions.
    //

    call_waveOutPause(hWaveOut);
    call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    call_waveOutRestart(hWaveOut);
    
    mmr = call_waveOutClose(hWaveOut);

    if(WAVERR_STILLPLAYING != mmr)
    {
        iResult = TST_FAIL;

        if(MMSYSERR_NOERROR == mmr)
        {
            if(pWaveHdr->dwFlags & WHDR_DONE)
            {
                LogFail("WHDR_DONE bit set. Test inconclusive");
            }
            else
            {
                LogFail("waveOutClose succeeds while WHDR_DONE bit clear");
            }
        }
        else
        {
            LogFail("Close did not fail w/ WAVERR_STILLPLAYING");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);
        }
    }
    else
    {
        LogPass("Close failed w/ WAVERR_STILLPLAYING");

        call_waveOutReset(hWaveOut);
        call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);
    }

    ExactFreePtr(pWaveHdr);

    return (iResult);
} // Test_waveOutClose()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutGetPosition
//
//  Description:
//      Tests the driver functionality for waveOutGetPosition.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutGetPosition
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    DWORD               dw;
    UINT                u;
    HANDLE              hHeap;
    MMTIME              mmt;
    DWORD               dwTime,dwTimebase;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutGetPosition";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Opening device...
    //

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        //
        //  Verify waveOutGetPosition is zero when first opened.
        //

        Log_TestCase("~Verifying waveOutGetPosition is zero when first opened");

        mmr = call_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPosition failed");

            call_waveOutReset(hWaveOut);
            call_waveOutClose(hWaveOut);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(u != mmt.wType)
        {
            tstLog(
                VERBOSE,
                "Note: Time type [%s] is not supported.",
                GetTimeTypeText(u));
        }

        Log_MMTIME(&mmt);

        dw = GetMSFromMMTIME(gti.pwfxOutput,&mmt);

        if(0 != dw)
        {
            LogFail("Time is not zero after open");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Time is zero after open");
        }
    }

    //
    //  Preparing header...
    //

    pwh->lpData             = gti.wrLong.pData;
    pwh->dwBufferLength     = gti.wrLong.cbSize;
    pwh->dwBytesRecorded    = 0L;
    pwh->dwUser             = 0L;
    pwh->dwFlags            = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Defaults to 1/60th of a second.
    //

//    dwError = 1000 / 60;
//
//    dwError = GetIniDWORD(szTestName,gszDelta,dwError);
//
//    Log_TestCase("~Verifying waveOutGetPosition is accurate");
//
    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        mmr = waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPosition failed");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(mmt.wType != u)
        {
            continue;
        }

        pwh->dwFlags &= ~(WHDR_DONE);

        call_waveOutPause(hWaveOut);
        call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));
        
        call_waveOutRestart(hWaveOut);

        while(!(pwh->dwFlags & WHDR_DONE));

//        {
//            mmr = time_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME),&dwTime);
//
//            dwTime = dwTime - dwTimebase;
//
//            if(MMSYSERR_NOERROR != mmr)
//            {
//                LogFail("waveOutGetPosition failed");
//
//                call_waveOutReset(hWaveOut);
//                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
//                call_waveOutClose(hWaveOut);
//
//                ExactHeapDestroy(hHeap);
//                return TST_FAIL;
//            }
//
//            dwActual = GetMSFromMMTIME(gti.pwfxOutput,&mmt);
//            dw       = dwActual;
//
//            DPF(1,"GetPos: %lu GetTime: %lu.",dw,dwTime);
//
//            dw = ((dwTime > dw)?(dwTime - dw):(dw - dwTime));
//
//            if(dwError < dw)
//            {
//                LogFail("waveOutGetPosition is drifting");
//                tstLog(
//                    TERSE,
//                    "     Expected time: %lu ms\n"
//                    "     Actual time: %lu ms",
//                    dwTime,
//                    dwActual);
//
//                iResult = TST_FAIL;
//            }
//            else
//            {
//                LogPass("waveOutGetPosition is accurate");
//            }
//        }

        //
        //  Verify position is non-zero after playing (w/out waveOutReset)
        //

        Log_TestCase("~Verifying waveOutGetPosition is not zero after playing");

        mmr = call_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPosition failed");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        dw = GetMSFromMMTIME(gti.pwfxOutput,&mmt);

        if(0 == dw)
        {
            LogFail("Position is zero after playing");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Position is non-zero after playing");
        }

        call_waveOutReset(hWaveOut);

        //
        //  Verify waveOutGetPosition resets after waveOutReset.
        //

        Log_TestCase("~Verifying waveOutGetPosition is zero after reset");

        mmr = call_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPosition failed");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        dw = GetMSFromMMTIME(gti.pwfxOutput,&mmt);

        if(0 == dw)
        {
            LogPass("Position is zero after reset");
        }
        else
        {
            LogFail("Position is non-zero after playing");

            iResult = TST_FAIL;
        }
    }

    call_waveOutReset(hWaveOut);

    //
    //  Verify waveOutGetPosition is not going backwards.
    //

    Log_TestCase("~Verifying waveOutGetPosition is not going backwards");

    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        pwh->dwFlags &= (~WHDR_DONE);

        call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

        tstLog(VERBOSE,"Note: Time type is [%s].",GetTimeTypeText(u));

        dwTimebase = 0;
        dw         = 0;

        while(!(pwh->dwFlags & WHDR_DONE))
        {
            mmr = waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

            if(MMSYSERR_NOERROR != mmr)
            {
                LogFail("waveOutGetPosition returned error");

                iResult = TST_FAIL;

                break;
            }

            if(u != mmt.wType)
            {
                //
                //  This time type is not supported by hardware.
                //

                dw = 2;

                break;
            }

            dwTime = GetValueFromMMTIME(&mmt);

            if(dwTime < dwTimebase)
            {
                tstLog(TERSE,
                    "    FAIL: waveOutGetPosition went from %lu to %lu.",
                    dwTimebase,
                    dwTime);

                iResult = TST_FAIL;
                dw      = 1;
            }

            dwTimebase = dwTime;
        }

        call_waveOutReset(hWaveOut);

        if(0 == dw)
        {
            LogPass("Position did not go backwards");
        }
    }

    //
    //  Verify waveOutGetPosition reaches the end of buffer.
    //

    Log_TestCase("~Verifying waveOutGetPosition reaches the end of buffer");

    pwh->dwFlags &= (~WHDR_DONE);
    
    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    //
    //  Polling waiting for tests to get finished.
    //

    while(!(pwh->dwFlags & WHDR_DONE));

    dwTimebase = pwh->dwBufferLength * 1000 / gti.pwfxOutput->nAvgBytesPerSec;

    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        mmr = call_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPosition returns error");

            break;
        }

        if(TIME_BYTES == mmt.wType)
        {
            if(mmt.u.cb != pwh->dwBufferLength)
            {
                tstLog(
                    TERSE,
                    "    FAIL:Buffer length is %lu bytes; position "
                        "is %lu bytes.",
                    pwh->dwBufferLength,
                    mmt.u.cb);

                iResult = TST_FAIL;
            }
            else
            {
                tstLog(
                    VERBOSE,
                    "    PASS:Both buffer length and position are %lu bytes.",
                    pwh->dwBufferLength);
            }
        }
        else
        {
            dw = GetMSFromMMTIME(gti.pwfxOutput,&mmt);

            if(dwTimebase != dw)
            {
                tstLog(
                    TERSE,
                    "    FAIL:Buffer length is %lu ms; position is %lu ms.",
                    dwTimebase,
                    dw);

                iResult = TST_FAIL;
            }
            else
            {
                tstLog(
                    VERBOSE,
                    "    PASS:Both buffer length and position are %lu ms.",
                    dw);
            }
        }
    }

//    dwTime = waveGetTime() + 100;
//
//    while(dwTime > waveGetTime());
//
//    mmt.wType = TIME_BYTES;
//
//    call_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

    //
    //  Verify waveOutGetPosition is not "snapped" to DMA buffer size.
    //

#pragma message(REMIND("DMA buffer size thingy"))
    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        //
        //  Verify waveOutGetPosition accuracy
        //
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveOutGetPosition()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutPrepareHeader
//
//  Description:
//      Tests the driver functionality for waveOutPrepareHeader.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutPrepareHeader
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pWaveHdr;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutPrepareHeader";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    pWaveHdr = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    //
    //  First, verify prepare works...
    //

    Log_TestCase("~Verifying prepare after open works");

    _fmemset(pWaveHdr,0,sizeof(WAVEHDR));

    pWaveHdr->lpData            = gti.wrMedium.pData;
    pWaveHdr->dwBufferLength    = gti.wrMedium.cbSize;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }
    else
    {
        LogPass("waveOutPrepareHeader succeeds");
    }

    //
    //  Second, verify WHDR_PREPARED bit is set.
    //

    Log_TestCase("~Verifying WHDR_PREPARED bit is set in WAVEHDR.dwFlags");

    if(pWaveHdr->dwFlags & WHDR_PREPARED)
    {
        LogPass("waveOutPrepareHeader sets the WHDR_PREPARED bit");
    }
    else
    {
        LogFail("waveOutPrepareHeader does not set WHDR_PREPARED bit");

        iResult = TST_FAIL;
    }

    //
    //  Third, verify preparing twice succeeds.
    //

    Log_TestCase("~Verifying preparing twice succeeds");

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveOutPrepareHeader succeed");
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    ExactFreePtr(pWaveHdr);

    return (iResult);
} // Test_waveOutPrepareHeader()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutUnprepareHeader
//
//  Description:
//      Tests the driver functionality for waveOutUnprepareHeader.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutUnprepareHeader
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pWaveHdr;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutUnprepareHeader";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    pWaveHdr = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    //
    //  First, verify unprepare works...
    //

    Log_TestCase("~Verifying unprepare after prepare works");

    _fmemset(pWaveHdr,0,sizeof(WAVEHDR));

    pWaveHdr->lpData            = gti.wrLong.pData;
    pWaveHdr->dwBufferLength    = gti.wrLong.cbSize;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        ExactFreePtr(pWaveHdr);
        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    if(!(WHDR_PREPARED & pWaveHdr->dwFlags))
    {
        LogFail("waveOutPrepareHeader did not set WHDR_PREPARED bit");

        ExactFreePtr(pWaveHdr);
        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    mmr = call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutUnprepareHeader failed");

        ExactFreePtr(pWaveHdr);
        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }
    else
    {
        LogPass("waveOutUnprepareHeader succeeds");
    }

    //
    //  Second, verify WHDR_PREPARED bit is cleared.
    //

    Log_TestCase("~Verifying WHDR_PREPARED bit is cleared in WAVEHDR.dwFlags");

    if(WHDR_PREPARED & pWaveHdr->dwFlags)
    {
        LogFail("waveOutUnprepareHeader did not clear WHDR_PREPARED bit");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveOutUnprepareHeader cleared WHDR_PREPARED bit");
    }

    //
    //  Third, verify unpreparing twice succeeds.
    //

    Log_TestCase("~Verify unpreparing header twice succeeds");

    mmr = call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutUnprepareHeader twice failed");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveOutUnprepareHeader twice succeeds");
    }

    //
    //  Fourth, verify unpreparing queued buffer fails.
    //

    Log_TestCase("~Verify unpreparing queued buffer fails");

    _fmemset(pWaveHdr,0,sizeof(WAVEHDR));

    pWaveHdr->lpData            = gti.wrLong.pData;
    pWaveHdr->dwBufferLength    = gti.wrLong.cbSize;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutPrepareHeader failed");

        ExactFreePtr(pWaveHdr);
        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    pWaveHdr->dwFlags |= (WHDR_BEGINLOOP|WHDR_ENDLOOP);
    pWaveHdr->dwLoops = (DWORD)(-1);

    call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    mmr = call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(pWaveHdr->dwFlags & WHDR_INQUEUE)
    {
        if(WAVERR_STILLPLAYING == mmr)
        {
            LogPass("waveOutUnpreparedHeader failed while playing");
        }
        else
        {
            LogFail("waveOutPrepareHeader succeeds while playing");

            iResult = TST_FAIL;
        }
    }
    else
    {
        LogFail("Test inconclusive");

        iResult = TST_FAIL;
    }

    //
    //  Fifth, verify unpreparing after playback succeeds.
    //

    call_waveOutReset(hWaveOut);
    
    mmr = call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutUnprepareHeader after playing fails");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveOutUnprepareHeader after playing succeeds");
    }

    call_waveOutClose(hWaveOut);

    ExactFreePtr(pWaveHdr);

    return (iResult);
} // Test_waveOutUnprepareHeader()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutBreakLoop
//
//  Description:
//      Tests the driver functionality for waveOutBreakLoop.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutBreakLoop
(
    void
)
{
    HWAVEOUT            hwo;
    MMRESULT            mmr;
    HANDLE              hHeap;
    WAVEOUTCAPS         woc;
    MMTIME              mmt;
    DWORD               cbTotal, cbActual, cbTarget;
    volatile LPWAVEHDR  pwh[5];
    DWORD               dw;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutBreakLoop";

    //
    //  Are there any output devices?
    //

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Is device synchronous?
    //

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_SYNC)
    {
        LogPass("Device is synchronous.  Test not applicable");

        return TST_PASS;
    }

    //
    //  Allocating memory.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for each header...
    //

    for(dw = 5; dw; dw--)
    {
        pwh[dw - 1] = ExactHeapAllocPtr(
                        hHeap,
                        GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR));

        if(NULL == pwh[dw - 1])
        {
            LogFail(gszFailNoMem);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    //
    //  Opening device...
    //

    mmr = call_waveOutOpen(
        &hwo,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(dw = 5; dw; dw--)
    {
        if(0 == (dw % 2))
        {
            //
            //  Odd headers are from Short resource...
            //

            pwh[dw - 1]->lpData          = gti.wrShort.pData;
            pwh[dw - 1]->dwBufferLength  = gti.wrShort.cbSize;
        }
        else
        {
            //
            //  Even headers are from Medium resource...
            //

            pwh[dw - 1]->lpData          = gti.wrMedium.pData;
            pwh[dw - 1]->dwBufferLength  = gti.wrMedium.cbSize;
        }

        pwh[dw - 1]->dwBytesRecorded = 0L;
        pwh[dw - 1]->dwUser          = 0L;
        pwh[dw - 1]->dwFlags         = 0L;
    }

    for(dw = 5; dw; dw--)
    {
        mmr = call_waveOutPrepareHeader(hwo,pwh[dw - 1],sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail(gszFailWOPrepare);

            call_waveOutReset(hwo);
            call_waveOutClose(hwo);

            ExactHeapDestroy(hwo);
            return TST_FAIL;
        }
    }

    //
    //  Verify playing buffers adds up to the expected number of bytes.
    //

    Log_TestCase("Verifying playing buffers adds up to the expected number "
        "of bytes");

    CLEAR_FLAG(pwh[0]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[1]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[2]->dwFlags,WHDR_DONE);

    call_waveOutReset(hwo);

    for(cbTotal = 0, dw = 3; dw; dw--)
    {
        cbTotal += pwh[dw - 1]->dwBufferLength;
    }

    call_waveOutWrite(hwo,pwh[0],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[1],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[2],sizeof(WAVEHDR));

    tstLog(VERBOSE,"\n<< Polling WHDR_DONE bit in header. >>");

    while(!(((volatile LPWAVEHDR)pwh[2])->dwFlags & WHDR_DONE));

    mmt.wType = TIME_BYTES;
    call_waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

    cbActual = mmt.u.cb;

    tstLog(VERBOSE,"\n  Expected length: %lu.",cbTotal);
    tstLog(VERBOSE,"    Actual length: %lu.",cbActual);

    if(cbTotal != cbActual)
    {
        iResult = TST_FAIL;

        if(TIME_BYTES == mmt.wType)
        {
            LogFail("Position is not full length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");
        }
    }
    else
    {
        if(TIME_BYTES == mmt.wType)
        {
            LogPass("Position is same as length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");

            iResult = TST_FAIL;
        }
    }

    //
    //  Verify waveOutBreak loop does nothing if no loops in stream.
    //

    Log_TestCase("Verifying waveOutBreak loop does nothing if"
        " no loops in stream");

    CLEAR_FLAG(pwh[0]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[1]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[2]->dwFlags,WHDR_DONE);

    call_waveOutReset(hwo);

    for(cbTotal = 0, dw = 3; dw; dw--)
    {
        cbTotal += pwh[dw - 1]->dwBufferLength;
    }

    call_waveOutWrite(hwo,pwh[0],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[1],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[2],sizeof(WAVEHDR));

    call_waveOutBreakLoop(hwo);

    tstLog(VERBOSE,"\n<< Polling WHDR_DONE bit in header. >>");

    while(!(pwh[2]->dwFlags & WHDR_DONE));

    mmt.wType = TIME_BYTES;
    call_waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

    cbActual = mmt.u.cb;

    tstLog(VERBOSE,"\n  Expected length: %lu.",cbTotal);
    tstLog(VERBOSE,"    Actual length: %lu.",cbActual);

    if(cbTotal != cbActual)
    {
        iResult = TST_FAIL;

        if(TIME_BYTES == mmt.wType)
        {
            LogFail("Position is not full length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");
        }
    }
    else
    {
        if(TIME_BYTES == mmt.wType)
        {
            LogPass("Position is same as length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");

            iResult = TST_FAIL;
        }
    }

    //
    //  Verify playing loops works.
    //

    Log_TestCase("Verifying playing loops works");

    CLEAR_FLAG(pwh[0]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[1]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[2]->dwFlags,WHDR_DONE);

    CLEAR_FLAG(pwh[0]->dwFlags,(WHDR_BEGINLOOP|WHDR_ENDLOOP));
    CLEAR_FLAG(pwh[1]->dwFlags,(WHDR_BEGINLOOP|WHDR_ENDLOOP));

    SET_FLAG(pwh[2]->dwFlags,(WHDR_BEGINLOOP|WHDR_ENDLOOP));

    pwh[2]->dwLoops = 4;

    cbTotal  = pwh[0]->dwBufferLength +
               (pwh[2]->dwLoops) * (pwh[2]->dwBufferLength) +
               pwh[1]->dwBufferLength;

    call_waveOutReset(hwo);

    //
    //  Note: Order of waveOutWrite's...
    //

    call_waveOutPause(hwo);
    call_waveOutWrite(hwo,pwh[0],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[2],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[1],sizeof(WAVEHDR));
    call_waveOutRestart(hwo);

    mmt.wType = TIME_BYTES;
    mmt.u.cb  = 0;

    tstLog(VERBOSE,"\n<< Polling WHDR_DONE bit in header. >>");

    while(!(pwh[1]->dwFlags & WHDR_DONE));

    mmt.wType = TIME_BYTES;
    call_waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

    cbActual = mmt.u.cb;

    tstLog(VERBOSE,"\n  Expected length: %lu.",cbTotal);
    tstLog(VERBOSE,"    Actual length: %lu.",cbActual);

    if(cbTotal != cbActual)
    {
        iResult = TST_FAIL;

        if(TIME_BYTES == mmt.wType)
        {
            LogFail("Position is not full length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");
        }
    }
    else
    {
        if(TIME_BYTES == mmt.wType)
        {
            LogPass("Position is same as length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");

            iResult = TST_FAIL;
        }
    }

    //
    //  Verify breaking after one loop works.
    //

    Log_TestCase("Verify breaking after one loop works");

    CLEAR_FLAG(pwh[0]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[1]->dwFlags,WHDR_DONE);
    CLEAR_FLAG(pwh[2]->dwFlags,WHDR_DONE);

    CLEAR_FLAG(pwh[0]->dwFlags,(WHDR_BEGINLOOP|WHDR_ENDLOOP));
    CLEAR_FLAG(pwh[1]->dwFlags,(WHDR_BEGINLOOP|WHDR_ENDLOOP));

    SET_FLAG(pwh[2]->dwFlags,(WHDR_BEGINLOOP|WHDR_ENDLOOP));

    pwh[2]->dwLoops = 4;

    //
    //  Doing BreakLoop after first loop... Calculating that position...
    //  Playing: 0, 2 (looped), 1
    //

    cbTarget = pwh[0]->dwBufferLength + pwh[2]->dwBufferLength;

    tstLog(TERSE,"cbTarget: %lu",cbTarget);

    cbTotal  = pwh[0]->dwBufferLength +
               2 * (pwh[2]->dwBufferLength) +
               pwh[1]->dwBufferLength;

    call_waveOutReset(hwo);

    //
    //  Note: Order of waveOutWrite's...
    //

    call_waveOutPause(hwo);
    call_waveOutWrite(hwo,pwh[0],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[2],sizeof(WAVEHDR));
    call_waveOutWrite(hwo,pwh[1],sizeof(WAVEHDR));
    call_waveOutRestart(hwo);

    mmt.wType = TIME_BYTES;
    mmt.u.cb  = 0;

    while(mmt.u.cb < cbTarget)
    {
        waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));
    }

    call_waveOutBreakLoop(hwo);

    tstLog(VERBOSE,"\n<< Polling WHDR_DONE bit in header. >>");

    while(!(pwh[1]->dwFlags & WHDR_DONE));

    mmt.wType = TIME_BYTES;
    call_waveOutGetPosition(hwo,&mmt,sizeof(MMTIME));

    cbActual = mmt.u.cb;

    tstLog(VERBOSE,"\n  Expected length: %lu.",cbTotal);
    tstLog(VERBOSE,"    Actual length: %lu.",cbActual);

    if(cbTotal != cbActual)
    {
        iResult = TST_FAIL;

        if(TIME_BYTES == mmt.wType)
        {
            LogFail("Position is not full length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");
        }
    }
    else
    {
        if(TIME_BYTES == mmt.wType)
        {
            LogPass("Position is same as length of stream");
        }
        else
        {
            LogFail("MMTIME type changed.  Test inconclusive");

            iResult = TST_FAIL;
        }
    }























    //
    //  Clean-Up...
    //

    call_waveOutReset(hwo);

    for(dw = 5; dw; dw--)
    {
        call_waveOutUnprepareHeader(hwo,pwh[dw - 1],sizeof(WAVEHDR));
    }

    call_waveOutClose(hwo);

    ExactHeapDestroy(hHeap);

    return (iResult);

} // Test_waveOutBreakLoop()


//--------------------------------------------------------------------------;
//
//  BOOL IsPaused
//
//  Description:
//      Determines whether the device is playing.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Handle to the open instance.
//
//  Return (BOOL):
//      TRUE if paused, FALSE otherwise.
//
//  History:
//      11/15/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

BOOL IsPaused
(
    HWAVEOUT    hWaveOut
)
{
    MMTIME      mmt;
    MMRESULT    mmr;
    DWORD       dwTime;
    DWORD       dw;

    mmt.wType = TIME_BYTES;

    mmr = waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

    if(MMSYSERR_NOERROR != mmr)
    {
        return FALSE;
    }

    dwTime = mmt.u.cb;

    dw = waveGetTime() + gti.cMinStopThreshold;

    //
    //  Waiting for threshold number of milliseconds.
    //

//    while(20 < (waveGetTime() - dw));
    while(dw > (waveGetTime()));

    mmt.wType = TIME_BYTES;

    mmr = waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

    if(MMSYSERR_NOERROR != mmr)
    {
        return FALSE;
    }

    dw = mmt.u.cb;

    DPF(3,"IsPaused: dw = %lu, dwTime = %lu",dw,dwTime);

    return ((dw == dwTime)?TRUE:FALSE);
} // IsPaused()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutPause
//
//  Description:
//      Tests the driver functionality for waveOutPause.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutPause
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    HANDLE              hHeap;
    WAVEOUTCAPS         woc;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutPause";

    //
    //  Are there any output devices?
    //

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Is device synchronous?
    //

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_SYNC)
    {
        LogPass("Device is synchronous.  Test not applicable");

        return TST_PASS;
    }

    //
    //  Allocating memory.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    pwh->lpData             = gti.wrLong.pData;
    pwh->dwBufferLength     = gti.wrLong.cbSize;
    pwh->dwBytesRecorded    = 0L;
    pwh->dwUser             = 0L;
    pwh->dwFlags            = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    //
    //  Verify driver is not paused by default.
    //

    Log_TestCase("Verifying driver is not paused by default");

    if(IsPaused(hWaveOut))
    {
        LogFail("Device is paused immediately after open");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device is not paused after open");
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    pwh->dwFlags = 0L;

    //
    //  Verify pausing before waveOutPrepareHeader buffer works.
    //

    Log_TestCase("Verifying pausing before waveOutPrepareHeader buffer works");

    mmr = call_waveOutPause(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutClose(hWaveOut);
        
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        LogPass("Device is paused");
    }
    else
    {
        LogFail("Device is not paused");

        iResult = TST_FAIL;
    }

    call_waveOutRestart(hWaveOut);
    call_waveOutReset(hWaveOut);

    pwh->dwFlags &= (~WHDR_DONE);

    //
    //  Verify pausing before waveOutWrite works.
    //

    Log_TestCase("Verifying pausing before waveOutWrite works");

    mmr = call_waveOutPause(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        LogPass("Device is paused");
    }
    else
    {
        LogFail("Device is not paused");

        iResult = TST_FAIL;
    }

    //
    //  Verify driver is not paused after waveOutReset.
    //

    call_waveOutReset(hWaveOut);

    pwh->dwFlags &= (~WHDR_DONE);

    Log_TestCase("Verifying driver is not paused after waveOutReset");

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        LogFail("Device is paused after waveOutReset");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device is not paused after waveOutReset");
    }

    //
    //  Verify pausing while playing works.
    //

    Log_TestCase("Verifying pausing while playing works");

    call_waveOutPause(hWaveOut);

    if(pwh->dwFlags & WHDR_DONE)
    {
        LogFail("Test inconclusive buffer is already done playing");

        iResult = TST_FAIL;
    }
    else
    {
        if(IsPaused(hWaveOut))
        {
            LogPass("Device is paused");
        }
        else
        {
            LogFail("Device is not paused");

            iResult = TST_FAIL;
        }
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveOutPause()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutRestart
//
//  Description:
//      Tests the driver functionality for waveOutRestart.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutRestart
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    HANDLE              hHeap;
    WAVEOUTCAPS         woc;
    MMTIME              mmt;
    DWORD               dwTime,dwError;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutRestart";

    //
    //  Are there any output devices?
    //

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Is device synchronous?
    //

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_SYNC)
    {
        LogPass("Device is synchronous.  Test not applicable");

        return TST_PASS;
    }

    //
    //  Allocating memory.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }
              
    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh->lpData             = gti.wrLong.pData;
    pwh->dwBufferLength     = gti.wrLong.cbSize;
    pwh->dwBytesRecorded    = 0L;
    pwh->dwUser             = 0L;
    pwh->dwFlags            = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Verify waveOutRestart has no effect when not paused.
    //

    Log_TestCase("Verifying waveOutRestart has no effect when not paused");

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        LogFail("Device is paused immediately after open");

        iResult = TST_FAIL;
    }
    else
    {
        mmr = call_waveOutRestart(hWaveOut);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutRestart returned error");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactHeapDestroy(hHeap);

            return TST_FAIL;
        }

        if(IsPaused(hWaveOut))
        {
            LogFail("Device is paused");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Device is not paused");
        }
    }

    //
    //  Verify waveOutRestart before waveOutPrepareHeader works.
    //

    Log_TestCase("Verifying waveOutRestart before waveOutPrepareHeader works");

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    mmr = call_waveOutPause(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutPause failed");

        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveOutRestart(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutRestart failed");

        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        LogFail("Device is paused after waveOutRestart");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device is not paused after waveOutRestart");
    }

    //
    //  Verify waveOutRestart before waveOutWrite works.
    //

    Log_TestCase("Verifying waveOutRestart before waveOutWrite works");

    call_waveOutReset(hWaveOut);

    mmr = call_waveOutPause(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutPause failed");

        call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveOutRestart(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutRestart failed");

        call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        LogFail("Device is paused after waveOutRestart");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device is not paused after waveOutRestart");
    }

    //
    //  Verify waveOutGetPosition starts reasonably after waveOutRestart.
    //

    Log_TestCase("Verifying waveOutGetPosition starts reasonably "
        "after waveOutRestart");

    dwError = GetIniDWORD(szTestName,gszError,30);

    call_waveOutReset(hWaveOut);

    mmr = call_waveOutPause(hWaveOut);

    mmt.wType = TIME_BYTES;

    pwh->dwFlags &= (~WHDR_DONE);

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    mmr = waveOutRestart(hWaveOut);

    dwTime = waveGetTime();

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutRestart failed");

        call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(;;)
    {
        waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(0 != mmt.u.cb)
        {
            dwTime = waveGetTime() - dwTime;

            break;
        }
    }

    tstLog(VERBOSE,"Lag time: %lu ms.",dwTime);

    if(dwTime > dwError)
    {
        LogFail("waveOutGetPosition did not start soon after waveOutRestart");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveOutGetPosition started soon after waveOutRestart");
    }

    call_waveOutReset(hWaveOut);
    pwh->dwFlags &= (~WHDR_DONE);

    //
    //  Verify restarting while paused works.
    //

    Log_TestCase("Verifying restaring while paused works");

    call_waveOutReset(hWaveOut);

    mmr = call_waveOutPause(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveOutPause failed");

        call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        mmr = call_waveOutRestart(hWaveOut);

        if(IsPaused(hWaveOut))
        {
            LogFail("waveOutRestart did not restart device");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("waveOutRestart restarted device");
        }
    }
    else
    {
        LogFail("waveOutPause did not pause device");

        iResult = TST_FAIL;
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveOutRestart()


//--------------------------------------------------------------------------;
//
//  DWORD GetMSPos
//
//  Description:
//      Gets the current time in milliseconds.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Handle to wave open instance.
//
//      LPWAVEFORMATEX pwfx: Pointer to format structure.
//
//  Return (DWORD):
//      Current position in milliseconds.
//
//  History:
//      12/13/94    Fwong       Added for waveOutReset Test Case.
//
//--------------------------------------------------------------------------;

DWORD GetMSPos
(
    HWAVEOUT        hWaveOut,
    LPWAVEFORMATEX  pwfx
)
{
    MMTIME      mmt;
    DWORD       dwTime;
    MMRESULT    mmr;

    mmt.wType = TIME_BYTES;

    mmr = waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

    if(MMSYSERR_NOERROR != mmr)
    {
        return 0L;
    }

    dwTime = GetMSFromMMTIME(pwfx,&mmt);

    return dwTime;
}


//--------------------------------------------------------------------------;
//
//  int Test_waveOutReset
//
//  Description:
//      Tests the driver functionality for waveOutReset.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutReset
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh1;
    volatile LPWAVEHDR  pwh2;
    volatile LPWAVEHDR  pwh3;
    HANDLE              hHeap;
    WAVEOUTCAPS         woc;
    LPWAVEINFO          pwi;
    DWORD               dw;
    MMTIME              mmt;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutReset";

    //
    //  Are there any output devices?
    //

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Is device synchronous?
    //

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_SYNC)
    {
        LogPass("Device is synchronous.  Test not applicable");

        return TST_PASS;
    }

    //
    //  Allocating memory.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh3 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh3)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwi = ExactHeapAllocPtr(
        hHeap,
        GMEM_SHARE|GMEM_FIXED,
        sizeof(WAVEINFO) + 4*sizeof(DWORD));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    dw  = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|OUTPUT_MAP(gti));

    pwh1->lpData             = gti.wrShort.pData;
    pwh1->dwBufferLength     = gti.wrShort.cbSize;
    pwh1->dwBytesRecorded    = 0L;
    pwh1->dwUser             = 0L;
    pwh1->dwFlags            = 0L;

    pwh2->lpData             = gti.wrLong.pData;
    pwh2->dwBufferLength     = gti.wrLong.cbSize;
    pwh2->dwBytesRecorded    = 0L;
    pwh2->dwUser             = 0L;
    pwh2->dwFlags            = 0L;

    pwh3->lpData             = gti.wrMedium.pData;
    pwh3->dwBufferLength     = gti.wrMedium.cbSize;
    pwh3->dwBytesRecorded    = 0L;
    pwh3->dwUser             = 0L;
    pwh3->dwFlags            = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutClose(hWaveOut);

        LogFail(gszFailWOPrepare);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        LogFail(gszFailWOPrepare);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh3,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutUnprepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        LogFail(gszFailWOPrepare);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Verify waveOutReset works if immediately after open.
    //

    Log_TestCase("Verifying waveOutReset works if immediately after open");

    mmr = call_waveOutReset(hWaveOut);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("waveOutReset works immediately after open");
    }
    else
    {
        call_waveOutUnprepareHeader(hWaveOut,pwh3,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        LogFail("waveOutReset returned error");

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Verify waveOutReset works if device is paused.
    //

    Log_TestCase("Verifying waveOutReset works if device is paused");

    call_waveOutPause(hWaveOut);
    call_waveOutWrite(hWaveOut,pwh2,sizeof(WAVEHDR));

    mmr = call_waveOutReset(hWaveOut);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("waveOutReset works if device is paused");
    }
    else
    {
        call_waveOutUnprepareHeader(hWaveOut,pwh3,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        LogFail("waveOutReset returned error");

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Clearing DONE bit in header...
    //

    pwh2->dwFlags &= (~WHDR_DONE);

    //
    //  Verify device is restarted after reset.
    //

    Log_TestCase("Verify device is restarted after reset");

    call_waveOutWrite(hWaveOut,pwh2,sizeof(WAVEHDR));

    if(IsPaused(hWaveOut))
    {
        LogFail("waveOutReset did not restart device");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveOutReset restarted device");
    }

    //
    //  Verify waveOutReset works if device is restarted.
    //

    Log_TestCase("Verifying waveOutReset works if device is restarted");

    mmr = call_waveOutReset(hWaveOut);
    pwh2->dwFlags &= (~WHDR_DONE);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("waveOutReset works if device is restarted");
    }
    else
    {
        call_waveOutUnprepareHeader(hWaveOut,pwh3,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        LogFail("waveOutReset returned error");

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Verify waveOutReset resets waveOutGetPosition count.
    //

    call_waveOutWrite(hWaveOut,pwh3,sizeof(WAVEHDR));

    //  Polling...

    while(!(pwh3->dwFlags & WHDR_DONE));

    mmt.wType = TIME_BYTES;
    call_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));
    dw = GetMSFromMMTIME(gti.pwfxOutput,&mmt);

    if(0 == dw)
    {
        LogFail("Position has not moved");

        iResult = TST_FAIL;
    }

    Log_TestCase("Verifying waveOutReset resets waveOutGetPosition count");

    mmr = call_waveOutReset(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Driver failed waveOutReset()");

        iResult = TST_FAIL;
    }
    else
    {
        mmt.wType = TIME_BYTES;
        call_waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));
        dw = GetMSFromMMTIME(gti.pwfxOutput,&mmt);

        if(0 != dw)
        {
            LogFail("Position was not reset to zero");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Position was reset to zero");
        }
    }

    //
    //  Verify waveOutReset forces DONE callbacks.
    //

    Log_TestCase("Verifying waveOutReset forces DONE callbacks");

    pwh1->dwFlags &= (~WHDR_DONE);
    pwh2->dwFlags &= (~WHDR_DONE);
    pwh3->dwFlags &= (~WHDR_DONE);

    //  Note:  There will be 3 headers we use count of 4 to detect too many
    //          callbacks.

    pwi->dwCount   = 4;
    pwi->dwCurrent = 0L;
    pwi->fdwFlags  = 0L;

    call_waveOutWrite(hWaveOut,pwh1,sizeof(WAVEHDR));
    call_waveOutWrite(hWaveOut,pwh2,sizeof(WAVEHDR));
    call_waveOutWrite(hWaveOut,pwh3,sizeof(WAVEHDR));

    mmr = call_waveOutReset(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Driver failed waveOutReset()");
    }
    else
    {
        if(3 == pwi->dwCurrent)
        {
            LogPass("Driver made correct number of callbacks");
        }
        else
        {
            if(3 > pwi->dwCurrent)
            {
                LogFail("Driver made too many callbacks");
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Driver made %lu callbacks; 3 expected.",
                    pwi->dwCurrent);
            }

            iResult = TST_FAIL;
        }
    }

    //
    //  Verify waveOutReset forces DONE callbacks for looped buffers.
    //

    Log_TestCase("Verifying waveOutReset forces DONE callbacks for looped"
        " buffers");

    pwh1->dwFlags &= (~WHDR_DONE);
    pwh2->dwFlags &= (~WHDR_DONE);
    pwh3->dwFlags &= (~WHDR_DONE);

    pwh1->dwFlags |= WHDR_BEGINLOOP;
    pwh2->dwFlags |= WHDR_ENDLOOP;
    pwh1->dwLoops  = 5;
    pwh2->dwLoops  = 5;

    pwh3->dwFlags |= (WHDR_BEGINLOOP | WHDR_ENDLOOP);
    pwh3->dwLoops  = 20;

    //  Note:  There will be 3 headers we use count of 4 to detect too many
    //          callbacks.

    pwi->dwCount   = 4;
    pwi->dwCurrent = 0L;
    pwi->fdwFlags  = 0L;

    call_waveOutWrite(hWaveOut,pwh1,sizeof(WAVEHDR));
    call_waveOutWrite(hWaveOut,pwh2,sizeof(WAVEHDR));
    call_waveOutWrite(hWaveOut,pwh3,sizeof(WAVEHDR));

    mmr = call_waveOutReset(hWaveOut);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Driver failed waveOutReset()");
    }
    else
    {
        if(3 == pwi->dwCurrent)
        {
            LogPass("Driver made correct number of callbacks");
        }
        else
        {
            if(3 < pwi->dwCurrent)
            {
                LogFail("Driver made too many callbacks");
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Driver made %lu callbacks; 3 expected.",
                    pwi->dwCurrent);
            }

            iResult = TST_FAIL;
        }
    }

    call_waveOutUnprepareHeader(hWaveOut,pwh3,sizeof(WAVEHDR));
    call_waveOutUnprepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));
    call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    DLL_WaveControl(DLL_END,NULL);
    PageUnlock(pwi);
    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveOutReset()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutGetPitch
//
//  Description:
//      Tests the driver functionality for waveOutGetPitch.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutGetPitch
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    WAVEOUTCAPS         woc;
    DWORD               dw,dwPitch;
    volatile LPWAVEHDR  pWaveHdr;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutGetPitch";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    if(!(woc.dwSupport & WAVECAPS_PITCH))
    {
        //
        //  Verifying waveOutGetPitch fails (when WAVECAPS_PITCH not set).
        //
        
        Log_TestCase("~Verifying waveOutGetPitch fails when WAVECAPS_PITCH "
            "not set");

        mmr = call_waveOutGetPitch(hWaveOut,&dwPitch);

        if(MMSYSERR_NOTSUPPORTED == mmr)
        {
            LogPass("Device does not support waveOutGetPitch");
            call_waveOutClose(hWaveOut);

            return TST_PASS;
        }
        else
        {
            LogFail("Device does not return MMSYSERR_NOTSUPPORTED");
            call_waveOutClose(hWaveOut);
        
            return TST_FAIL;
        }
    }

    //
    //  Verifying waveOutGetPitch succeeds (when WAVECAPS_PITCH set).
    //

    Log_TestCase("~Verifying waveOutGetPitch succeeds");

    mmr = call_waveOutGetPitch(hWaveOut,&dwPitch);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Device does not support waveOutGetPitch");

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }
    else
    {
        LogPass("Device supports waveOutGetPitch");
    }

    //
    //  Verifying Pitch is 1.00 after open.
    //

    Log_TestCase("~Verifying initial pitch is 1.000");

    if(0x00010000 == dwPitch)
    {
        //
        //  Initial pitch is 1.00!
        //

        LogPass("Initial pitch is 1.000");
    }
    else
    {
        tstLog(
            TERSE,
            "\n    FAIL: Initial pitch is " RATIO_FORMAT ".", RATIO(dwPitch));

        iResult = TST_FAIL;
    }

    pWaveHdr = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        LogFail(gszFailNoMem);

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    pWaveHdr->lpData         = gti.wrLong.pData;
    pWaveHdr->dwBufferLength = gti.wrLong.cbSize;
    pWaveHdr->dwFlags        = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    for(dw = 0x00008000; dw < 0x00030000; dw += 0x80000)
    {
        mmr = call_waveOutSetPitch(hWaveOut,dw);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutSetPitch is not supported");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pWaveHdr);

            return TST_FAIL;
        }

        //
        //  Verifying getting pitch while stopped
        //

        Log_TestCase("~Verifying waveOutGetPitch while stopped works");

        mmr = call_waveOutGetPitch(hWaveOut,&dwPitch);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPitch is not supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("waveOutGetPitch is supported");

            Log_TestCase("~Verifying waveOutGetPitch and waveOutSetPitch "
                "values are similar");

            if(dw != dwPitch)
            {
                LogFail("waveOutGetPitch and waveOutSetPitch inconsistent");

                iResult = TST_FAIL;
            }
            else
            {
                LogPass("waveOutGetPitch and waveOutSetPitch consistent");
            }
        }

        if(woc.dwSupport & WAVECAPS_SYNC)
        {
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
        }
        else
        {
            call_waveOutPause(hWaveOut);
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

            //
            //  Verifying getting pitch while paused works.
            //

            Log_TestCase("~Verifying waveOutGetPitch while paused works");

            mmr = call_waveOutGetPitch(hWaveOut,&dwPitch);

            if(MMSYSERR_NOERROR != mmr)
            {
                LogFail("waveOutGetPitch is not supported");

                iResult = TST_FAIL;
            }
            else
            {
                LogPass("waveOutGetPitch is supported");

                Log_TestCase("~Verifying get pitch value similar to set "
                    "pitch");

                if(dw != dwPitch)
                {
                    LogFail("waveOutGetPitch and waveOutSetPitch inconsistent");

                    iResult = TST_FAIL;
                }
                else
                {
                    LogPass("waveOutGetPitch and waveOutSetPitch consistent");
                }
            }
            
            call_waveOutRestart(hWaveOut);

            //
            //  Verifying getting pitch while playing (async devices) works.
            //

            mmr = call_waveOutSetPitch(hWaveOut,0x10000);

            if(MMSYSERR_NOERROR != mmr)
            {
                LogFail("waveOutSetPitch is not supported");

                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pWaveHdr);

                return TST_FAIL;
            }

            mmr = call_waveOutGetPitch(hWaveOut,&dwPitch);
            call_waveOutSetPitch(hWaveOut,dw);

            if(pWaveHdr->dwFlags & WHDR_DONE)
            {
                //
                //  The DONE bit set?!
                //

                LogFail("Buffer is done playing; test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                //
                //  The DONE bit is not set!
                //

                if(MMSYSERR_NOERROR != mmr)
                {
                    LogFail("waveOutGetPitch is not supported");

                    iResult = TST_FAIL;
                }
                else
                {
                    LogPass("waveOutGetPitch is supported");

                    Log_TestCase("Verifying get pitch value similar to "
                        "set pitch");

                    if(0x10000 != dwPitch)
                    {
                        LogFail("waveOutGetPitch and waveOutSetPitch "
                            "inconsistent");

                        iResult = TST_FAIL;
                    }
                    else
                    {
                        LogPass("waveOutGetPitch and waveOutSetPitch "
                            "consistent");
                    }
                }
            }

            call_waveOutReset(hWaveOut);
        }
    }

    call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    return (iResult);
} // Test_waveOutGetPitch()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutGetPlaybackRate
//
//  Description:
//      Tests the driver functionality for waveOutGetPlaybackRate.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutGetPlaybackRate
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    WAVEOUTCAPS         woc;
    DWORD               dw,dwRate;
    volatile LPWAVEHDR  pWaveHdr;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutGetPlaybackRate";

#pragma message(REMIND("Remember to check rate accuracy."))
    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    if(!(woc.dwSupport & WAVECAPS_PLAYBACKRATE))
    {
        //
        //  Verifying GetRate fails (when WAVECAPS_PLAYBACKRATE not set).
        //
        
        Log_TestCase("Verifying waveOutGetPlaybackRate fails when "
            "WAVECAPS_PLAYBACKRATE not set");

        mmr = call_waveOutGetPlaybackRate(hWaveOut,&dwRate);

        call_waveOutClose(hWaveOut);

        if(MMSYSERR_NOTSUPPORTED == mmr)
        {
            LogPass("Device does not support waveOutGetPlaybackRate");

            return TST_PASS;
        }
        else
        {
            LogFail("Device does not return MMSYSERR_NOTSUPPORTED");

            return TST_FAIL;
        }
    }

    //
    //  Verifying GetRate succeeds (when WAVECAPS_PLAYBACKRATE set).
    //

    Log_TestCase("Verifying waveOutGetPlaybackRate succeeds");

    mmr = call_waveOutGetPlaybackRate(hWaveOut,&dwRate);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Device does not support waveOutGetPlaybackRate");

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }
    else
    {
        LogPass("Device supports waveOutGetPlaybackRate");
    }

    //
    //  Verifying rate is 1.00 after open.
    //

    Log_TestCase("Verifying initial rate is 1.000");

    if(0x00010000 == dwRate)
    {
        //
        //  Initial rate is 1.00!
        //

        LogPass("Initial rate is 1.000");
    }
    else
    {
        tstLog(
            TERSE,
            "\n    FAIL: Initial rate is %u.%03u.",
            dwRate / 0x10000,
            (((dwRate & 0xffff)*1000)/0x10000));

        iResult = TST_FAIL;
    }

    pWaveHdr = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        LogFail(gszFailNoMem);

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    pWaveHdr->lpData         = gti.wrLong.pData;
    pWaveHdr->dwBufferLength = gti.wrLong.cbSize;
    pWaveHdr->dwFlags        = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR == mmr)
    {
        DPF(1,gszFailExactAlloc);

        LogFail(gszFailNoMem);
        ExactFreePtr(pWaveHdr);

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    for(dw = 0x00008000; dw < 0x00030000; dw += 0x80000)
    {
        mmr = call_waveOutSetPlaybackRate(hWaveOut,dw);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPlaybackRate is not supported");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pWaveHdr);

            return TST_FAIL;
        }

        //
        //  Verifying getting rate while stopped
        //

        Log_TestCase("Verifying waveOutGetPlaybackRate while stopped works");

        mmr = call_waveOutGetPlaybackRate(hWaveOut,&dwRate);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPlaybackRate is not supported");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("waveOutGetPlaybackRate is supported");

            Log_TestCase("Verifying get rate value similar to set rate");

            if(dw != dwRate)
            {
                LogFail("waveOutGetPlaybackRate and waveOutSetPlaybackRate"
                    " inconsistent");

                iResult = TST_FAIL;
            }
            else
            {
                LogPass("waveOutGetPlaybackRate and waveOutSetPlaybackRate "
                    "consistent");
            }
        }

        if(woc.dwSupport & WAVECAPS_SYNC)
        {
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
        }
        else
        {
            call_waveOutPause(hWaveOut);
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

            //
            //  Verifying getting rate while paused works.
            //

            Log_TestCase("Verifying getting rate while paused works");

            mmr = call_waveOutGetPlaybackRate(hWaveOut,&dwRate);

            if(MMSYSERR_NOERROR != mmr)
            {
                LogFail("waveOutGetPlaybackRate is not supported");

                iResult = TST_FAIL;
            }
            else
            {
                LogPass("waveOutGetPlaybackRate is supported");

                Log_TestCase("Verifying get rate value similar to set rate");

                if(dw != dwRate)
                {
                    LogFail("waveOutGetPlaybackRate and "
                        "waveOutSetPlaybackRate inconsistent");

                    iResult = TST_FAIL;
                }
                else
                {
                    LogPass("waveOutGetPlaybackRate and "
                        "waveOutSetPlaybackRate consistent");
                }
            }
            
            call_waveOutRestart(hWaveOut);

            //
            //  Verifying getting rate while playing (async devices) works.
            //

            mmr = call_waveOutSetPlaybackRate(hWaveOut,0x10000);

            if(MMSYSERR_NOERROR != mmr)
            {
                LogFail("waveOutGetPlaybackRate is not supported");

                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pWaveHdr);

                return TST_FAIL;
            }

            mmr = call_waveOutGetPlaybackRate(hWaveOut,&dwRate);
            call_waveOutSetPlaybackRate(hWaveOut,dw);

            if(pWaveHdr->dwFlags & WHDR_DONE)
            {
                //
                //  The DONE bit set?!
                //

                LogFail("Buffer is done playing; test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                //
                //  The DONE bit is not set!
                //

                if(MMSYSERR_NOERROR != mmr)
                {
                    LogFail("waveOutGetPlaybackRate is not supported");

                    iResult = TST_FAIL;
                }
                else
                {
                    LogPass("waveOutGetPlaybackRate is supported");

                    Log_TestCase("Verifying get rate value similar to "
                        "set rate");

                    if(0x10000 != dwRate)
                    {
                        LogFail("waveOutGetPlaybackRate and "
                            "waveOutSetPlaybackRate inconsistent");

                        iResult = TST_FAIL;
                    }
                    else
                    {
                        LogPass("waveOutGetPlaybackRate and "
                            "waveOutSetPlaybackRate consistent");
                    }
                }
            }

            call_waveOutReset(hWaveOut);
        }
    }

    call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    return (iResult);
} // Test_waveOutGetPlaybackRate()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutSetPitch
//
//  Description:
//      Tests the driver functionality for waveOutSetPitch.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutSetPitch
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    WAVEOUTCAPS         woc;
    DWORD               dw,dwPitch;
    volatile LPWAVEHDR  pWaveHdr;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutSetPitch";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    if(!(woc.dwSupport & WAVECAPS_PITCH))
    {
        //
        //  Verifying SetPitch fails (when WAVECAPS_PITCH not set).
        //
        
        Log_TestCase("~Verifying SetPitch fails when WAVECAPS_PITCH not set");

        mmr = call_waveOutSetPitch(hWaveOut,0x8000);

        call_waveOutClose(hWaveOut);

        if(MMSYSERR_NOTSUPPORTED == mmr)
        {
            LogPass("Device does not support setting pitch");

            return TST_PASS;
        }
        else
        {
            LogFail("Device does not return MMSYSERR_NOTSUPPORTED");

            return TST_FAIL;
        }
    }

    //
    //  Verifying SetPitch succeeds (when WAVECAPS_PITCH set).
    //

    Log_TestCase("Verifying SetPitch succeeds");

    mmr = call_waveOutSetPitch(hWaveOut,0x8000);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Device does not support setting pitch");

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }
    else
    {
        LogPass("Device supports setting pitch");
    }

    pWaveHdr = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        LogFail(gszFailNoMem);

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    pWaveHdr->lpData         = gti.wrLong.pData;
    pWaveHdr->dwBufferLength = gti.wrLong.cbSize;
    pWaveHdr->dwFlags        = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutClose(hWaveOut);
        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }

    for(dw = 0x00008000; dw < 0x00030000; dw += 0x80000)
    {
        //
        //  Verifying setting pitch before playing works.
        //

        Log_TestCase("Verifying setting pitch before playing works");

        mmr = call_waveOutSetPitch(hWaveOut,dw);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutSetPitch is not supported");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pWaveHdr);

            return TST_FAIL;
        }

        //
        //  Verifying pitch was actually set properly.
        //

        Log_TestCase("Verifying pitch was set correctly");

        mmr = call_waveOutGetPitch(hWaveOut,&dwPitch);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPitch is not supported");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pWaveHdr);

            return TST_FAIL;
        }

        if(dwPitch != dw)
        {
            //
            //  Pitches are not similar.
            //

            LogFail("Current pitch not similar to set pitch");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Current pitch similar to set pitch");
        }

        if(woc.dwSupport & WAVECAPS_SYNC)
        {
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
        }
        else
        {
            //
            //  Verying setting pitch while playing (async devices) works.
            //

            call_waveOutPause(hWaveOut);
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutRestart(hWaveOut);

            mmr = call_waveOutSetPitch(hWaveOut,0x10000);

            if(pWaveHdr->dwFlags & WHDR_DONE)
            {
                //
                //  The DONE bit is set?!
                //

                LogFail("Buffer is done playing; test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                if(MMSYSERR_NOERROR != mmr)
                {
                    LogFail("waveOutSetPitch is not supported");

                    call_waveOutReset(hWaveOut);

                    call_waveOutUnprepareHeader(
                        hWaveOut,
                        pWaveHdr,
                        sizeof(WAVEHDR));

                    call_waveOutClose(hWaveOut);

                    ExactFreePtr(pWaveHdr);

                    return TST_FAIL;
                }

                //
                //  Verifying pitch was actually set properly.
                //

                Log_TestCase("Verifying pitch was set correctly");

                mmr = call_waveOutGetPitch(hWaveOut,&dwPitch);

                if(MMSYSERR_NOERROR != mmr)
                {
                    LogFail("waveOutGetPitch is not supported");

                    call_waveOutReset(hWaveOut);

                    call_waveOutUnprepareHeader(
                        hWaveOut,
                        pWaveHdr,
                        sizeof(WAVEHDR));

                    call_waveOutClose(hWaveOut);

                    ExactFreePtr(pWaveHdr);

                    return TST_FAIL;
                }

                if(dwPitch != 0x10000)
                {
                    //
                    //  Pitches are not similar.
                    //

                    LogFail("Current pitch not similar to set pitch");

                    iResult = TST_FAIL;
                }
                else
                {
                    LogPass("Current pitch similar to set pitch");
                }
            }
        }
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);
    ExactFreePtr(pWaveHdr);

    return (iResult);
} // Test_waveOutSetPitch()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutSetPlaybackRate
//
//  Description:
//      Tests the driver functionality for waveOutSetPlaybackRate.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutSetPlaybackRate
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    WAVEOUTCAPS         woc;
    DWORD               dw,dwRate;
    volatile LPWAVEHDR  pWaveHdr;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutSetPlaybackRate";

#pragma message(REMIND("Remember to check rate accuracy."))

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    if(!(woc.dwSupport & WAVECAPS_PLAYBACKRATE))
    {
        //
        //  Verifying SetRate fails (when WAVECAPS_PLAYBACKRATE not set).
        //
        
        Log_TestCase("~Verifying SetRate fails when WAVECAPS_PLAYBACKRATE "
            "not set");

        mmr = call_waveOutSetPlaybackRate(hWaveOut,0x8000);

        call_waveOutClose(hWaveOut);

        if(MMSYSERR_NOTSUPPORTED == mmr)
        {
            LogPass("Device does not support setting rate");

            return TST_PASS;
        }
        else
        {
            LogFail("Device does not return MMSYSERR_NOTSUPPORTED");

            return TST_FAIL;
        }
    }

    //
    //  Verifying waveOutSetPlaybackRate succeeds (when
    //  WAVECAPS_PLAYBACKRATE set).
    //

    Log_TestCase("Verifying waveOutSetPlaybackRate succeeds");

    mmr = call_waveOutSetPlaybackRate(hWaveOut,0x8000);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Device does not support waveOutSetPlaybackRate");

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }
    else
    {
        LogPass("Device supports waveOutSetPlaybackRate");
    }

    pWaveHdr = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        LogFail(gszFailNoMem);

        call_waveOutClose(hWaveOut);

        return TST_FAIL;
    }

    pWaveHdr->lpData         = gti.wrLong.pData;
    pWaveHdr->dwBufferLength = gti.wrLong.cbSize;
    pWaveHdr->dwFlags        = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutClose(hWaveOut);
        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }

    for(dw = 0x00008000; dw < 0x00030000; dw += 0x80000)
    {
        //
        //  Verifying setting playback rate before playing works.
        //

        Log_TestCase("Verifying setting rate before playing works");

        mmr = call_waveOutSetPlaybackRate(hWaveOut,dw);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutSetPlaybackRate is not supported");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pWaveHdr);

            return TST_FAIL;
        }

        //
        //  Verifying rate was actually set properly.
        //

        Log_TestCase("Verifying rate was set correctly");

        mmr = call_waveOutGetPlaybackRate(hWaveOut,&dwRate);

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveOutGetPlaybackRate is not supported");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pWaveHdr);

            return TST_FAIL;
        }

        if(dwRate != dw)
        {
            //
            //  Rates are not similar.
            //

            LogFail("Current rate not similar to set rate");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Current rate similar to set rate");
        }

        if(woc.dwSupport & WAVECAPS_SYNC)
        {
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
        }
        else
        {
            //
            //  Verying setting rate while playing (async devices) works.
            //

            call_waveOutPause(hWaveOut);
            call_waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
            call_waveOutRestart(hWaveOut);

            mmr = call_waveOutSetPlaybackRate(hWaveOut,0x10000);

            if(pWaveHdr->dwFlags & WHDR_DONE)
            {
                //
                //  The DONE bit is set?!
                //

                LogFail("Buffer is done playing; test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                if(MMSYSERR_NOERROR != mmr)
                {
                    LogFail("waveOutSetPlaybackRate is not supported");

                    call_waveOutReset(hWaveOut);

                    call_waveOutUnprepareHeader(
                        hWaveOut,
                        pWaveHdr,
                        sizeof(WAVEHDR));

                    call_waveOutClose(hWaveOut);

                    ExactFreePtr(pWaveHdr);

                    return TST_FAIL;
                }

                //
                //  Verifying rate was actually set properly.
                //

                Log_TestCase("Verifying rate was set correctly");

                mmr = call_waveOutGetPlaybackRate(hWaveOut,&dwRate);

                if(MMSYSERR_NOERROR != mmr)
                {
                    LogFail("waveOutGetPlaybackRate is not supported");

                    call_waveOutReset(hWaveOut);

                    call_waveOutUnprepareHeader(
                        hWaveOut,
                        pWaveHdr,
                        sizeof(WAVEHDR));

                    call_waveOutClose(hWaveOut);

                    ExactFreePtr(pWaveHdr);

                    return TST_FAIL;
                }

                if(dwRate != 0x10000)
                {
                    //
                    //  Rates are not similar.
                    //

                    LogFail("Current rate not similar to set rate");

                    iResult = TST_FAIL;
                }
                else
                {
                    LogPass("Current rate similar to set rate");
                }
            }
        }
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    ExactFreePtr(pWaveHdr);

    return (iResult);
} // Test_waveOutSetPlaybackRate()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutGetVolume
//
//  Description:
//      Tests the driver functionality for waveOutGetVolume.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutGetVolume
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    WAVEOUTCAPS         woc;
    DWORD               dwInitVolume;
    DWORD               dw,dwVolume;
    DWORD               dwStereoMask;
    volatile LPWAVEHDR  pwh;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutGetVolume";

#pragma message(REMIND("What to do w/ Device IDs"))

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_LRVOLUME)
    {
        //
        //  Verify WAVECAPS_XVOLUME flags are consistent.
        //

        Log_TestCase("Verifying WAVECAPS_XVOLUME flags are consistent");

        if(woc.dwSupport & WAVECAPS_VOLUME)
        {
            LogPass("WAVECAPS_VOLUME also set, flags are consistent");
        }
        else
        {
            LogFail("WAVECAPS_VOLUME not set when WAVECAPS_LRVOLUME set");

            iResult = TST_FAIL;
        }
    }

    dwStereoMask = (1 == woc.wChannels)?0x0000ffff:0xffffffff;

    pwh = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    if(!(woc.dwSupport & WAVECAPS_VOLUME))
    {
        //
        //  Verify waveOutGetVolume fails (when WAVECAPS_VOLUME not set).
        //

        Log_TestCase("Verifying waveOutGetVolume fails (when "
            "WAVECAPS_VOLUME not set)");

        mmr = call_waveOutGetVolume((UINT)hWaveOut,&dw);

        call_waveOutClose(hWaveOut);

        if(MMSYSERR_NOTSUPPORTED == mmr)
        {
            LogPass("Device does not support waveOutGetVolume");
        }
        else
        {
            LogFail("waveOutGetVolume does not return MMSYSERR_NOTSUPPORTED");

            iResult = TST_FAIL;
        }

        ExactFreePtr(pwh);
        return iResult;
    }

    //
    //  Verify waveOutGetVolume succeeds (when WAVECAPS_VOLUME set).
    //

    Log_TestCase("Verifying waveOutGetVolume succeeds (when WAVECAPS_VOLUME set)");

    mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwInitVolume);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("Device supports waveOutGetVolume");
    }
    else
    {
        LogFail("Device does not support waveOutGetVolume");

        call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
        call_waveOutClose(hWaveOut);

        ExactFreePtr(pwh);
        return TST_FAIL;
    }

    pwh->lpData         = gti.wrMedium.pData;
    pwh->dwBufferLength = gti.wrMedium.cbSize;
    pwh->dwFlags        = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,gszFailExactAlloc);

        LogFail(gszFailNoMem);
        
        call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
        call_waveOutClose(hWaveOut);

        ExactFreePtr(pwh);

        return TST_FAIL;
    }

    for(dw  = (0xffffffff & dwStereoMask);
        dw  > (0x10001000 & dwStereoMask);
        dw -= (0x10001000 & dwStereoMask))
    {
        //
        //  Verify waveOutGetVolume while stopped works.
        //

        Log_TestCase("Verifying waveOutGetVolume while stopped works");

        mmr = call_waveOutSetVolume((UINT)hWaveOut,dw);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        if(dw == dwVolume)
        {
            LogPass("waveOutGetVolume similar to set volume");
        }
        else
        {
            LogFail("waveOutGetVolume different from set volume");

            iResult = TST_FAIL;
        }

        //
        //  Clearing DONE bit.
        //

        pwh->dwFlags &= (~WHDR_DONE);

        call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

        if(!(woc.dwSupport & WAVECAPS_SYNC))
        {
            //
            //  Verify waveOutGetVolume while playing (async devices) works.
            //

            Log_TestCase("Verifying waveOutGetVolume while playing "
                "(async devices) works");

            mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            if(pwh->dwFlags & WHDR_DONE)
            {
                LogFail("Buffer already finished playing.  Test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                if(dw == dwVolume)
                {
                    LogPass("waveOutGetVolume similar to set volume");
                }
                else
                {
                    LogFail("waveOutGetVolume different from set volume");

                    iResult = TST_FAIL;
                }
            }

            //
            //  Verify waveOutGetVolume while paused works.
            //

            Log_TestCase("Verifying waveOutGetVolume while paused works");

            mmr = call_waveOutPause(hWaveOut);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            if(pwh->dwFlags & WHDR_DONE)
            {
                LogFail("Buffer already finished playing.  Test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                if(dw == dwVolume)
                {
                    LogPass("waveOutGetVolume similar to set volume");
                }
                else
                {
                    LogFail("waveOutGetVolume different from set volume");

                    iResult = TST_FAIL;
                }
            }

            mmr = call_waveOutRestart(hWaveOut);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }
        }

        //
        //  Polling DONE bit...
        //

        while(!(pwh->dwFlags & WHDR_DONE))
        {
            TestYield();

            if(tstCheckRunStop(VK_ESCAPE))
            {
                //
                //  Aborted!!!  Cleaning up...
                //

                tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
                tstLogFlush();

                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }
        }

        //
        //  Verify waveOutGetVolume after playing (no waveOutReset) works.
        //

        Log_TestCase("Verifying waveOutGetVolume after playing "
            "(no waveOutReset) works");

        mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        if(dw == dwVolume)
        {
            LogPass("waveOutGetVolume similar to set volume");
        }
        else
        {
            LogFail("waveOutGetVolume different from set volume");

            iResult = TST_FAIL;
        }

        call_waveOutReset(hWaveOut);
    }

    //
    //  Cleaning up...
    //

    call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
    call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
    call_waveOutClose(hWaveOut);

    ExactFreePtr(pwh);

    return (iResult);
} // Test_waveOutGetVolume()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutSetVolume
//
//  Description:
//      Tests the driver functionality for waveOutSetVolume.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutSetVolume
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    WAVEOUTCAPS         woc;
    DWORD               dwInitVolume;
    DWORD               dw,dwVolume;
    DWORD               dwStereoMask;
    volatile LPWAVEHDR  pwh;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutSetVolume";

#pragma message(REMIND("What to do w/ Device IDs"))

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_LRVOLUME)
    {
        //
        //  Verify WAVECAPS_XVOLUME flags are consistent.
        //

        Log_TestCase("Verifying WAVECAPS_XVOLUME flags are consistent");

        if(woc.dwSupport & WAVECAPS_VOLUME)
        {
            LogPass("WAVECAPS_VOLUME also set, flags are consistent");
        }
        else
        {
            LogFail("WAVECAPS_VOLUME not set when WAVECAPS_LRVOLUME set");

            iResult = TST_FAIL;
        }
    }

    dwStereoMask = (1 == woc.wChannels)?0x0000ffff:0xffffffff;

    pwh = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwInitVolume);

    if(!(woc.dwSupport & WAVECAPS_VOLUME))
    {
        //
        //  Verify waveOutSetVolume fails (when WAVECAPS_VOLUME not set).
        //

        Log_TestCase("Verifying waveOutSetVolume fails (when "
            "WAVECAPS_VOLUME not set)");

        mmr = call_waveOutSetVolume((UINT)hWaveOut,0xffffffff);

        if(MMSYSERR_NOTSUPPORTED == mmr)
        {
            LogPass("Device does not support waveOutSetVolume");
        }
        else
        {
            LogFail("waveOutSetVolume does not return MMSYSERR_NOTSUPPORTED");

            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);

            iResult = TST_FAIL;
        }

        call_waveOutClose(hWaveOut);

        return iResult;
    }

    //
    //  Verify waveOutSetVolume succeeds (when WAVECAPS_VOLUME set).
    //

    Log_TestCase("Verifying waveOutSetVolume succeeds (when WAVECAPS_VOLUME set)");

    mmr = call_waveOutSetVolume((UINT)hWaveOut,0xffffffff);

    if(MMSYSERR_NOERROR == mmr)
    {
        LogPass("Device supports waveOutSetVolume");
    }
    else
    {
        LogFail("Device does not support waveOutSetVolume");

        call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);

        return TST_FAIL;
    }

    pwh->lpData         = gti.wrMedium.pData;
    pwh->dwBufferLength = gti.wrMedium.cbSize;
    pwh->dwFlags        = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,gszFailExactAlloc);

        LogFail(gszFailNoMem);
        call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
        call_waveOutClose(hWaveOut);

        ExactFreePtr(pwh);

        return TST_FAIL;
    }

    for(dw  = (0xffffffff & dwStereoMask);
        dw  > (0x10001000 & dwStereoMask);
        dw -= (0x10001000 & dwStereoMask))
    {
        //
        //  Verify waveOutSetVolume while stopped works.
        //

        Log_TestCase("Verifying waveOutSetVolume while stopped works");

        mmr = call_waveOutSetVolume((UINT)hWaveOut,0);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        mmr = call_waveOutSetVolume((UINT)hWaveOut,dw);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        if(dw == dwVolume)
        {
            LogPass("waveOutGetVolume similar to set volume");
        }
        else
        {
            LogFail("waveOutGetVolume different from set volume");

            iResult = TST_FAIL;
        }

        //
        //  Clearing DONE bit.
        //

        pwh->dwFlags &= (~WHDR_DONE);

        call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

        if(!(woc.dwSupport & WAVECAPS_SYNC))
        {
            //
            //  Verify waveOutSetVolume while playing (async devices) works.
            //

            Log_TestCase("Verifying waveOutSetVolume while playing "
                "(async devices) works");

            mmr = call_waveOutSetVolume((UINT)hWaveOut,0);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            mmr = call_waveOutSetVolume((UINT)hWaveOut,dw);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            if(pwh->dwFlags & WHDR_DONE)
            {
                LogFail("Buffer already finished playing.  Test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                if(dw == dwVolume)
                {
                    LogPass("waveOutSetVolume similar to set volume");
                }
                else
                {
                    LogFail("waveOutSetVolume different from set volume");

                    iResult = TST_FAIL;
                }
            }

            //
            //  Verify waveOutSetVolume while paused works.
            //

            Log_TestCase("Verifying waveOutSetVolume while paused works");

            mmr = call_waveOutPause(hWaveOut);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            mmr = call_waveOutSetVolume((UINT)hWaveOut,0);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            mmr = call_waveOutSetVolume((UINT)hWaveOut,dw);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }

            if(pwh->dwFlags & WHDR_DONE)
            {
                LogFail("Buffer already finished playing.  Test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                if(dw == dwVolume)
                {
                    LogPass("waveOutSetVolume similar to set volume");
                }
                else
                {
                    LogFail("waveOutSetVolume different from set volume");

                    iResult = TST_FAIL;
                }
            }

            mmr = call_waveOutRestart(hWaveOut);

            if(MMSYSERR_NOERROR != mmr)
            {
                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }
        }

        //
        //  Polling DONE bit...
        //

        while(!(pwh->dwFlags & WHDR_DONE))
        {
            TestYield();

            if(tstCheckRunStop(VK_ESCAPE))
            {
                //
                //  Aborted!!!  Cleaning up...
                //

                tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
                tstLogFlush();

                call_waveOutReset(hWaveOut);
                call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
                call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
                call_waveOutClose(hWaveOut);

                ExactFreePtr(pwh);

                return TST_FAIL;
            }
        }

        //
        //  Verify waveOutSetVolume after playing (no waveOutReset) works.
        //

        Log_TestCase("Verifying waveOutSetVolume after playing "
            "(no waveOutReset) works");

        mmr = call_waveOutSetVolume((UINT)hWaveOut,0);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        mmr = call_waveOutSetVolume((UINT)hWaveOut,dw);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        mmr = call_waveOutGetVolume((UINT)hWaveOut,&dwVolume);

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
            call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
            call_waveOutClose(hWaveOut);

            ExactFreePtr(pwh);

            return TST_FAIL;
        }

        if(dw == dwVolume)
        {
            LogPass("waveOutSetVolume similar to set volume");
        }
        else
        {
            LogFail("waveOutSetVolume different from set volume");

            iResult = TST_FAIL;
        }

        call_waveOutReset(hWaveOut);
    }

    //
    //  Cleaning up...
    //

    call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
    call_waveOutSetVolume((UINT)hWaveOut,dwInitVolume);
    call_waveOutClose(hWaveOut);

    ExactFreePtr(pwh);

    return (iResult);
} // Test_waveOutSetVolume()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\waveutil.c ===
//--------------------------------------------------------------------------;
//
//  File: WaveUtil.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      Contains general utilities mostly to do with wave.
//
//  Contents:
//      Volume_SupportStereo()
//      GetMSFromMMTIME()
//      GetValueFromMMTIME()
//      ConvertWaveResource()
//      LoadWaveResourceFile()
//      LoadWaveResource()
//      PlayWaveResource()
//      CreateSilentBuffer()
//      IGetNumFormats()
//      IGetFormat()
//      tstGetNumFormats()
//      tstGetFormat()
//
//  History:
//      11/24/93    Fwong       Re-doing WaveTest.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include <memgr.h>
#include <inimgr.h>
#include <waveutil.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "Debug.h"


//--------------------------------------------------------------------------;
//
//  BOOL VolumeSupportStereo
//
//  Description:
//      Determines whether volume control supports individual channels.
//
//  Arguments:
//      UINT uDeviceID: Device ID for device.
//
//  Return (BOOL):
//      TRUE if supported, FALSE otherwise.
//
//  History:
//      12/03/93    Fwong
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL Volume_SupportStereo
(
    UINT    uDeviceID
)
{
    MMRESULT    mmr;
    WAVEOUTCAPS woc;
    DWORD       dwSupport = 0L;

    mmr = waveOutGetDevCaps(uDeviceID,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR == mmr)
    {
        //
        //  No error...
        //

        dwSupport = woc.dwSupport;
    }
    else
    {
        if(WAVE_MAPPER == uDeviceID)
        {
            //
            //  waveOutGetDevCaps returned error... Wave Mapper probably not
            //      installed.  Enumerating all wave devices.
            //

            for(uDeviceID = waveOutGetNumDevs();uDeviceID;uDeviceID--)
            {
                mmr = waveOutGetDevCaps(uDeviceID-1,&woc,sizeof(WAVEOUTCAPS));

                if(MMSYSERR_NOERROR == mmr)
                {
                    dwSupport |= woc.dwSupport;
                }
            }
        }
    }

    return ((dwSupport & WAVECAPS_LRVOLUME)?TRUE:FALSE);
} // Volume_SupportStereo()


//--------------------------------------------------------------------------;
//
//  DWORD GetMSFromMMTIME
//
//  Description:
//      Given an MMTIME structure it returns the time in milliseconds.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: pointer to WAVEFORMATEX structure.
//
//      LPMMTIME pmmt: pointer to MMTIME structure.
//
//  Return (DWORD):
//      Time in milliseconds.
//
//  History:
//      09/30/94    Fwong       For waveXGetPosition stuff.
//
//--------------------------------------------------------------------------;

DWORD GetMSFromMMTIME
(
    LPWAVEFORMATEX  pwfx,
    LPMMTIME        pmmt
)
{
    DWORD   dw;

    switch (pmmt->wType)
    {
        case TIME_MS:
            dw = pmmt->u.ms;
            break;

        case TIME_SAMPLES:
            dw = pmmt->u.sample * 1000 / pwfx->nSamplesPerSec;
            break;

        case TIME_BYTES:
            dw = pmmt->u.cb * 1000 / pwfx->nAvgBytesPerSec;
            break;

        case TIME_SMPTE:
            dw = pmmt->u.smpte.hour;
            dw = dw * 60 + pmmt->u.smpte.min;
            dw = dw * 60 + pmmt->u.smpte.sec;
            dw = dw * 1000 + pmmt->u.smpte.frame * 1000 / pmmt->u.smpte.fps;
            break;

        case TIME_MIDI:
        case TIME_TICKS:
        default:
            dw = (DWORD)(-1);
            break;
    }

    return dw;
} // GetMSFromMMTIME()


DWORD GetValueFromMMTIME
(
    LPMMTIME    pmmt
)
{
    DWORD   dwVal;

    switch (pmmt->wType)
    {
        case TIME_MS:
            dwVal = pmmt->u.ms;
            break;

        case TIME_SAMPLES:
            dwVal = pmmt->u.sample;
            break;

        case TIME_BYTES:
            dwVal = pmmt->u.cb;
            break;

        case TIME_SMPTE:
            dwVal = (pmmt->u.smpte.hour << 24) + (pmmt->u.smpte.min << 16) +
                    (pmmt->u.smpte.sec  <<  8) + pmmt->u.smpte.frame;

            break;

        case TIME_MIDI:
            dwVal = pmmt->u.midi.songptrpos;
            break;

        case TIME_TICKS:
            dwVal = pmmt->u.ticks;
            break;

        default:
            dwVal = 0;
    }

    return dwVal;
} // GetValueFromMMTIME()


//--------------------------------------------------------------------------;
//
//  BOOL ConvertWaveResource
//
//  Description:
//      Converts wave resource to another format.
//
//  Arguments:
//      LPWAVEFORMATEX pwfxSrc: Source Format.
//
//      LPWAVEFORMATEX pwfxDst: Destination Format.
//
//      LPWAVERESOURCE pwr: Wave Resource.
//
//  Return (BOOL):
//      TRUE is successful, FALSE otherwise.
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL ConvertWaveResource
(
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst,
    LPWAVERESOURCE  pwr
)
{
    HACMSTREAM          has;
    MMRESULT            mmr;
    LPBYTE              pData;
    DWORD               dw;
    LPACMSTREAMHEADER   pash;
    HCURSOR             hcurSave;

    if(wfxCmp(pwfxSrc,pwfxDst))
    {
        //
        //  Formats are equal... No conversion required!
        //

        return TRUE;
    }

    DPF(1,"ConvertWaveResource() conversion required!!");

    mmr = acmStreamOpen(
        &has,
        NULL,
        pwfxSrc,
        pwfxDst,
        NULL,
        0L,
        0L,
        ACM_STREAMOPENF_NONREALTIME);

    if(MMSYSERR_NOERROR != mmr)
    {
        WAVERESOURCE    wr;
        LPWAVEFORMATEX  pwfx1;
        LPWAVEFORMATEX  pwfx2;

        //
        //  Making copy of wave resource...
        //

        wr.cbSize = pwr->cbSize;
        wr.pData  = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE, wr.cbSize);

        hmemcpy(wr.pData,pwr->pData,wr.cbSize);

        //
        //  Allocating memory for intermediate formats.
        //

        pwfx1 = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(PCMWAVEFORMAT));
        pwfx2 = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(PCMWAVEFORMAT));

        _fmemset(pwfx1,0,sizeof(PCMWAVEFORMAT));
        _fmemset(pwfx2,0,sizeof(PCMWAVEFORMAT));

        //
        //  Finding first intermediate format...
        //

        pwfx1->wFormatTag = WAVE_FORMAT_PCM;

        mmr = acmFormatSuggest(
            NULL,
            pwfxSrc,
            pwfx1,
            sizeof(PCMWAVEFORMAT),
            ACM_FORMATSUGGESTF_WFORMATTAG);

        if(MMSYSERR_NOERROR != mmr)
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        //
        //  Finding second intermediate format...
        //

        pwfx2->wFormatTag     = WAVE_FORMAT_PCM;
        pwfx2->nChannels      = pwfxDst->nChannels;
        pwfx2->nSamplesPerSec = pwfxDst->nSamplesPerSec;

        mmr = acmFormatSuggest(
            NULL,
            pwfxDst,
            pwfx2,
            sizeof(PCMWAVEFORMAT),
            ACM_FORMATSUGGESTF_WFORMATTAG|
                ACM_FORMATSUGGESTF_NCHANNELS|
                ACM_FORMATSUGGESTF_NSAMPLESPERSEC);

        if(MMSYSERR_NOERROR != mmr)
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        //
        //  Making sure conversions work!!
        //

        mmr = acmStreamOpen(
            NULL,
            NULL,
            pwfxSrc,
            pwfx1,
            NULL,
            0L,
            0L,
            ACM_STREAMOPENF_NONREALTIME|ACM_STREAMOPENF_QUERY);

        if(MMSYSERR_NOERROR != mmr)
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        mmr = acmStreamOpen(
            NULL,
            NULL,
            pwfx1,
            pwfx2,
            NULL,
            0L,
            0L,
            ACM_STREAMOPENF_NONREALTIME|ACM_STREAMOPENF_QUERY);

        if(MMSYSERR_NOERROR != mmr)
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        mmr = acmStreamOpen(
            NULL,
            NULL,
            pwfx2,
            pwfxDst,
            NULL,
            0L,
            0L,
            ACM_STREAMOPENF_NONREALTIME|ACM_STREAMOPENF_QUERY);

        if(MMSYSERR_NOERROR != mmr)
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        if(FALSE == ConvertWaveResource(pwfxSrc,pwfx1,&wr))
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        if(FALSE == ConvertWaveResource(pwfx1,pwfx2,&wr))
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        if(FALSE == ConvertWaveResource(pwfx2,pwfxDst,&wr))
        {
            ExactFreePtr(wr.pData);
            ExactFreePtr(pwfx1);
            ExactFreePtr(pwfx2);

            return FALSE;
        }

        ExactFreePtr(pwfx1);
        ExactFreePtr(pwfx2);
        ExactFreePtr(pwr->pData);

        pwr->pData  = wr.pData;
        pwr->cbSize = wr.cbSize;

        return TRUE;
    }

    hcurSave = SetCursor(LoadCursor(NULL,IDC_WAIT));

    mmr = acmStreamSize(has, pwr->cbSize, &dw, ACM_STREAMSIZEF_SOURCE);

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  Something went wrong...
        //

        DPF(1,"acmStreamSize failed...");
        acmStreamClose(has,0L);
        SetCursor(hcurSave);
        return FALSE;
    }

    pData = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,dw);
    pash  = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(ACMSTREAMHEADER));

    _fmemset(pash, 0, sizeof(ACMSTREAMHEADER));

    pash->cbStruct      = sizeof(ACMSTREAMHEADER);
    pash->pbSrc         = pwr->pData;
    pash->cbSrcLength   = pwr->cbSize;
    pash->pbDst         = pData;
    pash->cbDstLength   = dw;

    mmr = acmStreamPrepareHeader(has,pash,0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  Something went wrong...
        //

        DPF(1,"acmStreamPrepareHeader failed...");
        ExactFreePtr(pData);
        ExactFreePtr(pash);
        acmStreamClose(has,0L);
        SetCursor(hcurSave);
        return FALSE;
    }

    mmr = acmStreamConvert(
        has,
        pash,
        ACM_STREAMCONVERTF_START|ACM_STREAMCONVERTF_END);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamConvert failed...");

        acmStreamUnprepareHeader(has,pash,0L);
        ExactFreePtr(pData);
        ExactFreePtr(pash);
        acmStreamClose(has,0L);
        SetCursor(hcurSave);
        return FALSE;
    }

    mmr = acmStreamUnprepareHeader(has, pash, 0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamUnprepareHeader failed...");

        ExactFreePtr(pData);
        ExactFreePtr(pash);
        acmStreamClose(has,0L);
        SetCursor(hcurSave);
        return FALSE;
    }

    mmr = acmStreamClose(has, 0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamClose failed...");

        ExactFreePtr(pData);
        ExactFreePtr(pash);
        SetCursor(hcurSave);
        return FALSE;
    }

    DPF(1,"ConverWaveResource successful.");

#ifdef DEBUG
    if(pash->cbSrcLength != pash->cbSrcLengthUsed)
    {
        DPF(1,"WARNING!!  Not all Source Data Used!!");
    }
#endif

    SetCursor(hcurSave);

    ExactFreePtr(pwr->pData);

    pwr->cbSize = pash->cbDstLengthUsed;
    pwr->pData  = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE, pwr->cbSize);

    hmemcpy(pwr->pData,pData,pwr->cbSize);

    ExactFreePtr(pData);
    ExactFreePtr(pash);

    return TRUE;
} // ConvertWaveResource()


//--------------------------------------------------------------------------;
//
//  BOOL LoadWaveResourceFile
//
//  Description:
//      Loads a wave resource from an external file.
//
//  Arguments:
//      LPWAVERESOURCE pwr: Wave Resource.
//
//      DWORD dwResource: Resource ID.
//
//  Return (BOOL):
//      TRUE is successful, FALSE otherwise.
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL LoadWaveResourceFile
(
    LPWAVERESOURCE  pwr,
    DWORD           dwResource
)
{
    MMRESULT        mmr;
    LPBYTE          pData;
    DWORD           cbRead;
    HMMIO           hmmio;
    MMCKINFO        mmiockSub;
    MMCKINFO        mmiockParent;
    LPWAVEFORMATEX  pwfx;
    char            szScrap[MAXSTDSTR];

    //
    //  Getting file resource name...
    //

    switch (dwResource)
    {
        case WR_LONG:
            cbRead = GetIniString(gszGlobal,gszLong,szScrap,MAXSTDSTR);
            break;

        case WR_MEDIUM:
            cbRead = GetIniString(gszGlobal,gszMedium,szScrap,MAXSTDSTR);
            break;

        case WR_SHORT:
            cbRead = GetIniString(gszGlobal,gszShort,szScrap,MAXSTDSTR);
            break;
    }

    if(0 == cbRead)
    {
        return FALSE;
    }

    DPF(1,"File name... [%s]",(LPSTR)szScrap);

    hmmio = mmioOpen(szScrap,NULL,MMIO_READ | MMIO_ALLOCBUF);

    if(NULL == hmmio)
    {
        //
        //  mmioOpen Failed?!  Let's talk to RickB...
        //

        DPF(1,"mmioOpen w/ resource file failed...");
        return FALSE;
    }

    //
    //  Finding WAVE chunk
    //

    _fmemset((LPMMCKINFO)&mmiockParent,0,(UINT)sizeof(MMCKINFO));

    mmiockParent.fccType = mmioFOURCC('W','A','V','E');
    mmr = mmioDescend(hmmio,&mmiockParent,NULL,MMIO_FINDRIFF);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"mmioDescend [WAVE] failed.");
        mmioClose(hmmio,0);
        return FALSE;
    }

    //
    //  Finding fmt chunk
    //

    _fmemset((LPMMCKINFO)&mmiockSub,0,(UINT)sizeof(MMCKINFO));

    mmiockSub.ckid = mmioFOURCC('f','m','t',' ');
    mmr = mmioDescend(hmmio,&mmiockSub,&mmiockParent,MMIO_FINDCHUNK);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"mmioDescend [fmt ] failed.");
        mmioClose(hmmio,0);
        return FALSE;
    }

    //
    //  Reading format into format buffer
    //

    pwfx   = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,mmiockSub.cksize);

    if(NULL == pwfx)
    {
        DPF(1,gszFailExactAlloc);

        mmioClose(hmmio,0);
        return FALSE;
    }

    cbRead = mmioRead(hmmio,(HPSTR)pwfx,mmiockSub.cksize);

    if(cbRead != mmiockSub.cksize)
    {
        //
        //  Didn't read that many bytes?
        //

        DPF(1,"Didn't read enough bytes");

        ExactFreePtr(pwfx);
        mmioClose(hmmio,0);

        return FALSE;
    }

    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        //
        //  Dude!!  We only do PCM for resource!!!
        //

        DPF(1,"Dude!!  We only do PCM for resource!!!");

        ExactFreePtr(pwfx);
        mmioClose(hmmio,0);

        return FALSE;
    }

    //
    //  Finding data chunk
    //

    mmiockSub.ckid = mmioFOURCC('d','a','t','a');
    mmr = mmioDescend(hmmio,&mmiockSub,&mmiockParent,MMIO_FINDCHUNK);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"mmioDescend [data] failed.");

        ExactFreePtr(pwfx);

        return FALSE;
    }

    //
    //  Reading Wave Data
    //

    pData  = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,mmiockSub.cksize);

    if(NULL == pData)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pwfx);
        mmioClose(hmmio,0);

        return FALSE;
    }

    cbRead = mmioRead(hmmio,(HPSTR)pData,mmiockSub.cksize);

    if(cbRead != mmiockSub.cksize)
    {
        //
        //  Didn't read that many bytes?
        //

        DPF(1,"Didn't read enough bytes");

        ExactFreePtr(pwfx);
        ExactFreePtr(pData);
        mmioClose(hmmio,0);

        return FALSE;
    }

    //
    //  Cleaning up...
    //

    if(NULL != pwr->pData)
    {
        ExactFreePtr(pwr->pData);
    }

    mmioClose(hmmio,0);

    pwr->pData  = pData;
    pwr->cbSize = cbRead;

    ConvertWaveResource(pwfx,gti.pwfxOutput,pwr);

    //
    //  Freeing format...
    //

    if(NULL != pwfx)
    {
        ExactFreePtr(pwfx);
    }

    return TRUE;
} // LoadWaveResourceFile()


//--------------------------------------------------------------------------;
//
//  BOOL LoadWaveResource
//
//  Description:
//      Loads a wave resource.
//
//  Arguments:
//      LPWAVERESOURCE pwr: Wave Resource.
//
//      DWORD dwResource: Resource ID.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      02/21/94    Fwong       Err... Who knows?!
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL LoadWaveResource
(
    LPWAVERESOURCE  pwr,
    DWORD           dwResource
)
{
    MMRESULT        mmr;
    HRSRC           hrsrc;
    HGLOBAL         hRes;
    LPBYTE          pRes;
    LPBYTE          pData;
    DWORD           cbRead;
    HMMIO           hmmio;
    MMIOINFO        mmioinfo;
    MMCKINFO        mmiockSub;
    MMCKINFO        mmiockParent;
    LPWAVEFORMATEX  pwfx;

    //
    //  Trying .ini file first...
    //

    if(LoadWaveResourceFile(pwr,dwResource))
    {
        return TRUE;
    }

    //
    //  Loading resource...
    //

    hrsrc = FindResource(
                ghinstance,
                MAKEINTRESOURCE(dwResource),
                MAKEINTRESOURCE(WAVE));

    if(NULL == hrsrc)
    {
        DPF(1,"Couldn't find resource...");
        return FALSE;
    }

    hRes = LoadResource(ghinstance,hrsrc);
    pRes = LockResource(hRes);

    _fmemset((LPMMIOINFO)&mmioinfo,0,(UINT)sizeof(MMIOINFO));

    mmioinfo.pchBuffer  = pRes;
    mmioinfo.fccIOProc  = FOURCC_MEM;
    mmioinfo.cchBuffer  = SizeofResource(ghinstance,hrsrc);
    mmioinfo.adwInfo[0] = 0L;

    hmmio = mmioOpen(NULL,&mmioinfo,MMIO_READ);

    if(NULL == hmmio)
    {
        //
        //  mmioOpen Failed?!  Let's talk to RickB...
        //

        DPF(1,"mmioOpen w/ memory file failed...");
        UnlockResource(hRes);
        FreeResource(hRes);
        return FALSE;
    }

    //
    //  Finding WAVE chunk
    //

    _fmemset((LPMMCKINFO)&mmiockParent,0,(UINT)sizeof(MMCKINFO));

    mmiockParent.fccType = mmioFOURCC('W','A','V','E');
    mmr = mmioDescend(hmmio,&mmiockParent,NULL,MMIO_FINDRIFF);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"mmioDescend [WAVE] failed.");
        mmioClose(hmmio,0);
        UnlockResource(hRes);
        FreeResource(hRes);
        return FALSE;
    }

    //
    //  Finding fmt chunk
    //

    _fmemset((LPMMCKINFO)&mmiockSub,0,(UINT)sizeof(MMCKINFO));

    mmiockSub.ckid = mmioFOURCC('f','m','t',' ');
    mmr = mmioDescend(hmmio,&mmiockSub,&mmiockParent,MMIO_FINDCHUNK);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"mmioDescend [fmt ] failed.");
        mmioClose(hmmio,0);
        UnlockResource(hRes);
        FreeResource(hRes);
        return FALSE;
    }

    //
    //  Reading format into format buffer
    //

    pwfx   = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,mmiockSub.cksize);

    if(NULL == pwfx)
    {
        DPF(1,gszFailExactAlloc);

        UnlockResource(hRes);
        FreeResource(hRes);

        return FALSE;
    }

    cbRead = mmioRead(hmmio,(HPSTR)pwfx,mmiockSub.cksize);

    if(cbRead != mmiockSub.cksize)
    {
        //
        //  Didn't read that many bytes?
        //

        DPF(1,"Didn't read enough bytes");

        ExactFreePtr(pwfx);
        mmioClose(hmmio,0);
        UnlockResource(hRes);
        FreeResource(hRes);

        return FALSE;
    }

    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        //
        //  Dude!!  We only do PCM for resource!!!
        //

        DPF(1,"Dude!!  We only do PCM for resource!!!");

        ExactFreePtr(pwfx);
        mmioClose(hmmio,0);
        UnlockResource(hRes);
        FreeResource(hRes);

        return FALSE;
    }

    //
    //  Finding data chunk
    //

    mmiockSub.ckid = mmioFOURCC('d','a','t','a');
    mmr = mmioDescend(hmmio,&mmiockSub,&mmiockParent,MMIO_FINDCHUNK);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"mmioDescend [data] failed.");

        ExactFreePtr(pwfx);
        UnlockResource(hRes);
        FreeResource(hRes);
        mmioClose(hmmio,0);

        return FALSE;
    }

    //
    //  Reading Wave Data
    //

    pData  = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,mmiockSub.cksize);

    if(NULL == pData)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pwfx);
        UnlockResource(hRes);
        FreeResource(hRes);
        mmioClose(hmmio,0);

        return FALSE;
    }

    cbRead = mmioRead(hmmio,(HPSTR)pData,mmiockSub.cksize);

    if(cbRead != mmiockSub.cksize)
    {
        //
        //  Didn't read that many bytes?
        //

        DPF(1,"Didn't read enough bytes");

        ExactFreePtr(pwfx);
        ExactFreePtr(pData);
        mmioClose(hmmio,0);
        UnlockResource(hRes);
        FreeResource(hRes);

        return FALSE;
    }

    //
    //  Cleaning up...
    //

    if(NULL != pwr->pData)
    {
        ExactFreePtr(pwr->pData);
    }

    mmioClose(hmmio,0);
    UnlockResource(hRes);
    FreeResource(hRes);

    pwr->pData  = pData;
    pwr->cbSize = cbRead;

    ConvertWaveResource(pwfx,gti.pwfxOutput,pwr);

    //
    //  Freeing format...
    //

    if(NULL != pwfx)
    {
        ExactFreePtr(pwfx);
    }

    return TRUE;
} // LoadWaveResource()


//--------------------------------------------------------------------------;
//
//  BOOL PlayWaveResource
//
//  Description:
//      Given format, data, and size it plays the resource through the
//      the default device w/ the default output format.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Source format.
//
//      LPBYTE pData: Pointer to data.
//
//      DWORD cbSize: Size (in bytes) of data.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      10/21/94    Fwong       Support for input tests.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL PlayWaveResource
(
    LPWAVEFORMATEX  pwfx,
    LPBYTE          pData,
    DWORD           cbSize
)
{
    HWAVEOUT            hWaveOut;
    volatile LPWAVEHDR  pwh;
    HANDLE              hHeap;
    MMRESULT            mmr;
    WAVERESOURCE        wr;
    BOOL                fAlloc = TRUE;

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        return FALSE;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        ExactHeapDestroy(hHeap);
        return FALSE;
    }

    wr.cbSize = cbSize;

    if(wfxCmp(pwfx,gti.pwfxOutput))
    {
        wr.pData = pData;
        fAlloc   = FALSE;
    }
    else
    {
        //
        //  Note: Not doing heap allocation since ConvertWaveResource may
        //  free the memory.
        //

        wr.pData = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cbSize);

        if(NULL == wr.pData)
        {
            ExactHeapDestroy(hHeap);
            return FALSE;
        }

        hmemcpy(wr.pData,pData,cbSize);

        ConvertWaveResource(pwfx,gti.pwfxOutput,&wr);
    }

    mmr = call_waveOutOpen(
            &hWaveOut,
            gti.uOutputDevice,
            gti.pwfxOutput,
            0L,
            0L,
            WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    pwh->lpData          = wr.pData;
    pwh->dwBufferLength  = wr.cbSize;
    pwh->dwBytesRecorded = 0L;
    pwh->dwUser          = 0L;
    pwh->dwFlags         = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutClose(hWaveOut);

        if(fAlloc)
        {
            ExactFreePtr(wr.pData);
        }

        ExactHeapDestroy(hHeap);

        return FALSE;
    }

    mmr = call_waveOutWrite(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        if(fAlloc)
        {
            ExactFreePtr(wr.pData);
        }

        ExactHeapDestroy(hHeap);

        return FALSE;
    }

    while(!(pwh->dwFlags & WHDR_DONE));

    mmr = call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        call_waveOutReset(hWaveOut);
        call_waveOutUnprepareHeader(hWaveOut,pwh,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        if(fAlloc)
        {
            ExactFreePtr(wr.pData);
        }

        ExactHeapDestroy(hHeap);

        return FALSE;
    }

    call_waveOutClose(hWaveOut);

    if(fAlloc)
    {
        ExactFreePtr(wr.pData);
    }

    ExactHeapDestroy(hHeap);

    return TRUE;
}


//--------------------------------------------------------------------------;
//
//  BOOL CreateSilentBuffer
//
//  Description:
//      Creates a buffer of silence.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Wave format.
//
//      LPBYTE pData: Destination buffer.
//
//      DWORD cbSize: Size of desired silent buffer.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      10/31/94    Fwong       For DMA size stuff.
//
//--------------------------------------------------------------------------;

BOOL CreateSilentBuffer
(
    LPWAVEFORMATEX  pwfx,
    LPBYTE          pData,
    DWORD           cbSize
)
{
    MMRESULT            mmr;
    HACMSTREAM          has;
    LPBYTE              pData1;
    DWORD               dw,cbSize1;
    LPWAVEFORMATEX      pwfx1;
    LPACMSTREAMHEADER   pash;
    HANDLE              hHeap;

    DPF(1,"CreateSilentBuffer size: %lu bytes.",cbSize);

    if(WAVE_FORMAT_PCM == pwfx->wFormatTag)
    {
        switch (pwfx->wBitsPerSample)
        {
            case 8:
                for(dw = cbSize; dw; dw--)
                {
                    pData[dw-1] = 0x80;
                }
                return TRUE;

            case 16:
                for(dw = cbSize / 2; dw; dw --)
                {
                    ((LPWORD)pData)[dw-1] = 0x8000;
                }
                return TRUE;

            default:
                break;
        }
    }

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        return FALSE;
    }

    pwfx1 = ExactHeapAllocPtr(
                hHeap,
                GMEM_MOVEABLE|GMEM_SHARE,
                sizeof(PCMWAVEFORMAT));

    if(NULL == pwfx1)
    {
        ExactHeapDestroy(hHeap);
        return FALSE;
    }

    pwfx1->wFormatTag = WAVE_FORMAT_PCM;

    mmr = acmFormatSuggest(
            NULL,
            pwfx,
            pwfx1,
            sizeof(PCMWAVEFORMAT),
            ACM_FORMATSUGGESTF_WFORMATTAG);

    if(MMSYSERR_NOERROR != mmr)
    {
        ExactHeapDestroy(hHeap);
        return FALSE;
    }

    mmr = acmStreamOpen(
        &has,
        NULL,
        pwfx1,
        pwfx,
        NULL,
        0L,
        0L,
        ACM_STREAMOPENF_NONREALTIME);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamOpen failed.");

        ExactHeapDestroy(hHeap);
        return FALSE;
    }

    mmr = acmStreamSize(has,cbSize,&cbSize1,ACM_STREAMSIZEF_DESTINATION);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamSize failed.");

        acmStreamClose(has,0L);
        ExactHeapDestroy(hHeap);
        return FALSE;
    }

    pData1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize1);

    if(NULL == pData1)
    {
        acmStreamClose(has,0L);
        ExactHeapDestroy(hHeap);
        return FALSE;
    }

    switch (pwfx1->wBitsPerSample)
    {
        case 8:
            for(dw = cbSize1; dw; dw--)
            {
                pData1[dw-1] = 0x80;
            }
            break;

        case 16:
            for(dw = cbSize1 / 2; dw; dw --)
            {
                ((LPWORD)pData1)[dw-1] = 0x8000;
            }
            break;

        default:
            //
            //  Hmm... neither 8-bit nor 16-bit format?!
            //

            acmStreamClose(has,0L);
            ExactHeapDestroy(hHeap);

            return FALSE;
    }
    
    pash = ExactHeapAllocPtr(
            hHeap,
            GMEM_SHARE|GMEM_MOVEABLE,
            sizeof(ACMSTREAMHEADER));

    if(NULL == pash)
    {
        acmStreamClose(has,0L);
        ExactHeapDestroy(hHeap);

        return FALSE;
    }

    _fmemset(pash, 0, sizeof(ACMSTREAMHEADER));

    pash->cbStruct      = sizeof(ACMSTREAMHEADER);
    pash->pbSrc         = pData1;
    pash->cbSrcLength   = cbSize1;
    pash->pbDst         = pData;
    pash->cbDstLength   = cbSize;

    mmr = acmStreamPrepareHeader(has, pash, 0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamPrepareHeader failed.");

        acmStreamClose(has,0L);
        ExactHeapDestroy(hHeap);

        return FALSE;
    }

    mmr = acmStreamConvert(
            has,
            pash,
            ACM_STREAMCONVERTF_START|ACM_STREAMCONVERTF_END);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamConvert failed.");

        acmStreamUnprepareHeader(has,pash,0L);
        acmStreamClose(has,0L);
        ExactHeapDestroy(hHeap);

        return FALSE;
    }

    mmr = acmStreamUnprepareHeader(has,pash,0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamUnPrepareHeader failed.");

        acmStreamClose(has,0L);
        ExactHeapDestroy(hHeap);

        return FALSE;
    }

    mmr = acmStreamClose(has,0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        DPF(1,"acmStreamClose failed.");
        
        ExactHeapDestroy(hHeap);

        return FALSE;
    }

#ifdef DEBUG
    if(pash->cbSrcLength != pash->cbSrcLengthUsed)
    {
        DPF(1,"WARNING!!  Not all Source Data Used!!");
    }
#endif

    DPF(1,"CreateSilentBuffer successful.");

    ExactHeapDestroy(hHeap);

    return TRUE;
} // CreateSilentBuffer()


//--------------------------------------------------------------------------;
//
//  DWORD IGetNumFormats
//
//  Description:
//      This is a wrapper around the GetNumFormats library function.
//      Note: This version eliminates duplicates.  So eventually tests
//            will run considerably faster.
//
//  Arguments:
//      None.
//
//  Return (DWORD):
//      Number of different formats.
//
//  History:
//      02/10/95    Fwong       Tweaking wavetest.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL IGetNumFormats
(
    void
)
{
    DWORD           ii,jj;
    DWORD           cReal;
    static DWORD    cCount = 0L;
    DWORD           cbSize;
    BOOL            fUpdate;
    LPDWORD         pdwIndex;
    LPWAVEFORMATEX  pwfx,pwfx1,pwfx2;
    
    if(cCount != 0)
    {
        return cCount;
    }

    cbSize = gti.cbMaxFormatSize;

    cReal   = GetNumFormats();

    //
    //  Note: Building histogram of indeces for faster format lookup.
    //

    pdwIndex = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cReal * sizeof(DWORD));

    if(NULL == pdwIndex)
    {
        return 0L;
    }

    cCount = 0L;

    //
    //  Note: Since it takes considerable time to actually get the format.
    //  we will attempt to load all formats into a buffer so that we can
    //  compare them.
    //

    pwfx = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cReal * cbSize);

    if(NULL == pwfx)
    {
        pwfx1  = gti.pwfx1;
        pwfx2  = gti.pwfx2;

        for(ii = 0; ii < cReal; ii++)
        {
            GetFormat(pwfx1,cbSize,ii);

            cCount++;
            fUpdate = TRUE;

            for(jj = 0; jj < ii; jj++)
            {
                GetFormat(pwfx2,cbSize,jj);

                if(wfxCmp(pwfx1,pwfx2))
                {
                    fUpdate = FALSE;
                    cCount--;
                    break;
                }
            }

            if(fUpdate)
            {
                pdwIndex[cCount - 1] = ii;
            }
        }
    }
    else
    {
        for(ii = 0; ii < cReal; ii++)
        {
            pwfx1 = (LPWAVEFORMATEX)(((LPBYTE)(pwfx)) + ii * cbSize);

            GetFormat(pwfx1,cbSize,ii);
        }

        for(ii = 0; ii < cReal; ii++)
        {
            pwfx1 = (LPWAVEFORMATEX)(((LPBYTE)(pwfx)) + ii * cbSize);

            cCount++;
            fUpdate = TRUE;

            for(jj = 0; jj < ii; jj++)
            {
                pwfx2 = (LPWAVEFORMATEX)(((LPBYTE)(pwfx)) + jj * cbSize);

                if(wfxCmp(pwfx1,pwfx2))
                {
                    fUpdate = FALSE;
                    cCount--;
                    break;
                }
            }

            if(fUpdate)
            {
                pdwIndex[cCount - 1] = ii;
            }
        }

        ExactFreePtr(pwfx);
    }

    if(NULL != gti.pdwIndex)
    {
        ExactFreePtr(gti.pdwIndex);
    }

    gti.pdwIndex = ExactAllocPtr(
        GMEM_MOVEABLE|GMEM_SHARE,
        cCount * sizeof(DWORD));

    hmemcpy(gti.pdwIndex,pdwIndex,cCount * sizeof(DWORD));

    ExactFreePtr(pdwIndex);

    return (cCount);
} // IGetNumFormats()


BOOL FNGLOBAL IGetFormat
(
    LPWAVEFORMATEX  pwfx,
    DWORD           cbwfx,
    DWORD           dwIndex
)
{
    if((NULL == gti.pdwIndex) || (((DWORD)(-1)) == gti.pdwIndex[0]))
    {
        //
        //  Note: IGetNumFormats builds a histogram...
        //

        IGetNumFormats();
    }

    return GetFormat(pwfx,cbwfx,gti.pdwIndex[dwIndex]);
}


DWORD FNGLOBAL tstGetNumFormats
(
    void
)
{
    if(gti.fdwFlags & TESTINFOF_SPC_FMTS)
    {
        return 3*IGetNumFormats();
    }
    else
    {
        return IGetNumFormats();
    }
}

BOOL FNGLOBAL tstGetFormat
(
    LPWAVEFORMATEX  pwfx,
    DWORD           cbwfx,
    DWORD           dwIndex
)
{
    UINT    uType;
    DWORD   dwRealIndex;

    if(gti.fdwFlags & TESTINFOF_SPC_FMTS)
    {
        uType       = (UINT)(dwIndex % 3);
        dwRealIndex = dwIndex / 3;

        if(!IGetFormat(pwfx,cbwfx,dwRealIndex))
        {
            return FALSE;
        }

        switch (uType)
        {
            case 0:
                //
                //  We don't modify the format at all...
                //

                break;

            case 1:
                //
                //  We slow it down by n %.
                //

                pwfx->nSamplesPerSec =
                    ((100 - gti.uSlowPercent) * pwfx->nSamplesPerSec / 100);

                pwfx->nAvgBytesPerSec = 
                    ((100 - gti.uSlowPercent) * pwfx->nAvgBytesPerSec / 100);

                break;

            case 2:
                //
                //  We speed it up by n %
                //

                pwfx->nSamplesPerSec =
                    ((100 + gti.uFastPercent) * pwfx->nSamplesPerSec / 100);

                pwfx->nAvgBytesPerSec = 
                    ((100 + gti.uFastPercent) * pwfx->nAvgBytesPerSec / 100);

                break;
        }

        return TRUE;
    }
    else
    {
        return IGetFormat(pwfx,cbwfx,dwIndex);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\write.c ===
//--------------------------------------------------------------------------;
//
//  File: Write.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      waveOutDMABufferSize()
//      Test_waveOutWrite()
//      Test_waveOutWrite_LTDMABufferSize()
//      Test_waveOutWrite_EQDMABufferSize()
//      Test_waveOutWrite_GTDMABufferSize()
//      Test_waveOutWrite_Loop()
//      Test_waveOutWrite_Starve()
//
//  History:
//      07/18/94    Fwong
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include <memgr.h>
#include <inimgr.h>
#include <waveutil.h>
#include <TstsHell.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "Debug.h"


//--------------------------------------------------------------------------;
//
//  DWORD waveOutDMABufferSize
//
//  Description:
//      Gets the DMA buffer size for the specified device with the
//          the specified format.
//
//  Arguments:
//      UINT uDeviceID: Device ID.
//
//      LPWAVEFORMATEX pwfx: Pointer to format.
//
//  Return (DWORD):
//      DMA buffer size (in bytes), 0 if inconclusive.
//
//  History:
//      06/01/94    Fwong       For better testing.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL waveOutDMABufferSize
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx
)
{
    HWAVEOUT            hWaveOut;
    volatile LPWAVEHDR  pWaveHdr;
    volatile LPWAVEHDR  pWaveHdrStub;
    LPBYTE              pData,pDataStub;
    LPWAVEINFO          pwi;
    HANDLE              hHeap;
    DWORD               cbSize,cbDelta;
    DWORD               nBlockAlign;
    DWORD               dwTimeBuf, dwTimeComplete ;
    DWORD               dw;
    MMRESULT            mmr;

    DPF(1,"waveOutDMABufferSize");

    DisableThreadCalls();

    if(((UINT)WAVE_MAPPER) == uDeviceID)
    {
        //
        //  Not valid to get DMA buffer for wave mapper.
        //

        EnableThreadCalls();

        return 0L;
    }

    nBlockAlign = (DWORD)pwfx->nBlockAlign;

    //
    //  Allocating Heap.
    //

    hHeap = ExactHeapCreate(0);

    if(NULL == hHeap)
    {
        DPF(1,"ExactHeapCreate failed.");

        EnableThreadCalls();

        return 0L;
    }

    //
    //  Allocating memory for first wave header
    //

    pWaveHdr = ExactHeapAllocPtr(
        hHeap,
        GMEM_SHARE|GMEM_MOVEABLE,
        sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    //
    //  Allocating memory for second wave header...
    //

    pWaveHdrStub = ExactHeapAllocPtr(
        hHeap,
        GMEM_SHARE|GMEM_MOVEABLE,
        sizeof(WAVEHDR));

    if(NULL == pWaveHdrStub)
    {
        DPF(1,gszFailExactAlloc);

        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    //
    //  Allocating memory for second buffer.
    //

    pDataStub = ExactHeapAllocPtr(hHeap,GMEM_SHARE|GMEM_MOVEABLE,nBlockAlign);

    if(NULL == pDataStub)
    {
        DPF(1,gszFailExactAlloc);

        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    //
    //  Allocating memory for WAVEINFO structure.
    //

    pwi = ExactHeapAllocPtr(
        hHeap,
        GMEM_SHARE|GMEM_FIXED,
        sizeof(WAVEINFO) + 2*sizeof(DWORD));

    if(NULL == pwi)
    {
        DPF(1,gszFailExactAlloc);

        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    PageLock(pwi);

    pwi->fdwFlags   = 0L;
    pwi->dwInstance = 0L;
    pwi->dwCount    = 2;
    pwi->dwCurrent  = 0;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = waveOutOpen(
        &hWaveOut,
        uDeviceID,
        (HACK)pwfx,
        (DWORD)(FARPROC)pfnCallBack,
        0L,
        CALLBACK_FUNCTION|WAVE_ALLOWSYNC);

    if(MMSYSERR_NOERROR != mmr)
    {
        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    CreateSilentBuffer(pwfx,pDataStub,nBlockAlign);

    pWaveHdrStub->lpData         = pDataStub;
    pWaveHdrStub->dwBufferLength = nBlockAlign;
    pWaveHdrStub->dwFlags        = 0L;

    mmr = waveOutPrepareHeader(hWaveOut,pWaveHdrStub,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        waveOutClose(hWaveOut);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    pwi->dwCurrent = 0;

    waveOutPause(hWaveOut);
    waveOutWrite(hWaveOut,pWaveHdrStub,sizeof(WAVEHDR));

    dw = waveGetTime();
    waveOutRestart(hWaveOut);

    //
    //  Spinning on WHDR_DONE bit.
    //

    tstLog( VERBOSE, "spinning on WHDR_DONE bit..." ) ;

    while(!(WHDR_DONE & pWaveHdrStub->dwFlags));

    dwTimeComplete = waveGetTime() ;
    dwTimeBuf = dwTimeComplete - dw ;
    cbSize    = (pwfx->nAvgBytesPerSec * (dwTimeBuf))/1000;

    DPF(3,"cbSize = %lu",cbSize);

    if(5 >= dwTimeBuf)
    {
        DPF(
            1,
            "Elapsed time is %lu ms.  Probably not DMA based.",
            dwTimeComplete - dw);

        waveOutUnprepareHeader(hWaveOut,pWaveHdrStub,sizeof(WAVEHDR));
        waveOutClose(hWaveOut);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    //
    //  Adding slop time...
    //

    dwTimeBuf = dwTimeBuf * 3 / 2;

    //
    //  Allocating memory for data (4 * estimated buffer size)
    //

    pData = ExactHeapAllocPtr(hHeap,GMEM_SHARE|GMEM_MOVEABLE,4*cbSize);

    if(NULL == pData)
    {
        DPF(1,gszFailExactAlloc);

        waveOutUnprepareHeader(hWaveOut,pWaveHdrStub,sizeof(WAVEHDR));
        waveOutClose(hWaveOut);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    pWaveHdr->lpData         = pData;
    pWaveHdr->dwBufferLength = 2*cbSize;
    pWaveHdr->dwFlags        = 0L;

    CreateSilentBuffer(pwfx,pData,4*cbSize);

    mmr = waveOutPrepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    
    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        waveOutUnprepareHeader(hWaveOut,pWaveHdrStub,sizeof(WAVEHDR));
        waveOutClose(hWaveOut);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);
        EnableThreadCalls();

        return 0L;
    }

    cbSize  = ROUNDUP_TO_BLOCK(cbSize,nBlockAlign);
    cbDelta = ROUNDUP_TO_BLOCK(cbSize/2,nBlockAlign);

    DPF(5,"cbSize[%lu]:cbDelta[%lu]:dwTimeBuf[%lu]",cbSize,cbDelta,dwTimeBuf);

    for(;;)
    {
        pwi->dwCurrent = 0;
        
        pWaveHdr->dwBufferLength = cbSize;
        
        waveOutPause(hWaveOut);
        waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

        dw = waveGetTime();
        waveOutRestart(hWaveOut);

        //
        //  Spinning on WHDR_DONE bit.
        //

        tstLog( VERBOSE, "spinning on WHDR_DONE bit..." ) ;
        while(!(WHDR_DONE & pWaveHdr->dwFlags));

        dwTimeComplete = waveGetTime() - dw;
        
        DPF(5,"cbSize[%lu]:cbDelta[%lu]:dwTime[%lu]",cbSize,cbDelta,dwTimeComplete);
        tstLog(VERBOSE,"cbSize[%lu]:cbDelta[%lu]:dwTime[%lu]",cbSize,cbDelta,dwTimeComplete);

        if(dwTimeBuf > dwTimeComplete)
        {
            cbSize += cbDelta;
        }
        else
        {
            cbSize -= cbDelta;
        }

        if(cbDelta == nBlockAlign)
        {
            break;
        }

        cbDelta = (cbDelta / 2) + (cbDelta % 2);
        cbDelta = ROUNDUP_TO_BLOCK(cbDelta,nBlockAlign);
    }

    for(dw = dwTimeComplete;;cbSize += nBlockAlign)
    {
        pwi->dwCurrent = 0;
        
        pWaveHdr->dwBufferLength = cbSize;
        
        waveOutPause(hWaveOut);
        waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

        dw = waveGetTime();
        waveOutRestart(hWaveOut);

        //
        //  Spinning on WHDR_DONE bit.
        //

        tstLog( VERBOSE, "spinning on WHDR_DONE bit..." ) ;
        while(!(WHDR_DONE & pWaveHdr->dwFlags));

        dwTimeComplete = waveGetTime() ;
        dw = dwTimeComplete - dw;

        if(dw > dwTimeBuf)
        {
            break;
        }

        DPF( 5,"Loop1:cbSize[%lu]:dwTime[%lu]",cbSize,dw);
        tstLog(VERBOSE,"Loop1:cbSize[%lu]:dwTime[%lu]",cbSize,dw);
    }

    for(;;cbSize -= nBlockAlign)
    {
        pwi->dwCurrent = 0;
        
        pWaveHdr->dwBufferLength = cbSize;
        
        waveOutPause(hWaveOut);
        waveOutWrite(hWaveOut,pWaveHdr,sizeof(WAVEHDR));

        dw = waveGetTime();
        waveOutRestart(hWaveOut);

        //
        //  Spinning on WHDR_DONE bit.
        //

        tstLog( VERBOSE, "spinning on WHDR_DONE bit..." ) ;
        while(!(WHDR_DONE & pWaveHdr->dwFlags));

        dwTimeComplete = waveGetTime() ;
        dw = dwTimeComplete - dw;

        if(dw < dwTimeBuf)
        {
            break;
        }

        DPF(5,"Loop2:cbSize[%lu]:dwTime[%lu]",cbSize,dw);
        tstLog(VERBOSE,"Loop2:cbSize[%lu]:dwTime[%lu]",cbSize,dw);
    }

    tstLog(VERBOSE,"Loop3:cbSize[%lu]:dwTime[%lu]",cbSize,dw);

    //
    //  Cleaning up wave device...
    //

    waveOutReset(hWaveOut);
    waveOutUnprepareHeader(hWaveOut,pWaveHdr,sizeof(WAVEHDR));
    waveOutUnprepareHeader(hWaveOut,pWaveHdrStub,sizeof(WAVEHDR));
    waveOutClose(hWaveOut);

    //
    //  Misc cleanup...
    //

    DLL_WaveControl(DLL_END,NULL);
    PageUnlock(pwi);
    ExactHeapDestroy(hHeap);
    EnableThreadCalls();

    return cbSize;
} // waveOutDMABufferSize()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutWrite
//
//  Description:
//      Tests the driver functionality for waveOutWrite.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutWrite
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwhLong;
    volatile LPWAVEHDR  pwhShort;
    DWORD               dw,dw2;
    DWORD               dwTime;
    HANDLE              hHeap;
    LPWAVEINFO          pwi;
    LPVOID              pNothing;
    WAVEOUTCAPS         woc;
    MMTIME              mmt;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutWrite";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwhLong  = ExactHeapAllocPtr(
                hHeap,
                GMEM_MOVEABLE|GMEM_SHARE,
                sizeof(WAVEHDR));

    if(NULL == pwhLong)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwhShort = ExactHeapAllocPtr(
                hHeap,
                GMEM_MOVEABLE|GMEM_SHARE,
                sizeof(WAVEHDR));

    if(NULL == pwhShort)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pNothing = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,0);

    if(NULL == pNothing)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Opening device...
    //

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Preparing headers...
    //

    pwhLong->lpData             = gti.wrLong.pData;
    pwhLong->dwBufferLength     = gti.wrLong.cbSize;
    pwhLong->dwBytesRecorded    = 0L;
    pwhLong->dwUser             = 0L;
    pwhLong->dwFlags            = 0L;

    pwhShort->lpData            = gti.wrShort.pData;
    pwhShort->dwBufferLength    = gti.wrShort.cbSize;
    pwhShort->dwBytesRecorded   = 0L;
    pwhShort->dwUser            = 0L;
    pwhShort->dwFlags           = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveOutPrepareHeader(hWaveOut,pwhShort,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  verify WHDR_DONE bit gets set in WAVEHDR w/ NULL callback.
    //

    Log_TestCase("~Verifying WHDR_DONE bit gets set w/ CALLBACK_NULL");

    dw  = ((pwhShort->dwBufferLength * 1500)/gti.pwfxOutput->nAvgBytesPerSec);
    dw2 = waveGetTime();

    DisableThreadCalls();

    mmr = call_waveOutWrite(hWaveOut,pwhShort,sizeof(WAVEHDR));

    EnableThreadCalls();

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveOutWrite?
        //

        LogFail("waveOutWrite failed");

        call_waveOutReset(hWaveOut);
        call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwhShort,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    while(!(pwhShort->dwFlags & WHDR_DONE))
    {
        dwTime = waveGetTime() - dw2;

        if(dwTime > dw)
        {
            //
            //  Over 1.5 times expected time?!
            //

            LogFail("Driver has not set bit after 1 1/2 length of buffer");

            //
            //  To log pass/fail...
            //

            dw = 0;

            iResult = TST_FAIL;

            break;
        }
    }

    if(0 != dw)
    {
        LogPass("Driver set bit within 1 1/2 length of buffer");
    }

    call_waveOutReset(hWaveOut);

    //
    //  verify that writing partial buffer works.
    //  Note: we should be able to change the dwBufferLength field as long
    //        as the new one is shorter.
    //

    Log_TestCase("~Verifying that writing partial buffer works");

#pragma message(REMIND("Add more to this test case..."))
    dw  = pwhLong->dwBufferLength;
    dw2 = ROUNDUP_TO_BLOCK(dw/2,gti.pwfxOutput->nBlockAlign);

    pwhLong->dwBufferLength  = dw2;
    pwhLong->dwFlags        &= ~(WHDR_DONE);

    mmr = call_waveOutWrite(hWaveOut,pwhLong,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveOutWrite?
        //

        LogFail("waveOutWrite failed");

        call_waveOutReset(hWaveOut);
        call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hWaveOut,pwhShort,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
    call_waveOutUnprepareHeader(hWaveOut,pwhShort,sizeof(WAVEHDR));

    //
    //  verify that writing zero sized buffer works.
    //

//    Log_TestCase("Verifying writing zero sized buffer works");
//
//    pwhShort->lpData            = pNothing;
//    pwhShort->dwBufferLength    = 0L;
//    pwhShort->dwBytesRecorded   = 0L;
//    pwhShort->dwUser            = 0L;
//    pwhShort->dwFlags           = 0L;
//
//    mmr = call_waveOutPrepareHeader(hWaveOut,pwhShort,sizeof(WAVEHDR));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailWOPrepare);
//
//        call_waveOutReset(hWaveOut);
//        call_waveOutClose(hWaveOut);
//
//        ExactHeapDestroy(hHeap);
//        return TST_FAIL;
//    }
//
//    mmr = call_waveOutWrite(hWaveOut,pwhShort,sizeof(WAVEHDR));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        //
//        //  There's a problem with waveOutWrite?
//        //
//
//        LogFail("waveOutWrite failed");
//
//        call_waveOutReset(hWaveOut);
//        call_waveOutUnprepareHeader(hWaveOut,pwhShort,sizeof(WAVEHDR));
//        call_waveOutClose(hWaveOut);
//
//        ExactHeapDestroy(hHeap);
//
//        return TST_FAIL;
//    }
//    else
//    {
//        LogPass("waveOutWrite w/ a zero sized buffer succeeds");
//    }
//
//    call_waveOutReset(hWaveOut);
//    call_waveOutUnprepareHeader(hWaveOut,pwhShort,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    //
    //  For ASync ONLY...
    //

    mmr =  call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwi = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEINFO));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    dw = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Preparing headers...
    //

    pwhLong->lpData             = gti.wrLong.pData;
    pwhLong->dwBufferLength     = gti.wrLong.cbSize;
    pwhLong->dwBytesRecorded    = 0L;
    pwhLong->dwUser             = 0L;
    pwhLong->dwFlags            = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutReset(hWaveOut);
        call_waveOutClose(hWaveOut);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    if(!(WAVECAPS_SYNC & woc.dwSupport))
    {
#ifndef WIN32

        //
        //  verify that driver is in FIXED memory.
        //

        GlobalCompact((DWORD)(-1));

        Log_TestCase("~Verifying driver is in FIXED memory");

        mmr = call_waveOutWrite(hWaveOut,pwhLong,sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            //
            //  There's a problem with waveOutWrite?
            //

            LogFail("waveOutWrite failed");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            DLL_WaveControl(DLL_END,NULL);
            PageUnlock(pwi);
            ExactHeapDestroy(hHeap);

            return TST_FAIL;
        }
        
        GlobalCompact((DWORD)(-1));

        //
        //  Waiting for callback...
        //

        while(!(pwi->fdwFlags & WOM_DONE_FLAG))
        {
            SLEEP(0);
        }

        //
        //  Note: If driver is not FIXED GlobalCompact should have forced it
        //        out of memory ().
        //
        //  If it gets this far, it passes.
        //

        LogPass("Parts of driver properly marked as FIXED");

        waveOutReset(hWaveOut);

        pwi->dwInstance = ~dw;
        pwi->fdwFlags   = 0L;

#endif  //  WIN32

        //
        //  verify that driver does not mark buffer done early.
        //

        Log_TestCase("~Verifying that driver does not mark buffer done early");

        call_waveOutPause(hWaveOut);

        pwhLong->dwFlags &= ~(WHDR_DONE);

        mmt.wType = TIME_BYTES;

        call_waveOutWrite(hWaveOut,pwhLong,sizeof(WAVEHDR));
        waveOutRestart(hWaveOut);

        while(!(pwhLong->dwFlags & WHDR_DONE));
        
        mmr = waveOutGetPosition(hWaveOut,&mmt,sizeof(MMTIME));

        if(mmt.u.cb == pwhLong->dwBufferLength)
        {
            LogPass("Driver does not mark buffer done early");
        }
        else
        {
            LogFail("Driver marks buffer done early");
        }

        waveOutReset(hWaveOut);

        pwi->dwInstance = ~dw;
        pwi->fdwFlags   = 0L;

        //
        //  verify that writing same buffer multiple times fails.
        //

        Log_TestCase("~Verifying writing same buffer fails");

        mmr = call_waveOutWrite(hWaveOut,pwhLong,sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            //
            //  There's a problem with waveOutWrite?
            //

            LogFail("waveOutWrite failed");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            DLL_WaveControl(DLL_END,NULL);
            PageUnlock(pwi);
            ExactHeapDestroy(hHeap);

            return TST_FAIL;
        }

        mmr = call_waveOutWrite(hWaveOut,pwhLong,sizeof(WAVEHDR));

        if(WAVERR_STILLPLAYING != mmr)
        {
            LogFail("waveOutWrite for 2nd buffer did not return "
                "WAVERR_STILLPLAYING");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("waveOutWrite returned WAVERR_STILLPLAYING for 2nd buffer");
        }

        //
        //  verify that WHDR_INQUEUE bit is set (before callback).
        //

        Log_TestCase("~Verifying WHDR_INQUEUE bit is set (before callback)");

        if(pwhLong->dwFlags & WHDR_INQUEUE)
        {
            if(pwi->fdwFlags & WOM_DONE_FLAG)
            {
                LogFail("WOM_DONE callback occured.  Test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                LogPass("WHDR_INQUEUE bit set before callback");
            }
        }
        else
        {
            if(pwi->fdwFlags & WOM_DONE_FLAG)
            {
                LogFail("WOM_DONE callback occured.  Test inconclusive");
            }
            else
            {
                LogFail("WHDR_INQUEUE bit not set before callback");
            }

            iResult = TST_FAIL;
        }

        //
        //  verify that WHDR_DONE bit is clear (before callback).
        //

        Log_TestCase("~Verifying that WHDR_DONE bit is clear (before callback)");

        if(pwhLong->dwFlags & WHDR_DONE)
        {
            if(pwi->fdwFlags & WOM_DONE_FLAG)
            {
                LogFail("WOM_DONE callback occured.  Test inconclusive");
            }
            else
            {
                LogFail("WHDR_DONE bit set before callback");
            }

            iResult = TST_FAIL;
        }
        else
        {
            if(pwi->fdwFlags & WOM_DONE_FLAG)
            {
                LogFail("WOM_DONE callback occured.  Test inconclusive");

                iResult = TST_FAIL;
            }
            else
            {
                LogPass("WHDR_DONE bit not set before callback");
            }
        }
    }
    else
    {
        //
        //  Device is synchronous...
        //

        mmr = call_waveOutWrite(hWaveOut,pwhLong,sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            //
            //  There's a problem with waveOutWrite?
            //

            LogFail("waveOutWrite failed");

            call_waveOutReset(hWaveOut);
            call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
            call_waveOutClose(hWaveOut);

            DLL_WaveControl(DLL_END,NULL);
            PageUnlock(pwi);
            ExactHeapDestroy(hHeap);

            return TST_FAIL;
        }
    }

    //
    //  Waiting for callback...
    //

    while(!(pwi->fdwFlags & WOM_DONE_FLAG))
    {
        SLEEP(0);
    }

    //
    //  verify that WHDR_INQUEUE bit is clear (after callback).
    //

    Log_TestCase("~Verifying that WHDR_INQUEUE bit is clear (after callback)");

    if(pwhLong->dwFlags & WHDR_INQUEUE)
    {
        LogFail("WHDR_INQUEUE bit set after callback");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("WHDR_INQUEUE bit not set after callback");
    }

    //
    //  verify that WHDR_DONE bit is set (after callback).
    //

    Log_TestCase("~Verifying that WHDR_DONE bit is set (after callback)");

    if(pwhLong->dwFlags & WHDR_DONE)
    {
        LogPass("WHDR_DONE bit set after callback");
    }
    else
    {
        LogFail("WHDR_DONE bit not set after callback");

        iResult = TST_FAIL;
    }

    //
    //  verify callback returned correct dwInstance.
    //

    Log_TestCase("~Verifying that callback received correct dwInstance");

    if(dw == pwi->dwInstance)
    {
        LogPass("Callback received correct dwInstance");
    }
    else
    {
        LogFail("Callback received incorrect dwInstance");

        iResult = TST_FAIL;
    }

    //
    //  Cleaning up...
    //

    call_waveOutReset(hWaveOut);
    call_waveOutUnprepareHeader(hWaveOut,pwhLong,sizeof(WAVEHDR));
    call_waveOutClose(hWaveOut);

    DLL_WaveControl(DLL_END,NULL);
    PageUnlock(pwi);
    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveOutWrite()


int FNGLOBAL Test_waveOutWrite_LTDMABufferSize
(
    void
)
{
    HWAVEOUT                hWaveOut;
    MMRESULT                mmr;
    DWORD                   cNumBuffers;
    DWORD                   cbBufferSize;
    DWORD                   dw;
    DWORD                   dwOffset;
    DWORD                   dwTime,dwTimeOut;
    volatile LPWAVEHDR FAR *apwh;
    HANDLE                  hHeap;
    int                     iResult = TST_PASS;
    static char             szTestName[] = "waveOutWrite (Less than DMA buffer size)";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Dealing with DMA buffer size.
    //

    cbBufferSize = waveOutDMABufferSize(gti.uOutputDevice,gti.pwfxOutput);

    if(0 == cbBufferSize)
    {
        //
        //  Unable to determine DMA buffer size; using 1/16 second.
        //

        dw           = (gti.pwfxOutput->nAvgBytesPerSec / 16);
        cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxOutput->nBlockAlign);

        tstLog(
            TERSE,
            "Not able to ascertain DMA buffer size.  Using %lu bytes.",
            cbBufferSize);
    }
    else
    {
        tstLog(
            TERSE,
            "Estimated DMA buffer size is: %lu bytes.",
            cbBufferSize);
    }

    dw = GetIniDWORD(szTestName,gszRatio,0x0000c000);

    tstLog(VERBOSE,"Ratio to buffer size is " RATIO_FORMAT ".", RATIO(dw));

    if(0x10000 < dw)
    {
        LogFail("Ratio is not less than 1.00");

        return TST_FAIL;
    }

    dw = (cbBufferSize * dw) / 0x10000;

    cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxOutput->nBlockAlign);

    tstLog(VERBOSE,"New buffer size is: %lu bytes",cbBufferSize);

    //
    //  Allocating heap.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for wave headers
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);
    dw          = cNumBuffers * sizeof(LPWAVEHDR);
    apwh        = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,dw);

    if(NULL == apwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1] = ExactHeapAllocPtr(
                        hHeap,
                        GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR));

        if(NULL == apwh[dw-1])
        {
            //
            //  Allocating memory failed.
            //

            LogFail(gszFailNoMem);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    if (cbBufferSize > gti.wrLong.cbSize)
    {
        LogFail("Buffer size too big, no resources that size");

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Setting up wave headers contents and preparing.
    //

    dwOffset = 0;

    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1]->lpData          = (LPBYTE)(&gti.wrLong.pData[dwOffset]);
        apwh[dw-1]->dwBufferLength  = cbBufferSize;
        apwh[dw-1]->dwBytesRecorded = 0L;
        apwh[dw-1]->dwUser          = 0L;
        apwh[dw-1]->dwFlags         = 0L;
        apwh[dw-1]->dwLoops         = 0L;
        apwh[dw-1]->lpNext          = NULL;
        apwh[dw-1]->reserved        = 0L;

        DPF(5,"dwOffset: %lu",dwOffset);

        dwOffset += cbBufferSize;
        dwOffset  = ((dwOffset + cbBufferSize) > gti.wrLong.cbSize)?0:dwOffset;

        mmr = call_waveOutPrepareHeader(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            for(;dw < cNumBuffers;dw++)
            {
                call_waveOutUnprepareHeader(hWaveOut,apwh[dw],sizeof(WAVEHDR));
            }

            call_waveOutClose(hWaveOut);

            LogFail(gszFailWOPrepare);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    //
    //  Outputing...
    //

    call_waveOutPause(hWaveOut);

    for(dw = cNumBuffers; dw; dw--)
    {
        call_waveOutWrite(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));
    }

    call_waveOutRestart(hWaveOut);

    dwTime = waveGetTime();

    //
    //  Unpreparing...
    //

    dwTimeOut = cNumBuffers * cbBufferSize * 2000 /
                (gti.pwfxOutput->nAvgBytesPerSec);

    for(dw = cNumBuffers; dw; dw--)
    {
//        while(!(apwh[dw-1]->dwFlags & WHDR_DONE));
        while(!(apwh[dw-1]->dwFlags & WHDR_DONE))
        {
            if((dwTime + dwTimeOut) < waveGetTime())
            {
                DPF(3,"TimeOut at: %lu",waveGetTime());
                break;
            }
        }

        call_waveOutUnprepareHeader(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));
    }

    //
    //  Cleaning up...
    //

    call_waveOutReset(hWaveOut);
    call_waveOutClose(hWaveOut);

    //
    //  Freeing memory...
    //

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveOutWrite_LTDMABufferSize()


int FNGLOBAL Test_waveOutWrite_EQDMABufferSize
(
    void
)
{
    HWAVEOUT                hWaveOut;
    MMRESULT                mmr;
    DWORD                   cNumBuffers;
    DWORD                   cbBufferSize;
    DWORD                   dw;
    DWORD                   dwOffset;
    volatile LPWAVEHDR FAR *apwh;
    HANDLE                  hHeap;
    int                     iResult = TST_PASS;
    static char             szTestName[] = "waveOutWrite (DMA buffer size)";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Dealing with DMA buffer size.
    //

    cbBufferSize = waveOutDMABufferSize(gti.uOutputDevice,gti.pwfxOutput);

    if(0 == cbBufferSize)
    {
        //
        //  Unable to determine DMA buffer size; using 1/16 second.
        //

        dw           = (gti.pwfxOutput->nAvgBytesPerSec / 16);
        cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxOutput->nBlockAlign);

        tstLog(
            TERSE,
            "Not able to ascertain DMA buffer size.  Using %lu bytes.",
            cbBufferSize);
    }
    else
    {
        tstLog(
            TERSE,
            "Estimated DMA buffer size is: %lu bytes.",
            cbBufferSize);
    }

    //
    //  Allocating heap.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for wave headers
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);
    dw          = cNumBuffers * sizeof(LPWAVEHDR);
    apwh        = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,dw);

    if(NULL == apwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1] = ExactHeapAllocPtr(
                        hHeap,
                        GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR));

        if(NULL == apwh[dw-1])
        {
            //
            //  Allocating memory failed.
            //

            LogFail(gszFailNoMem);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    if (cbBufferSize > gti.wrLong.cbSize)
    {
        LogFail("Buffer size too big, no resources that size");

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Setting up wave headers contents and preparing.
    //

    dwOffset = 0;
    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1]->lpData          = (LPBYTE)(&gti.wrLong.pData[dwOffset]);
        apwh[dw-1]->dwBufferLength  = cbBufferSize;
        apwh[dw-1]->dwBytesRecorded = 0L;
        apwh[dw-1]->dwUser          = 0L;
        apwh[dw-1]->dwFlags         = 0L;
        apwh[dw-1]->dwLoops         = 0L;
        apwh[dw-1]->lpNext          = NULL;
        apwh[dw-1]->reserved        = 0L;

        DPF(5,"dwOffset: %lu",dwOffset);

        dwOffset += cbBufferSize;
        dwOffset  = ((dwOffset + cbBufferSize) > gti.wrLong.cbSize)?0:dwOffset;

        mmr = call_waveOutPrepareHeader(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            for(;dw < cNumBuffers;dw++)
            {
                call_waveOutUnprepareHeader(hWaveOut,apwh[dw],sizeof(WAVEHDR));
            }

            call_waveOutClose(hWaveOut);

            LogFail(gszFailWOPrepare);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    //
    //  Outputing...
    //

    call_waveOutPause(hWaveOut);

    for(dw = cNumBuffers; dw; dw--)
    {
        call_waveOutWrite(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));
    }

    call_waveOutRestart(hWaveOut);

    //
    //  Unpreparing...
    //

    for(dw = cNumBuffers; dw; dw--)
    {
        while(!(apwh[dw-1]->dwFlags & WHDR_DONE));

        call_waveOutUnprepareHeader(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));
    }

    //
    //  Cleaning up...
    //

    call_waveOutReset(hWaveOut);
    call_waveOutClose(hWaveOut);

    //
    //  Freeing memory...
    //

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveOutWrite_EQDMABufferSize()


int FNGLOBAL Test_waveOutWrite_GTDMABufferSize
(
    void
)
{
    HWAVEOUT                hWaveOut;
    MMRESULT                mmr;
    DWORD                   cNumBuffers;
    DWORD                   cbBufferSize;
    DWORD                   dw;
    DWORD                   dwOffset;
    volatile LPWAVEHDR FAR *apwh;
    HANDLE                  hHeap;
    int                     iResult = TST_PASS;
    static char             szTestName[] = "waveOutWrite (Greater than DMA"
                                " buffer size)";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Dealing with DMA buffer size.
    //

    cbBufferSize = waveOutDMABufferSize(gti.uOutputDevice,gti.pwfxOutput);

    if(0 == cbBufferSize)
    {
        //
        //  Unable to determine DMA buffer size; using 1/16 second.
        //

        dw           = (gti.pwfxOutput->nAvgBytesPerSec / 16);
        cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxOutput->nBlockAlign);

        tstLog(
            TERSE,
            "Not able to ascertain DMA buffer size.  Using %lu bytes.",
            cbBufferSize);
    }
    else
    {
        tstLog(
            TERSE,
            "Estimated DMA buffer size is: %lu bytes.",
            cbBufferSize);
    }

    dw = GetIniDWORD(szTestName,gszRatio,0x00014000);

    tstLog(VERBOSE,"Ratio to buffer size is " RATIO_FORMAT ".", RATIO(dw));

    if(0x10000 > dw)
    {
        LogFail("Ratio is not greater than 1.00");

        return TST_FAIL;
    }

    dw = (cbBufferSize * dw) / 0x10000;

    cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxOutput->nBlockAlign);

    tstLog(VERBOSE,"New buffer size is: %lu bytes",cbBufferSize);

    //
    //  Allocating heap.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for wave headers
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);
    dw          = cNumBuffers * sizeof(LPWAVEHDR);
    apwh        = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,dw);

    if(NULL == apwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1] = ExactHeapAllocPtr(
                        hHeap,
                        GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR));

        if(NULL == apwh[dw-1])
        {
            //
            //  Allocating memory failed.
            //

            LogFail(gszFailNoMem);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    if (cbBufferSize > gti.wrLong.cbSize)
    {
        LogFail("Buffer size too big, no resources that size");

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Setting up wave headers contents and preparing.
    //

    dwOffset = 0;
    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1]->lpData          = (LPBYTE)(&gti.wrLong.pData[dwOffset]);
        apwh[dw-1]->dwBufferLength  = cbBufferSize;
        apwh[dw-1]->dwBytesRecorded = 0L;
        apwh[dw-1]->dwUser          = 0L;
        apwh[dw-1]->dwFlags         = 0L;
        apwh[dw-1]->dwLoops         = 0L;
        apwh[dw-1]->lpNext          = NULL;
        apwh[dw-1]->reserved        = 0L;

        DPF(5,"dwOffset: %lu",dwOffset);

        dwOffset += cbBufferSize;
        dwOffset  = ((dwOffset + cbBufferSize) > gti.wrLong.cbSize)?0:dwOffset;

        mmr = call_waveOutPrepareHeader(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            for(;dw < cNumBuffers;dw++)
            {
                call_waveOutUnprepareHeader(hWaveOut,apwh[dw],sizeof(WAVEHDR));
            }

            call_waveOutClose(hWaveOut);

            LogFail(gszFailWOPrepare);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    //
    //  Outputing...
    //

    call_waveOutPause(hWaveOut);

    for(dw = cNumBuffers; dw; dw--)
    {
        call_waveOutWrite(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));
    }

    call_waveOutRestart(hWaveOut);

    //
    //  Unpreparing...
    //

    for(dw = cNumBuffers; dw; dw--)
    {
        while(!(WHDR_DONE & apwh[dw-1]->dwFlags));

        call_waveOutUnprepareHeader(hWaveOut,apwh[dw-1],sizeof(WAVEHDR));
    }

    //
    //  Cleaning up...
    //

    call_waveOutReset(hWaveOut);
    call_waveOutClose(hWaveOut);

    //
    //  Freeing memory...
    //

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveOutWrite_GTDMABufferSize()


int FNGLOBAL Test_waveOutWrite_Loop
(
    void
)
{
#if 1
    return TST_TNYI;
#else
    HWAVEOUT            hwo;
    MMRESULT            mmr;
    LPWAVEHDR volatile  pwh1, pwh2, pwh3, pwh4;
    HANDLE              hHeap;
    DWORD               cbTarget;
//    DWORD               cbActual;
    MMTIME              mmt;
    LPBYTE              pData;
    LPWAVEINFO          pwi;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutWrite looping";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    //
    //  Allocating heap.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for wave headers.
    //

    pwh1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh1)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwh2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh2)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwh3 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh3)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwh4 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh4)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Allocating memory for additional stuff...
    //

    pData = ExactHeapAllocPtr(
        hHeap,
        GMEM_MOVEABLE|GMEM_SHARE,
        gti.pwfxOutput->nBlockAlign);

    if(NULL == pData)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwi = ExactHeapAllocPtr(
        hHeap,
        GMEM_SHARE|GMEM_FIXED,
        sizeof(WAVEINFO) + 6*sizeof(DWORD));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Prepping data for function callback.
    //

    PageLock(pwi);

    pwi->fdwFlags   = 0L;
    pwi->dwInstance = 0L;
    pwi->dwCount    = 0;
    pwi->dwCurrent  = 0;

    DLL_WaveControl(DLL_INIT,pwi);

    //
    //  Doing open...
    //

    mmr = call_waveOutOpen(
        &hwo,
        gti.uOutputDevice,
        gti.pwfxOutput,
        (DWORD)(FARPROC)pfnCallBack,
        0L,
        CALLBACK_FUNCTION|WAVE_ALLOWSYNC|OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return 0L;
    }

    //
    //  Prepraring headers...
    //

    pwh1->lpData          = gti.wrShort.pData;
    pwh1->dwBufferLength  = gti.wrShort.cbSize;
    pwh1->dwBytesRecorded = 0L;
    pwh1->dwUser          = 0L;
    pwh1->dwFlags         = 0L;
    pwh1->dwLoops         = 0L;
    pwh1->lpNext          = NULL;
    pwh1->reserved        = 0L;

    mmr = call_waveOutPrepareHeader(hwo,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutClose(hwo);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return 0L;
    }

    pwh2->lpData          = gti.wrMedium.pData;
    pwh2->dwBufferLength  = gti.wrMedium.cbSize;
    pwh2->dwBytesRecorded = 0L;
    pwh2->dwUser          = 0L;
    pwh2->dwFlags         = 0L;
    pwh2->dwLoops         = 0L;
    pwh2->lpNext          = NULL;
    pwh2->reserved        = 0L;

    mmr = call_waveOutPrepareHeader(hwo,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutUnprepareHeader(hwo,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hwo);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return 0L;
    }

    pwh3->lpData          = gti.wrShort.pData;
    pwh3->dwBufferLength  = gti.wrShort.cbSize;
    pwh3->dwBytesRecorded = 0L;
    pwh3->dwUser          = 0L;
    pwh3->dwFlags         = 0L;
    pwh3->dwLoops         = 0L;
    pwh3->lpNext          = NULL;
    pwh3->reserved        = 0L;

    mmr = call_waveOutPrepareHeader(hwo,pwh3,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutUnprepareHeader(hwo,pwh2,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hwo,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hwo);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return 0L;
    }

    pwh4->lpData          = gti.wrMedium.pData;
    pwh4->dwBufferLength  = gti.wrMedium.cbSize;
    pwh4->dwBytesRecorded = 0L;
    pwh4->dwUser          = 0L;
    pwh4->dwFlags         = 0L;
    pwh4->dwLoops         = 0L;
    pwh4->lpNext          = NULL;
    pwh4->reserved        = 0L;

    mmr = call_waveOutPrepareHeader(hwo,pwh4,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutUnprepareHeader(hwo,pwh3,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hwo,pwh2,sizeof(WAVEHDR));
        call_waveOutUnprepareHeader(hwo,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hwo);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return 0L;
    }

    //
    //  verify driver correctly does 0 loops.
    //

    //
    //  verify correct number of loops are played.
    //

    //
    //  verify loops play correctly w/one buffer.
    //

    //
    //  verify loops play correctly w/ multiple buffers.
    //

    //
    //  verify loops continue correctly (after playing through one buffer).
    //

    //
    //  verify driver correctly plays two sets of loops.
    //

    //
    //  verify WHDR_BEGINLOOP is checked at waveOutWrite time.
    //

    //
    //  verify WHDR_ENDLOOP is checked at waveOutWrite time.
    //

    //
    //  verify WAVEHDR.dwLoops is checked at waveOutWrite time.
    //

    //
    //  verify driver correctly follows one WHDR_BEGINLOOP.
    //

    //
    //  verify only one callback is done per WAVEHDR.
    //

    //
    //  verify driver correctly loops after first buffer is done.
    //

    //
    //  verify driver correctly plays > 64K loops.
    //

    DLL_WaveControl(DLL_END,NULL);
    PageUnlock(pwi);
    ExactHeapDestroy(hHeap);

    return iResult;
#endif
} // Test_waveOutWrite_Loop()


//--------------------------------------------------------------------------;
//
//  int Test_waveOutWrite_Starve
//
//  Description:
//      Tests the driver for correct behavior when starved.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      11/16/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveOutWrite_Starve
(
    void
)
{
    HWAVEOUT            hWaveOut;
    MMRESULT            mmr;
    DWORD               dw;
    DWORD               dwTime;
    volatile LPWAVEHDR  pwh1;
    volatile LPWAVEHDR  pwh2;
    HANDLE              hHeap;
    WAVEOUTCAPS         woc;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveOutWrite buffer starvation";

    Log_TestName(szTestName);

    if(0 == waveOutGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoOutDevs);

        return iResult;
    }

    mmr = call_waveOutGetDevCaps(gti.uOutputDevice,&woc,sizeof(WAVEOUTCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        return TST_FAIL;
    }

    if(woc.dwSupport & WAVECAPS_SYNC)
    {
        LogPass("Device is synchronous.  Test not valid");

        return TST_PASS;
    }

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    dw = waveOutDMABufferSize(gti.uOutputDevice,gti.pwfxOutput);

    if(0 == dw)
    {
        dw = gti.pwfxOutput->nAvgBytesPerSec / 16;
        dw = ROUNDUP_TO_BLOCK(dw,gti.pwfxOutput->nBlockAlign);
    }

    //
    //  Calculating number of milliseconds.
    //

    dw = dw * 1000 / gti.pwfxOutput->nAvgBytesPerSec;

    mmr = call_waveOutOpen(
        &hWaveOut,
        gti.uOutputDevice,
        gti.pwfxOutput,
        0L,
        0L,
        OUTPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh1->lpData          = gti.wrShort.pData;
    pwh1->dwBufferLength  = gti.wrShort.cbSize;
    pwh1->dwBytesRecorded = 0L;
    pwh1->dwUser          = 0L;
    pwh1->dwFlags         = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutClose(hWaveOut);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwh2->lpData          = gti.wrMedium.pData;
    pwh2->dwBufferLength  = gti.wrMedium.cbSize;
    pwh2->dwBytesRecorded = 0L;
    pwh2->dwUser          = 0L;
    pwh2->dwFlags         = 0L;

    mmr = call_waveOutPrepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
        call_waveOutClose(hWaveOut);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    for(;dw;dw /= 2)
    {
        tstLog(VERBOSE,"Using %lu ms silence intervals.",dw);

        //
        //  Writing first buffer...
        //

        pwh1->dwFlags &= ~(WHDR_DONE);
        call_waveOutWrite(hWaveOut,pwh1,sizeof(WAVEHDR));

        //
        //  Waiting (Spinning on DONE bit)...
        //

        while(!(pwh1->dwFlags & WHDR_DONE));

        //
        //  Starving...
        //

        dwTime = waveGetTime();
        while(dw > (waveGetTime() - dwTime));

        //
        //  Clearing done bit...
        //

        pwh2->dwFlags &= ~(WHDR_DONE);
        call_waveOutWrite(hWaveOut,pwh2,sizeof(WAVEHDR));

        //
        //  Waiting (Spinning on DONE bit)...
        //

        while(!(pwh2->dwFlags & WHDR_DONE));

        //
        //  Starving...
        //

        dwTime = waveGetTime();
        while(dw > (waveGetTime() - dwTime));

        //
        //  Clearing done bit...
        //

        pwh1->dwFlags &= ~(WHDR_DONE);
        call_waveOutWrite(hWaveOut,pwh1,sizeof(WAVEHDR));

        //
        //  Waiting (Spinning on DONE bit)...
        //

        tstLog(VERBOSE,"<< Polling WHDR_DONE bit in header. >>");

        while(!(pwh1->dwFlags & WHDR_DONE));

        call_waveOutReset(hWaveOut);
    }

    call_waveOutUnprepareHeader(hWaveOut,pwh1,sizeof(WAVEHDR));
    call_waveOutUnprepareHeader(hWaveOut,pwh2,sizeof(WAVEHDR));

    call_waveOutClose(hWaveOut);

    ExactHeapDestroy(hHeap);

    return TST_PASS;
} // Test_waveOutWrite_Starve()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\wrappers.c ===
//--------------------------------------------------------------------------;
//
//  File: Wrappers.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      ThreadFunc()
//      DisableThreadCalls()
//      EnableThreadCalls()
//      call_waveOutGetDevCaps()
//      call_waveOutGetVolume()
//      call_waveOutSetVolume()
//      call_waveOutOpen()
//      call_waveOutClose()
//      call_waveOutPrepareHeader()
//      call_waveOutUnprepareHeader()
//      call_waveOutWrite()
//      call_waveOutPause()
//      call_waveOutRestart()
//      time_waveOutRestart()
//      call_waveOutReset()
//      call_waveOutBreakLoop()
//      call_waveOutGetPosition()
//      time_waveOutGetPosition()
//      call_waveOutGetPitch()
//      call_waveOutSetPitch()
//      call_waveOutGetPlaybackRate()
//      call_waveOutSetPlaybackRate()
//      call_waveOutGetID()
//      call_waveInGetDevCaps()
//      call_waveInOpen()
//      call_waveInClose()
//      call_waveInPrepareHeader()
//      call_waveInUnprepareHeader()
//      call_waveInAddBuffer()
//      call_waveInStart()
//      time_waveInStart()
//      call_waveInStop()
//      call_waveInReset()
//      call_waveInGetPosition()
//      time_waveInGetPosition()
//      call_waveInGetID()
//
//  History:
//      12/01/93    Fwong
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "AppPort.h"
#include <TstsHell.h>
#include "WaveTest.h"
#ifdef  WIN32
#include "Thread.h"
#endif  //  WIN32
#include "Debug.h"


#ifdef  WIN32

//--------------------------------------------------------------------------;
//
//  DWORD ThreadFunc
//
//  Description:
//      Thread function to call API's on seperate threads.
//
//  Arguments:
//      LPVOID pThreadParam: Pointer to WAVETHREADX structure.
//
//  Return (DWORD):
//      As per function prototype.
//
//  History:
//      12/03/94    Fwong       Added for some multi-threaded support.
//
//--------------------------------------------------------------------------;

DWORD WINAPI ThreadFunc
(
    LPVOID  pThreadParam
)
{
    LPWAVETHREADBASE    pwtb = (LPWAVETHREADBASE)pThreadParam;
    LPWAVETHREADSTRUCT  pwts = (LPWAVETHREADSTRUCT)pThreadParam;
    LPWAVETHREADATTR    pwta = (LPWAVETHREADATTR)pThreadParam;
    LPWAVETHREADOPEN    pwto = (LPWAVETHREADOPEN)pThreadParam;
    LPWAVETHREADHANDLE  pwth = (LPWAVETHREADHANDLE)pThreadParam;

    DPF(4,"ThreadFunc time: %lu ms.",waveGetTime());

    pwtb->dwTime    = waveGetTime();

    switch (pwtb->uType)
    {
        case ID_WAVEOUTGETDEVCAPS:
            pwtb->mmr = waveOutGetDevCaps(
                (UINT)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEOUTGETVOLUME:
            pwtb->mmr = waveOutGetVolume(
                (VOLCTRL)pwta->hWave,
                (LPDWORD)(pwta->dw));

            break;

        case ID_WAVEOUTSETVOLUME:
            pwtb->mmr = waveOutSetVolume((VOLCTRL)pwta->hWave,pwta->dw);

            break;

        case ID_WAVEOUTOPEN:
            pwtb->mmr = waveOutOpen(
                pwto->phWave,
                pwto->uDeviceID,
                (HACK)pwto->pwfx,
                pwto->dwCallback,
                pwto->dwInstance,
                pwto->fdwFlags);

            break;

        case ID_WAVEOUTCLOSE:
            pwtb->mmr = waveOutClose((HWAVEOUT)pwth->hWave);

            break;

        case ID_WAVEOUTPREPAREHEADER:
            pwtb->mmr = waveOutPrepareHeader(
                (HWAVEOUT)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEOUTUNPREPAREHEADER:
            pwtb->mmr = waveOutUnprepareHeader(
                (HWAVEOUT)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEOUTWRITE:
            pwtb->mmr = waveOutWrite(
                (HWAVEOUT)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEOUTPAUSE:
            pwtb->mmr = waveOutPause((HWAVEOUT)pwth->hWave);

            break;

        case ID_WAVEOUTRESTART:
            pwtb->mmr = waveOutRestart((HWAVEOUT)pwth->hWave);

            break;

        case ID_WAVEOUTRESET:
            pwtb->mmr = waveOutReset((HWAVEOUT)pwth->hWave);

            break;

        case ID_WAVEOUTBREAKLOOP:
            pwtb->mmr = waveOutBreakLoop((HWAVEOUT)pwth->hWave);

            break;

        case ID_WAVEOUTGETPOSITION:
            pwtb->mmr = waveOutGetPosition(
                (HWAVEOUT)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEOUTGETPITCH:
            pwtb->mmr = waveOutGetPitch(pwta->hWave,(LPDWORD)(pwta->dw));

            break;

        case ID_WAVEOUTSETPITCH:
            pwtb->mmr = waveOutSetPitch(pwta->hWave,pwta->dw);

            break;

        case ID_WAVEOUTGETPLAYBACKRATE:
            pwtb->mmr = waveOutGetPlaybackRate(pwta->hWave,(LPDWORD)(pwta->dw));

            break;

        case ID_WAVEOUTSETPLAYBACKRATE:
            pwtb->mmr = waveOutSetPlaybackRate(pwta->hWave,pwta->dw);

            break;

        case ID_WAVEOUTGETID:
            pwtb->mmr = waveOutGetID(pwta->hWave,(LPUINT)(pwta->dw));

            break;

        case ID_WAVEINGETDEVCAPS:
            pwtb->mmr = waveInGetDevCaps(
                (UINT)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEINOPEN:
            pwtb->mmr = waveInOpen(
                (LPHWAVEIN)pwto->phWave,
                pwto->uDeviceID,
                pwto->pwfx,
                pwto->dwCallback,
                pwto->dwInstance,
                pwto->fdwFlags);

            break;

        case ID_WAVEINCLOSE:
            pwtb->mmr = waveInClose((HWAVEIN)pwth->hWave);

            break;

        case ID_WAVEINPREPAREHEADER:
            pwtb->mmr = waveInPrepareHeader(
                (HWAVEIN)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEINUNPREPAREHEADER:
            pwtb->mmr = waveInUnprepareHeader(
                (HWAVEIN)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEINADDBUFFER:
            pwtb->mmr = waveInAddBuffer(
                (HWAVEIN)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEINSTART:
            pwtb->mmr = waveInStart((HWAVEIN)pwth->hWave);

            break;

        case ID_WAVEINSTOP:
            pwtb->mmr = waveInStop((HWAVEIN)pwth->hWave);

            break;

        case ID_WAVEINRESET:
            pwtb->mmr = waveInReset((HWAVEIN)pwth->hWave);

            break;

        case ID_WAVEINGETPOSITION:
            pwtb->mmr = waveInGetPosition(
                (HWAVEIN)pwts->hWave,
                pwts->pStruct,
                pwts->cbSize);

            break;

        case ID_WAVEINGETID:
            pwtb->mmr = waveInGetID((HWAVEIN)pwta->hWave,(LPUINT)(pwta->dw));

            break;
    }

    pwtb->dwTime    = waveGetTime() - pwtb->dwTime;
    pwtb->fdwFlags |= THREADFLAG_DONE;

    return THREAD_DONE;
} // ThreadFunc()

#endif  //  WIN32


void FNGLOBAL DisableThreadCalls
(
    void
)
{
    gti.fdwFlags |= (gti.fdwFlags & TESTINFOF_THREAD)?TESTINFOF_THREADAUX:0;

    gti.fdwFlags &= (~TESTINFOF_THREAD);
}


void FNGLOBAL EnableThreadCalls
(
    void
)
{
    gti.fdwFlags |= (gti.fdwFlags & TESTINFOF_THREADAUX)?TESTINFOF_THREAD:0;

    gti.fdwFlags &= (~TESTINFOF_THREADAUX);
}


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutGetDevCaps
//
//  Description:
//      Wrapper function for waveOutGetDevCaps.
//
//  Arguments:
//      UINT uDeviceID: Identical to API.
//
//      LPWAVEOUTCAPS lpCaps: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutGetDevCaps
(
    UINT            uDeviceID,
    LPWAVEOUTCAPS   lpCaps,
    UINT            uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutGetDevCaps";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"uDeviceID: %u",uDeviceID);
    tstLog(VERBOSE,"   lpCaps: " PTR_FORMAT,MAKEPTR(lpCaps));
    tstLog(VERBOSE,"    uSize: %u",uSize);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEOUTGETDEVCAPS;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)uDeviceID;
        wts.pStruct      = (LPVOID)lpCaps;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutGetDevCaps(uDeviceID,lpCaps,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutGetDevCaps(uDeviceID,lpCaps,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    if(MMSYSERR_NOERROR == mmr)
    {
        tstBeginSection(NULL);
        tstLog(VERBOSE,"");

        Log_WAVEOUTCAPS(lpCaps);

        tstEndSection();
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutGetDevCaps()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutGetVolume
//
//  Description:
//      Wrapper function for waveOutGetVolume.
//
//  Arguments:
//      UINT uDeviceID: Identical to API.
//
//      LPDWORD lpdwVolume: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutGetVolume
(
    UINT    uDeviceID,
    LPDWORD lpdwVolume
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutGetVolume";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE," uDeviceID: %u",uDeviceID);
    tstLog(VERBOSE,"lpdwVolume: " PTR_FORMAT,MAKEPTR(lpdwVolume));

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEOUTGETVOLUME;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = (HWAVEOUT)uDeviceID;
        wta.dw           = (DWORD)lpdwVolume;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutGetVolume((VOLCTRL)uDeviceID,lpdwVolume);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutGetVolume((VOLCTRL)uDeviceID,lpdwVolume);
        dwTime = waveGetTime() - dwTime;
    }

    if(MMSYSERR_NOERROR == mmr)
    {
        tstBeginSection(NULL);
        tstLog(VERBOSE,"");

        if(Volume_SupportStereo(uDeviceID))
        {
            tstLog(VERBOSE," Left: 0x%04x",LOWORD(*lpdwVolume));
            tstLog(VERBOSE,"Right: 0x%04x",HIWORD(*lpdwVolume));
        }
        else
        {
            tstLog(VERBOSE,"Volume: 0x%04x",LOWORD(*lpdwVolume));
        }

        tstEndSection();
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutGetVolume()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutSetVolume
//
//  Description:
//      Wrapper function for waveOutSetVolume.
//
//  Arguments:
//      UINT uDeviceID: Identical to API.
//
//      DWORD dwVolume: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutSetVolume
(
    UINT    uDeviceID,
    DWORD   dwVolume
)
{
    MMRESULT    mmr;
    char        szFnName[] = "waveOutSetVolume";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE," uDeviceID: %u",uDeviceID);
    tstLog(VERBOSE,"  dwVolume: 0x%08lx",dwVolume);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEOUTSETVOLUME;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = (HWAVEOUT)uDeviceID;
        wta.dw           = dwVolume;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutSetVolume((VOLCTRL)uDeviceID,dwVolume);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutSetVolume((VOLCTRL)uDeviceID,dwVolume);
        dwTime = waveGetTime() - dwTime;
    }

    if(MMSYSERR_NOERROR == mmr)
    {
        tstBeginSection(NULL);
        tstLog(VERBOSE,"");

        if(Volume_SupportStereo(uDeviceID))
        {
            tstLog(VERBOSE," Left: 0x%04x",LOWORD(dwVolume));
            tstLog(VERBOSE,"Right: 0x%04x",HIWORD(dwVolume));
        }
        else
        {
            tstLog(VERBOSE,"Volume: 0x%04x",LOWORD(dwVolume));
        }

        tstEndSection();
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutSetVolume()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutOpen
//
//  Description:
//      Wrapper function for waveOutOpen.
//
//  Arguments:
//      LPHWAVEOUT lphWaveOut: Identical to API.
//
//      UINT uDeviceID: Identical to API.
//
//      LPWAVEFORMATEX pwfx: Identical to API.
//
//      DWORD dwCallback: Identical to API.
//
//      DWORD dwInstance: Identical to API.
//
//      DWORD dwFlags: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutOpen
(
    LPHWAVEOUT      lphWaveOut,
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    DWORD           dwCallback,
    DWORD           dwInstance,
    DWORD           dwFlags
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutOpen";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADOPEN      wto;

        wto.wtb.uType    = ID_WAVEOUTOPEN;
        wto.wtb.fdwFlags = 0L;
        wto.phWave       = lphWaveOut; 
        wto.uDeviceID    = uDeviceID; 
        wto.pwfx         = pwfx; 
        wto.dwCallback   = dwCallback; 
        wto.dwInstance   = dwInstance; 
        wto.fdwFlags     = dwFlags; 

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wto,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutOpen(
                        lphWaveOut,
                        uDeviceID,
                        (HACK)pwfx,
                        dwCallback,
                        dwInstance,
                        dwFlags);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wto);

            dwTime = wto.wtb.dwTime;
            mmr    = wto.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutOpen(
                    lphWaveOut,
                    uDeviceID,
                    (HACK)pwfx,
                    dwCallback,
                    dwInstance,
                    dwFlags);
        dwTime = waveGetTime() - dwTime;
    }

    tstLog(VERBOSE,"lphWaveOut: " PTR_FORMAT,MAKEPTR(lphWaveOut));

//    tstLog(VERBOSE,"lphWaveOut: 0x%04x:%04x",MAKEPTR(lphWaveOut));
//    tstLog(VERBOSE,"lphWaveOut: " PTR_FORMAT,MAKEPTR((LPVOID)lphWaveOut));
    
    if(!IsBadReadPtr(lphWaveOut,sizeof(HWAVE)))
    {
        tstLog(VERBOSE,"  hWaveOut: " UINT_FORMAT,((UINT)(*lphWaveOut)));
    }

    tstLog(VERBOSE," uDeviceID: %u",uDeviceID);
    tstLog(VERBOSE,"      pwfx: " PTR_FORMAT,MAKEPTR(pwfx));

//    tstLog(VERBOSE,"      pwfx: " PTR_FORMAT,MAKEPTR(pwfx));
//    tstLog(VERBOSE,"      pwfx: 0x%04x:%04x",MAKEPTR(pwfx));

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEFORMATEX(pwfx);
    tstEndSection();
    tstLog(VERBOSE,"");

    tstLog(VERBOSE,"dwCallback: 0x%08lx",dwCallback);
    tstLog(VERBOSE,"dwInstance: 0x%08lx",dwInstance);

    Enum_waveOpen_Flags(dwFlags,10);

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutOpen()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutClose
//
//  Description:
//      Wrapper function for waveOutClose.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutClose
(
    HWAVEOUT    hWaveOut
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutClose";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEOUTCLOSE;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveOut;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutClose(hWaveOut);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutClose(hWaveOut);
        dwTime = waveGetTime() - dwTime;
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutClose()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutPrepareHeader
//
//  Description:
//      Wrapper function for waveOutPrepareHeader.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      LPWAVEHDR lpWaveOutHdr: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutPrepareHeader
(
    HWAVEOUT    hWaveOut,
    LPWAVEHDR   lpWaveOutHdr,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutPrepareHeader";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"    hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"lpWaveOutHdr: " PTR_FORMAT,MAKEPTR(lpWaveOutHdr));

    tstLog(VERBOSE,"       uSize: %u",uSize);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEOUTPREPAREHEADER;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveOut;
        wts.pStruct      = lpWaveOutHdr;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutPrepareHeader(hWaveOut,lpWaveOutHdr,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutPrepareHeader(hWaveOut,lpWaveOutHdr,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEHDR(lpWaveOutHdr);
    tstEndSection();

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutPrepareHeader()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutUnprepareHeader
//
//  Description:
//      Wrapper function for waveOutUnprepareHeader.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      LPWAVEHDR lpWaveOutHdr: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutUnprepareHeader
(
    HWAVEOUT    hWaveOut,
    LPWAVEHDR   lpWaveOutHdr,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutUnprepareHeader";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"    hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"lpWaveOutHdr: " PTR_FORMAT,MAKEPTR(lpWaveOutHdr));

    tstLog(VERBOSE,"       uSize: %u",uSize);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEOUTUNPREPAREHEADER;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveOut;
        wts.pStruct      = lpWaveOutHdr;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutUnprepareHeader(hWaveOut,lpWaveOutHdr,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutUnprepareHeader(hWaveOut,lpWaveOutHdr,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEHDR(lpWaveOutHdr);
    tstEndSection();

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutUnprepareHeader()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutWrite
//
//  Description:
//      Wrapper function for waveOutWrite.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      LPWAVEHDR lpWaveOutHdr: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutWrite
(
    HWAVEOUT    hWaveOut,
    LPWAVEHDR   lpWaveOutHdr,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutWrite";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"    hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"lpWaveOutHdr: " PTR_FORMAT,MAKEPTR(lpWaveOutHdr));

    tstLog(VERBOSE,"       uSize: %u",uSize);

#ifdef WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEOUTWRITE;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveOut;
        wts.pStruct      = lpWaveOutHdr;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutWrite(hWaveOut,lpWaveOutHdr,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutWrite(hWaveOut,lpWaveOutHdr,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEHDR(lpWaveOutHdr);
    tstEndSection();

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutWrite()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutPause
//
//  Description:
//      Wrapper function for waveOutPause.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutPause
(
    HWAVEOUT    hWaveOut
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutPause";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEOUTPAUSE;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveOut;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutPause(hWaveOut);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutPause(hWaveOut);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutPause()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutRestart
//
//  Description:
//      Wrapper function for waveOutRestart.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutRestart
(
    HWAVEOUT    hWaveOut
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutRestart";
    DWORD       dwTime;

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEOUTRESTART;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveOut;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutRestart(hWaveOut);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutRestart(hWaveOut);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutRestart()


//--------------------------------------------------------------------------;
//
//  MMRESULT time_waveOutRestart
//
//  Description:
//
//
//  Arguments:
//      HWAVEOUT hWaveOut LPDWORD pdwTime:
//
//  Return (MMRESULT):
//
//  History:
//      02/27/95    Fwong
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL time_waveOutRestart
(
    HWAVEOUT    hWaveOut,
    LPDWORD     pdwTime
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutRestart";
    DWORD       dwTime,dwTime2;

    dwTime   = waveGetTime();
    mmr      = waveOutRestart(hWaveOut);
    dwTime2  = waveGetTime();
    *pdwTime = (dwTime2 + dwTime) / 2;
    dwTime2  = dwTime2 - dwTime;
         
    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);

    Log_Error(szFnName,mmr,dwTime2);

    *pdwTime = dwTime;

    return mmr;
} // call_waveOutRestart()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutReset
//
//  Description:
//      Wrapper function for waveOutReset.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutReset
(
    HWAVEOUT    hWaveOut
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutReset";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEOUTRESET;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveOut;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutReset(hWaveOut);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutReset(hWaveOut);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutReset()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutBreakLoop
//
//  Description:
//      Wrapper function for waveOutBreakLoop.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutBreakLoop
(
    HWAVEOUT    hWaveOut
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutBreakLoop";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEOUTBREAKLOOP;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveOut;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutBreakLoop(hWaveOut);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutBreakLoop(hWaveOut);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutBreakLoop()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutGetPosition
//
//  Description:
//      Wrapper function for waveOutGetPosition.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      LPMMTIME lpInfo: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutGetPosition
(
    HWAVEOUT    hWaveOut,
    LPMMTIME    lpInfo,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutGetPosition";
    UINT        uQueryType;
    DWORD       dwTime;

    uQueryType = lpInfo->wType;

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEOUTGETPOSITION;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveOut;
        wts.pStruct      = lpInfo;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutGetPosition(hWaveOut,lpInfo,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutGetPosition(hWaveOut,lpInfo,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"  lpInfo: " PTR_FORMAT,MAKEPTR(lpInfo));
    tstLog(VERBOSE,"   uSize: %u\n",uSize);

    switch (uQueryType)
    {
        case TIME_MS:
            tstLog(VERBOSE,"Query wType: TIME_MS (%u)",uQueryType);
            break;

        case TIME_SAMPLES:
            tstLog(VERBOSE,"Query wType: TIME_SAMPLES (%u)",uQueryType);
            break;

        case TIME_BYTES:
            tstLog(VERBOSE,"Query wType: TIME_BYTES (%u)",uQueryType);
            break;

        case TIME_SMPTE:
            tstLog(VERBOSE,"Query wType: TIME_SMPTE (%u)",uQueryType);
            break;

        case TIME_MIDI:
            tstLog(VERBOSE,"Query wType: TIME_MIDI (%u)",uQueryType);
            break;

        case TIME_TICKS:
            tstLog(VERBOSE,"Query wType: TIME_TICKS (%u)",uQueryType);
            break;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_MMTIME(lpInfo);
    tstEndSection();
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutGetPosition()


MMRESULT FNGLOBAL time_waveOutGetPosition
(
    HWAVEOUT    hWaveOut,
    LPMMTIME    lpInfo,
    UINT        uSize,
    LPDWORD     pdwTime
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutGetPosition";
    DWORD       dwTime,dwTime2;
    UINT        uQueryType;

    uQueryType = lpInfo->wType;

    dwTime   = waveGetTime();
    mmr      = waveOutGetPosition(hWaveOut,lpInfo,uSize);
    dwTime2  = waveGetTime();
    *pdwTime = (dwTime2 + dwTime) / 2;
    dwTime2  = dwTime2 - dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"  lpInfo: " PTR_FORMAT,MAKEPTR(lpInfo));
    tstLog(VERBOSE,"   uSize: %u\n",uSize);

    switch (uQueryType)
    {
        case TIME_MS:
            tstLog(VERBOSE,"Query wType: TIME_MS (%u)",uQueryType);
            break;

        case TIME_SAMPLES:
            tstLog(VERBOSE,"Query wType: TIME_SAMPLES (%u)",uQueryType);
            break;

        case TIME_BYTES:
            tstLog(VERBOSE,"Query wType: TIME_BYTES (%u)",uQueryType);
            break;

        case TIME_SMPTE:
            tstLog(VERBOSE,"Query wType: TIME_SMPTE (%u)",uQueryType);
            break;

        case TIME_MIDI:
            tstLog(VERBOSE,"Query wType: TIME_MIDI (%u)",uQueryType);
            break;

        case TIME_TICKS:
            tstLog(VERBOSE,"Query wType: TIME_TICKS (%u)",uQueryType);
            break;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_MMTIME(lpInfo);
    tstEndSection();
         
    Log_Error(szFnName,mmr,dwTime2);

    return mmr;
} // time_waveOutGetPosition()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutGetPitch
//
//  Description:
//      Wrapper function for waveOutGetPitch.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      LPDWORD lpdwPitch: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutGetPitch
(
    HWAVEOUT    hWaveOut,
    LPDWORD     lpdwPitch
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutGetPitch";
    DWORD       dwTime;
    DWORD       dw;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE," hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"lpdwPitch: " PTR_FORMAT,MAKEPTR(lpdwPitch));

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEOUTGETPITCH;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = hWaveOut;
        wta.dw           = (DWORD)lpdwPitch;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutGetPitch(hWaveOut,lpdwPitch);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutGetPitch(hWaveOut,lpdwPitch);
        dwTime = waveGetTime() - dwTime;
    }
         
    if(MMSYSERR_NOERROR == mmr)
    {
        dw = *lpdwPitch;

        tstLog(
            VERBOSE,
            "    Pitch: %u.%03u of original.",
            HIWORD(dw),
            LOWORD(dw)*1000/0x10000);
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutGetPitch()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutSetPitch
//
//  Description:
//      Wrapper function for waveOutSetPitch.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      DWORD dwPitch: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutSetPitch
(
    HWAVEOUT    hWaveOut,
    DWORD       dwPitch
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutSetPitch";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE," dwPitch: 0x%08lx",dwPitch);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEOUTSETPITCH;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = hWaveOut;
        wta.dw           = dwPitch;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutSetPitch(hWaveOut,dwPitch);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutSetPitch(hWaveOut,dwPitch);
        dwTime = waveGetTime() - dwTime;
    }
         
    if(MMSYSERR_NOERROR == mmr)
    {
        tstLog(
            VERBOSE,
            "   Pitch: %u.%03u of original.",
            HIWORD(dwPitch),
            LOWORD(dwPitch)*1000/0x10000);
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutSetPitch()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutGetPlaybackRate
//
//  Description:
//      Wrapper function for waveOutGetPlaybackRate.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      LPDWORD lpdwRate: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutGetPlaybackRate
(
    HWAVEOUT    hWaveOut,
    LPDWORD     lpdwRate
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutGetPlaybackRate";
    DWORD       dwTime;
    DWORD       dw;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"lpdwRate: " PTR_FORMAT,MAKEPTR(lpdwRate));

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEOUTGETPLAYBACKRATE;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = hWaveOut;
        wta.dw           = (DWORD)lpdwRate;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutGetPlaybackRate(hWaveOut,lpdwRate);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutGetPlaybackRate(hWaveOut,lpdwRate);
        dwTime = waveGetTime() - dwTime;
    }
         
    if(MMSYSERR_NOERROR == mmr)
    {
        dw = *lpdwRate;

        tstLog(
            VERBOSE,
            "    Rate: %u.%03u of original.",
            HIWORD(dw),
            LOWORD(dw)*1000/0x10000);
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutGetPlaybackRate()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutSetPlaybackRate
//
//  Description:
//      Wrapper function for waveOutSetPlaybackRate.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      DWORD dwRate: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutSetPlaybackRate
(
    HWAVEOUT    hWaveOut,
    DWORD       dwRate
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutSetPlaybackRate";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"  dwRate: 0x%08lx",dwRate);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEOUTSETPLAYBACKRATE;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = hWaveOut;
        wta.dw           = dwRate;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutSetPlaybackRate(hWaveOut,dwRate);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutSetPlaybackRate(hWaveOut,dwRate);
        dwTime = waveGetTime() - dwTime;
    }
         
    if(MMSYSERR_NOERROR == mmr)
    {
        tstLog(
            VERBOSE,
            "   Rate: %u.%03u of original.",
            HIWORD(dwRate),
            LOWORD(dwRate)*1000/0x10000);
    }

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutSetPlaybackRate()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveOutGetID
//
//  Description:
//      Wrapper function for waveOutGetID.
//
//  Arguments:
//      HWAVEOUT hWaveOut: Identical to API.
//
//      LPUINT lpuDeviceID: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveOutGetID
(
    HWAVEOUT    hWaveOut,
    LPUINT      lpuDeviceID
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveOutGetID";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"   hWaveOut: " UINT_FORMAT,hWaveOut);
    tstLog(VERBOSE,"lpuDeviceID: " PTR_FORMAT,MAKEPTR(lpuDeviceID));

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEOUTGETID;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = hWaveOut;
        wta.dw           = (DWORD)lpuDeviceID;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveOutGetID(hWaveOut,lpuDeviceID);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveOutGetID(hWaveOut,lpuDeviceID);
        dwTime = waveGetTime() - dwTime;
    }

    tstLog(VERBOSE,"   DeviceID: %u",(UINT)(*lpuDeviceID));
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveOutGetID()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInGetDevCaps
//
//  Description:
//      Wrapper function for waveInGetDevCaps.
//
//  Arguments:
//      UINT uDeviceID: Identical to API.
//
//      LPWAVEINCAPS lpCaps: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInGetDevCaps
(
    UINT            uDeviceID,
    LPWAVEINCAPS    lpCaps,
    UINT            uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInGetDevCaps";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"uDeviceID: %u",uDeviceID);
    tstLog(VERBOSE,"   lpCaps: " PTR_FORMAT,MAKEPTR(lpCaps));
    tstLog(VERBOSE,"    uSize: %u",uSize);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEINGETDEVCAPS;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)uDeviceID;
        wts.pStruct      = lpCaps;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInGetDevCaps(uDeviceID,lpCaps,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInGetDevCaps(uDeviceID,lpCaps,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    if(MMSYSERR_NOERROR == mmr)
    {
        tstBeginSection(NULL);
        tstLog(VERBOSE,"");

        Log_WAVEINCAPS(lpCaps);

        tstEndSection();
    }
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInGetDevCaps()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInOpen
//
//  Description:
//      Wrapper function for waveInOpen.
//
//  Arguments:
//      LPHWAVEIN lphWaveIn: Identical to API.
//
//      UINT uDeviceID: Identical to API.
//
//      LPWAVEFORMATEX pwfx: Identical to API.
//
//      DWORD dwCallback: Identical to API.
//
//      DWORD dwInstance: Identical to API.
//
//      DWORD dwFlags: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInOpen
(
    LPHWAVEIN       lphWaveIn,
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    DWORD           dwCallback,
    DWORD           dwInstance,
    DWORD           dwFlags
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInOpen";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADOPEN      wto;

        wto.wtb.uType    = ID_WAVEINOPEN;
        wto.wtb.fdwFlags = 0L;
        wto.phWave       = (LPHWAVEOUT)lphWaveIn; 
        wto.uDeviceID    = uDeviceID; 
        wto.pwfx         = pwfx; 
        wto.dwCallback   = dwCallback; 
        wto.dwInstance   = dwInstance; 
        wto.fdwFlags     = dwFlags; 

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wto,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInOpen(
                        lphWaveIn,
                        uDeviceID,
                        (HACK)pwfx,
                        dwCallback,
                        dwInstance,
                        dwFlags);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wto);

            dwTime = wto.wtb.dwTime;
            mmr    = wto.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInOpen(
                    lphWaveIn,
                    uDeviceID,
                    (HACK)pwfx,
                    dwCallback,
                    dwInstance,
                    dwFlags);
        dwTime = waveGetTime() - dwTime;
    }

    tstLog(VERBOSE," lphWaveIn: " PTR_FORMAT,MAKEPTR((LPVOID)lphWaveIn));
    
    if(!IsBadReadPtr(lphWaveIn,sizeof(HWAVE)))
    {
        tstLog(VERBOSE,"   hWaveIn: " UINT_FORMAT,((UINT)(*lphWaveIn)));
    }

    tstLog(VERBOSE," uDeviceID: %u",uDeviceID);
    tstLog(VERBOSE,"      pwfx: " PTR_FORMAT,MAKEPTR(pwfx));

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEFORMATEX(pwfx);
    tstEndSection();
    tstLog(VERBOSE,"");

    tstLog(VERBOSE,"dwCallback: 0x%08lx",dwCallback);
    tstLog(VERBOSE,"dwInstance: 0x%08lx",dwInstance);

    Enum_waveOpen_Flags(dwFlags,10);
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInOpen()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInClose
//
//  Description:
//      Wrapper function for waveInClose.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInClose
(
    HWAVEIN hWaveIn
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInClose";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveIn: " UINT_FORMAT,hWaveIn);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEINCLOSE;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveIn;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInClose(hWaveIn);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInClose(hWaveIn);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInClose()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInPrepareHeader
//
//  Description:
//      Wrapper function for waveInPrepareHeader.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//      LPWAVEHDR lpWaveInHdr: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInPrepareHeader
(
    HWAVEIN     hWaveIn,
    LPWAVEHDR   lpWaveInHdr,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInPrepareHeader";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"    hWaveIn: " UINT_FORMAT,hWaveIn);
    tstLog(VERBOSE,"lpWaveInHdr: " PTR_FORMAT,MAKEPTR(lpWaveInHdr));

    tstLog(VERBOSE,"      uSize: %u",uSize);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEINPREPAREHEADER;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveIn;
        wts.pStruct      = lpWaveInHdr;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInPrepareHeader(hWaveIn,lpWaveInHdr,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInPrepareHeader(hWaveIn,lpWaveInHdr,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEHDR(lpWaveInHdr);
    tstEndSection();
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInPrepareHeader()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInUnprepareHeader
//
//  Description:
//      Wrapper function for waveInUnprepareHeader.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//      LPWAVEHDR lpWaveInHdr: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInUnprepareHeader
(
    HWAVEIN     hWaveIn,
    LPWAVEHDR   lpWaveInHdr,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInUnprepareHeader";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"    hWaveIn: " UINT_FORMAT,hWaveIn);
    tstLog(VERBOSE,"lpWaveInHdr: " PTR_FORMAT,MAKEPTR(lpWaveInHdr));

    tstLog(VERBOSE,"      uSize: %u",uSize);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEINUNPREPAREHEADER;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveIn;
        wts.pStruct      = lpWaveInHdr;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInUnprepareHeader(hWaveIn,lpWaveInHdr,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInUnprepareHeader(hWaveIn,lpWaveInHdr,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEHDR(lpWaveInHdr);
    tstEndSection();
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInUnprepareHeader()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInAddBuffer
//
//  Description:
//      Wrapper function for waveInAddBuffer.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//      LPWAVEHDR lpWaveInHdr: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInAddBuffer
(
    HWAVEIN     hWaveIn,
    LPWAVEHDR   lpWaveInHdr,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInAddBuffer";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"    hWaveIn: " UINT_FORMAT,hWaveIn);
    tstLog(VERBOSE,"lpWaveInHdr: " PTR_FORMAT,MAKEPTR(lpWaveInHdr));

    tstLog(VERBOSE,"      uSize: %u",uSize);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEINADDBUFFER;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveIn;
        wts.pStruct      = lpWaveInHdr;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInAddBuffer(hWaveIn,lpWaveInHdr,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInAddBuffer(hWaveIn,lpWaveInHdr,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_WAVEHDR(lpWaveInHdr);
    tstEndSection();
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInAddBuffer()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInStart
//
//  Description:
//      Wrapper function for waveInStart.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInStart
(
    HWAVEIN hWaveIn
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInStart";
    DWORD       dwTime;

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEINSTART;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveIn;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInStart(hWaveIn);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInStart(hWaveIn);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveIn: " UINT_FORMAT,hWaveIn);

    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInStart()


MMRESULT FNGLOBAL time_waveInStart
(
    HWAVEIN hWaveIn,
    LPDWORD pdwTime
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInStart";
    DWORD       dwTime,dwTime2;

    dwTime   = waveGetTime();
    mmr      = waveInStart(hWaveIn);
    dwTime2  = waveGetTime();
    *pdwTime = (dwTime2 + dwTime) / 2;
    dwTime2  = dwTime2 - dwTime;
         
    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveIn: " UINT_FORMAT,hWaveIn);

    Log_Error(szFnName,mmr,dwTime2);

    return mmr;
} // time_waveInStart()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInStop
//
//  Description:
//      Wrapper function for waveInStop.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInStop
(
    HWAVEIN hWaveIn
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInStop";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveIn: " UINT_FORMAT,hWaveIn);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEINSTOP;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveIn;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInStop(hWaveIn);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInStop(hWaveIn);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInStop()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInReset
//
//  Description:
//      Wrapper function for waveInReset.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInReset
(
    HWAVEIN hWaveIn
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInReset";
    DWORD       dwTime;

    Log_FunctionName(szFnName);

    tstLog(VERBOSE,"hWaveIn: " UINT_FORMAT,hWaveIn);

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADHANDLE    wth;

        wth.wtb.uType    = ID_WAVEINRESET;
        wth.wtb.fdwFlags = 0L;
        wth.hWave        = (HWAVE)hWaveIn;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wth,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInReset(hWaveIn);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wth);

            dwTime = wth.wtb.dwTime;
            mmr    = wth.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInReset(hWaveIn);
        dwTime = waveGetTime() - dwTime;
    }
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInReset()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInGetPosition
//
//  Description:
//      Wrapper function for waveInGetPosition.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//      LPMMTIME lpInfo: Identical to API.
//
//      UINT uSize: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInGetPosition
(
    HWAVEIN     hWaveIn,
    LPMMTIME    lpInfo,
    UINT        uSize
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInGetPosition";
    DWORD       dwTime;
    UINT        uQueryType;

    uQueryType = lpInfo->wType;

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADSTRUCT    wts;

        wts.wtb.uType    = ID_WAVEINGETPOSITION;
        wts.wtb.fdwFlags = 0L;
        wts.hWave        = (HWAVE)hWaveIn;
        wts.pStruct      = lpInfo;
        wts.cbSize       = uSize;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wts,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInGetPosition(hWaveIn,lpInfo,uSize);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wts);

            dwTime = wts.wtb.dwTime;
            mmr    = wts.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInGetPosition(hWaveIn,lpInfo,uSize);
        dwTime = waveGetTime() - dwTime;
    }

    Log_FunctionName(szFnName);

    tstLog(VERBOSE," hWaveIn: " UINT_FORMAT,hWaveIn);
    tstLog(VERBOSE,"  lpInfo: " PTR_FORMAT,MAKEPTR(lpInfo));
    tstLog(VERBOSE,"   uSize: %u\n",uSize);

    switch (uQueryType)
    {
        case TIME_MS:
            tstLog(VERBOSE,"Query wType: TIME_MS (%u)",uQueryType);
            break;

        case TIME_SAMPLES:
            tstLog(VERBOSE,"Query wType: TIME_SAMPLES (%u)",uQueryType);
            break;

        case TIME_BYTES:
            tstLog(VERBOSE,"Query wType: TIME_BYTES (%u)",uQueryType);
            break;

        case TIME_SMPTE:
            tstLog(VERBOSE,"Query wType: TIME_SMPTE (%u)",uQueryType);
            break;

        case TIME_MIDI:
            tstLog(VERBOSE,"Query wType: TIME_MIDI (%u)",uQueryType);
            break;

        case TIME_TICKS:
            tstLog(VERBOSE,"Query wType: TIME_TICKS (%u)",uQueryType);
            break;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_MMTIME(lpInfo);
    tstEndSection();
         
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInGetPosition()


MMRESULT FNGLOBAL time_waveInGetPosition
(
    HWAVEIN     hWaveIn,
    LPMMTIME    lpInfo,
    UINT        uSize,
    LPDWORD     pdwTime
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInGetPosition";
    DWORD       dwTime,dwTime2;
    UINT        uQueryType;

    uQueryType = lpInfo->wType;

    dwTime   = waveGetTime();
    mmr      = waveInGetPosition(hWaveIn,lpInfo,uSize);
    dwTime2  = waveGetTime();
    *pdwTime = (dwTime2 + dwTime) / 2;
    dwTime2  = dwTime2 - dwTime;

    Log_FunctionName(szFnName);
    tstLog(VERBOSE," hWaveIn: " UINT_FORMAT,hWaveIn);
    tstLog(VERBOSE,"  lpInfo: " PTR_FORMAT,MAKEPTR(lpInfo));
    tstLog(VERBOSE,"   uSize: %u\n",uSize);

    switch (uQueryType)
    {
        case TIME_MS:
            tstLog(VERBOSE,"Query wType: TIME_MS (%u)",uQueryType);
            break;

        case TIME_SAMPLES:
            tstLog(VERBOSE,"Query wType: TIME_SAMPLES (%u)",uQueryType);
            break;

        case TIME_BYTES:
            tstLog(VERBOSE,"Query wType: TIME_BYTES (%u)",uQueryType);
            break;

        case TIME_SMPTE:
            tstLog(VERBOSE,"Query wType: TIME_SMPTE (%u)",uQueryType);
            break;

        case TIME_MIDI:
            tstLog(VERBOSE,"Query wType: TIME_MIDI (%u)",uQueryType);
            break;

        case TIME_TICKS:
            tstLog(VERBOSE,"Query wType: TIME_TICKS (%u)",uQueryType);
            break;
    }

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");
    Log_MMTIME(lpInfo);
    tstEndSection();
         
    Log_Error(szFnName,mmr,dwTime2);

    return mmr;
} // time_waveInGetPosition()


//--------------------------------------------------------------------------;
//
//  MMRESULT call_waveInGetID
//
//  Description:
//      Wrapper function for waveInGetID.
//
//  Arguments:
//      HWAVEIN hWaveIn: Identical to API.
//
//      LPUINT lpuDeviceID: Identical to API.
//
//  Return (MMRESULT):
//      Identical to API.
//
//  History:
//      02/21/94    Fwong       Commenting wrappers.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL call_waveInGetID
(
    HWAVEIN hWaveIn,
    LPUINT  lpuDeviceID
)
{
    MMRESULT    mmr;
    static char szFnName[] = "waveInGetID";
    DWORD       dwTime;

    Log_FunctionName(szFnName);
    tstBeginSection(NULL);

    tstLog(VERBOSE,"    hWaveIn: " UINT_FORMAT,hWaveIn);
    tstLog(VERBOSE,"lpuDeviceID: " PTR_FORMAT,MAKEPTR(lpuDeviceID));

#ifdef  WIN32
    if(gti.fdwFlags & TESTINFOF_THREAD)
    {
        HANDLE              hThread;
        DWORD               dwThreadID;
        WAVETHREADATTR      wta;

        wta.wtb.uType    = ID_WAVEINGETID;
        wta.wtb.fdwFlags = 0L;
        wta.hWave        = (HWAVEOUT)hWaveIn;
        wta.dw           = (DWORD)lpuDeviceID;

        DPF(4,"CreateThread time: %lu ms.",waveGetTime());

        hThread = CreateWaveThread(ThreadFunc,wta,dwThreadID);

        if(NULL == hThread)
        {
            dwTime = waveGetTime();
            mmr    = waveInGetID(hWaveIn,lpuDeviceID);
            dwTime = waveGetTime() - dwTime;
        }
        else
        {
            CloseHandle(hThread);

            WaitForAPI(wta);

            dwTime = wta.wtb.dwTime;
            mmr    = wta.wtb.mmr;
        }
    }
    else
#endif  //  WIN32
    {
        dwTime = waveGetTime();
        mmr    = waveInGetID(hWaveIn,lpuDeviceID);
        dwTime = waveGetTime() - dwTime;
    }

    tstLog(VERBOSE,"   DeviceID: %u",(UINT)(*lpuDeviceID));
    
    Log_Error(szFnName,mmr,dwTime);

    return mmr;
} // call_waveInGetID()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\amkspin.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// amkspin.cpp  
//

#include <streams.h>            // quartz, includes windows
#include <measure.h>            // performance measurement (MSR_)
#include <winbase.h>

#include <initguid.h>
#include <olectl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"


STDMETHODIMP
AMKsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList,
    KSPIN_MEDIUM * MediumSet
    )
{
    PKSPIN_MEDIUM   Medium;

    *MediumList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**MediumList) + sizeof(*Medium)));
    if (!*MediumList) {
        return E_OUTOFMEMORY;
    }
    (*MediumList)->Count = 1;
    (*MediumList)->Size = sizeof(**MediumList) + sizeof(*Medium);
    Medium = reinterpret_cast<PKSPIN_MEDIUM>(*MediumList + 1);
    Medium->Set   = MediumSet->Set;
    Medium->Id    = MediumSet->Id;
    Medium->Flags = MediumSet->Flags;

    // The following special return code notifies the proxy that this pin is
    // not available as a kernel mode connection

    return S_FALSE;              
}


STDMETHODIMP
AMKsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    )
{
    PKSPIN_INTERFACE    Interface;

    *InterfaceList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**InterfaceList) + sizeof(*Interface)));
    if (!*InterfaceList) {
        return E_OUTOFMEMORY;
    }
    (*InterfaceList)->Count = 1;
    (*InterfaceList)->Size = sizeof(**InterfaceList) + sizeof(*Interface);
    Interface = reinterpret_cast<PKSPIN_INTERFACE>(*InterfaceList + 1);
    Interface->Set = KSINTERFACESETID_Standard;
    Interface->Id = KSINTERFACE_STANDARD_STREAMING;
    Interface->Flags = 0;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\xformtst\xformtst.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       xformtst.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <objbase.h>
#include <devioctl.h>

#include <tchar.h>
#include <stdio.h>
#include <conio.h>
#include <malloc.h>

#include <setupapi.h>

#include <mmsystem.h>
#include <mmreg.h>
#include <ks.h>
#include <ksmedia.h>

BOOL
HandleControl(
    HANDLE   DeviceHandle,
    DWORD    IoControl,
    PVOID    InBuffer,
    ULONG    InSize,
    PVOID    OutBuffer,
    ULONG    OutSize,
    PULONG   BytesReturned
    )
{
    BOOL            IoResult;
    OVERLAPPED      Overlapped;

    RtlZeroMemory(&Overlapped, sizeof(OVERLAPPED));
    if (!(Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
        return FALSE;
    IoResult = 
        DeviceIoControl(
            DeviceHandle, 
            IoControl, 
            InBuffer, 
            InSize, 
            OutBuffer, 
            OutSize, 
            BytesReturned, 
            &Overlapped );
    if (!IoResult && (ERROR_IO_PENDING == GetLastError())) {
        WaitForSingleObject(Overlapped.hEvent, INFINITE);
        IoResult = TRUE;
    }
    CloseHandle(Overlapped.hEvent);
    return IoResult;
}

VOID
PinSetState(
    HANDLE  PinHandle,
    KSSTATE DeviceState
    )
{
    KSPROPERTY      Property;
    ULONG           BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    if (!HandleControl( 
            PinHandle, 
            IOCTL_KS_PROPERTY, 
            &Property, 
            sizeof(Property), 
            &DeviceState, 
            sizeof(DeviceState), 
            &BytesReturned )) {
        printf( "error: PinSetState failed\n" );   
    }
}


BOOL 
GetDefaultInterfaceDetails(
    LPGUID InterfaceGuid,
    PSP_INTERFACE_DEVICE_DETAIL_DATA InterfaceDeviceDetails,
    ULONG DetailsSize
    )
{
    HDEVINFO                    InterfaceSet;
    SP_INTERFACE_DEVICE_DATA    InterfaceDeviceData;
    
    InterfaceSet = 
        SetupDiGetClassDevs( 
            InterfaceGuid,
            NULL,
            NULL,
            DIGCF_PRESENT | DIGCF_INTERFACEDEVICE );

    if (!InterfaceSet) {
        printf( "error: no devices registered for interface.\n" );
        return FALSE;
    }       

    InterfaceDeviceData.cbSize = sizeof( SP_INTERFACE_DEVICE_DATA );
    if (!SetupDiEnumInterfaceDevice(
            InterfaceSet,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            InterfaceGuid,
            0,                          // DWORD MemberIndex
            &InterfaceDeviceData )) { 
        printf( 
            "error: unable to retrieve information for interface, %d.\n", 
            GetLastError() );
        return FALSE;
    }

    InterfaceDeviceDetails->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    if (!SetupDiGetInterfaceDeviceDetail(
        InterfaceSet,
        &InterfaceDeviceData,
        InterfaceDeviceDetails,
        DetailsSize,
        NULL,                           // PDWORD RequiredSize
        NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

        printf( 
            "error: unable to retrieve device details for interface, %d.\n",
            GetLastError() );
        return FALSE;
    }

    return TRUE;    
}

BOOL
FindIdentifierInSet(
    HANDLE FilterHandle,
    ULONG PinId,
    ULONG PropertyId,
    PKSIDENTIFIER Identifier
    )
{
    KSP_PIN         Pin;
    PKSIDENTIFIER   Identifiers;
    PVOID           Buffer;
    ULONG           BytesReturned, Count, Size;
    
    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinId;
    Pin.Reserved = 0;
    
    HandleControl(
        FilterHandle, 
        IOCTL_KS_PROPERTY, 
        &Pin, 
        sizeof( Pin ), 
        &Size, 
        sizeof( ULONG ), 
        &BytesReturned);
    if (!BytesReturned) {
        printf( "error: failed to size of the interfaces array.\n" );
        return FALSE;
    }
    if (NULL == (Buffer = HeapAlloc( GetProcessHeap(), 0, Size ))) {
        printf( "error: failed to allocate a buffer for interfaces\n" );
        return FALSE;
    }
    //
    // Retrieve the identifier array
    //    
    HandleControl(
        FilterHandle, 
        IOCTL_KS_PROPERTY, 
        &Pin, 
        sizeof( Pin ), 
        Buffer, 
        Size,
        &BytesReturned);

    Identifiers = 
        (PKSIDENTIFIER)((PUCHAR)Buffer + sizeof(KSMULTIPLE_ITEM));
    Count = ((PKSMULTIPLE_ITEM)Buffer)->Count;
    
    for (;Count; Count--) {
        if (0 == memcmp( Identifiers++, Identifier, sizeof( KSIDENTIFIER ))) {
            break;
        }
    }
    HeapFree( GetProcessHeap(), 0, Buffer );    
    return Count;
}

BOOL
GetDefaultDataFormat(
    HANDLE SourceFilterHandle,
    ULONG SourcePinId,
    HANDLE SinkFilterHandle,
    ULONG  SinkPinId,
    PKSDATAFORMAT *DataFormat
    )
{
    KSP_PIN         Pin;
    PKSDATAFORMAT   IntersectionFormat;
    PKSP_PIN        DataIntersection;
    PVOID           RangesBuffer;
    ULONG           BytesReturned, Size, IntersectionSize;
    
    *DataFormat = NULL;
    
    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_DATARANGES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = SourcePinId;
    Pin.Reserved = 0;
    
    HandleControl(
        SourceFilterHandle, 
        IOCTL_KS_PROPERTY, 
        &Pin, 
        sizeof( Pin ), 
        &Size, 
        sizeof( ULONG ), 
        &BytesReturned);
    if (!BytesReturned) {
        printf( "error: failed to size of the data ranges.\n" );
        return FALSE;
    }

    IntersectionSize = Size + sizeof( KSP_PIN );    
    if (NULL == (RangesBuffer = 
                    HeapAlloc( 
                        GetProcessHeap(), 
                        0, 
                        IntersectionSize ))) {
        printf( "error: failed to allocate a buffer for data ranges\n" );
        return FALSE;
    }

    DataIntersection = (PKSP_PIN) RangesBuffer;
    
    //
    // Retrieve the data ranges list
    //    
    HandleControl(
        SourceFilterHandle, 
        IOCTL_KS_PROPERTY, 
        &Pin, 
        sizeof( Pin ), 
        DataIntersection + 1,
        Size,
        &BytesReturned);

        
    //
    // Find the intersection
    //
    
    DataIntersection->Property.Set = KSPROPSETID_Pin;
    DataIntersection->Property.Id = KSPROPERTY_PIN_DATAINTERSECTION;
    DataIntersection->Property.Flags = KSPROPERTY_TYPE_GET;
    DataIntersection->PinId = SinkPinId;
    DataIntersection->Reserved = 0;
    
    HandleControl(
        SinkFilterHandle, 
        IOCTL_KS_PROPERTY, 
        DataIntersection, 
        IntersectionSize,
        &Size, 
        sizeof( ULONG ), 
        &BytesReturned);
    if (!BytesReturned) {
        printf( "error: failed to size of the data intersection.\n" );
        return FALSE;
    }
    if (NULL == (*DataFormat = HeapAlloc( GetProcessHeap(), 0, Size ))) {
        printf( "error: failed to allocate a buffer for the data intersection\n" );
        HeapFree( GetProcessHeap(), 0, RangesBuffer );               
        return FALSE;
    }
    
    //
    // Retrieve the intersection data format
    //    
    
    HandleControl(
        SinkFilterHandle, 
        IOCTL_KS_PROPERTY, 
        DataIntersection,
        IntersectionSize,
        *DataFormat,
        Size,
        &BytesReturned);
    
    HeapFree( GetProcessHeap(), 0, RangesBuffer );               
    if (!BytesReturned) {
        printf( "error: data intersection failed.\n" );
        HeapFree( GetProcessHeap(), 0, *DataFormat );
        *DataFormat = NULL;
        return FALSE;
    }

    return TRUE;    
}

BOOL
GetAllocatorFramingRequirements(
    HANDLE PinHandle,
    PKSALLOCATOR_FRAMING Framing
    )
{
    KSPROPERTY      Property;
    ULONG           BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;
    Property.Flags = KSPROPERTY_TYPE_GET;
    HandleControl( 
        PinHandle, 
        IOCTL_KS_PROPERTY, 
        &Property, 
        sizeof(Property), 
        Framing,
        sizeof( KSALLOCATOR_FRAMING ),
        &BytesReturned );
        
    return BytesReturned;
}

BOOL
SetStreamAllocator(
    HANDLE SourcePinHandle,
    HANDLE AllocatorHandle
)
{
    KSPROPERTY      Property;
    ULONG           BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_ALLOCATOR;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return HandleControl( 
                SourcePinHandle, 
                IOCTL_KS_PROPERTY, 
                &Property, 
                sizeof(Property), 
                &AllocatorHandle,
                sizeof( HANDLE ),
                &BytesReturned );
}

BOOL
FindCompatiblePin(
    HANDLE FilterHandle,
    REFGUID InterfaceGuid,
    ULONG InterfaceRuid,
    REFGUID MediumGuid,
    ULONG MediumRuid,
    KSPIN_DATAFLOW DataFlow,
    KSPIN_COMMUNICATION Communication,
    PKSDATAFORMAT DataFormat OPTIONAL,
    PULONG PinId
    )
{
    KSP_PIN         Pin;
    ULONG           BytesReturned, TypeCount;
    KSIDENTIFIER    Identifier;
    
    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_CTYPES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    HandleControl( 
        FilterHandle, 
        IOCTL_KS_PROPERTY, 
        &Pin, 
        sizeof( KSPROPERTY ), 
        &TypeCount, 
        sizeof( ULONG ), 
        &BytesReturned );
    if (!BytesReturned) {
        printf("error: failed to retrieve number of pin types.\n");
        return FALSE;
    }

    for (*PinId = 0; *PinId < TypeCount; (*PinId)++) {
        KSPIN_DATAFLOW      ThisDataFlow;
        KSPIN_COMMUNICATION ThisCommunication;
        
        Pin.PinId = *PinId;
        Pin.Reserved = 0;

        Pin.Property.Id = KSPROPERTY_PIN_DATAFLOW;
        HandleControl( 
            FilterHandle, 
            IOCTL_KS_PROPERTY, 
            &Pin, 
            sizeof( Pin ), 
            &ThisDataFlow, 
            sizeof( KSPIN_DATAFLOW ), 
            &BytesReturned);
        if (DataFlow != ThisDataFlow) {
            continue;
        }        
    
        Pin.Property.Id = KSPROPERTY_PIN_COMMUNICATION;
        HandleControl( 
            FilterHandle, 
            IOCTL_KS_PROPERTY, 
            &Pin, 
            sizeof( Pin ), 
            &ThisCommunication, 
            sizeof( KSPIN_COMMUNICATION ), 
            &BytesReturned);
        if (Communication != ThisCommunication) {
            continue;
        }        
    
        Identifier.Set = *InterfaceGuid;
        Identifier.Id = InterfaceRuid;
        Identifier.Flags = 0;
    
        if (!FindIdentifierInSet( 
                FilterHandle, 
                *PinId, 
                KSPROPERTY_PIN_INTERFACES, 
                &Identifier )) {
            continue;
        }
    
        Identifier.Set = *MediumGuid;
        Identifier.Id = MediumRuid;
        Identifier.Flags = 0;
        
        if (!FindIdentifierInSet( 
                FilterHandle, 
                *PinId, 
                KSPROPERTY_PIN_MEDIUMS,     
                &Identifier )) {
            continue;
        }
    
        if (NULL == DataFormat) {
            return TRUE;
        }
    
        return TRUE;
    
            
    }
    return FALSE;    
}

HANDLE
ConnectStreamFile(
    HANDLE          FilterHandle,
    ULONG           PinId,
    PSTR            FileName
    )
{
    UCHAR           ConnectBuffer[ sizeof( KSPIN_CONNECT ) + 
                                   sizeof( KSDATAFORMAT ) + 
                                   sizeof( WCHAR ) * 256 ];
    PKSPIN_CONNECT  Connect;
    PKSDATAFORMAT   FileFormat;
    HANDLE          PinHandle;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
    Connect->Interface.Set = KSINTERFACESETID_Standard;
    Connect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    Connect->Interface.Flags = 0;
    Connect->Medium.Set = KSMEDIUMSETID_FileIo;
    Connect->Medium.Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Connect->Medium.Flags = 0;
    Connect->PinId = PinId;
    Connect->PinToHandle = NULL;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
    FileFormat = (PKSDATAFORMAT)(Connect + 1);
    FileFormat->MajorFormat = KSDATAFORMAT_TYPE_STREAM;
    FileFormat->SubFormat = KSDATAFORMAT_SUBTYPE_UNKNOWN;
    FileFormat->Specifier = KSDATAFORMAT_SPECIFIER_FILENAME;
    FileFormat->Reserved = 0;
    swprintf( (PWCHAR)(FileFormat + 1), L"\\DosDevices\\%S", FileName );
    FileFormat->FormatSize = 
        sizeof(KSDATAFORMAT) + 
            wcslen( (PWCHAR)(FileFormat + 1) ) * sizeof( WCHAR ) + 
                sizeof( UNICODE_NULL );
    if (KsCreatePin( FilterHandle, Connect, GENERIC_READ | GENERIC_WRITE, &PinHandle ))
        return (HANDLE) -1;
    return PinHandle;
}

HANDLE
ConnectPins(
    HANDLE FilterHandle,
    ULONG PinId,
    REFGUID InterfaceGuid,
    ULONG InterfaceRuid,
    REFGUID MediumGuid,
    ULONG MediumRuid,
    HANDLE PinHandle OPTIONAL,
    PKSDATAFORMAT DataFormat,
    ULONG DataFormatSize
    )
{
    HANDLE          ConnectHandle;
    PKSPIN_CONNECT  Connect;
    
    Connect = 
        (PKSPIN_CONNECT) 
            HeapAlloc( 
                GetProcessHeap(), 
                0, 
                sizeof( KSPIN_CONNECT ) + DataFormatSize );
                
    Connect->Interface.Set = *InterfaceGuid;
    Connect->Interface.Id = InterfaceRuid;
    Connect->Interface.Flags = 0;
    Connect->Medium.Set = *MediumGuid;
    Connect->Medium.Id = MediumRuid;
    Connect->Medium.Flags = 0;
    Connect->PinId = PinId;
    Connect->PinToHandle = PinHandle;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
    memcpy( 
        Connect + 1,
        DataFormat,
        DataFormatSize );

    //
    // The mode was incorrect... should be GENERIC_READ for
    // read operations (controlled by DataFlow direction).
    //
            
    if (KsCreatePin(FilterHandle, Connect, GENERIC_READ, &ConnectHandle)) {
        ConnectHandle = (HANDLE)-1;
        printf( "error: failed to connect pins: %08x\n", GetLastError() ); 
    }
    HeapFree( GetProcessHeap(), 0, Connect );
        
    return ConnectHandle;
}

HANDLE 
KsOpenDefaultFilter(
    REFGUID Category
    )
{
    HANDLE  Filter;
    BYTE    Storage[ 256 * sizeof( WCHAR ) + 
                     sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA ) ];
    PSP_INTERFACE_DEVICE_DETAIL_DATA InterfaceDeviceDetails;
    
    InterfaceDeviceDetails = (PSP_INTERFACE_DEVICE_DETAIL_DATA) Storage;
    
    if (!GetDefaultInterfaceDetails( 
            (LPGUID) Category,
            InterfaceDeviceDetails, 
            sizeof( Storage ))) {
        return (HANDLE) -1;
    }
    
    printf( 
        "opening filter: %s\n", 
        InterfaceDeviceDetails->DevicePath );

    Filter = 
        CreateFile( 
            InterfaceDeviceDetails->DevicePath,
            GENERIC_READ | GENERIC_WRITE, 
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL );
    
    if (Filter == (HANDLE) -1) {
        printf( 
            "error: failed to open device (%x)\n", 
            InterfaceDeviceDetails->DevicePath, 
            GetLastError() );
    }
    return Filter;    
}

int
_cdecl
main(
    int argc,
    char* argv[],
    char* envp[]
    )
{
    int                         i;
    HANDLE                      AllocatorHandle,
                                CaptureHandle, 
                                InterfaceXlatHandle,
                                CommunicationXlatHandle,
                                FileIoPin,
                                InterfaceToCapture,
                                CommunicationToInterface,
                                CommunicationToRenderer,
                                RendererHandle,
                                CaptureSinkPin,
                                InterfaceSinkPin,
                                RendererSinkPin;
    KSALLOCATOR_FRAMING         Framing;                           
    KSDATAFORMAT                DataFormat;
    PKSDATAFORMAT               FileFormat;
    ULONG                       SinkPinId, PinId;
    
    AllocatorHandle =
        CaptureHandle = 
        CommunicationXlatHandle = 
        CommunicationToInterface =
        InterfaceXlatHandle = 
        InterfaceToCapture =
        RendererHandle =
            (HANDLE) -1;
        
    if (argc < 2) {
        printf( "usage: %s <filepath>\n", argv[ 0 ] );
        goto CleanUp;
    }

    CaptureHandle = 
        KsOpenDefaultFilter( &KSCATEGORY_CAPTURE  );
    if ((HANDLE) -1 == CaptureHandle) {
        printf( "error: failed to open capture device.\n" );
        goto CleanUp;
    }

    InterfaceXlatHandle = 
        KsOpenDefaultFilter( &KSCATEGORY_INTERFACETRANSFORM );
    if ((HANDLE) -1 == InterfaceXlatHandle) {
        printf( "error: failed to open interface transform device.\n" );
        goto CleanUp;
    }

    CommunicationXlatHandle = 
        KsOpenDefaultFilter( &KSCATEGORY_COMMUNICATIONSTRANSFORM );
    if ((HANDLE) -1 == CommunicationXlatHandle) {
        printf( "error: failed to open communication transform device.\n" );
        goto CleanUp;
    }

    RendererHandle =
        KsOpenDefaultFilter( &KSCATEGORY_RENDER );
    if ((HANDLE) -1 == RendererHandle) {
        printf( "error: failed to open render device.\n" );
        goto CleanUp;
    }
    
    if (!FindCompatiblePin( 
            CaptureHandle, 
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_FileIo,
            KSMEDIUM_TYPE_ANYINSTANCE,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BRIDGE,
            NULL,
            &PinId )) {
        printf( "error: unable to locate a compatible FILEIO pin.\n" );
        goto CleanUp;
    }    

    printf( 
        "located a compatible FILEIO pin on the capture device: %d\n", 
        PinId );    

    FileIoPin =
        ConnectStreamFile( 
            CaptureHandle, 
            PinId, 
            argv[ 1 ] );
        
    if ((HANDLE) -1 == FileIoPin) {
        printf( "error: unable to connect file to FILEIO pin.\n" );
    }    


    if (!FindCompatiblePin( 
            CaptureHandle, 
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            NULL,
            &SinkPinId )) {
        printf( 
            "error: unable to locate a compatible capture DEVIO sink pin.\n" );
        goto CleanUp;
    }    

    printf( 
        "located a compatible capture DEVIO sink pin: %d\n", 
        SinkPinId );    

    DataFormat.FormatSize = sizeof( KSDATAFORMAT );
    DataFormat.Flags = 0;
    DataFormat.MajorFormat = KSDATAFORMAT_TYPE_STREAM;
    DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_UNKNOWN;
    DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_NONE;

    CaptureSinkPin = 
        ConnectPins( 
            CaptureHandle, 
            SinkPinId,
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            NULL,
            (PKSDATAFORMAT) &DataFormat,
            sizeof( KSDATAFORMAT ) );
    
    if ((HANDLE) -1 == CaptureSinkPin) {
        printf( "error: unable to connect to the capture DEVIO sink.\n" );
        goto CleanUp;
    }
     
    if (!FindCompatiblePin( 
            InterfaceXlatHandle, 
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SOURCE,
            NULL,
            &PinId )) {
        printf( 
            "error: unable to locate a compatible intf DEVIO source pin.\n" );
        goto CleanUp;
    }    

    printf( 
        "located a compatible intf DEVIO source pin: %d\n", 
        PinId );    

    InterfaceToCapture = 
        ConnectPins( 
            InterfaceXlatHandle,
            PinId,
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            CaptureSinkPin,
            (PKSDATAFORMAT) &DataFormat,
            sizeof( KSDATAFORMAT ) );
    
    if ((HANDLE) -1 == InterfaceToCapture) {
        printf( 
            "error: unable connect interface device to capture device.\n" );
        goto CleanUp;
    }

    if (!FindCompatiblePin( 
            InterfaceXlatHandle, 
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            NULL,
            &SinkPinId )) {
        printf( 
            "error: unable to locate a compatible intf DEVIO sink pin.\n" );
        goto CleanUp;
    }    

    printf( 
        "located a compatible intf DEVIO sink pin: %d\n", 
        SinkPinId );    

    if (!FindCompatiblePin( 
            CommunicationXlatHandle, 
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SOURCE,
            NULL,
            &PinId )) {
        printf( 
            "error: unable to locate a compatible comm DEVIO source pin.\n" );
        goto CleanUp;
    }    

    printf( 
        "located a compatible comm DEVIO source pin: %d\n", 
        PinId );    
        
    //
    // The connection to the translation filter supplies the data format
    //        
    
    if (!GetDefaultDataFormat( 
            CommunicationXlatHandle,
            PinId,
            InterfaceXlatHandle, 
            SinkPinId,
            &FileFormat)) {
        printf( "error: unable to obtain the default format for the sink.\n" );
        goto CleanUp;
    }
    
    printf(
        "read default format from sink.\n" );
        
    printf( "default data format:\n" );
    printf( 
        "    FormatSize: %08x\n", 
        ((PKSDATAFORMAT_WAVEFORMATEX) FileFormat)->DataFormat.FormatSize );    
    printf( 
        "    Channels: %d\n", 
        ((PKSDATAFORMAT_WAVEFORMATEX) FileFormat)->WaveFormatEx.nChannels );
    printf( 
        "    Bits/sample: %d\n", 
        ((PKSDATAFORMAT_WAVEFORMATEX) FileFormat)->WaveFormatEx.wBitsPerSample );
        
    printf( 
        "    Samples/sec: %d\n", 
        ((PKSDATAFORMAT_WAVEFORMATEX) FileFormat)->WaveFormatEx.nSamplesPerSec );
    printf( 
        "    Avg. Bytes/sec: %d\n", 
        ((PKSDATAFORMAT_WAVEFORMATEX) FileFormat)->WaveFormatEx.nAvgBytesPerSec );
    
    InterfaceSinkPin =
        ConnectPins( 
            InterfaceXlatHandle, 
            SinkPinId,
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            NULL,
            (PKSDATAFORMAT) FileFormat,
            FileFormat->FormatSize );
    
    if ((HANDLE) -1 == InterfaceSinkPin) {
        printf( "error: unable to connect to the intf DEVIO sink.\n" );
        goto CleanUp;
    }

    CommunicationToInterface = 
        ConnectPins( 
            CommunicationXlatHandle,
            PinId,
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            InterfaceSinkPin,
            (PKSDATAFORMAT) FileFormat,
            FileFormat->FormatSize );
    
    if ((HANDLE) -1 == CommunicationToInterface) {
        printf( 
            "error: unable connect communication device to interface device.\n" );
        goto CleanUp;
    }
    
    if (!GetAllocatorFramingRequirements( 
            CommunicationToInterface,
            &Framing )) {
        printf( 
            "error: unable to retrieve allocator framing requirements.\n" );
        goto CleanUp;
    }

    printf( "Allocator requirements:\n" );
    printf( "    Requirements: %08x\n", Framing.RequirementsFlags );    
    printf( "    PoolType: %d\n", Framing.PoolType );
    printf( "    Frames: %d\n", Framing.Frames );
    printf( "    Frame Size: %d\n", Framing.FrameSize );
    printf( "    FileAlignment: %08x\n", Framing.FileAlignment );
    
    Framing.OptionsFlags &= ~KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
    
    if (KsCreateAllocator( 
            CommunicationToInterface,
            &Framing,
            &AllocatorHandle )) {
        printf( "error: failed to create allocator\n" );
        goto CleanUp;
    }

    if (!SetStreamAllocator( CommunicationToInterface, AllocatorHandle )) {
        printf( "error: failed to set the stream allocator.\n" );
        goto CleanUp;
    }

    //
    // Connect the communication transform to renderer path
    //    
    
    if (!FindCompatiblePin( 
            RendererHandle, 
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            NULL,
            &SinkPinId )) {
        printf( 
            "error: unable to locate a compatible render DEVIO sink pin.\n" );
        goto CleanUp;
    }    

    printf( 
        "located a compatible render DEVIO sink pin: %d\n", 
        SinkPinId );    

    RendererSinkPin =
        ConnectPins( 
            RendererHandle, 
            SinkPinId,
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            NULL,
            (PKSDATAFORMAT) FileFormat,
            FileFormat->FormatSize );
    
    if ((HANDLE) -1 == RendererSinkPin) {
        printf( "error: unable to connect to the render DEVIO sink.\n" );
        goto CleanUp;
    }

    if (!FindCompatiblePin( 
            CommunicationXlatHandle, 
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SOURCE,
            NULL,
            &PinId )) {
        printf( 
            "error: unable to locate a compatible comm DEVIO source pin.\n" );
        CloseHandle( RendererSinkPin );
        goto CleanUp;
    }    

    printf( 
        "located a compatible comm DEVIO source pin: %d\n", 
        PinId );    

    CommunicationToRenderer = 
        ConnectPins( 
            CommunicationXlatHandle,
            PinId,
            &KSINTERFACESETID_Standard,
            KSINTERFACE_STANDARD_STREAMING,
            &KSMEDIUMSETID_Standard,
            KSMEDIUM_TYPE_ANYINSTANCE,
            RendererSinkPin,
            (PKSDATAFORMAT) FileFormat,
            FileFormat->FormatSize );
    
    if ((HANDLE) -1 == CommunicationToRenderer) {
        printf( 
            "error: unable connect interface device to capture device.\n" );
        goto CleanUp;
    }

#if defined( USE_INCOMPATIBLE_ALLOCATORS )

    //
    // TEST CODE... create another allocator to simulate "incompatible"
    // allocators.
    //    
    
    Framing.FrameSize *= 2;
    
    if (KsCreateAllocator( 
            CommunicationToRenderer,
            &Framing,
            &AllocatorHandle )) {
        printf( "error: failed to create allocator\n" );
        goto CleanUp;
    }

    if (!SetStreamAllocator( CommunicationToRenderer, AllocatorHandle )) {
        printf( "error: failed to set the stream allocator.\n" );
        goto CleanUp;
    }
#endif    
    
    //
    // Connections completed.
    //
    
    printf( "connections completed, letting it run.\n" );

    printf( "run to capture sink\n" );    
    PinSetState( CaptureSinkPin, KSSTATE_RUN );
    printf( "run to interface source\n" );    
    PinSetState( InterfaceToCapture, KSSTATE_RUN );
    printf( "run to interface sink\n" );    
    PinSetState( InterfaceSinkPin, KSSTATE_RUN );
    printf( "run to communication source (interface)\n" );    
    PinSetState( CommunicationToInterface, KSSTATE_RUN );
    printf( "run to renderer sink\n" );    
    PinSetState( RendererSinkPin, KSSTATE_RUN );
    printf( "run to communication source (renderer)\n" );    
    PinSetState( CommunicationToRenderer, KSSTATE_RUN );
        
    printf( "press any key to continue..." );    
//    while (!_kbhit()) {
//        Sleep( 0 );
//    }
    _getch();
    printf( "\n" );
    
    printf( "stop to communication source (renderer)\n" );    
    PinSetState( CommunicationToRenderer, KSSTATE_STOP );
    printf( "stop to renderer sink\n" );    
    PinSetState( RendererSinkPin, KSSTATE_STOP );
    printf( "stop to communication source (interface)\n" );    
    PinSetState( CommunicationToInterface, KSSTATE_STOP );
    printf( "stop to interface sink\n" );    
    PinSetState( InterfaceSinkPin, KSSTATE_STOP );
    printf( "stop to interface source\n" );    
    PinSetState( InterfaceToCapture, KSSTATE_STOP );
    printf( "stop to capture sink\n" );    
    PinSetState( CaptureSinkPin, KSSTATE_STOP );

CleanUp:
    if ((HANDLE) -1 != AllocatorHandle) {
        CloseHandle( AllocatorHandle );
    }
    if ((HANDLE) -1 != CaptureHandle) {        
        CloseHandle( CaptureHandle );
    }
    if ((HANDLE) -1 != RendererHandle) {        
        CloseHandle( RendererHandle );
    }
    if ((HANDLE) -1 != InterfaceXlatHandle) {        
        CloseHandle( InterfaceXlatHandle );
    }
    if ((HANDLE) -1 != CommunicationXlatHandle) {        
        CloseHandle( CommunicationXlatHandle );
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\chanlist.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// chanlist.cpp  Classes that keeps the channel list and country list
//



#include <streams.h>            // quartz, includes windows
#include <measure.h>            // performance measurement (MSR_)
#include <tchar.h>

#include "chanlist.h"


// -------------------------------------------------------------------------
// CChanList
// -------------------------------------------------------------------------

CChanList::CChanList(HRESULT *phr, long lCountry, long lFreqList, BOOL bIsCable, long TuningSpace)
    : m_pList (NULL)
    , m_pChannels (NULL)
    , m_pChannelsAuto (NULL)
    , m_lChannelCount (0)
    , m_hGlobal (NULL)
    , m_IsCable (bIsCable)
    , m_lCountry (lCountry)
    , m_lTuningSpace (TuningSpace)
    , m_lFreqList (lFreqList)
    , m_lMinTunerChannel (0)
    , m_lMaxTunerChannel (0)
{
    BOOL bFound = FALSE;

    // Load the resource if not already loaded

    if (m_pList == NULL) {
        if (m_hRes = FindResource (g_hInst, 
                        MAKEINTRESOURCE(lFreqList), 
                        RT_RCDATA)) {
            if (m_hGlobal = LoadResource (g_hInst, m_hRes)) {
                m_pList = (long *) LockResource (m_hGlobal);                
            }
        }

    }

    ASSERT (m_pList != NULL);
    if (m_pList == NULL)
    {
        *phr = HRESULT_FROM_WIN32(GetLastError());

        return;
    }

    // Get the min and max channel numbers
    m_ListHdr = * ((PCHANLISTHDR) m_pList);

    // Create a pointer to the channels only
    m_pChannels = (long *) ((BYTE *) m_pList + sizeof (CHANLISTHDR));

     // Sanity check
    m_lChannelCount = m_ListHdr.MaxChannel - m_ListHdr.MinChannel + 1;
    ASSERT (m_lChannelCount > 0 && m_lChannelCount < 1000); 
    
    // Create a parallel list for the corrected frequencies from the registry
    m_pChannelsAuto = new long [m_lChannelCount];
    if (m_pChannelsAuto == NULL)
    {
        *phr = E_OUTOFMEMORY;

        return;
    }

    // And set the list to the unitialized state
    ZeroMemory (m_pChannelsAuto, sizeof(long) * m_lChannelCount);

    // Finally, try to get the corrected frequencies from the Registry
    ReadListFromRegistry (m_lTuningSpace);
           
}

CChanList::~CChanList()
{
    // Win32 automatically frees the resources

    m_hRes = NULL;
    m_hGlobal = NULL;
    m_pList = NULL;

    delete [] m_pChannelsAuto;  m_pChannelsAuto = NULL;
}

// Return TRUE if the default frequency is being returned
// Else, a fine-tune frequency is being returned, return FALSE.  
//
// Note:  Some channel lists contain a gap in the numbering.  In this case,
// the returned frequency will be zero, and the method returns TRUE.


BOOL
CChanList::GetFrequency(long nChannel, long * pFrequency, BOOL fForceDefault)
{
    // validate channel against legal range
    if (nChannel < m_ListHdr.MinChannel || nChannel > m_ListHdr.MaxChannel)
    {
        *pFrequency = 0;
        return TRUE;
    }

    if (!fForceDefault)
    {
        *pFrequency = *(m_pChannelsAuto + nChannel - m_ListHdr.MinChannel);
        if (0 == *pFrequency)
        {
            *pFrequency = *(m_pChannels + nChannel - m_ListHdr.MinChannel);
            fForceDefault = TRUE;
        }
    }
    else
        *pFrequency = *(m_pChannels + nChannel - m_ListHdr.MinChannel);

    return fForceDefault;
}

BOOL
CChanList::SetAutoTuneFrequency(long nChannel, long Frequency)
{
    if (nChannel < m_ListHdr.MinChannel || nChannel > m_ListHdr.MaxChannel)
        return FALSE;

    *(m_pChannelsAuto + nChannel - m_ListHdr.MinChannel) = Frequency;

    return TRUE;
}

// Determine the min and max channels supported.
// This is then limited by the actual frequencies supported by the physical tuner.

void
CChanList::GetChannelMinMax(long *plChannelMin, long *plChannelMax,
                            long lTunerFreqMin, long lTunerFreqMax)
{

    ASSERT (m_pChannels != NULL);

    // Calc the actual channels supported by the physical tuner,
    //   this is only done the first time through
    if (m_lMinTunerChannel == 0) {
        long j;

        // start at the bottom and work up
        for (j = m_ListHdr.MinChannel; j <= m_ListHdr.MaxChannel; j++) {
            if (m_pChannels[j - m_ListHdr.MinChannel] >= lTunerFreqMin) {
                m_lMinTunerChannel = j;
                break;
            }
        }

        // start at the top and work down
        for (j = m_ListHdr.MaxChannel; j >= m_ListHdr.MinChannel; j--) {
            m_lMaxTunerChannel = j;
            if (m_pChannels[j - m_ListHdr.MinChannel] <= lTunerFreqMax) {
                break;           
            }
        }
    }

    *plChannelMin = min (m_ListHdr.MinChannel, m_lMinTunerChannel); 
    *plChannelMax = min (m_ListHdr.MaxChannel, m_lMaxTunerChannel);
}

// Constants for the registry routines that follow
#define MAX_KEY_LEN 256
#define PROTECT_REGISTRY_ACCESS
#define CHANLIST_MUTEX_WAIT INFINITE

BOOL
CChanList::WriteListToRegistry(long lTuningSpace)
{
    BOOL rc = FALSE;

    DbgLog((LOG_TRACE, 2, TEXT("Entering WriteListToRegistry")));

#ifdef PROTECT_REGISTRY_ACCESS
    HANDLE hMutex;

    // Create (or open) the mutex that protects access to this part of the registry
    hMutex = CreateMutex(NULL, FALSE, g_strRegAutoTuneName);
    if (hMutex != NULL)
    {
        DbgLog((LOG_TRACE, 2, TEXT("Waiting for Mutex")));
        // Wait for our turn
        DWORD dwWait = WaitForSingleObject(hMutex, CHANLIST_MUTEX_WAIT);
        if (WAIT_OBJECT_0 == dwWait)
        {
#endif
            HKEY hKeyTS;
            long hr;

            m_lTuningSpace = lTuningSpace;

            // Open the hard-coded path (i.e. no path name computation necessary)
            hr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                g_strRegAutoTunePath, 
                0, 
                TEXT (""),
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS | KEY_EXECUTE,
                NULL,                   // LPSECURITY_ATTRIBUTES
                &hKeyTS,
                NULL);

            if (ERROR_SUCCESS == hr)
            {
                TCHAR szKeyText[MAX_KEY_LEN];
                HKEY hKeyList;

                // Now open the path specific to our TS and broadcast/cable designation
                // The key consists of the prefix TS, the value of the TuningSpace, 
                // followed by "-1" if cable and "-0" if broadcast
                wsprintf (szKeyText, TEXT("TS%d-%d"), lTuningSpace, m_IsCable);

#ifndef NOT_BACKWARD_COMPATIBLE
                // We need to clean up old way of keeping fine-tuning info
                DWORD dwType;

                // Get the key type of the default value
                hr = RegQueryValueEx(
                    hKeyTS,     // handle of key to query 
                    szKeyText,  // default value
                    0,          // reserved 
                    &dwType,    // address of buffer for value type 
                    NULL,
                    NULL);
                if (ERROR_SUCCESS == hr)
                {
                    // Check if it has the old type
                    if (REG_BINARY == dwType)
                    {
                        DbgLog((LOG_TRACE, 2, TEXT("Detected old AutoTune format")));

                        // ... and clear its value
                        hr = RegDeleteValue(hKeyTS, szKeyText);
                        if (ERROR_SUCCESS != hr)
                        {
                            DbgLog((LOG_ERROR, 2, TEXT("Failed to clear old value of %s"), szKeyText));
                        }
                    }
                    else
                    {
                        DbgLog((LOG_ERROR, 2, TEXT("Unexpected type for %s"), szKeyText));
                    }
                }
                else
                {
                    DbgLog((LOG_TRACE, 2, TEXT("Detected new AutoTune format")));
                }
#endif
                hr = RegCreateKeyEx(
                    hKeyTS,
                    szKeyText, 
                    0, 
                    TEXT(""),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS | KEY_EXECUTE,
                    NULL,                   // LPSECURITY_ATTRIBUTES
                    &hKeyList,
                    NULL);

                if (ERROR_SUCCESS == hr)
                {
                    // Set/Create the value containing the fine-tuning list
                    hr = RegSetValueEx(
                                hKeyList,
                                g_strRegAutoTuneName,
                                0,
                                REG_BINARY,
                                (unsigned char *) m_pChannelsAuto,
                                m_lChannelCount * sizeof (DWORD));

                    if (ERROR_SUCCESS == hr)
                        rc = TRUE;
                    else
                    {
                        DbgLog((LOG_ERROR, 2, TEXT("Failed setting %s\\%s"),
                            szKeyText, g_strRegAutoTuneName
                            ));
                    }

                    RegCloseKey(hKeyList);
                }

                RegCloseKey(hKeyTS);
            }
            else
            {
                DbgLog((LOG_ERROR, 2, TEXT("Failed creating/opening %s"), g_strRegAutoTunePath));
            }

#ifdef PROTECT_REGISTRY_ACCESS
            ReleaseMutex(hMutex);
        }
        else
        {
            DbgLog((LOG_ERROR, 2, TEXT("Failed waiting for mutex")));
        }

        CloseHandle(hMutex);
    }
    else
    {
        DbgLog((LOG_ERROR, 2, TEXT("Failed creating/opening mutex")));
    }
#endif

    DbgLog((LOG_TRACE, 2, TEXT("Leaving WriteListToRegistry, %s"),
        rc ? TEXT("success") : TEXT("failure")
        ));

    return rc;
}

BOOL
CChanList::ReadListFromRegistry(long lTuningSpace)
{
    BOOL rc = FALSE;

    DbgLog((LOG_TRACE, 2, TEXT("Entering ReadListFromRegistry")));

#ifdef PROTECT_REGISTRY_ACCESS
    HANDLE hMutex;

    // Create (or open) the mutex that protects access to this part of the registry
    hMutex = CreateMutex(NULL, FALSE, g_strRegAutoTuneName);
    if (hMutex != NULL)
    {
        DbgLog((LOG_TRACE, 2, TEXT("Waiting for Mutex")));

        // Wait for our turn
        DWORD dwWait = WaitForSingleObject(hMutex, CHANLIST_MUTEX_WAIT);
        if (WAIT_OBJECT_0 == dwWait)
        {
#endif
            HKEY hKeyTS;
            long hr;

            m_lTuningSpace = lTuningSpace;

            // Open the hard-coded path (i.e. no path name computation necessary)
            hr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                g_strRegAutoTunePath, 
                0, 
                KEY_READ,
                &hKeyTS);

            if (ERROR_SUCCESS == hr)
            {
                TCHAR szKeyText[MAX_KEY_LEN];
                HKEY hKeyList;

                // Now open the path specific to our TS and broadcast/cable designation
                // The key consists of the prefix TS, the value of the TuningSpace, 
                // followed by "-1" if cable and "-0" if broadcast
                wsprintf (szKeyText, TEXT("TS%d-%d"), lTuningSpace, m_IsCable);

                // Try it as a key first (the new way to store fine-tuning)
                hr = RegOpenKeyEx(
                    hKeyTS,
                    szKeyText, 
                    0, 
                    KEY_READ,
                    &hKeyList);

                if (ERROR_SUCCESS == hr)
                {
                    DbgLog((LOG_TRACE, 2, TEXT("Using new AutoTune format")));

                    TCHAR szName[MAX_KEY_LEN];
                    DWORD dwNameLength;
                    DWORD dwIndex, dwType;
                    DWORD dwSize = m_lChannelCount * sizeof (DWORD);

                    // First get the fine-tuning information
                    hr = RegQueryValueEx(
                        hKeyList,               // handle of key to query 
                        g_strRegAutoTuneName,   // address of name of value to query 
                        0,                      // reserved 
                        0,                      // address of buffer for value type 
                        (unsigned char *) m_pChannelsAuto,    // address of data buffer 
                        &dwSize);               // address of data buffer size 

                    if (ERROR_SUCCESS == hr)
                        rc = TRUE;  // at least we got something

                    DbgLog((LOG_TRACE, 4, TEXT("Checking for frequency overrides")));

                    // Now check for frequency overrides
                    for (dwIndex = 0, hr = ERROR_SUCCESS; ERROR_SUCCESS == hr; dwIndex++)
                    {
                        // Initialize the size
                        dwNameLength = MAX_KEY_LEN;

                        // Get the next (or first) value
                        hr = RegEnumValue(
                            hKeyList,
                            dwIndex,
                            szName,
                            &dwNameLength,
                            NULL,
                            &dwType,
                            NULL,
                            NULL);

                        if (ERROR_SUCCESS == hr)
                        {
                            LPTSTR pszNext;
                            long nChannel;
                        
                            // Try to convert the key name to a channel number
                            nChannel = _tcstol(szName, &pszNext, 10);
                            if (!*pszNext)  // must be '\0' or we skip it
                            {
                                // See if the value is a DWORD
                                if (REG_DWORD == dwType)
                                {
                                    DWORD Frequency, dwSize = sizeof(DWORD);

                                    // Get the frequency override
                                    hr = RegQueryValueEx(
                                        hKeyList,               // handle of key to query 
                                        szName,                 // address of name of value to query 
                                        0,                      // reserved 
                                        0,                      // address of buffer for value type 
                                        (BYTE *)&Frequency,    // address of data buffer 
                                        &dwSize);               // address of data buffer size 

                                    if (ERROR_SUCCESS == hr)
                                    {
                                        DbgLog((LOG_TRACE, 4, TEXT("Override, channel %d - frequency %d"),
                                            nChannel, Frequency
                                            ));

                                        if (!SetAutoTuneFrequency(nChannel, Frequency))
                                        {
                                            DbgLog((LOG_ERROR, 4, TEXT("Override failed, channel %d"),
                                                nChannel
                                                ));
                                        }
                                        else
                                            rc = TRUE;  // at least we got something
                                    }
                                    else
                                    {
                                        DbgLog((LOG_ERROR, 4, TEXT("Cannot get value of key %s"),
                                            szName
                                            ));
                                    }
                                }
                                else
                                {
                                    DbgLog((LOG_TRACE, 4, TEXT("Type of value for key %s not DWORD"),
                                        szName
                                        ));
                                }

                                hr = ERROR_SUCCESS;
                            }
                            else
                            {
                                DbgLog((LOG_TRACE, 4, TEXT("Skipping \"%s\" value"),
                                    szName
                                    ));
                            }
                        } // key enumeration
#if 0
                        else
                        {
                            if (ERROR_NO_MORE_ITEMS != hr)
                            {
                                LPVOID lpMsgBuf;
                                FormatMessage( 
                                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                    FORMAT_MESSAGE_FROM_SYSTEM | 
                                    FORMAT_MESSAGE_IGNORE_INSERTS,
                                    NULL,
                                    GetLastError(),
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                    (LPTSTR) &lpMsgBuf,
                                    0,
                                    NULL 
                                );
                                DbgLog((LOG_ERROR, 4, (LPCTSTR)lpMsgBuf));
                                // Free the buffer.
                                LocalFree( lpMsgBuf );
                            }
                            else if (0 == dwIndex)
                            {
                                DbgLog((LOG_TRACE, 4, TEXT("No values?@!")));
                            }
                        }
#endif
                    } // loop

                    RegCloseKey(hKeyList);  // clean this up since we've clobbered hr
                }
#ifndef NOT_BACKWARD_COMPATIBLE
                else
                {
                    DWORD dwSize = m_lChannelCount * sizeof (DWORD);

                    // Try getting the fine-tuning information the old way
                    hr = RegQueryValueEx(
                        hKeyTS,   // handle of key to query 
                        szKeyText,  // address of name of value to query 
                        0,          // reserved 
                        0,          // address of buffer for value type 
                        (unsigned char *)m_pChannelsAuto,    // address of data buffer 
                        &dwSize);   // address of data buffer size 

                    if (ERROR_SUCCESS == hr)
                    {
                        DbgLog((LOG_TRACE, 2, TEXT("Using old AutoTune format")));

                        rc = TRUE;
                    }
                    else
                    {
                        DbgLog((LOG_ERROR, 2, TEXT("Failed getting %s"),
                            szKeyText
                            ));
                    }
                }
#endif

                RegCloseKey(hKeyTS);
            }
            else
            {
                DbgLog((LOG_ERROR, 2, TEXT("Failed opening %s"), g_strRegAutoTunePath));
            }

#ifdef PROTECT_REGISTRY_ACCESS
            ReleaseMutex(hMutex);
        }
        else
        {
            DbgLog((LOG_ERROR, 2, TEXT("Failed waiting for mutex")));
        }

        CloseHandle(hMutex);
    }
    else
    {
        DbgLog((LOG_ERROR, 2, TEXT("Failed creating/opening mutex")));
    }
#endif

    DbgLog((LOG_TRACE, 2, TEXT("Leaving ReadListFromRegistry, %s"),
        rc ? TEXT("success") : TEXT("failure")
        ));

    return rc;
}

// -------------------------------------------------------------------------
// CCountryList
// -------------------------------------------------------------------------

CCountryList::CCountryList()
    : m_pList (NULL)
    , m_hRes (NULL)
    , m_hGlobal (NULL)
    , m_LastCountry (-1)
    , m_LastFreqListCable (-1)
    , m_LastFreqListBroad (-1)
{
    // Let's avoid creating a map until it is actually needed                   
}

CCountryList::~CCountryList()
{
    // Win32 automatically frees the resources

    m_hRes = NULL;
    m_hGlobal = NULL;
    m_pList = NULL;
}


// The country list is a table with four columns, 
// column 1 = the long distance dialing code for the country
// column 2 = the cable frequency list
// column 3 = the broadcast frequency list
// column 4 = the analog video standard

BOOL
CCountryList::GetFrequenciesAndStandardFromCountry (
                long lCountry, 
                long *plIndexCable, 
                long *plIndexBroad,
                AnalogVideoStandard *plAnalogVideoStandard)
{
    BOOL bFound = FALSE;

    // Special case USA

    if (lCountry == 1) {
        *plIndexCable = F_USA_CABLE;
        *plIndexBroad = F_USA_BROAD;
        *plAnalogVideoStandard = AnalogVideo_NTSC_M;
        return TRUE;
    }
    
    // Keeps a MRU list of one entry, see if it is the same
    if (lCountry == m_LastCountry) {
        *plIndexCable = m_LastFreqListCable;
        *plIndexBroad = m_LastFreqListBroad;
        *plAnalogVideoStandard = m_LastAnalogVideoStandard;
        return TRUE;
    }
        
    // Load the resource if not already loaded

    if (m_pList == NULL) {
        if (m_hRes = FindResource (g_hInst, 
                        MAKEINTRESOURCE (RCDATA_COUNTRYLIST), 
                        RT_RCDATA)) {
            if (m_hGlobal = LoadResource (g_hInst, m_hRes)) {
                m_pList = (WORD *) LockResource (m_hGlobal);                
            }
        }
    }

    ASSERT (m_pList != NULL);

    if (m_pList == NULL) {
        // Uh oh, must be out of memory.
        // punt by returning the USA channel list
        *plIndexCable = F_USA_CABLE;
        *plIndexBroad = F_USA_BROAD;
        *plAnalogVideoStandard = AnalogVideo_NTSC_M;
        return FALSE;
    }

    PCOUNTRY_ENTRY pEntry = (PCOUNTRY_ENTRY) m_pList;
        
    // A country code of Zero terminates the list!
    while (pEntry->Country != 0) {
        if (pEntry->Country == lCountry) {
            bFound = TRUE;
            m_LastCountry = lCountry;  
            *plIndexCable = m_LastFreqListCable = pEntry->IndexCable;
            *plIndexBroad = m_LastFreqListBroad = pEntry->IndexBroadcast;
            *plAnalogVideoStandard = m_LastAnalogVideoStandard = 
                (AnalogVideoStandard) pEntry->AnalogVideoStandard;
            break;
        }
        pEntry++;
    }

    return bFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\ctvtuner.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
// CTVTuner - the class that actually controls the hardware

#ifndef _INC_CTVTUNER_H
#define _INC_CTVTUNER_H

#include "chanlist.h"

enum {
    CableSystem_Current     = 0,
    CableSystem_Standard    = 1,
    CableSystem_IRC         = 2,
    CableSystem_HRC         = 3,
    CableSystem_End         = 4
};

enum TuningMode {
    TuningMode_TV           = 0,
    TuningMode_FM,
    TuningMode_AM,
    TuningMode_ATSC,
    TuningMode_DSS,
    TuningMode_Last         // Keep this one last!!!
};

// If the graph starts running without having previously set a frequency,
// or the channel selection property page is displayed without prior
// initialization, then these channels/frequencies are used.

#define CHANNEL_DEFAULT_TV          4L 
#define CHANNEL_DEFAULT_AM     540000L
#define CHANNEL_DEFAULT_FM   87900000L
#define CHANNEL_DEFAULT_ATSC       65L
#define CHANNEL_DEFAULT_DSS         5L

// How far to move when the up/down arrows are pressed

#define CHANNEL_STEP_TV          1L 
#define CHANNEL_STEP_AM      10000L
#define CHANNEL_STEP_FM     200000L
#define CHANNEL_STEP_ATSC        1L
#define CHANNEL_STEP_DSS         1L

enum TuningTrend { AdjustingNone, AdjustingUp, AdjustingDown };

class CTVTunerFilter;       // forward decl
class CTVTuner;     

#define FRAMETO100NS(FrameRate) ((REFERENCE_TIME)(LONG)((double)1e7/FrameRate))

typedef struct tagTVFormatInfo {
    BOOL fSupported;                            // TRUE if format supported
    AnalogVideoStandard AVStandard;             // enum from capture.odl
    long lActiveWidth;                          // 720 til HDTV
    long lActiveHeight;                         // PAL_M is the oddball
    REFERENCE_TIME  AvgTimePerFrame;            // 100 nS units
    long lSoundOffset;                          // Sound offset from vid carrier
    long lChannelWidth;                         // Channel bandwidth in Hz
} TVFORMATINFO;

// The following is a table of all potential formats a tuner can support.
//
// The first column is a flag indicating whether the format is actually
// supported by a particular device.  The flag will be set or cleared when 
// the device driver is first initialized, depending on the capabilities
// it reports.

const TVFORMATINFO TVTunerFormatCaps [] = 
{
// OK?  Enum of Format        W    H   Frame Rate             Offset   Width

    1, AnalogVideo_NTSC_M,   720, 483, FRAMETO100NS (29.97),  4500000, 6000000,
    1, AnalogVideo_NTSC_M_J, 720, 483, FRAMETO100NS (29.97),  4500000, 6000000,

    1, AnalogVideo_PAL_B,    720, 575, FRAMETO100NS (25.00),  5500000, 7000000,
    1, AnalogVideo_PAL_D,    720, 575, FRAMETO100NS (25.00),  6500000, 8000000,
    1, AnalogVideo_PAL_G,    720, 575, FRAMETO100NS (25.00),  5500000, 8000000,
    1, AnalogVideo_PAL_H,    720, 575, FRAMETO100NS (25.00),  5500000, 8000000,
    1, AnalogVideo_PAL_I,    720, 575, FRAMETO100NS (25.00),  5996000, 8000000,
    1, AnalogVideo_PAL_M,    720, 480, FRAMETO100NS (29.97),  4500000, 6000000,
    1, AnalogVideo_PAL_N,    720, 575, FRAMETO100NS (25.00),  4500000, 6000000,
    1, AnalogVideo_PAL_N_COMBO,
                             720, 575, FRAMETO100NS (25.00),  4500000, 6000000,

    1, AnalogVideo_SECAM_B,  720, 575, FRAMETO100NS (25.00),  5500000, 7000000,
    1, AnalogVideo_SECAM_D,  720, 575, FRAMETO100NS (25.00),  6500000, 8000000,
    1, AnalogVideo_SECAM_G,  720, 575, FRAMETO100NS (25.00),  5500000, 8000000,
    1, AnalogVideo_SECAM_H,  720, 575, FRAMETO100NS (25.00),  5500000, 8000000,
    1, AnalogVideo_SECAM_K,  720, 575, FRAMETO100NS (25.00),  6500000, 8000000,
    1, AnalogVideo_SECAM_K1, 720, 575, FRAMETO100NS (25.00),  6500000, 8000000,
    1, AnalogVideo_SECAM_L,  720, 575, FRAMETO100NS (25.00),  6500000, 8000000,
    1, AnalogVideo_SECAM_L1, 720, 575, FRAMETO100NS (25.00),  6500000, 8000000,
};

#define NUM_TVTUNER_FORMATS (sizeof (TVTunerFormatCaps) / sizeof (TVFORMATINFO))


// -------------------------------------------------------------------------
// CTunerMode class, a generic tuner base class
// -------------------------------------------------------------------------

class CTunerMode 
{

protected:

    CTVTuner           *m_pTVTuner;         // Encapsulating class
    CTVTunerFilter     *m_pFilter;          // Parent Filter
    BOOL                m_Active;
    long                m_Mode;             // AM/FM/TV/DSS/ATSC
    long                m_lCountryCode;
    long                m_lChannel;         // 3, 4, 5, ...
    long                m_lVideoCarrier;    // Or AM and FM Freq!!!
    long                m_lAudioCarrier;
    long                m_lVideoSubChannel;
    long                m_lAudioSubChannel;
    long                m_ChannelStep;       // for UI

    // Info about the hardware capabilites of the device in this mode
    KSPROPERTY_TUNER_MODE_CAPS_S    m_ModeCaps;

    // Current Frequency
    KSPROPERTY_TUNER_FREQUENCY_S    m_Frequency;

    // Info about the status of tuning
    KSPROPERTY_TUNER_STATUS_S       m_Status;
    long                            m_lBusy;
    void*                           m_InAutoTune; // Prevents recursive autotunes

    // Info about the formats supported by this particular tuner
    TVFORMATINFO                    m_TVTunerFormatCaps [NUM_TVTUNER_FORMATS];
    TVFORMATINFO                    m_TVFormatInfo;
                                     
    // Info about the current cable system
    int                             m_CableSystem;


public:

    CTunerMode(CTVTunerFilter *pFilter, 
               CTVTuner *pTVTuner, 
               long Mode, 
               long lChannel,
               long lVideoSubChannel,
               long lAudioSubChannel,
               long ChannelStep);
    virtual ~CTunerMode();

    HRESULT Init(void);

    virtual STDMETHODIMP HW_Tune ( long VideoCarrier, long AudioCarrier );
    virtual STDMETHODIMP HW_GetStatus ();
    virtual STDMETHODIMP HW_SetVideoStandard( long lVideoStandard);
                                   
    virtual STDMETHODIMP put_Mode(AMTunerModeType lMode);
    virtual STDMETHODIMP get_Mode(/* [in] */ AMTunerModeType *plMode);
    virtual STDMETHODIMP put_Channel (
                            long lChannel,              // TV Chan, or Radio Freq.
                            long lVideoSubChannel,      // Only used for TV
                            long lAudioSubChannel);     // Only used for TV
    virtual STDMETHODIMP get_Channel (
                            long * plChannel, 
                            long * plVideoSubChannel,
                            long * plAudioSubChannel);
    virtual STDMETHODIMP ChannelMinMax (long * plChannelMin, long * plChannelMax);
    virtual STDMETHODIMP AutoTune (long lChannel, long *plFoundSignal);
    virtual STDMETHODIMP StoreAutoTune ();
    virtual STDMETHODIMP SignalPresent( 
                            /* [out] */ long *plSignalStrength);
    virtual STDMETHODIMP get_VideoFrequency (long * plFreq);
    virtual STDMETHODIMP get_AudioFrequency (long * plFreq);
    virtual STDMETHODIMP get_AvailableTVFormats (long *lAnalogVideoStandard);
    virtual STDMETHODIMP get_TVFormat (long *plAnalogVideoStandard);
    virtual STDMETHODIMP put_CountryCode(long lCountryCode);
    virtual BOOL         SetTVFormatInfo(
                            AnalogVideoStandard AVStandard,
                            TVFORMATINFO *pTVFormatInfo,
                            BOOL fForce);
    virtual long         GetChannelStep () {return m_ChannelStep;};
};

// -------------------------------------------------------------------------
// All of the specific tuner classes derived from the above
// -------------------------------------------------------------------------

class CTunerMode_AMFM : public CTunerMode {
public:
    CTunerMode_AMFM(
        CTVTunerFilter *pFilter, 
        CTVTuner *pTVTuner, 
        long Mode, 
        long DefaultChannel,
        long ChannelStep
        ) : CTunerMode (pFilter, pTVTuner, Mode, DefaultChannel, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT, ChannelStep)
    {
    }

    STDMETHODIMP put_Channel(long lChannel, long, long);
    STDMETHODIMP AutoTune(long lChannel, long * plFoundSignal);

    HRESULT AutoTune(void);
    BOOL SearchNeighborhood(long freq, TuningTrend trend, int depth);
};

class CTunerMode_AM : public CTunerMode_AMFM {
public:
    CTunerMode_AM (CTVTunerFilter *pFilter, CTVTuner *pTVTuner, long Channel) :
       CTunerMode_AMFM(pFilter, pTVTuner, AMTUNER_MODE_AM_RADIO, Channel, CHANNEL_STEP_AM)
    {
    }
};

class CTunerMode_FM : public CTunerMode_AMFM {
public:
    CTunerMode_FM (CTVTunerFilter *pFilter, CTVTuner *pTVTuner, long Channel) :
       CTunerMode_AMFM(pFilter, pTVTuner, AMTUNER_MODE_FM_RADIO, Channel, CHANNEL_STEP_FM)
    {
    }
};

class CTunerMode_TV : public CTunerMode {
public:
    CTunerMode_TV (CTVTunerFilter *pFilter, CTVTuner *pTVTuner, long Mode, long Channel, long VideoSubChannel, long AudioSubChannel, long ChannelStep = CHANNEL_STEP_TV) :
       CTunerMode (pFilter, pTVTuner, Mode, Channel, VideoSubChannel, AudioSubChannel, ChannelStep)
    {
    }

    STDMETHODIMP put_Channel(
                        long lChannel,
                        long lVideoSubChannel,
                        long lAudioSubChannel);
    STDMETHODIMP ChannelMinMax(
                        long *plChannelMin, long *plChannelMax);
    BOOL         SearchNeighborhood ( 
                        long freq, 
                        TuningTrend trend, 
                        int depth);
    HRESULT AutoTune(BOOL bFromScratch);
    STDMETHODIMP AutoTune (
                        long lChannel, long * plFoundSignal);
    STDMETHODIMP put_CountryCode(
                        long lCountryCode);
    
    STDMETHODIMP SignalPresent( 
                        /* [out] */ long *plSignalStrength);
                                          
};

class CTunerMode_ATSC : public CTunerMode_TV {
public:
      CTunerMode_ATSC (CTVTunerFilter *pFilter, CTVTuner *pTVTuner, long Channel, long VideoSubChannel, long AudioSubChannel) :
        CTunerMode_TV (pFilter, pTVTuner, (long) 0x10 /*AMTUNER_MODE_ATSC*/, Channel, VideoSubChannel, AudioSubChannel, CHANNEL_STEP_ATSC)
      {
      }

      STDMETHODIMP SignalPresent( 
                          /* [out] */ long *plSignalStrength);
};

class CTunerMode_DSS : public CTunerMode {
public:
      CTunerMode_DSS (CTVTunerFilter *pFilter, CTVTuner *pTVTuner, long Channel, long VideoSubChannel, long AudioSubChannel) :
          CTunerMode (pFilter, pTVTuner, AMTUNER_MODE_DSS, Channel, VideoSubChannel, AudioSubChannel, CHANNEL_STEP_DSS)
      {
      }
};



// -------------------------------------------------------------------------
// CTVTuner class, the class that encapsulates all tuner modes
// -------------------------------------------------------------------------

const int SearchLimit = 8;

// limit on depth of recursion in CTVTuner::SearchNeighborhood()

class CTVTuner 
{
    friend class CTunerMode;

private:

    // Only the following functions should be modified as the
    // underlying hardware driver model changes

    HRESULT     HW_GetTVTunerCaps ();
    HRESULT     HW_SetInput (long lIndex);

    // End of driver model specific funtions

    HANDLE              m_hDevice;
    TCHAR               m_pDeviceName [MAX_PATH * 2]; //Registry path can be longer!
    
    CTVTunerFilter     *m_pFilter;
    ULONG               m_ModesSupported;
    long                m_CurrentMode;      // AM/FM/TV/DSS/ATSC
    long                m_lCountryCode;
    long                m_lTuningSpace;

    // All of the tuner modes supported / encapsulated
    CTunerMode         *m_pModeList [TuningMode_Last];
    CTunerMode         *m_pMode_Current;  // one of the above modes

    // Info about the formats supported by this particular tuner
    AnalogVideoStandard m_VideoStandardForCountry;

    // Info about the inputs and their assigned type (cable vs ant)
    long                m_lTotalInputs;         // total number of inputs
    long                m_lInputIndex;          // currently connected input
    TunerInputType      m_CurrentInputType;     // type of current input
    TunerInputType *    m_pInputTypeArray;      // array of input types

    // Info about the status of tuning
    int                 m_CableSystem;
    int                *m_CableSystemCounts;    // Standard-IRC-HRC

    // Overall capabilities of the tuner (TV, AM, FM, DSS, ...)
    KSPROPERTY_TUNER_CAPS_S m_TunerCaps;
    KSPIN_MEDIUM        m_IFMedium;

    // Channel to Frequency mapping lists
    CCountryList *      m_pListCountry;
    CChanList *         m_pListCable;
    CChanList *         m_pListBroadcast;
    CChanList *         m_pListCurrent;  // either m_pListCable or m_pListBroadcast

    int CreateDevice();

public:
    CTVTuner(CTVTunerFilter *pCTVTunerFilter);
    ~CTVTuner();

    STDMETHODIMP Load(LPPROPERTYBAG pPropBag, 
                      LPERRORLOG pErrorLog,
                      PKSPROPERTY_TUNER_CAPS_S pTunerCaps,
                      PKSPIN_MEDIUM pIFMedium);

    HANDLE Device() {return m_hDevice;}

    CChanList *  GetCurrentChannelList () {
        ASSERT (m_pListCurrent);
        return (m_pListCurrent);
    };

    int * GetCurrentCableSystemCountsForCurrentInput () {
        ASSERT (m_CableSystemCounts);
        ASSERT (m_lInputIndex >= 0 && m_lInputIndex < m_lTotalInputs);
        return (&m_CableSystemCounts[m_lInputIndex]);
    };

    AnalogVideoStandard GetVideoStandardForCurrentCountry () {
        return m_VideoStandardForCountry;
    };

    TunerInputType GetCurrentInputType() {
        return m_CurrentInputType;
    }

    HRESULT DeliverChannelChangeInfo(KS_TVTUNER_CHANGE_INFO &ChangeInfo,
                                     long Mode); 

    // --- IAMTVTuner Interface

    STDMETHODIMP put_Channel (
            long lChannel, 
            long lVideoSubChannel,
            long lAudioSubChannel);
    STDMETHODIMP get_Channel (
            long * plChannel, 
            long * plVideoSubChannel,
            long * plAudioSubChannel);
    STDMETHODIMP ChannelMinMax (long * plChannelMin, long * plChannelMax);
    STDMETHODIMP AutoTune (long lChannel, long *plFoundSignal);
    STDMETHODIMP StoreAutoTune ();
    STDMETHODIMP put_CountryCode (long lCountry);
    STDMETHODIMP get_CountryCode (long * plCountry);
    STDMETHODIMP put_TuningSpace (long lTuningSpace);
    STDMETHODIMP get_TuningSpace (long * plTuningSpace);
    STDMETHODIMP SignalPresent( 
            /* [out] */ long *plSignalStrength);

    STDMETHODIMP put_Mode( 
        /* [in] */ AMTunerModeType lMode);
    STDMETHODIMP get_Mode( 
        /* [out] */ AMTunerModeType __RPC_FAR *plMode);
    STDMETHODIMP GetAvailableModes( 
        /* [out] */ long *plModes);

    STDMETHODIMP get_AvailableTVFormats (long *lAnalogVideoStandard);
    STDMETHODIMP get_TVFormat (long *plAnalogVideoStandard);
    STDMETHODIMP get_NumInputConnections (long * plNumInputConnections);
    STDMETHODIMP put_InputType (long lIndex, TunerInputType InputConnectionType);
    STDMETHODIMP get_InputType (long lIndex, TunerInputType * pInputConnectionType);
    STDMETHODIMP put_ConnectInput (long lIndex);
    STDMETHODIMP get_ConnectInput (long * plIndex);
    STDMETHODIMP get_VideoFrequency (long * plFreq);
    STDMETHODIMP get_AudioFrequency (long * plFreq);

    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\kssupp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __KSSUPPORT__
#define __KSSUPPORT__

class CKsSupport : 
	  public IKsPin
    , public IKsPropertySet
    , public CUnknown
{
protected:
	KSPIN_MEDIUM        m_Medium;
    GUID                m_CategoryGUID;
    KSPIN_COMMUNICATION m_Communication;

public:

    // Constructor and destructor
    CKsSupport(KSPIN_COMMUNICATION Communication, LPUNKNOWN pUnk) :
          m_Communication (Communication)
        , m_CategoryGUID (GUID_NULL)
        , CUnknown (TEXT ("CKsSupport"), pUnk)
        {
            m_Medium.Set = GUID_NULL;
            m_Medium.Id = 0;
            m_Medium.Flags = 0;   
        };

    ~CKsSupport()
        {};

    void SetKsMedium   (const KSPIN_MEDIUM *Medium)    {m_Medium = *Medium;};
    void SetKsCategory (const GUID *Category)  {m_CategoryGUID = *Category;};

    DECLARE_IUNKNOWN;

    // IKsPropertySet implementation

    STDMETHODIMP 
    Set (
        REFGUID guidPropSet, 
        DWORD dwPropID, 
        LPVOID pInstanceData, 
        DWORD cbInstanceData, 
        LPVOID pPropData, 
        DWORD cbPropData
        )
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP 
    Get (
        REFGUID guidPropSet, 
        DWORD dwPropID, 
        LPVOID pInstanceData, 
        DWORD cbInstanceData, 
        LPVOID pPropData, 
        DWORD cbPropData, 
        DWORD *pcbReturned
        )
    {
        if (guidPropSet != AMPROPSETID_Pin)
	        return E_PROP_SET_UNSUPPORTED;

        if (dwPropID != AMPROPERTY_PIN_CATEGORY && dwPropID != AMPROPERTY_PIN_MEDIUM)
	        return E_PROP_ID_UNSUPPORTED;

        if (pPropData == NULL && pcbReturned == NULL)
	        return E_POINTER;

        if (pcbReturned)
            *pcbReturned = ((dwPropID == AMPROPERTY_PIN_CATEGORY) ? 
                sizeof(GUID) : sizeof (KSPIN_MEDIUM));

        if (pPropData == NULL)
	        return S_OK;

        if (cbPropData < sizeof(GUID))
	        return E_UNEXPECTED;

        if (dwPropID == AMPROPERTY_PIN_CATEGORY) {
            *(GUID *)pPropData = m_CategoryGUID;
        }
        else if (dwPropID == AMPROPERTY_PIN_MEDIUM) {
            *(KSPIN_MEDIUM *)pPropData = m_Medium;
        }


        return S_OK;
    }

    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
    {
        if (guidPropSet != AMPROPSETID_Pin)
	        return E_PROP_SET_UNSUPPORTED;

        if (dwPropID != AMPROPERTY_PIN_CATEGORY && dwPropID != AMPROPERTY_PIN_MEDIUM)
	        return E_PROP_ID_UNSUPPORTED;

        if (pTypeSupport)
	        *pTypeSupport = KSPROPERTY_SUPPORT_GET;

        return S_OK;
    }


    // IKsPin implementation

    virtual STDMETHODIMP 
    KsQueryMediums(
        PKSMULTIPLE_ITEM* MediumList
        )
        { return ::AMKsQueryMediums (MediumList, &m_Medium); }; 

    virtual STDMETHODIMP
    KsQueryInterfaces(
        PKSMULTIPLE_ITEM* InterfaceList
        ) 
        { return ::AMKsQueryInterfaces (InterfaceList); };

    STDMETHODIMP
    KsCreateSinkPinHandle(
        KSPIN_INTERFACE& Interface,
        KSPIN_MEDIUM& Medium
        ) { return E_UNEXPECTED; };


    STDMETHODIMP
    KsGetCurrentCommunication(
        KSPIN_COMMUNICATION *Communication,
        KSPIN_INTERFACE *Interface,
        KSPIN_MEDIUM *Medium
        )
        {
            if (Communication != NULL) {
                *Communication = m_Communication; 
            }
            if (Interface != NULL) {
                Interface->Set = KSINTERFACESETID_Standard;
                Interface->Id = KSINTERFACE_STANDARD_STREAMING;
                Interface->Flags = 0;
            }
            if (Medium != NULL) {
                *Medium = m_Medium;
            }
            // Special return code that indicates 
            // Kernel transport is  not possible

            return S_FALSE;     
        };
    
    STDMETHODIMP 
    KsPropagateAcquire() 
        { return NOERROR; };


    STDMETHODIMP
    KsDeliver(IMediaSample* Sample, ULONG Flags) 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsMediaSamplesCompleted ( PKSSTREAM_SEGMENT StreamSegment )
        { return E_UNEXPECTED; };

    STDMETHODIMP_(IMemAllocator*)
    KsPeekAllocator(KSPEEKOPERATION Operation) 
        { return NULL; };

    STDMETHODIMP
    KsReceiveAllocator( IMemAllocator* MemAllocator) 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsRenegotiateAllocator() 
        { return E_UNEXPECTED; };

    STDMETHODIMP_(LONG)
    KsIncrementPendingIoCount() 
        { return E_UNEXPECTED; };

    STDMETHODIMP_(LONG)
    KsDecrementPendingIoCount() 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta) 
        { return E_UNEXPECTED; };
    
    STDMETHODIMP_(REFERENCE_TIME) 
    KsGetStartTime() 
        { return E_UNEXPECTED; };
};

#endif // __KSSUPPORT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\amkspin.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// amkspin.h  
//

STDMETHODIMP
AMKsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList,
    KSPIN_MEDIUM * MediumSet
    );

STDMETHODIMP
AMKsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\chanlist.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//

#ifndef _INC_CHANLIST_H
#define _INC_CHANLIST_H

// Location in the registry where autotune parameters are kept

#define TSS_REGBASE TEXT("SOFTWARE\\Microsoft\\TV System Services\\")

const LPCTSTR   g_strRegBasePath = TSS_REGBASE;
const LPCTSTR   g_strRegAutoTunePath = TSS_REGBASE TEXT("TVAutoTune");
const LPCTSTR   g_strRegAutoTuneName = TEXT("AutoTune");


// The country list contains the numerical ID of the frequency list for each
// country.  The list is terminated by a zero country code.

#define RCDATA_COUNTRYLIST         9999

// The frequency list contains the frequencies available for this country

#define F_USA_CABLE             1       // USA
#define F_USA_BROAD             2
#define F_JAP_CABLE             3       // Japan
#define F_JAP_BROAD             4
#define F_WEU_CABLE             5       // Western Europe
#define F_WEU_BROAD             6
#define F_EEU_CABLE             7       // Eastern Europe
#define F_EEU_BROAD             8
#define F_FRA_CABLE             9       // France
#define F_FRA_BROAD             10
#define F_UK__CABLE             11      // UK
#define F_UK__BROAD             12
#define F_ITA_CABLE             13      // Italy
#define F_ITA_BROAD             14
#define F_OZ__CABLE             15      // Australia
#define F_OZ__BROAD             16
#define F_NZ__CABLE             17      // New Zealand
#define F_NZ__BROAD             18
#define F_FOT_CABLE             19      // French Overseas Teritory
#define F_FOT_BROAD             20
#define F_IRE_CABLE             21      // Ireland
#define F_IRE_BROAD             22
#define F_CHN_CABLE             23
#define F_CHN_BROAD             24
#define F_CZE_CABLE             25
#define F_CZE_BROAD             26
#define F_UNI_CABLE             27


#define F_FIX_CABLE             1
#define F_FIX_BROAD             2

// This structure references an RCDATA resource, and hence
// it must be pragma pack 1
#pragma pack(push, 1)
typedef struct tagCountryEntry {
    WORD    Country;
    WORD    IndexCable;
    WORD    IndexBroadcast;
    DWORD   AnalogVideoStandard;
} COUNTRY_ENTRY, *PCOUNTRY_ENTRY;
#pragma pack(pop)

// -------------------------------------------------------------------------
// CCountryList class, holds the mapping between country and tuning space
// -------------------------------------------------------------------------

class CCountryList
{

private:
    HRSRC               m_hRes;
    HGLOBAL             m_hGlobal;
    WORD *              m_pList;

    // Cache the last request, since it will often be reused...
    long                m_LastCountry;
    long                m_LastFreqListCable;
    long                m_LastFreqListBroad;
    AnalogVideoStandard m_LastAnalogVideoStandard;

public:
    CCountryList ();
    ~CCountryList ();

    BOOL GetFrequenciesAndStandardFromCountry (
            long lCountry, 
            long *plIndexCable, 
            long *plIndexBroad,
            AnalogVideoStandard *plAnalogVideoStandard);   
};

typedef struct tagChanListHdr {
     long MinChannel;
     long MaxChannel;
} CHANLISTHDR, * PCHANLISTHDR;

// -------------------------------------------------------------------------
// CChanList class, 
// -------------------------------------------------------------------------

class CChanList
{

private:

    HRSRC               m_hRes;
    HGLOBAL             m_hGlobal;
    long *              m_pList;
    long *              m_pChannels;            // Freq list from RC
    long *              m_pChannelsAuto;        // Freq list corrected by AutoTune
    long                m_lChannelCount;        // Size of both the above lists
    long                m_lFreqList;
    long                m_lCountry;
    AnalogVideoStandard m_lAnalogVideoStandard;
    long                m_lTuningSpace;
    BOOL                m_IsCable;              // else is broadcast
    CHANLISTHDR         m_ListHdr;
    long                m_lMinTunerChannel;     // lowest channel supported by physical tuner
    long                m_lMaxTunerChannel;     // highest channel supported by physical tuner

public:
    CChanList (HRESULT *phr, long lCountry, long lFreqList, BOOL bIsCable, long lTuningSpace);
    ~CChanList ();

    BOOL GetFrequency(long nChannel, long * Frequency, BOOL fForceDefault);
    BOOL SetAutoTuneFrequency(long nChannel, long Frequency);
    void GetChannelMinMax(long *plChannelMin, long *plChannelMax,
                          long lTunerFreqMin, long lTunerFreqMax);

    BOOL WriteListToRegistry(long lTuningSpace);
    BOOL ReadListFromRegistry(long lTuningSpace);

    long GetVideoCarrierFrequency (long lChannel);

    long GetFreqListID(void) { return m_lFreqList; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\ptvtuner.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  ptvtuner.h  TV Tuner property page

#ifndef _INC_PTVTUNER_H
#define _INC_PTVTUNER_H

// -------------------------------------------------------------------------
// CTVTunerProperties class
// -------------------------------------------------------------------------

class CTVTunerProperties : public CBasePropertyPage {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    CTVTunerProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CTVTunerProperties();

    static void StringFromTVStandard(long TVStd, TCHAR *sz) ;
    static void StringFromMode(long Mode, TCHAR *sz);
    HRESULT ChangeMode(long Mode);
    void    UpdateInputView();
    void    UpdateFrequencyView();
    void    UpdateChannelRange();
    void    SetDirty();

    // Controls
    HWND                m_hwndChannel;
    HWND                m_hwndChannelSpin;
    HWND                m_hwndCountryCode;
    HWND                m_hwndTuningSpace;
    HWND                m_hwndTuningMode;
    HWND                m_hwndStandardsSupported;
    HWND                m_hwndStandardCurrent;
    HWND                m_hwndStatus;


    // Keep the original settings on entry
    long                m_ChannelOriginal;
    long                m_CountryCodeOriginal;
    TunerInputType      m_InputConnectionOriginal;
    long                m_InputIndexOriginal;
    long                m_TuningSpaceOriginal;
    long                m_TuningModeOriginal;

    // Dynamic values changed by UI
    long                m_CurChan;
    long                m_CountryCode;
    long                m_TVFormat;
    long                m_TVFormatsAvailable;
    long                m_InputIndex;
    long                m_ChannelMin;
    long                m_ChannelMax;
    long                m_UIStep;
    long                m_CurVideoSubChannel;
    long                m_CurAudioSubChannel;
    long                m_TuningSpace;
    long                m_TuningMode;

    long                m_Pos;
    long                m_SavedChan;
    UINT_PTR            m_timerID;
    long                m_AvailableModes;

    long                m_AutoTuneOriginalChannel;
    long                m_AutoTuneCurrentChannel;

    IAMTVTuner          *m_pTVTuner;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\ctvtuner.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// ctvtuner.cpp  Class that encapsulates knowledge of Broadcast, ATSC,
//               FM, AM, and (someday?) DSS tuning
//
// Some basic assumptions:
// 
// 1) The "country" setting is global to all subtuners
// 2) The VideoFormat list is unique to each subtuner
// 3) The OptimalTuning list is global to all tuners
// 4) Input connections are global to all tuners
//

#include <streams.h>            // quartz, includes windows
#include <measure.h>            // performance measurement (MSR_)
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"
#include "kssupp.h"
#include "ctvtuner.h"
#include "tvtuner.h"
  
// define this to enable the 1MHz linear search mechanism to be delivered with the test kit
#undef LINEAR_SEARCH_FOR_TEST_KIT

// -------------------------------------------------------------------------
// CTunerMode
//
// Virtual members are generally used for AM and FM
// TV overrides
// -------------------------------------------------------------------------

CTunerMode::CTunerMode(CTVTunerFilter *pFilter
                       , CTVTuner *pTVTuner
                       , long Mode
                       , long lChannel
                       , long lVideoSubChannel
                       , long lAudioSubChannel
                       , long ChannelStep)
    : m_pFilter (pFilter)
    , m_pTVTuner(pTVTuner)
    , m_Mode (Mode)
    , m_Active (FALSE)
    , m_lCountryCode (-1)   // Init to an illegal value
    , m_lChannel(lChannel)
    , m_lVideoSubChannel(lVideoSubChannel)
    , m_lAudioSubChannel(lAudioSubChannel)
    , m_lVideoCarrier(0)
    , m_lAudioCarrier(0)
    , m_InAutoTune (reinterpret_cast<void*>(FALSE))
    , m_ChannelStep (ChannelStep)
{
}

HRESULT
CTunerMode::Init(void)
{
    ULONG cbReturned;
    BOOL  fOk;
    int j;

    ZeroMemory (&m_ModeCaps, sizeof (m_ModeCaps));
    ZeroMemory (&m_Frequency, sizeof (m_Frequency));
    ZeroMemory (&m_Status, sizeof (m_Status));

    // Get the capabilities for this mode

    m_ModeCaps.Property.Set   = PROPSETID_TUNER;
    m_ModeCaps.Property.Id    = KSPROPERTY_TUNER_MODE_CAPS;
    m_ModeCaps.Property.Flags = KSPROPERTY_TYPE_GET;
    m_ModeCaps.Mode           = m_Mode;

    fOk = KsControl(m_pTVTuner->Device(),
                    (DWORD) IOCTL_KS_PROPERTY, 
                    &m_ModeCaps, sizeof( m_ModeCaps), 
                    &m_ModeCaps, sizeof( m_ModeCaps), 
                    &cbReturned);

    if (!fOk) {
        DbgLog(( LOG_ERROR, 0, 
                 TEXT("FAILED:  KSPROPERTY_TUNER_MODE_CAPS, KSPROPERTY_TYPE_GET, cbReturned = %d"), cbReturned));

        return E_FAIL;
    }

    // Create a local version of TVTunerFormatCaps to
    // allow subtuners with different capabilities

    for (j = 0; j < NUM_TVTUNER_FORMATS; j++) {
        m_TVTunerFormatCaps[j] = TVTunerFormatCaps[j];
    }

    TVFORMATINFO * pTVInfo = m_TVTunerFormatCaps;

    // Walk the list of supported formats and set the flag in the table if supported
    for (j = 0; j < NUM_TVTUNER_FORMATS; j++, pTVInfo++) {
        if (pTVInfo->AVStandard & m_ModeCaps.StandardsSupported) {
            pTVInfo->fSupported = TRUE;     
        } 
        else {
            pTVInfo->fSupported = FALSE;     
        }
    }

    return S_OK;
}

CTunerMode::~CTunerMode()
{
}


HRESULT
CTunerMode::HW_Tune( long VideoCarrier, 
                     long AudioCarrier)
{
    BOOL fOk;
    ULONG cbReturned;

    m_Frequency.Property.Set   = PROPSETID_TUNER;
    m_Frequency.Property.Id    = KSPROPERTY_TUNER_FREQUENCY;
    m_Frequency.Property.Flags = KSPROPERTY_TYPE_SET;

    m_Frequency.Frequency      = VideoCarrier;
    m_Frequency.LastFrequency  = VideoCarrier;  // not used
    m_Frequency.TuningFlags    = KS_TUNER_TUNING_EXACT;

    m_Frequency.Channel         = m_lChannel;
    m_Frequency.VideoSubChannel = m_lVideoSubChannel;
    m_Frequency.AudioSubChannel = m_lAudioSubChannel;
    m_Frequency.Country         = m_lCountryCode; 

    fOk = KsControl(m_pTVTuner->Device(),
                    (DWORD) IOCTL_KS_PROPERTY, 
                    &m_Frequency, sizeof(m_Frequency), 
                    &m_Frequency, sizeof(m_Frequency), 
                    &cbReturned);

    if (!fOk) {
        DbgLog(( LOG_ERROR, 0, 
                 TEXT("FAILED:  KSPROPERTY_TUNER_FREQUENCY, KSPROPERTY_TYPE_SET, cbReturned = %d"), cbReturned));
    }

    return fOk ? S_OK : S_FALSE;
}

HRESULT
CTunerMode::HW_GetStatus ()
{
    BOOL fOk;
    ULONG cbReturned;
    KSPROPERTY_TUNER_STATUS_S Status;

    Status.Property.Set   = PROPSETID_TUNER;
    Status.Property.Id    = KSPROPERTY_TUNER_STATUS;
    Status.Property.Flags = KSPROPERTY_TYPE_GET;
   
    fOk = KsControl(m_pTVTuner->Device(),
                    (DWORD) IOCTL_KS_PROPERTY, 
                    &Status, sizeof( Status), 
                    &Status, sizeof( Status), 
                    &cbReturned);

    if (fOk) {
        m_Status = Status;
    }
    else {
        DbgLog(( LOG_ERROR, 0, TEXT("FAILED:  KSPROPERTY_TUNER_STATUS, KSPROPERTY_TYPE_GET, cbReturned = %d"), cbReturned));
    }
                   
    return fOk ? S_OK : S_FALSE;
}

HRESULT
CTunerMode::HW_SetVideoStandard( long lVideoStandard)
{
    BOOL fOk;
    ULONG cbReturned;
    KSPROPERTY_TUNER_STANDARD_S Standard;

    Standard.Property.Set   = PROPSETID_TUNER;
    Standard.Property.Id    = KSPROPERTY_TUNER_STANDARD;
    Standard.Property.Flags = KSPROPERTY_TYPE_SET;

    Standard.Standard       = lVideoStandard;

    fOk = KsControl(m_pTVTuner->Device(),
                    (DWORD) IOCTL_KS_PROPERTY, 
                    &Standard, sizeof(Standard), 
                    &Standard, sizeof(Standard), 
                    &cbReturned);

    if (!fOk) {
        DbgLog(( LOG_ERROR, 0, 
                 TEXT("FAILED:  KSPROPERTY_TUNER_STANDARD, KSPROPERTY_TYPE_SET, cbReturned = %d"), cbReturned));
    }
    return fOk ? S_OK : S_FALSE;
}

STDMETHODIMP
CTunerMode::put_Channel(
    long lChannel,
    long lVideoSubChannel,
    long lAudioSubChannel)
{
    m_lChannel = lChannel;
    m_lVideoSubChannel = lVideoSubChannel;
    m_lAudioSubChannel = lAudioSubChannel;

    return HW_Tune(m_lChannel, m_lChannel);
}

STDMETHODIMP
CTunerMode::get_Channel(
    long * plChannel,
    long * plVideoSubChannel,
    long * plAudioSubChannel)
{
    *plChannel = m_lChannel;
    *plVideoSubChannel = m_lVideoSubChannel;
    *plAudioSubChannel = m_lAudioSubChannel;
    
    return NOERROR;
}

STDMETHODIMP
CTunerMode::ChannelMinMax(long *plChannelMin, long *plChannelMax)
{
    // Total hack follows.  Only the CTVTuner class knows about the
    // step to get to adjacent frequencies, and this is not exposed
    // anywhere in the COM interface.  As a special case for
    // ChannelMinMax, if both the min and max values point at the same
    // location (which would normally be an app bug), then return 
    // the UI step value instead. 

    if (plChannelMin == plChannelMax) {
        *plChannelMin = GetChannelStep();
    } 
    else {
        // For non TV Modes, the MinMax can be found directly from the Caps
        *plChannelMin = m_ModeCaps.MinFrequency;
        *plChannelMax = m_ModeCaps.MaxFrequency;
    }


    return NOERROR;
}

STDMETHODIMP 
CTunerMode::AutoTune (long lChannel, long * plFoundSignal)
{
    return S_OK;
}

STDMETHODIMP 
CTunerMode::StoreAutoTune ()
{
    return S_OK;
}

//
// In general, the possible return values are:
//      AMTUNER_HASNOSIGNALSTRENGTH	= -1,
//      AMTUNER_NOSIGNAL	= 0,
//      AMTUNER_SIGNALPRESENT = 1
//
// But the virtual case for AM/FM gets the actual signal strength
// from the hardware.

STDMETHODIMP 
CTunerMode::SignalPresent( 
            /* [out] */ long *plSignalStrength)
{
    HW_GetStatus ();
    *plSignalStrength = m_Status.SignalStrength;
    return NOERROR;
}

// Returns the "Mode" of this subtuner, not the mode of the overall tuner!!!
STDMETHODIMP 
CTunerMode::get_Mode(/* [in] */ AMTunerModeType *plMode)
{
    *plMode = (AMTunerModeType) m_Mode;
    return NOERROR;
}

//
// All subtuners are informed of global tuner mode changes
//
STDMETHODIMP 
CTunerMode::put_Mode(/* [in] */ AMTunerModeType lMode)
{
    BOOL fOk;
    KSPROPERTY_TUNER_MODE_S TunerMode;
    ULONG cbReturned;

    m_Active = (lMode == m_Mode);

    if (m_Active) {
        TunerMode.Property.Set   = PROPSETID_TUNER;
        TunerMode.Property.Id    = KSPROPERTY_TUNER_MODE;
        TunerMode.Property.Flags = KSPROPERTY_TYPE_SET;
        TunerMode.Mode           = m_Mode;
    
        fOk = KsControl(m_pTVTuner->Device(),
                        (DWORD) IOCTL_KS_PROPERTY, 
                        &TunerMode, sizeof( KSPROPERTY_TUNER_MODE_S), 
                        &TunerMode, sizeof( KSPROPERTY_TUNER_MODE_S), 
                        &cbReturned);
        
        if (fOk) {
            return put_Channel (m_lChannel, m_lVideoSubChannel, m_lAudioSubChannel);
        }
        else {
            DbgLog(( LOG_ERROR, 0, 
                     TEXT("FAILED:  KSPROPERTY_TUNER_MODE, KSPROPERTY_TYPE_SET, cbReturned = %d"), cbReturned));
            return E_INVALIDARG;
        }
    }

    return S_OK;
}

STDMETHODIMP 
CTunerMode::get_VideoFrequency (long * plFreq)
{
    *plFreq = m_lVideoCarrier;
    return NOERROR;
}

STDMETHODIMP 
CTunerMode::get_AudioFrequency (long * plFreq)
{
    *plFreq = m_lAudioCarrier;
    return NOERROR;
}

STDMETHODIMP 
CTunerMode::get_AvailableTVFormats (long * plAnalogVideoStandard)
{
    *plAnalogVideoStandard = m_ModeCaps.StandardsSupported;
    return NOERROR;
}

STDMETHODIMP 
CTunerMode::get_TVFormat (long *plAnalogVideoStandard)
{
    // This will be zero for AM and FM, so don't ASSERT (m_TVFormatInfo.AVStandard);
    *plAnalogVideoStandard = m_TVFormatInfo.AVStandard;

    return NOERROR;
}

STDMETHODIMP
CTunerMode::put_CountryCode(long lCountryCode)
{
    HRESULT hr = S_OK;

    m_lCountryCode = lCountryCode;
    if (m_Active) {
        hr = put_Channel (m_lChannel, m_lVideoSubChannel, m_lAudioSubChannel);
    }
    return hr;
}

// The fForce parameter forces the first enumerated videostandard
// to be selected

BOOL 
CTunerMode::SetTVFormatInfo(
        AnalogVideoStandard AVStandard,
        TVFORMATINFO *pTVFormatInfo,
        BOOL fForce)
{

    TVFORMATINFO * pTVInfo = m_TVTunerFormatCaps;

    // Walk the list of supported formats 

    for (int j = 0; j < NUM_TVTUNER_FORMATS; j++, pTVInfo++) {
        if (pTVInfo->fSupported == TRUE) {
            if ((pTVInfo->AVStandard == AVStandard) || fForce) {
                *pTVFormatInfo = *pTVInfo;

                return TRUE;
            }
        }
    }
    return FALSE;
}

// -------------------------------------------------------------------------
// CTunerMode_AMFM
// -------------------------------------------------------------------------

STDMETHODIMP
CTunerMode_AMFM::put_Channel(long lChannel, long, long)
{
    long junkFoundSignal;

    return AutoTune(lChannel, &junkFoundSignal);
}

/* Search either up or down from the given frequency looking
 * for a perfect lock. If we are close on the first call, call
 * ourselves recursively, noting the trend.
 *
 * There is a limit on the number of times we can recurse. If
 * the new trend conflicts with the previous trend, then we must
 * have hopped over the "perfect" frequency, in which case the
 * most recent frequency will be considered a perfect lock.
 */
BOOL 
CTunerMode_AMFM::SearchNeighborhood( 
                                   long freq,
                                   TuningTrend trend = AdjustingNone,
                                   int depth = 0
    )
{
    BOOL rc = FALSE;

#ifdef DEBUG
    LPTSTR lpszTrend;

    switch (trend)
    {
    case AdjustingUp:
        lpszTrend = TEXT("Adjusting Up");
        break;

    case AdjustingDown:
        lpszTrend = TEXT("Adjusting Down");
        break;

    case AdjustingNone:
        lpszTrend = TEXT("Initial Try");
        break;
    }

    DbgLog(
        ( LOG_TRACE, 2
        , TEXT("SearchNeighborhood(freq = %d) %s")
        , freq
        , lpszTrend
        )
        );
#endif

    if (depth > SearchLimit)
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Recursion limit reached, bailing out")
            )
            );

        return FALSE;
    }

    /* Set the Video and Audio frequencies to be the same
     */
    m_lVideoCarrier = m_lAudioCarrier = freq;

    /* Check if the frequencies are beyond the limits of the tuner
     */
    if (m_lVideoCarrier < (long) m_ModeCaps.MinFrequency || m_lVideoCarrier > (long) m_ModeCaps.MaxFrequency)
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Frequency out of range")
            )
        );
        return FALSE;
    }

    /* Try the given frequencies without adjustment
     */
    HRESULT hr = HW_Tune(m_lVideoCarrier, m_lAudioCarrier);
    if (hr == S_OK)
    {
        // In order to improve frequency search times, the gross assumption here is that 
        // the SettlingTime must be honored for large jumps, but that smaller frequency
        // changes (made by us, incidentally) can get by with smaller settling times.

        if (AdjustingNone == trend)
            Sleep(m_ModeCaps.SettlingTime);
        else
            Sleep(5);

        // For some reason, the Philips FR1236 returns Busy (FL == 0) for a much longer time
        // than it should.  Keep looping, hoping it will become unbusy.

        for (int j = 0; j < 5; j++) {
            hr = HW_GetStatus();
            if (hr == S_OK && !m_Status.Busy) {
                break;
            }
            Sleep(5);
        }

        DbgLog(( LOG_TRACE, 5, TEXT("TUNING: PLLOffset = %d, Busy = %d"), (LONG) m_Status.PLLOffset, (LONG) m_Status.Busy));

        if (hr == S_OK && !m_Status.Busy)
        {
            /* Act according to the tuning trend (if any)
             */
            switch (trend)
            {
            case AdjustingNone:
                switch ((LONG) m_Status.PLLOffset)
                {
                case 1:        // Need to adjust up
                    rc = SearchNeighborhood
                    ( freq + m_ModeCaps.TuningGranularity
                    , AdjustingUp, depth+1
                    );
                    break;

                case -1:    // Need to adjust down
                    rc = SearchNeighborhood
                    ( freq - m_ModeCaps.TuningGranularity
                    , AdjustingDown, depth+1
                    );
                    break;

                case 0:        // Perfect
                    rc = TRUE;
                    break;

                default:    // Just plain missed
                    rc = FALSE;
                }
                break;

            case AdjustingUp:
                switch ((LONG) m_Status.PLLOffset)
                {
                case 1:        // Close but still low
                    rc = SearchNeighborhood
                    ( freq + m_ModeCaps.TuningGranularity
                    , AdjustingUp, depth+1
                    );
                    break;

                case -1:    // Switched trend
                case 0:        // Perfect
                    rc = TRUE;
                    break;

                default:    // Something is very wrong
                    rc = FALSE;
                }
                break;

            case AdjustingDown:
                switch ((LONG) m_Status.PLLOffset)
                {
                case -1:    // Close but still high
                    rc = SearchNeighborhood
                    (freq - m_ModeCaps.TuningGranularity
                    , AdjustingDown, depth+1
                    );
                    break;

                case 1:        // Switched trend
                case 0:        // Perfect
                    rc = TRUE;
                    break;

                default:    // Something is very wrong
                    rc = FALSE;
                }
                break;
            }
        }
        else
            m_Status.PLLOffset = 100; // set to a really bad value
    }

    return rc;
}

STDMETHODIMP 
CTunerMode_AMFM::AutoTune (long lChannel, long * plFoundSignal)
{
    long SignalStrength = AMTUNER_NOSIGNAL;

    // Set a flag so everybody else knows we're in the midst of an AutoTune operation
    if (InterlockedCompareExchangePointer(&m_InAutoTune, reinterpret_cast<void*>(TRUE), reinterpret_cast<void*>(FALSE)) != reinterpret_cast<void*>(FALSE))
        return S_FALSE; // already set to TRUE, don't interrupt the current autotune

    m_lChannel = lChannel;
    m_lVideoSubChannel = -1;
    m_lAudioSubChannel = -1;

    DbgLog(( LOG_TRACE, 2, TEXT("Start AutoTune(channel = %d)"), m_lChannel));

    HRESULT hr = AutoTune();
    if (NOERROR == hr)
        SignalPresent(&SignalStrength);

    // Assume AMTUNER_HASNOSIGNALSTRENGTH means tuned
    *plFoundSignal = (SignalStrength != AMTUNER_NOSIGNAL);

    InterlockedExchangePointer(&m_InAutoTune, reinterpret_cast<void*>(FALSE));

    return hr;
}

HRESULT
CTunerMode_AMFM::AutoTune(void)
{
    BOOL bFoundSignal = FALSE;
    long freq = m_lChannel;

    // if the driver has the tuning logic, let it do the hard part
    if (m_ModeCaps.Strategy == KS_TUNER_STRATEGY_DRIVER_TUNES) {

        // Set the Video and Audio frequencies to the same value
        m_lVideoCarrier = m_lAudioCarrier = freq;

        // Try the given frequencies without adjustment
        HRESULT hr = HW_Tune(m_lVideoCarrier, m_lAudioCarrier);
        if (hr == S_OK) {

            DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Started")));
            Sleep(m_ModeCaps.SettlingTime);
            DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Finished")));
        }
        else {

            DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Unsuccessful")));
        }

        return hr;
    }

    // Broadcast (Antenna)
    bFoundSignal = SearchNeighborhood(freq);    // anchor the search at the default
    if (!bFoundSignal) {

        DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Starting Exhaustive Search")));

        /* The default frequency isn't working. Take the brute-force
         * approach.
         *
         * Search through a band around the target frequency, ending
         * up at the default target frequency if no signal is found.
         */
        long halfband = (m_Mode == AMTUNER_MODE_FM_RADIO ? 100000 : 5000);   // 100KHz (FM) or 5KHz (AM)
        long slices = halfband / m_ModeCaps.TuningGranularity;
        long idx;

        // Step through the band above target frequency
        for (idx = 1; !bFoundSignal && idx <= slices; idx++) {

            bFoundSignal = SearchNeighborhood
                ( freq + (m_ModeCaps.TuningGranularity * idx)
                , AdjustingUp       // Wait for one frame
                , SearchLimit-1     // Let the search fine-tune
                );
        }

        if (!bFoundSignal) {

            // Step through the band below the target frequency
            bFoundSignal = SearchNeighborhood(freq - halfband);   // anchor the search
            for (idx = slices - 1; !bFoundSignal && idx >= 0; idx--) {

                bFoundSignal = SearchNeighborhood
                    ( freq - (m_ModeCaps.TuningGranularity * idx)
                    , AdjustingUp       // Wait for one frame
                    , SearchLimit-1     // Let the search fine-tune
                    );
            }
        }
    }

#ifdef DEBUG
    // That's all we can do, check the flag, display the results, and save (or clear) the frequency
    if (bFoundSignal)
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Exiting AutoTune(channel = %d) Locked")
            , m_lChannel
            )
        );
    }
    else
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Exiting AutoTune(channel = %d) Not Locked")
            , m_lChannel
            )
        );
    }
#endif

    return bFoundSignal ? NOERROR : S_FALSE;
}

// -------------------------------------------------------------------------
// CTunerMode_TV
// -------------------------------------------------------------------------

//
// Channel of -1 means just propogate tuning information downstream for VBI codecs
//
STDMETHODIMP
CTunerMode_TV::put_Channel(
    long lChannel,
    long lVideoSubChannel,
    long lAudioSubChannel)
{
    KS_TVTUNER_CHANGE_INFO ChangeInfo;
    HRESULT hr = NOERROR;

#ifdef DEBUG
    DWORD dwTimeStart, dwTimeToTune, dwTimeToDeliver, dwTimeTotal;
    dwTimeStart = timeGetTime();
#endif

    //
    // -1 is used to indicate that we only want to propogate previous tuning info
    // onto the output pin, but not actually tune!
    //

    /* Inform the filter of the start of the channel change
     */
    ChangeInfo.dwChannel = lChannel;
    ChangeInfo.dwAnalogVideoStandard = m_TVFormatInfo.AVStandard;
    m_pTVTuner->get_CountryCode ((long *) &ChangeInfo.dwCountryCode);
    ChangeInfo.dwFlags = KS_TVTUNER_CHANGE_BEGIN_TUNE;
    m_pTVTuner->DeliverChannelChangeInfo(ChangeInfo, m_Mode);

#ifdef DEBUG
    dwTimeToDeliver = timeGetTime();
#endif

    if (lChannel != -1) {
        // Set a flag so everybody else knows we're in the midst of an AutoTune operation
        if (InterlockedCompareExchangePointer(&m_InAutoTune, reinterpret_cast<void*>(TRUE), reinterpret_cast<void*>(FALSE)) == reinterpret_cast<void*>(FALSE)) {
            m_lChannel = lChannel;
            m_lVideoSubChannel = lVideoSubChannel;
            m_lAudioSubChannel = lAudioSubChannel;

            DbgLog(( LOG_TRACE, 2, TEXT("Start AutoTune(channel = %d)"), m_lChannel));

            hr = AutoTune(FALSE);

            InterlockedExchangePointer(&m_InAutoTune, reinterpret_cast<void*>(FALSE));
        }
        else {
            hr = S_FALSE; // don't interrupt the current autotune
        }
    }

#ifdef DEBUG
    dwTimeToTune = timeGetTime();
#endif

    /* Inform the filter of the end of the channel change
     */
    ChangeInfo.dwFlags = KS_TVTUNER_CHANGE_END_TUNE;
    m_pTVTuner->DeliverChannelChangeInfo(ChangeInfo, m_Mode);


#ifdef DEBUG
    dwTimeTotal = timeGetTime();
    DbgLog(
        ( LOG_TRACE, 5
        , TEXT("Channel=%d, Deliver (time ms)=%d, Tune (time ms)=%d, Total (time ms)=%d")
        , lChannel
        , dwTimeToDeliver - dwTimeStart
        , dwTimeToTune - dwTimeStart
        , dwTimeTotal - dwTimeStart
        )
        );
#endif
    return hr;
}


STDMETHODIMP
CTunerMode_TV::ChannelMinMax(long *plChannelMin, long *plChannelMax)
{
    CChanList * pListCurrent = m_pTVTuner->GetCurrentChannelList();
    if (!pListCurrent) {
        return E_FAIL;
    }

    // Total hack follows.  Only the CTVTuner class knows about the
    // step to get to adjacent frequencies, and this is not exposed
    // anywhere in the COM interface.  As a special case for
    // ChannelMinMax, if both the min and max values point at the same
    // location (which would normally be an app bug), then return 
    // the UI step value instead. 

    if (plChannelMin == plChannelMax) {
        *plChannelMin = GetChannelStep();
    } 
    else {
        pListCurrent->GetChannelMinMax (plChannelMin, plChannelMax,
                m_ModeCaps.MinFrequency, m_ModeCaps.MaxFrequency);
    }
    return NOERROR;
}


/* Search either up or down from the given frequency looking
 * for a perfect lock. If we are close on the first call, call
 * ourselves recursively, noting the trend.
 *
 * There is a limit on the number of times we can recurse. If
 * the new trend conflicts with the previous trend, then we must
 * have hopped over the "perfect" frequency, in which case the
 * most recent frequency will be considered a perfect lock.
 */
BOOL 
CTunerMode_TV::SearchNeighborhood( 
                                   long freq,
                                   TuningTrend trend = AdjustingNone,
                                   int depth = 0
    )
{
    BOOL rc = FALSE;

#ifdef DEBUG
    LPTSTR lpszTrend;

    switch (trend)
    {
    case AdjustingUp:
        lpszTrend = TEXT("Adjusting Up");
        break;

    case AdjustingDown:
        lpszTrend = TEXT("Adjusting Down");
        break;

    case AdjustingNone:
        lpszTrend = TEXT("Initial Try");
        break;
    }

    DbgLog(
        ( LOG_TRACE, 2
        , TEXT("SearchNeighborhood(freq = %d) %s")
        , freq
        , lpszTrend
        )
        );
#endif

    if (depth > SearchLimit)
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Recursion limit reached, bailing out")
            )
            );

        return FALSE;
    }

    /* Save the Video and Audio frequencies
     */
    m_lVideoCarrier = freq;
    m_lAudioCarrier = freq + m_TVFormatInfo.lSoundOffset;

    /* Check if the frequencies are beyond the limits of the tuner
     */
    if (m_lVideoCarrier < (long) m_ModeCaps.MinFrequency || m_lVideoCarrier > (long) m_ModeCaps.MaxFrequency)
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Frequency out of range")
            )
        );
        return FALSE;
    }

    /* Try the given frequencies without adjustment
     */
    HRESULT hr = HW_Tune(m_lVideoCarrier, m_lAudioCarrier);
    if (hr == S_OK)
    {
        // convert REFERENCE_TIME [100ns units] to ms
        DWORD dwFrameTime_ms = static_cast<DWORD>(m_TVFormatInfo.AvgTimePerFrame/10000L) + 1L;

        // In order to improve channel switching times, the gross assumption here is that 
        // the SettlingTime must be honored for large jumps, but that smaller, in-channel frequency
        // changes (made by us, incidentally) can get by with smaller settling times.

        if (AdjustingNone == trend)
            Sleep(m_ModeCaps.SettlingTime);
        else
            Sleep(dwFrameTime_ms);

        // For some reason, the Philips FR1236 returns Busy (FL == 0) for a much longer time
        // than it should.  Keep looping, hoping it will become unbusy.

        for (int j = 0; j < 5; j++) {
            hr = HW_GetStatus();
            if (hr == S_OK && !m_Status.Busy) {
                break;
            }
            Sleep(dwFrameTime_ms);  // wait a frame
        }

        DbgLog(( LOG_TRACE, 5, TEXT("TUNING: PLLOffset = %d, Busy = %d"), (LONG) m_Status.PLLOffset, (LONG) m_Status.Busy));

        if (hr == S_OK && !m_Status.Busy)
        {
            /* Act according to the tuning trend (if any)
             */
            switch (trend)
            {
            case AdjustingNone:
                switch ((LONG) m_Status.PLLOffset)
                {
                case 1:        // Need to adjust up
                    rc = SearchNeighborhood
                    ( freq + m_ModeCaps.TuningGranularity
                    , AdjustingUp, depth+1
                    );
                    break;

                case -1:    // Need to adjust down
                    rc = SearchNeighborhood
                    ( freq - m_ModeCaps.TuningGranularity
                    , AdjustingDown, depth+1
                    );
                    break;

                case 0:        // Perfect
                    rc = TRUE;
                    break;

                default:    // Just plain missed
                    rc = FALSE;
                }
                break;

            case AdjustingUp:
                switch ((LONG) m_Status.PLLOffset)
                {
                case 1:        // Close but still low
                    rc = SearchNeighborhood
                    ( freq + m_ModeCaps.TuningGranularity
                    , AdjustingUp, depth+1
                    );
                    break;

                case -1:    // Switched trend
                case 0:        // Perfect
                    rc = TRUE;
                    break;

                default:    // Something is very wrong
                    rc = FALSE;
                }
                break;

            case AdjustingDown:
                switch ((LONG) m_Status.PLLOffset)
                {
                case -1:    // Close but still high
                    rc = SearchNeighborhood
                    (freq - m_ModeCaps.TuningGranularity
                    , AdjustingDown, depth+1
                    );
                    break;

                case 1:        // Switched trend
                case 0:        // Perfect
                    rc = TRUE;
                    break;

                default:    // Something is very wrong
                    rc = FALSE;
                }
                break;
            }
        }
        else
            m_Status.PLLOffset = 100; // set to a really bad value
    }

    return rc;
}

STDMETHODIMP 
CTunerMode_TV::AutoTune (long lChannel, long * plFoundSignal)
{
    long SignalStrength = AMTUNER_NOSIGNAL;

    // Set a flag so everybody else knows we're in the midst of an AutoTune operation
    if (InterlockedCompareExchangePointer(&m_InAutoTune, reinterpret_cast<void*>(TRUE), reinterpret_cast<void*>(FALSE)) != reinterpret_cast<void*>(FALSE))
        return S_FALSE; // already set to TRUE, don't interrupt the current autotune

    m_lChannel = lChannel;
    m_lVideoSubChannel = -1;
    m_lAudioSubChannel = -1;

    DbgLog(( LOG_TRACE, 2, TEXT("Start AutoTune(channel = %d)"), m_lChannel));

    // Attempt to tune without using any previous autotune frequency (start from scratch)
    HRESULT hr = AutoTune(TRUE);
    if (NOERROR == hr)
        SignalPresent(&SignalStrength);

    // Assume AMTUNER_HASNOSIGNALSTRENGTH means tuned
    *plFoundSignal = (SignalStrength != AMTUNER_NOSIGNAL);

    InterlockedExchangePointer(&m_InAutoTune, reinterpret_cast<void*>(FALSE));

    return hr;
}

HRESULT
CTunerMode_TV::AutoTune(BOOL bFromScratch)
{
    BOOL bFoundSignal = FALSE;
    long freq = 0L;

    CChanList * pListCurrent = m_pTVTuner->GetCurrentChannelList();
    if (!pListCurrent) {
        return E_FAIL;
    }
    
    // this could override bFromScratch if no autotune frequency is found
    bFromScratch = pListCurrent->GetFrequency(m_lChannel, &freq, bFromScratch);
    if (0 == freq) {
        return S_FALSE; // no frequency for this channel
    }

    // if the driver has the tuning logic, let it do the hard part
    if (m_ModeCaps.Strategy == KS_TUNER_STRATEGY_DRIVER_TUNES) {

        // Save the Video and Audio frequencies
        m_lVideoCarrier = freq;
        m_lAudioCarrier = freq + m_TVFormatInfo.lSoundOffset;

        // Try the given frequencies without adjustment
        HRESULT hr = HW_Tune(m_lVideoCarrier, m_lAudioCarrier);
        if (hr == S_OK) {

            DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Started")));
            Sleep(m_ModeCaps.SettlingTime);
            DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Finished")));
        }
        else {

            DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Unsuccessful")));
        }

        return hr;
    }

    // if we have a previously fine-tuned frequency, then give the frequency
    // the benefit of the doubt before doing anything fancy
    if (!bFromScratch) {

        bFoundSignal = SearchNeighborhood(freq);
        if (!bFoundSignal) {

            // what once worked no longer works, start over with the default
            bFromScratch = pListCurrent->GetFrequency(m_lChannel, &freq, TRUE);
        }
        else {

            DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Found fine-tuned")));
        }
    }

    if (!bFoundSignal) {

        if (TunerInputCable == m_pTVTuner->GetCurrentInputType()) {

            int iCableSystem, preferredCableSystem;

            // --------------------------------------------------------
            // The main Cable TV Tuning loop
            // Keeps track of the CableSystem which has been used most
            // successfully in the past and uses it preferentially.
            // --------------------------------------------------------

            // The following must be true for the following code to work
            ASSERT
                (
                CableSystem_Current  == 0 &&
                CableSystem_Standard == 1 &&
                CableSystem_IRC      == 2 &&
                CableSystem_HRC      == 3 &&
                CableSystem_End      == 4
                );

            // Figure out which cable tuning space has been most successful (give preferrence
            // to CableSystem_Standard in the absence of any other hits)
            int *pCableSystemCounts = m_pTVTuner->GetCurrentCableSystemCountsForCurrentInput();
            pCableSystemCounts[CableSystem_Current] = pCableSystemCounts[CableSystem_Standard];
            preferredCableSystem = CableSystem_Standard;

            // Sort for the system with the most hits (CableSystem_Standard will never have any
            // hits, so as to allow IRC a chance to be best)
            for (iCableSystem = CableSystem_Standard; iCableSystem < CableSystem_End; iCableSystem++) {

                if (pCableSystemCounts[CableSystem_Current] < pCableSystemCounts[iCableSystem]) {
                    pCableSystemCounts[CableSystem_Current] = pCableSystemCounts[iCableSystem];
                    preferredCableSystem = iCableSystem; 
                }
            }

            for (int cs = CableSystem_Current; !bFoundSignal && cs < CableSystem_End; cs++) {

                if (cs == CableSystem_Current) {
                    // Try whichever system has been most successful first
                    m_CableSystem = preferredCableSystem;
                }
                else {
                    m_CableSystem = cs;
                }

                // Avoid testing the default or current system twice
                if (cs != CableSystem_Current && cs == preferredCableSystem) {
                    continue;
                }

                switch (m_CableSystem) {

                case CableSystem_Standard:
                    bFoundSignal = SearchNeighborhood(freq);                        // Std
                    if (bFoundSignal) {
                        // Never bump this count, otherwise IRC would never win
                        // pCableSystemCounts[CableSystem_Standard]++;
                        DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Found Standard")));
                    }
                    break;
    
                case CableSystem_IRC:
                    if (m_lChannel == 5 || m_lChannel == 6) {
                        bFoundSignal = SearchNeighborhood(freq + 2000000);          // IRC (5,6)
                        if (bFoundSignal) {
                            // this is the only time we are sure we have an IRC cable system
                            pCableSystemCounts[CableSystem_IRC]++;
                        }
                    }

                    // No need to check the other channels since IRC is otherwise identical to
                    // CableSystem_Standard, which has already been done (or will be done next)

                    if (bFoundSignal) {
                        DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Found IRC")));
                    }
                    break;
    
                case CableSystem_HRC:
                    if (m_lChannel == 5 || m_lChannel == 6) {
                        bFoundSignal = SearchNeighborhood(freq + 750000);           // HRC (5,6)
                    }
                    else {
                        bFoundSignal = SearchNeighborhood(freq - 1250000);          // HRC
                    }

                    if (bFoundSignal) {
                        pCableSystemCounts[CableSystem_HRC]++;
                        DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Found HRC")));
                    }
                    break;

                default:
                    ASSERT(CableSystem_End != m_CableSystem);   // Shouldn't get here
                }

                // Don't try IRC or HRC if not USA Cable
                if ( !(F_USA_CABLE == pListCurrent->GetFreqListID()) )
                    break;
            }

#ifdef LINEAR_SEARCH_FOR_TEST_KIT
            if (!bFoundSignal) {
                // Check if using the "Uni-Cable" frequency list
                if (F_UNI_CABLE == pListCurrent->GetFreqListID()) {

                    DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Starting Exhaustive Search")));

                    /* The default frequency isn't working. Take the brute-force
                     * approach.
                     *
                     * Start at the target frequency, and work up to almost 1MHz
                     * above the target frequency. This is optimized for a cable
                     * channel line-up consisting of a channel at each 1MHz
                     * increment.
                     */
                    long slices = 1000000 / m_ModeCaps.TuningGranularity;
                    long idx;

                    // Step upward from the target frequency
                    for (idx = 1; idx < slices; idx++) {
                        bFoundSignal = SearchNeighborhood
                            ( freq + (m_ModeCaps.TuningGranularity * idx)
                            , AdjustingUp                                   // Wait for one frame
                            , SearchLimit-1                                 // Let the search fine-tune
                            );
                        if (bFoundSignal)
                            break;
                    }
                }
            }
#endif
        }
        else {

            // Broadcast (Antenna)
            bFoundSignal = SearchNeighborhood(freq);    // anchor the search at the default
            if (!bFoundSignal) {

                DbgLog(( LOG_TRACE, 5, TEXT("TUNING: Starting Exhaustive Search")));

                /* The default frequency isn't working. Take the brute-force
                 * approach.
                 *
                 * Search through the .5MHz band around the target frequency,
                 * ending up at the default target frequency.
                 */
                long slices = 250000 / m_ModeCaps.TuningGranularity;
                long idx;

                // Step through a .25MHz range (inclusive) above target frequency
                for (idx = 1; !bFoundSignal && idx <= slices; idx++) {

                    bFoundSignal = SearchNeighborhood
                        ( freq + (m_ModeCaps.TuningGranularity * idx)
                        , AdjustingUp       // Wait for one frame
                        , SearchLimit-1     // Let the search fine-tune
                        );
                }

                if (!bFoundSignal) {

                    // Step through a .25MHz range (inclusive) below the target frequency
                    bFoundSignal = SearchNeighborhood(freq - 250000);   // anchor the search
                    for (idx = slices - 1; !bFoundSignal && idx >= 0; idx--) {

                        bFoundSignal = SearchNeighborhood
                            ( freq - (m_ModeCaps.TuningGranularity * idx)
                            , AdjustingUp       // Wait for one frame
                            , SearchLimit-1     // Let the search fine-tune
                            );
                    }
                }
            }
        }
    }

    // That's all we can do, check the flag, display the results, and save (or clear) the frequency
    if (bFoundSignal)
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Exiting AutoTune(channel = %d) Locked")
            , m_lChannel
            )
        );

        pListCurrent->SetAutoTuneFrequency (m_lChannel, m_lVideoCarrier);
    }
    else
    {
        DbgLog(
            ( LOG_TRACE, 2
            , TEXT("Exiting AutoTune(channel = %d) Not Locked")
            , m_lChannel
            )
        );

        pListCurrent->SetAutoTuneFrequency (m_lChannel, 0);
    }

    return bFoundSignal ? NOERROR : S_FALSE;
}

STDMETHODIMP
CTunerMode_TV::put_CountryCode(long lCountryCode)
{
    AnalogVideoStandard lAnalogVideoStandard;
    BOOL fSupported;

    DbgLog(
        ( LOG_TRACE, 2
        , TEXT("put_CountryCode(lCountryCode = %d)")
        , lCountryCode
        )
    );

    if (m_lCountryCode == lCountryCode)
        return NOERROR;

    CChanList * pListCurrent = m_pTVTuner->GetCurrentChannelList();
    if (!pListCurrent) {
        return E_FAIL;
    }
    
    lAnalogVideoStandard = m_pTVTuner->GetVideoStandardForCurrentCountry();
    ASSERT (lAnalogVideoStandard);

    // Check if the format of this country is supported by the tuner
    // Even if it's not, continue with initialization so we don't blow
    // up later trying to reference invalid frequency lists!

    fSupported = SetTVFormatInfo(lAnalogVideoStandard, &m_TVFormatInfo, FALSE);
    if (!fSupported) {
        if (m_lCountryCode == -1) {
            SetTVFormatInfo(lAnalogVideoStandard, &m_TVFormatInfo, TRUE);
        }
        else {
            return HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
        }
    }

    // Post Win98 SP1, inform the tuner of the new video standard!!!
    HW_SetVideoStandard(lAnalogVideoStandard);

    m_lCountryCode = lCountryCode;

    if (m_Active) {
        put_Channel (m_lChannel, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
    }

    return NOERROR;
}


// Look downstream for a locked signal on the VideoDecoder
//
// Possible plSignalStrength values are:
//      AMTUNER_HASNOSIGNALSTRENGTH	= -1,
//      AMTUNER_NOSIGNAL	= 0,
//      AMTUNER_SIGNALPRESENT = 1
//
STDMETHODIMP 
CTunerMode_TV::SignalPresent( 
            /* [out] */ long *plSignalStrength)
{
    HRESULT hr;
    long Locked;
    IAMAnalogVideoDecoder *pAnalogVideoDecoder;
    IPin *pPinConnected;
    CBasePin *pPin = m_pFilter->GetPinFromType(TunerPinType_Video);

    // Assume the worst
    *plSignalStrength = AMTUNER_HASNOSIGNALSTRENGTH;

    // if the video output pin is connected
    if (pPin && pPin->IsConnected()) {
        // get the pin on the downstream filter
        if (SUCCEEDED (hr = pPin->ConnectedTo(&pPinConnected))) { 
            // recursively search for the requested interface
            if (SUCCEEDED (hr = m_pFilter->FindDownstreamInterface (
                                    pPinConnected, 
                                    __uuidof (IAMAnalogVideoDecoder),
                                    (void **) &pAnalogVideoDecoder))) {
                pAnalogVideoDecoder->get_HorizontalLocked(&Locked);
                pAnalogVideoDecoder->Release();
                *plSignalStrength = Locked ? AMTUNER_SIGNALPRESENT : AMTUNER_NOSIGNAL;
            }
            pPinConnected->Release();
        }
    }
    return NOERROR;
}


// -------------------------------------------------------------------------
// CTunerMode_ATSC
// -------------------------------------------------------------------------

// Look downstream for a locked signal on the Demodulator
//
// Possible plSignalStrength values are:
//      AMTUNER_HASNOSIGNALSTRENGTH	= -1,
//      AMTUNER_NOSIGNAL	= 0,
//      AMTUNER_SIGNALPRESENT = 1
//
STDMETHODIMP 
CTunerMode_ATSC::SignalPresent( 
            /* [out] */ long *plSignalStrength)
{
    *plSignalStrength = AMTUNER_SIGNALPRESENT;


    // Hack, for now, DTV lock is returned from the tuner via
    // SignalStrength!!!

    HW_GetStatus ();
    *plSignalStrength = m_Status.SignalStrength;


#if 0 // update for Demodulator interface
    
    HRESULT hr;
    long Locked;
    IAMDemodulator *pDemodulator;
    IPin *pPinConnected;
    CBasePin *pPin = m_pFilter->GetPinFromType(TunerPinType_IF);

    // Assume the worst
    *plSignalStrength = AMTUNER_HASNOSIGNALSTRENGTH;

    // if the video output pin is connected
    if (pPin && pPin->IsConnected()) {
        // get the pin on the downstream filter
        if (SUCCEEDED (hr = pPin->ConnectedTo(&pPinConnected))) { 
            // recursively search for the requested interface
            if (SUCCEEDED (hr = m_pFilter->FindDownstreamInterface (
                                    pPinConnected, 
                                    __uuidof (IAMDemodulator),
                                    (void **) &pDemodulator))) {
                pDemodulator->get_Locked(&Locked);
                pDemodulator->Release();
                *plSignalStrength = Locked ? AMTUNER_SIGNALPRESENT : AMTUNER_NOSIGNAL;
            }
            pPinConnected->Release();
        }
    }
#endif
    return NOERROR;
}


// -------------------------------------------------------------------------
// CTVTuner class
// 
// Encapsulates multiple subtuners
// -------------------------------------------------------------------------

// Get the formats supported by the device
// This should be the first call made during initialization
HRESULT
CTVTuner::HW_GetTVTunerCaps()
{
    BOOL fOk;
    ULONG cbReturned;
    KSPROPERTY_TUNER_CAPS_S TunerCaps;

    if ( !m_hDevice )
          return E_INVALIDARG;

    // Get the overall modes supported, ie.
    // TV, FM, AM, DSS, ...

    ZeroMemory (&TunerCaps, sizeof (TunerCaps));

    TunerCaps.Property.Set   = PROPSETID_TUNER;
    TunerCaps.Property.Id    = KSPROPERTY_TUNER_CAPS;
    TunerCaps.Property.Flags = KSPROPERTY_TYPE_GET;

    fOk = KsControl(m_hDevice,
                    (DWORD) IOCTL_KS_PROPERTY, 
                    &TunerCaps, sizeof( KSPROPERTY_TUNER_CAPS_S), 
                    &TunerCaps, sizeof( KSPROPERTY_TUNER_CAPS_S), 
                    &cbReturned);

    if (!fOk) {
        DbgLog(( LOG_ERROR, 0, 
                 TEXT("FAILED:  KSPROPERTY_TUNER_CAPS, KSPROPERTY_TYPE_GET, cbReturned = %d"), cbReturned));
        return E_FAIL;
    }

    m_TunerCaps = TunerCaps;

    // Check if m_lTotalInputs not already gotten from a previous instance (via IPersistStream)
    if (m_lTotalInputs == 0)
    {
        KSPROPERTY_TUNER_MODE_CAPS_S TunerModeCaps;

        // GAK!!! Now get details of the TV mode capabilities
        // only to get the number of inputs!!! Very Ugly!!!

        TunerModeCaps.Property.Set   = PROPSETID_TUNER;
        TunerModeCaps.Property.Id    = KSPROPERTY_TUNER_MODE_CAPS;
        TunerModeCaps.Property.Flags = KSPROPERTY_TYPE_GET;
        TunerModeCaps.Mode           = KSPROPERTY_TUNER_MODE_TV;

        fOk = KsControl(m_hDevice,
                        (DWORD) IOCTL_KS_PROPERTY, 
                        &TunerModeCaps, sizeof( KSPROPERTY_TUNER_MODE_CAPS_S), 
                        &TunerModeCaps, sizeof( KSPROPERTY_TUNER_MODE_CAPS_S), 
                        &cbReturned);

        if ( fOk ) {
            m_lTotalInputs = TunerModeCaps.NumberOfInputs;
        }
        else {
            DbgLog(( LOG_ERROR, 0, 
                     TEXT("FAILED:  KSPROPERTY_TUNER_MODE_CAPS, KSPROPERTY_TYPE_GET, cbReturned = %d"), cbReturned));
        }
    }
                   
    // Figure out if the device supports an IntermediateFreq Pin
    // Post Win98 SP1
    KSPROPERTY_TUNER_IF_MEDIUM_S IFMedium;
    ZeroMemory (&IFMedium, sizeof (IFMedium));
    IFMedium.Property.Set   = PROPSETID_TUNER;
    IFMedium.Property.Id    = KSPROPERTY_TUNER_IF_MEDIUM;
    IFMedium.Property.Flags = KSPROPERTY_TYPE_GET;

    KsControl(m_hDevice,
              (DWORD) IOCTL_KS_PROPERTY, 
              &IFMedium, sizeof( KSPROPERTY_TUNER_IF_MEDIUM_S), 
              &IFMedium, sizeof( KSPROPERTY_TUNER_IF_MEDIUM_S), 
              &cbReturned);
    if (!fOk) {
        DbgLog(( LOG_ERROR, 0, TEXT("BENIGN:  KSPROPERTY_TUNER_IF_MEDIUM, KSPROPERTY_TYPE_GET, cbReturned = %d"), cbReturned));
    }
    m_IFMedium = IFMedium.IFMedium;

    return fOk ? S_OK : S_FALSE;
}


HRESULT
CTVTuner::HW_SetInput (long lIndex)
{
    BOOL fOk;
    ULONG cbReturned;
    KSPROPERTY_TUNER_INPUT_S Input;

    if ( !m_hDevice )
          return E_INVALIDARG;

    Input.Property.Set   = PROPSETID_TUNER;
    Input.Property.Id    = KSPROPERTY_TUNER_INPUT;
    Input.Property.Flags = KSPROPERTY_TYPE_SET;

    Input.InputIndex = lIndex;

    fOk = KsControl(m_hDevice,
                    (DWORD) IOCTL_KS_PROPERTY, 
                    &Input, sizeof( Input), 
                    &Input, sizeof( Input), 
                    &cbReturned);

    if (!fOk) {
        DbgLog(( LOG_ERROR, 0, 
                 TEXT("FAILED:  KSPROPERTY_TUNER_INPUT, KSPROPERTY_TYPE_SET, cbReturned = %d"), cbReturned));
    }
    return fOk ? S_OK : S_FALSE;

}

// -------------------------------------------------------------------------
// CTVTuner
// -------------------------------------------------------------------------

CTVTuner::CTVTuner(CTVTunerFilter *pTVTunerFilter)
    : m_pFilter(pTVTunerFilter) 
    , m_lTotalInputs (0)
    , m_lCountryCode (-1)   // Init to an illegal value
    , m_VideoStandardForCountry ((AnalogVideoStandard) 0)
    , m_lTuningSpace (0)
    , m_CurrentInputType (TunerInputCable)
    , m_lInputIndex (0)
    , m_pInputTypeArray (NULL)
    , m_pListCountry (NULL)
    , m_pListBroadcast (NULL)
    , m_pListCable (NULL)
    , m_pListCurrent (NULL)
    , m_hDevice (NULL)
    , m_CurrentMode (0)
    , m_ModesSupported (0)
    , m_CableSystemCounts (NULL)
    , m_pMode_Current (NULL)

{
    ZeroMemory (m_pModeList, sizeof (m_pModeList));

    //
    // Create the master list of all countries and their video standards
    //
    m_pListCountry = new CCountryList ();
}

STDMETHODIMP 
CTVTuner::Load(LPPROPERTYBAG pPropBag, 
               LPERRORLOG pErrorLog,
               PKSPROPERTY_TUNER_CAPS_S pTunerCaps,
               PKSPIN_MEDIUM pIFMedium)
{
    HRESULT hr = S_OK;
    int j;
    VARIANT var;
    VariantInit(&var);

    // This should be NULL, but recover gracefully
    ASSERT(m_hDevice == NULL);
    if (m_hDevice)
        CloseHandle(m_hDevice);

    V_VT(&var) = VT_BSTR;
    if(SUCCEEDED(pPropBag->Read(L"DevicePath", &var, 0)))
    {
#ifndef _UNICODE
        WideCharToMultiByte(CP_ACP, 0, V_BSTR(&var), -1,
                            m_pDeviceName, sizeof(m_pDeviceName), 0, 0);
#else
        lstrcpy(m_pDeviceName, V_BSTR(&var));
#endif
        VariantClear(&var);
        DbgLog((LOG_TRACE,2,TEXT("CTVTunerFilter::Load: use %s"), m_pDeviceName));

        if (!CreateDevice()) {
            DbgLog((LOG_TRACE,2,TEXT("CTVTunerr::Load Failed: use %s"), m_pDeviceName));
            return E_FAIL;
        }
    }

    //
    // Determine the overall capabilities of the tuner
    //
    HW_GetTVTunerCaps ();
    ASSERT (m_TunerCaps.ModesSupported & 
            KSPROPERTY_TUNER_MODE_TV        |
            KSPROPERTY_TUNER_MODE_FM_RADIO  |
            KSPROPERTY_TUNER_MODE_AM_RADIO  |
            KSPROPERTY_TUNER_MODE_DSS       |
            KSPROPERTY_TUNER_MODE_ATSC      
            );

    // Validate m_lTotalInputs
    if (m_lTotalInputs <= 0)
    {
        DbgLog((LOG_TRACE,2,TEXT("CTVTunerr::Load Failed: invalid NumberOfInputs"), m_lTotalInputs));
        return E_FAIL;
    }

    // This will be NULL if no previous instance to init from
    if (m_pInputTypeArray == NULL)
    {
        m_pInputTypeArray = new TunerInputType [m_lTotalInputs];
        if (m_pInputTypeArray == NULL)
            return E_OUTOFMEMORY;

        // Initialize the input types
        for (j = 0; j < m_lTotalInputs; j++) {
            m_pInputTypeArray[j] = TunerInputCable;
        }

        // Set the current input type
        m_CurrentInputType = TunerInputCable;

        // This should be NULL, but recover gracefully
        ASSERT(m_CableSystemCounts == NULL);
        delete [] m_CableSystemCounts;

        m_CableSystemCounts = new int [m_lTotalInputs * CableSystem_End];
        if (m_CableSystemCounts == NULL)
            return E_OUTOFMEMORY;

        for (j = 0; j < CableSystem_End * m_lTotalInputs; j++) {
            m_CableSystemCounts[j] = 0;
        }

        m_lCountryCode = GetProfileInt(TEXT("intl"), TEXT ("iCountry"), 1); // for backward compatibility

        // Note that this must be done BEFORE creating the subtuners
        hr = put_CountryCode (m_lCountryCode);  
        if (FAILED(hr) && m_lCountryCode != 1) {
            hr = put_CountryCode (1);  // USA, Canada, Caribbean by default
        }
    }

    // Proceed only if we could set the country code
    if (SUCCEEDED(hr))
    {
        put_ConnectInput (m_lInputIndex);

        if (m_ModesSupported == 0)
            m_ModesSupported = m_TunerCaps.ModesSupported;
        else
            ASSERT(m_ModesSupported == m_TunerCaps.ModesSupported);

        //
        // Create all of the "sub tuners" supported
        //
        if (m_TunerCaps.ModesSupported & KSPROPERTY_TUNER_MODE_TV) {
            if (!m_pModeList[TuningMode_TV]) {
                m_pModeList[TuningMode_TV] =  new CTunerMode_TV(
                    m_pFilter,
                    this,
                    AMTUNER_MODE_TV,
                    CHANNEL_DEFAULT_TV,
                    AMTUNER_SUBCHAN_DEFAULT,
                    AMTUNER_SUBCHAN_DEFAULT
                    );
                m_CurrentMode = m_CurrentMode ? m_CurrentMode : KSPROPERTY_TUNER_MODE_TV;
            }
        }
        if (m_TunerCaps.ModesSupported & KSPROPERTY_TUNER_MODE_ATSC) {
            if (!m_pModeList[TuningMode_ATSC]) {
                m_pModeList[TuningMode_ATSC] = new CTunerMode_ATSC(
                    m_pFilter,
                    this,
                    CHANNEL_DEFAULT_ATSC,
                    AMTUNER_SUBCHAN_DEFAULT,
                    AMTUNER_SUBCHAN_DEFAULT
                    );
                m_CurrentMode = m_CurrentMode ? m_CurrentMode : KSPROPERTY_TUNER_MODE_ATSC;
            }
        }
        if (m_TunerCaps.ModesSupported & KSPROPERTY_TUNER_MODE_DSS) {
            if (!m_pModeList[TuningMode_DSS]) {
                m_pModeList[TuningMode_DSS] = new CTunerMode_DSS(
                    m_pFilter,
                    this,
                    CHANNEL_DEFAULT_DSS,
                    AMTUNER_SUBCHAN_DEFAULT,
                    AMTUNER_SUBCHAN_DEFAULT
                    );
                m_CurrentMode = m_CurrentMode ? m_CurrentMode : KSPROPERTY_TUNER_MODE_DSS;
            }
        }
        if (m_TunerCaps.ModesSupported & KSPROPERTY_TUNER_MODE_AM_RADIO) {
            if (!m_pModeList[TuningMode_AM]) {
                m_pModeList[TuningMode_AM] = new CTunerMode_AM(
                    m_pFilter,
                    this,
                    CHANNEL_DEFAULT_AM
                    );
                m_CurrentMode = m_CurrentMode ? m_CurrentMode : KSPROPERTY_TUNER_MODE_AM_RADIO;
            }
        }
        if (m_TunerCaps.ModesSupported & KSPROPERTY_TUNER_MODE_FM_RADIO) {
            if (!m_pModeList[TuningMode_FM]) {
                m_pModeList[TuningMode_FM] = new CTunerMode_FM(
                    m_pFilter,
                    this,
                    CHANNEL_DEFAULT_FM
                    );
                m_CurrentMode = m_CurrentMode ? m_CurrentMode : KSPROPERTY_TUNER_MODE_FM_RADIO;
            }
        }

        // Now that the subtuners have been created, finish initializing them, and
        // tell all of the subtuners the country code has changed
        for (j = 0; SUCCEEDED(hr) && j < TuningMode_Last; j++) {
            if (m_pModeList[j]) {
                hr = m_pModeList[j]->Init();
                if (SUCCEEDED(hr))
                    hr = m_pModeList[j]->put_CountryCode (m_lCountryCode);
            }
        }

        if (SUCCEEDED(hr))
        {
            // Finally, complete the process by activating the desired mode
            hr = put_Mode((AMTunerModeType)m_CurrentMode);
        }
    }

    // Give the caller a copy of the TunerCaps structure
    *pTunerCaps = m_TunerCaps;

    // Post Win98 SP1, copy the IF Freq medium
    *pIFMedium = m_IFMedium;

    return hr;
}

HRESULT CTVTuner::ReadFromStream(IStream *pStream)
{
    ULONG cb = 0;
    HRESULT hr;

    // Get the input count
    hr = pStream->Read(&m_lTotalInputs, sizeof(m_lTotalInputs), &cb);
    if (FAILED(hr) || sizeof(m_lTotalInputs) != cb)
        return hr;

    // This should be NULL, but recover gracefully
    ASSERT(m_pInputTypeArray == NULL);
    delete [] m_pInputTypeArray;

    m_pInputTypeArray = new TunerInputType[m_lTotalInputs];
    if (m_pInputTypeArray)
    {
        // Initialize the input types
        for (long j = 0; j < m_lTotalInputs; j++)
        {
            hr = pStream->Read(&m_pInputTypeArray[j], sizeof(TunerInputType), &cb);
            if (FAILED(hr) || sizeof(TunerInputType) != cb)
                return hr;
        }
    }
    else
        return E_OUTOFMEMORY;

    // This should be NULL, but recover gracefully
    ASSERT(m_CableSystemCounts == NULL);
    delete [] m_CableSystemCounts;

    m_CableSystemCounts = new int [CableSystem_End * m_lTotalInputs];
    if (m_CableSystemCounts)
    {
        for (long j = 0; j < CableSystem_End * m_lTotalInputs; j++)
            m_CableSystemCounts[j] = 0;
    }
    else
        return E_OUTOFMEMORY;

    // Get the input index
    hr = pStream->Read(&m_lInputIndex, sizeof(m_lInputIndex), &cb);
    if (FAILED(hr) || sizeof(m_lInputIndex) != cb)
        return hr;

    // Set the current input type
    m_CurrentInputType = m_pInputTypeArray[m_lInputIndex];

    // Get the country code
    hr = pStream->Read(&m_lCountryCode, sizeof(m_lCountryCode), &cb);
    if (FAILED(hr) || sizeof(m_lCountryCode) != cb)
        return hr;

    // Get the tuning space
    hr = pStream->Read(&m_lTuningSpace, sizeof(m_lTuningSpace), &cb);
    if (FAILED(hr) || sizeof(m_lTuningSpace) != cb)
        return hr;

    // Note that this must be done BEFORE creating the subtuners
    hr = put_CountryCode (m_lCountryCode);  
    if (FAILED(hr) && m_lCountryCode != 1) {
        hr = put_CountryCode (1);  // USA, Canada, Caribbean by default
    }
    if (FAILED(hr))
        return hr;

    // Get the modes supported
    hr = pStream->Read(&m_ModesSupported, sizeof(m_ModesSupported), &cb);
    if (FAILED(hr) || sizeof(m_ModesSupported) != cb)
        return hr;

    // Get the current mode
    hr = pStream->Read(&m_CurrentMode, sizeof(m_CurrentMode), &cb);
    if (FAILED(hr) || sizeof(m_CurrentMode) != cb)
        return hr;

    // Create all of the supported sub tuners
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_TV) {
        long Channel = CHANNEL_DEFAULT_TV;

        // Get the channel
        hr = pStream->Read(&Channel, sizeof(Channel), &cb);
        if (FAILED(hr) || sizeof(Channel) != cb)
            return hr;

        m_pModeList[TuningMode_TV] =  new CTunerMode_TV (m_pFilter, this, AMTUNER_MODE_TV, Channel, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_ATSC) {
        long Channel = CHANNEL_DEFAULT_ATSC;
        long VideoSubChannel = AMTUNER_SUBCHAN_DEFAULT;
        long AudioSubChannel = AMTUNER_SUBCHAN_DEFAULT;

        // Get the ATSC Channels
        hr = pStream->Read(&Channel, sizeof(Channel), &cb);
        if (FAILED(hr) || sizeof(Channel) != cb)
            return hr;

        hr = pStream->Read(&VideoSubChannel, sizeof(VideoSubChannel), &cb);
        if (FAILED(hr) || sizeof(VideoSubChannel) != cb)
            return hr;

        hr = pStream->Read(&AudioSubChannel, sizeof(AudioSubChannel), &cb);
        if (FAILED(hr) || sizeof(AudioSubChannel) != cb)
            return hr;

        m_pModeList[TuningMode_ATSC] = new CTunerMode_ATSC (m_pFilter, this, Channel, VideoSubChannel, AudioSubChannel);
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_DSS) {
        long Channel = CHANNEL_DEFAULT_DSS;
        long VideoSubChannel = AMTUNER_SUBCHAN_DEFAULT;
        long AudioSubChannel = AMTUNER_SUBCHAN_DEFAULT;

        // Get the DSS Channels
        hr = pStream->Read(&Channel, sizeof(Channel), &cb);
        if (FAILED(hr) || sizeof(Channel) != cb)
            return hr;

        hr = pStream->Read(&VideoSubChannel, sizeof(VideoSubChannel), &cb);
        if (FAILED(hr) || sizeof(VideoSubChannel) != cb)
            return hr;

        hr = pStream->Read(&AudioSubChannel, sizeof(AudioSubChannel), &cb);
        if (FAILED(hr) || sizeof(AudioSubChannel) != cb)
            return hr;

        m_pModeList[TuningMode_DSS] = new CTunerMode_DSS (m_pFilter, this, Channel, VideoSubChannel, AudioSubChannel);
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_AM_RADIO) {
        long Channel = CHANNEL_DEFAULT_AM;

        // Get the AM station
        hr = pStream->Read(&Channel, sizeof(Channel), &cb);
        if (FAILED(hr) || sizeof(Channel) != cb)
            return hr;

        m_pModeList[TuningMode_AM] = new CTunerMode_AM (m_pFilter, this, Channel);
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_FM_RADIO) {
        long Channel = CHANNEL_DEFAULT_FM;

        // Get the FM station
        hr = pStream->Read(&Channel, sizeof(Channel), &cb);
        if (FAILED(hr) || sizeof(Channel) != cb)
            return hr;

        m_pModeList[TuningMode_FM] = new CTunerMode_FM (m_pFilter, this, Channel);
    }

    return hr;
}

HRESULT CTVTuner::WriteToStream(IStream *pStream)
{
    HRESULT hr = S_OK;

    // Save the Inputs count
    hr = pStream->Write(&m_lTotalInputs, sizeof(m_lTotalInputs), NULL);
    if (FAILED(hr))
        return hr;

    // This shouldn't be NULL
    ASSERT(m_pInputTypeArray != NULL);
    if (m_pInputTypeArray)
    {
        // Initialize the input types
        for (long j = 0; j < m_lTotalInputs; j++)
        {
            hr = pStream->Write(&m_pInputTypeArray[j], sizeof(TunerInputType), NULL);
            if (FAILED(hr))
                return hr;
        }
    }

    // Save the input index
    hr = pStream->Write(&m_lInputIndex, sizeof(m_lInputIndex), NULL);
    if (FAILED(hr))
        return hr;

    // Save the country code
    hr = pStream->Write(&m_lCountryCode, sizeof(m_lCountryCode), NULL);
    if (FAILED(hr))
        return hr;

    // Save the tuning space
    hr = pStream->Write(&m_lTuningSpace, sizeof(m_lTuningSpace), NULL);
    if (FAILED(hr))
        return hr;

    // Save the modes supported
    hr = pStream->Write(&m_ModesSupported, sizeof(m_ModesSupported), NULL);
    if (FAILED(hr))
        return hr;

    // Save the current mode
    hr = pStream->Write(&m_CurrentMode, sizeof(m_CurrentMode), NULL);
    if (FAILED(hr))
        return hr;

    // Save all of the supported sub tuners' states
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_TV) {
        long Channel;
        long junk;

        hr = m_pModeList[TuningMode_TV]->get_Channel(&Channel, &junk, &junk);
        if (FAILED(hr))
            return hr;

        // Save the channel
        hr = pStream->Write(&Channel, sizeof(Channel), NULL);
        if (FAILED(hr))
            return hr;
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_ATSC) {
        long Channel;
        long VideoSubChannel;
        long AudioSubChannel;

        hr = m_pModeList[TuningMode_ATSC]->get_Channel(&Channel, &VideoSubChannel, &AudioSubChannel);
        if (FAILED(hr))
            return hr;

        // Save the ATSC Channels
        hr = pStream->Write(&Channel, sizeof(Channel), NULL);
        if (FAILED(hr))
            return hr;

        hr = pStream->Write(&VideoSubChannel, sizeof(VideoSubChannel), NULL);
        if (FAILED(hr))
            return hr;

        hr = pStream->Write(&AudioSubChannel, sizeof(AudioSubChannel), NULL);
        if (FAILED(hr))
            return hr;
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_DSS) {
        long Channel;
        long VideoSubChannel;
        long AudioSubChannel;

        hr = m_pModeList[TuningMode_DSS]->get_Channel(&Channel, &VideoSubChannel, &AudioSubChannel);
        if (FAILED(hr))
            return hr;

        // Save the DSS Channels
        hr = pStream->Write(&Channel, sizeof(Channel), NULL);
        if (FAILED(hr))
            return hr;

        hr = pStream->Write(&VideoSubChannel, sizeof(VideoSubChannel), NULL);
        if (FAILED(hr))
            return hr;

        hr = pStream->Write(&AudioSubChannel, sizeof(AudioSubChannel), NULL);
        if (FAILED(hr))
            return hr;
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_AM_RADIO) {
        long Channel;
        long junk;

        hr = m_pModeList[TuningMode_AM]->get_Channel(&Channel, &junk, &junk);
        if (FAILED(hr))
            return hr;

        // Save the AM station
        hr = pStream->Write(&Channel, sizeof(Channel), NULL);
        if (FAILED(hr))
            return hr;
    }
    if (m_ModesSupported & KSPROPERTY_TUNER_MODE_FM_RADIO) {
        long Channel;
        long junk;

        hr = m_pModeList[TuningMode_FM]->get_Channel(&Channel, &junk, &junk);
        if (FAILED(hr))
            return hr;

        // Save the FM station
        hr = pStream->Write(&Channel, sizeof(Channel), NULL);
        if (FAILED(hr))
            return hr;
    }

    return hr;
}

int CTVTuner::SizeMax(void)
{
    return
    // The Inputs count
    sizeof(m_lTotalInputs)
    +
    // InputTypes array
    (m_lTotalInputs * sizeof(TunerInputType))
    +
    // The input index
    sizeof(m_lInputIndex)
    +
    // The country code
    sizeof(m_lCountryCode)
    +
    // The tuning space
    sizeof(m_lTuningSpace)
    +
    // The modes supported
    sizeof(m_ModesSupported)
    +
    // The current mode
    sizeof(m_CurrentMode)
    +
    // calculate the space used by the supported tuners
    m_ModesSupported & KSPROPERTY_TUNER_MODE_TV ? sizeof(long) : 0
    +
    m_ModesSupported & KSPROPERTY_TUNER_MODE_ATSC ? sizeof(long) * 3 : 0
    +
    m_ModesSupported & KSPROPERTY_TUNER_MODE_DSS ? sizeof(long) * 3 : 0
    +
    m_ModesSupported & KSPROPERTY_TUNER_MODE_AM_RADIO ? sizeof(long) : 0
    +
    m_ModesSupported & KSPROPERTY_TUNER_MODE_FM_RADIO ? sizeof(long) : 0
    ;
}

CTVTuner::~CTVTuner()
{
    delete [] m_pInputTypeArray;      m_pInputTypeArray = NULL;
    delete  m_pListCable;             m_pListCable = NULL;
    delete  m_pListBroadcast;         m_pListBroadcast = NULL;
    delete  m_pListCountry;           m_pListCountry = NULL;
    delete [] m_CableSystemCounts;    m_CableSystemCounts = NULL;

    m_pListCurrent = NULL;

    // Delete all of the "sub tuners"
    for (int j = 0; j < TuningMode_Last; j++) {
        if (m_pModeList[j] != NULL) {
            delete m_pModeList[j];
            m_pModeList[j] = NULL;
        }
    }

    if ( m_hDevice ) {
       CloseHandle( m_hDevice );
    }
}

int CTVTuner::CreateDevice()
{
    HANDLE hDevice ;

    hDevice = CreateFile( m_pDeviceName,
                   GENERIC_READ | GENERIC_WRITE,
                   0,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                   NULL ) ;

    if ( hDevice == (HANDLE) -1 ) {
        DbgLog(( LOG_TRACE, 0, TEXT("CTVTuner::CreateDevice FAILED!")));
        return 0 ;
    } else {
        m_hDevice = hDevice;
        return 1;
    }
}


// -------------------------------------------------------------------------
// IAMTVTuner
// -------------------------------------------------------------------------

STDMETHODIMP
CTVTuner::put_Channel(
    long lChannel,
    long lVideoSubChannel,
    long lAudioSubChannel)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->put_Channel(
                            lChannel,
                            lVideoSubChannel,
                            lAudioSubChannel);
}

STDMETHODIMP
CTVTuner::get_Channel(
    long *plChannel,
    long * plVideoSubChannel,
    long * plAudioSubChannel)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->get_Channel(
                            plChannel,
                            plVideoSubChannel,
                            plAudioSubChannel);
}

STDMETHODIMP
CTVTuner::ChannelMinMax(long *plChannelMin, long *plChannelMax)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->ChannelMinMax (plChannelMin, plChannelMax);
}


STDMETHODIMP 
CTVTuner::AutoTune (long lChannel, long * plFoundSignal)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->AutoTune(lChannel, plFoundSignal);
}

STDMETHODIMP 
CTVTuner::StoreAutoTune ()
{
    DbgLog(( LOG_TRACE, 2, TEXT("StoreAutoTune() called")));

    if (m_pListCurrent)
    {
        BOOL fOK;

        fOK = m_pListCurrent->WriteListToRegistry (m_lTuningSpace);

        return fOK ? NOERROR : HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
    }
    else
        return E_FAIL;   // somebody ignored a previous error code
}

STDMETHODIMP
CTVTuner::put_CountryCode(long lCountryCode)
{
    long lIndexCable, lIndexBroad;
    HRESULT hr = S_OK;
    HRESULT hrFinal = S_OK;
    long lCountryCodeOriginal = m_lCountryCode;

//    if (m_lCountryCode == lCountryCode)
//        return NOERROR;

    // Get the RCDATA indices for the two tuning spaces, given a country

    if (!m_pListCountry->GetFrequenciesAndStandardFromCountry (
            lCountryCode, 
            &lIndexCable, 
            &lIndexBroad, 
            &m_VideoStandardForCountry))
        return HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);

    m_lCountryCode = lCountryCode;

    ASSERT (m_pListCountry);

    delete m_pListCable;
    delete m_pListBroadcast;
    m_pListCable = new CChanList (&hr, lCountryCode, lIndexCable, TRUE, m_lTuningSpace);
    m_pListBroadcast = new CChanList (&hr, lCountryCode, lIndexBroad, FALSE, m_lTuningSpace);
    if (FAILED(hr) || !m_pListCable || !m_pListBroadcast)
    {
        m_pListCurrent = NULL;

        return FAILED(hr) ? hr : E_OUTOFMEMORY;
    }
    
    m_pListCurrent = ((m_CurrentInputType == TunerInputCable) ?
            m_pListCable : m_pListBroadcast);

    //
    // Tell all of the subtuners the country code has changed
    // 
    for (int j = 0; j < TuningMode_Last; j++) {
        if (m_pModeList[j]) {
            hr = m_pModeList[j]->put_CountryCode (lCountryCode);
            DbgLog(( LOG_ERROR, 0, 
                TEXT("FAILED:  %0x=put_CountryCode(%d), TunerMode=%d"), hr, lCountryCode, j));
            if (m_pModeList[j] == m_pMode_Current) {
                hrFinal = hr;
            }
        }
    }

    return hrFinal;
}

STDMETHODIMP
CTVTuner::get_CountryCode(long *plCountryCode)
{
    *plCountryCode = m_lCountryCode;
    return NOERROR;
}


STDMETHODIMP
CTVTuner::put_TuningSpace(long lTuningSpace)
{
    m_lTuningSpace = lTuningSpace;
    ASSERT (m_pListCurrent);
    m_pListCurrent->ReadListFromRegistry(lTuningSpace);

    return NOERROR;
}

STDMETHODIMP
CTVTuner::get_TuningSpace(long *plTuningSpace)
{
    *plTuningSpace = m_lTuningSpace;

    return NOERROR;
}

//
// Possible plSignalStrength values for TV are:
//      AMTUNER_HASNOSIGNALSTRENGTH	= -1,
//      AMTUNER_NOSIGNAL	= 0,
//      AMTUNER_SIGNALPRESENT = 1
//      or (0 - 100) for AM/FM
//
STDMETHODIMP 
CTVTuner::SignalPresent( 
            /* [out] */ long *plSignalStrength)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->SignalPresent (plSignalStrength);
}

STDMETHODIMP 
CTVTuner::put_Mode( 
        /* [in] */ AMTunerModeType lMode)
{
    HRESULT hr;
    long OriginalMode = (long) m_CurrentMode;
    BOOL ModeChangeOk = FALSE;
    static BOOL Recursion = FALSE;

    // Check that the requested mode is theoretically supported by
    // the device

    if (!(lMode & m_TunerCaps.ModesSupported)) {
        return E_INVALIDARG;
    }

    //
    // Now tell all of the subtuners that the mode has changed
    //
    for (int j = 0; j < TuningMode_Last; j++) {
        AMTunerModeType lModeOfTuner;

        if (m_pModeList[j]) {
            hr = m_pModeList[j]->get_Mode (&lModeOfTuner);
            ASSERT (SUCCEEDED (hr));
            hr = m_pModeList[j]->put_Mode (lMode);
            ASSERT (SUCCEEDED (hr));
            if (lModeOfTuner == lMode) {
                ModeChangeOk = SUCCEEDED (hr);
                m_pMode_Current = m_pModeList[j];
            }
        }
    }
    
    if (ModeChangeOk) {
        m_CurrentMode = lMode;
    }
    else {
        // Mode Change FAILED, try to put back the original mode!!!
        if (!Recursion) {
            ASSERT (FALSE);
            Recursion = TRUE;
            hr = put_Mode ((AMTunerModeType) OriginalMode);
            Recursion = FALSE;
            ASSERT (SUCCEEDED (hr));
        }
    }
    return hr;
}


STDMETHODIMP
CTVTuner::get_Mode( 
        /* [out] */ AMTunerModeType *plMode)
{
    BOOL fOk;
    KSPROPERTY_TUNER_MODE_S TunerMode;
    ULONG cbReturned;

    if ( !m_hDevice )
          return E_INVALIDARG;

    *plMode = (AMTunerModeType) m_CurrentMode;

    // Sanity check, confirm that the device mode matches our
    // internal version

    TunerMode.Property.Set   = PROPSETID_TUNER;
    TunerMode.Property.Id    = KSPROPERTY_TUNER_MODE;
    TunerMode.Property.Flags = KSPROPERTY_TYPE_GET;

    fOk = KsControl(m_hDevice,
                    (DWORD) IOCTL_KS_PROPERTY, 
                    &TunerMode, sizeof( KSPROPERTY_TUNER_MODE_S), 
                    &TunerMode, sizeof( KSPROPERTY_TUNER_MODE_S), 
                    &cbReturned);
    
    if (!fOk || (m_CurrentMode != (AMTunerModeType) TunerMode.Mode)) {
        DbgLog(( LOG_ERROR, 0, 
                 TEXT("FAILED:  KSPROPERTY_TUNER_MODE, KSPROPERTY_TYPE_GET, cbReturned = %d, Mode = %x"), 
                 cbReturned, (AMTunerModeType) TunerMode.Mode));
    }
        
    return NOERROR;
}


STDMETHODIMP 
CTVTuner::GetAvailableModes( 
        /* [out] */ long *plModes)
{
    *plModes = m_TunerCaps.ModesSupported;
    return NOERROR;
}


STDMETHODIMP 
CTVTuner::get_AvailableTVFormats (long *pAnalogVideoStandard)
{
    *pAnalogVideoStandard = 0;

    ASSERT (m_pMode_Current);
    return  m_pMode_Current->get_AvailableTVFormats (pAnalogVideoStandard);
}


STDMETHODIMP 
CTVTuner::get_TVFormat (long *plAnalogVideoStandard)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->get_TVFormat (plAnalogVideoStandard);
}


STDMETHODIMP 
CTVTuner::get_NumInputConnections (long * plNumInputConnections)
{
    *plNumInputConnections = m_lTotalInputs;
    return NOERROR;
}


STDMETHODIMP 
CTVTuner::get_InputType (long lIndex, TunerInputType * pInputConnectionType)
{
    if (lIndex < 0 || (lIndex >= m_lTotalInputs))
        return HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);

    *pInputConnectionType = m_pInputTypeArray[lIndex];
    return NOERROR;
}


STDMETHODIMP 
CTVTuner::put_InputType (long lIndex, TunerInputType InputConnectionType)
{
    if (lIndex < 0 || lIndex >= m_lTotalInputs) 
        return HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);

    m_pInputTypeArray[lIndex] = InputConnectionType;

    // If we're changing the type of the currently selected input
    if (lIndex == m_lInputIndex) {
        m_CurrentInputType = m_pInputTypeArray[lIndex];
        m_pListCurrent = ((m_CurrentInputType == TunerInputCable) ?
            m_pListCable : m_pListBroadcast);
    }

    // Since we're changing the input type (cable vs broad), we need to retune
    if (m_pMode_Current) {
        long lChannel, lVideoSubChannel, AudioSubChannel;

        get_Channel(&lChannel, &lVideoSubChannel, &AudioSubChannel);
        put_Channel( lChannel,  lVideoSubChannel,  AudioSubChannel);
    }

    return NOERROR;
    
}


STDMETHODIMP 
CTVTuner::put_ConnectInput (long lIndex)
{
    if (lIndex < 0 || lIndex >= m_lTotalInputs) 
        return HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);

    m_lInputIndex = lIndex;
    m_CurrentInputType = m_pInputTypeArray[lIndex];
    m_pListCurrent = ((m_CurrentInputType == TunerInputCable) ?
            m_pListCable : m_pListBroadcast);

    HW_SetInput (lIndex);

    if (m_pMode_Current) {
        long lChannel, lVideoSubChannel, AudioSubChannel;

        get_Channel(&lChannel, &lVideoSubChannel, &AudioSubChannel);
        put_Channel( lChannel,  lVideoSubChannel,  AudioSubChannel);
    }

    return NOERROR;
    
}


STDMETHODIMP 
CTVTuner::get_ConnectInput (long *plIndex)
{
    *plIndex = m_lInputIndex;
    return NOERROR;
}


STDMETHODIMP 
CTVTuner::get_VideoFrequency (long * plFreq)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->get_VideoFrequency (plFreq);
}


STDMETHODIMP 
CTVTuner::get_AudioFrequency (long * plFreq)
{
    ASSERT (m_pMode_Current);
    return  m_pMode_Current->get_AudioFrequency (plFreq);
}


HRESULT
CTVTuner::DeliverChannelChangeInfo(KS_TVTUNER_CHANGE_INFO &ChangeInfo,
                            long Mode)
{
    return m_pFilter->DeliverChannelChangeInfo(ChangeInfo, Mode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tvtuner.rc
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


#define IDD_TVTunerDialog               101
#define IDC_AUTOTUNE_NEXT               101
#define IDC_CHANNEL                     1000
#define IDC_COUNTRYCODE                 1001
#define IDC_TUNINGSPACE                 1002
#define IDC_FORMAT                      1003
#define IDC_CABLE                       1004
#define IDC_ANTENNA                     1005
#define IDC_VIDEOFREQ                   1006
#define IDC_AUDIOFREQ                   1007
#define IDS_TVTUNERPROPNAME             1008
#define IDC_CHANNELSPIN                 1012
#define IDC_AUTOTUNE                    1013
#define IDC_AUTOTUNESTATUS              1014
#define IDC_INPUT1                      1015
#define IDC_INPUT2                      1016
#define IDC_INPUT3                      1017
#define IDC_SAVEAUTOTUNE                1018
#define IDC_STANDARD_CURRENT            1018
#define IDC_ENTER                       1019
#define IDC_STANDARD_SUPPORTED          1020
#define IDC_BUTTON0                     1021
#define IDC_BUTTON1                     1022
#define IDC_BUTTON2                     1023
#define IDC_BUTTON3                     1024
#define IDC_BUTTON4                     1025
#define IDC_BUTTON5                     1026
#define IDC_BUTTON6                     1027
#define IDC_BUTTON7                     1028
#define IDC_BUTTON8                     1029
#define IDC_BUTTON9                     1030
#define IDC_TUNINGMODE                  1031
#define IDS_TVSTD_NTSC_M                1032
#define IDS_TVSTD_NTSC_M_J              1033
#define IDS_TVSTD_PAL_B                 1034
#define IDS_TVSTD_PAL_D                 1035
#define IDS_TVSTD_PAL_G                 1036
#define IDS_TVSTD_PAL_H                 1037
#define IDS_TVSTD_PAL_I                 1038
#define IDS_TVSTD_PAL_M                 1039
#define IDS_TVSTD_PAL_N                 1040
#define IDS_TVSTD_PAL_N_COMBO           1041
#define IDS_TVSTD_SECAM_B               1042
#define IDS_TVSTD_SECAM_D               1043
#define IDS_TVSTD_SECAM_G               1044
#define IDS_TVSTD_SECAM_H               1045
#define IDS_TVSTD_SECAM_K               1046
#define IDS_TVSTD_SECAM_K1              1047
#define IDS_TVSTD_SECAM_L               1048
#define IDS_TVSTD_SECAM_L1              1049
#define IDS_TUNERMODE_TV                1050
#define IDS_TUNERMODE_FM_RADIO          1051
#define IDS_TUNERMODE_AM_RADIO          1052
#define IDS_TUNERMODE_DSS               1053
#define IDS_TUNERMODE_ATSC              1054
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1055
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\ptvtuner.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// ptvtuner.cpp  Property page for TV Tuner
//

// The following nastiness is to get UDM_SETRANGE32 defined.  What is the proper way?
#undef  _WIN32_IE 
#define _WIN32_IE 0x500

#include <windows.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "kssupp.h"
#include "tvtuner.h"
#include "ctvtuner.h"
#include "ptvtuner.h"
#include "resource.h"



// -------------------------------------------------------------------------
// CTVTunerProperties
// -------------------------------------------------------------------------

CUnknown *CTVTunerProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CTVTunerProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CTVTunerProperties::CTVTunerProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("TVTuner Property Page"), lpunk, 
        IDD_TVTunerDialog, IDS_TVTUNERPROPNAME)
    , m_pTVTuner(NULL) 
    , m_CurChan( 0 )
    , m_Pos( 1 )
    , m_timerID( 0 )
    , m_SavedChan( 3 )
    , m_hwndChannel (0)
    , m_hwndCountryCode(0)    
    , m_hwndTuningSpace(0)    
    , m_hwndTuningMode(0)     
    , m_hwndStandardsSupported(0)
    , m_hwndStandardCurrent(0)
    , m_hwndStatus(0)
{
}

// destructor
CTVTunerProperties::~CTVTunerProperties()
{
   if ( m_timerID )
      KillTimer( m_hwnd, m_timerID );
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CTVTunerProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pTVTuner == NULL);

    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_IAMTVTuner,(void **)&m_pTVTuner);

    if (FAILED(hr)) {
        MessageBox (NULL, TEXT("QueryInterface IID_IAMTvTuner FAILED"), TEXT(""), MB_OK);
        return E_NOINTERFACE;
    }

    ASSERT(m_pTVTuner);

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CTVTunerProperties::OnDisconnect()
{
    // Release the interface

    if (m_pTVTuner == NULL) {
        return E_UNEXPECTED;
    }

    m_pTVTuner->Release();
    m_pTVTuner = NULL;
    return NOERROR;
}

#define MAX_RES_SZ 256

//
// OnActivate
//
// Called on dialog creation

HRESULT CTVTunerProperties::OnActivate(void)
{
    HRESULT hr;

    InitCommonControls ();

    m_hwndChannel               = GetDlgItem (m_hwnd, IDC_CHANNEL);          
    m_hwndChannelSpin           = GetDlgItem (m_hwnd, IDC_CHANNELSPIN);          
    m_hwndCountryCode           = GetDlgItem (m_hwnd, IDC_COUNTRYCODE); 
    m_hwndTuningSpace           = GetDlgItem (m_hwnd, IDC_TUNINGSPACE); 
    m_hwndTuningMode            = GetDlgItem (m_hwnd, IDC_TUNINGMODE);  
    m_hwndStandardsSupported    = GetDlgItem (m_hwnd, IDC_STANDARD_SUPPORTED);
    m_hwndStandardCurrent       = GetDlgItem (m_hwnd, IDC_STANDARD_CURRENT); 
    m_hwndStatus                = GetDlgItem (m_hwnd, IDC_AUTOTUNESTATUS); 
    
    // Setup the spinbox
    SendMessage (m_hwndChannelSpin, UDM_SETBUDDY, 
                (WPARAM) m_hwndChannel, 0L);

    // Get current filter state to resore if dialog is cancelled
    hr = m_pTVTuner->get_Channel(&m_ChannelOriginal, &m_CurVideoSubChannel, &m_CurAudioSubChannel);
    hr = m_pTVTuner->get_CountryCode(&m_CountryCodeOriginal);
    hr = m_pTVTuner->get_ConnectInput (&m_InputIndexOriginal);
    hr = m_pTVTuner->get_TuningSpace (&m_TuningSpaceOriginal);
    hr = m_pTVTuner->get_Mode((AMTunerModeType *) &m_TuningModeOriginal);
    hr = m_pTVTuner->GetAvailableModes (&m_AvailableModes);

    // Copy to the dynamic variables changed by the UI
    m_CurChan = m_ChannelOriginal;
    m_CountryCode = m_CountryCodeOriginal;
    m_InputIndex = m_InputIndexOriginal;
    m_TuningSpace = m_TuningSpaceOriginal;
    m_TuningMode = m_TuningModeOriginal;

    // Create combobox of all supported modes
    int CurrentModeIndex = 0;
    int SelectedModeIndex = 0;
    long Mask;

    for (int j = 0; j < 32; j++) {
        Mask = 1 << j;
        if (m_AvailableModes & Mask) {
            TCHAR ptc[MAX_RES_SZ];
            StringFromMode (Mask, ptc);
            ASSERT(*ptc);
            ComboBox_AddString (m_hwndTuningMode, ptc);
            ComboBox_SetItemData(m_hwndTuningMode, CurrentModeIndex, Mask);
            if (m_TuningMode == Mask) {
                SelectedModeIndex = CurrentModeIndex;
            }
            CurrentModeIndex++;
        }
    }
    ComboBox_SetCurSel(m_hwndTuningMode, SelectedModeIndex);

    // Init for the current tuning mode
    hr = ChangeMode (m_TuningMode);

    // This dialog only allows up to 3 input sources 
    // For each input, show whether it is Cable or Antenna
    long lCount;
    m_pTVTuner->get_NumInputConnections(&lCount);
    EnableWindow (GetDlgItem (m_hwnd, IDC_INPUT1), lCount > 0);
    EnableWindow (GetDlgItem (m_hwnd, IDC_INPUT2), lCount > 1); 
    EnableWindow (GetDlgItem (m_hwnd, IDC_INPUT3), lCount > 2);

    UpdateInputView();

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CTVTunerProperties::OnDeactivate(void)
{
    return NOERROR;
}
    

//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CTVTunerProperties::OnApplyChanges(void)
{
    // Fix

    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR CTVTunerProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    long l, k;
    BOOL fOK;
    int iNotify;

    switch (uMsg) {

    case WM_INITDIALOG:
        m_hwnd = hwnd;
        return (INT_PTR) TRUE;    // I don't call setfocus...


    case WM_NOTIFY:
        {
            int idCtrl = (int) wParam;    
            LPNMUPDOWN lpnmud = (LPNMUPDOWN) lParam;
            if (lpnmud->hdr.hwndFrom == m_hwndChannelSpin) {
                lpnmud->iDelta *= m_UIStep;
                l = lpnmud->iPos + 
                    lpnmud->iDelta; 
                m_pTVTuner->put_Channel(l, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
                UpdateFrequencyView();
                SetDirty(); 
            }
        }
        break;

    case WM_TIMER:
       if ( m_timerID )
          KillTimer( hwnd, m_timerID );
       m_timerID = 0;
       m_CurChan = 0;
       m_Pos = 1;
       SetDlgItemInt( hwnd, IDC_CHANNEL, m_SavedChan, FALSE);
       break;

    case WM_COMMAND:

        iNotify = HIWORD (wParam);       
        
        switch (LOWORD(wParam)) {

        case IDC_BUTTON1:
        case IDC_BUTTON2:
        case IDC_BUTTON3:
        case IDC_BUTTON4:
        case IDC_BUTTON5:
        case IDC_BUTTON6:
        case IDC_BUTTON7:
        case IDC_BUTTON8:
        case IDC_BUTTON9:
        case IDC_BUTTON0:

           if ( m_timerID ) {
                KillTimer( hwnd, m_timerID );
                m_timerID = 0;
           }

           if ( m_Pos == 1 ) {
              m_SavedChan = GetDlgItemInt (hwnd, IDC_CHANNEL, &fOK, FALSE);
              m_CurChan = 0;
           } 

           m_CurChan *= 10;
           m_CurChan += (LONG) wParam - IDC_BUTTON0;
           m_Pos++;
           SetDlgItemInt( hwnd, IDC_CHANNEL, m_CurChan, FALSE);
           m_timerID = SetTimer( hwnd, 5, 3000, NULL );
           break;

        case IDC_ENTER:
            if ( m_timerID ) {
                KillTimer( hwnd, m_timerID );
                m_timerID = 0;
            }
           m_Pos = 1;
           iNotify = EN_KILLFOCUS;
           // Intentional fall through

        case IDC_CHANNEL:
            if (iNotify == EN_KILLFOCUS) {
                            
                int iPos = GetDlgItemInt (hwnd, IDC_CHANNEL, &fOK, FALSE);

                if (!fOK || (iPos > m_ChannelMax || iPos < m_ChannelMin)) {
                    m_pTVTuner->get_Channel(&l,
                            &m_CurVideoSubChannel, &m_CurAudioSubChannel);
                    SetDlgItemInt (hwnd, IDC_CHANNEL, l, FALSE);
                    break;
                }

                m_pTVTuner->put_Channel(iPos, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);

                UpdateFrequencyView();
                SetDirty(); 
            }
            break;

        case IDC_AUTOTUNE:
            
            m_pTVTuner->get_Channel(&m_AutoTuneOriginalChannel, 
                    &m_CurVideoSubChannel, &m_CurAudioSubChannel);
            m_AutoTuneCurrentChannel = m_ChannelMin;
            // Intentional fall through

        case IDC_AUTOTUNE_NEXT:
            {
                // at the end of all channels?
                // or the escape key pressed?

                BOOL AbortScan = (GetAsyncKeyState (VK_ESCAPE) & 0x8000);

                if ((m_AutoTuneCurrentChannel > m_ChannelMax) || AbortScan) {

                    if (!AbortScan)
                        m_pTVTuner->StoreAutoTune();                

                    m_pTVTuner->put_Channel(m_AutoTuneOriginalChannel,
                            AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
                    SetDlgItemInt (hwnd, IDC_CHANNEL, m_AutoTuneOriginalChannel, TRUE);

                    UpdateFrequencyView();
                    break;
                }

                SetDlgItemInt (hwnd, IDC_CHANNEL, m_AutoTuneCurrentChannel, TRUE);
                m_pTVTuner->AutoTune (m_AutoTuneCurrentChannel, &k);
                UpdateFrequencyView();
                SetDlgItemInt (m_hwnd, IDC_AUTOTUNESTATUS, k, FALSE);
                UpdateWindow (hwnd);

                m_AutoTuneCurrentChannel += m_UIStep;

                // Do it all again
                PostMessage (hwnd, WM_COMMAND, IDC_AUTOTUNE_NEXT, 0L);
            }
            break;

        case IDC_ANTENNA:
        case IDC_CABLE: 
            m_pTVTuner->get_ConnectInput (&l);
            m_pTVTuner->put_InputType (l, (LOWORD(wParam) == IDC_ANTENNA) ?
                    TunerInputAntenna : TunerInputCable);
            UpdateInputView();
            UpdateChannelRange();
            UpdateFrequencyView();

            SetDirty ();
            break;


        case IDC_INPUT1:
        case IDC_INPUT2:
        case IDC_INPUT3:
            m_pTVTuner->put_ConnectInput (LOWORD(wParam) - IDC_INPUT1);
            UpdateInputView();
            SetDirty ();
            break;

        case IDC_COUNTRYCODE:
            if (iNotify == EN_KILLFOCUS) {
                
                int iPos = GetDlgItemInt (hwnd, IDC_COUNTRYCODE, &fOK, FALSE);

                if (!fOK || iPos < 0) {
                    SetDlgItemInt (hwnd, IDC_COUNTRYCODE, m_CountryCodeOriginal, FALSE);
                }
                if (m_pTVTuner->put_CountryCode(iPos) == NOERROR) {
                    SetDirty ();
                }
                else {
                    SetDlgItemInt (hwnd, IDC_COUNTRYCODE, m_CountryCodeOriginal, FALSE);
                }
                UpdateChannelRange();
                UpdateFrequencyView();
            }
            break;

        case IDC_TUNINGSPACE:
            if (iNotify == EN_KILLFOCUS) {
                
                int iPos = GetDlgItemInt (hwnd, IDC_TUNINGSPACE, &fOK, FALSE);

                if (!fOK || iPos < 0) {
                    SetDlgItemInt (hwnd, IDC_TUNINGSPACE, m_TuningSpaceOriginal, FALSE);
                }
                if (m_pTVTuner->put_TuningSpace(iPos) == NOERROR) {
                    SetDirty ();
                }
                else {
                    SetDlgItemInt (hwnd, IDC_TUNINGSPACE, m_TuningSpaceOriginal, FALSE);
                }
                UpdateChannelRange();
                UpdateFrequencyView();
            }
            break;

        case IDC_TUNINGMODE:
            if (iNotify == CBN_SELCHANGE) {
                int TuningModeIndex, TuningMode;

                SetDirty ();
                m_CurChan = 0;
                m_Pos = 1;
                TuningModeIndex = ComboBox_GetCurSel (m_hwndTuningMode);
                TuningMode = (int)ComboBox_GetItemData (m_hwndTuningMode, TuningModeIndex);
                ChangeMode (TuningMode);
            }
            break;

        default:
            return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
        }
        
        return (INT_PTR) TRUE;

    default:
        return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
    }

    return (INT_PTR) TRUE;
}

//
// StringFromTVStandard
//
void CTVTunerProperties::StringFromTVStandard(long TVStd, TCHAR *sz) 
{
    ASSERT(sz);
    int string_id;
    *sz = 0;

    switch (TVStd) {

        case AnalogVideo_NTSC_M:      string_id = IDS_TVSTD_NTSC_M;      break;
        case AnalogVideo_NTSC_M_J:    string_id = IDS_TVSTD_NTSC_M_J;    break;
        case AnalogVideo_PAL_B:       string_id = IDS_TVSTD_PAL_B;       break;
        case AnalogVideo_PAL_D:       string_id = IDS_TVSTD_PAL_D;       break;
        case AnalogVideo_PAL_G:       string_id = IDS_TVSTD_PAL_G;       break;
        case AnalogVideo_PAL_H:       string_id = IDS_TVSTD_PAL_H;       break;
        case AnalogVideo_PAL_I:       string_id = IDS_TVSTD_PAL_I;       break;
        case AnalogVideo_PAL_M:       string_id = IDS_TVSTD_PAL_M;       break;
        case AnalogVideo_PAL_N:       string_id = IDS_TVSTD_PAL_N;       break;
        case AnalogVideo_PAL_N_COMBO: string_id = IDS_TVSTD_PAL_N_COMBO; break;
        case AnalogVideo_SECAM_B:     string_id = IDS_TVSTD_SECAM_B;     break;
        case AnalogVideo_SECAM_D:     string_id = IDS_TVSTD_SECAM_D;     break;
        case AnalogVideo_SECAM_G:     string_id = IDS_TVSTD_SECAM_G;     break;
        case AnalogVideo_SECAM_H:     string_id = IDS_TVSTD_SECAM_H;     break;
        case AnalogVideo_SECAM_K:     string_id = IDS_TVSTD_SECAM_K;     break;
        case AnalogVideo_SECAM_K1:    string_id = IDS_TVSTD_SECAM_K1;    break;
        case AnalogVideo_SECAM_L:     string_id = IDS_TVSTD_SECAM_L;     break;
        case AnalogVideo_SECAM_L1:    string_id = IDS_TVSTD_SECAM_L1;    break;
        default: 
            string_id = 0;
            break;
    }
    if(string_id) {
        LoadString(g_hInst, string_id, sz, MAX_RES_SZ);
    }
}

//
// StringFromModeBit
//
void CTVTunerProperties::StringFromMode(long Mode, TCHAR *sz) 
{
    int string_id;
    ASSERT(sz);
    *sz = 0;

    switch (Mode) {

    case KSPROPERTY_TUNER_MODE_TV:          string_id = IDS_TUNERMODE_TV;       break;
    case KSPROPERTY_TUNER_MODE_FM_RADIO:    string_id = IDS_TUNERMODE_FM_RADIO; break;
    case KSPROPERTY_TUNER_MODE_AM_RADIO:    string_id = IDS_TUNERMODE_AM_RADIO; break;
    case KSPROPERTY_TUNER_MODE_DSS:         string_id = IDS_TUNERMODE_DSS;      break;
    case KSPROPERTY_TUNER_MODE_ATSC:        string_id = IDS_TUNERMODE_ATSC;     break;
        default: 
            string_id = 0;
            break;
    }
    if(string_id) {
        LoadString(g_hInst, string_id, sz, MAX_RES_SZ);
    }
}

HRESULT CTVTunerProperties::ChangeMode(long Mode)
{
    long j;
    TCHAR buf[80];
    HRESULT hr;

    ASSERT (Mode & m_AvailableModes);

    hr = m_pTVTuner->put_Mode((AMTunerModeType) Mode);

    if (FAILED(hr)) {
        return hr;
    }

    // Getting the videofrequency has the side effect of setting the
    // default channel initially if it has never been set!!!
    hr = m_pTVTuner->get_VideoFrequency(&j);

    hr = m_pTVTuner->get_Channel(&m_CurChan, &m_CurVideoSubChannel, &m_CurAudioSubChannel);
    hr = m_pTVTuner->get_CountryCode(&m_CountryCode);
    hr = m_pTVTuner->get_AvailableTVFormats (&m_TVFormatsAvailable);
    hr = m_pTVTuner->get_TVFormat (&m_TVFormat);
    hr = m_pTVTuner->get_ConnectInput (&m_InputIndex);
    hr = m_pTVTuner->get_TuningSpace (&m_TuningSpace);
    hr = m_pTVTuner->get_Mode((AMTunerModeType *) &m_TuningMode);
    ASSERT (m_TuningMode == Mode);

    UpdateChannelRange();

    wsprintf (buf, TEXT ("%d"), m_CurChan); 
    Edit_SetText (m_hwndChannel, buf);
    wsprintf (buf, TEXT ("%d"), m_CountryCode); 
    Edit_SetText (m_hwndCountryCode, buf);
    wsprintf (buf, TEXT ("%d"), m_TuningSpace); 
    Edit_SetText (m_hwndTuningSpace, buf);
    UpdateFrequencyView();

    UpdateInputView();

    // Show the current video format
    TCHAR szTC[MAX_RES_SZ];
    StringFromTVStandard(m_TVFormat, szTC);
    if (*szTC) {
        Static_SetText (m_hwndStandardCurrent, szTC);
    }

    // List of all supported formats
    ComboBox_ResetContent (m_hwndStandardsSupported);
    for (j = 1; j; j <<= 1) {
        StringFromTVStandard (m_TVFormatsAvailable & j, szTC);
        if (*szTC) {
            ComboBox_AddString (m_hwndStandardsSupported, szTC);
        }
    }
    ComboBox_SetCurSel(m_hwndStandardsSupported, 0);

    return S_OK;
}

void CTVTunerProperties::UpdateInputView() 
{
    long j;
    TunerInputType tTunerInputType;

    m_pTVTuner->get_ConnectInput (&j);
    CheckRadioButton(m_hwnd,
                IDC_INPUT1,
                IDC_INPUT3,
                IDC_INPUT1 + j);

    m_pTVTuner->get_InputType (j, &tTunerInputType);

    CheckRadioButton(m_hwnd,
                IDC_CABLE,
                IDC_ANTENNA,
                IDC_CABLE + ((tTunerInputType == TunerInputCable) ? 0 : 1));
}

void CTVTunerProperties::UpdateFrequencyView() 
{
    long lFreq;
    long lSignalStrength;

    m_pTVTuner->get_VideoFrequency(&lFreq);
    SetDlgItemInt (m_hwnd, IDC_VIDEOFREQ, lFreq, FALSE);
    m_pTVTuner->get_AudioFrequency(&lFreq);
    SetDlgItemInt (m_hwnd, IDC_AUDIOFREQ, lFreq, FALSE);
    m_pTVTuner->SignalPresent(&lSignalStrength);
    SetDlgItemText (m_hwnd, IDC_AUTOTUNESTATUS, 
                    lSignalStrength ? TEXT ("Locked") : TEXT ("Unlocked"));

}

void CTVTunerProperties::UpdateChannelRange() 
{
    m_pTVTuner->ChannelMinMax(&m_ChannelMin, &m_ChannelMax);  

    SendMessage (GetDlgItem (m_hwnd, IDC_CHANNELSPIN), UDM_SETRANGE32,
            (WPARAM) m_ChannelMin, (LPARAM) m_ChannelMax); 

    // Total hack follows.  Only the CTVTuner class knows about the
    // step to get to adjacent frequencies, and this is not exposed
    // anywhere in the COM interface.  As a special case for
    // ChannelMinMax, if both the min and max values point at the same
    // location (which would normally be an app bug), then return 
    // the UI step value instead. 
    
    m_pTVTuner->ChannelMinMax(&m_UIStep, &m_UIStep);  
}

//
// SetDirty
//
// notifies the property page site of changes

void 
CTVTunerProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\tvtuner.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//

#ifndef _INC_TVTUNERFILTER_H
#define _INC_TVTUNERFILTER_H

class CTVTuner;                         // forward declaration
class CTVTunerFilter;                   // forward declaration

#define MyValidateWritePtr(p,cb, ret) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            return ret;}

BOOL KsControl(
        HANDLE hDevice,
        DWORD dwIoControl,
        PVOID pvIn,
        ULONG cbIn,
        PVOID pvOut,
        ULONG cbOut,
        PULONG pcbReturned);

#define DEFAULT_INIT_CHANNEL 4

enum TunerPinType { 
     TunerPinType_Video     = 0, 
     TunerPinType_Audio,
     TunerPinType_FMAudio,
     TunerPinType_IF,
     TunerPinType_Last      // Always keep this one last
};

// -------------------------------------------------------------------------
// CAnalogStream
// -------------------------------------------------------------------------

// CAnalogStream manages the data flow from the output pin

class CAnalogStream 
    : public CBaseOutputPin 
    , public CKsSupport 
{

public:
    CAnalogStream(TCHAR *pObjectName, 
                  CTVTunerFilter *pParent, 
                  CCritSec *pLock, 
                  HRESULT *phr, 
                  LPCWSTR pPinName,
                  const KSPIN_MEDIUM * Medium,
                  const GUID * CategoryGUID);
    ~CAnalogStream();

    // set the agreed media type
    HRESULT SetMediaType(const CMediaType *pMediaType);


    // IKsPin required overrides
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    HRESULT CheckConnect(IPin *pReceivePin);

protected:
    CTVTunerFilter *m_pTVTunerFilter;
    KSPIN_MEDIUM    m_Medium;
    GUID            m_CategoryGUID;
};

// -------------------------------------------------------------------------
// CAnalogVideoStream
// -------------------------------------------------------------------------

// CAnalogVideoStream manages the data flow from the output pin.

class CAnalogVideoStream 
    : public CAnalogStream
{

public:
    CAnalogVideoStream(CTVTunerFilter *pParent, 
                       CCritSec *pLock, 
                       HRESULT *phr, 
                       LPCWSTR pPinName,
                       const KSPIN_MEDIUM *Medium,
                       const GUID *CategoryGUID);
    ~CAnalogVideoStream();

    // ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // verify we can handle this format
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);

    HRESULT Run(REFERENCE_TIME tStart);
};

// -------------------------------------------------------------------------
// CAnalogAudioStream
// -------------------------------------------------------------------------

// CAnalogAudioStream manages the data flow from the output pin.

class CAnalogAudioStream : public CAnalogStream {

public:
    CAnalogAudioStream(CTVTunerFilter *pParent, 
                       CCritSec *pLock, 
                       HRESULT *phr, 
                       LPCWSTR pPinName,
                       const KSPIN_MEDIUM *Medium,
                       const GUID *CategoryGUID);
    ~CAnalogAudioStream();

    // ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // verify we can handle this format
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
};

// -------------------------------------------------------------------------
// CFMAudioStream
// -------------------------------------------------------------------------

// CFMAudioStream manages the data flow from the output pin.

class CFMAudioStream : public CAnalogStream {

public:
    CFMAudioStream(CTVTunerFilter *pParent, 
                   CCritSec *pLock, 
                   HRESULT *phr, 
                   LPCWSTR pPinName,
                   const KSPIN_MEDIUM *Medium,
                   const GUID *CategoryGUID);
    ~CFMAudioStream();

    // ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // verify we can handle this format
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
};

// -------------------------------------------------------------------------
// CIFStream  (Intermediate Frequency)
// -------------------------------------------------------------------------

// CIFStream manages the data flow from the output pin.

class CIFStream : public CAnalogStream {

public:
    CIFStream(CTVTunerFilter *pParent, 
                   CCritSec *pLock, 
                   HRESULT *phr, 
                   LPCWSTR pPinName,
                   const KSPIN_MEDIUM *Medium,
                   const GUID *CategoryGUID);
    ~CIFStream();

    // ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // verify we can handle this format
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
};

// -------------------------------------------------------------------------
// CTVTunerFilter
// -------------------------------------------------------------------------

class CTVTunerFilter
    : public CBaseFilter,
      public IAMTVTuner,
      public ISpecifyPropertyPages,
      public IPersistPropertyBag,
      public CPersistStream,
      public IKsObject,
      public IKsPropertySet
{
    friend class CTVTuner;
    friend class CAnalogVideoStream;
    friend class CAnalogAudioStream;
    friend class CFMAudioStream;
    friend class CIFStream;

public:
    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);
    ~CTVTunerFilter(void);

    DECLARE_IUNKNOWN

    // Basic COM - used here to reveal our property interface.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    int GetPinCount();
    CBasePin *GetPin(int n);
    CBasePin *GetPinFromType (TunerPinType);

    STDMETHODIMP FindDownstreamInterface (
        IPin        *pPin, 
        const GUID  &pInterfaceGUID,
        VOID       **pInterface);

    // We can't cue!
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();
    
    // Implement IKsPropertySet
    STDMETHODIMP Set(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength);
    STDMETHODIMP Get(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength, ULONG* BytesReturned);
    STDMETHODIMP QuerySupported(REFGUID PropSet, ULONG Property, ULONG* TypeSupport);
    
    //
    // --- IAMTuner interface -----------------------------
    //
    STDMETHODIMP put_Channel ( 
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel);
    STDMETHODIMP get_Channel ( 
            /* [out] */ long  *plChannel,
            /* [out] */ long  *plVideoSubChannel,
            /* [out] */ long  *plAudioSubChannel);

    STDMETHODIMP ChannelMinMax (
            long * plChannelMin, 
            long * plChannelMax);

    STDMETHODIMP put_CountryCode (
            long lCountry);
    STDMETHODIMP get_CountryCode (
            long * plCountry);

    STDMETHODIMP put_TuningSpace (
            long lTuningSpace);
    STDMETHODIMP get_TuningSpace (
            long * plTuningSpace);

    STDMETHODIMP Logon( 
            /* [in] */ HANDLE hCurrentUser);
    STDMETHODIMP Logout(void);

    STDMETHODIMP SignalPresent( 
            /* [out] */ long __RPC_FAR *plSignalStrength);

    STDMETHODIMP put_Mode( 
        /* [in] */ AMTunerModeType lMode);
    STDMETHODIMP get_Mode( 
        /* [out] */ AMTunerModeType __RPC_FAR *plMode);
    STDMETHODIMP GetAvailableModes( 
        /* [out] */ long __RPC_FAR *plModes);
    
    STDMETHODIMP RegisterNotificationCallBack( 
        /* [in] */ IAMTunerNotification __RPC_FAR *pNotify,
        /* [in] */ long lEvents);
    
    STDMETHODIMP UnRegisterNotificationCallBack( 
        IAMTunerNotification __RPC_FAR *pNotify);

    //
    // --- IAMTVTuner Interface ----------------------------------
    //
    STDMETHODIMP get_AvailableTVFormats (long *lAnalogVideoStandard);
    STDMETHODIMP get_TVFormat (long *plAnalogVideoStandard);
    STDMETHODIMP AutoTune (long lChannel, long *plFoundSignal);
    STDMETHODIMP StoreAutoTune ();
    STDMETHODIMP get_NumInputConnections (long * plNumInputConnections);
    STDMETHODIMP put_InputType (long lIndex, TunerInputType InputConnectionType);
    STDMETHODIMP get_InputType (long lIndex, TunerInputType * pInputConnectionType);
    STDMETHODIMP put_ConnectInput (long lIndex);
    STDMETHODIMP get_ConnectInput (long * plIndex);
    STDMETHODIMP get_VideoFrequency (long * plFreq);
    STDMETHODIMP get_AudioFrequency (long * plFreq);

        
    //
    // --- IPersistPropertyBag ---
    //
    STDMETHODIMP InitNew(void) ;
    STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) ;
    STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) ;
    STDMETHODIMP GetClassID(CLSID *pClsID);

    //
    // --- CPersistStream ---
    //

    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    DWORD GetSoftwareVersion(void);
    int SizeMax();

    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);

    HRESULT DeliverChannelChangeInfo(KS_TVTUNER_CHANGE_INFO &ChangeInfo,
                                     long Mode);

private:
    // Constructor
    CTVTunerFilter(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);


    // If there are multiple instances of this filter active, it's
    // useful for debug messages etc. to know which one this is.

    static              m_nInstanceCount;        // total instances
    int                 m_nThisInstance;

#ifdef PERF
    int m_idReceive;
#endif

    CTVTuner            *m_pTVTuner;
    CAnalogStream       *m_pPinList[TunerPinType_Last];
    
    KSPIN_MEDIUM        m_IFMedium;
    int                 m_cPins;

    CCritSec            m_TVTunerLock;          // To serialise access.

    // persist stream saved from  IPersistPropertyBag::Load
    IPersistStream     *m_pPersistStreamDevice;

    // Overall capabilities of the tuner (TV, AM, FM, DSS, ...)
    KSPROPERTY_TUNER_CAPS_S m_TunerCaps;
};


#endif // _INC_TVTUNERFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tvtuner\tvtuner.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// tvtuner.cpp  Main filter code for TV Tuner
//

#include <streams.h>            // quartz, includes windows
#include <measure.h>            // performance measurement (MSR_)
#include <winbase.h>

#include <initguid.h>
#include <olectl.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "amtvuids.h"

#include "kssupp.h"
#include "tvtuner.h"
#include "ctvtuner.h"           // the guy that does the real work
#include "ptvtuner.h"           // property page

#if ENABLE_DEMOD
#include "demodi.h"
#include "demod.h"
#endif // ENABLE_DEMOD

// Put out the name of the function and instance on the debugger.
#define DbgFunc(a) DbgLog(( LOG_TRACE                        \
                          , 2                                \
                          , TEXT("CTVTuner(Instance %d)::%s") \
                          , m_nThisInstance                  \
                          , TEXT(a)                          \
                         ));


// -------------------------------------------------------------------------
// g_Templates
// -------------------------------------------------------------------------

#if ENABLE_DEMOD
// BUGBUG, add to DShow
static GUID CLSID_DemodulatorFilter = 
// {77DE9E80-86D5-11d2-8F82-9A999D58494B}
{0x77de9e80, 0x86d5, 0x11d2, 0x8f, 0x82, 0x9a, 0x99, 0x9d, 0x58, 0x49, 0x4b};
#endif

CFactoryTemplate g_Templates[]=
{ 
    {
        L"TV Tuner Filter", 
        &CLSID_CTVTunerFilter, 
        CTVTunerFilter::CreateInstance
    },
    {
        L"TV Tuner Property Page", 
        &CLSID_TVTunerFilterPropertyPage, 
        CTVTunerProperties::CreateInstance
    },
#if ENABLE_DEMOD
    {
        L"Demodulator Filter", 
        &CLSID_DemodulatorFilter, 
        Demod::CreateInstance
    }
#endif // ENABLE_DEMOD
};
int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);


// initialise the static instance count.
int CTVTunerFilter::m_nInstanceCount = 0;


//
// This should be in a library, or helper object
//
BOOL
KsControl
(
   HANDLE hDevice,
   DWORD dwIoControl,
   PVOID pvIn,
   ULONG cbIn,
   PVOID pvOut,
   ULONG cbOut,
   PULONG pcbReturned
)
{
    HRESULT hr;

    hr = ::KsSynchronousDeviceControl(
                hDevice,
                dwIoControl,
                pvIn,
                cbIn,
                pvOut,
                cbOut,
                pcbReturned);

    return (SUCCEEDED (hr));
}

// -------------------------------------------------------------------------
// CAnalogStream
// -------------------------------------------------------------------------

CAnalogStream::CAnalogStream(TCHAR *pObjectName, 
                             CTVTunerFilter *pParent, 
                             CCritSec *pLock, HRESULT *phr, 
                             LPCWSTR pName,
                             const KSPIN_MEDIUM * Medium,
                             const GUID * CategoryGUID)
    : CBaseOutputPin(pObjectName, pParent, pLock, phr, pName)
    , CKsSupport (KSPIN_COMMUNICATION_SOURCE, reinterpret_cast<LPUNKNOWN>(pParent))
    , m_pTVTunerFilter (pParent)
{
    m_CategoryGUID = * CategoryGUID;
    if (Medium == NULL) {
        m_Medium.Set = GUID_NULL;
        m_Medium.Id = 0;
        m_Medium.Flags = 0;
    }
    else {
        m_Medium = * Medium;
    }

    SetKsMedium (&m_Medium); 
    SetKsCategory (CategoryGUID);
  
}

CAnalogStream::~CAnalogStream(void) 
{
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP CAnalogStream::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// CheckConnect
//
HRESULT CAnalogStream::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;

    hr = CBaseOutputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID, or check for a wildcard.
    if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void**) (&KsPin)))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

                Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
                    fOK = TRUE;
                }
            }

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect

//
// SetMediaType
//
// Overriden from CBasePin.
HRESULT CAnalogStream::SetMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pLock);

    // Pass the call up to my base class
    return CBasePin::SetMediaType(pMediaType);
}

// -------------------------------------------------------------------------
// CAnalogVideoStream
// -------------------------------------------------------------------------

CAnalogVideoStream::CAnalogVideoStream(CTVTunerFilter *pParent, 
                                       CCritSec *pLock, 
                                       HRESULT *phr, 
                                       LPCWSTR pName,
                                       const KSPIN_MEDIUM * Medium,
                                       const GUID * CategoryGUID)
    : CAnalogStream(NAME("Analog Video output pin"), pParent, pLock, phr, pName, Medium, CategoryGUID) 
{
}

CAnalogVideoStream::~CAnalogVideoStream(void) 
{
}


//
// Format Support
//

//
// GetMediaType
//
HRESULT CAnalogVideoStream::GetMediaType (
    int iPosition,
    CMediaType *pmt) 
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 2, TEXT("AnalogVideoStream::GetMediaType")));

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition >= 0)
        return VFW_S_NO_MORE_ITEMS;

    ANALOGVIDEOINFO avi;
    
    pmt->SetFormatType(&FORMAT_AnalogVideo);
    pmt->SetType(&MEDIATYPE_AnalogVideo);
    pmt->SetTemporalCompression(FALSE);
    pmt->SetSubtype(&KSDATAFORMAT_SUBTYPE_NONE);
    
    SetRect (&avi.rcSource, 0, 0,  720, 483);
    SetRect (&avi.rcTarget, 0, 0,  720, 483);
    avi.dwActiveWidth  =  720;
    avi.dwActiveHeight =  483;
    avi.AvgTimePerFrame = FRAMETO100NS (29.97);
    
    pmt->SetFormat ((BYTE *) &avi, sizeof (avi));

    return NOERROR;
}


//
// CheckMediaType
//
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
HRESULT CAnalogVideoStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pLock);

    if (   (*(pMediaType->Type()) != MEDIATYPE_AnalogVideo)    // we only output video!
        || (pMediaType->IsTemporalCompressed())        // ...in uncompressed form
        || !(pMediaType->IsFixedSize()) ) {        // ...in fixed size samples
        return E_INVALIDARG;
    }

    // Check for the subtypes we support

    // Get the format area of the media type

    return S_OK;  // This format is acceptable.
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. 
HRESULT CAnalogVideoStream::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    // Just one buffer of sizeof(KS_TVTUNER_CHANGE_INFO) length
    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = sizeof(KS_TVTUNER_CHANGE_INFO);
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }

    return NOERROR;
}

HRESULT CAnalogVideoStream::Run(REFERENCE_TIME tStart)
{
    // Channel of -1 means:
    //
    // Propogate tuning info downstream, but don't actually tune
    // This informs VBI decoders of the format as we transition to the run state
    // 

    m_pTVTunerFilter->put_Channel( -1, 
                        AMTUNER_SUBCHAN_DEFAULT, 
                        AMTUNER_SUBCHAN_DEFAULT);    

    return NOERROR;
}

// -------------------------------------------------------------------------
// CAnalogAudioStream
// -------------------------------------------------------------------------

CAnalogAudioStream::CAnalogAudioStream(CTVTunerFilter *pParent, 
                                       CCritSec *pLock, 
                                       HRESULT *phr, 
                                       LPCWSTR pName,
                                       const KSPIN_MEDIUM * Medium,
                                       const GUID * CategoryGUID)
    : CAnalogStream(NAME("Analog Audio output pin"), pParent, pLock, phr, pName, Medium, CategoryGUID) 
{
}

CAnalogAudioStream::~CAnalogAudioStream(void) 
{
}

//
// Format Support
//

//
// GetMediaType
//
HRESULT CAnalogAudioStream::GetMediaType (
    int iPosition,
    CMediaType *pmt) 
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 2, TEXT("AnalogAudioStream::GetMediaType")));

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition > 0)
    return VFW_S_NO_MORE_ITEMS;

    pmt->SetFormatType(&GUID_NULL);
    pmt->SetType(&MEDIATYPE_AnalogAudio);
    pmt->SetTemporalCompression(FALSE);
    pmt->SetSubtype(&MEDIASUBTYPE_NULL);

    return S_OK;
}


//
// CheckMediaType
//
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
HRESULT CAnalogAudioStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pLock);

    // BOGUS, what should the analog audio format be?
    if (   (*(pMediaType->Type()) != MEDIATYPE_AnalogAudio)    // we only output video!
        || (pMediaType->IsTemporalCompressed())        // ...in uncompressed form
        || !(pMediaType->IsFixedSize()) ) {        // ...in fixed size samples
        return E_INVALIDARG;
    }

    // Check for the subtypes we support

    // Get the format area of the media type

    return S_OK;  // This format is acceptable.
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. 
HRESULT CAnalogAudioStream::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    // Just one buffer of sizeof(KS_TVTUNER_CHANGE_INFO) length
    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = sizeof(KS_TVTUNER_CHANGE_INFO);
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }

    return NOERROR;
}

// -------------------------------------------------------------------------
// CFMAudioStream
// -------------------------------------------------------------------------

CFMAudioStream::CFMAudioStream(CTVTunerFilter *pParent, 
                               CCritSec *pLock, 
                               HRESULT *phr, 
                               LPCWSTR pName,
                               const KSPIN_MEDIUM * Medium,
                               const GUID * CategoryGUID)
    : CAnalogStream(NAME("Analog Audio output pin"), pParent, pLock, phr, pName, Medium, CategoryGUID) 
{
}

CFMAudioStream::~CFMAudioStream(void) 
{
}

//
// Format Support
//

//
// GetMediaType
//
HRESULT CFMAudioStream::GetMediaType (
    int iPosition,
    CMediaType *pmt) 
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 2, TEXT("AnalogAudioStream::GetMediaType")));

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition > 0)
    return VFW_S_NO_MORE_ITEMS;

    pmt->SetFormatType(&GUID_NULL);
    pmt->SetType(&MEDIATYPE_AnalogAudio);
    pmt->SetTemporalCompression(FALSE);
    pmt->SetSubtype(&MEDIASUBTYPE_NULL);

    return S_OK;
}


//
// CheckMediaType
//
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
HRESULT CFMAudioStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pLock);

    // BOGUS, what should the analog audio format be?
    if (   (*(pMediaType->Type()) != MEDIATYPE_AnalogAudio)    // we only output video!
        || (pMediaType->IsTemporalCompressed())        // ...in uncompressed form
        || !(pMediaType->IsFixedSize()) ) {        // ...in fixed size samples
        return E_INVALIDARG;
    }

    // Check for the subtypes we support

    // Get the format area of the media type

    return S_OK;  // This format is acceptable.
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. 
HRESULT CFMAudioStream::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    // Just one buffer of sizeof(KS_TVTUNER_CHANGE_INFO) length
    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = sizeof(KS_TVTUNER_CHANGE_INFO);
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }

    return NOERROR;
}

// -------------------------------------------------------------------------
// CIFStream  Intermediate Frequency Stream for DTV
// -------------------------------------------------------------------------

CIFStream::CIFStream(CTVTunerFilter *pParent, 
                               CCritSec *pLock, 
                               HRESULT *phr, 
                               LPCWSTR pName,
                               const KSPIN_MEDIUM * Medium,
                               const GUID * CategoryGUID)
    : CAnalogStream(NAME("IF output pin"), pParent, pLock, phr, pName, Medium, CategoryGUID) 
{
}

CIFStream::~CIFStream(void) 
{
}

//
// Format Support
//

//
// GetMediaType
//
HRESULT CIFStream::GetMediaType (
    int iPosition,
    CMediaType *pmt) 
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 2, TEXT("IntermediateFreqStream::GetMediaType")));

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition > 0)
    return VFW_S_NO_MORE_ITEMS;

    pmt->SetFormatType(&GUID_NULL);
    pmt->SetType(&MEDIATYPE_AnalogVideo);
    pmt->SetTemporalCompression(FALSE);
    pmt->SetSubtype(&MEDIASUBTYPE_NULL);

    return S_OK;
}


//
// CheckMediaType
//
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
HRESULT CIFStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pLock);

    // BOGUS, what should the analog audio format be?
    if (   (*(pMediaType->Type()) != MEDIATYPE_AnalogVideo)    // we only output video!
        || (pMediaType->IsTemporalCompressed())        // ...in uncompressed form
        || !(pMediaType->IsFixedSize()) ) {        // ...in fixed size samples
        return E_INVALIDARG;
    }

    // Check for the subtypes we support

    // Get the format area of the media type

    return S_OK;  // This format is acceptable.
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. 
HRESULT CIFStream::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    // Just one buffer of sizeof(KS_TVTUNER_CHANGE_INFO) length
    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = sizeof(KS_TVTUNER_CHANGE_INFO);
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }

    return NOERROR;
}


// -------------------------------------------------------------------------
// CTVTuner
// -------------------------------------------------------------------------

CTVTunerFilter::CTVTunerFilter(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr)
    : m_pTVTuner(NULL)
    , m_cPins(0)
    , m_pPersistStreamDevice(NULL)
    , CBaseFilter(tszName, punk, &m_TVTunerLock, CLSID_CTVTunerFilter)
    , CPersistStream(punk, phr)
{
    DbgFunc("TVTunerFilter");

    ZeroMemory (m_pPinList, sizeof (m_pPinList));

    m_pTVTuner = new CTVTuner(this);
    if (m_pTVTuner == NULL)
        *phr = E_OUTOFMEMORY;

    m_nThisInstance = ++m_nInstanceCount;

#ifdef PERF
    TCHAR msg[64];
    wsprintf(msg, TEXT("TVTunerFilter instance %d "), m_nThisInstance);
    m_idReceive = Msr_Register(msg);
#endif

} 

//
// CTVTunerFilter::Destructor
//
CTVTunerFilter::~CTVTunerFilter(void) 
{
    for (int j = 0; j < TunerPinType_Last; j++) {
        if (m_pPinList[j]) {
            delete m_pPinList[j];
            m_pPinList[j] = NULL;
        }
    }

    delete m_pTVTuner;

    if (m_pPersistStreamDevice) {
       m_pPersistStreamDevice->Release();
    }
}

//
// CreateInstance
//
// Provide the way for COM to create a CTVTunerFilter object
CUnknown *CTVTunerFilter::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

    CTVTunerFilter *pNewObject = new CTVTunerFilter(NAME("TVTuner Filter"), punk, phr );
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return pNewObject;
} // CreateInstance


int CTVTunerFilter::GetPinCount()
{
    CAutoLock lock(m_pLock);
    BOOL CreatePins = TRUE;

    // Create the output pins only when they're needed
    for (int j = 0; j < TunerPinType_Last; j++) {
        if (m_pPinList[j] != NULL) {
            CreatePins = FALSE;
            break;
        }
    }

    if (CreatePins) {
        HRESULT hr = NOERROR;

        if (!IsEqualGUID (m_TunerCaps.VideoMedium.Set, GUID_NULL)) {

            // Create the baseband video output
            m_pPinList [TunerPinType_Video] = new CAnalogVideoStream
                ( this
                , &m_TVTunerLock
                , &hr
                , L"Analog Video"
                , &m_TunerCaps.VideoMedium
                , &GUID_NULL);
            if (m_pPinList [TunerPinType_Video] != NULL) {
                if (FAILED(hr)) {
                    delete m_pPinList [TunerPinType_Video];
                    m_pPinList [TunerPinType_Video] = NULL;
                }
                else {
                    m_cPins++;
                }
            }
        }

        if (!IsEqualGUID (m_TunerCaps.TVAudioMedium.Set, GUID_NULL)) {

            // Create the TV Audio output pin
            m_pPinList [TunerPinType_Audio] = new CAnalogAudioStream
                ( this
                , &m_TVTunerLock
                , &hr
                , L"Analog Audio"
                , &m_TunerCaps.TVAudioMedium
                , &GUID_NULL
                );
            if (m_pPinList [TunerPinType_Audio] != NULL) {
                if (FAILED(hr)) {
                    delete m_pPinList [TunerPinType_Audio];
                    m_pPinList [TunerPinType_Audio] = NULL;
                }
                else {
                    m_cPins++;
                }
            }
        } // endif this is a TV tuner

        if (!IsEqualGUID (m_TunerCaps.RadioAudioMedium.Set, GUID_NULL)) {
        
            // Create the FM Audio output pin
            m_pPinList [TunerPinType_FMAudio] = new CFMAudioStream
                ( this
                , &m_TVTunerLock
                , &hr
                , L"FM Audio"
                , &m_TunerCaps.RadioAudioMedium
                , &GUID_NULL
                );
            if (m_pPinList [TunerPinType_FMAudio] != NULL) {
                if (FAILED(hr)) {
                    delete m_pPinList [TunerPinType_FMAudio];
                    m_pPinList [TunerPinType_FMAudio] = NULL;
                }
                else {
                    m_cPins++;
                }
            }
        }

        if (!IsEqualGUID (m_IFMedium.Set, GUID_NULL)) {
        
            // Create the IntermediateFreq output pin
            m_pPinList [TunerPinType_IF] = new CIFStream
                ( this
                , &m_TVTunerLock
                , &hr
                , L"IntermediateFreq"
                , &m_IFMedium
                , &GUID_NULL
                );
            if (m_pPinList [TunerPinType_IF] != NULL) {
                if (FAILED(hr)) {
                    delete m_pPinList [TunerPinType_IF];
                    m_pPinList [TunerPinType_IF] = NULL;
                }
                else {
                    m_cPins++;
                }
            }
        }
    }

    return m_cPins;
}

CBasePin *CTVTunerFilter::GetPin(int n)
{
    CBasePin *pPin = NULL;
    int Count = 0;

    for (int j = 0; j < TunerPinType_Last; j++) {
        if (m_pPinList[j] != NULL) {
            if (Count == n) {
                pPin = (CBasePin *) m_pPinList[j];
                break;
            }
            Count++;
        }
    }

    return pPin;
}

CBasePin *CTVTunerFilter::GetPinFromType (TunerPinType PinType)
{
    if (PinType < 0 || PinType >= TunerPinType_Last) {
        ASSERT (FALSE);
        return NULL;
    }

    // It's legal to return NULL from this function during initialization

    return m_pPinList [PinType];
}


//
// NonDelegatingQueryInterface
//
STDMETHODIMP CTVTunerFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == IID_IAMTVTuner) {
        return GetInterface((IAMTVTuner *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    }
    else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *) this, ppv);
    }
    else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else if (riid == __uuidof(IKsObject)) {
        return GetInterface(static_cast<IKsObject*>(this), ppv);
    } 
    else if (riid == __uuidof(IKsPropertySet)) {
        return GetInterface(static_cast<IKsPropertySet*>(this), ppv);
    }
    else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


// We can't Cue!

STDMETHODIMP CTVTunerFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    HRESULT hr = CBaseFilter::GetState(dwMSecs, State);
    
    if (m_State == State_Paused) {
        hr = ((HRESULT)VFW_S_CANT_CUE); // VFW_S_CANT_CUE;
    }
    return hr;
};

// -------------------------------------------------------------------------
// IPersistPropertyBag interface implementation for AMPnP support
// -------------------------------------------------------------------------

STDMETHODIMP CTVTunerFilter::InitNew(void)
{
    // Fine.  Just call Load()
    return S_OK ;
}

STDMETHODIMP CTVTunerFilter::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT hr;

    CAutoLock Lock(m_pLock);
    ASSERT(m_pTVTuner != NULL);

    // ::Load can succeed only once
    ASSERT(m_pPersistStreamDevice == 0);

    // save moniker with addref. ignore error if qi fails
    hr = pPropBag->QueryInterface(IID_IPersistStream, (void **)&m_pPersistStreamDevice);

    return m_pTVTuner->Load(pPropBag, pErrorLog, &m_TunerCaps, &m_IFMedium); 
}

STDMETHODIMP CTVTunerFilter::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, 
                            BOOL fSaveAllProperties)
{
    return E_NOTIMPL ;
}

/* Return the filter's clsid */
STDMETHODIMP CTVTunerFilter::GetClassID(CLSID *pClsID)
{
    return CBaseFilter::GetClassID(pClsID);
}


// -------------------------------------------------------------------------
// IPersistStream interface implementation for saving to a graph file
// -------------------------------------------------------------------------

#define ORIGINAL_DEFAULT_PERSIST_VERSION    0

// Insert obsolete versions above with new names
// Keep the following name, and increment the value if changing the persist stream format

#define CURRENT_PERSIST_VERSION             1

DWORD
CTVTunerFilter::GetSoftwareVersion(
    void
    )
/*++

Routine Description:

    Implement the CPersistStream::GetSoftwareVersion method. Returns
    the new version number rather than the default of zero.

Arguments:

    None.

Return Value:

    Return CURRENT_PERSIST_VERSION.

--*/
{
    return CURRENT_PERSIST_VERSION;
}

HRESULT CTVTunerFilter::WriteToStream(IStream *pStream)
{
    HRESULT hr;

    if (m_pPersistStreamDevice)
    {
        // CPersistStream already has written out the version acquired
        // from the CPersistStream::GetSoftwareVersion method.

        // Save the tuner state stream, followed by the property bag stream
        hr = m_pTVTuner->WriteToStream(pStream);
        if (SUCCEEDED(hr))
            hr = m_pPersistStreamDevice->Save(pStream, TRUE);
    }
    else
        hr = E_UNEXPECTED;

    return hr;
}

HRESULT CTVTunerFilter::ReadFromStream(IStream *pStream)
{
    DWORD dwJunk;
    HRESULT hr;

    //
    // If there is a stream pointer, then IPersistPropertyBag::Load has already
    // been called, and therefore this instance already has been initialized
    // with some particular state.
    //
    if (m_pPersistStreamDevice)
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);

    // The first element in the serialized data is the version stamp.
    // This was read by CPersistStream and put into mPS_dwFileVersion.
    // The rest of the data is the tuner state stream followed by the
    // property bag stream.
    if (mPS_dwFileVersion > GetSoftwareVersion())
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    switch (mPS_dwFileVersion)
    {
    case ORIGINAL_DEFAULT_PERSIST_VERSION:
        // Before any kind of useful persistence was implemented,
        // another version ID was stored in the stream. This reads
        // that value (and basically ignores it).
        hr = pStream->Read(&dwJunk, sizeof(dwJunk), 0);
        if (SUCCEEDED(hr))
            SetDirty(TRUE); // force an update to the persistent stream
        break;

    case CURRENT_PERSIST_VERSION:
        hr = m_pTVTuner->ReadFromStream(pStream);
        break;
    }

    // If all went well, then access the property bag to load and initialize the device
    if(SUCCEEDED(hr))
    {
        IPersistStream  *pMonPersistStream = NULL;

        // Use a device moniker instance to access and parse the property bag stream
        hr = CoCreateInstance(
            CLSID_CDeviceMoniker,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IPersistStream,
            (void **)&pMonPersistStream
            );
        if(SUCCEEDED(hr))
        {
            // Have the moniker get the property bag out of the stream
            hr = pMonPersistStream->Load(pStream);
            if(SUCCEEDED(hr))
            {
                IPropertyBag *pPropBag;

                // Get a reference for the property bag interface
                hr = pMonPersistStream->QueryInterface(IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    // Now call the Load method on this instance to open and initialize the device
                    hr = Load(pPropBag, NULL);

                    pPropBag->Release();
                }
            }

            pMonPersistStream->Release();
        }
    }

    return hr;
}

int CTVTunerFilter::SizeMax(void)
{
    if (m_pPersistStreamDevice)
    {
        // Get the space required for the Tuner state
        int DataSize = m_pTVTuner->SizeMax();
        ULARGE_INTEGER  BagLength;

        // The size of the property bag needs to be added.
        if (SUCCEEDED(m_pPersistStreamDevice->GetSizeMax(&BagLength))) {
            return (int)BagLength.QuadPart + DataSize;
        }
    }

    return 0;
}



// -------------------------------------------------------------------------
// ISpecifyPropertyPages
// -------------------------------------------------------------------------


//
// GetPages
//
// Returns the clsid's of the property pages we support
STDMETHODIMP CTVTunerFilter::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));

    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_TVTunerFilterPropertyPage;

    return NOERROR;
}

HRESULT
CTVTunerFilter::DeliverChannelChangeInfo(KS_TVTUNER_CHANGE_INFO &ChangeInfo, long Mode)
{
    HRESULT hr = NOERROR;
    IMediaSample *pMediaSample;
    CAnalogStream * pPin = NULL;
    CAutoLock Lock(m_pLock);

    //
    // At present, tuning notifications are only sent downstream on the 
    // AnalogVideo and ATSC streams
    //
    switch (Mode) {
    case KSPROPERTY_TUNER_MODE_TV:
        pPin = m_pPinList[TunerPinType_Video];
        break;
    case KSPROPERTY_TUNER_MODE_ATSC:
        pPin = m_pPinList[TunerPinType_IF];
        break;
    }

    if (pPin == NULL || !pPin->IsConnected()) {
        return hr;
    }


    hr = pPin->GetDeliveryBuffer(&pMediaSample, NULL, NULL, 0);
    if (!FAILED(hr)) {
        BYTE *pBuf;
    
        /* Get the sample's buffer pointer
         */
        hr = pMediaSample->GetPointer(&pBuf);
        if (!FAILED(hr))
        {
            /* Copy the ChangeInfo structure into the media sample
             */
            memcpy(pBuf, &ChangeInfo, sizeof(KS_TVTUNER_CHANGE_INFO));
            hr = pMediaSample->SetActualDataLength(sizeof(KS_TVTUNER_CHANGE_INFO));
            hr = pPin->Deliver(pMediaSample);
        }
    
        pMediaSample->Release();
    }
    return hr;
}

//
// Generic recursive function which traverses a graph downstream, searching
// for a given filter interface.
//
// pPin is assumed to be an input pin on a filter
//
//
STDMETHODIMP
CTVTunerFilter::FindDownstreamInterface (
    IPin        *pPin, 
    const GUID  &pInterfaceGUID,
    VOID       **pInterface)
{
    HRESULT                 hr;
    PIN_INFO                PinInfo;
    ULONG                   InternalConnectionCount = 0;
    IPin                  **InternalConnectionPinArray;
    ULONG                   j;
    BOOL                    Found = FALSE;
    IPin                   *pInputPin;
                    
    
    //
    // See if the desired interface is available on the filter of the passed in pin
    //

    if (pPin == NULL)
        return E_NOINTERFACE;

    if (SUCCEEDED (hr = pPin->QueryPinInfo(&PinInfo))) {
        if (SUCCEEDED (hr = PinInfo.pFilter->QueryInterface(
                            pInterfaceGUID, 
                            reinterpret_cast<PVOID*>(pInterface)))) {
            Found = TRUE;
        }
        PinInfo.pFilter->Release();
    }
    if (Found) {
        return hr;
    }

    //
    // Must not be available on this filter, so recursively search all of the connected pins
    //

    // first, just get the count of connected pins

    if (SUCCEEDED (hr = pPin->QueryInternalConnections(
                        NULL, // InternalConnectionPinArray, 
                        &InternalConnectionCount))) {

        if (InternalConnectionPinArray = new IPin * [InternalConnectionCount]) {

            if (SUCCEEDED (hr = pPin->QueryInternalConnections(
                                InternalConnectionPinArray, 
                                &InternalConnectionCount))) {

                for (j = 0; !Found && (j < InternalConnectionCount); j++) {

                    if (SUCCEEDED (InternalConnectionPinArray[j]->ConnectedTo(&pInputPin))) {

                        // Call ourself recursively
                        if (SUCCEEDED (hr = FindDownstreamInterface (
                                            pInputPin,
                                            pInterfaceGUID,
                                            pInterface))) {
                            Found = TRUE;
                        }
                        pInputPin->Release();
                    }
                }
            }
            for (j = 0; j < InternalConnectionCount; j++) {
                InternalConnectionPinArray[j]->Release();
            }
            delete [] InternalConnectionPinArray;
        }
    }

    return Found ? S_OK : E_NOINTERFACE;
}

// -------------------------------------------------------------------------
// IKsObject and IKsPropertySet
// -------------------------------------------------------------------------

STDMETHODIMP_(HANDLE)
CTVTunerFilter::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsObject::KsGetObjectHandle method. This is used both within
    this filter instance, and across filter instances in order to connect pins
    of two filter drivers together. It is the only interface which need be
    supported by another filter implementation to allow it to act as another
    proxy.

Arguments:

    None.

Return Value:

    Returns the handle to the underlying filter driver. This presumably is not
    NULL, as the instance was successfully created.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter.
    //
    return m_pTVTuner->Device();
}


STDMETHODIMP
CTVTunerFilter::Set(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Set method. This sets a property on the
    underlying kernel filter.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the data to pass to the property.

    DataLength -
        Contains the length of the data passed.

Return Value:

    Returns NOERROR if the property was set.

--*/
{
    ULONG   BytesReturned;

    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_SET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsSynchronousDeviceControl(
            m_pTVTuner->Device(),
            IOCTL_KS_PROPERTY,
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            &BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_SET;
        return KsSynchronousDeviceControl(
            m_pTVTuner->Device(),
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            &BytesReturned);
    }
}


STDMETHODIMP
CTVTunerFilter::Get(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength,
    ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Get method. This gets a property on the
    underlying kernel filter.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the place in which to return the data for the property.

    DataLength -
        Contains the length of the data buffer passed.

    BytesReturned -
        The place in which to put the number of bytes actually returned.

Return Value:

    Returns NOERROR if the property was retrieved.

--*/
{
    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_GET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsSynchronousDeviceControl(
            m_pTVTuner->Device(),
            IOCTL_KS_PROPERTY,
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_GET;
        return KsSynchronousDeviceControl(
            m_pTVTuner->Device(),
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            BytesReturned);
    }
}


STDMETHODIMP
CTVTunerFilter::QuerySupported(
    REFGUID PropSet,
    ULONG Id,
    ULONG* TypeSupport
    )
/*++

Routine Description:

    Implement the IKsPropertySet::QuerySupported method. Return the type of
    support is provided for this property.

Arguments:

    PropSet -
        The GUID of the set to query.

    Id -
        The property identifier within the set.

    TypeSupport
        Optionally the place in which to put the type of support. If NULL, the
        query returns whether or not the property set as a whole is supported.
        In this case the Id parameter is not used and must be zero.

Return Value:

    Returns NOERROR if the property support was retrieved.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = PropSet;
    Property.Id = Id;
    Property.Flags = TypeSupport ? KSPROPERTY_TYPE_BASICSUPPORT : KSPROPERTY_TYPE_SETSUPPORT;
    return KsSynchronousDeviceControl(
        m_pTVTuner->Device(),
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        TypeSupport,
        TypeSupport ? sizeof(*TypeSupport) : 0,
        &BytesReturned);
}

// -------------------------------------------------------------------------
// IAMTuner
// -------------------------------------------------------------------------

STDMETHODIMP
CTVTunerFilter::put_Channel(
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel)
{
    long Min, Max;

    ChannelMinMax (&Min, &Max);
    if (lChannel < Min || lChannel > Max) {
        return E_INVALIDARG;
    }

    SetDirty(TRUE);

    return m_pTVTuner->put_Channel(lChannel, lVideoSubChannel, lAudioSubChannel);
}

STDMETHODIMP
CTVTunerFilter::get_Channel(
            /* [out] */ long  *plChannel,
            /* [out] */ long  *plVideoSubChannel,
            /* [out] */ long  *plAudioSubChannel)
{
    MyValidateWritePtr (plChannel, sizeof(long), E_POINTER);
    MyValidateWritePtr (plVideoSubChannel, sizeof(long), E_POINTER);
    MyValidateWritePtr (plAudioSubChannel, sizeof(long), E_POINTER);

    return m_pTVTuner->get_Channel(plChannel, plVideoSubChannel, plAudioSubChannel);
}

STDMETHODIMP
CTVTunerFilter::ChannelMinMax(long *plChannelMin, long *plChannelMax)
{
    MyValidateWritePtr (plChannelMin, sizeof(long), E_POINTER);
    MyValidateWritePtr (plChannelMax, sizeof(long), E_POINTER);

    return m_pTVTuner->ChannelMinMax (plChannelMin, plChannelMax);
}

STDMETHODIMP
CTVTunerFilter::put_CountryCode(long lCountryCode)
{
    SetDirty(TRUE);

    return m_pTVTuner->put_CountryCode(lCountryCode);
}

STDMETHODIMP
CTVTunerFilter::get_CountryCode(long *plCountryCode)
{
    MyValidateWritePtr (plCountryCode, sizeof(long), E_POINTER);

    return m_pTVTuner->get_CountryCode(plCountryCode);
}


STDMETHODIMP
CTVTunerFilter::put_TuningSpace(long lTuningSpace)
{
    SetDirty(TRUE);

    return m_pTVTuner->put_TuningSpace(lTuningSpace);
}

STDMETHODIMP
CTVTunerFilter::get_TuningSpace(long *plTuningSpace)
{
    MyValidateWritePtr (plTuningSpace, sizeof(long), E_POINTER);

    return m_pTVTuner->get_TuningSpace(plTuningSpace);
}

STDMETHODIMP
CTVTunerFilter::Logon(HANDLE hCurrentUser)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CTVTunerFilter::Logout (void)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CTVTunerFilter::SignalPresent( 
      /* [out] */ long *plSignalStrength)
{
    MyValidateWritePtr (plSignalStrength, sizeof(long), E_POINTER);

    return m_pTVTuner->SignalPresent (plSignalStrength);
}

STDMETHODIMP 
CTVTunerFilter::put_Mode( 
      /* [in] */ AMTunerModeType lMode)
{
    SetDirty(TRUE);

    return m_pTVTuner->put_Mode(lMode);
}

STDMETHODIMP 
CTVTunerFilter::get_Mode( 
      /* [in] */ AMTunerModeType *plMode)
{
    MyValidateWritePtr (plMode, sizeof(long), E_POINTER);

    return m_pTVTuner->get_Mode (plMode);
}

STDMETHODIMP
CTVTunerFilter::GetAvailableModes( 
    /* [out] */ long __RPC_FAR *plModes)
{
    MyValidateWritePtr (plModes, sizeof(long), E_POINTER);

    return m_pTVTuner->GetAvailableModes (plModes);
}

STDMETHODIMP 
CTVTunerFilter::RegisterNotificationCallBack( 
    /* [in] */ IAMTunerNotification *pNotify,
    /* [in] */ long lEvents) 
{ 
    return E_NOTIMPL;
}

STDMETHODIMP
CTVTunerFilter::UnRegisterNotificationCallBack( 
    IAMTunerNotification  *pNotify)
{ 
    return E_NOTIMPL;
}

// -------------------------------------------------------------------------
// IAMTVTuner
// -------------------------------------------------------------------------

STDMETHODIMP 
CTVTunerFilter::get_AvailableTVFormats (
        long *pAnalogVideoStandard)
{
    MyValidateWritePtr (pAnalogVideoStandard, sizeof(long), E_POINTER);

    return m_pTVTuner->get_AvailableTVFormats (pAnalogVideoStandard); 
}


STDMETHODIMP 
CTVTunerFilter::get_TVFormat (long *plAnalogVideoStandard)
{
    MyValidateWritePtr (plAnalogVideoStandard, sizeof(AnalogVideoStandard), E_POINTER);

    return m_pTVTuner->get_TVFormat (plAnalogVideoStandard);
}

STDMETHODIMP 
CTVTunerFilter::AutoTune (long lChannel, long * plFoundSignal)
{
    MyValidateWritePtr (plFoundSignal, sizeof(long), E_POINTER);

    SetDirty(TRUE);

    return m_pTVTuner->AutoTune (lChannel, plFoundSignal);
}

STDMETHODIMP 
CTVTunerFilter::StoreAutoTune ()
{
    return m_pTVTuner->StoreAutoTune ();
}

STDMETHODIMP 
CTVTunerFilter::get_NumInputConnections (long * plNumInputConnections)
{
    MyValidateWritePtr (plNumInputConnections, sizeof(long), E_POINTER);

    return m_pTVTuner->get_NumInputConnections (plNumInputConnections);
}

STDMETHODIMP 
CTVTunerFilter::get_InputType (long lIndex, TunerInputType * pInputConnectionType)
{
    MyValidateWritePtr (pInputConnectionType, sizeof(long), E_POINTER);

    return m_pTVTuner->get_InputType (lIndex, pInputConnectionType);
}

STDMETHODIMP 
CTVTunerFilter::put_InputType (long lIndex, TunerInputType InputConnectionType)
{
    SetDirty(TRUE);

    return m_pTVTuner->put_InputType (lIndex, InputConnectionType);
}

STDMETHODIMP 
CTVTunerFilter::put_ConnectInput (long lIndex)
{
    SetDirty(TRUE);

    return m_pTVTuner->put_ConnectInput (lIndex);
}

STDMETHODIMP 
CTVTunerFilter::get_ConnectInput (long * plIndex)
{
    MyValidateWritePtr (plIndex, sizeof(long), E_POINTER);

    return m_pTVTuner->get_ConnectInput (plIndex);
}

STDMETHODIMP 
CTVTunerFilter::get_VideoFrequency (long * plFreq)
{
    MyValidateWritePtr (plFreq, sizeof(long), E_POINTER);

    return m_pTVTuner->get_VideoFrequency (plFreq);
}

STDMETHODIMP 
CTVTunerFilter::get_AudioFrequency (long * plFreq)
{
    MyValidateWritePtr (plFreq, sizeof(long), E_POINTER);

    return m_pTVTuner->get_AudioFrequency (plFreq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbiscope\scope.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// VBIScope filter


// {2CBDE200-56EB-11d1-8F82-A033C8B05564}
DEFINE_GUID(CLSID_VBISCOPE,
0x2cbde200, 0x56eb, 0x11d1, 0x8f, 0x82, 0xa0, 0x33, 0xc8, 0xb0, 0x55, 0x64);

class CScopeFilter;
class CScopeWindow;

// Class supporting the scope input pin

class CScopeInputPin : public CBaseInputPin
{
    friend class CScopeFilter;
    friend class CScopeWindow;

private:

    CScopeFilter *m_pFilter;         // The filter that owns us

public:

    CScopeInputPin(CScopeFilter *pTextOutFilter,
                   HRESULT *phr,
                   LPCWSTR pPinName);
    ~CScopeInputPin();

    // Lets us know where a connection ends
    HRESULT BreakConnect();

    // Check that we can support this input type
    HRESULT CheckMediaType(const CMediaType *pmt);

    // Actually set the current format
    HRESULT SetMediaType(const CMediaType *pmt);

    // IMemInputPin virtual methods

    // Override so we can show and hide the window
    HRESULT Active(void);
    HRESULT Inactive(void);

    // Here's the next block of data from the stream.
    // AddRef it if you are going to hold onto it
    STDMETHODIMP Receive(IMediaSample *pSample);

}; // CScopeInputPin


// This class looks after the management of a window. When the class gets
// instantiated the constructor spawns off a worker thread that does all
// the window work. The original thread waits until it is signaled to
// continue. The worker thread first registers the window class if it
// is not already done. Then it creates a window and sets it's size to
// a default iWidth by iHeight dimensions. The worker thread MUST be the
// one who creates the window as it is the one who calls GetMessage. When
// it has done all this it signals the original thread which lets it
// continue, this ensures a window is created and valid before the
// constructor returns. The thread start address is the WindowMessageLoop
// function. This takes as it's initialisation parameter a pointer to the
// CVideoWindow object that created it, the function also initialises it's
// window related member variables such as the handle and device contexts

// These are the video window styles

const DWORD dwTEXTSTYLES = (WS_POPUP | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPCHILDREN);
const DWORD dwCLASSSTYLES = (CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT | CS_OWNDC);
const LPTSTR RENDERCLASS = TEXT("VBIScopeWindowClass");
const LPTSTR TITLE = TEXT("VBIScope");

const int iWIDTH = 320;             // Initial window width
const int iHEIGHT = 240;            // Initial window height
const int WM_GOODBYE (WM_USER + 2); // Sent to close the window

class CScopeWindow : public CCritSec
{
    friend class CScopeInputPin;
    friend class CScopeFilter;

private:

    HINSTANCE m_hInstance;          // Global module instance handle
    CScopeFilter *m_pRenderer;      // The owning renderer object
    HWND m_hwndDlg;                 // Handle for our dialog
    HWND m_hwnd;                    // Handle for the graph window
    HBRUSH m_hBrushBackground;      // Used to paint background
    HPEN m_hPen1;                   // We use two pens for drawing
    HPEN m_hPen2;                   //  the waveforms in the window
    HPEN m_hPenTicks;               // Used to draw ticks at bottom
    HBITMAP m_hBitmap;              // Draw all waveforms into here
    HANDLE m_hThread;               // Our worker thread
    DWORD m_ThreadID;               // Worker thread ID
    CAMEvent m_SyncWorker;          // Synchronise with worker thread
    CAMEvent m_RenderEvent;         // Signals sample to render
    LONG m_Width;                   // Client window width
    LONG m_Height;                  // Client window height
    BOOL m_bActivated;              // Has the window been activated
    CRefTime m_StartSample;         // Most recent sample start time
    CRefTime m_EndSample;           // And it's associated end time
    BOOL m_bStreaming;              // Are we currently streaming
    POINT *m_pPoints1;              // Array of points to graph Channel1
    POINT *m_pPoints2;              // Array of points to graph Channel2
    int m_nPoints;                  // Size of m_pPoints[1|2]
    int m_LastMediaSampleSize;      // Size of last MediaSample

    int m_nSamplesPerLine;          // Samples per VBI line
    int m_MaxValue;                 // Max Value of the POINTS array

    double m_DurationPerSample;     // Time per sample
    double m_DurationOfLine;        // Time of one line

    int m_TopLine;                  // Left channel control settings
    int m_BottomLine;               // Right channel control settings
    BOOL m_TopF1;
    BOOL m_TopF2;
    BOOL m_BottomF1;
    BOOL m_BottomF2;

    int m_nTimebase;                // Timebase settings
    BOOL m_fFreeze;                 // Flag toi signal we're UI frozen
    int m_TBScroll;                 // Holds position in scroll range

    REFERENCE_TIME  m_CurrentFrame;
    REFERENCE_TIME  m_LastFrame;
    ULONGLONG       m_DroppedFrames;
    DWORD           m_FrameFlags;
    BOOL            m_IsF1;
    KS_VBIINFOHEADER m_VBIIH;

    // Hold window handles to controls

    HWND m_hwndTopLine;
    HWND m_hwndTopLineText;
    HWND m_hwndBottomLine;
    HWND m_hwndBottomLineText;
    HWND m_hwndTimebase;
    HWND m_hwndFreeze;
    HWND m_hwndTBScroll;
    HWND m_hwndTBStart;
    HWND m_hwndTBEnd;
    HWND m_hwndFrameCount;

    // These create and manage a video window on a separate thread

    HRESULT UninitialiseWindow();
    HRESULT InitialiseWindow(HWND hwnd);
    HRESULT MessageLoop();

    static DWORD __stdcall WindowMessageLoop(LPVOID lpvThreadParm);

    // Maps windows message loop into C++ virtual methods
    friend LRESULT CALLBACK WndProc(HWND hwnd,      // Window handle
                                    UINT uMsg,      // Message ID
                                    WPARAM wParam,  // First parameter
                                    LPARAM lParam); // Other parameter

    // Called when we start and stop streaming
    HRESULT ResetStreamingTimes();

    // Window message handlers
    BOOL OnClose();
    BOOL OnPaint();

    // Draw the waveform
    void ClearWindow(HDC hdc);
    BOOL AllocWaveBuffers(void);
    void CopyWaveform(IMediaSample *pMediaSample);

    void DrawPartialWaveform(HDC hdc,
                             int IndexStart,
                             int IndexEnd,
                             int ViewportStart,
                             int ViewportEnd);

    void DrawWaveform(void);
    void SetControlRanges(HWND hDlg);
    void SetHorizScrollRange(HWND hDlg);
    void ProcessVertScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam);
    void ProcessHorizScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam);

    friend INT_PTR CALLBACK ScopeDlgProc(HWND hwnd,        // Window handle
                                         UINT uMsg,          // Message ID
                                         WPARAM wParam,      // First parameter
                                         LPARAM lParam);     // Other parameter

public:

    // Constructors and destructors

    CScopeWindow(TCHAR *pName, CScopeFilter *pRenderer, HRESULT *phr);
    virtual ~CScopeWindow();

    HRESULT StartStreaming();
    HRESULT StopStreaming();
    HRESULT InactivateWindow();
    HRESULT ActivateWindow();

    // Called when the input pin receives a sample
    HRESULT Receive(IMediaSample * pIn);

}; // CScopeWindow


// This is the COM object that represents the VBIScope filter

class CScopeFilter : public CBaseFilter, public CCritSec
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN


    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

public:

    CScopeFilter(LPUNKNOWN pUnk,HRESULT *phr);
    virtual ~CScopeFilter();

    // Return the pins that we support
    int GetPinCount();
    CBasePin *GetPin(int n);

    // This goes in the factory template table to create new instances
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN, HRESULT *);

    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

private:

    // The nested classes may access our private state
    friend class CScopeInputPin;
    friend class CScopeWindow;

    CScopeInputPin *m_pInputPin;   // Handles pin interfaces
    CScopeWindow m_Window;         // Looks after the window

}; // CScopeFilter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbiscope\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scope.rc
//
#define VERSION_RES_MINOR_VER           0
#define VERSION_RES_BUILD               0
#define VER_DEBUG                       0
#define VERSION_RES_MAJOR_VER           1
#define IDD_SCOPEDIALOG                 101
#define IDI_ICON1                       103
#define IDC_TOP_LINE                    1001
#define IDC_TOP_LINE_TEXT               1002
#define IDC_L_OFFSET                    1003
#define IDC_L_TITLE                     1004
#define IDC_TIMEBASE_TEXT               1004
#define IDC_L_AUTO                      1005
#define IDC_BOTTOM_LINE                 1006
#define IDC_BOTTOM_LINE_TEXT            1007
#define IDC_R_OFFSET                    1008
#define IDC_R_TITLE                     1009
#define IDC_L_OFFSET_TEXT               1009
#define IDC_R_AUTO                      1010
#define IDC_TS_LAST                     1011
#define IDC_TB_START                    1012
#define IDC_TB_SCROLL                   1012
#define IDC_FREEZE                      1013
#define IDC_TIMEBASE                    1014
#define IDC_R_OFFSET_TEXT               1015
#define IDC_TS_START                    1016
#define IDC_TS_DELTA                    1017
#define IDC_FRAMES                      1017
#define IDC_SCOPEWINDOW                 1019
#define IDC_USER1                       1021
#define IDC_TRIGGER                     1022
#define IDC_FORMAT                      1023
#define IDC_BUFSIZE                     1024
#define IDC_DROPPED                     1024
#define IDC_TOP_F1                      1026
#define IDC_TOP_F2                      1028
#define IDC_BOTTOM_F1                   1029
#define IDC_BOTTOM_F2                   1030
#define VERSION_RES_LANGUAGE            0x409
#define VERSION_RES_CHARSET             1252

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbiscope\scope.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <tchar.h>
#include <commctrl.h>
#include <initguid.h>
#include <stdio.h>
#include <wxdebug.h>
#include <ks.h>
#include <ksmedia.h>
#include "scope.h"
#include "resource.h"

//
//
// What this sample illustrates
//
// An audio oscilloscope that shows the waveform graphically as the audio is
// received by the filter. The filter is a renderer that can put where ever
// the normal runtime renderer goes. We have a single input pin that accepts
// a number of difference audio formats and renders the data as appropriate.
//
//
// Summary
//
// This is an audio oscilloscope renderer - we are basicly an audio renderer
// When we are created we also create a class to look after the scope window
// whose constructor creates a worker thread, when it is destroyed it will
// also terminate the worker thread. On that worker thread a window is looked
// after that shows the audio waveform for data sent to us. The data is kept
// in a circular buffer that loops when sufficient data has been received. We
// support a number of different audio formats such as 8bit mode and stereo.
//
//
// Demonstration Instructions
//
// (To really sure of this demonstration the machine must have a sound card)
// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any
// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to
// the filters in the graph and find the filter (box) titled "Audio Renderer"
// This is the filter we will be replacing with this oscilloscope renderer.
// Then click on the box and hit DELETE. After that go to the Graph menu and
// select "Insert Filters", from the dialog box that pops up find and select
// "Oscilloscope", then dismiss the dialog. Back in the graph layout find the
// output pin of the filter that was connected to the input of the audio
// renderer you just deleted, right click and select "Render". You should
// see it being connected to the input pin of the oscilloscope you inserted
//
// Click Run on GRAPHEDT and you'll see a waveform for the audio soundtrack...
//
//
// Files
//
// icon1.ico            The icon for the oscilloscope window
// makefile             How we build it...
// resource.h           Microsoft Visual C++ generated file
// scope.cpp            The main filter and window implementations
// scope.def            What APIs the DLL imports and exports
// scope.h              Window and filter class definitions
// scope.mak            Visual C++ generated makefile
// scope.rc             Dialog box template for our window
// scope.reg            What goes in the registry to make us work
//
//
// Base classes we use
//
// CBaseInputPin        A generic input pin we use for the filter
// CCritSec             A wrapper class around a critical section
// CBaseFilter          The generic ActiveMovie filter object
//
//


// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &KSDATAFORMAT_TYPE_VBI,           // Major type
    &KSDATAFORMAT_SUBTYPE_RAW8          // Minor type
};


const AMOVIESETUP_PIN sudPins  =
{
    L"Input",                   // Pin string name
    FALSE,                      // Is it rendered
    FALSE,                      // Is it an output
    FALSE,                      // Allowed zero pins
    FALSE,                      // Allowed many
    &CLSID_NULL,                // Connects to filter
    L"Output",                  // Connects to pin
    1,                          // Number of pins types
    &sudPinTypes } ;            // Pin information


const AMOVIESETUP_FILTER sudScope =
{
    &CLSID_VBISCOPE,               // Filter CLSID
    L"VBI Scope",            // String name
    MERIT_DO_NOT_USE,           // Filter merit
    1,                          // Number pins
    &sudPins                    // Pin details
};


// List of class IDs and creator functions for class factory

CFactoryTemplate g_Templates []  = {
    { L"VBI Scope"
    , &CLSID_VBISCOPE
    , CScopeFilter::CreateInstance
    , NULL
    , &sudScope }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//
// CreateInstance
//
// This goes in the factory template table to create new instances
//
CUnknown * WINAPI CScopeFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CScopeFilter(pUnk, phr);

} // CreateInstance


//
// Constructor
//
// Create the filter, scope window, and input pin
//
#pragma warning(disable:4355)
//
CScopeFilter::CScopeFilter(LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseFilter(NAME("VBIScope"), pUnk, (CCritSec *) this, CLSID_VBISCOPE),
    m_Window(NAME("VBIScope"), this, phr)
{
    // Create the single input pin

    m_pInputPin = new CScopeInputPin(this,phr,L"Scope Input Pin");
    if (m_pInputPin == NULL) {
        *phr = E_OUTOFMEMORY;
    }

} // (Constructor)


//
// Destructor
//
CScopeFilter::~CScopeFilter()
{
    // Delete the contained interfaces

    ASSERT(m_pInputPin);
    delete m_pInputPin;
    m_pInputPin = NULL;

} // (Destructor)


//
// GetPinCount
//
// Return the number of input pins we support
//
int CScopeFilter::GetPinCount()
{
    return 1;

} // GetPinCount


//
// GetPin
//
// Return our single input pin - not addrefed
//
CBasePin *CScopeFilter::GetPin(int n)
{
    // We only support one input pin and it is numbered zero

    ASSERT(n == 0);
    if (n != 0) {
        return NULL;
    }
    return m_pInputPin;

} // GetPin


//
// JoinFilterGraph
//
// Show our window when we join a filter graph
//   - and hide it when we are annexed from it
//
STDMETHODIMP CScopeFilter::JoinFilterGraph(IFilterGraph *pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (FAILED(hr)) {
        return hr;
    }

    // Hide or show the scope as appropriate

    if (pGraph == NULL) {
        m_Window.InactivateWindow();
    } else {
        m_Window.ActivateWindow();
    }
    return hr;

} // JoinFilterGraph


//
// Stop
//
// Switch the filter into stopped mode.
//
STDMETHODIMP CScopeFilter::Stop()
{
    CAutoLock lock(this);

    if (m_State != State_Stopped) {

        // Pause the device if we were running
        if (m_State == State_Running) {
            HRESULT hr = Pause();
            if (FAILED(hr)) {
                return hr;
            }
        }

        DbgLog((LOG_TRACE,1,TEXT("Stopping....")));

        // Base class changes state and tells pin to go to inactive
        // the pin Inactive method will decommit our allocator which
        // we need to do before closing the device

        HRESULT hr = CBaseFilter::Stop();
        if (FAILED(hr)) {
            return hr;
        }
    }
    return NOERROR;

} // Stop


//
// Pause
//
// Override Pause to stop the window streaming
//
STDMETHODIMP CScopeFilter::Pause()
{
    CAutoLock lock(this);

    // Check we can PAUSE given our current state

    if (m_State == State_Running) {
        m_Window.StopStreaming();
    }

    // tell the pin to go inactive and change state
    return CBaseFilter::Pause();

} // Pause


//
// Run
//
// Overriden to start the window streaming
//
STDMETHODIMP CScopeFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock lock(this);
    HRESULT hr = NOERROR;
    FILTER_STATE fsOld = m_State;

    // This will call Pause if currently stopped

    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    m_Window.ActivateWindow();

    if (fsOld != State_Running) {
        m_Window.StartStreaming();
    }
    return NOERROR;

} // Run


//
// Constructor
//
CScopeInputPin::CScopeInputPin(CScopeFilter *pFilter,
                               HRESULT *phr,
                               LPCWSTR pPinName) :
    CBaseInputPin(NAME("Scope Input Pin"), pFilter, pFilter, phr, pPinName)
{
    m_pFilter = pFilter;

} // (Constructor)


//
// Destructor does nothing
//
CScopeInputPin::~CScopeInputPin()
{
} // (Destructor)


//
// BreakConnect
//
// This is called when a connection or an attempted connection is terminated
// and allows us to reset the connection media type to be invalid so that
// we can always use that to determine whether we are connected or not. We
// leave the format block alone as it will be reallocated if we get another
// connection or alternatively be deleted if the filter is finally released
//
HRESULT CScopeInputPin::BreakConnect()
{
    // Check we have a valid connection

    if (m_mt.IsValid() == FALSE) {
        return E_FAIL;
    }

    m_pFilter->Stop();

    // Reset the CLSIDs of the connected media type

    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);
    return CBaseInputPin::BreakConnect();

} // BreakConnect


//
// CheckMediaType
//
// Check that we can support a given proposed type
//
HRESULT CScopeInputPin::CheckMediaType(const CMediaType *pmt)
{
    PKS_VBIINFOHEADER pIH = (PKS_VBIINFOHEADER) pmt->Format();

    if (pIH == NULL)
        return E_INVALIDARG;

    if (pmt->majortype != KSDATAFORMAT_TYPE_VBI) {
        return E_INVALIDARG;
    }

    if (pmt->subtype != KSDATAFORMAT_SUBTYPE_RAW8) {
        return E_INVALIDARG;
    }

    if (pmt->formattype != KSDATAFORMAT_SPECIFIER_VBI) {
        return E_INVALIDARG;
    }

    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
// Actually set the format of the input pin
//
HRESULT CScopeInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock(m_pFilter);

    // Pass the call up to my base class

    HRESULT hr = CBaseInputPin::SetMediaType(pmt);
    if (SUCCEEDED(hr)) {

        PKS_VBIINFOHEADER pIH = (PKS_VBIINFOHEADER) pmt->Format();

        // Save a copy of the VBI info header
        m_pFilter->m_Window.m_VBIIH = *pIH;
        ASSERT (pIH->BufferSize == ((pIH->EndLine - pIH->StartLine + 1) *
                pIH->StrideInBytes));
        m_pFilter->m_Window.m_nSamplesPerLine = pIH->SamplesPerLine;
        m_pFilter->m_Window.m_MaxValue = 256;
        m_pFilter->m_Window.m_DurationPerSample = 1.0 / pIH->SamplingFrequency;
        m_pFilter->m_Window.m_DurationOfLine = (double) pIH->SamplesPerLine *
            m_pFilter->m_Window.m_DurationPerSample;

        if (!m_pFilter->m_Window.AllocWaveBuffers ())
            return E_FAIL;

        // Reset the horizontal scroll bar
        m_pFilter->m_Window.SetHorizScrollRange(m_pFilter->m_Window.m_hwndDlg);

        // Reset the horizontal scroll bar
        m_pFilter->m_Window.SetControlRanges(m_pFilter->m_Window.m_hwndDlg);
    }
    return hr;

} // SetMediaType


//
// Active
//
// Implements the remaining IMemInputPin virtual methods
//
HRESULT CScopeInputPin::Active(void)
{
    return NOERROR;

} // Active


//
// Inactive
//
// Called when the filter is stopped
//
HRESULT CScopeInputPin::Inactive(void)
{
    return NOERROR;

} // Inactive


//
// Receive
//
// Here's the next block of data from the stream
//
HRESULT CScopeInputPin::Receive(IMediaSample * pSample)
{
    // Lock this with the filter-wide lock
    CAutoLock lock(m_pFilter);

    // If we're stopped, then reject this call
    // (the filter graph may be in mid-change)
    if (m_pFilter->m_State == State_Stopped) {
        return E_FAIL;
    }

    // Check all is well with the base class
    HRESULT hr = CBaseInputPin::Receive(pSample);
    if (FAILED(hr)) {
        return hr;
    }

    // Send the sample to the video window object for rendering
    return m_pFilter->m_Window.Receive(pSample);

} // Receive


//
// CScopeWindow Constructor
//
CScopeWindow::CScopeWindow(TCHAR *pName, CScopeFilter *pRenderer,HRESULT *phr) :
    m_hInstance(g_hInst),
    m_pRenderer(pRenderer),
    m_hThread(INVALID_HANDLE_VALUE),
    m_ThreadID(0),
    m_hwndDlg(NULL),
    m_hwnd(NULL),
    m_pPoints1(NULL),
    m_pPoints2(NULL),
    m_nPoints(0),
    m_bStreaming(FALSE),
    m_bActivated(FALSE),
    m_LastMediaSampleSize(0)
{
    // Create a thread to look after the window

    ASSERT(m_pRenderer);
    m_hThread = CreateThread(NULL,                  // Security attributes
                             (DWORD) 0,             // Initial stack size
                             WindowMessageLoop,     // Thread start address
                             (LPVOID) this,         // Thread parameter
                             (DWORD) 0,             // Creation flags
                             &m_ThreadID);          // Thread identifier

    // If we couldn't create a thread the whole thing's off

    ASSERT(m_hThread);
    if (m_hThread == NULL) {
        *phr = E_FAIL;
        return;
    }

    // Wait until the window has been initialised
    m_SyncWorker.Wait();

} // (Constructor)


//
// Destructor
//
CScopeWindow::~CScopeWindow()
{
    // Ensure we stop streaming and release any samples

    StopStreaming();
    InactivateWindow();

    // Tell the thread to destroy the window
    SendMessage(m_hwndDlg, WM_GOODBYE, (WPARAM)0, (LPARAM)0);

    // Make sure it has finished

    ASSERT(m_hThread != NULL);
    WaitForSingleObject(m_hThread,INFINITE);
    CloseHandle(m_hThread);

    if (m_pPoints1 != NULL) delete [] m_pPoints1;
    if (m_pPoints2 != NULL) delete [] m_pPoints2;

} // (Destructor)


//
// ResetStreamingTimes
//
// This resets the latest sample stream times
//
HRESULT CScopeWindow::ResetStreamingTimes()
{
    m_StartSample = 0;
    m_EndSample = 0;
    return NOERROR;

} // ResetStreamingTimes


//
// StartStreaming
//
// This is called when we start running state
//
HRESULT CScopeWindow::StartStreaming()
{
    CAutoLock cAutoLock(this);

    // Are we already streaming

    if (m_bStreaming == TRUE) {
        return NOERROR;
    }

    m_bStreaming = TRUE;

    m_CurrentFrame = 0;
    m_LastFrame = 0;
    m_DroppedFrames = 0;

    return NOERROR;

} // StartStreaming


//
// StopStreaming
//
// This is called when we stop streaming
//
HRESULT CScopeWindow::StopStreaming()
{
    CAutoLock cAutoLock(this);

    // Have we been stopped already

    if (m_bStreaming == FALSE) {
        return NOERROR;
    }

    m_bStreaming = FALSE;
    return NOERROR;

} // StopStreaming


//
// InactivateWindow
//
// Called at the end to put the window in an inactive state
//
HRESULT CScopeWindow::InactivateWindow()
{
    // Has the window been activated
    if (m_bActivated == FALSE) {
        return S_FALSE;
    }

    // Now hide the scope window

    ShowWindow(m_hwndDlg,SW_HIDE);
    m_bActivated = FALSE;
    return NOERROR;

} // InactivateWindow


//
// ActivateWindow
//
// Show the scope window
//
HRESULT CScopeWindow::ActivateWindow()
{
    // Has the window been activated
    if (m_bActivated == TRUE) {
        return S_FALSE;
    }

    m_bActivated = TRUE;
    ASSERT(m_bStreaming == FALSE);

    ShowWindow(m_hwndDlg,SW_SHOWNORMAL);
    return NOERROR;

} // ActivateWindow


//
// OnClose
//
// This function handles the WM_CLOSE message
//
BOOL CScopeWindow::OnClose()
{
    InactivateWindow();
    return TRUE;

} // OnClose



typedef struct TBEntry_tag {
    double TBDuration;
    TCHAR  TBText[16];
} TBEntry;

TBEntry Timebases[] =
{
    1e-6,  TEXT ("100 nS/Div"),
    2e-6,  TEXT ("200 nS/Div"),
    5e-6,  TEXT ("500 nS/Div"),
   10e-6,  TEXT ("1 uS/Div"),
   20e-6,  TEXT ("2 uS/Div"),
   50e-6,  TEXT ("5 uS/Div"),
   60e-6,  TEXT ("6 uS/Div"),
  100e-6,  TEXT ("10 uS/Div"),
};

#define N_TIMEBASES (sizeof(Timebases) / sizeof (Timebases[0]))
#define TIMEBASE_DEFAULT_INDEX 5


//
// SetControlRanges
//
// Set the scroll ranges for all of the vertical trackbars
//
void CScopeWindow::SetControlRanges(HWND hDlg)
{
    SendMessage(m_hwndTopLine, TBM_SETRANGE, TRUE,
        MAKELONG(m_VBIIH.StartLine, m_VBIIH.EndLine) );
    SendMessage(m_hwndTopLine, TBM_SETPOS, TRUE, (LPARAM) m_TopLine);
    SetDlgItemInt (hDlg, IDC_TOP_LINE_TEXT, m_TopLine, TRUE);

    SendMessage(m_hwndBottomLine, TBM_SETRANGE, TRUE,
        MAKELONG(m_VBIIH.StartLine, m_VBIIH.EndLine) );
    SendMessage(m_hwndBottomLine, TBM_SETPOS, TRUE, (LPARAM) m_BottomLine);
    SetDlgItemInt(hDlg, IDC_BOTTOM_LINE_TEXT, m_BottomLine, TRUE);

    SendMessage(m_hwndTimebase, TBM_SETRANGE, TRUE, MAKELONG(0, N_TIMEBASES - 1) );
    SendMessage(m_hwndTimebase, TBM_SETPOS, TRUE, (LPARAM) m_nTimebase);
    SetDlgItemText (hDlg, IDC_TIMEBASE_TEXT, Timebases[m_nTimebase].TBText);

} // SetControlRanges


//
// StringFromTVStandard
//
TCHAR * StringFromTVStandard(long TVStd)
{
    TCHAR * ptc;

    switch (TVStd) {
        case 0:                      ptc = TEXT("None");        break;
        case AnalogVideo_NTSC_M:     ptc = TEXT("NTSC_M");      break;
        case AnalogVideo_NTSC_M_J:   ptc = TEXT("NTSC_M_J");    break;
        case AnalogVideo_NTSC_433:   ptc = TEXT("NTSC_433");    break;

        case AnalogVideo_PAL_B:      ptc = TEXT("PAL_B");       break;
        case AnalogVideo_PAL_D:      ptc = TEXT("PAL_D");       break;
        case AnalogVideo_PAL_G:      ptc = TEXT("PAL_G");       break;
        case AnalogVideo_PAL_H:      ptc = TEXT("PAL_H");       break;
        case AnalogVideo_PAL_I:      ptc = TEXT("PAL_I");       break;
        case AnalogVideo_PAL_M:      ptc = TEXT("PAL_M");       break;
        case AnalogVideo_PAL_N:      ptc = TEXT("PAL_N");       break;
        case AnalogVideo_PAL_60:     ptc = TEXT("PAL_60");      break;

        case AnalogVideo_SECAM_B:    ptc = TEXT("SECAM_B");     break;
        case AnalogVideo_SECAM_D:    ptc = TEXT("SECAM_D");     break;
        case AnalogVideo_SECAM_G:    ptc = TEXT("SECAM_G");     break;
        case AnalogVideo_SECAM_H:    ptc = TEXT("SECAM_H");     break;
        case AnalogVideo_SECAM_K:    ptc = TEXT("SECAM_K");     break;
        case AnalogVideo_SECAM_K1:   ptc = TEXT("SECAM_K1");    break;
        case AnalogVideo_SECAM_L:    ptc = TEXT("SECAM_L");     break;
        case AnalogVideo_SECAM_L1:   ptc = TEXT("SECAM_L1");    break;
        default:
            ptc = TEXT("[undefined]");
            break;
    }
    return ptc;
}


//
// SetHorizScrollRange
//
// The horizontal scrollbar handles scrolling through the buffer
//
void CScopeWindow::SetHorizScrollRange(HWND hDlg)
{
    SendMessage(m_hwndTBScroll, TBM_SETRANGE, TRUE, MAKELONG(0, (m_nPoints - 1)));
    SendMessage(m_hwndTBScroll, TBM_SETPOS, TRUE, (LPARAM) 0);

    m_TBScroll = 0;

    // TODO: Show info about each sample

    TCHAR szFormat[160];
    _stprintf (szFormat, TEXT("BpL: %d\nStr: %d\n%f\n"), m_VBIIH.SamplesPerLine,
                                     m_VBIIH.StrideInBytes,
                                     (float) m_VBIIH.SamplingFrequency / 1e6);

    TCHAR * pStd = StringFromTVStandard (m_VBIIH.VideoStandard);
    _tcscat (szFormat, pStd ? pStd : TEXT("[undefined]") );

    SetDlgItemText (hDlg, IDC_FORMAT, szFormat);

} // SetHorizScrollRange


//
// ProcessHorizScrollCommands
//
// Called when we get a horizontal scroll bar message
//
void CScopeWindow::ProcessHorizScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int pos;
    int command = LOWORD (wParam);

    if (command != TB_ENDTRACK &&
        command != TB_THUMBTRACK &&
        command != TB_LINEDOWN &&
        command != TB_LINEUP &&
        command != TB_PAGEUP &&
        command != TB_PAGEDOWN)
            return;

    ASSERT (IsWindow ((HWND) lParam));

    pos = (int) SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L);

    if ((HWND) lParam == m_hwndTBScroll) {
        m_TBScroll = pos;
    }
    OnPaint();

} // ProcessHorizScrollCommands


//
// ProcessVertScrollCommands
//
// Called when we get a vertical scroll bar message
//
void CScopeWindow::ProcessVertScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    int pos;
    int command = LOWORD (wParam);

    if (command != TB_ENDTRACK &&
        command != TB_THUMBTRACK &&
        command != TB_LINEDOWN &&
        command != TB_LINEUP &&
        command != TB_PAGEUP &&
        command != TB_PAGEDOWN)
            return;

    ASSERT (IsWindow ((HWND) lParam));

    pos = (int) SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L);

    if ((HWND) lParam == m_hwndTopLine) {
        m_TopLine = pos;
        SetDlgItemInt (hDlg, IDC_TOP_LINE_TEXT, m_TopLine, TRUE);
    } else if ((HWND) lParam == m_hwndBottomLine) {
        m_BottomLine = pos;
        SetDlgItemInt (hDlg, IDC_BOTTOM_LINE_TEXT, m_BottomLine, TRUE);
    } else if ((HWND) lParam == m_hwndTimebase) {
        m_nTimebase = pos ;
        SetDlgItemText (hDlg, IDC_TIMEBASE_TEXT, Timebases[m_nTimebase].TBText);
    }
    OnPaint();

} // ProcessVertScrollCommands


//
// InitialiseWindow
//
// This is called by the worker window thread after it has created the main
// window and it wants to initialise the rest of the owner objects window
// variables such as the device contexts. We execute this function with the
// critical section still locked.
//
HRESULT CScopeWindow::InitialiseWindow(HWND hDlg)
{
    HRESULT hr = NO_ERROR;
    RECT rR;

    // Initialise the window variables
    m_hwnd = GetDlgItem (hDlg, IDC_SCOPEWINDOW);

    // Quick sanity check
    ASSERT(m_hwnd != NULL);

    m_nTimebase = TIMEBASE_DEFAULT_INDEX;
    m_fFreeze = 0;

    // Default is show CC on the bottom trace
    m_TopLine = 20;
    m_BottomLine = 21;
    m_TBScroll = 0;

    m_TopF1 = TRUE;
    m_TopF2 = TRUE;
    m_BottomF1 = TRUE;
    m_BottomF2 = FALSE;

    GetWindowRect (m_hwnd, &rR);
    m_Width = rR.right - rR.left;
    m_Height = rR.bottom - rR.top;

    m_hwndTopLine =       GetDlgItem (hDlg, IDC_TOP_LINE);
    m_hwndTopLineText =   GetDlgItem (hDlg, IDC_TOP_LINE_TEXT);

    m_hwndBottomLine =       GetDlgItem (hDlg, IDC_BOTTOM_LINE);
    m_hwndBottomLineText =   GetDlgItem (hDlg, IDC_BOTTOM_LINE_TEXT);

    m_hwndTimebase =    GetDlgItem (hDlg, IDC_TIMEBASE);
    m_hwndFreeze =      GetDlgItem (hDlg, IDC_FREEZE);
    m_hwndTBStart =     GetDlgItem (hDlg, IDC_TS_START);
    m_hwndTBEnd   =     GetDlgItem (hDlg, IDC_TS_LAST);
    m_hwndFrameCount =  GetDlgItem (hDlg, IDC_FRAMES);
    m_hwndTBScroll =    GetDlgItem (hDlg, IDC_TB_SCROLL);

    SetControlRanges(hDlg);
    SetHorizScrollRange(hDlg);

    CheckDlgButton(hDlg, IDC_TOP_F1, m_TopF1);	
    CheckDlgButton(hDlg, IDC_TOP_F2, m_TopF2);	
    CheckDlgButton(hDlg, IDC_BOTTOM_F1, m_BottomF1);	
    CheckDlgButton(hDlg, IDC_BOTTOM_F2, m_BottomF2);

    CheckDlgButton(hDlg, IDC_FREEZE, m_fFreeze);	

    m_hPen1 = CreatePen (PS_SOLID, 0, RGB (0, 0xff, 0));
    m_hPen2 = CreatePen (PS_SOLID, 0, RGB (0, 0xff, 0));
    m_hPenTicks = CreatePen (PS_SOLID, 0, RGB (0x80, 0x80, 0x80));
    m_hBrushBackground = (HBRUSH) GetStockObject (BLACK_BRUSH);

    if ( !m_hPen1 || !m_hPen2 || !m_hPenTicks || !m_hBrushBackground )
	hr = E_FAIL;

    HDC hdc = GetDC (NULL);
    if ( hdc )
    {
        m_hBitmap = CreateCompatibleBitmap (hdc, m_Width, m_Height);
        ReleaseDC (NULL, hdc);
    }
    else
    {
        m_hBitmap = NULL;
        hr = E_FAIL;
    }

    return hr;
} // InitialiseWindow


//
// UninitialiseWindow
//
// This is called by the worker window thread when it receives a WM_GOODBYE
// message from the window object destructor to delete all the resources we
// allocated during initialisation
//
HRESULT CScopeWindow::UninitialiseWindow()
{
    // Reset the window variables
    DeleteObject (m_hPen1);
    DeleteObject (m_hPen2);
    DeleteObject (m_hPenTicks);
    DeleteObject (m_hBitmap);

    m_hwnd = NULL;
    return NOERROR;

} // UninitialiseWindow


//
// ScopeDlgProc
//
// The Scope window is actually a dialog box, and this is its window proc.
// The only thing tricky about this is that the "this" pointer to the
// CScopeWindow is passed during the WM_INITDIALOG message and is stored
// in the window user data. This lets us access methods in the class
// from within the dialog.
//
INT_PTR CALLBACK ScopeDlgProc(HWND hDlg,	        // Handle of dialog box
                              UINT uMsg,	        // Message identifier
                              WPARAM wParam,	// First message parameter
                              LPARAM lParam)	// Second message parameter
{
    CScopeWindow *pScopeWindow;      // Pointer to the owning object

    // Get the window long that holds our owner pointer
    pScopeWindow = (CScopeWindow *) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg) {
        case WM_INITDIALOG:
            pScopeWindow = (CScopeWindow *) lParam;
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pScopeWindow);
            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hDlg, 0);
                    return TRUE;

                case IDC_FREEZE:
                    pScopeWindow->m_fFreeze =
                        (BOOL) IsDlgButtonChecked(hDlg,IDC_FREEZE);
                    pScopeWindow->DrawWaveform();
                    break;

                case IDC_TOP_F1:
                    pScopeWindow->m_TopF1 =
                        (BOOL) IsDlgButtonChecked(hDlg,IDC_TOP_F1);
                    break;

                case IDC_TOP_F2:
                    pScopeWindow->m_TopF2 =
                        (BOOL) IsDlgButtonChecked(hDlg,IDC_TOP_F2);
                    break;

                case IDC_BOTTOM_F1:
                    pScopeWindow->m_BottomF1 =
                        (BOOL) IsDlgButtonChecked(hDlg,IDC_BOTTOM_F1);
                    break;

                case IDC_BOTTOM_F2:
                    pScopeWindow->m_BottomF2 =
                        (BOOL) IsDlgButtonChecked(hDlg,IDC_BOTTOM_F2);
                    break;

                default:
                    break;
            }

        case WM_VSCROLL:
            pScopeWindow->ProcessVertScrollCommands(hDlg, wParam, lParam);
            break;

        case WM_HSCROLL:
            pScopeWindow->ProcessHorizScrollCommands(hDlg, wParam, lParam);
            break;

        case WM_PAINT:
            ASSERT(pScopeWindow != NULL);
            pScopeWindow->OnPaint();
            break;

        // We stop WM_CLOSE messages going any further by intercepting them
        // and then setting an abort signal flag in the owning renderer so
        // that it knows the user wants to quit. The renderer can then
        // go about deleting it's interfaces and the window helper object
        // which will eventually cause a WM_DESTROY message to arrive. To
        // make it look as though the window has been immediately closed
        // we hide it and then wait for the renderer to catch us up

        case WM_CLOSE:
            ASSERT(pScopeWindow != NULL);
            pScopeWindow->OnClose();
            return (LRESULT) 0;

        // We receive a WM_GOODBYE window message (synchronously) from the
        // window object destructor in which case we do actually destroy
        // the window and complete the process in the WM_DESTROY message

        case WM_GOODBYE:
            ASSERT(pScopeWindow != NULL);
            pScopeWindow->UninitialiseWindow();
            PostQuitMessage(FALSE);
            EndDialog (hDlg, 0);
            return (LRESULT) 0;

        default:
            break;
    }
    return (LRESULT) 0;

} // ScopeDlgProc


//
// MessageLoop
//
// This is the standard windows message loop for our worker thread. It sits
// in a normal processing loop dispatching messages until it receives a quit
// message, which may be generated through the owning object's destructor
//
HRESULT CScopeWindow::MessageLoop()
{
    MSG Message;        // Windows message structure
    DWORD dwResult;     // Wait return code value

    HANDLE hWait[] = { (HANDLE) m_RenderEvent };

    // Enter the modified message loop

    while (TRUE) {

        // We use this to wait for two different kinds of events, the first
        // are the normal windows messages, the other is an event that will
        // be signaled when a sample is ready

        dwResult = MsgWaitForMultipleObjects((DWORD) 1,     // Number events
                                             hWait,         // Event handle
                                             FALSE,         // Wait for either
                                             INFINITE,      // No timeout
                                             QS_ALLINPUT);  // All messages

        // Has a sample become ready to render
        if (dwResult == WAIT_OBJECT_0) {
            DrawWaveform();
        }

        // Process the thread's window message

        while (PeekMessage(&Message,NULL,(UINT) 0,(UINT) 0,PM_REMOVE)) {

            // Check for the WM_QUIT message

            if (Message.message == WM_QUIT) {
                return NOERROR;
            }

            // Send the message to the window procedure

            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
    }

} // MessageLoop


//
// WindowMessageLoop
//
// This creates a window and processes it's messages on a separate thread
//
DWORD __stdcall CScopeWindow::WindowMessageLoop(LPVOID lpvThreadParm)
{
    CScopeWindow *pScopeWindow;     // The owner renderer object

    // Cast the thread parameter to be our owner object
    pScopeWindow = (CScopeWindow *) lpvThreadParm;

    pScopeWindow->m_hwndDlg =
        CreateDialogParam(
            pScopeWindow->m_hInstance,	        // Handle of app instance
            MAKEINTRESOURCE (IDD_SCOPEDIALOG),	// Dialog box template
            NULL,	                        // Handle of owner window
            ScopeDlgProc,	                // Address of dialog procedure
            (LPARAM) pScopeWindow               // Initialization value
        );

    if (pScopeWindow->m_hwndDlg )
    {
        // Initialise the window, then signal the constructor that it can
        // continue and then unlock the object's critical section and
        // process messages

        if ( SUCCEEDED(pScopeWindow->InitialiseWindow(pScopeWindow->m_hwndDlg)) )
        {
            pScopeWindow->m_SyncWorker.Set();
            pScopeWindow->MessageLoop();
        }
    }

    ExitThread(TRUE);
    return TRUE;
} // WindowMessageLoop


//
// OnPaint
//
// WM_PAINT message
//
BOOL CScopeWindow::OnPaint()
{
    DrawWaveform();
    return TRUE;

} // OnPaint


//
// ClearWindow
//
// Clear the scope to black and draw the center tickmarks
//
void CScopeWindow::ClearWindow(HDC hdc)
{
    int y = m_Height / 2;

    SetMapMode (hdc, MM_TEXT);
    SetWindowOrgEx (hdc, 0, 0, NULL);
    SetViewportOrgEx (hdc, 0, 0, NULL);
	
    // Paint the entire window black
    PatBlt(hdc,            // Handle of device context
           (INT) 0,        // x-coord of upper-left corner
           (INT) 0,        // y-coord of upper-left corner
           m_Width,        // Width of rectangle to be filled
           m_Height,       // Height of rectangle to be filled
           BLACKNESS);     // Raster operation code

    // Draw the horizontal line
    HPEN hPenOld = (HPEN) SelectObject (hdc, m_hPenTicks);
    MoveToEx (hdc, 0, y, NULL);
    LineTo (hdc, m_Width, y);

    // Draw the tickmarks
    float inc = (float) m_Width / 10;
    int pos, j;
    int TickPoint;
    for (j = 0; j <= 10; j++) {
        if (j == 0 || j == 5 || j == 10)
            TickPoint =  m_Height / 15;
        else
            TickPoint = m_Height / 30;
        pos = (int) (j * inc);
        MoveToEx (hdc, pos, y + TickPoint, NULL);
        LineTo (hdc, pos, y - TickPoint);
    }
    SelectObject (hdc, hPenOld);

} // ClearWindow


//
// DrawPartialWaveform
//
// Draw a part of the VBIScope waveform - IndexStart and IndexEnd
// are pointers into the m_pPoints array (in LOGICAL COORDINATES)
// while ViewpointStart and ViewpointEnd are in SCREEN COORDINATES
//
void CScopeWindow::DrawPartialWaveform(HDC hdc,
                                       int IndexStart,
                                       int IndexEnd,
                                       int ViewportStart,
                                       int ViewportEnd)
{
    int nPoints = IndexEnd - IndexStart;
    int nViewportWidth = ViewportEnd - ViewportStart;
    HPEN OldPen;

    ASSERT (IndexStart + nPoints < m_nPoints);

    // Origin at lower left, x increases up, y increases to right
    SetMapMode (hdc, MM_ANISOTROPIC);

    // Draw the first trace
    if (m_TopF1 || m_TopF2) {
        SetWindowOrgEx (hdc, IndexStart, 0, NULL);
        SetWindowExtEx (hdc, nPoints, (int) m_MaxValue, NULL);
        SetViewportExtEx (hdc, nViewportWidth, -m_Height / 2, NULL);
        SetViewportOrgEx (hdc, ViewportStart, m_Height / 2, NULL);
        OldPen = (HPEN) SelectObject (hdc, m_hPen1);
        Polyline (hdc, m_pPoints1 + IndexStart, nPoints + 1);
        SelectObject (hdc, OldPen);
    }

    // Draw the second trace
    if (m_BottomF1 || m_BottomF2) {
        SetWindowOrgEx (hdc, IndexStart, 0, NULL);
        SetWindowExtEx (hdc, nPoints, (int) m_MaxValue, NULL);
        SetViewportExtEx (hdc, nViewportWidth, -m_Height / 2, NULL);
        SetViewportOrgEx (hdc, ViewportStart,  m_Height , NULL);
        OldPen = (HPEN) SelectObject (hdc, m_hPen2);
        Polyline (hdc, m_pPoints2 + IndexStart, nPoints + 1);
        SelectObject (hdc, OldPen);
    }

} // DrawPartialWaveform


//
// DrawWaveform
//
// Draw the full VBIScope waveform
//
void CScopeWindow::DrawWaveform(void)
{
    CAutoLock lock(m_pRenderer);
    TCHAR szT[40];

    if (m_pPoints1 == NULL)
        return;

    double  ActualLineStartTime = m_VBIIH.ActualLineStartTime / 100.0; // in microseconds.
    double  StartTime = m_TBScroll * m_DurationPerSample;
    double  StopTime = StartTime + Timebases [m_nTimebase].TBDuration;
    double  TotalLineTime = m_nPoints * m_DurationPerSample;
    int     PointsToDisplay;
    int     ActualPointsToDisplay;

    ActualPointsToDisplay = PointsToDisplay = (int) (m_nPoints *
        (Timebases [m_nTimebase].TBDuration / TotalLineTime));

    if (m_TBScroll + PointsToDisplay >= m_nPoints - 1) {
        ActualPointsToDisplay = m_nPoints - m_TBScroll - 1;
    }

    HDC hdc = GetWindowDC (m_hwnd);  // WindowDC has clipping region

    if ( hdc )
    {
        HDC hdcT = CreateCompatibleDC (hdc);

        if ( hdcT )
        {
            HBITMAP hBitmapOld = (HBITMAP) SelectObject (hdcT, m_hBitmap);

            ClearWindow (hdcT);

            DrawPartialWaveform(hdcT,
                m_TBScroll, m_TBScroll + ActualPointsToDisplay,// Index start, Index end
                0, (int) (m_Width * (float) ActualPointsToDisplay / PointsToDisplay));                // Window start, Window end

            SetMapMode (hdcT, MM_TEXT);
            SetWindowOrgEx (hdcT, 0, 0, NULL);
            SetViewportOrgEx (hdcT, 0, 0, NULL);

            BitBlt(hdc,	        // Handle of destination device context
                    0,	        // x-coordinate of upper-left corner
                    0, 	        // y-coordinate of upper-left corner
                    m_Width,	// Wwidth of destination rectangle
                    m_Height,	// Height of destination rectangle
                    hdcT,	    // Handle of source device context
                    0,          // x-coordinate of source rectangle
                    0,          // y-coordinate of source rectangle
                    SRCCOPY); 	// Raster operation code

            SelectObject (hdcT, hBitmapOld);
            DeleteDC (hdcT);
        }

        GdiFlush();
        ReleaseDC (m_hwnd, hdc);
    }

    // Frame count
    wsprintf (szT, TEXT("%ld"), m_CurrentFrame);
    SetDlgItemText (m_hwndDlg, IDC_FRAMES, szT);

    // Dropped
    wsprintf (szT, TEXT("%ld"), m_DroppedFrames);
    SetDlgItemText (m_hwndDlg, IDC_DROPPED, szT);

    // Show the start time of the display in microseconds
    _stprintf (szT, TEXT("%7.4lfus"), ActualLineStartTime + StartTime * 1e6);
    SetDlgItemText (m_hwndDlg, IDC_TS_START, szT);

    // And the stop time
    _stprintf (szT, TEXT("%7.4lfus"), ActualLineStartTime + StopTime * 1e6);
    SetDlgItemText (m_hwndDlg, IDC_TS_LAST, szT);
} // DrawWaveform


//
// AllocWaveBuffers
//
// Allocate two buffers for two video lines
// This is only called when the format changes
// Return TRUE if allocations succeed
//
BOOL CScopeWindow::AllocWaveBuffers()
{
    int j;

    if (m_pPoints1) delete [] m_pPoints1;
    if (m_pPoints2) delete [] m_pPoints2;

    m_pPoints1 = NULL;
    m_pPoints2 = NULL;
    m_nPoints = 0;

    m_nPoints = m_nSamplesPerLine = m_VBIIH.SamplesPerLine;

    if (m_pPoints1 = new POINT [m_nPoints]) {
        for (j = 0; j < m_nPoints; j++)
            m_pPoints1[j].x = j;
    }

    if (m_pPoints2 = new POINT [m_nPoints]) {
        for (j = 0; j < m_nPoints; j++)
            m_pPoints2[j].x = j;
    }

    // Return TRUE if allocations succeeded
    ASSERT ((m_pPoints1 != NULL) && (m_pPoints2 != NULL));
    return ((m_pPoints1 != NULL) && (m_pPoints2 != NULL));

} // AllocWaveBuffers



//
// CopyWaveform
//
// Copy the current MediaSample into a POINT array so we can use GDI
// to paint the waveform.
//
void CScopeWindow::CopyWaveform(IMediaSample *pMediaSample)
{
    BYTE                   *pWave;  // Pointer to VBI data
    ULONG                   nBytes;
    ULONG                   j;
    BYTE                   *pb;
    HRESULT                 hr;
    REFERENCE_TIME          tDummy;
    IMediaSample2          *Sample2;
    AM_SAMPLE2_PROPERTIES   SampleProperties;

    pMediaSample->GetPointer(&pWave);
    ASSERT(pWave != NULL);

    nBytes = pMediaSample->GetActualDataLength();
    ASSERT (nBytes == (m_VBIIH.EndLine - m_VBIIH.StartLine + 1) *
                       m_VBIIH.StrideInBytes);

    hr = pMediaSample->GetMediaTime (&m_CurrentFrame, &tDummy);
    m_DroppedFrames += (m_CurrentFrame - (m_LastFrame + 1));
    m_LastFrame = m_CurrentFrame;

    // All this to just get the field polarity flags...
    if (SUCCEEDED( pMediaSample->QueryInterface(
                    __uuidof(IMediaSample2),
                    reinterpret_cast<PVOID*>(&Sample2) ) )) {
        hr = Sample2->GetProperties(
                    sizeof( SampleProperties ),
                    reinterpret_cast<PBYTE> (&SampleProperties) );
        Sample2->Release();
        m_FrameFlags = SampleProperties.dwTypeSpecificFlags;
    }

    m_IsF1 = (m_FrameFlags & KS_VIDEO_FLAG_FIELD1);

    // Copy data for the top line
    if ((m_IsF1 && m_TopF1) || (!m_IsF1 && m_TopF2)) {
        pb = pWave + ((m_TopLine - m_VBIIH.StartLine) *
                m_VBIIH.StrideInBytes);
        for (j = 0; j < m_VBIIH.SamplesPerLine; j++) {
            m_pPoints1[j].y = (int)*pb++;
        }
    }

    // Copy data for the bottom line
    if ((m_IsF1 && m_BottomF1) || (!m_IsF1 && m_BottomF2)) {
        pb = pWave + ((m_BottomLine - m_VBIIH.StartLine) *
                m_VBIIH.StrideInBytes);
        for (j = 0; j < m_VBIIH.SamplesPerLine; j++) {
            m_pPoints2[j].y = (int)*pb++;
        }
    }
} // CopyWaveform


//
// Receive
//
// Called when the input pin receives another sample.
// Copy the waveform to our circular 1 second buffer
//
HRESULT CScopeWindow::Receive(IMediaSample *pSample)
{
    CAutoLock cAutoLock(this);
    ASSERT(pSample != NULL);

    // Has our UI been frozen

    if (m_fFreeze) {
        return NOERROR;
    }

    REFERENCE_TIME tStart, tStop;
    pSample->GetTime (&tStart,&tStop);
    m_StartSample = tStart;
    m_EndSample = tStop;

    // Ignore samples of the wrong size!!!
    if ((m_LastMediaSampleSize = pSample->GetActualDataLength()) != (int) m_VBIIH.BufferSize) {
        // ASSERT (FALSE);
        return NOERROR;
    }

    if (m_bStreaming == TRUE) {
        CopyWaveform (pSample);     // Copy data to our circular buffer
        SetEvent(m_RenderEvent);    // Set an event to display the
    }
    return NOERROR;

} // Receive


//
// DllRegisterServer
//
// Handles DLL registry
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbisurf\filter.cpp ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include <vbisurf.h>

#include <initguid.h>
DEFINE_GUID(IID_IDirectDraw7, 0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b);

AMOVIESETUP_MEDIATYPE sudInPinTypes =
{
    &MEDIATYPE_Video,     // Major type
    &MEDIASUBTYPE_VPVBI   // Minor type
};

AMOVIESETUP_MEDIATYPE sudOutPinTypes =
{
    &MEDIATYPE_NULL,      // Major type
    &MEDIASUBTYPE_NULL    // Minor type
};

AMOVIESETUP_PIN psudPins[] =
{
    {
        L"VBI Notify",          // Pin's string name
        FALSE,                  // Is it rendered
        FALSE,                  // Is it an output
        FALSE,                  // Allowed none
        FALSE,                  // Allowed many
        &CLSID_NULL,            // Connects to filter
        L"Output",              // Connects to pin
        1,                      // Number of types
        &sudInPinTypes          // Pin information
    },
    {
        L"Null",                // Pin's string name
        FALSE,                  // Is it rendered
        TRUE,                   // Is it an output
        FALSE,                  // Allowed none
        FALSE,                  // Allowed many
        &CLSID_NULL,            // Connects to filter
        L"",                    // Connects to pin
        1,                      // Number of types
        &sudOutPinTypes         // Pin information
    }
};

const AMOVIESETUP_FILTER sudVBISurfaces =
{
    &CLSID_VBISurfaces,       // Filter CLSID
    L"VBI Surface Allocator", // Filter name
    MERIT_NORMAL,             // Filter merit
    sizeof(psudPins) / sizeof(AMOVIESETUP_PIN), // Number pins
    psudPins                  // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance


CFactoryTemplate g_Templates[] =
{
    { L"VBI Surface Allocator", &CLSID_VBISurfaces, CVBISurfFilter::CreateInstance, NULL, &sudVBISurfaces },
    { L"VideoPort VBI Object", &CLSID_VPVBIObject, CAMVideoPort::CreateInstance, NULL, NULL }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//==========================================================================
// DllRegisterSever
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
} // DllRegisterServer


//==========================================================================
// DllUnregisterServer
HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
} // DllUnregisterServer


//==========================================================================
// CreateInstance
// This goes in the factory template table to create new filter instances
CUnknown *CVBISurfFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CVBISurfFilter *pFilter = new CVBISurfFilter(NAME("VBI Surface Allocator"), pUnk, phr);
    if (FAILED(*phr))
    {
        if (pFilter)
        {
            delete pFilter;
            pFilter = NULL;
        }
    }
    return pFilter;
} // CreateInstance


#pragma warning(disable:4355)


//==========================================================================
// Constructor
CVBISurfFilter::CVBISurfFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
    : CBaseFilter(pName, pUnk, &this->m_csFilter, CLSID_VBISurfaces, phr),
    m_pInput(NULL),
    m_pOutput(NULL),
    m_pDirectDraw(NULL)
{

    // load DirectDraw, create the primary surface
    HRESULT hr = InitDirectDraw();
    if (!FAILED(hr))
    {
        // create the pins
        hr = CreatePins();
        if (FAILED(hr))
            *phr = hr;
    }
    else
        *phr = hr;

    return;
}


//==========================================================================
CVBISurfFilter::~CVBISurfFilter()
{
    // release directdraw, surfaces, etc.
    ReleaseDirectDraw();

    // delete the pins
    DeletePins();
}


//==========================================================================
// Creates the pins for the filter. Override to use different pins
HRESULT CVBISurfFilter::CreatePins()
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::CreatePins")));

    // Allocate the input pin
    m_pInput = new CVBISurfInputPin(NAME("VBI Surface input pin"), this, &m_csFilter, &hr, L"VBI Notify");
    if (m_pInput == NULL || FAILED(hr))
    {
        if (SUCCEEDED(hr))
            hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 0, TEXT("Unable to create the input pin, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // set the pointer to DirectDraw on the input pin
    hr = m_pInput->SetDirectDraw(m_pDirectDraw);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pInput->SetDirectDraw failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Allocate the output pin
    m_pOutput = new CVBISurfOutputPin(NAME("VBI Surface output pin"), this, &m_csFilter, &hr, L"Null");
    if (m_pOutput == NULL || FAILED(hr))
    {
        if (SUCCEEDED(hr))
            hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 0, TEXT("Unable to create the output pin, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::CreatePins")));
    return hr;
}


//==========================================================================
// CVBISurfFilter::DeletePins
void CVBISurfFilter::DeletePins()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::DeletePins")));

    if (m_pInput)
    {
        delete m_pInput;
        m_pInput = NULL;
    }

    if (m_pOutput)
    {
        delete m_pOutput;
        m_pOutput = NULL;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::DeletePins")));
}


//==========================================================================
// NonDelegatingQueryInterface
STDMETHODIMP CVBISurfFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    //DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::NonDelegatingQueryInterface")));
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    if (riid == IID_IVPVBINotify)
    {
        DbgLog((LOG_TRACE, 0, TEXT("QI(IID_VPVBINotify) called on filter class!")));
        hr = m_pInput->NonDelegatingQueryInterface(riid, ppv);
    }
    else
    {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
    //DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::NonDelegatingQueryInterface")));
    return hr;
}


//==========================================================================
// return the number of pins we provide
int CVBISurfFilter::GetPinCount()
{
    //DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::GetPinCount")));
    //DbgLog((LOG_TRACE, 0, TEXT("PinCount = 2")));
    //DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::GetPinCount")));
    return 2;
}


//==========================================================================
// returns a non-addrefed CBasePin *
CBasePin* CVBISurfFilter::GetPin(int n)
{
    CBasePin *pRetPin;

    //DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::GetPin")));

    switch (n)
    {
    case 0:
        pRetPin = m_pInput;
        break;

    case 1:
        pRetPin = m_pOutput;
        break;

    default:
        DbgLog((LOG_TRACE, 5, TEXT("Bad Pin Requested, n = %d, No. of Pins = %d"), n, 2));
        pRetPin = NULL;
    }

    //DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::GetPin")));
    return pRetPin;
}


//==========================================================================
// the base classes inform the pins of every state transition except from
// run to pause. Overriding Pause to inform the input pins about that transition also
STDMETHODIMP CVBISurfFilter::Pause()
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::Pause")));

    CAutoLock l(&m_csFilter);

    if (m_State == State_Running)
    {
        if (m_pInput->IsConnected())
        {
            hr = m_pInput->RunToPause();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0, TEXT("m_pInput->RunToPause failed, hr = 0x%x"), hr));
            }
        }
        else
        {
            DbgLog((LOG_TRACE, 0, TEXT("CVBISurfFilter::Pause - not connected")));
        }
    }

    hr = CBaseFilter::Pause();

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::Pause")));
    return hr;
}


//==========================================================================
// gets events notifications from pins
HRESULT CVBISurfFilter::EventNotify(long lEventCode, long lEventParam1, long lEventParam2)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::EventNotify")));

    CAutoLock l(&m_csFilter);

    // call CBaseFilter::NotifyEvent
    NotifyEvent(lEventCode, lEventParam1, lEventParam2);

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::EventNotify")));
    return hr;
}

static BOOL WINAPI GetPrimaryCallbackEx(
  GUID FAR *lpGUID,
  LPSTR     lpDriverDescription,
  LPSTR     lpDriverName,
  LPVOID    lpContext,
  HMONITOR  hm
)
{
    GUID&  guid = *((GUID *)lpContext);
    if( !lpGUID ) {
        guid = GUID_NULL;
    } else {
        guid = *lpGUID;
    }
    return TRUE;
}

HRESULT
CreateDirectDrawObject(
    const GUID* pGUID,
    LPDIRECTDRAW7 *ppDirectDraw
    )
{
    UINT ErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    HRESULT hr = DirectDrawCreateEx( const_cast<GUID*>(pGUID), (LPVOID *)ppDirectDraw,
                                            IID_IDirectDraw7, NULL);
    SetErrorMode(ErrorMode);
    return hr;
}


//==========================================================================
// This function is used to allocate the direct-draw related resources.
// This includes allocating the the direct-draw service provider and the
// primary surface
HRESULT CVBISurfFilter::InitDirectDraw()
{
    HRESULT hr = NOERROR;
    HRESULT hrFailure = VFW_E_DDRAW_CAPS_NOT_SUITABLE;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfFilter::InitDirectDraw")));

    CAutoLock lock(&m_csFilter);

    // release the previous direct draw object if any
    ReleaseDirectDraw();

    // Ask the loader to create an instance
    GUID primary;
    hr = DirectDrawEnumerateExA(GetPrimaryCallbackEx,&primary,DDENUM_ATTACHEDSECONDARYDEVICES);
    if( FAILED(hr)) {
        ASSERT( !"Can't get primary" );
        goto CleanUp;
    }

    LPDIRECTDRAW7 pDirectDraw;
    hr = CreateDirectDrawObject( &primary, &pDirectDraw);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Function InitDirectDraw, CreateDirectDrawObject failed")));
        hr = hrFailure;
        goto CleanUp;
    }
    // Set the cooperation level on the surface to be shared
    hr = pDirectDraw->SetCooperativeLevel(NULL, DDSCL_NORMAL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Function InitDirectDraw, SetCooperativeLevel failed")));
        hr = hrFailure;
        goto CleanUp;
    }

    SetDirectDraw( pDirectDraw );

    // if we have reached this point, we should have a valid ddraw object
    ASSERT(m_pDirectDraw);

    // Initialise our capabilities structures
    DDCAPS DirectCaps;
    DDCAPS DirectSoftCaps;
    INITDDSTRUCT( DirectCaps );
    INITDDSTRUCT( DirectSoftCaps );

    // Load the hardware and emulation capabilities
    hr = m_pDirectDraw->GetCaps(&DirectCaps,&DirectSoftCaps);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Function InitDirectDraw, GetCaps failed")));
        hr = hrFailure;
        goto CleanUp;
    }

    // make sure the caps are ok
    if (!(DirectCaps.dwCaps2 & DDCAPS2_VIDEOPORT))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Device does not support a Video Port")));
        hr =  VFW_E_NO_VP_HARDWARE;
        goto CleanUp;
    }

CleanUp:

    // anything fails, might as well as release the whole thing
    if (FAILED(hr))
    {
        ReleaseDirectDraw();
    }
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfFilter::InitDirectDraw")));
    return hr;
}

//
//  Actually sets the variable & distributes it to the pins
//
HRESULT CVBISurfFilter::SetDirectDraw( LPDIRECTDRAW7 pDirectDraw )
{
    m_pDirectDraw = pDirectDraw;
    if( m_pInput ) {
        m_pInput->SetDirectDraw( m_pDirectDraw );
    }
    return S_OK;
}

// this function is used to release the resources allocated by the function
// "InitDirectDraw". these include the direct-draw service provider and the
// Source surfaces
void CVBISurfFilter::ReleaseDirectDraw()
{
    AMTRACE((TEXT("CVBISurfFilter::ReleaseDirectDraw")));

    CAutoLock lock(&m_csFilter);

    // Release any DirectDraw provider interface
    if (m_pDirectDraw)
    {
        m_pDirectDraw->Release();
        SetDirectDraw( NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbisurf\inpin.cpp ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include <vbisurf.h>


//==========================================================================
// constructor
CVBISurfInputPin::CVBISurfInputPin(TCHAR *pObjectName, CVBISurfFilter *pFilter, CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName) :
    CBaseInputPin(pObjectName, pFilter, pLock, phr, pPinName),
    m_pFilterLock(pLock),
    m_pFilter(pFilter),
    m_pIVPUnknown(NULL),
    m_pIVPObject(NULL),
    m_pIVPNotify(NULL),
    m_pDirectDraw(NULL)
{
    HRESULT hr = NOERROR;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::Constructor")));
    
    // create the VideoPort object
    hr = CoCreateInstance(CLSID_VPVBIObject, NULL, CLSCTX_INPROC_SERVER,
        IID_IUnknown, (void**)&m_pIVPUnknown);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CoCreateInstance(CLSID_VPVBIObject) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    hr = m_pIVPUnknown->QueryInterface(IID_IVPVBIObject, (void**)&m_pIVPObject);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPUnknown->QueryInterface(IID_IVPVBIObject) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    hr = m_pIVPUnknown->QueryInterface(IID_IVPVBINotify, (void**)&m_pIVPNotify);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPUnknown->QueryInterface(IID_IVPVBINotify) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

	hr = m_pIVPObject->SetObjectLock(m_pFilterLock);
	if (FAILED(hr))
	{
        DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->SetObjectLock() failed, hr = 0x%x"), hr));
        goto CleanUp;
	}

CleanUp:
    if (FAILED(hr))
        *phr = hr;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::Constructor")));
    return;
}


//==========================================================================
// destructor
CVBISurfInputPin::~CVBISurfInputPin(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::Destructor")));
    
    RELEASE(m_pIVPNotify);

    RELEASE(m_pIVPObject);
    
    // release the inner object
    RELEASE(m_pIVPUnknown);
    
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::Destructor")));
}


//==========================================================================
// overriden to expose IVPVBINotify, IKsPin, and IKsPropertySet
STDMETHODIMP CVBISurfInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;
    
    //DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::NonDelegatingQueryInterface")));
    
    if (riid == IID_IVPVBINotify)
    {
        hr = GetInterface((IVPVBINotify*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IVPVBINotify*) failed, hr = 0x%x"), hr));
        }
    }
    else if (riid == IID_IKsPin)
    {
        ASSERT(m_pIVPUnknown);
        hr = m_pIVPUnknown->QueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("m_pIVPUnknown->QueryInterface(IKsPin) failed, hr = 0x%x"), hr));
        }
    }
    else if (riid == IID_IKsPropertySet)
    {
        ASSERT(m_pIVPUnknown);
        hr = m_pIVPUnknown->QueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("m_pIVPUnknown->QueryInterface(IKsPropertySet) failed, hr = 0x%x"), hr));
        }
    }
    else 
    {
        // call the base class
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("CBaseInputPin::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
    } 
    
    //DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::NonDelegatingQueryInterface")));
    return hr;
}


//==========================================================================
// check that the mediatype is acceptable
HRESULT CVBISurfInputPin::CheckMediaType(const CMediaType* pmt)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::CheckMediaType")));

    HRESULT hr = NOERROR;
    
    // check if the videoport object likes it
    hr = m_pIVPObject->CheckMediaType(pmt);
    
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::CheckMediaType")));
    return hr;
}


//==========================================================================
HRESULT CVBISurfInputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::GetMediaType")));

    HRESULT hr = VFW_S_NO_MORE_ITEMS;

    hr = m_pIVPObject->GetMediaType(iPosition, pmt);

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::GetMediaType")));

    return hr;
}


//==========================================================================
// called after we have agreed a media type to actually set it
HRESULT CVBISurfInputPin::SetMediaType(const CMediaType* pmt)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::SetMediaType")));

    HRESULT hr = NOERROR;
    
    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // Set the base class media type (should always succeed)
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::SetMediaType")));
    return hr;
}


//==========================================================================
// CheckConnect
HRESULT CVBISurfInputPin::CheckConnect(IPin * pReceivePin)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::CheckConnect")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    hr = m_pIVPObject->CheckConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->CheckConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CheckConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::CheckConnect")));
    return hr;
}


//==========================================================================
// Complete Connect
HRESULT CVBISurfInputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::CompleteConnect")));

    HRESULT hr = NOERROR;
    CMediaType cMediaType;
    AM_MEDIA_TYPE *pNewMediaType = NULL, *pEnumeratedMediaType = NULL;
    
    // tell the videoport object 
    hr = m_pIVPObject->CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }


    // call the base class
    hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::CompleteConnect failed, hr = 0x%x"), hr));
        m_pIVPObject->BreakConnect();
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::CompleteConnect")));
    return hr;
}


//==========================================================================
HRESULT CVBISurfInputPin::BreakConnect(void)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::BreakConnect")));

    HRESULT hr = NOERROR;
    
    // tell the videoport object 
    ASSERT(m_pIVPObject);
    hr = m_pIVPObject->BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->BreakConnect failed, hr = 0x%x"), hr));
    }

    // call the base class
    hr = CBaseInputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::BreakConnect failed, hr = 0x%x"), hr));
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::BreakConnect")));
    return hr;
}


//==========================================================================
// transition from stop to pause state
HRESULT CVBISurfInputPin::Active(void)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::Active")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    hr = m_pIVPObject->Active();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->Active failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::Active();

    // if it is a VP connection, this error is ok
    if (hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::Active failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::Active")));
    return hr;
}


//==========================================================================
// transition from pause to stop state
HRESULT CVBISurfInputPin::Inactive(void)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::Inactive")));

    HRESULT hr = NOERROR;
    
    // tell the videoport object
    hr = m_pIVPObject->Inactive();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->Inactive failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::Inactive();

    // if it is a VP connection, this error is ok
    if (hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::Inactive failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::Inactive")));
    return hr;
}


//==========================================================================
// transition from pause to run state
HRESULT CVBISurfInputPin::Run(REFERENCE_TIME tStart)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::Run")));

    HRESULT hr = NOERROR;
    
    // tell the videoport object 
    hr = m_pIVPObject->Run(tStart);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->Run() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::Run(tStart);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::Run failed, hr = 0x%x"), hr));
        m_pIVPObject->RunToPause();
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::Run")));
    return hr;
}


//==========================================================================
// transition from run to pause state
HRESULT CVBISurfInputPin::RunToPause(void)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::RunToPause")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    hr = m_pIVPObject->RunToPause();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->RunToPause() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::RunToPause")));
    return hr;
}


//==========================================================================
// signals start of flushing on the input pin
HRESULT CVBISurfInputPin::BeginFlush(void)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::BeginFlush")));

    HRESULT hr = NOERROR;

    // call the base class
    hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::BeginFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::BeginFlush")));
    return hr;
}


//==========================================================================
// signals end of flushing on the input pin
HRESULT CVBISurfInputPin::EndFlush(void)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::EndFlush")));

    HRESULT hr = NOERROR;
    
    // call the base class
    hr = CBaseInputPin::EndFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::EndFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::EndFlush")));
    return hr;
}


//==========================================================================
// called when the upstream pin delivers us a sample
HRESULT CVBISurfInputPin::Receive(IMediaSample *pMediaSample)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::Receive")));

    HRESULT hr = NOERROR;
    
    hr = CBaseInputPin::Receive(pMediaSample);

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::Receive")));
    return hr;
}


//==========================================================================
// signals end of data stream on the input pin
STDMETHODIMP CVBISurfInputPin::EndOfStream(void)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::EndOfStream")));

    HRESULT hr = NOERROR;

    // Make sure we're streaming ok

    hr = CheckStreaming();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("CheckStreaming() failed, hr = 0x%x"), hr));
        return hr;
    }

    // call the base class
    hr = CBaseInputPin::EndOfStream();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::EndOfStream() failed, hr = 0x%x"), hr));
        return hr;
    } 

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::EndOfStream")));
    return hr;
}


//==========================================================================
// signals end of data stream on the input pin
HRESULT CVBISurfInputPin::EventNotify(long lEventCode, long lEventParam1, long lEventParam2)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::EventNotify")));

    HRESULT hr = NOERROR;
    
    m_pFilter->EventNotify(lEventCode, lEventParam1, lEventParam2);

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::EventNotify")));
    return hr;
}


//==========================================================================
// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVBISurfInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::GetAllocator")));

    HRESULT hr = NOERROR;

    if (!ppAllocator)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ppAllocator is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    *ppAllocator = NULL;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::GetAllocator")));
    return hr;
} // GetAllocator


//==========================================================================
// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVBISurfInputPin::NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::NotifyAllocator")));

    HRESULT hr = NOERROR;

    if (!pAllocator)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ppAllocator is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::NotifyAllocator")));
    return hr;
} // NotifyAllocator


//==========================================================================
// sets the pointer to directdraw
HRESULT CVBISurfInputPin::SetDirectDraw(LPDIRECTDRAW7 pDirectDraw)
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::SetDirectDraw")));

    HRESULT hr = NOERROR;

    // make sure the pointer is valid
    if (!pDirectDraw)
    {
        DbgLog((LOG_ERROR, 0, TEXT("pDirectDraw is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    
    m_pDirectDraw = pDirectDraw;

    // tell the videoport object 
    hr = m_pIVPObject->SetDirectDraw(pDirectDraw);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->SetDirectDraw failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::SetDirectDraw")));
    return hr;
}


//==========================================================================
// this function is used to redo the whole videoport connect process, while the graph
// maybe be running.
STDMETHODIMP CVBISurfInputPin::RenegotiateVPParameters()
{
    CAutoLock cLock(m_pFilterLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfInputPin::RenegotiateVPParameters")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    ASSERT(m_pIVPNotify);
    hr = m_pIVPNotify->RenegotiateVPParameters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPNotify->RenegotiateVPParameters() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    if (FAILED(hr) && m_pFilter->IsActive())
    {
        /* Raise a runtime error if we fail the media type */
        EventNotify(EC_COMPLETE, S_OK, 0);
        EventNotify(EC_ERRORABORT, hr, 0);
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfInputPin::RenegotiateVPParameters")));
    //return hr;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbisurf\outpin.cpp ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include <vbisurf.h>


//==========================================================================
// constructor
CVBISurfOutputPin::CVBISurfOutputPin( TCHAR *pObjectName,
    CVBISurfFilter *pFilter, CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName) :
    CBasePin(pObjectName, pFilter, pLock, phr, pPinName, PINDIR_OUTPUT)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfOutputPin::Constructor")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfOutputPin::Constructor")));
}


//==========================================================================
// destructor
CVBISurfOutputPin::~CVBISurfOutputPin()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfOutputPin::Destructor")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfOutputPin::Destructor")));
}


//==========================================================================
// BeginFlush should be called on input pins only
STDMETHODIMP CVBISurfOutputPin::BeginFlush(void)
{
    return E_UNEXPECTED;
}


//==========================================================================
// EndFlush should be called on input pins only
STDMETHODIMP CVBISurfOutputPin::EndFlush(void)
{
    return E_UNEXPECTED;
}


//==========================================================================
// check a given transform 
HRESULT CVBISurfOutputPin::CheckMediaType(const CMediaType* pmt)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfOutputPin::CheckMediaType")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfOutputPin::CheckMediaType")));

    /* This pin exists only to convince the vidsvr that this filter doesn't
     * represent a valid output device. We don't accept any mediatypes.
     */
    return S_FALSE;
}


//==========================================================================
// Propose nothing
HRESULT CVBISurfOutputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    HRESULT hr = VFW_S_NO_MORE_ITEMS;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfOutputPin::GetMediaType")));

    if (iPosition < 0) 
        hr = E_INVALIDARG;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfOutputPin::GetMediaType")));

    return hr;
}


//==========================================================================
// called after we have agreed a media type to actually set it
HRESULT CVBISurfOutputPin::SetMediaType(const CMediaType* pmt)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CVBISurfOutputPin::SetMediaType")));
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfOutputPin::SetMediaType")));

    /* This pin exists only to convince the vidsvr that this filter doesn't
     * represent a valid output device. We don't accept any mediatypes.
     */
    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbisurf\resource.h ===
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vbisurf.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbisurf\vbisurf.h ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef __VBISURF__
#define __VBISURF__

#include <streams.h>       
#include <ddraw.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <ks.h>
#include <ksproxy.h>

#include <tchar.h>

class CAMVideoPort;



//==========================================================================

class CSurfaceWatcher : public CAMThread
{
    enum Command {CMD_EXIT};

    // These are just to get rid of compiler warnings,  don't make them available
private:
    CSurfaceWatcher &operator=(const CSurfaceWatcher &);
    CSurfaceWatcher(const CSurfaceWatcher &);

public:
    CSurfaceWatcher();
    virtual ~CSurfaceWatcher();
    void Init(CAMVideoPort *pParent);

private:
    DWORD ThreadProc(void);
    HANDLE m_hEvent;
    CAMVideoPort *m_pParent;
};



//==========================================================================
DECLARE_INTERFACE_(IVPVBIObject, IUnknown)
{
    STDMETHOD (SetDirectDraw)(THIS_ LPDIRECTDRAW7 pDirectDraw) PURE;
    STDMETHOD (SetObjectLock)(THIS_ CCritSec *pMainObjLock) PURE;
    STDMETHOD (CheckMediaType)(THIS_ const CMediaType* pmt) PURE;
    STDMETHOD (GetMediaType)(THIS_ int iPosition, CMediaType *pMediaType) PURE;
    STDMETHOD (CheckConnect)(THIS_ IPin *pReceivePin) PURE;
    STDMETHOD (CompleteConnect)(THIS_ IPin *pReceivePin) PURE;
    STDMETHOD (BreakConnect)(THIS_) PURE;
    STDMETHOD (Active)(THIS_) PURE;
    STDMETHOD (Inactive)(THIS_) PURE;
    STDMETHOD (Run)(THIS_ REFERENCE_TIME tStart) PURE;
    STDMETHOD (RunToPause)(THIS_) PURE;
    STDMETHOD (GetVPDataInfo)(THIS_ AMVPDATAINFO *pAMVPDataInfo) PURE;
    STDMETHOD (CheckSurfaces)(THIS_) PURE;
};


//==========================================================================
class CAMVideoPort : public CUnknown, public IVPVBINotify, public IVPVBIObject, public IKsPropertySet, public IKsPin
{
    
public:
    static CUnknown* CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    CAMVideoPort(LPUNKNOWN pUnk, HRESULT *phr);
    ~CAMVideoPort();
    
    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IVPVBIObject Interface to the outside world

    STDMETHODIMP SetDirectDraw(LPDIRECTDRAW7 pDirectDraw);
    STDMETHODIMP SetObjectLock(CCritSec *pMainObjLock);
    STDMETHODIMP CheckMediaType(const CMediaType* pmt);
    STDMETHODIMP GetMediaType(int iPosition, CMediaType *pMediaType);
    STDMETHODIMP CheckConnect(IPin * pReceivePin);
    STDMETHODIMP CompleteConnect(IPin *pReceivePin);
    STDMETHODIMP BreakConnect();
    STDMETHODIMP Active();
    STDMETHODIMP Inactive();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP RunToPause();
    STDMETHODIMP GetVPDataInfo(AMVPDATAINFO *pAMVPDataInfo);
    STDMETHODIMP CheckSurfaces();

    // IVPVBINotify functions here
    STDMETHODIMP RenegotiateVPParameters();

    // IKsPropertySet implementation
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
        { return E_NOTIMPL; }
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport);

    // IKsPin implementation
    STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM *pMediumList);
    STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM *pInterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium)
        { return E_UNEXPECTED; }
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION *pCommunication, KSPIN_INTERFACE *pInterface, KSPIN_MEDIUM *pMedium);
    STDMETHODIMP KsPropagateAcquire()
        { return NOERROR; }
    STDMETHODIMP KsDeliver(IMediaSample *pSample, ULONG Flags)
        { return E_UNEXPECTED; }
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation)
        { return NULL; }
    STDMETHODIMP KsReceiveAllocator( IMemAllocator *pMemAllocator)
        { return E_UNEXPECTED; }
    STDMETHODIMP KsRenegotiateAllocator()
        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount()
        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount()
        { return E_UNEXPECTED; }
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta)
        { return E_UNEXPECTED; };
    STDMETHODIMP_(REFERENCE_TIME) KsGetStartTime()
        { return E_UNEXPECTED; };
    STDMETHODIMP KsMediaSamplesCompleted(PKSSTREAM_SEGMENT StreamSegment)
        { return E_UNEXPECTED; }


    // IKsPin stuff
protected:
    KSPIN_MEDIUM m_Medium;
    GUID m_CategoryGUID;
    KSPIN_COMMUNICATION m_Communication;

    // helper functions
    void SetKsMedium(const KSPIN_MEDIUM *pMedium) {m_Medium = *pMedium;};
    void SetKsCategory (const GUID *pCategory) {m_CategoryGUID = *pCategory;};

private:
    // called in CompleteConnect
    HRESULT NegotiateConnectionParameters();
    HRESULT GetDecoderVPDataInfo();

    // All these functions are called from within StartVideo
    HRESULT GetVideoPortCaps();
    static HRESULT CALLBACK EnumCallback (LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext);
    BOOL EqualPixelFormats(LPDDPIXELFORMAT lpFormat1, LPDDPIXELFORMAT lpFormat2);
    HRESULT GetBestFormat(DWORD dwNumInputFormats, LPDDPIXELFORMAT lpddInputFormats,
        LPDWORD lpdwBestEntry, LPDDPIXELFORMAT lpddBestOutputFormat);
    HRESULT CreateVideoPort();
    HRESULT CreateVPSurface(void);
    HRESULT SetDDrawKernelHandles();
    HRESULT NegotiatePixelFormat();
    HRESULT InitializeVideoPortInfo();

    // Other internal functions
    HRESULT SetupVideoPort();
    HRESULT TearDownVideoPort();
    HRESULT StartVideo();
    HRESULT StopVideo();

private:
    // Critical sections
    CCritSec                *m_pMainObjLock;                // Lock given by controlling object

    // ddraw stuff
    LPDIRECTDRAW7           m_pDirectDraw;                  // DirectDraw service provider

    // surface related stuff
    LPDIRECTDRAWSURFACE7    m_pOffscreenSurf;
    

    // enum to specify, whether the videoport is in a stopped or running state
    // or has been torn down because its surfaces were stolen by a full-screen DOS app
    // or a DirectX app.
    enum VP_STATE {VP_STATE_NO_VP, VP_STATE_STOPPED, VP_STATE_RUNNING};

    // variables to store current state etc
    VP_STATE                m_VPState;
    BOOL                    m_bConnected;
    BOOL                    m_bFilterRunning;
    BOOL                    m_bVPNegotiationFailed;
    CSurfaceWatcher         m_SurfaceWatcher;
    
    // vp data structures
    IVPVBIConfig            *m_pIVPConfig;
    DWORD                   m_dwVideoPortId;
    DWORD                   m_dwPixelsPerSecond;
    LPDDVIDEOPORTCONTAINER  m_pDDVPContainer;
    LPDIRECTDRAWVIDEOPORT   m_pVideoPort;
    DDVIDEOPORTINFO         m_svpInfo;
    DDVIDEOPORTCAPS         m_vpCaps;
    DDVIDEOPORTCONNECT      m_vpConnectInfo;

    // capture driver structures
    AMVPDATAINFO            m_capVPDataInfo;
    
    // All the pixel formats (Video)
    DDPIXELFORMAT           m_ddVPInputVideoFormat;
    DDPIXELFORMAT           m_ddVPOutputVideoFormat;

    BOOL    m_bHalfLineFix;
    // surface parameters
    DWORD m_dwSurfacePitch;
    DWORD m_dwSurfaceHeight;
    DWORD m_dwSurfaceOriginX;
    DWORD m_dwSurfaceOriginY;

};


extern const AMOVIESETUP_FILTER sudVBISurfaces;


class CVBISurfInputPin;
class CVBISurfOutputPin;


//==========================================================================
class CVBISurfFilter : public CBaseFilter
{
public:

    // the base classes do this, so have to do it
    friend class CVBISurfInputPin;
    // COM stuff
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    CVBISurfFilter(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *phr);
    ~CVBISurfFilter();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    
    // CBasePin methods
    int GetPinCount();
    CBasePin* GetPin(int n);
    STDMETHODIMP Pause();

    // CVBISurfOutputPin methods
    HRESULT EventNotify(long lEventCode, long lEventParam1, long lEventParam2);

private:
    // CVBISurfOutputPin methods

    // override this if you want to supply your own pins
    virtual HRESULT CreatePins();
    virtual void DeletePins();

    // ddraw related functions
    HRESULT InitDirectDraw();
    HRESULT SetDirectDraw(LPDIRECTDRAW7 pDirectDraw);
    void    ReleaseDirectDraw();

    CCritSec                m_csFilter;                     // filter wide lock
    CVBISurfInputPin        *m_pInput;                      // Array of input pin pointers
    CVBISurfOutputPin       *m_pOutput;                     // output pin

    // ddraw stuff
    LPDIRECTDRAW7           m_pDirectDraw;                  // DirectDraw service provider
};


//==========================================================================
class CVBISurfInputPin : public CBaseInputPin, public IVPVBINotify
{
public:
    CVBISurfInputPin(TCHAR *pObjectName, CVBISurfFilter *pFilter, CCritSec *pLock,
        HRESULT *phr, LPCWSTR pPinName);
    ~CVBISurfInputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    
    // connection related functions
    HRESULT CheckConnect(IPin * pReceivePin);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT SetMediaType(const CMediaType *pmt);

    // streaming functions
    HRESULT Active();
    HRESULT Inactive();
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT RunToPause();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample *pMediaSample);
    STDMETHODIMP EndOfStream(void);

    // allocator related functions
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly);

    // some helper fnctions
    CMediaType& CurrentMediaType() { return m_mt; }
    IPin *CurrentPeer() { return m_Connected; }
    HRESULT EventNotify(long lEventCode, long lEventParam1, long lEventParam2);

    // ddraw, overlay related functions
    HRESULT SetDirectDraw(LPDIRECTDRAW7 pDirectDraw);

    // IVPVBINotify functions
    STDMETHODIMP RenegotiateVPParameters();

private:
    CCritSec                *m_pFilterLock; // Critical section for interfaces
    CVBISurfFilter          *m_pFilter;

    // VideoPort related stuff
    LPUNKNOWN               m_pIVPUnknown;
    IVPVBIObject            *m_pIVPObject;
    IVPVBINotify            *m_pIVPNotify;

    // ddraw stuff
    LPDIRECTDRAW7           m_pDirectDraw;  // DirectDraw service provider
};


//==========================================================================
class CVBISurfOutputPin : public CBasePin
{
public:
    CVBISurfOutputPin
        ( TCHAR *pObjectName
        , CVBISurfFilter *pFilter
        , CCritSec *pLock
        , HRESULT *phr
        , LPCWSTR pPinName
        );
    ~CVBISurfOutputPin();

    // IUnknown support
    DECLARE_IUNKNOWN

    // IPin interface
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);

    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
};

template <typename T>
__inline void ZeroStruct(T& t)
{
    ZeroMemory(&t, sizeof(t));
}

template <typename T>
__inline void INITDDSTRUCT(T& dd)
{
    ZeroStruct(dd);
    dd.dwSize = sizeof(dd);
}

template<typename T>
__inline void RELEASE( T* &p )
{
    if( p ) {
        p->Release();
        p = NULL;
    }
}

#endif //__VBISURF__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbisurf\thread.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;

/* Satellite Receiver Filter
 */

#include "vbisurf.h"

CSurfaceWatcher::CSurfaceWatcher() : CAMThread()
{
    m_pParent = NULL;
    m_hEvent = INVALID_HANDLE_VALUE;
}


CSurfaceWatcher::~CSurfaceWatcher()
{
    // Tell the worker thread to exit, then wait for it to do so
    if (ThreadExists())
    {
        CallWorker(CMD_EXIT);
        Close();
    }
}


void CSurfaceWatcher::Init(CAMVideoPort *pParent)
{
    ASSERT(pParent != NULL);
    m_pParent = pParent;
    Create();   // Create the worker thread
}


DWORD CSurfaceWatcher::ThreadProc(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("CSurfaceWatcher::ThreadProc - started.")));

    // Use GetRequestHandle and WaitForSingleObject instead of GetRequest so we can
    // use the Timeout feature
    ASSERT(m_hEvent == INVALID_HANDLE_VALUE);
    m_hEvent = GetRequestHandle();
    ASSERT(m_hEvent != INVALID_HANDLE_VALUE);

    BOOL bDone = FALSE;
    while(!bDone)
    {
        DWORD dwWaitResult;
        DWORD dwRequest;

        //DbgLog((LOG_TRACE, 1, TEXT("CSurfaceWatcher::ThreadProc - waiting...")));
        dwWaitResult = WaitForSingleObject(m_hEvent, 2000L);

        // Check for a thread command, even if WaitResult indicates otherwise
        // (If we're exiting, what's the point in doing any work?)
        if (CheckRequest(&dwRequest))
        {
            // A CAMThread command needs to be processed
            switch(dwRequest)
            {
                case CMD_EXIT:
                    DbgLog((LOG_TRACE, 1, TEXT("CSurfaceWatcher::ThreadProc - CMD_EXIT!")));
                    Reply((DWORD)NOERROR);
                    bDone = TRUE;   // we're done
                    continue;       // exit while loop
                    break;

                default:
                    DbgLog((LOG_ERROR, 0, TEXT("CSurfaceWatcher::ThreadProc - bad request %u!"), dwRequest));
                    Reply((DWORD)E_NOTIMPL);
                    break;
            }
        }

        if (dwWaitResult == WAIT_TIMEOUT)
        {
            //DbgLog((LOG_TRACE, 1, TEXT("CSurfaceWatcher::ThreadProc - time to check")));
            ASSERT(m_pParent);
            m_pParent->CheckSurfaces();
        }
        else
            DbgLog((LOG_ERROR, 0, TEXT("CSurfaceWatcher::ThreadProc - unexpected WaitResult!")));
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vbisurf\vpobj.cpp ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------


#include <vbisurf.h>


// Temporary definitions while waiting DX5A integration
#ifndef DDVPCREATE_VBIONLY
#    define DDVPCREATE_VBIONLY 0x00000001l
#endif


HRESULT WINAPI SurfaceCounter(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext);
HRESULT WINAPI SurfaceKernelHandle(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext);


//==========================================================================
// CreateInstance
// This goes in the factory template table to create new VPObject instances
CUnknown *CAMVideoPort::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::CreateInstance")));

    *phr = NOERROR;

    CAMVideoPort *pVPObject = new CAMVideoPort(pUnk, phr);
    if (FAILED(*phr))
    {
        if (pVPObject)
        {
            delete pVPObject;
            pVPObject = NULL;
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::CreateInstance")));
    return pVPObject;
} // CreateInstance


//==========================================================================
// constructor
CAMVideoPort::CAMVideoPort(LPUNKNOWN pUnk, HRESULT *phr) :
        CUnknown(NAME("VP Object"), pUnk),
        m_pDDVPContainer(NULL),
        m_pOffscreenSurf(NULL),
        m_bConnected(FALSE),
        m_pIVPConfig(NULL),
        m_VPState(VP_STATE_NO_VP),
        m_bFilterRunning(FALSE),
        m_bVPNegotiationFailed(FALSE),
        m_Communication(KSPIN_COMMUNICATION_SOURCE),
        m_CategoryGUID(GUID_NULL),
        m_pDirectDraw(NULL),
        m_dwPixelsPerSecond(0),
        m_dwVideoPortId(0),
        m_pVideoPort(NULL)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::Constructor")));

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;   

    memset(&m_capVPDataInfo, 0, sizeof(AMVPDATAINFO));
    memset(&m_svpInfo, 0, sizeof(DDVIDEOPORTINFO));
    memset(&m_vpCaps, 0, sizeof(DDVIDEOPORTCAPS));
    memset(&m_vpConnectInfo, 0, sizeof(DDVIDEOPORTCONNECT));

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::Constructor")));
    return;
}


//==========================================================================
// destructor
CAMVideoPort::~CAMVideoPort()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::Destructor")));

    if (m_bConnected)
    {
        DbgLog((LOG_ERROR, 0, TEXT("Destructor called without calling breakconnect")));
        BreakConnect();
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::Destructor")));
    return;
}


//==========================================================================
// overridden to expose IVPVBINotify and IVPVBIObject
STDMETHODIMP CAMVideoPort::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;
    
    if (riid == IID_IVPVBINotify) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CAMVideoPort::NonDelegatingQueryInterface(IID_IVPVBINotify)")));
        hr = GetInterface((IVPVBINotify*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetInterface(IVPVBINotify*) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    } 
    else if (riid == IID_IVPVBIObject) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CAMVideoPort::NonDelegatingQueryInterface(IID_IVPVBIObject)")));
        hr = GetInterface((IVPVBIObject*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetInterface(IVPVBIObject*) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    } 
    else if (riid == IID_IKsPin) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CAMVideoPort::NonDelegatingQueryInterface(IID_IKsPin)")));
        hr = GetInterface((IKsPin*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetInterface(IKsPin*) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    } 
    else if (riid == IID_IKsPropertySet) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CAMVideoPort::NonDelegatingQueryInterface(IID_IKsPropertySet)")));
        hr = GetInterface((IKsPropertySet*)this, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetInterface(IKsPropertySet*) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    else 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CAMVideoPort::NonDelegatingQueryInterface(Other)")));
        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("CUnknown::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::NonDelegatingQueryInterface")));
    return hr;
}


//==========================================================================
// sets the pointer to directdraw
STDMETHODIMP CAMVideoPort::SetDirectDraw(LPDIRECTDRAW7 pDirectDraw)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::SetDirectDraw")));

    HRESULT hr = NOERROR;

    if (!pDirectDraw)
    {
        DbgLog((LOG_ERROR, 0, TEXT("pDirectDraw is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    
    m_pDirectDraw = pDirectDraw;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::SetDirectDraw")));
    return hr;
}


//==========================================================================
// sets the pointer to the lock, which would be used to synchronize calls to the object
STDMETHODIMP CAMVideoPort::SetObjectLock(CCritSec *pMainObjLock)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::SetObjectLock")));
    HRESULT hr = NOERROR;

    if (!pMainObjLock)
    {
        DbgLog((LOG_ERROR, 0, TEXT("pMainObjLock is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    
    m_pMainObjLock = pMainObjLock;

    // Must wait until m_pMainObjLock is set before starting thread in
    // m_SurfaceWatcher so it can't call before there's a lock to use.
    m_SurfaceWatcher.Init(this);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::SetObjectLock")));
    return hr;
}


//==========================================================================
// check that the mediatype is acceptable
STDMETHODIMP CAMVideoPort::CheckMediaType(const CMediaType* pmt)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::CheckMediaType")));

    HRESULT hr = NOERROR;
    
    if  ((pmt->majortype != MEDIATYPE_Video) || (pmt->subtype != MEDIASUBTYPE_VPVBI))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::CheckMediaType")));
    return hr;
}


//==========================================================================
HRESULT CAMVideoPort::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::GetMediaType")));

    HRESULT hr = S_OK;

    if (iPosition == 0)
    {
        pmt->SetType(&MEDIATYPE_Video);
        pmt->SetSubtype(&MEDIASUBTYPE_VPVBI);
        pmt->SetFormatType(&FORMAT_None);
        pmt->SetSampleSize(1);
        pmt->SetTemporalCompression(FALSE);
    }
    else if (iPosition > 0) 
        hr = VFW_S_NO_MORE_ITEMS;
    else
        hr = E_INVALIDARG;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CVBISurfOutputPin::GetMediaType")));

    return hr;
}


//==========================================================================
// 
STDMETHODIMP CAMVideoPort::CheckConnect(IPin * pReceivePin)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::CheckConnect")));

    HRESULT hr = NOERROR;
    PKSMULTIPLE_ITEM pMediumList = NULL;
    IKsPin *pIKsPin = NULL;
    PKSPIN_MEDIUM pMedium = NULL;

    hr = pReceivePin->QueryInterface(IID_IKsPin, (void **)&pIKsPin);
    if (FAILED(hr))
        goto CleanUp;

    ASSERT(pIKsPin);
    hr = pIKsPin->KsQueryMediums(&pMediumList);
    if (FAILED(hr))
        goto CleanUp;

    ASSERT(pMediumList);
    pMedium = (KSPIN_MEDIUM *)(pMediumList+1);
    SetKsMedium((const KSPIN_MEDIUM *)pMedium);

CleanUp:
    RELEASE(pIKsPin);

    if (pMediumList)
    {
        CoTaskMemFree((void*)pMediumList);
        pMediumList = NULL;
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::CheckConnect")));
    return hr;
}


//==========================================================================
// supposed to be called when the host connects with the decoder
STDMETHODIMP CAMVideoPort::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::CompleteConnect")));
    ASSERT(!m_bConnected);

    HRESULT hr = NOERROR;

    // re-initialize variables
    m_dwPixelsPerSecond = 0;
    memset(&m_vpConnectInfo, 0, sizeof(DDVIDEOPORTCONNECT));
    memset(&m_capVPDataInfo, 0, sizeof(AMVPDATAINFO));

    if (!m_pDirectDraw)
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pDirectDraw is NULL")));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }
    
    ASSERT(m_pIVPConfig == NULL);
    hr = pReceivePin->QueryInterface(IID_IVPVBIConfig, (void **)&m_pIVPConfig);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,  TEXT("QueryInterface(IID_IVPVBIConfig) failed, hr = 0x%x"), hr));
        hr = VFW_E_NO_TRANSPORT;
        goto CleanUp;
    }
    ASSERT(m_pIVPConfig);

    // memset all of them to zero
    memset(&m_ddVPInputVideoFormat, 0, sizeof(m_ddVPInputVideoFormat));
    memset(&m_ddVPOutputVideoFormat, 0, sizeof(m_ddVPOutputVideoFormat));
    
    // create the VP container
    ASSERT(m_pDDVPContainer == NULL);
    hr = m_pDirectDraw->QueryInterface( IID_IDDVideoPortContainer, (LPVOID *)&m_pDDVPContainer);
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR,0,  TEXT("m_pDirectDraw->QueryInterface(IID_IDDVideoPortContainer) failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

    // negotiate the connection parameters
    // get/set connection info happens here
    hr = NegotiateConnectionParameters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("NegotiateConnectionParameters failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }
    
    // get the decoder data parameters
    hr = GetDecoderVPDataInfo();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetDecoderVPDataInfo failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

    hr = SetupVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("SetupVideoPort failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

    // Success!
    m_bConnected = TRUE;
    
CleanUp:
    if (FAILED(hr))
        BreakConnect();

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::CompleteConnect, hr = 0x%x"), hr));
    return hr;
}


//==========================================================================
STDMETHODIMP CAMVideoPort::BreakConnect()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::BreakConnect")));

    HRESULT hr = NOERROR;
    
    if (m_VPState == VP_STATE_RUNNING)
    {
        DbgLog((LOG_ERROR, 0, TEXT("BreakConnect called while videoport running")));
        StopVideo();
    }

    if (m_VPState == VP_STATE_STOPPED)
    {
        hr = TearDownVideoPort();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("TearDownVideoPort failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    // release the videoport container
    RELEASE(m_pDDVPContainer);
    
    // release the IVPConfig interface
    RELEASE(m_pIVPConfig);

    m_bConnected = FALSE;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::BreakConnect, hr = 0x%x"), hr));
    return hr;
}       


//==========================================================================
// transition from Stop to Pause.
// We do not need to to anything
STDMETHODIMP CAMVideoPort::Active()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::Active")));
    ASSERT(m_VPState != VP_STATE_RUNNING);

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::Active - not connected")));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::Active, hr = 0x%x"), hr));
    return hr;
}


//==========================================================================
// transition (from Pause or Run) to Stop
STDMETHODIMP CAMVideoPort::Inactive()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::Inactive")));

    HRESULT hr = NOERROR;
    
    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::Inactive - not connected")));
        goto CleanUp;
    }
    
    // Inactive is also called when going from pause to stop, in which case the 
    // VideoPort would have already been stopped in the function RunToPause.
    // Also, we may have been temporarily disconnected from the videoport by
    // a full screen DOS box or a DirectX game, in which case m_VPState would be
    // VP_STATE_RETRYING
    if (m_VPState == VP_STATE_RUNNING)
    {
        // stop the VideoPort
        hr = StopVideo();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR, 0, TEXT("StopVideo failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

CleanUp:
    m_bFilterRunning = FALSE;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::Inactive, hr = 0x%x"), hr));
    return hr;
}


//==========================================================================
// transition from Pause to Run. We just start the VideoPort.
STDMETHODIMP CAMVideoPort::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::Run")));
    UNREFERENCED_PARAMETER(tStart);
    ASSERT(m_bConnected);
    ASSERT(!m_bFilterRunning);
    ASSERT(m_VPState != VP_STATE_RUNNING);

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::Run - not connected")));
        goto CleanUp;
    }

    if (m_VPState == VP_STATE_NO_VP)
    {
        hr = SetupVideoPort();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::Run - SetupVideoPort failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    hr = StartVideo();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("StartVideo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    m_bFilterRunning = TRUE;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::Run, hr = 0x%x"), hr));
    return hr;
}


//==========================================================================
// transition from Run to Pause. We just stop the VideoPort
// Note that transition from Run to Stop is caught by Inactive
STDMETHODIMP CAMVideoPort::RunToPause()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::RunToPause")));
    ASSERT(m_bConnected);
    ASSERT(m_bFilterRunning);

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::RunToPause - not connected")));
        goto CleanUp;
    }

    // We may have been temporarily disconnected from the videoport by
    // a full screen DOS box or a DirectX game, in which case m_VPState would be
    // VP_STATE_RETRYING
    if (m_VPState == VP_STATE_RUNNING)
    {
        // stop the VideoPort
        hr = StopVideo();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR, 0, TEXT("StopVideo failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    m_bFilterRunning = FALSE;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::RunToPause")));
    return hr;
}


//==========================================================================
STDMETHODIMP CAMVideoPort::GetVPDataInfo(AMVPDATAINFO *pAMVPDataInfo)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::GetVPDataInfo")));

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::GetVPDataInfo - not connected")));
        goto CleanUp;
    }

    if (!pAMVPDataInfo)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR, 2, TEXT("pAMVPDataInfo is NULL")));
        goto CleanUp;
    }
    
    *pAMVPDataInfo = m_capVPDataInfo;
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::GetVPDataInfo")));
    return hr;
}


//==========================================================================
// this function is used to redo the whole videoport connect process, while the graph
// maybe be running.
STDMETHODIMP CAMVideoPort::RenegotiateVPParameters()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 1, TEXT("Entering CAMVideoPort::RenegotiateVPParameters")));

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::RenegotiateVPParameters - not connected")));
        goto CleanUp;
    }

    if (m_VPState == VP_STATE_RUNNING)
        StopVideo();

    if (m_VPState == VP_STATE_STOPPED)
        TearDownVideoPort();

    hr = SetupVideoPort();   // always want_vp_setup (if connected)
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR,0, TEXT("SetupVideoPort failed in RenegotiateVPParameters, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (m_bFilterRunning)
    {
        hr = StartVideo();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR,0, TEXT("StartVideo failed in RenegotiateVPParameters, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    m_bVPNegotiationFailed = FALSE;

CleanUp:
    if (FAILED(hr) && hr != VFW_E_NOT_CONNECTED)
    {
        hr = VFW_E_VP_NEGOTIATION_FAILED;

        if (m_VPState == VP_STATE_RUNNING)
        {
            StopVideo();
        }

        if (m_VPState == VP_STATE_STOPPED)
        {
            TearDownVideoPort();
        }

        m_bVPNegotiationFailed = TRUE;
    }

    DbgLog((LOG_TRACE, 1, TEXT("Leaving CAMVideoPort::RenegotiateVPParameters, hr = 0x%x"), hr));

    return hr;
}


//==========================================================================
// IKsPin::Get implementation
STDMETHODIMP CAMVideoPort::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
	DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::Get")));

    if (guidPropSet != KSPROPSETID_Pin)
    {
        hr = E_PROP_SET_UNSUPPORTED;
        goto CleanUp;
    }

    if ((pPropData == NULL) && (pcbReturned == NULL))
    {
        hr = E_POINTER;
        goto CleanUp;
    }

    if (dwPropID == KSPROPERTY_PIN_CATEGORY)
    {
        if (pcbReturned)
            *pcbReturned = sizeof(GUID);
        if (pPropData != NULL)
        {
            if (cbPropData < sizeof(GUID))
            {
                hr = E_UNEXPECTED;
                goto CleanUp;
            }
            *(GUID *)pPropData = m_CategoryGUID;
        }
    }
    else if (dwPropID == KSPROPERTY_PIN_MEDIUMS)
    {
        if (pcbReturned)
            *pcbReturned = sizeof (KSPIN_MEDIUM);
        if (pPropData != NULL)
        {
            if (cbPropData < sizeof(KSPIN_MEDIUM))
            {
                hr = E_UNEXPECTED;
                goto CleanUp;
            }
            *(KSPIN_MEDIUM *)pPropData = m_Medium;
        }
    }
    else
        hr = E_PROP_ID_UNSUPPORTED;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::Get")));
    return hr;
}


//==========================================================================
//
STDMETHODIMP CAMVideoPort::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::QuerySupported")));

    if (guidPropSet != KSPROPSETID_Pin)
    {
        hr = E_PROP_SET_UNSUPPORTED;
        goto CleanUp;
    }

    if ((dwPropID != KSPROPERTY_PIN_CATEGORY) && (dwPropID != KSPROPERTY_PIN_MEDIUMS))
    {
        hr = E_PROP_ID_UNSUPPORTED;
        goto CleanUp;
    }

    if (pTypeSupport)
        *pTypeSupport = KSPROPERTY_SUPPORT_GET;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::QuerySupported")));
    return hr;
}


//==========================================================================
//
STDMETHODIMP CAMVideoPort::KsQueryMediums(PKSMULTIPLE_ITEM* pMediumList)
{
    // The following special return code notifies the proxy that this pin is
    // not available as a kernel mode connection
    HRESULT hr = S_FALSE;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::KsQueryMediums")));
    *pMediumList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pMediumList)));
    if (!*pMediumList) 
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    (*pMediumList)->Count = 0;
    (*pMediumList)->Size = sizeof(**pMediumList);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::KsQueryMediums")));
    return hr;
}


//==========================================================================
//
STDMETHODIMP CAMVideoPort::KsQueryInterfaces(PKSMULTIPLE_ITEM* pInterfaceList)
{
    PKSPIN_INTERFACE pInterface;
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::KsQueryInterfaces")));

    *pInterfaceList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pInterfaceList) + sizeof(*pInterface)));
    if (!*pInterfaceList) 
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    (*pInterfaceList)->Count = 1;
    (*pInterfaceList)->Size = sizeof(**pInterfaceList) + sizeof(*pInterface);
    pInterface = reinterpret_cast<PKSPIN_INTERFACE>(*pInterfaceList + 1);
    pInterface->Set = KSINTERFACESETID_Standard;
    pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
    pInterface->Flags = 0;

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::KsQueryInterfaces")));
    return hr;
}

//==========================================================================
//
STDMETHODIMP CAMVideoPort::KsGetCurrentCommunication(KSPIN_COMMUNICATION* pCommunication, 
    KSPIN_INTERFACE* pInterface, KSPIN_MEDIUM* pMedium)
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::KsGetCurrentCommunication")));

    if (pCommunication != NULL) 
        *pCommunication = m_Communication; 

    if (pInterface != NULL) 
    {
        pInterface->Set = KSINTERFACESETID_Standard;
        pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
        pInterface->Flags = 0;
    }

    if (pMedium != NULL) 
        *pMedium = m_Medium;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::KsGetCurrentCommunication")));
    return NOERROR;
}


//==========================================================================
// Called every second or two by the thread in CSurfaceWatcher m_SurfaceWatcher,
// this function checks if we have lost our DDraw surface to a full-screen DOS box
// or a DirectX game. If we have (on this call or a previous one), attempt to get it back.
HRESULT CAMVideoPort::CheckSurfaces()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    //DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::CheckSurfaces")));

    HRESULT hr = NOERROR;

    if (!m_bConnected || m_bVPNegotiationFailed)
    {
        //DbgLog((LOG_TRACE, 2, TEXT("CAMVideoPort::CheckSurfaces - not connected")));
        goto CleanUp;
    }

    // First, see if we think we have surfaces but have really lost them.
    if (m_VPState != VP_STATE_NO_VP)
    {
        //DbgLog((LOG_TRACE, 1, TEXT("CAMVideoPort::CheckSurfaces - checking surfaces")));
        if (m_pOffscreenSurf)
        {
            if (m_pOffscreenSurf->IsLost() == DDERR_SURFACELOST)
            {
                DbgLog((LOG_TRACE, 1, TEXT("CAMVideoPort::CheckSurfaces - Surface Lost!")));
                if (m_VPState == VP_STATE_RUNNING)
                {
                    hr = StopVideo();
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::CheckSurfaces - StopVideo failed (1), hr = 0x%x"), hr));
                        goto CleanUp;
                    }
                }
                TearDownVideoPort();
            }
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::CheckSurfaces - no surface!")));
            if (m_VPState == VP_STATE_RUNNING)
            {
                hr = StopVideo();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::CheckSurfaces - StopVideo failed (2), hr = 0x%x"), hr));
                    goto CleanUp;
                }
            }
            TearDownVideoPort();
        }
    }

    // Next, check if our state is what we need. May have been changed above, or on a previous
    // call, or on a call to RenegotiateVPParameters.
    if (m_VPState == VP_STATE_NO_VP)
    {
        DbgLog((LOG_TRACE, 1, TEXT("CAMVideoPort::CheckSurfaces - trying to re-setup videoport")));
        hr = SetupVideoPort();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::CheckSurfaces - SetupVideoPort failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    if ((m_VPState == VP_STATE_STOPPED) && m_bFilterRunning)
    {
        hr = StartVideo();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::CheckSurfaces - StartVideo failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    m_bVPNegotiationFailed = FALSE;

CleanUp:
    if (FAILED(hr))
    {
        if (m_VPState == VP_STATE_RUNNING)
        {
            StopVideo();
        }

        if (m_VPState == VP_STATE_STOPPED)
        {
            TearDownVideoPort();
        }

        m_bVPNegotiationFailed = TRUE;
    }

    //DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::CheckSurfaces")));
    return NOERROR;
}


//==========================================================================
// this functions negotiates the connection parameters with
// the decoder. 
// Since this function might be called during renegotiation, the
// existing connection parameters are passed in as input and if 
// possible, we try to use the same parameters.
HRESULT CAMVideoPort::GetVideoPortCaps()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::GetVideoPortCaps")));
    HRESULT hr = NOERROR;

    // vpCaps is scratch memory, results stored in this->m_vpCaps
    memset(&m_vpCaps, 0, sizeof(DDVIDEOPORTCAPS));
    DDVIDEOPORTCAPS vpCaps;
    INITDDSTRUCT( vpCaps );
    vpCaps.dwVideoPortID = 0;
    hr = m_pDDVPContainer->EnumVideoPorts(0, &vpCaps, this, CAMVideoPort::EnumCallback);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,  TEXT("m_pDDVPContainer->EnumVideoPorts failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::GetVideoPortCaps, hr = 0x%x"), hr));
    return hr;
}

    
//==========================================================================
// This is a callback for the EnumVideoPorts method and saves the capabilites
// the video port.
HRESULT CALLBACK CAMVideoPort::EnumCallback (LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext )
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::EnumCallback")));

    CAMVideoPort* pAMVideoPort = NULL;
    if (lpContext)
    {
        pAMVideoPort = (CAMVideoPort*)lpContext;
    }
    else
    {
        DbgLog((LOG_ERROR,0,TEXT("lpContext = NULL, THIS SHOULD NOT BE HAPPENING!!!")));
        hr = E_FAIL;
        goto CleanUp;
    }
    
    if (lpCaps && pAMVideoPort)
    {
        memcpy( &(pAMVideoPort->m_vpCaps), lpCaps, sizeof(DDVIDEOPORTCAPS));
        DbgLog((LOG_TRACE, 3, TEXT("VIDEOPORTCAPS: NumAutoFlip=%d, NumVBIAutoFlip=%d"),
            lpCaps->dwNumAutoFlipSurfaces, lpCaps->dwNumVBIAutoFlipSurfaces));
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::EnumCallback")));
    return hr;
}


//==========================================================================
// This functions negotiates the connection parameters with the decoder. 
HRESULT CAMVideoPort::NegotiateConnectionParameters()
{
    HRESULT hr = NOERROR;
    
    LPDDVIDEOPORTCONNECT lpddCaptureConnect = NULL;
    DWORD dwNumCaptureEntries = 0;
    LPDDVIDEOPORTCONNECT lpddVideoPortConnect = NULL;
    DWORD dwNumVideoPortEntries = 0;
    BOOL bIntersectionFound = FALSE;
    DWORD i, j;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::NegotiateConnectionParameters")));

    ASSERT(m_pIVPConfig);
    ASSERT(m_pDDVPContainer);

    // find the number of entries to be proposed by the decoder
    hr = m_pIVPConfig->GetConnectInfo(&dwNumCaptureEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumCaptureEntries);
    
    // allocate the necessary memory
    lpddCaptureConnect = (LPDDVIDEOPORTCONNECT) new BYTE [dwNumCaptureEntries*sizeof(DDVIDEOPORTCONNECT)];
    if (lpddCaptureConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiateConnectionParameters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    // memset the allocated memory to zero
    memset(lpddCaptureConnect, 0, dwNumCaptureEntries*sizeof(DDVIDEOPORTCONNECT));
    
    // set the right size in each of the structs.
    for (i = 0; i < dwNumCaptureEntries; i++)
    {
        lpddCaptureConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }
    
    // get the entries proposed by the decoder
    hr = m_pIVPConfig->GetConnectInfo(&dwNumCaptureEntries, lpddCaptureConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // find the number of entries supported by the videoport
    hr = m_pDDVPContainer->GetVideoPortConnectInfo(m_dwVideoPortId, &dwNumVideoPortEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pDDVPContainer->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumVideoPortEntries);

    // allocate the necessary memory
    lpddVideoPortConnect = (LPDDVIDEOPORTCONNECT) new BYTE[dwNumVideoPortEntries*sizeof(DDVIDEOPORTCONNECT)];
    if (lpddVideoPortConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiateConnectionParameters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    memset(lpddVideoPortConnect, 0, dwNumVideoPortEntries*sizeof(DDVIDEOPORTCONNECT));

    // set the right size in each of the structs.
    for (i = 0; i < dwNumVideoPortEntries; i++)
    {
        lpddVideoPortConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries supported by the videoport
    hr = m_pDDVPContainer->GetVideoPortConnectInfo(0, &dwNumVideoPortEntries, lpddVideoPortConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pDDVPContainer->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }

#ifdef DEBUG
        for (i = 0; i < dwNumCaptureEntries; i++)
            DbgLog((LOG_TRACE, 3, TEXT("lpddCaptureConnect[%d].dwFlags = 0x%x"), i, lpddCaptureConnect[i].dwFlags));
        for (j = 0; j < dwNumVideoPortEntries; j++)
            DbgLog((LOG_TRACE,3,TEXT("lpddVideoPortConnect[%d].dwFlags = 0x%x"), j, lpddVideoPortConnect[j].dwFlags));
#endif
        
        // take the first element of the intersection of the two lists and
        // set that value on the decoder
        for (i = 0; i < dwNumCaptureEntries && !bIntersectionFound; i++)
        {
            for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
            {
                if (lpddCaptureConnect[i].dwPortWidth == lpddVideoPortConnect[j].dwPortWidth &&
                    IsEqualIID(lpddCaptureConnect[i].guidTypeID, lpddVideoPortConnect[j].guidTypeID))
                {
                    // make sure we save the right one (the one from the video port, not the one
                    // from the capture driver)
                    memcpy(&m_vpConnectInfo, (lpddVideoPortConnect+j), sizeof(DDVIDEOPORTCONNECT));
                    hr = m_pIVPConfig->SetConnectInfo(i);
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->SetConnectInfo failed, hr = 0x%x"), hr));
                        goto CleanUp;
                    }

                    bIntersectionFound = TRUE;
                }
            }
        }

    if (!bIntersectionFound)
    {
        hr = E_FAIL;

        goto CleanUp;
    }
    
    // cleanup
CleanUp:
    delete [] lpddCaptureConnect;
    delete [] lpddVideoPortConnect;
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::NegotiateConnectionParameters")));
    return hr;
}


//==========================================================================
// This functions gets various data parameters from the decoder
// parameters include dimensions, double-clock, vact etc.
// Also maximum pixel rate the decoder will output.
// This happens after the connnection parameters have been set-up
HRESULT CAMVideoPort::GetDecoderVPDataInfo()
{
    HRESULT hr = NOERROR;
    DWORD dwMaxPixelsPerSecond = 0;
    AMVPSIZE amvpSize;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::GetDecoderVPDataInfo")));

    // set the size of the struct
    m_capVPDataInfo.dwSize = sizeof(AMVPDATAINFO);
    
    // get the VideoPort data information
    hr = m_pIVPConfig->GetVPDataInfo(&m_capVPDataInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetVPDataInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    amvpSize.dwWidth = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;
    amvpSize.dwHeight = m_capVPDataInfo.amvpDimInfo.dwVBIHeight;
    
    // get the maximum pixel rate the decoder will output
    hr = m_pIVPConfig->GetMaxPixelRate(&amvpSize, &dwMaxPixelsPerSecond);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetMaxPixelRate failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_dwPixelsPerSecond = dwMaxPixelsPerSecond;
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::GetDecoderVPDataInfo")));
    return hr;
}


//==========================================================================
// this is just a helper function used by the "NegotiatePixelFormat"
// function. Just compares two pixel-formats to see if they are the
// same. We can't use a memcmp because of the fourcc codes.
BOOL CAMVideoPort::EqualPixelFormats(LPDDPIXELFORMAT lpFormat1, LPDDPIXELFORMAT lpFormat2)
{
    BOOL bRetVal = FALSE;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::EqualPixelFormats")));

    if (lpFormat1->dwFlags & DDPF_RGB &&
        lpFormat2->dwFlags & DDPF_RGB)
    {
        if (lpFormat1->dwRGBBitCount == lpFormat2->dwRGBBitCount &&
            lpFormat1->dwRBitMask == lpFormat2->dwRBitMask &&
            lpFormat1->dwGBitMask == lpFormat2->dwGBitMask &&
            lpFormat1->dwBBitMask == lpFormat2->dwBBitMask)
        {
            bRetVal = TRUE;
        }
    }
    else if (lpFormat1->dwFlags & DDPF_FOURCC &&
        lpFormat2->dwFlags & DDPF_FOURCC)
    {
        if (lpFormat1->dwFourCC == lpFormat2->dwFourCC)
        {
            bRetVal = TRUE;
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::EqualPixelFormats")));
    return bRetVal;
}


//==========================================================================
// this function takes a list of inputformats and returns the
// first input and output format pair that matches
HRESULT CAMVideoPort::GetBestFormat(
    DWORD dwNumInputFormats,
    LPDDPIXELFORMAT lpddInputFormats,
    LPDWORD lpdwBestEntry,
    LPDDPIXELFORMAT lpddBestOutputFormat)
{
    LPDDPIXELFORMAT lpddOutputFormats = NULL;
    HRESULT hr = S_FALSE;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::GetBestFormat")));

    for (DWORD i = 0; hr == S_FALSE && i < dwNumInputFormats; i++)
    {
        DWORD dwNumOutputFormats = 0;

        // find the number of entries supported by the videoport
        hr = m_pVideoPort->GetOutputFormats(&lpddInputFormats[i], &dwNumOutputFormats, NULL, DDVPFORMAT_VBI);
        if (!FAILED(hr))
        {
            if (dwNumOutputFormats != 0)
            {
                // allocate the necessary memory
                lpddOutputFormats = (LPDDPIXELFORMAT) new BYTE[dwNumOutputFormats*sizeof(DDPIXELFORMAT)];
                if (lpddOutputFormats != NULL)
                {
                    // memset the allocated memory to zero
                    memset(lpddOutputFormats, 0, dwNumOutputFormats*sizeof(DDPIXELFORMAT));
                    
                    // set the right size in each of the structs.
                    for (DWORD j = 0; j < dwNumOutputFormats; j++)
                        lpddOutputFormats[j].dwSize = sizeof(DDPIXELFORMAT);
                    
                    // get the entries supported by the videoport for this input format
                    hr = m_pVideoPort->GetOutputFormats(&lpddInputFormats[i], &dwNumOutputFormats, lpddOutputFormats, DDVPFORMAT_VBI);
                    if (!FAILED(hr))
                    {
                        // check each output format for a match
                        for (j = 0; j < dwNumOutputFormats; j++)
                        {
                            if (EqualPixelFormats(&lpddInputFormats[i], &lpddOutputFormats[j]))
                            {
                                memcpy(lpddBestOutputFormat, &lpddOutputFormats[j], sizeof(DDPIXELFORMAT));
                                *lpdwBestEntry = i;

                                break;
                            }
                            
                        }

                        // Force continuation of the search if no match for this input format
                        if (j == dwNumOutputFormats)
                            hr = S_FALSE;
                    }
                    else
                        DbgLog((LOG_ERROR,0,TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"), hr));

                    delete [] lpddOutputFormats, lpddOutputFormats = NULL;
                }
                else
                {
                    DbgLog((LOG_ERROR,0,TEXT("failed to allocate memory for lpddOutputFormats in GetBestFormat")));

                    hr = E_OUTOFMEMORY;
                }
            }
            else
                hr = S_FALSE;   // not found yet
        }
        else
            DbgLog((LOG_ERROR,0,TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"), hr));
    } // end of outer for loop

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::GetBestFormat")));
    return hr;
}


//==========================================================================
// Calls DDRAW to actually create the video port.
HRESULT CAMVideoPort::CreateVideoPort()
{
    HRESULT hr = NOERROR;
    DDVIDEOPORTDESC svpDesc;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::CreateVideoPort")));

    INITDDSTRUCT( svpDesc );
    
    // fill up the fields of the description struct
    svpDesc.dwVBIWidth = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;
    svpDesc.dwFieldHeight = m_capVPDataInfo.amvpDimInfo.dwFieldHeight;
    svpDesc.dwFieldWidth = m_capVPDataInfo.amvpDimInfo.dwFieldWidth;
    
    svpDesc.dwMicrosecondsPerField = m_capVPDataInfo.dwMicrosecondsPerField;
    svpDesc.dwMaxPixelsPerSecond = m_dwPixelsPerSecond;
    svpDesc.dwVideoPortID = m_dwVideoPortId;
    //DAG_TODO: need to use QueryVideoPortStatus
    svpDesc.VideoPortType.dwSize = sizeof(DDVIDEOPORTCONNECT);
    svpDesc.VideoPortType.dwPortWidth = m_vpConnectInfo.dwPortWidth;
    memcpy(&(svpDesc.VideoPortType.guidTypeID), &(m_vpConnectInfo.guidTypeID), sizeof(GUID));
    svpDesc.VideoPortType.dwFlags = 0;
    
    // if the decoder can send double clocked data and the videoport 
    // supports it, then set that property. This field is only valid
    // with an external signal.
    if (m_capVPDataInfo.bEnableDoubleClock &&
        m_vpConnectInfo.dwFlags & DDVPCONNECT_DOUBLECLOCK)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_DOUBLECLOCK;
    }
    
    // if the decoder can give an external activation signal and the 
    // videoport supports it, then set that property. This field is 
    // only valid with an external signal.
    if (m_capVPDataInfo.bEnableVACT && 
        m_vpConnectInfo.dwFlags & DDVPCONNECT_VACT)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_VACT;
    }
    
    // if the decoder can send interlaced data and the videoport 
    // supports it, then set that property.
    // !!!SJF_TODO - should we fail if the decoder can't send interlaced data?
    if (m_capVPDataInfo.bDataIsInterlaced)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INTERLACED;
    }

    if (m_bHalfLineFix)
    {
        //!!!SJF_TODO - flip polarity back to normal on decoder?
        ASSERT(!m_capVPDataInfo.bFieldPolarityInverted);
        //!!!SJF_TODO - fail if videoport doesn't handle inverted polarity?
        ASSERT(m_vpConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY);
        DbgLog((LOG_TRACE, 3, TEXT("INVERTPOLARITY & HALFLINE")));
        
        svpDesc.VideoPortType.dwFlags |=
            (DDVPCONNECT_INVERTPOLARITY | DDVPCONNECT_HALFLINE);
    }
    
#if 0 // def DEBUG
    DbgLog((LOG_TRACE, 3, TEXT("CreateVideoPort - DDVIDEOPORTDESC")));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize: %d"),svpDesc.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldWidth: %d"),svpDesc.dwFieldWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwVBIWidth: %d"),svpDesc.dwVBIWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldHeight: %d"),svpDesc.dwFieldHeight));
    DbgLog((LOG_TRACE, 3, TEXT("dwMicroseconds: %d"),svpDesc.dwMicrosecondsPerField));
    DbgLog((LOG_TRACE, 3, TEXT("dwMaxPixels: %d"),svpDesc.dwMaxPixelsPerSecond));
    DbgLog((LOG_TRACE, 3, TEXT("dwVideoPortID: %d"),svpDesc.dwVideoPortID));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved1: %d"),svpDesc.dwReserved1));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved2: %d"),svpDesc.dwReserved2));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved3: %d"),svpDesc.dwReserved3));
    DbgLog((LOG_TRACE, 3, TEXT("DDVIDEOPORTCONNECT")));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize: %d"),svpDesc.VideoPortType.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwPortWidth: %d"),svpDesc.VideoPortType.dwPortWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwFlags: 0x%x"),svpDesc.VideoPortType.dwFlags));
    DbgLog((LOG_TRACE, 3, TEXT("GUID: 0x%x"),*((DWORD *)&svpDesc.VideoPortType.guidTypeID)));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved1: %d"),svpDesc.VideoPortType.dwReserved1));
#endif // DEBUG

    // create the videoport. The first parameter is dwFlags, reserved for 
    // future use by ddraw. The last parameter is pUnkOuter, again must be
    // NULL.
    hr = m_pDDVPContainer->CreateVideoPort(DDVPCREATE_VBIONLY, &svpDesc, &m_pVideoPort, NULL );
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("Unable to create the video port, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::CreateVideoPort")));
    return hr;
}


//==========================================================================
// this function is used to allocate an offscreen surface to attach to the 
// videoport. 
// The allocation order it tries is just in decreasing amount of memory
// required.
// (3 buffers, single height)
// (2 buffers, single height)
// (1 buffer , single height).
HRESULT CAMVideoPort::CreateVPSurface(void)
{
    DWORD dwMaxBuffers;
    HRESULT hr = NOERROR;
    DWORD dwCurHeight = 0, dwCurBuffers = 0;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::CreateVPSurface")));

    ASSERT(m_pDirectDraw);
    
    // we will try to allocate up to 3 buffers (unless the 
    // hardware can handle less than 3)
    dwMaxBuffers = 3;
    if (m_vpCaps.dwNumVBIAutoFlipSurfaces < dwMaxBuffers)
        dwMaxBuffers = m_vpCaps.dwNumVBIAutoFlipSurfaces;
    
    // initialize the fields of ddsdDesc
    DDSURFACEDESC2 ddsdDesc;
    INITDDSTRUCT( ddsdDesc );
    ddsdDesc.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsdDesc.ddpfPixelFormat = m_ddVPOutputVideoFormat;
    ddsdDesc.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_VIDEOMEMORY | DDSCAPS_VIDEOPORT;

    ddsdDesc.dwHeight = m_dwSurfaceHeight;

    ddsdDesc.dwWidth = m_dwSurfacePitch;
    DbgLog((LOG_TRACE, 3, TEXT("Surface height %d, width %d, max buffers %d"),
        ddsdDesc.dwHeight, ddsdDesc.dwWidth, dwMaxBuffers));

    // we will only try to allocate more than one buffer if the videoport 
    // is cabable of autoflipping 
    if ((m_vpCaps.dwFlags & DDVPD_CAPS) && (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) && dwMaxBuffers > 1)
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;
        
        for (dwCurBuffers = dwMaxBuffers; !m_pOffscreenSurf &&  dwCurBuffers >= 2; dwCurBuffers--)
        {
            ddsdDesc.dwBackBufferCount = dwCurBuffers-1;

            hr = m_pDirectDraw->CreateSurface(&ddsdDesc, &m_pOffscreenSurf, NULL);
            if (SUCCEEDED(hr))
            {
                DbgLog((LOG_TRACE, 3, TEXT("allocated %d backbuffers"),
                    ddsdDesc.dwBackBufferCount));
                goto CleanUp;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("failed to allocate %d backbuffers, hr = 0x%x"),
                    ddsdDesc.dwBackBufferCount, hr));
            }
        }
    }
    
    // we should only reach this point when attempt to allocate multiple
    // buffers failed or no autoflip available
    DbgLog((LOG_ERROR, 0, TEXT("Warning: unable to allocate backbuffers")));
    
    ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
    ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
    m_svpInfo.dwVPFlags &= ~DDVP_AUTOFLIP;

    hr = m_pDirectDraw->CreateSurface(&ddsdDesc, &m_pOffscreenSurf, NULL);
    if (SUCCEEDED(hr))
    {
        goto CleanUp;
    }
    
    ASSERT(!m_pOffscreenSurf);
    DbgLog((LOG_ERROR,0,  TEXT("Unable to create offscreen surface")));

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::CreateVPSurface")));
    return hr;
}


//==========================================================================
// this function is used to inform the decoder of the various ddraw kernel handle
// using IVPConfig interface
HRESULT CAMVideoPort::SetDDrawKernelHandles()
{
    HRESULT hr = NOERROR;
    IDirectDrawKernel *pDDK = NULL;
    IDirectDrawSurfaceKernel *pDDSK = NULL;
    ULONG_PTR *rgKernelHandles = NULL;
    DWORD dwCount = 0;
    ULONG_PTR ddKernelHandle = 0;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::SetDDrawKernelHandles")));

    // get the IDirectDrawKernel interface
    ASSERT(m_pDirectDraw);
    hr = m_pDirectDraw->QueryInterface(IID_IDirectDrawKernel, (LPVOID *)&pDDK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("QueryInterface for IDirectDrawKernel failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // get the kernel handle
    ASSERT(pDDK);
    hr = pDDK->GetKernelHandle(&ddKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("GetKernelHandle from IDirectDrawKernel failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // set the kernel handle to directdraw using IVPConfig
    ASSERT(m_pIVPConfig);
    ASSERT(ddKernelHandle);
    hr = m_pIVPConfig->SetDirectDrawKernelHandle(ddKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetDirectDrawKernelHandle failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // set the VidceoPort Id using IVPConfig
    ASSERT(m_pIVPConfig);
    hr = m_pIVPConfig->SetVideoPortID(m_dwVideoPortId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetVideoPortID failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // Count the attached surfaces
    dwCount = 1; // includes the surface we already have a pointer to
    hr = m_pOffscreenSurf->EnumAttachedSurfaces((LPVOID)&dwCount, SurfaceCounter);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("EnumAttachedSurfaces failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Allocate a buffer to hold the count and surface handles
    rgKernelHandles = reinterpret_cast<ULONG_PTR *>(CoTaskMemAlloc((dwCount + 1) * sizeof(ULONG_PTR)));
    if (rgKernelHandles == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("Out of memory while retrieving surface kernel handles")));
        goto CleanUp;
    }

    // Initialize the array with the handle for m_pOffscreenSurf
    *rgKernelHandles = 0;
    hr = SurfaceKernelHandle(m_pOffscreenSurf, NULL, (PVOID)rgKernelHandles);
    if (hr != DDENUMRET_OK)
    {
        goto CleanUp;
    }
    hr = NOERROR;
    
    hr = m_pOffscreenSurf->EnumAttachedSurfaces((LPVOID)rgKernelHandles, SurfaceKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("EnumAttachedSurfaces failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // set the kernel handle to the offscreen surface using IVPConfig
    ASSERT(m_pIVPConfig);
    hr = m_pIVPConfig->SetDDSurfaceKernelHandles(static_cast<DWORD>(*rgKernelHandles), rgKernelHandles+1);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetDDSurfaceKernelHandles failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // call SetSurfaceParameters interface on IVPConfig
    ASSERT(m_pIVPConfig);
    DbgLog((LOG_TRACE, 3, TEXT("SetSurfaceParams(%d,%d,%d)"),
        m_dwSurfacePitch, m_dwSurfaceOriginX, m_dwSurfaceOriginY));
    hr = m_pIVPConfig->SetSurfaceParameters(m_dwSurfacePitch,
        m_dwSurfaceOriginX,m_dwSurfaceOriginY);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetSurfaceParameters failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    // release the kernel ddraw handle
    RELEASE(pDDK);
    
    if (rgKernelHandles)
    {
        CoTaskMemFree(rgKernelHandles);
        rgKernelHandles = NULL;
    }
    
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::SetDDrawKernelHandles")));
    return hr;
}


//==========================================================================
// this function is used to negotiate the pixelformat with the decoder.
// It asks the decoder for a list of input formats, intersects that list
// with the one the decoder supports (while maintaining the order) and 
// then calls "GetBestFormat" on that list to get the "best" input and
// output format. After that it calls "SetPixelFormat" on the decoder in
// order to inform the decoder of the decision.
HRESULT CAMVideoPort::NegotiatePixelFormat()
{
    HRESULT hr = NOERROR;
    
    LPDDPIXELFORMAT lpddCaptureFormats = NULL;
    DWORD dwNumCaptureEntries = 0;
    LPDDPIXELFORMAT lpddVPInputFormats = NULL;
    DWORD dwNumVPInputEntries = 0;
    LPDDPIXELFORMAT lpddIntersectionFormats = NULL;
    DWORD dwNumIntersectionEntries = 0;
    DWORD dwBestEntry, dwMaxIntersectionEntries = 0;
    DWORD i = 0, j = 0;
    
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::NegotiatePixelFormat")));

    // find the number of entries to be proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumCaptureEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumCaptureEntries);
    
    // allocate the necessary memory
    lpddCaptureFormats = (LPDDPIXELFORMAT) new BYTE [dwNumCaptureEntries*sizeof(DDPIXELFORMAT)];
    if (lpddCaptureFormats == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    // memset the allocated memory to zero
    memset(lpddCaptureFormats, 0, dwNumCaptureEntries*sizeof(DDPIXELFORMAT));
    
    // set the right size of all the structs
    for (i = 0; i < dwNumCaptureEntries; i++)
    {   
        lpddCaptureFormats[i].dwSize = sizeof(DDPIXELFORMAT);
    }
    
    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumCaptureEntries, lpddCaptureFormats);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // find the number of entries supported by the videoport
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries, NULL, DDVPFORMAT_VBI);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumVPInputEntries);
    
    // allocate the necessary memory
    lpddVPInputFormats = (LPDDPIXELFORMAT) new BYTE[dwNumVPInputEntries*sizeof(DDPIXELFORMAT)];
    if (lpddVPInputFormats == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    // memset the allocated memory to zero
    memset(lpddVPInputFormats, 0, dwNumVPInputEntries*sizeof(DDPIXELFORMAT));
    
    // set the right size of all the structs
    for (i = 0; i < dwNumVPInputEntries; i++)
    {
        lpddVPInputFormats[i].dwSize = sizeof(DDPIXELFORMAT);
    }
    
    // get the entries supported by the videoport
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries, lpddVPInputFormats, DDVPFORMAT_VBI);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // calculate the maximum number of elements in the interesection
    dwMaxIntersectionEntries = (dwNumCaptureEntries < dwNumVPInputEntries) ? 
        (dwNumCaptureEntries) : (dwNumVPInputEntries);
    
    // allocate the necessary memory
    lpddIntersectionFormats = (LPDDPIXELFORMAT) new BYTE[dwMaxIntersectionEntries*sizeof(DDPIXELFORMAT)];
    if (lpddIntersectionFormats == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    // memset the allocated memory to zero
    // no need to set the size of the structs here, as we will memcpy them anyway
    memset(lpddIntersectionFormats, 0, dwMaxIntersectionEntries*sizeof(DDPIXELFORMAT));
    
    // find the intersection of the two lists 
    dwNumIntersectionEntries = 0;
    for (i = 0; i < dwNumCaptureEntries; i++)
    {
        for (j = 0; j < dwNumVPInputEntries; j++)
        {
            if (EqualPixelFormats(lpddCaptureFormats+i, lpddVPInputFormats+j))
            {
                ASSERT(dwNumIntersectionEntries < dwMaxIntersectionEntries);
                memcpy((lpddIntersectionFormats+dwNumIntersectionEntries),
                    (lpddCaptureFormats+i), sizeof(DDPIXELFORMAT));
                dwNumIntersectionEntries++;
            }
        }
    }
    
    // the number of entries in the intersection is zero!!
    // Return failure.
    if (dwNumIntersectionEntries == 0)
    {
        ASSERT(i == dwNumCaptureEntries);
        ASSERT(j == dwNumVPInputEntries);
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }
    
    // find the first input format in the intersection list that has a matching output format
    hr = GetBestFormat(dwNumIntersectionEntries, lpddIntersectionFormats,
        &dwBestEntry, &m_ddVPOutputVideoFormat);
    if (hr != NOERROR)
    {
        DbgLog((LOG_ERROR,0,TEXT("GetBestFormat failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // cache the input format
    memcpy(&m_ddVPInputVideoFormat, (lpddIntersectionFormats+dwBestEntry), sizeof(m_ddVPInputVideoFormat));
    // set the format the decoder is supposed to be using
    for (i = 0; i < dwNumCaptureEntries; i++)
    {
        if (EqualPixelFormats(lpddCaptureFormats+i, &m_ddVPInputVideoFormat))
        {
            hr = m_pIVPConfig->SetVideoFormat(i);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->SetVideoFormat failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            break;
        }
    }
    
    // we are sure that the chosen input format is in the input list 
    ASSERT(i < dwNumCaptureEntries);

    // Update the m_svpInfo structure which was mostly filled in in
    // InitializeVideoPortInfo
    ASSERT(EqualPixelFormats(&m_ddVPInputVideoFormat, &m_ddVPOutputVideoFormat));
    m_svpInfo.lpddpfVBIInputFormat = &m_ddVPInputVideoFormat;
    m_svpInfo.lpddpfVBIOutputFormat = &m_ddVPOutputVideoFormat;

    
CleanUp:
    // cleanup
    delete [] lpddCaptureFormats;
    delete [] lpddVPInputFormats;
    delete [] lpddIntersectionFormats;
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::NegotiatePixelFormat")));
    return hr;
}


//==========================================================================
HRESULT CAMVideoPort::InitializeVideoPortInfo()
{
    HRESULT hr = NOERROR;
    RECT rcVPCrop;

    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::InitializeVideoPortInfo")));

    m_dwSurfacePitch = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;
    m_dwSurfaceHeight = m_capVPDataInfo.amvpDimInfo.dwVBIHeight;
    m_dwSurfaceOriginX = m_capVPDataInfo.amvpDimInfo.rcValidRegion.left;
    m_dwSurfaceOriginY = m_capVPDataInfo.amvpDimInfo.rcValidRegion.top;
    m_bHalfLineFix = FALSE;

    // If we ask the videoport to do cropping, the bottom of the cropping
    // region MUST touch but not overlap the top of the cropping region
    // for video set by OVMIXER due to h/w limitations.
    // So, the bottom of our crop region is always dwVBIHeight (or
    // possibly dwVBIHeight+1 if certain halfline fixes are in effect,
    // see below) even if the capture driver hasn't set ValidRegion to
    // include that many lines.
    rcVPCrop.top = 0;
    rcVPCrop.left = 0;
    rcVPCrop.bottom = m_capVPDataInfo.amvpDimInfo.dwVBIHeight;
    rcVPCrop.right = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;

    // Adjust for half-lines
    // Some video decoders send halflines in even or odd field.
    // Some video ports capture halflines, some don't.
    // See Video Line Numbering using VPE by smac
    if (m_vpConnectInfo.dwFlags & DDVPCONNECT_HALFLINE) // e.g. ATI videoport
    {
        if ((m_capVPDataInfo.lHalfLinesOdd == 0) &&
        (m_capVPDataInfo.lHalfLinesEven == 1))  // e.g. Brooktree decoder
        {
            // ATI All In Wonder (AIW) board
            // halfline problem
            DbgLog((LOG_TRACE, 3, TEXT("Setting up for AIW h/w")));
            m_dwSurfaceHeight++;
            rcVPCrop.bottom += 1;
            m_bHalfLineFix = TRUE;
        }
        else if (((m_capVPDataInfo.lHalfLinesOdd == -1) && (m_capVPDataInfo.lHalfLinesEven ==  0)) ||   // e.g. Philips decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven == -1)) ||   // e.g. ? decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven ==  0)))     // e.g. ? decoder
        {
            // no halfline problem, do nothing
        }
        else
        {
            // YIKES! We have no solution for these cases (if they even exist)!
            DbgLog((LOG_ERROR, 0,TEXT("CAMVideoPort::InitializeVideoPortInfo: unfixable halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }
    else    // videoport that doesn't capture halflines
    {
        if ((m_capVPDataInfo.lHalfLinesOdd == -1) &&
            (m_capVPDataInfo.lHalfLinesEven == 0))  // e.g. Philips decoder
        {
            // halfline problem
            m_dwSurfaceHeight++;
            rcVPCrop.top -= 1;
            m_bHalfLineFix = TRUE;
        }
        else if (((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven ==  1)) ||   // e.g. BT829 decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  1) && (m_capVPDataInfo.lHalfLinesEven ==  0)) ||   // e.g. ? decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven ==  0)))     // e.g. ? decoder
        {
            // no halfline problem, do nothing
        }
        else
        {
            // YIKES! We have no solution for these cases (if they even exist)!
            DbgLog((LOG_ERROR, 0,TEXT("CAMVideoPort::InitializeVideoPortInfo: unfixable halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }

    // Adjust if video discards lines during the VREF period
    if (m_vpConnectInfo.dwFlags & DDVPCONNECT_DISCARDSVREFDATA)
    {
        DbgLog((LOG_TRACE, 3, TEXT("VideoPort discards %d VREF lines"),
            m_capVPDataInfo.dwNumLinesInVREF));
        ASSERT(m_dwSurfaceOriginY >= m_capVPDataInfo.dwNumLinesInVREF);
        m_dwSurfaceOriginY -= m_capVPDataInfo.dwNumLinesInVREF;
        m_dwSurfaceHeight -= m_capVPDataInfo.dwNumLinesInVREF;
        rcVPCrop.bottom -= m_capVPDataInfo.dwNumLinesInVREF;
    }

    // initialize the DDVIDEOPORTINFO struct to be passed to pVideoport->StartVideo
    memset(&m_svpInfo, 0, sizeof(DDVIDEOPORTINFO));
    m_svpInfo.dwSize = sizeof(DDVIDEOPORTINFO);
    m_svpInfo.dwVBIHeight = m_dwSurfaceHeight;
    // Assume we're going to be able to autoflip
    m_svpInfo.dwVPFlags = DDVP_AUTOFLIP;
    // pixelformats get filled in in NegotiatePixelFormats

#if 0   // !!!SJF_TODO - ATI says that cropping for VBI is not supported.
    // We always set h/w cropping in the Y direction if we can.
    // For VBI, we don't need to do cropping in the X direction.
    // Can the videoport crop in the Y direction?
    if ((m_vpCaps.dwFlags & DDVPD_FX) && (m_vpCaps.dwFX & DDVPFX_CROPY))
    {
        rcVPCrop.top = m_dwSurfaceOriginY;
        m_dwSurfaceHeight -= m_dwSurfaceOriginY;
        m_dwSurfaceOriginY = 0;

        m_svpInfo.rCrop = rcVPCrop;
        m_svpInfo.dwVPFlags |= DDVP_CROP;

        DbgLog((LOG_TRACE, 3, TEXT("Cropping left top:      (%d,%d)"),
            m_svpInfo.rCrop.left, m_svpInfo.rCrop.top));
        DbgLog((LOG_TRACE, 3, TEXT("Cropping bottom right:  (%d,%d)"),
            m_svpInfo.rCrop.right, m_svpInfo.rCrop.bottom));
    }
    else
    {
        if (m_bHalfLineFix)
        {
            DbgLog((LOG_ERROR, 0,TEXT("CAMVideoPort::InitializeVideoPortInfo: can't crop to fix halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }
#endif  // 0

    if (m_bHalfLineFix)
    {
        if (!(m_vpConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY))
        {
            DbgLog((LOG_ERROR, 0, TEXT("CAMVideoPort::InitializeVideoPortInfo: can't invert polarity to fix halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }

#if 0 // def DEBUG
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfaceHeight:  %d"),m_dwSurfaceHeight));
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfacePitch:   %d"),m_dwSurfacePitch));
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfaceOriginX: %d"),m_dwSurfaceOriginX));
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfaceOriginY: %d"),m_dwSurfaceOriginY));
#endif // DEBUG

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::InitializeVideoPortInfo")));

    return hr;
}


//==========================================================================
//
HRESULT CAMVideoPort::SetupVideoPort()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::SetupVideoPort")));
    ASSERT(m_VPState == VP_STATE_NO_VP);

    HRESULT hr = NOERROR;

    // initialize variables
    memset(&m_svpInfo, 0, sizeof(DDVIDEOPORTINFO));
    memset(&m_vpCaps, 0, sizeof(DDVIDEOPORTCAPS));

    // Get the Video Port caps
    hr = GetVideoPortCaps();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetVideoPortCaps failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // initalize the DDVideoPortInfo structure
    hr = InitializeVideoPortInfo();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("InitializeVideoPortInfo FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // create the video port
    hr = CreateVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CreateVideoPort failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // negotiate the pixel format 
    if (NegotiatePixelFormat() != 0)
    {
        DbgLog((LOG_ERROR, 0, TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // create the offscreen surface
    hr = CreateVPSurface();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CreateVPSurface FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }
    
    // attach the offscreen surface to the videoport
    hr = m_pVideoPort->SetTargetSurface(reinterpret_cast<LPDIRECTDRAWSURFACE>(m_pOffscreenSurf), DDVPTARGET_VBI);
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pVideoPort->SetTargetSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // inform the decoder of the ddraw kernel handle, videoport id and surface kernel
    // handle
    hr = SetDDrawKernelHandles();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("SetDDrawKernelHandles failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    m_VPState = VP_STATE_STOPPED;

CleanUp:
    if (FAILED(hr))
        TearDownVideoPort();

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::SetupVideoPort, hr = 0x%x"), hr));

    return hr;
}


//==========================================================================
//
HRESULT CAMVideoPort::TearDownVideoPort()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::TearDownVideoPort")));

    // Release the DirectDraw surface
    RELEASE(m_pOffscreenSurf);

    // release the videoport
    RELEASE(m_pVideoPort);

    m_VPState = VP_STATE_NO_VP;

    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::TearDownVideoPort")));
    return NOERROR;
}


//==========================================================================
//
HRESULT CAMVideoPort::StartVideo()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::StartVideo")));
    ASSERT(m_VPState == VP_STATE_STOPPED);

    HRESULT hr = NOERROR;
    DWORD dwSignalStatus;

#if 0 // def DEBUG
    DbgLog((LOG_TRACE, 3, TEXT("DDVIDEOPORTINFO at StartVideo")));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize: %d"), m_svpInfo.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwOriginX: %d"), m_svpInfo.dwOriginX));
    DbgLog((LOG_TRACE, 3, TEXT("dwOriginY: %d"), m_svpInfo.dwOriginY));
    DbgLog((LOG_TRACE, 3, TEXT("dwVPFlags: 0x%0x"), m_svpInfo.dwVPFlags));
    DbgLog((LOG_TRACE, 3, TEXT("Cropping left top: (%d,%d)"),
        m_svpInfo.rCrop.left, m_svpInfo.rCrop.top));
    DbgLog((LOG_TRACE, 3, TEXT("Cropping right bottom: (%d,%d)"),
        m_svpInfo.rCrop.right, m_svpInfo.rCrop.bottom));
    DbgLog((LOG_TRACE, 3, TEXT("dwPrescaleWidth: %d"),
        m_svpInfo.dwPrescaleWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwPrescaleHeight: %d"),
        m_svpInfo.dwPrescaleHeight));
    if (m_svpInfo.lpddpfInputFormat)
        DbgLog((LOG_TRACE, 3, TEXT("InputFormat: 0x%0x, %d, 0x%0x, 0x%0x"),
            m_svpInfo.lpddpfInputFormat,
            m_svpInfo.lpddpfInputFormat->dwSize,
            m_svpInfo.lpddpfInputFormat->dwFlags,
            m_svpInfo.lpddpfInputFormat->dwFourCC));

    if (m_svpInfo.lpddpfVBIInputFormat)
        DbgLog((LOG_TRACE, 3, TEXT("VBIInputFormat: 0x%0x, %d, 0x%0x, 0x%0x"),
            m_svpInfo.lpddpfVBIInputFormat,
            m_svpInfo.lpddpfVBIInputFormat->dwSize,
            m_svpInfo.lpddpfVBIInputFormat->dwFlags,
            m_svpInfo.lpddpfVBIInputFormat->dwFourCC));
    if (m_svpInfo.lpddpfVBIOutputFormat)
        DbgLog((LOG_TRACE, 3, TEXT("VBIOutputFormat: 0x%0x, %d, 0x%0x, 0x%0x"),
            m_svpInfo.lpddpfVBIOutputFormat,
            m_svpInfo.lpddpfVBIOutputFormat->dwSize,
            m_svpInfo.lpddpfVBIOutputFormat->dwFlags,
            m_svpInfo.lpddpfVBIOutputFormat->dwFourCC));
    DbgLog((LOG_TRACE, 3, TEXT("dwVBIHeight: %d"), m_svpInfo.dwVBIHeight));
#endif // DEBUG

    hr = m_pVideoPort->StartVideo(&m_svpInfo);
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("StartVideo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_VPState = VP_STATE_RUNNING;

    DbgLog((LOG_TRACE, 2, TEXT("STARTVIDEO DONE!")));

    // check if the videoport is receiving a signal.
    hr = m_pVideoPort->GetVideoSignalStatus(&dwSignalStatus);
    if (hr != E_NOTIMPL)
    {
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetVideoSignalStatus() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        else if (dwSignalStatus == DDVPSQ_NOSIGNAL)
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetVideoSignalStatus() returned DDVPSQ_NOSIGNAL, hr = 0x%x"), hr));
            //goto CleanUp;   // SJF_TODO - ignore error for now
        }
    }
    //m_pVideoPort->WaitForSync(DDVPWAIT_END, 0, 0);
    
CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::StartVideo")));

    return hr;
}


HRESULT CAMVideoPort::StopVideo()
{
    DbgLog((LOG_TRACE, 4, TEXT("Entering CAMVideoPort::StopVideo")));
    ASSERT(m_VPState == VP_STATE_RUNNING);

    HRESULT hr = NOERROR;

    hr = m_pVideoPort->StopVideo();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR,0, TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        //goto CleanUp;
        hr = NOERROR;
    }
    m_VPState = VP_STATE_STOPPED;

//CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving CAMVideoPort::StopVideo, hr = 0x%x"), hr));
    return hr;
}
    

//==========================================================================
// This routine is appropriate as a callback for
// IDirectDrawSurface2::EnumAttachedSurfaces()
//
HRESULT WINAPI SurfaceCounter(
    LPDIRECTDRAWSURFACE7 lpDDSurface,
    LPDDSURFACEDESC2 lpDDSurfaceDesc,
    LPVOID lpContext)
{
    DWORD *dwCount = (DWORD *)lpContext;

    (*dwCount)++;

    return DDENUMRET_OK;
}


//==========================================================================
// This routine is appropriate as a callback for
// IDirectDrawSurface2::EnumAttachedSurfaces()
//
// The context parameter is a block of storage
// where the first DWORD element is the count of
// the remaining DWORD elements in the block.
//
// Each time this routine is called, it will
// increment the count, and put a kernel handle
// in the next available slot.
//
// It is assumed that the block of storage is
// large enough to hold the total number of kernel
// handles. The ::SurfaceCounter callback is one
// way to assure this (see above).
//
HRESULT WINAPI SurfaceKernelHandle(
    LPDIRECTDRAWSURFACE7 lpDDSurface,
    LPDDSURFACEDESC2 lpDDSurfaceDesc,
    LPVOID lpContext)
{
    IDirectDrawSurfaceKernel *pDDSK = NULL;
    ULONG_PTR *rgKernelHandles = (ULONG_PTR *)lpContext;
    HRESULT hr;

    DbgLog((LOG_TRACE, 4, TEXT("Entering ::SurfaceKernelHandle")));

    // get the IDirectDrawKernel interface
    hr = lpDDSurface->QueryInterface(IID_IDirectDrawSurfaceKernel, (LPVOID *)&pDDSK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("QueryInterface for IDirectDrawSurfaceKernel failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // get the kernel handle, using the first element of the context
    // as an index into the array
    ASSERT(pDDSK);
    (*rgKernelHandles)++;
    hr = pDDSK->GetKernelHandle(rgKernelHandles + *rgKernelHandles);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("GetKernelHandle from IDirectDrawSurfaceKernel failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    hr = DDENUMRET_OK;

CleanUp:
    // release the kernel ddraw surface handle
    RELEASE(pDDSK);

    DbgLog((LOG_TRACE, 5, TEXT("Leaving ::SurfaceKernelHandle")));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\dlg.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Dlg.cpp

Abstract:

    Dialog functions.

Author:

    FelixA 1996

Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"
#include "dlg.h"

///////////////////////////////////////////////////////////////////////////////
//
// Sets the lParam to the 'this' pointer
// wraps up PSN_ messages and calls virtual functions
// calls off to your overridable DlgProc
//

BOOL CALLBACK CDlg::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CDlg * pSV = (CDlg*)GetWindowLongPtr(hDlg,DWLP_USER);

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            pSV=(CDlg*)lParam;
            pSV->SetWindow(hDlg);
            SetWindowLongPtr(hDlg,DWL_USER,(LPARAM)pSV);
            pSV->OnInit();
        }
        break;

        // Override the Do Command to get a nice wrapped up feeling.
        case WM_COMMAND:
            if(pSV)
                return pSV->DoCommand(LOWORD(wParam),HIWORD(wParam));
        break;

        case WM_NOTIFY:
            if(pSV)
                return pSV->DoNotify((NMHDR FAR *)lParam);
        break;

        case WM_DESTROY:
            if(pSV)
                pSV->Destroy();
        break;
    }

    if(pSV)
        return pSV->DlgProc(hDlg,uMessage,wParam,lParam);
    else
        return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// You can override this DlgProc if you want to handle specific messages
//
BOOL CALLBACK CDlg::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Below are just default handlers for the virtual functions.
//
int CDlg::DoCommand(WORD wCmdID,WORD hHow)
{
    switch( wCmdID )
    {
        case IDOK:
        case IDCANCEL:
            EndDialog(wCmdID);
        break;
    }
    return 1;    // not handled, just did Apply work.
}

void CDlg::OnInit()
{
}

CDlg::CDlg(int DlgID, HWND hWnd, HINSTANCE hInst)
: m_DlgID(DlgID),
  m_hParent(hWnd),
  m_Inst(hInst),
  m_bCreatedModeless(FALSE),
  m_hDlg(0)
{
}

//
//
//
int CDlg::Do()
{
    m_bCreatedModeless=FALSE;
    return DialogBoxParam( m_Inst,  MAKEINTRESOURCE(m_DlgID), m_hParent, (DLGPROC)BaseDlgProc, (LPARAM)this);
}

HWND CDlg::CreateModeless()
{
    if(m_hDlg)
        return m_hDlg;

    HWND hWnd=CreateDialogParam(m_Inst, MAKEINTRESOURCE(m_DlgID), m_hParent, (DLGPROC)BaseDlgProc,  (LPARAM)this);
    if(hWnd)
        m_bCreatedModeless=TRUE;
    return hWnd;
}

int CDlg::DoNotify(NMHDR * pHdr)
{
    return FALSE;
}

void CDlg::Destroy()
{
    if(m_bCreatedModeless)
    {
        if(m_hDlg)
            m_hDlg=NULL;
    }
}

CDlg::~CDlg()
{
    if(m_hDlg)
        DestroyWindow(m_hDlg);
}

void CDlg::SetDlgID(UINT id)
{
    m_DlgID=id;
}

void CDlg::SetInstance(HINSTANCE hInst)
{
    m_Inst=hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\dlg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Dlg.h

Abstract:

    Header file for Dlg.cpp

Author:
    
    FelixA 1996

Modified:
               
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/


#ifndef __DIALOGH
#define __DIALOGH

class CDlg
{
public:
    void SetInstance(HINSTANCE hInst);
    void SetDlgID(UINT id);
    void Destroy();
    CDlg(int DlgID, HWND hWndParent, HINSTANCE hInst);
    ~CDlg();

    HWND GetWindow() const { return m_hDlg; }
    HWND GetParent() const { return ::GetParent(m_hDlg); }
    HWND GetDlgItem(int iD) const { return ::GetDlgItem(m_hDlg,iD); }
    HINSTANCE GetInstance() const { return m_Inst;}
    BOOL EndDialog(int iRet) { return ::EndDialog(m_hDlg,iRet); }

    // If you want your own dlg proc.
    int Do();
    virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual int DoCommand(WORD wCmdID,WORD hHow);    // return 0 if you handled this.
    virtual void OnInit();
    virtual int DoNotify(NMHDR * pHdr);
    HWND CreateModeless();

private:
    BOOL m_bCreatedModeless;
    void SetWindow(HWND hDlg) { m_hDlg=hDlg; }
    int  m_DlgID;
    HWND m_hDlg;
    HWND m_hParent;
    HINSTANCE m_Inst;

protected:
    static BOOL CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\drvproc.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    drvproc.cpp

Abstract:

    This really is a C file and is the front end to DRV_* (DriverProc()) messages.

Author:

    Yee J. Wu (ezuwu) 1-April-98

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"
#include "talk.h"       // PCHANNEL



//
//  we use this driverID to determine when we where opened as a video
//  device or from the control panel, etc....
//
#define BOGUS_DRIVER_ID     1

#ifdef WIN32
extern "C" {
#endif

LRESULT
FAR
PASCAL
_loadds
DriverProc(
           DWORD dwDriverID,
           HDRVR hDriver,
           UINT uiMessage,
           LPARAM lParam1,
           LPARAM lParam2
           )
{
    switch (uiMessage)
    {
    case DRV_LOAD:	// Get the buddy up and running - DONE
        DbgLog((LOG_TRACE,2,TEXT("DRV_LOAD:")));
        return 1L;

    case DRV_FREE:	// tells the buddy to quit - DONE
        DbgLog((LOG_TRACE,2,TEXT("DRV_FREE:")));
        return (LRESULT)1L;

    case DRV_OPEN:	// Calls to 32bit guy to get a handle to use.
        DbgLog((LOG_TRACE,2,TEXT("DRV_OPEN")));


        /*
         Sent to the driver when it is opened.

         dwDriverID is 0L.

         lParam1 is a far pointer to a zero-terminated string
         containing the name used to open the driver.

         lParam2 is passed through from the drvOpen call. It is
         NULL if this open is from the Drivers Applet in control.exe
         It is LPVIDEO_OPEN_PARMS otherwise.

         Return 0L to fail the open.

         DefDriverProc will return ZERO so we do have to
         handle the DRV_OPEN message.
         */

        //
        //  if we were opened without a open structure then just
        //  return a phony (non zero) id so the OpenDriver() will
        //  work.
        //
        if(lParam2 == 0) {
            DbgLog((LOG_TRACE,2,TEXT("DRV_OPEN: lParam2 == 0; return BOGUS_DRIVER_ID")));
            return BOGUS_DRIVER_ID;
        }

        //  Verify this open is for us, and not for an installable
        //  codec.
        if (((LPVIDEO_OPEN_PARMS) lParam2) -> fccType != OPEN_TYPE_VCAP) {
             DbgLog((LOG_TRACE,2,TEXT("DRV_OPEN: fccType != OPEN_TYPE_VCAP")));
             return 0L;
        }

        return (LRESULT) VideoOpen((LPVIDEO_OPEN_PARMS) lParam2);

    case DRV_CLOSE:
        DbgLog((LOG_TRACE,2,TEXT("DRV_CLOSE")));

        /*
         Sent to the driver when it is closed. Drivers are unloaded
         when the close count reaches zero.

         dwDriverID is the driver identifier returned from the
         corresponding DRV_OPEN.

         lParam1 is passed through from the drvClose call.

         lParam2 is passed through from the drvClose call.

         Return 0L to fail the close.

         DefDriverProc will return ZERO so we do have to
         handle the DRV_CLOSE message.
         */

        if (dwDriverID == BOGUS_DRIVER_ID || dwDriverID == 0)
            return 1L;      // return success

        return ((VideoClose((PCHANNEL)dwDriverID) == DV_ERR_OK) ? 1L : 0);

    case DRV_ENABLE:
        DbgLog((LOG_TRACE,2,TEXT("DRV_ENABLE")));

        /*
         Sent to the driver when the driver is loaded or reloaded
         and whenever Windows is enabled. Drivers should only
         hook interrupts or expect ANY part of the driver to be in
         memory between enable and disable messages

         dwDriverID is 0L.
         lParam1 is 0L.
         lParam2 is 0L.

         Return value is ignored.
         */
		      return (LRESULT)1L;

    case DRV_DISABLE:
        DbgLog((LOG_TRACE,2,TEXT("DRV_DISABLE")));

        /*
         Sent to the driver before the driver is freed.
         and whenever Windows is disabled

         dwDriverID is 0L.
         lParam1 is 0L.
         lParam2 is 0L.

         Return value is ignored.
         */
		      return (LRESULT)1L;

    case DRV_QUERYCONFIGURE:
        DbgLog((LOG_TRACE,2,TEXT("DRV_QUERYCONFIGURE")));
        /*
         Sent to the driver so that applications can
         determine whether the driver supports custom
         configuration. The driver should return a
         non-zero value to indicate that configuration
         is supported.

         dwDriverID is the value returned from the DRV_OPEN
         call that must have succeeded before this message
         was sent.

         lParam1 is passed from the app and is undefined.
         lParam2 is passed from the app and is undefined.

         Return 0L to indicate configuration NOT supported.
         */
        return (LRESULT)0;        // we do not support configuration

    case DRV_CONFIGURE:
        DbgLog((LOG_TRACE,2,TEXT("DRV_CONFIGURE") ));
        /*
         Sent to the driver so that it can display a custom
         configuration dialog box.

         lParam1 is passed from the app. and should contain
         the parent window handle in the loword.
         lParam2 is passed from the app and is undefined.

         Return value is undefined.

         Drivers should create their own section in system.ini.
         The section name should be the driver name.
         */
#if 0
        VideoConfig(
            (PCHANNEL) dwDriverID,
            (HWND) lParam1,            // Parent window handle
            (DRVCONFIGINFO *) lParam2  // the names of the registry key and value associated with the driver
            );
#endif
			     return 0;

    case DRV_INSTALL:
        DbgLog((LOG_TRACE,2,TEXT("DRV_INSTALL")));
        /*
         Windows has installed the driver, and since we
         are loaded on demand, there is no need to
         restart Windows.
         */
        return (LRESULT)DRV_OK;
    case DRV_REMOVE:
        DbgLog((LOG_TRACE,2,TEXT("DRV_REMOVE")));
        return (LRESULT)DRV_OK;

    case DVM_GETVIDEOAPIVER: /* lParam1 = LPDWORD */
        DbgLog((LOG_TRACE,2,TEXT("DVM_GETVIDEOAPIVER=%s"), VIDEOAPIVERSION));
        if(lParam1) {
            *(LPDWORD) lParam1 = VIDEOAPIVERSION;
            return DV_ERR_OK;
        } else
            return DV_ERR_PARAM1;

    default:
        if(dwDriverID == BOGUS_DRIVER_ID || dwDriverID == 0)
            return DefDriverProc(dwDriverID, hDriver, uiMessage,lParam1,lParam2);


        return VideoProcessMessage((PCHANNEL)dwDriverID, uiMessage, lParam1, lParam2);
    }
}

#ifdef WIN32
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\debug.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Debug.h

Abstract:

    Header file for Debug.cpp and probably used by all .CPP.

Author:

    Yee J. Wu (ezuwu) 15-October-97

Environment:

    User mode only

Revision History:

--*/

#ifndef _DEBUGH
#define _DEBUGH

#if DBG || defined(_DEBUG)

    #ifndef _DEBUG
        #define _DEBUG
    #endif

    #define ModuleDebugLevel VfWWDM32DebugLevel
    #define ModuleDebugStamp VfWWDM32DebugStamp

    extern DWORD ModuleDebugLevel;

    #define TRACE  PlaceStamp(__FILE__,__LINE__);dbgPrintf

    void PlaceStamp(LPSTR lpszFile, int iLineNum);
    void dbgPrintf(char * szFormat, ...);

    #define dp1(_x_) {if (ModuleDebugLevel >= 1) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dp2(_x_) {if (ModuleDebugLevel >= 2) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dp3(_x_) {if (ModuleDebugLevel >= 3) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dp4(_x_) {if (ModuleDebugLevel >= 4) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}

    //BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine, LPSTR szExpr);
    //#define ASSERT(expr)  _Assert((expr), __FILE__, __LINE__, #expr)

#else

    #define TRACE 0?0:
    #define dbgPrintf 0?0:
    #define dprintf(_x_)
    #define dp1(_x_)
    #define dp2(_x_)
    #define dp3(_x_)
    #define dp4(_x_)

    #undef ASSERT
    #define ASSERT(expr)

#endif

#endif // DEBUGH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\clsdrv.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ClsDrv.cpp

Abstract:

    This is a driver for the interface with WDM capture driver including
    open/close a driver and query/set its properties.

Author:

    FelixA
    
Modified:    
    
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

#include "winerror.h"
#include "clsdrv.h"
#include "vfwext.h"  // For TARGET_DEVICE_FRIENDLY_NAME used in VfWEXT DLL

// This might only be defined for NT5 at the time of this implementation.
// For compiling purpose, it is added here; but may never get used if
// this error code is not mapped from kernel status of STATUS_DEVICE_REMOVED.                           
#ifndef ERROR_DEVICE_REMOVED
// defined in winerror.h of NT5 
#define ERROR_DEVICE_REMOVED 1617L
#endif

#ifndef STATUS_MORE_ENTRIES
#define STATUS_MORE_ENTRIES         0x00000105
#endif


TCHAR gszMsVideoVfWWDM[]  = TEXT("System\\CurrentControlSet\\control\\MediaResources\\msvideo\\MSVideo.VFWWDM");
TCHAR gszSoftwareVfWWDM[] = TEXT("Software\\Microsoft\\VfWWDM Mapper");
TCHAR gszDevicePath[]     = TEXT("DevicePath");



//
// These are defined as multibyte character in ddk\vfdwext.h
// redefined here as UNICODE
//
#define TARGET_DEVICE_FRIENDLY_NAME_TCHAR     TEXT(TARGET_DEVICE_FRIENDLY_NAME)      // REG_SZ
#define TARGET_DEVICE_OPEN_EXCLUSIVELY_TCHAR  TEXT(TARGET_DEVICE_OPEN_EXCLUSIVELY)   // REG_DWORD

                     
CClassDriver::CClassDriver() 
        : m_hDevice(0),
          m_ulCapturePinID(0),
          m_bDeviceRemoved(TRUE),  // Set to FALSE when graph is built.
          m_hRKeyMsVideoVfWWDM(0),
          m_hRKeySoftwareVfWWDM(0),
          m_hRKeyDevice(0),
          m_pMultItemsHdr(0)
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    DWORD dwNewOrExist;

    DWORD hr = RegCreateKeyEx(      
        HKEY_LOCAL_MACHINE,
        gszMsVideoVfWWDM,
        0,                       // Reserved
        NULL,                    // Object class
        REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE,
        NULL,                    // Security attribute
        &m_hRKeyMsVideoVfWWDM,
        &dwNewOrExist);


    // Get save device path
    if (m_hRKeyMsVideoVfWWDM == NULL) {
        DbgLog((LOG_TRACE,1,TEXT("RegCreateKeyEx() error %dL, Registry ..\\MediaResources\\msvideo\\MSVideo.VFWWDM does nto exist !!"), hr));
        DbgLog((LOG_TRACE,1,TEXT("         Has installation problem.  Contact your software/hardware provider.")  ));

    } else {

        // Get last Open's Device Path (Symbolic Link)
#if 0
        if (!GetSettingFromReg(m_hRKeyMsVideoVfWWDM, gszDevicePath, &m_szDevicePath[0]))
#else
        DWORD dwType, dwRegValueSize;
        if(ERROR_SUCCESS != QueryRegistryValue(m_hRKeyMsVideoVfWWDM, gszDevicePath, MAX_PATH, (LPBYTE) &m_szDevicePath[0], &dwType, &dwRegValueSize))
#endif
            ZeroMemory(m_szDevicePath, sizeof(m_szDevicePath));


        //
        // Application can programatically open a capture device by 
        // setting these registry values
        //
#if 0
        if (!GetSettingFromReg(m_hRKeyMsVideoVfWWDM, TARGET_DEVICE_FRIENDLY_NAME_TCHAR, &m_szTargetFriendlyName[0])) {
#else
        if(ERROR_SUCCESS != QueryRegistryValue(m_hRKeyMsVideoVfWWDM, TARGET_DEVICE_FRIENDLY_NAME_TCHAR, MAX_PATH, (LPBYTE) &m_szTargetFriendlyName[0], &dwType, &dwRegValueSize)) {
#endif
            ZeroMemory(m_szTargetFriendlyName, sizeof(m_szTargetFriendlyName));
            m_bTargetOpenExclusively = FALSE;

        } else {
#if 0
            m_bTargetOpenExclusively = GetSettingFromReg(m_hRKeyMsVideoVfWWDM, TARGET_DEVICE_OPEN_EXCLUSIVELY_TCHAR, (DWORD) FALSE);
#else
            DWORD dwOpenExcl;
            m_bTargetOpenExclusively = 
                ERROR_SUCCESS == QueryRegistryValue(m_hRKeyMsVideoVfWWDM, TARGET_DEVICE_OPEN_EXCLUSIVELY_TCHAR, sizeof(DWORD), (LPBYTE) &dwOpenExcl, &dwType, &dwRegValueSize);
#endif
        }

        DbgLog((LOG_TRACE,2,TEXT("<< Open Exclusively (%s); FriendlyName (%s) >>"),
            m_bTargetOpenExclusively ? "YES" : "NO", m_szTargetFriendlyName));
    }

}


CClassDriver::~CClassDriver()
/*++
Routine Description:

Argument:

Return Value:

--*/
{

     // Remove the data range data
    DestroyDriverSupportedDataRanges();

    if(m_hRKeyMsVideoVfWWDM) {
        RegCloseKey(m_hRKeyMsVideoVfWWDM);
        m_hRKeyMsVideoVfWWDM = NULL;
    }

    if(m_hRKeySoftwareVfWWDM) {
        RegCloseKey(m_hRKeySoftwareVfWWDM);
        m_hRKeySoftwareVfWWDM = NULL;
    }

    if(m_hRKeyDevice) {
        RegCloseKey(m_hRKeyDevice);
        m_hRKeyDevice = NULL;
    }
}

LONG CClassDriver::CreateDeviceRegKey(
    LPCTSTR lpcstrDevice
    )
{
    LONG hr;
    DWORD dwNewOrExist;

    //
    // Create it of if exist open it.
    //
    hr = RegCreateKeyEx(      
        HKEY_LOCAL_MACHINE,
        gszSoftwareVfWWDM,
        0,                       // Reserved
        NULL,                    // Object class
        REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY,
        NULL,                    // Security attribute
        &m_hRKeySoftwareVfWWDM,
        &dwNewOrExist);

    if(NOERROR != hr) {
        return hr;
    }

    //
    // Open individual device subkey
    //
    TCHAR * lpszDevTemp = (TCHAR *) new TCHAR[_tcslen(lpcstrDevice)+1];
    if(lpszDevTemp == 0)
       return ERROR_NOT_ENOUGH_MEMORY;

    _tcscpy(lpszDevTemp, lpcstrDevice);
    for(unsigned int i = 0; i < _tcslen(lpszDevTemp); i++) {
        // Replave invalid character
        if(lpszDevTemp[i] == '\\')
            lpszDevTemp[i] = '#';
    }

    hr = RegCreateKeyEx(      
         m_hRKeySoftwareVfWWDM,
         lpszDevTemp,
         0,                       // Reserved
         NULL,                    // Object class
         REG_OPTION_NON_VOLATILE,
         KEY_READ | KEY_WRITE | KEY_CREATE_LINK, // KEY_ALL_ACCESS,
         NULL,                    // Security attribute
         &m_hRKeyDevice,
         &dwNewOrExist);


    if(ERROR_SUCCESS == hr) {      

        DbgLog((LOG_TRACE,1,TEXT("CreateDeviceRegKey: %s %s"), 
           dwNewOrExist == REG_CREATED_NEW_KEY ? "<New>" : "<Exist>",
           lpcstrDevice));
      
     } else {
        DbgLog((LOG_TRACE,1,TEXT("CreateDeviceRegKey: error %x; %s"), hr, lpcstrDevice));       
     }

     delete [] lpszDevTemp;

     return hr;
}

#if 0
BOOL CClassDriver::SetSettingToReg(
    HKEY hKey,
    LPTSTR pszValueName, 
    DWORD dwNewValue)
/*++
Routine Description:
    
Argument:

Return Value:

--*/
{
    if(hKey) {
        if (RegSetValueEx(hKey,    // handle of key to set value for 
                (LPCTSTR) pszValueName,    // "ImageWidth",   // address of value to set 
                0,                        // reserved 
                REG_DWORD ,                // flag for value type 
                (CONST BYTE *) &dwNewValue, // (CONST BYTE *) &buf[0], // address of the value data
                sizeof(dwNewValue) // copy _tcslen(buf)+1            // size of value data
            ) == ERROR_SUCCESS) {
            return TRUE;
        } else {
            DbgLog((LOG_TRACE,1,TEXT("Cannot save Valuename(%s) to %d."), pszValueName, dwNewValue));
            return FALSE;
        }        
    } else
        return FALSE;
}


BOOL CClassDriver::SetSettingToReg(
    HKEY hKey,
    LPTSTR pszValueName, 
    LPTSTR pszValue)
/*++
Routine Description:

Argument:

Return Value:

--*/
{    
    if(hKey) {

        if (RegSetValueEx(hKey,    // handle of key to set value for 
                (LPCTSTR) pszValueName,    // address of value to set 
                0,                        // reserved 
                REG_SZ,                    // flag for value type 
                (CONST BYTE *) pszValue, // address of the value data
                _tcslen(pszValue)+1        // size of value data
            ) == ERROR_SUCCESS) {
            return TRUE;
        } else {

            DbgLog((LOG_TRACE,1,TEXT("Cannot save ValueName(%s) to %s."), pszValueName, pszValue));
            return FALSE;
        }        
    } else
        return FALSE;
}


DWORD CClassDriver::GetSettingFromReg(
    HKEY hKey,
    LPTSTR pszValueName, 
    DWORD dwDefValue)
/*++
Routine Description:
    
Argument:

Return Value:

--*/
{
    DWORD dwValue, dwType, dwByteXfer = sizeof(DWORD);

    
    if(hKey) {
        if (RegQueryValueEx(hKey,    // handle of key to set value for 
                (LPCTSTR) pszValueName,    // "ImageWidth",   // address of value to set 
                0,                        // reserved 
                &dwType,                // flag for value type 
                (LPBYTE) &dwValue,        // address of the value data
                &dwByteXfer             // point to xfer data size
            ) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD) {
                return dwValue;
            }
            else {
                DbgLog((LOG_TRACE,2,TEXT("Expect REG_DWORD for ValueName(%s) but got %ld"), pszValueName, dwType));
                return dwDefValue;
            }
        } else {
            DbgLog((LOG_TRACE,1,TEXT("Cannot query Valuename(%s) set to default %d."), pszValueName, dwDefValue));
            return dwDefValue;
        }        
    } else
        return dwDefValue;
}

BOOL CClassDriver::GetSettingFromReg(
    HKEY hKey,
    LPTSTR pszValueName, 
    LPTSTR pszValue)
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    DWORD dwType, dwByteXfer = MAX_PATH;
    
    if(hKey) {

        if (RegQueryValueEx(hKey,    // handle of key to set value for 
                (LPCTSTR) pszValueName,        // "ImageWidth",   // address of value to set 
                0,                        // reserved 
                &dwType,                // flag for value type 
                (LPBYTE) pszValue,        // address of the value data
                &dwByteXfer             // point to xfer data size
            ) == ERROR_SUCCESS) {
            if (dwType == REG_SZ) {
                return TRUE;
            }
            else {
                DbgLog((LOG_TRACE,2,TEXT("Expect REG_SZ for ValueName (%s) but got %ld"), pszValueName, dwType));
                return FALSE;  // Wrong Registry type
            }
        } else {
            DbgLog((LOG_TRACE,1,TEXT("Cannot get ValueName(%s)."), pszValueName));
            return FALSE;
        }        
    } else
        return FALSE;
}

#endif

LONG                          // return code (winerror.h)
CClassDriver::QueryRegistryValue(
    HKEY   hRegKey,           // registry key to query
    LPCSTR lpcstrValueName,   // value name
    DWORD  dwDataBufSize,     // data buffer size
    LPBYTE lpbDataBuf,        // address of data buffer
    DWORD * pdwValueType,     // return regitry value type
    DWORD * pdwValueSize      // size in byte of this reg value     
    )
/*++
Routine Description:
    Query the registry value of a given registry key.  
    It also support querying size of the registry value so that  
    calling fucntion can dynamically allocated it.
--*/
{
    LONG  lResult;
    
    if(!hRegKey || !lpcstrValueName || !pdwValueSize)
        return ERROR_INVALID_PARAMETER;

    // Get value size first to make sure sifficient buffer size
    lResult = RegQueryValueEx( hRegKey, lpcstrValueName, 0, pdwValueType, NULL, pdwValueSize);

    if(ERROR_SUCCESS == lResult) {
        // make sure that the data buffer is big enough
        if(*pdwValueSize <= dwDataBufSize) 
            // Again, this time with data buffer
            lResult = RegQueryValueEx( hRegKey, lpcstrValueName, 0, pdwValueType, lpbDataBuf, pdwValueSize);           
        else 
            lResult = dwDataBufSize == 0 ? lResult : ERROR_INSUFFICIENT_BUFFER;            
    } 
#if DBG
    if(ERROR_SUCCESS != lResult) {
        DbgLog((LOG_TRACE,1,TEXT("RegQueryValueEx of %s; rc %dL"), lpcstrValueName, lResult));
    }
#endif

    return lResult;
}


LONG                          // return code (winerror.h)
CClassDriver::SetRegistryValue(
    HKEY   hRegKey,           // registry key to query
    LPCSTR lpcstrValueName,   // value name
    DWORD  dwDataBufSize,     // data buffer size
    LPBYTE lpbDataBuf,        // address of data buffer
    DWORD  dwValueType        // value type  
    )
/*++
Routine Description:
    Set the registry value of a given registry key.  
--*/
{
    LONG  lResult;
    
    if(!hRegKey || !lpcstrValueName)
        return ERROR_INVALID_PARAMETER;

    lResult = RegSetValueEx( hRegKey, lpcstrValueName, 0, dwValueType, lpbDataBuf, dwDataBufSize);
#if DBG
    if(ERROR_SUCCESS != lResult) {
        DbgLog((LOG_ERROR,1,TEXT("RegSetValueEx of %s; Type %d; rc %dL"), lpcstrValueName, dwValueType, lResult));
    }
#endif
    return lResult;
}

 

BOOL CClassDriver::WriteDevicePath() 
/*++
Routine Description:

Argument:

Return Value:

--*/
{

    // Persist last open device
#if 0
    return (SetSettingToReg(m_hRKeyMsVideoVfWWDM, gszDevicePath, &m_szDevicePath[0]));
#else
    return ERROR_SUCCESS == SetRegistryValue(m_hRKeyMsVideoVfWWDM, gszDevicePath, _tcslen(m_szDevicePath)+1, (LPBYTE) &m_szDevicePath[0], REG_SZ);
#endif
}


//  
// Get all the default data range fot the opened device
//
ULONG CClassDriver::CreateDriverSupportedDataRanges()
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    KSP_PIN KsProperty={0};
    ULONG    cbReturned;

    if(m_pMultItemsHdr) {
        DbgLog((LOG_TRACE,2,TEXT("DataRange is already allocated.")));
        return m_pMultItemsHdr->Count;
    }

    //
    // Ioctl to get data ranges
    //
    KsProperty.PinId          = GetCapturePinID(); 
    KsProperty.Property.Set   = KSPROPSETID_Pin;
    KsProperty.Property.Id    = KSPROPERTY_PIN_DATARANGES ;
    KsProperty.Property.Flags = KSPROPERTY_TYPE_GET;

    //
    // Get the size
    //
    ULONG dwSize=0;
    if(NOERROR != SyncDevIo(
            GetDriverHandle(),
            IOCTL_KS_PROPERTY,
            &KsProperty,
            sizeof( KsProperty ),
            &dwSize,
            sizeof(dwSize),
            &cbReturned)) {

        DbgLog((LOG_TRACE,1,TEXT("Couldn't get the size for the data ranges") ));
        return 0;
    }

    DbgLog((LOG_TRACE,2,TEXT("GetData ranges needs %d"),dwSize));

    m_pMultItemsHdr = (PKSMULTIPLE_ITEM) new BYTE[dwSize];

    if(m_pMultItemsHdr != NULL) {    
    
        if( NOERROR != SyncDevIo(
                GetDriverHandle(),
                IOCTL_KS_PROPERTY,
                &KsProperty,
                sizeof( KsProperty ),
                m_pMultItemsHdr,
                dwSize,
                &cbReturned)) {

            delete [] m_pMultItemsHdr;
            DbgLog((LOG_TRACE,1,TEXT("Problem getting the data ranges themselves")));
            return 0;
        }

        if(cbReturned < m_pMultItemsHdr->Size || m_pMultItemsHdr->Count == 0) {
            DbgLog((LOG_TRACE,1,TEXT("cbReturned < m_pMultItemsHdr->Size || m_pMultItemsHdr->Count == 0")));
            ASSERT(cbReturned == m_pMultItemsHdr->Size && m_pMultItemsHdr->Count > 0);
            delete [] m_pMultItemsHdr;        
            return 0;
        }
    } else {
        DbgLog((LOG_TRACE,1,TEXT("Insufficient resource!")));
        return 0;
    }

    ASSERT(m_pMultItemsHdr->Count > 0);
    // >= because KS_DATARANGE_VIDEO2 > KS_DATARANGE_VIDEO
    ASSERT(m_pMultItemsHdr->Size >= (sizeof(ULONG) * 2 + m_pMultItemsHdr->Count * sizeof(KS_DATARANGE_VIDEO)) );


    DbgLog((LOG_TRACE,1,TEXT("GetDataRange: %x, size %d, count %d, pData 0x%x; sizeoof(KS_DATARANGE_VIDEO) %d, sizeoof(KS_DATARANGE_VIDEO2) %d"),
        m_pMultItemsHdr, m_pMultItemsHdr->Size, m_pMultItemsHdr->Count, (m_pMultItemsHdr+1),
        sizeof(KS_DATARANGE_VIDEO), sizeof(KS_DATARANGE_VIDEO2) ));

    return m_pMultItemsHdr->Count;
}


void 
CClassDriver::DestroyDriverSupportedDataRanges()
{
    if (m_pMultItemsHdr) {
        delete [] m_pMultItemsHdr;
        m_pMultItemsHdr = 0;
    }
}


void 
CClassDriver::SetDeviceHandle(
    HANDLE hDevice,
    ULONG ulCapturePinID)                                   
{
    m_hDevice = hDevice;
    m_ulCapturePinID = ulCapturePinID;

    SetDeviceRemoved(FALSE);

    // and back it up; now they are the same.
    BackupDevicePath();    
    WriteDevicePath();

    if(CreateDriverSupportedDataRanges() == 0) { 
        DbgLog((LOG_TRACE,1,TEXT("Fail to query its data range.") ));    
        //return VFW_VIDSRC_PIN_OPEN_FAILED;
    } 

}


#define SYNCDEVIO_MAXWAIT_MSEC 20000   // unit = msec

HRESULT 
CClassDriver::SyncDevIo( 
    HANDLE hFile, 
    DWORD dwIoControlCode,    
    LPVOID lpInBuffer,    
    DWORD nInBufferSize,
    LPVOID lpOutBuffer, 
    DWORD nOutBufferSize, 
    LPDWORD lpBytesReturned
    )
/*++
Routine Description:

    Does overlapped IO and create the event for you.  This is a Synchronous because we wait 
    for the completion of the DevIo or TimeOUT after a fix amount of time.

    TimeOut is dangerous but once it has happened, we set the streamign state to STOP
    to reclaim the buffer.

Argument:

Return Value:

--*/
{
    DWORD dwLastError; 
    HRESULT hr = NOERROR;
    OVERLAPPED * pOv;

    if(GetDeviceRemoved())
       return ERROR_DEVICE_REMOVED; 

    if(!hFile || hFile ==(HANDLE)-1 ) {
        DbgLog((LOG_TRACE,1,TEXT("Invalid hFile=0x%x DevIo return FALSE"), hFile));
        return ERROR_INVALID_HANDLE;
    }

    pOv = (OVERLAPPED *) 
        VirtualAlloc(
            NULL, 
            sizeof(OVERLAPPED),          
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE);

    if(!pOv) {
        DbgLog((LOG_ERROR,0,TEXT("SyncDevIo: Allocate Overlap failed.")));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    pOv->Offset     = 0;
    pOv->OffsetHigh = 0;
    pOv->hEvent     = CreateEvent(NULL, TRUE, FALSE, NULL );
    if(pOv->hEvent == INVALID_HANDLE_VALUE) {
        DbgLog((LOG_TRACE,1,TEXT("CreateEvent has failed.")));
        dwLastError = GetLastError();
        VirtualFree(pOv, 0 , MEM_RELEASE);
        pOv = 0;
        return HRESULT_FROM_WIN32(dwLastError);
    }
        
    if(!DeviceIoControl( 
        hFile, 
        dwIoControlCode, 
        lpInBuffer, 
        nInBufferSize, 
        lpOutBuffer, 
        nOutBufferSize, 
        lpBytesReturned, 
        pOv)) {

        dwLastError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwLastError);
        if(hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            DWORD dwRtn = 
               WaitForSingleObject( pOv->hEvent, SYNCDEVIO_MAXWAIT_MSEC);  // INFINITE);
            if(dwRtn != WAIT_OBJECT_0) { 
                if(CancelIo(hFile)) {
                    CloseHandle(pOv->hEvent);
                    VirtualFree(pOv, 0 , MEM_RELEASE);
                    pOv = 0;
                    DbgLog((LOG_TRACE,1,TEXT("SyncDevIo: Waited %d msec, TIMEDOUT, but CancelIo() suceeded."), SYNCDEVIO_MAXWAIT_MSEC));
                    return ERROR_CANCELLED;
                } else {
                   // Not knowing when this will return,
                   // we will not close the handle or free the memory
                   DbgLog((LOG_ERROR,1,TEXT("SyncDevIo: Waited %d msec, TIMEDOUT!, CancelIo failed, Error %dL"), SYNCDEVIO_MAXWAIT_MSEC, GetLastError() ));
                   ASSERT(FALSE);
                   return ERROR_IO_INCOMPLETE;
                }
            }

            if(GetOverlappedResult(hFile, pOv, lpBytesReturned, TRUE)) {
                hr = NOERROR;
            } else {
                dwLastError = GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastError);
            }
        } else if(hr == ERROR_DEVICE_REMOVED) {
            SetDeviceRemoved(TRUE);
            DbgLog((LOG_TRACE,1,TEXT("SyncDevIo: Device has been removed; GetLastError %dL == ERROR_DEVICE_REMOVED %d"), hr, ERROR_DEVICE_REMOVED));
        } else {            
            DbgLog((LOG_ERROR,1,TEXT("SyncDevIo: Unexpected hr %dL"), HRESULT_CODE(hr) ));
        }
    } else {
        //
        // DeviceIoControl returns TRUE on success, even if the success
        // was not STATUS_SUCCESS. It also does not set the last error
        // on any successful return. Therefore any of the successful
        // returns which standard properties can return are not returned.
        //
        switch (pOv->Internal) {
        case STATUS_MORE_ENTRIES:
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            break;
        default:
            hr = NOERROR;
            break;
        }
    }
    CloseHandle(pOv->hEvent);
    VirtualFree(pOv, 0 , MEM_RELEASE);
    pOv = 0;
    return hr;           
}


BOOL CClassDriver::GetPropertyValue(
    GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    PLONG  plValue,
    PULONG pulFlags,
    PULONG pulCapabilities)
/*++
Routine Description:

Argument:

Return Value:
    FALSE: not supported.
    TRUE: plValue, pulFlags and PulCapabilities are all valid.

--*/
{
    ULONG cbReturned;        

    // -----------------------------
    // Get single PROCAMP value back
    // -----------------------------
    //
    // Note: KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S 
    //
      KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;
    ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

    VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
    VideoProperty.Flags          = 0;

    if(NOERROR != SyncDevIo(
            GetDriverHandle(),
            IOCTL_KS_PROPERTY,
            &VideoProperty,
            sizeof(VideoProperty),
            &VideoProperty,
            sizeof(VideoProperty),
            &cbReturned)) {

            DbgLog((LOG_TRACE,2,TEXT("This property is not supported by this minidriver/device.")));
            return FALSE;
        }

    *plValue         = VideoProperty.Value;
    *pulFlags        = VideoProperty.Flags;
    *pulCapabilities = VideoProperty.Capabilities;


    return TRUE;
}


BOOL CClassDriver::GetDefaultValue(
    GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    PLONG  plDefValue)    
/*++
Routine Description:

Argument:

Return Value:
    FALSE: not supported.
    TRUE: plDefValue is valid.

--*/
{
    KSPROPERTY          Property;
    PROCAMP_MEMBERSLIST proList;
    ULONG cbReturned;        

    ZeroMemory(&Property, sizeof(KSPROPERTY) );
    ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST) );

    Property.Set   = guidPropertySet;
    Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;


    if(NOERROR != SyncDevIo(
            GetDriverHandle(),
            IOCTL_KS_PROPERTY,
            &(Property),
            sizeof(Property),
            &proList, 
            sizeof(proList), 
            &cbReturned)) {

            DbgLog((LOG_TRACE,2,TEXT("Couldn't *get* the current property of the control.")));
            return FALSE;
        }

    if ( proList.proDesc.DescriptionSize < sizeof(KSPROPERTY_DESCRIPTION))
        return FALSE;
    else {
        *plDefValue = proList.ulData;
        return TRUE;
    }
}


BOOL CClassDriver::GetRangeValues(
    GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    PLONG  plMin,
    PLONG  plMax,
    PLONG  plStep)
/*++
Routine Description:

Argument:

Return Value:
    FALSE; not supported.
    TRUE: 
--*/
{
    KSPROPERTY          Property;
    PROCAMP_MEMBERSLIST proList;
    ULONG cbReturned;        

    ZeroMemory(&Property, sizeof(KSPROPERTY) );
    ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST) );

    Property.Set   = guidPropertySet;
    Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;


    if (NOERROR != SyncDevIo(
            GetDriverHandle(),
            IOCTL_KS_PROPERTY,
            &(Property),
            sizeof(Property),
            &proList, 
            sizeof(proList), 
            &cbReturned)) {

            // Initialize them to 0
            *plMin  = 0;
            *plMax  = 0;
            *plStep = 0;

            DbgLog((LOG_TRACE,2,TEXT("Couldn't *get* the current property of the control.")));
            return FALSE;
        }


    *plMin  = proList.proData.Bounds.SignedMinimum;
    *plMax  = proList.proData.Bounds.SignedMaximum;
    *plStep = proList.proData.SteppingDelta;

    return TRUE;
}



BOOL CClassDriver::SetPropertyValue(
    GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    LONG   lValue,
    ULONG  ulFlags,
    ULONG  ulCapabilities)
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    ULONG cbReturned;        

    // -----------------------------
    // Get single PROCAMP value back
    // -----------------------------
    //
    // Note: KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S 
    //
      KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;

    ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

    VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;

    VideoProperty.Flags        = ulFlags;
    VideoProperty.Value        = lValue;
    VideoProperty.Capabilities = ulCapabilities;

    if(NOERROR != SyncDevIo(
            GetDriverHandle(),
            IOCTL_KS_PROPERTY,
            &VideoProperty,
            sizeof(VideoProperty),
            &VideoProperty,
            sizeof(VideoProperty),
            &cbReturned)) {

            DbgLog((LOG_TRACE,2,TEXT("Couldn't *set* the current property of the control.") ));
            return FALSE;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\cap.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    cap.cpp

Abstract:

    This really is a C file and is the front end to DVM_STREAM_ messages

Author:

    Yee J. Wu (ezuwu) 1-April-98

Environment:

    User mode only

Revision History:

--*/


#include "pch.h"
#include "talk.h"



/****************************************************************************
 *
 *   cap.c
 *
 *   Main video capture module. Main capture ISR.
 *
 *   Microsoft Video for Windows Sample Capture Driver
 *   Chips & Technologies 9001 based frame grabbers.
 *
 *   Copyright (c) 1992-1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/


#include <mmddk.h>



/****************************************************************************
 *  videoCallback()  This calls DriverCallback for the input stream
 *
 *  msg		 The message to send.
 *
 *  dw1		Message-dependent parameter.
 *
 * There is no return value.
 ***************************************************************************/

void PASCAL videoCallback(PCHANNEL pChannel, WORD msg, DWORD_PTR dw1)
{
    // invoke the callback function, if it exists.  dwFlags contains driver-
    // specific flags in the LOWORD and generic driver flags in the HIWORD
    DbgLog((LOG_TRACE,3,TEXT("videoCallback=%lx with dwFlags=%x"),
		       pChannel->vidStrmInitParms.dwCallback, HIWORD(pChannel->vidStrmInitParms.dwFlags)));

    if(pChannel->vidStrmInitParms.dwCallback) {
        if(!DriverCallback (
                pChannel->vidStrmInitParms.dwCallback,        // client's callback DWORD
                HIWORD(pChannel->vidStrmInitParms.dwFlags),   // callback flags
                (struct HDRVR__ *) pChannel->vidStrmInitParms.hVideo,   // handle to the device
                msg,                                          // the message
                pChannel->vidStrmInitParms.dwCallbackInst,    // client's instance data
                dw1,                                          // first DWORD
                0)) {                                         // second DWORD not used

            DbgLog((LOG_TRACE,1,TEXT("DriverCallback():dwCallBack=%lx;dwFlags=%x; msg=%x;dw1=%1p has failed."),
                    pChannel->vidStrmInitParms.dwCallback, HIWORD(pChannel->vidStrmInitParms.dwFlags), msg,dw1));
        }
    } else {
        DbgLog((LOG_TRACE,1,TEXT("m_VidStrmInitParms.dwCallback is NULL")));
    }
}



DWORD PASCAL InStreamGetError(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
/*++
 This function implements the DVM_STREAM_GETERROR message.
 Return the number of frames skipped to date.  This count will be
 inaccurate if the frame rate requested is over 15fps.
--*/
{

    // lParam1: DWORD(addr): most recent error
    // lParam2: DWORD(addr): number of frame dropped
    if(!lParam1){
        DbgLog((LOG_TRACE,1,TEXT("lParam1 for DVM_STREAM_GETERROR is NULL; rtn DV_ERR_PARAM1 !")));
        return DV_ERR_PARAM1;
    }

    if(!lParam2){
        DbgLog((LOG_TRACE,1,TEXT("lParam1 for DVM_STREAM_GETERROR is NULL; rtn DV_ERR_PARAM2 !")));
        return DV_ERR_PARAM2;
    }

    CVFWImage * pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
    return pCVfWImage->VideoStreamGetError(lParam1,lParam2);
}





DWORD PASCAL InStreamGetPos(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
/*++
 This function implements the DVM_STREAM_GETPOSITION message.
 Return the current stream time from the start of capture based
 on the number of vsync interrupts.
--*/
{
    // lParam1: &MMTIME
    // lParam2: sizeof(MMTIME)

    if(!lParam1){
        DbgLog((LOG_TRACE,1,TEXT("lParam1 for DVM_STREAM_GETERROR is NULL; rtn DV_ERR_PARAM1 !")));
        return DV_ERR_PARAM1;
    }

    if((DWORD)lParam2 != sizeof(MMTIME)){
        DbgLog((LOG_TRACE,1,TEXT("lParam2 != sizeof(MMTIME), =%d; rtn DV_ERR_PARAM2 !")));
        return DV_ERR_PARAM2;
    }

    CVFWImage * pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
    return pCVfWImage->VideoStreamGetPos(lParam1,lParam2);
}



DWORD PASCAL InStreamInit(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
/*++
 Implement DVM_STREAM_INIT message; it initializes a video device for streaming.
--*/
{
    DWORD dwRtn;
    LPVIDEO_STREAM_INIT_PARMS lpStreamInitParms;
#ifdef WIN32
    CVFWImage * pCVfWImage;
#endif

    lpStreamInitParms = (LPVIDEO_STREAM_INIT_PARMS) lParam1;

    switch (pChannel->dwOpenType) {

    case VIDEO_IN:
        if(pChannel->bVideoOpen) {
            DbgLog((LOG_TRACE,1,TEXT("!!!DVM_STREAM_INIT: strem/bVideoOpen is alreay open! rtn DV_ERR_NONSPECIFIC.")));
            return DV_ERR_NONSPECIFIC;
        }

        if(sizeof(VIDEO_STREAM_INIT_PARMS) != (DWORD) lParam2) {
            DbgLog((LOG_TRACE,1,TEXT("!!! sizeof(LPVIDEO_STREAM_INIT_PARMS)(=%d) != (DWORD) lParam2 (=%d)"), sizeof(LPVIDEO_STREAM_INIT_PARMS), (DWORD) lParam2));
        }

        // lParam1: &VIDEO_STREAM_INIT_PARMS
        // lParam2: sizeof(VIDEO_STREAM_INIT_PARMS)
        pChannel->vidStrmInitParms   = *lpStreamInitParms;

        DbgLog((LOG_TRACE,2,TEXT("InStreamInit:==> dwCallBack=%lx;dwFlags=%x; ?= 5(EVENT)"),
              pChannel->vidStrmInitParms.dwCallback, HIWORD(pChannel->vidStrmInitParms.dwFlags)));

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        dwRtn = pCVfWImage->VideoStreamInit(lParam1,lParam2);

        if(dwRtn == DV_ERR_OK) {
            pChannel->bVideoOpen = TRUE;
            ASSERT(pChannel->dwVHdrCount == 0);
            ASSERT(pChannel->lpVHdrHead == 0);
        }
        return dwRtn;


    case VIDEO_EXTERNALIN:
        DbgLog((LOG_TRACE,2,TEXT("StreamInit+VID_EXTIN: this channel is on when it was first open.")));
        return DV_ERR_OK;


    case VIDEO_EXTERNALOUT:
        DbgLog((LOG_TRACE,2,TEXT("StreamInit+VID_EXTOUT: this overlay channel is request to be ON.")));
        pChannel->dwState = KSSTATE_RUN;

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

        if(pCVfWImage->StreamReady()) {
            HWND hClsCapWin;

            hClsCapWin = pCVfWImage->GetAvicapWindow();
            // If STREAM_INIT, set it visible;
            // if STREAM_FINI, remove its ownership and make it invisible.
            DbgLog((LOG_TRACE,2,TEXT("WM_1632_OVERLAY: >>>> <ON> hClsCapWin %x"), hClsCapWin));

            if(!pCVfWImage->IsOverlayOn()) {

                // If this is a AVICAP client, then we know its client window handle.
                if(hClsCapWin) {
                    DbgLog((LOG_TRACE,2,TEXT("A AVICAP client; so set its ClsCapWin(%x) as owner with (0x0, %d, %d)"), hClsCapWin, pCVfWImage->GetbiWidth(), pCVfWImage->GetbiHeight()));
                    pCVfWImage->BGf_OwnPreviewWindow(hClsCapWin, pCVfWImage->GetbiWidth(), pCVfWImage->GetbiHeight());
                }
                dwRtn = pCVfWImage->BGf_SetVisible(TRUE);

                pCVfWImage->SetOverlayOn(TRUE);
            }

        } else
            dwRtn = DV_ERR_OK;

    case VIDEO_OUT:
    default:
        return DV_ERR_NOTSUPPORTED;
    }
}


void PASCAL StreamReturnAllBuffers(PCHANNEL pChannel)
{
    WORD i;
    LPVIDEOHDR lpVHdr, lpVHdrTemp;

    if(pChannel->dwVHdrCount == 0)
        return;

    // Return any buffer in our possession
	   DbgLog((LOG_TRACE,2,TEXT("StreamReturnAllBuffers: returning all VideoHdr(s)")));
	   for(i=0, lpVHdr=pChannel->lpVHdrHead;i<pChannel->dwVHdrCount;i++) {

#ifndef WIN32
		      lpVHdrTemp = (LPVIDEOHDR) lpVHdr->dwReserved[0];   // Next->16bitAddr
#else
		      lpVHdrTemp = (LPVIDEOHDR) lpVHdr->dwReserved[1];   // Next->32bitAddr
#endif
        if(lpVHdr->dwFlags & VHDR_INQUEUE) {
            lpVHdr->dwFlags &= ~VHDR_INQUEUE;
            lpVHdr->dwFlags |= VHDR_DONE;
            videoCallback(pChannel, MM_DRVM_DATA, (DWORD_PTR) lpVHdr);
        }
        lpVHdr->dwReserved[0] = lpVHdr->dwReserved[1] = lpVHdr->dwReserved[2] = 0;
        if(0 == (lpVHdr = lpVHdrTemp)) break;
    }

    pChannel->lpVHdrHead = pChannel->lpVHdrTail = 0;
    pChannel->dwVHdrCount = 0;
}


DWORD PASCAL InStreamFini(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
/*++
 Implement DVM_STREAM_FINI message; it notify a video capture driver to
 terminate streaming on a video channel.
--*/
{
    DWORD dwRtn;
#ifdef WIN32
    CVFWImage * pCVfWImage;
#endif

    switch (pChannel->dwOpenType) {

    case VIDEO_IN:

        if(!pChannel->bVideoOpen) {
            DbgLog((LOG_TRACE,1,TEXT("InStreamClose: But stream/g_fVieoOpen is NULL. rtn DV_ERR_NONSPECIFIC")));
            return DV_ERR_NONSPECIFIC;
        }
        pChannel->bVideoOpen = FALSE;

        DbgLog((LOG_TRACE,2,TEXT("InStreamClose on VIDEO_IN channel:")));
        // lParam1: N/U
        // lParam2: N/U
        if(pChannel->dwState == KSSTATE_RUN) {
           dwRtn = DV_ERR_STILLPLAYING;
           DbgLog((LOG_TRACE,1,TEXT("InStreamFini: !!! Resetting but still in RUN state, stop the streaming first.")));

           // Stop the stream; tell 32bit to stop streaming.
           InStreamStop(pChannel, lParam1, lParam2);
        }

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        dwRtn = pCVfWImage->VideoStreamFini();

        //
        // Return any buffer in our possession
        //
        StreamReturnAllBuffers(pChannel);
        DbgLog((LOG_TRACE,2,TEXT("InStreamClose on VIDEO_IN channel:done!")));
        return dwRtn;

    case VIDEO_EXTERNALIN:
        // Unless the kernel driver is doing double buffer, it trigger no action.
        DbgLog((LOG_TRACE,2,TEXT("StreamFini+VID_EXTIN: rtn DV_ERR_OK.")));
        return DV_ERR_OK;

    case VIDEO_EXTERNALOUT:
        // E-Zu: need to turn on and off the overlay to the application window.
        DbgLog((LOG_TRACE,2,TEXT("StreamFini+VID_EXTOUT: State %d, if %d, send 1632_OVERLAY to FALSE."), pChannel->dwState, KSSTATE_RUN));

        if(pChannel->dwState != KSSTATE_RUN)
            return DV_ERR_NONSPECIFIC;

        pChannel->dwState = KSSTATE_STOP;

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

        if(pCVfWImage->StreamReady()) {
            HWND hClsCapWin;

            hClsCapWin = pCVfWImage->GetAvicapWindow();
            // If STREAM_INIT, set it visible;
            // if STREAM_FINI, remove its ownership and make it invisible.
            DbgLog((LOG_TRACE,2,TEXT("WM_1632_OVERLAY: >>>> <OFF> hClsCapWin %x"), hClsCapWin));

            if(pCVfWImage->IsOverlayOn()) {
                // If this is a AVICAP client, then we know its client window handle.
                dwRtn = pCVfWImage->BGf_SetVisible(FALSE);
                pCVfWImage->SetOverlayOn(FALSE);
            }

        } else
            dwRtn = DV_ERR_OK;

        return DV_ERR_OK;

    case VIDEO_OUT:
    default:
        return DV_ERR_NOTSUPPORTED;
    }

}


BOOL PASCAL QueHeader(PCHANNEL pChannel, LPVIDEOHDR lpVHdrNew)
{
    ASSERT(pChannel != NULL);
    ASSERT(lpVHdrNew != NULL);

    if(pChannel == NULL || lpVHdrNew == NULL){
        DbgLog((LOG_TRACE,1,TEXT("pChannel=NULL || Adding lpVHdr==NULL. rtn FALSE")));
        return FALSE;
    }

    if(pChannel->dwState == KSSTATE_STOP) {
        // This is done to achieve binary compatible between Win98 and NT version.
        // This will not work when pointer is 64 bits!
        lpVHdrNew->dwReserved[2] = (DWORD_PTR) lpVHdrNew->lpData;

        if(pChannel->lpVHdrHead == 0){
            pChannel->lpVHdrHead = pChannel->lpVHdrTail = lpVHdrNew;
            lpVHdrNew->dwReserved[0] = 0;
            lpVHdrNew->dwReserved[1] = 0;
        } else {

            pChannel->lpVHdrTail->dwReserved[0] = 0;                        // Not used.
            pChannel->lpVHdrTail->dwReserved[1] = (DWORD_PTR)lpVHdrNew;     // Next->32bit address
            pChannel->lpVHdrTail = lpVHdrNew;
        }

        lpVHdrNew->dwFlags &= ~VHDR_DONE;
        lpVHdrNew->dwFlags |= VHDR_INQUEUE;
        lpVHdrNew->dwBytesUsed = 0;  // It should be already initilzed.
        pChannel->dwVHdrCount++;

    } else if(pChannel->dwState == KSSTATE_RUN) {
        lpVHdrNew->dwFlags &= ~VHDR_DONE;
        lpVHdrNew->dwFlags |= VHDR_INQUEUE;
        lpVHdrNew->dwBytesUsed = 0;  // It should be already initilzed.

    } else {
        DbgLog((LOG_TRACE,1,TEXT("Unknow streaming state!! cannot add this buffer.")));
        return FALSE;
    }

    return TRUE;
}

DWORD PASCAL InStreamAddBuffer(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
/*++
 Implement DVM_STREAM_ADDBUFFER message; it notify a video capture driver to
 fill an input buffer with video data and return the full buffer to the
 client aplication.
--*/
{
    LPVIDEOHDR lpVHdr = (LPVIDEOHDR) lParam1;

    if(pChannel->dwOpenType != VIDEO_IN) {
        return DV_ERR_NOTSUPPORTED;
    }

    if(!pChannel->bVideoOpen) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamAddBuffer: but Stream is not yet open! rtn DV_ERR_NONSPECIFIC")));
        return DV_ERR_NONSPECIFIC;
    }

    /* return error if no node passed */
    if (!lpVHdr) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamAddBuffer: but LPVIDEOHDR is empty! rtn DV_ERR_PARAM1")));
        return DV_ERR_PARAM1;
    }

    /* return error if buffer has not been prepared */
    if (!(lpVHdr->dwFlags & VHDR_PREPARED)) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamAddBuffer: but LPVIDEOHDR is not VHDR_PREPARED! rtn DV_ERR_UNPREPARED")));
        return DV_ERR_UNPREPARED;
    }

    /* return error if buffer is already in the queue */
    if (lpVHdr->dwFlags & VHDR_INQUEUE) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamAddBuffer: but buffer is already in the queueVHDR_INQUEUE! rtn DV_ERR_NONSPECIFIC")));
        return DV_ERR_NONSPECIFIC;
    }

    if (lpVHdr->dwBufferLength < pChannel->lpbmiHdr->biSizeImage) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamAddBuffer: but buffer size(%d) is smaller than expected(%d)! rtn DV_ERR_NONSPECIFIC"), lpVHdr->dwBufferLength, pChannel->lpbmiHdr->biSizeImage));
        return DV_ERR_NONSPECIFIC;
    }


    // lParam1: &VIDEOHDR
    // lParam2: sizeof(VIEOHDR)

    QueHeader(pChannel, lpVHdr);
    return DV_ERR_OK;
}


void
_loadds
CALLBACK
TimerCallbackProc(
                  UINT  uiTimerID,
                  UINT  uMsg,
                  DWORD_PTR dwUser,
                  DWORD dw1,
                  DWORD dw2
                  )
{
	   PCHANNEL pChannel;
	   BOOL bCallback = FALSE;
	   LPVIDEOHDR lpVHdr;
    WORD i;


	   pChannel = (PCHANNEL) dwUser;
	   ASSERT(pChannel != 0);
	   if(pChannel==0) {
		      DbgLog((LOG_TRACE,1,TEXT("TimerCallbackProc: pChannel is NULL")));
		      return;
	   }

	   lpVHdr = pChannel->lpVHdrHead;

    //ASSERT(lpVHdr != 0);
    if(!lpVHdr) {
        DbgLog((LOG_TRACE,1,TEXT("TimerCallbackProc: pChannel->lpVHdrHead is NULL!")));
        return;
    }


	   // Why should we care about if there are data of not, just wait up Avicap.
    for (i=0; i<pChannel->dwVHdrCount;i++) {

       if(lpVHdr->dwFlags & VHDR_DONE){
            bCallback = TRUE;
            break;
       } else {
#ifndef WIN32
            lpVHdr = (LPVIDEOHDR)lpVHdr->dwReserved[0];   // Next->16bitAddr
#else
            lpVHdr = (LPVIDEOHDR)lpVHdr->dwReserved[1];   // Next->32bitAddr
#endif
       }
    }

    if(bCallback)
       videoCallback(pChannel, MM_DRVM_DATA, 0); // (DWORD) lpVHdr);
}



DWORD PASCAL InStreamStart(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
/*++
 Implement DVM_STREAM_START message; it notifies a video capture driver
 to start a video stream.
--*/
{
    DWORD dwRtn;

    if(pChannel->dwOpenType != VIDEO_IN) {
        DbgLog((LOG_TRACE,1,TEXT("DVM_STREAM_START+unsupported channel %d; rtn DV_ERR_NOTSUPPORTED"), pChannel->dwOpenType));
        return DV_ERR_NOTSUPPORTED;
    }

    DbgLog((LOG_TRACE,2,TEXT("InStreamStart(): Telling 32bit buddy to start streaming to us")));
	
    if(!pChannel->bVideoOpen) {
        DbgLog((LOG_TRACE,2,TEXT("Ask to start but bVieoOpen is FALSE! rtn DV_ERR_NONSPECIFIC.")));
        return DV_ERR_NONSPECIFIC;
    }

    ASSERT(pChannel->dwVHdrCount>0);
    ASSERT(pChannel->lpVHdrHead != 0);
    ASSERT(pChannel->lpVHdrTail != 0);

    // lParam1: N/U
    // lParam2: N/U
    if(pChannel->dwVHdrCount == 0) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamStart: No buffer; rtn DV_ERR_NONSPECIFIC. ")));
        return DV_ERR_NONSPECIFIC;
    }

    //
    // Make a circular queue: tail->head
    // dwReserved[0] 16bitAddress
    // dwReserved[1] 32bitAddress
    //
    pChannel->lpVHdrTail->dwReserved[1] = (DWORD_PTR) pChannel->lpVHdrHead;

    CVFWImage * pCVfWImage;
    pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
    dwRtn = pCVfWImage->VideoStreamStart(pChannel->dwVHdrCount, pChannel->lpVHdrHead);
    pChannel->dwState = KSSTATE_RUN;

    return dwRtn;
}




DWORD PASCAL InStreamStop(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
/*++
 Implement DVM_STREAM_STOP message; it notifies a video capture driver
 to stop a video stream; finish last buffer if needed.
--*/
{
	   DWORD dwRtn;

    if(pChannel->dwOpenType != VIDEO_IN) {
        DbgLog((LOG_TRACE,1,TEXT("DVM_STREAM_STOP+unsupported channel %d; rtn DV_ERR_NOTSUPPORTED"), pChannel->dwOpenType));
        return DV_ERR_NOTSUPPORTED;
    }

    if(!pChannel->bVideoOpen) {
	       DbgLog((LOG_TRACE,1,TEXT("InStreamStop: but there is not stream/bVideoOpen(FALSE) to stop! rtn DV_ERR_NONSPECIFIC")));
        return DV_ERR_NONSPECIFIC;
    }

#ifndef WIN32 // VfWImg.cpp will do the callback for 32bit buddy
	   // Stop schedule timer callback.
	   timeKillEvent(pChannel->hTimer);
	   pChannel->hTimer = 0;
#endif

    pChannel->dwState = KSSTATE_STOP;

    // lParam1: N/U
    // lParam2: N/U
#ifndef WIN32
    dwRtn = SendBuddyMessage(pChannel,WM_1632_STREAM_STOP,0,0);
#else
    CVFWImage * pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
    dwRtn = pCVfWImage->VideoStreamStop();
#endif

	return dwRtn;
}




/*
 *
 * Reset the buffers so that they may be unprepared and freed
 * This function implements the DVM_STREAM_RESET message.
 * Stop Streaming and release all buffers.
 *
 */
DWORD PASCAL InStreamReset(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    if(pChannel->dwOpenType != VIDEO_IN) {
        DbgLog((LOG_TRACE,1,TEXT("DVM_STREAM_RESET+unsupported channel %d; rtn DV_ERR_NOTSUPPORTED"), pChannel->dwOpenType));
        return DV_ERR_NOTSUPPORTED;
    }

    if(!pChannel->bVideoOpen) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamReset: stream/bVideoOpen(FALSE) is not yet open. rtn DV_ERR_NONSPECIFIC.")));
        return DV_ERR_NONSPECIFIC;
    }

    // We are asked to reset,
    // need to take care of the case that we might still in the RUN state!!
    if(pChannel->dwState == KSSTATE_RUN) {
        DbgLog((LOG_TRACE,1,TEXT("InStreamReset: !!! Resetting but still in RUN state, stop the streamign first.")));

        // Stop the stream; tell 32bit to stop streaming.
        InStreamStop(pChannel, lParam1, lParam2);
    }

    //
    // NOTE: (for 16bit)Need to make sure that the 32bit side AGREE that all the buffers are gone!!
    //
    // lParam1: N/U
    // lParam2: N/U
	   DbgLog((LOG_TRACE,2,TEXT("InStreamReset: returning all VideoHdr(s)")));

    //
    // Return any buffer in our possession
    //
    StreamReturnAllBuffers(pChannel);

    return DV_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\clsdrv.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ClsDrv.h

Abstract:

    Header file for ClsDrv.cpp

Author:

    FelixA 1996
    
Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/


#ifndef _CLSDRV_H
#define _CLSDRV_H


//
// Used to query/set property values and ranges
//
typedef struct {
    KSPROPERTY_DESCRIPTION      proDesc;
    KSPROPERTY_MEMBERSHEADER  proHdr;
    union {
        KSPROPERTY_STEPPING_LONG  proData;
        ULONG ulData;
    };

} PROCAMP_MEMBERSLIST;


class CClassDriver
{
private:

    HKEY    m_hRKeyMsVideoVfWWDM; 
    HKEY    m_hRKeySoftwareVfWWDM; 
    HKEY    m_hRKeyDevice;                    // Sub key for the WDM device

    BOOL    m_bDeviceRemoved;
    
    TCHAR   m_szTargetFriendlyName[MAX_PATH]; // The target friendly name
    BOOL    m_bTargetOpenExclusively;         // TRUE: open this only; FALSE: try other if this failed.

    HANDLE  m_hDevice;                        // the file handle
    TCHAR   m_szDevicePath[MAX_PATH];         // The device regitry path
    TCHAR   m_szDevicePathBkup[MAX_PATH];     // Use to detect DevicePath change

    ULONG   m_ulCapturePinID;                 // Capture Pin's PinID

    //
    // Pointer to variable size PKSMULTIPLE_ITEM header + DATA_RANGE_VIDEO/2
    //
    PKSMULTIPLE_ITEM m_pMultItemsHdr;  


public:
    CClassDriver();
    ~CClassDriver();

    // Once device has been removed, stream stop forever 
    // until this or another device is open.
    void SetDeviceRemoved(BOOL bDevRemoved) {m_bDeviceRemoved = bDevRemoved;};
    BOOL GetDeviceRemoved() {return m_bDeviceRemoved;};


    // ------------------
    // Registry functions
    // ------------------
    // Save the path to the registry. (save to system.ini now; change later..)
    BOOL WriteDevicePath();
    void ResetFriendlyName();

    HKEY GetDeviceRegKey() { return m_hRKeyDevice;}

    LONG CreateDeviceRegKey(LPCTSTR lpcstrDevice);

#if 0
    DWORD   GetSettingFromReg(HKEY hKey, LPTSTR pszValueName, DWORD dwDefValue);
    BOOL    SetSettingToReg(  HKEY hKey, LPTSTR pszValueName, DWORD dwNewValue);   
    BOOL    SetSettingToReg(  HKEY hKey, LPTSTR pszValueName, LPTSTR pszValue);
    BOOL    GetSettingFromReg(HKEY hKey, LPTSTR pszValueName, LPTSTR pszValue);
#endif

    VOID    ResetTargetDevice(); 

    // --------------
    // Core functions
    // --------------
    void SetDeviceHandle(HANDLE hDevice, ULONG ulCapturePinID);
    ULONG GetCapturePinID() { return m_ulCapturePinID; }

    HANDLE    GetDriverHandle() { return m_hDevice; }

    // Data ranged support by this driver.
    ULONG CreateDriverSupportedDataRanges();
    void  DestroyDriverSupportedDataRanges();
    PKSMULTIPLE_ITEM GetDriverSupportedDataRanges() {return m_pMultItemsHdr;};

    HRESULT SyncDevIo(
        HANDLE  hDevice,
        DWORD   dwIoControlCode, 
        LPVOID  lpInBuffer,
        DWORD   nInBufferSize,
        LPVOID  lpOutBuffer,
        DWORD   nOutBufferSize,
        LPDWORD lpBytesReturned);

    // ---------------------
    // Device Path functions
    // ---------------------
    BOOL GetTargetDeviceOpenExclusively() { return m_bTargetOpenExclusively; }    

    TCHAR * GetTargetDeviceFriendlyName() { return m_szTargetFriendlyName; }    

    TCHAR * GetDevicePath() { return m_szDevicePath; }    

    BOOL SetDevicePathSZ(TCHAR * pszNewPath) {
        if (_tcslen(pszNewPath) >= MAX_PATH) return FALSE;
        else { _tcscpy(m_szDevicePath, pszNewPath); return TRUE; }    
    }

    void BackupDevicePath() { _tcscpy(m_szDevicePathBkup, m_szDevicePath);}
    void RestoreDevicePath() {_tcscpy(m_szDevicePath, m_szDevicePathBkup);}

    //
    // m_szDevicePathBkup is intialized in contructor and here only
    //
    BOOL fDevicePathChanged() {
        if (_tcscmp(m_szDevicePathBkup, m_szDevicePath) == 0) 
            return FALSE;  // same
        else 
            return TRUE;
    }

    // 
    // Query/set device's properties and ranges
    //
    BOOL GetPropertyValue(
        GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
        ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        PLONG  plValue,
        PULONG pulFlags,
        PULONG pulCapabilities);

    BOOL GetDefaultValue(
        GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
        ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        PLONG  plDefValue);

    BOOL GetRangeValues(
        GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
        ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        PLONG  plMin,
        PLONG  plMax,
        PLONG  plStep);

    BOOL SetPropertyValue(
        GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
        ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        LONG   lValue,
        ULONG  ulFlags,
        ULONG  ulCapabilities);

    LONG QueryRegistryValue(
        HKEY   hRegKey,           // registry key to query
        LPCSTR lpcstrValueName,   // value name
        DWORD  dwDataBufSize,     // data buffer size
        LPBYTE lpbDataBuf,        // address of data buffer
        DWORD * pdwValueType,     // return regitry value type
        DWORD * pdwValueSize      // size in byte of this reg value     
        );

    LONG SetRegistryValue(
        HKEY   hRegKey,           // registry key to query
        LPCSTR lpcstrValueName,   // value name
        DWORD  dwDataBufSize,     // data buffer size
        LPBYTE lpbDataBuf,        // address of data buffer
        DWORD  dwValueType        // value type  
        );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\extin.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ExtIn.cpp

Abstract:

    Construct a list of capture dvices for user selection.

Author:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"
#include <commctrl.h>
#include "extin.h"
#include <vfwext.h>

#include "resource.h"

///////////////////////////////////////////////////////////////////////////////////
// This struct is for when a page doesn't have help information
// #pragma message ("TODO : add help ID mappings")
static DWORD g_ExtInNoHelpIDs[] = { 0,0 };

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////

#define IsBitSet(FLAGS, MASK) ((FLAGS & MASK) != MASK)

DWORD DoExternalInDlg(
    HINSTANCE   hInst,
    HWND        hP,
    CVFWImage * pImage)
/*++
Routine Description:

Argument:

Return Value:

--*/
{
     DWORD dwRtn = DV_ERR_OK;

    // Don't bother displaying a empty video source selection
    if(pImage->BGf_GetDevicesCount(BGf_DEVICE_VIDEO) <= 0) {
        return DV_ERR_NOTDETECTED;
    }

    //
    // Clear cached constants to programatically open a capture device
    //
    CExtInSheet Sheet(pImage, hInst,IDS_EXTERNALIN_HEADING, hP);

    // If there is no capture device selected,
    // we will only prompt user a list of capture device for selection.
    BOOL bNoDevSelected = pImage->BGf_GetDeviceHandle(BGf_DEVICE_VIDEO) == 0;
    DWORD dwPages=0;
    CExtInGeneral pExtGeneral(IDD_EXTIN_GENERAL, &Sheet);
    // Image property input property
    CExtInColorSliders pExtColor(IDD_EXTIN_COLOR_SLIDERS, &Sheet);
    CExtInCameraControls pCamControl(IDD_CAMERA_CONTROL, &Sheet);

    if(bNoDevSelected) {

        Sheet.AddPage(pExtGeneral);

    } else {

        //
        // Load OEM supplied exteneded pages, and get its page display codes.
        //
        dwPages = Sheet.LoadOEMPages(TRUE);

        // WDM video capture device selection page
        DbgLog((LOG_TRACE,3,TEXT("Exclusive=%s\n"), pImage->GetTargetDeviceOpenExclusively() ? "TRUE" : "FALSE"));
        DbgLog((LOG_TRACE,3,TEXT("BitSet=%s\n"), IsBitSet(dwPages, VFW_HIDE_VIDEOSRC_PAGE) ? "YES" : "NO"));

        //CExtInGeneral    pExtGeneral(IDD_EXTIN_GENERAL, &Sheet);

        if(!(pImage->GetTargetDeviceOpenExclusively()) &&
            IsBitSet(dwPages, VFW_HIDE_VIDEOSRC_PAGE)) {

            DbgLog((LOG_TRACE,3,TEXT("VidSrc Page is added.\n")));
            Sheet.AddPage(pExtGeneral);
        }

        // Image property input property
        // CExtInColorSliders pExtColor(IDD_EXTIN_COLOR_SLIDERS, &Sheet);

        if(IsBitSet(dwPages, VFW_HIDE_SETTINGS_PAGE)) {
            Sheet.AddPage(pExtColor);
        }

        //
        // Camera control
        //
        // To do : Query number of camera control supported
        //         if > 0, add page.
        //
        //CExtInCameraControls pCamControl(IDD_CAMERA_CONTROL, &Sheet);

        if(IsBitSet(dwPages, VFW_HIDE_CAMERACONTROL_PAGE)) {
            Sheet.AddPage(pCamControl);
        }
    }


    // If vendor add any page or not hide all my pages
    if(bNoDevSelected || dwPages != VFW_HIDE_ALL_PAGES) {

        // Invoking PropertyPage message: WM_INITDIALOG, WM_NOTIFY(WM_ACTIVE)..
        if(Sheet.Do() == IDOK) {
            if(pImage->fDevicePathChanged()) {

                pImage->CloseDriverAndPin();

                //
                // Set and later open last saved (in ::Apply) unique device path
                // if device is not there, a client application needs to
                // propmpt user the video source dialog box to select another one.
                //
                TCHAR * pstrLastSavedDevicePath = pImage->GetDevicePath();
                if(pstrLastSavedDevicePath) {
                    if(S_OK != pImage->BGf_SetObjCapture(BGf_DEVICE_VIDEO, pstrLastSavedDevicePath)) {
                        DbgLog((LOG_TRACE,1,TEXT("BGf_SetObjCapture(BGf_DEVICE_VIDEO, pstrLastSavedDevicePath) failed; probably no sych device path.\n") ));
                    }
                }

                if(!pImage->OpenDriverAndPin()) {
                    // trying to open another one ??  No.
                    // leave it to application to display message and
                    // let user make that descision
                    DbgLog((LOG_TRACE,1,TEXT("\n\n---- Cannot open driver or streaming pin handle !!! ----\n\n") ));
                    return DV_ERR_INVALHANDLE;
                }
                dwRtn = DV_ERR_OK;
            } else {
                // Nothing changed; we need to pass that
                // Need to pass this back to caller a rtn code other than DV_ERR_OK.



                dwRtn = DV_ERR_NONSPECIFIC;
            }
        } else {
            // User selected CANCEL,
            // Need to pass this back to caller a rtn code other than DV_ERR_OK.
            dwRtn = DV_ERR_NONSPECIFIC;
        }
    }


    //
    // Now unload all the extensions
    //
    if(!bNoDevSelected)
        Sheet.LoadOEMPages(FALSE);

    return dwRtn;
}


///////////////////////////////////////////////////////////////////////
BOOL CExtInGeneral::
FillVideoDevicesList(
    CVFWImage * pImage)
/*++
Routine Description:

    Fill a list of capture device that is connected to the system to
    a drop down box.

Argument:

Return Value:

--*/
{

    EnumDeviceInfo * p = pImage->GetCacheDevicesList();
    HWND hTemp = GetDlgItem(IDC_DEVICE_LIST);
    TCHAR * pstrDevicePathSelected = pImage->GetDevicePath();
    BOOL bFound = FALSE;
    DWORD i;

    for(i=0; i<pImage->GetCacheDevicesCount(); i++) {

        SendMessage (hTemp, CB_ADDSTRING, 0, (LPARAM) p->strFriendlyName);
        if(!bFound && _tcscmp(p->strDevicePath, pstrDevicePathSelected) == 0) {
            bFound = TRUE;
            m_idxDeviceSaved = i;
            SendMessage (hTemp, CB_SETCURSEL, (UINT) i, 0);
        }
        p++;
    }

    return TRUE;
}



BOOL
CExtInGeneral::FillVideoSourcesList(
    CVFWImage * pImage)
/*++
Routine Description:

    Fill a list of capture device that is connected to the system to
    a drop down box.

Argument:

Return Value:

--*/
{
    PTCHAR * paPinNames;
    LONG idxIsRoutedTo, cntNumVidSrcs = pImage->BGf_CreateInputChannelsList(&paPinNames);
    HWND hTemp = GetDlgItem(IDC_VIDSRC_LIST);
    LONG i;

    idxIsRoutedTo = pImage->BGf_GetIsRoutedTo();
    m_idxRoutedToSaved = idxIsRoutedTo;
    for(i=0; i<cntNumVidSrcs; i++) {

        SendMessage (hTemp, CB_ADDSTRING, 0, (LPARAM) paPinNames[i]);

        if(i == idxIsRoutedTo) {
            SendMessage (hTemp, CB_SETCURSEL, (UINT) i, 0);
        }
    }

    pImage->BGf_DestroyInputChannelsList(paPinNames);

    return TRUE;
}
/////////////////////////////////////////////////////////////////////////////////////
int CExtInGeneral::SetActive()
/*++
Routine Description:

    Initialize the controls before they become visible.

Argument:

Return Value:

--*/
{
    if( GetInit() )
        return 0;

    //
    // Query the video source (just is case a new camera just plugged in)
    // create the device linked list.  Fill them for user to select.
    //
    CExtInSheet * pSheet=(CExtInSheet *)GetSheet();
    if(pSheet) {

        CVFWImage * pImage=pSheet->GetImage();

        if(pImage->BGf_GetDevicesCount(BGf_DEVICE_VIDEO) > 0)
            FillVideoDevicesList(pImage);   // Fill the drop down with list of video devices

        if(pImage->BGf_GetInputChannelsCount() > 0)
            FillVideoSourcesList(pImage);   // Fill the drop down with list of video sources
        else {
            ShowWindow(GetDlgItem(IDC_STATIC_VIDSRC), FALSE);
            ShowWindow(GetDlgItem(IDC_VIDSRC_LIST), FALSE);
        }

        if(!pImage->BGf_SupportTVTunerInterface())
            ShowWindow(GetDlgItem(IDC_BTN_TVTUNER), FALSE);


        //
        // We caution user that the opening device is a non-shareable device
        //
        if(pImage->UseOVMixer() &&
           !pImage->BGf_GetDeviceHandle(BGf_DEVICE_VIDEO)) {
            TCHAR szMsgTitle[64];
            TCHAR szMsg[512];

            LoadString(GetInstance(), IDS_BPC_MSG ,      szMsg, sizeof(szMsg)-1);
            LoadString(GetInstance(), IDS_BPC_MSG_TITLE, szMsgTitle, sizeof(szMsgTitle)-1);
            MessageBox(0, szMsg, szMsgTitle, MB_SYSTEMMODAL | MB_ICONHAND | MB_OK);
        }

    }

    return 0;
}


/////////////////////////////////////////////////////////////////////////////////////
int CExtInGeneral::DoCommand(
    WORD wCmdID,
    WORD hHow)
/*++
Routine Description:

    Fill a list of capture device that is connected to the system to
    a drop down box.

Argument:

Return Value:

--*/
{
    CExtInSheet * pSheet=(CExtInSheet *)GetSheet();
    if(!pSheet)
        return 0;

    CVFWImage * pImage=pSheet->GetImage();

    switch (wCmdID) {
    case IDC_DEVICE_LIST:
        if(hHow == CBN_SELCHANGE ) {
            CExtInSheet * pS = (CExtInSheet*)GetSheet();
            if(pS) {
                LONG_PTR idxSel = SendMessage (GetDlgItem(IDC_DEVICE_LIST),CB_GETCURSEL, 0, 0);
                if(idxSel != CB_ERR) {  // validate.
                    //
                    // Get and Save currently selected DevicePath
                    //
                    LONG idxDeviceSel = (LONG)SendMessage (GetDlgItem(IDC_DEVICE_LIST),CB_GETCURSEL, 0, 0);
                    if(idxDeviceSel != CB_ERR) {
                        if(idxDeviceSel < pImage->BGf_GetDevicesCount(BGf_DEVICE_VIDEO)) {
                            EnumDeviceInfo * p = pImage->GetCacheDevicesList();
                            DbgLog((LOG_TRACE,1,TEXT("User has selected: %s\n"), (p+idxDeviceSel)->strFriendlyName));
                            pImage->SetDevicePathSZ((p+idxDeviceSel)->strDevicePath);
                        } else {
                            DbgLog((LOG_TRACE,1,TEXT("The index is out of range from number of devices %d\n"),                                  idxDeviceSel, pImage->BGf_GetDevicesCount(BGf_DEVICE_VIDEO)));
                        }
                    }

                    //
                    // Hide settings related to the current avtyive device.
                    //
                    BOOL bShown = m_idxDeviceSaved == idxSel;
                    if(pImage->BGf_SupportTVTunerInterface())
                        ShowWindow(GetDlgItem(IDC_BTN_TVTUNER),   bShown);

                    if(pImage->BGf_GetInputChannelsCount() > 0) {
                        ShowWindow(GetDlgItem(IDC_STATIC_VIDSRC), bShown);
                        ShowWindow(GetDlgItem(IDC_VIDSRC_LIST),   bShown);
                    }
                }
            }
        }
        break;

    case IDC_BTN_TVTUNER:
        // Show
        pImage->ShowTvTunerPage(GetWindow());
        break;
    }

    return 0;
}


/////////////////////////////////////////////////////////////////////////////////////
int CExtInGeneral::Apply()
/*++
Routine Description:

    Apply user's change now.

Argument:

Return Value:

--*/
{
    CExtInSheet * pS = (CExtInSheet*)GetSheet();
    if(pS) {

        CVFWImage * pImage=pS->GetImage();

        //
        // Get and Save currently selected DevicePath from its corresponding FriendlyName
        //
        LONG_PTR idxDeviceSel = SendMessage (GetDlgItem(IDC_DEVICE_LIST),CB_GETCURSEL, 0, 0);
        if (idxDeviceSel != CB_ERR) {
            if(idxDeviceSel < pImage->BGf_GetDevicesCount(BGf_DEVICE_VIDEO)) {
                EnumDeviceInfo * p = pImage->GetCacheDevicesList();
                DbgLog((LOG_TRACE,1,TEXT("User has selected: %s\n"), (p+idxDeviceSel)->strFriendlyName));
                pImage->SetDevicePathSZ((p+idxDeviceSel)->strDevicePath);
            } else {
                DbgLog((LOG_TRACE,1,TEXT("The index is out of range from number of devices %d\n"),
                       idxDeviceSel, pImage->BGf_GetDevicesCount(BGf_DEVICE_VIDEO)));
            }
        }

        LONG idxVidSrcSel = (LONG)SendMessage (GetDlgItem(IDC_VIDSRC_LIST),CB_GETCURSEL, 0, 0);
        if(idxVidSrcSel != CB_ERR) {
            if(idxVidSrcSel < pImage->BGf_GetInputChannelsCount()) {
                if(pImage->BGf_RouteInputChannel(idxVidSrcSel) != S_OK) {
                    DbgLog((LOG_TRACE,1,TEXT("Cannot route input pin %d selected.\n"), idxVidSrcSel));
                } else {
                    ShowWindow(GetDlgItem(IDC_BTN_TVTUNER),
                        pImage->BGf_SupportTVTunerInterface());
                }
            } else {
                DbgLog((LOG_TRACE,1,TEXT("The index for VidSrc is out of range from number of VidSrc %d\n"), pImage->BGf_GetInputChannelsCount()));

            }
        }
    }

    return 0;
}



/////////////////////////////////////////////////////////////////////////////////////
int CExtInGeneral::QueryCancel()
/*++
Routine Description:

    Revert user's change to original state.

Argument:

Return Value:

--*/
{
    CExtInSheet * pS = (CExtInSheet*)GetSheet();

    if (pS) {

        CVFWImage * pImage=pS->GetImage();

        // Restore the current device path from its backup
        // The current device path may have been change when user selected ::Apply
        pImage->RestoreDevicePath();

        // Restore video source selection.
        if(m_idxRoutedToSaved >= 0) {  // if == -1, nothing to restore.
            LONG_PTR idxVidSrcSel = SendMessage (GetDlgItem(IDC_VIDSRC_LIST),CB_GETCURSEL, 0, 0);
            if(idxVidSrcSel != CB_ERR) {   // Validate.
                if(idxVidSrcSel < pImage->BGf_GetInputChannelsCount()) {  // Validate.
                    if(idxVidSrcSel != m_idxRoutedToSaved)  // Only if it has been changed.
                        if(pImage->BGf_RouteInputChannel(m_idxRoutedToSaved) != S_OK) {
                            DbgLog((LOG_TRACE,1,TEXT("Cannot route input pin %d selected.\n"), m_idxRoutedToSaved));
                        }
                }
            } else {
                DbgLog((LOG_TRACE,1,TEXT("The index for VidSrc is out of range from number of VidSrc %d\n"), pImage->BGf_GetInputChannelsCount()));

            }
        }
    }

    return 0;
}

//
// Uses the Gloabl VFWImage that we instatiate.
// Get's the Pin handle for the page to be able to talk to its pin.
// I don't think they need to get at the Object itself.
//
BOOL
OemExtDllDeviceIoControl(
    LPARAM lParam,
    DWORD dwFlags,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped)
/*++
Routine Description:

Argument:

Return Value:
    TRUE if suceeded; FALSE is failed somehow/where!

--*/
{
    CExtInSheet * pS = (CExtInSheet*) lParam;

    if (!pS)
        return FALSE;

    CVFWImage * pImage = pS->GetImage();

    HANDLE hDevice;

    switch (dwFlags) {
    case VFW_USE_DEVICE_HANDLE:
        hDevice = pImage->GetDriverHandle();
        break;
    case VFW_USE_STREAM_HANDLE:
        hDevice = pImage->GetPinHandle();
        break;
    case VFW_QUERY_DEV_CHANGED:
        return pImage->fDevicePathChanged();
    default:
        return FALSE;
    }

    DbgLog((LOG_TRACE,3,TEXT("-- Call DeviceIoControl for VfWEXT client.\n") ));

    if( hDevice && hDevice != (HANDLE) -1 )
        return DeviceIoControl(
                    hDevice,
                    dwIoControlCode,
                    lpInBuffer,
                    nInBufferSize,
                    lpOutBuffer,
                    nOutBufferSize,
                    lpBytesReturned,
                    lpOverlapped);
    return FALSE;
}


BOOL AddPagesToMe(HPROPSHEETPAGE hPage, LPARAM pThings)
{
    CExtInSheet *pSheet=(CExtInSheet *)pThings;
    return pSheet->AddPage(hPage);
}


DWORD CExtInSheet::LoadOEMPages(BOOL bLoad)
{
    DWORD dwFlags = 0;
    HMODULE hLib = 0;

    // Get the OEM supplied extension pages
    TCHAR * pszExtensionDLL = m_pImage->BGf_GetObjCaptureExtensionDLL(BGf_DEVICE_VIDEO);


    // ExtensionDLL must be at least 5 characters "x.dll"
    if (pszExtensionDLL == NULL ||
        _tcslen(pszExtensionDLL) < 5) {

        DbgLog((LOG_TRACE,3,TEXT("NO OEM supplied extension DLL.\n") ));
        return 0;
    }


    if (bLoad) {

        hLib = LoadLibrary(pszExtensionDLL);
        if (hLib) {

            // Get pointer to the entry point of VFWWDMExtension
            VFWWDMExtensionProc pAddPages = (VFWWDMExtensionProc) GetProcAddress(hLib,"VFWWDMExtension");

            if (pAddPages) {

                dwFlags = pAddPages( (LPVOID)(OemExtDllDeviceIoControl), AddPagesToMe, (LPARAM)this);
            } else {

                DbgLog((LOG_TRACE,1,TEXT("OEM supplied extension DLL (%s) does not have a VFWWDMExtension() ?\n"), pszExtensionDLL));
            }
        } else {

            DbgLog((LOG_TRACE,1,TEXT("OEM supplied extension DLL (%s) is not loaded successfully!\n"), pszExtensionDLL));
        }
    } else {
        // Free loaded library
        if (hLib = GetModuleHandle(pszExtensionDLL)) {
            DbgLog((LOG_TRACE,2,TEXT("Unloading %s\n"),pszExtensionDLL));
            FreeLibrary(hLib);
            return 0;
        }
    }

    return dwFlags;
}


////////////////////////////////////////////////////////////////////////////////////////
// A common slider function: Will setup a spinner and related text to reflect a RANGE
// property settings.
////////////////////////////////////////////////////////////////////////////////////////
void SetTextValue(HWND hWnd, DWORD dwVal)
{
    TCHAR szTemp[MAX_PATH];
    wsprintf(szTemp,TEXT("%d"),dwVal);
    SetWindowText(hWnd, szTemp);
}

BOOL InitMinMax(HWND hDlg, UINT idSlider, LONG lMin, LONG lMax, LONG lStep)
{
    HWND hTB = GetDlgItem(hDlg, idSlider);
    DbgLog((LOG_TRACE,3,TEXT("(%d, %d) / %d = %d \n"), lMin, lMax, lStep, (lMax-lMin)/lStep ));
    SendMessage( hTB, TBM_SETTICFREQ, (lMax-lMin)/lStep, 0 );
    SendMessage( hTB, TBM_SETRANGE, 0, MAKELONG( lMin, lMax ) );

    return TRUE;
}




////////////////////////////////////////////////////////////////////////////////////////
//
// When the color page gets focus. This fills it with the current settings from
// the driver.
//
////////////////////////////////////////////////////////////////////////////////////////
CExtInColorSliders::CExtInColorSliders(int DlgId, CSheet * pS)
                : CPropPage(DlgId, pS)
{
    m_ulNumValidControls = 0;

    if ((m_pPC = (PPROPSLIDECONTROL) new PROPSLIDECONTROL[NumVideoSettings]) != NULL) {
        LONG i;

        for (i = 0; i <NumVideoSettings; i++)
            m_pPC[i] = g_VideoSettingControls[i];

    } else {
        DbgLog((LOG_TRACE,1,TEXT("^CExtInColorSliders: Memory allocation failed ! m_pPC=0x%x\n"), m_pPC));
    }
}


CExtInColorSliders::~CExtInColorSliders()
{
    if (m_pPC)
        delete [] m_pPC;
}


int CExtInColorSliders::SetActive()
{

    DbgLog((LOG_TRACE,3,TEXT("CExtInColorSliders::SetActive()\n")));

    CExtInSheet * pS = (CExtInSheet*)GetSheet();

    if(!pS || !m_pPC)
        return 0;

    CVFWImage * pImage = pS->GetImage();

    //
    // Returns zero to accept the activation or
    // -1 to activate the next or previous page
    // (depending on whether the user chose the Next or Back button)
    //
    LONG i;
    HWND hDlg = GetWindow();  // It is initialized after WM_INITDIALOG
    BOOL bDevChanged = pImage->fDevicePathChanged();

    if (bDevChanged) {

        ShowWindow(GetDlgItem(IDC_MSG_DEVCHG), bDevChanged);
        ShowWindow(GetDlgItem(IDC_TXT_WARN_DEVICECHANGE), bDevChanged);
        EnableWindow(hDlg, !bDevChanged);
    } else {

        EnableWindow(hDlg, !bDevChanged);
        ShowWindow(GetDlgItem(IDC_MSG_DEVCHG), bDevChanged);
        ShowWindow(GetDlgItem(IDC_TXT_WARN_DEVICECHANGE), bDevChanged);
    }

    if( GetInit() )
        return 0;

    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;
    TCHAR szDisplayName[256];


    for(i = j = 0 ; i < NumVideoSettings; i++) {

        //
        // Get the current value
        //
        if(pImage->GetPropertyValue(
                PROPSETID_VIDCAP_VIDEOPROCAMP,
                m_pPC[i].uiProperty,
                &lValue,
                &ulFlags,
                &ulCapabilities)) {


            LoadString(GetInstance(), m_pPC[i].uiString, szDisplayName, sizeof(szDisplayName));
            DbgLog((LOG_TRACE,2,TEXT("szDisplay = %s\n"), szDisplayName));
            SetWindowText(GetDlgItem(m_pPC[i].uiStatic), szDisplayName);
            //
            // Get the Range of Values possible.
            //
            if (pImage->GetRangeValues(PROPSETID_VIDCAP_VIDEOPROCAMP, m_pPC[i].uiProperty, &lMin, &lMax, &lStep))
                InitMinMax(GetWindow(), m_pPC[i].uiSlider, lMin, lMax, lStep);
            else {
                DbgLog((LOG_TRACE,1,TEXT("Cannot get range values for this property ID = %d\n"), m_pPC[j].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            EnableWindow(GetDlgItem(m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_pPC[i].uiAuto), TRUE);

            SetTickValue(lValue, GetDlgItem(m_pPC[i].uiSlider), GetDlgItem(m_pPC[i].uiCurrent));

            DbgLog((LOG_TRACE,2,TEXT("Capability = 0x%x; Flags=0x%x; lValue=%d\n"), ulCapabilities, ulFlags, lValue));
            DbgLog((LOG_TRACE,2,TEXT("switch(%d): \n"), ulCapabilities & (KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL | KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO)));

            switch (ulCapabilities & (KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL | KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO)){
            case KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL:
                EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);    // Disable auto
                break;
            case KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO:
                EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);    // Disable slider;
                // always auto!
                SendMessage (GetDlgItem(m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
                break;
            case (KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL | KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO):
                // Set flags
                if (ulFlags & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) {
                    DbgLog((LOG_TRACE,3,TEXT("Auto (checked) and slider disabled\n")));
                    // Set auto check box; greyed out slider
                    SendMessage (GetDlgItem(m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                    EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);
                } else {
                    // Unchcked auto; enable slider
                    SendMessage (GetDlgItem(m_pPC[i].uiAuto),BM_SETCHECK, 0, 0);
                    EnableWindow(GetDlgItem(m_pPC[i].uiSlider), TRUE);
                }
                break;
            case 0:
            default:
                EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
                EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
                break;
            }

            j++;

        } else {
            EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);
        }
    }

    m_ulNumValidControls = j;

    // Disable the "default" push button;
    // or inform user that no control is enabled.
    if (m_ulNumValidControls == 0)
        EnableWindow(GetDlgItem(IDC_DEF_COLOR), FALSE);

    return 0;
}

int CExtInColorSliders::DoCommand(WORD wCmdID,WORD hHow)
{

    if( !CPropPage::DoCommand(wCmdID, hHow) )
        return 0;

    // If a user select default settings of the video format
    if (wCmdID == IDC_DEF_COLOR) {

        CExtInSheet * pS = (CExtInSheet*)GetSheet();

        if(pS && m_pPC) {

            CVFWImage * pImage=pS->GetImage();
            HWND hwndSlider;
            LONG  lDefValue;
            ULONG i;

            for (i = 0 ; i < NumVideoSettings ; i++) {

                hwndSlider = GetDlgItem(m_pPC[i].uiSlider);

                if (IsWindowEnabled(hwndSlider)) {
                    if (pImage->GetDefaultValue(PROPSETID_VIDCAP_VIDEOPROCAMP, m_pPC[i].uiProperty, &lDefValue)) {
                        if (lDefValue != m_pPC[i].lCurrentValue) {
                            pImage->SetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP,m_pPC[i].uiProperty, lDefValue, KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                            SetTickValue(lDefValue, hwndSlider, GetDlgItem(m_pPC[i].uiCurrent));
                            m_pPC[i].lCurrentValue = lDefValue;
                        }
                    }
                }
            }
        }
        return 0;
    } else     if (hHow == BN_CLICKED) {

        CExtInSheet * pS = (CExtInSheet*)GetSheet();

        if(pS && m_pPC) {

            CVFWImage * pImage=pS->GetImage();
            ULONG i;

            for (i = 0 ; i < NumVideoSettings ; i++) {

                // find matching slider
                if (m_pPC[i].uiAuto == wCmdID) {

                    if ( BST_CHECKED == SendMessage (GetDlgItem(m_pPC[i].uiAuto),BM_GETCHECK, 1, 0)) {

                        pImage->SetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);
                    } else {

                        pImage->SetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_pPC[i].uiSlider), TRUE);
                    }
                    break;
                }
            }
        }

    }

    return 1;
}

//
// Call down to the minidriver and set all the properties
//
int CExtInColorSliders::Apply()
{

    return 0;
}

//
//  Cancel
//
int CExtInColorSliders::QueryCancel()
{
    CExtInSheet * pS = (CExtInSheet*)GetSheet();

    if (pS && m_pPC) {

        CVFWImage * pImage=pS->GetImage();
        HWND hwndSlider;
        ULONG i;

        for (i = 0 ; i < NumVideoSettings ; i++) {

            hwndSlider = GetDlgItem(m_pPC[i].uiSlider);

            if (IsWindowEnabled(hwndSlider)) {
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue)
                    pImage->SetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }

    return 0;
}

BOOL CALLBACK CExtInColorSliders::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_HSCROLL:

        CExtInSheet * pS = (CExtInSheet*)GetSheet();

        if(pS && m_pPC) {

            //int nScrollCode = (int) LOWORD(wParam);
            //short int nPos = (short int) HIWORD(wParam);
            HWND hwndControl = (HWND) lParam;
            CVFWImage * pImage=pS->GetImage();
            HWND hwndSlider;
            ULONG i;

            for (i = 0 ; i < NumVideoSettings ; i++) {

                hwndSlider = GetDlgItem(m_pPC[i].uiSlider);

                // find matching slider
                if (hwndSlider == hwndControl) {

                    LONG lValue = (LONG) GetTickValue(GetDlgItem(m_pPC[i].uiSlider));
                    pImage->SetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP,m_pPC[i].uiProperty, lValue, KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                    m_pPC[i].lCurrentValue = lValue;
                    SetTextValue(GetDlgItem(m_pPC[i].uiCurrent), lValue);
                    break;
                }
            }
        }

        break;
    }


    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// When the color page gets focus. This fills it with the current settings from
// the driver.
//
////////////////////////////////////////////////////////////////////////////////////////



CExtInCameraControls::CExtInCameraControls(int DlgId, CSheet * pS)
                : CPropPage(DlgId, pS)
{

    m_ulNumValidControls = 0;

    if ((m_pPC = (PPROPSLIDECONTROL) new PROPSLIDECONTROL[NumCameraControls]) != NULL) {
        LONG i;

        for (i = 0; i <NumCameraControls; i++)
            m_pPC[i] = g_CameraControls[i];

    } else {
        DbgLog((LOG_TRACE,1,TEXT("^CExtInCameraControls: Memory allocation failed ! m_pPC=0x%x\n"), m_pPC));
    }
}


CExtInCameraControls::~CExtInCameraControls()
{
    if (m_pPC)
        delete [] m_pPC;
}

int CExtInCameraControls::SetActive()
{
    DbgLog((LOG_TRACE,2,TEXT("CExtInCameraControls::SetActive()\n")));

    CExtInSheet * pS = (CExtInSheet*)GetSheet();

    if(!pS || !m_pPC)
        return 0;

    CVFWImage * pImage = pS->GetImage();

    //
    // Returns zero to accept the activation or
    // -1 to activate the next or previous page
    // (depending on whether the user chose the Next or Back button)
    //
    LONG  i;
    HWND hDlg = GetWindow();  // It is initialized after WM_INITDIALOG
    BOOL bDevChanged = pImage->fDevicePathChanged();

    if (bDevChanged) {

        ShowWindow(GetDlgItem(IDC_MSG_DEVCHG), bDevChanged);
        ShowWindow(GetDlgItem(IDC_TXT_WARN_DEVICECHANGE), bDevChanged);
        EnableWindow(hDlg, !bDevChanged);
    } else {

        EnableWindow(hDlg, !bDevChanged);
        ShowWindow(GetDlgItem(IDC_MSG_DEVCHG), bDevChanged);
        ShowWindow(GetDlgItem(IDC_TXT_WARN_DEVICECHANGE), bDevChanged);
    }

#if 0
    if (Image.fDevicePathChanged()) {

        for (i = 0 ; i < NumCameraControls; i++) {

            EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);
        }

        return -1;
    }
#endif

    if( GetInit() )
        return 0;

    //
    // Go call the driver for some properties.
    //
    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;

    for (i = j = 0 ; i < NumCameraControls; i++) {
        //
        // Get the current value
        //
        if (pImage->GetPropertyValue(
                PROPSETID_VIDCAP_CAMERACONTROL,
                m_pPC[i].uiProperty,
                &lValue,
                &ulFlags,
                &ulCapabilities)) {

            //
            // Get the Range of Values possible.
            //
            if (pImage->GetRangeValues(PROPSETID_VIDCAP_CAMERACONTROL, m_pPC[i].uiProperty, &lMin, &lMax, &lStep))
                InitMinMax(GetWindow(), m_pPC[i].uiSlider, lMin, lMax, lStep);
            else {
                DbgLog((LOG_TRACE,2,TEXT("Cannot get range values for this property ID = %d\n"), m_pPC[i].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            DbgLog((LOG_TRACE,2,TEXT("Capability = 0x%x =? 0 (manual) or 1 (auto); lValue=%d\n"), ulCapabilities, lValue));

            EnableWindow(GetDlgItem(m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_pPC[i].uiAuto), TRUE);

            SetTickValue(lValue, GetDlgItem(m_pPC[i].uiSlider), GetDlgItem(m_pPC[i].uiCurrent));

            switch (ulCapabilities & (KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL | KSPROPERTY_CAMERACONTROL_FLAGS_AUTO)){
            case KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL:
                EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);    // Disable auto
                break;
            case KSPROPERTY_CAMERACONTROL_FLAGS_AUTO:
                EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);    // Disable slider;
                // always auto!
                SendMessage (GetDlgItem(m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
                break;
            case (KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL | KSPROPERTY_CAMERACONTROL_FLAGS_AUTO):
                // Set flags
                if (ulFlags & KSPROPERTY_CAMERACONTROL_FLAGS_AUTO) {

                    // Set check box
                    SendMessage (GetDlgItem(m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                    EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);

                }
                break;
            case 0:
            default:
                EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
                EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
            }

            j++;

        } else {

            EnableWindow(GetDlgItem(m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_pPC[i].uiAuto), FALSE);
        }

    }

    m_ulNumValidControls = j;

    // What id m_ulNumValidControls == 0, why bother open the dialog box ?
    if (m_ulNumValidControls == 0) {
        return 1;
    }

    return 0;
}

int CExtInCameraControls::DoCommand(WORD wCmdID,WORD hHow)
{

    if( !CPropPage::DoCommand(wCmdID, hHow) )
        return 0;

    return 1;
}

//
// Call down to the minidriver and set all the properties
//
int CExtInCameraControls::Apply()
{
    CExtInSheet * pS = (CExtInSheet*)GetSheet();

    // Nothing to do !
    if(pS && m_pPC) {

    }

    return 0;
}

//
//  Cancel
//
int CExtInCameraControls::QueryCancel()
{
    CExtInSheet * pS = (CExtInSheet*)GetSheet();

    if (pS && m_pPC) {

        CVFWImage * pImage=pS->GetImage();
        HWND hwndSlider;
        ULONG i;

        for (i = 0 ; i < NumCameraControls ; i++) {

            hwndSlider = GetDlgItem(m_pPC[i].uiSlider);

            if (IsWindowEnabled(hwndSlider)) {
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue)
                    pImage->SetPropertyValue(PROPSETID_VIDCAP_CAMERACONTROL,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }

    return 0;
}

BOOL CALLBACK CExtInCameraControls::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage) {

    case WM_HSCROLL:

        CExtInSheet * pS = (CExtInSheet*)GetSheet();

        if(pS && m_pPC) {

            //int nScrollCode = (int) LOWORD(wParam);
            //short int nPos = (short int) HIWORD(wParam);
            HWND hwndControl = (HWND) lParam;
            CVFWImage * pImage=pS->GetImage();
            LONG i, lValue;
            HWND hwndSlider;

            for (i = 0; i < NumCameraControls; i++) {

                hwndSlider = GetDlgItem(m_pPC[i].uiSlider);

                // find its matching slider ??
                if (hwndSlider == hwndControl) {

                    lValue = GetTickValue(GetDlgItem(m_pPC[i].uiSlider));
                    pImage->SetPropertyValue(PROPSETID_VIDCAP_CAMERACONTROL,m_pPC[i].uiProperty, lValue, KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL, m_pPC[i].uiProperty);
                    m_pPC[i].lCurrentValue = lValue;
                    SetTextValue(GetDlgItem(m_pPC[i].uiCurrent), lValue);
                    break;
                }
            }
        }
    }


    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\extin.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Extin.h

Abstract:

    header file for extin.cpp

Author:
    
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#ifndef EXTIN_H
#define EXTIN_H

#include "resource.h"

#include "sheet.h"
#include "page.h"
#include "vfwimg.h"

DWORD DoExternalInDlg(HINSTANCE hInst, HWND hP, CVFWImage * pImage);

//
// A sheet holds the pages relating to the image device.
//
class CExtInSheet : public CSheet
{
    CVFWImage * m_pImage;    // the sheets get info about the driver from the Image class.
public:
    CExtInSheet(CVFWImage * pImage, HINSTANCE hInst, UINT iTitle=0, HWND hParent=NULL)
        : m_pImage(pImage), CSheet( hInst,iTitle,hParent) {}

    CVFWImage * GetImage() { return m_pImage; }   
    DWORD LoadOEMPages(BOOL bLoad);

};


//
// WDM capture device selection.
//
class CExtInGeneral : public CPropPage
{
private:
    LONG m_idxDeviceSaved;    // Original selected device.
    LONG m_idxRoutedToSaved;  // For cancel: Set to -1 to indicate none. validf is 0..n-1 input pins.
    BOOL FillVideoDevicesList(CVFWImage * pImage);   // Fill the drop down with list of video sources
    BOOL FillVideoSourcesList(CVFWImage * pImage);
public:
    int SetActive();                    
    int DoCommand(WORD wCmdID,WORD hHow);
    int Apply();
    int QueryCancel();

    CExtInGeneral(int DlgId, CSheet * pS) : CPropPage(DlgId, pS) {m_idxDeviceSaved = -1; m_idxRoutedToSaved = -1;}
    ~CExtInGeneral() {};
};


typedef struct _tagPROPSLIDECONTROL
{
    LONG lLastValue;
    LONG lCurrentValue;
    LONG lMin;
    LONG lMax;
    ULONG ulCapabilities;

    // IDs of dialog control item
    UINT uiProperty;
    UINT uiSlider;
    UINT uiString;
    UINT uiStatic;
    UINT uiCurrent;
    UINT uiAuto;
} PROPSLIDECONTROL, * PPROPSLIDECONTROL;

const static PROPSLIDECONTROL g_VideoSettingControls[] = 
{    
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,   IDC_SLIDER_BRIGHTNESS, IDS_BRIGHTNESS, IDC_BRIGHTNESS_STATIC, IDC_TXT_BRIGHTNESS_CURRENT, IDC_CB_AUTO_BRIGHTNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_CONTRAST,     IDC_SLIDER_CONTRAST,   IDS_CONTRAST,   IDC_CONTRAST_STATIC,   IDC_TXT_CONTRAST_CURRENT,   IDC_CB_AUTO_CONTRAST},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_HUE,           IDC_SLIDER_HUE,        IDS_HUE,        IDC_HUE_STATIC,        IDC_TXT_HUE_CURRENT,        IDC_CB_AUTO_HUE},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SATURATION,   IDC_SLIDER_SATURATION, IDS_SATURATION, IDC_SATURATION_STATIC, IDC_TXT_SATURATION_CURRENT, IDC_CB_AUTO_SATURATION},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SHARPNESS,    IDC_SLIDER_SHARPNESS,  IDS_SHARPNESS,  IDC_SHARPNESS_STATIC,  IDC_TXT_SHARPNESS_CURRENT,  IDC_CB_AUTO_SHARPNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE, IDC_SLIDER_WHITEBAL,   IDS_WHITEBAL,   IDC_WHITE_STATIC,      IDC_TXT_WHITE_CURRENT,      IDC_CB_AUTO_WHITEBAL},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_GAMMA,        IDC_SLIDER_GAMMA,      IDS_GAMMA,      IDC_GAMMA_STATIC,      IDC_TXT_GAMMA_CURRENT,      IDC_CB_AUTO_GAMMA},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,    IDC_SLIDER_BACKLIGHT,  IDS_BACKLIGHT,  IDC_BACKLIGHT_STATIC,      IDC_TXT_BACKLIGHT_CURRENT,  IDC_CB_AUTO_BACKLIGHT}
};

const ULONG NumVideoSettings = sizeof(g_VideoSettingControls) / sizeof(PROPSLIDECONTROL);


//
// Color selection (brightness tint hue etc.)
//
class CExtInColorSliders : public CPropPage
{
    PPROPSLIDECONTROL m_pPC;

public:
    ULONG m_ulNumValidControls;

    CExtInColorSliders(int DlgId, CSheet * pS); // : CPropPage(DlgId, pS);
    ~CExtInColorSliders();
    int SetActive();
    int QueryCancel();
    int DoCommand(WORD wCmdID,WORD hHow);
    int Apply();    // return 0

    BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

//
// Camera control (focus, zoom etc.)
//

static PROPSLIDECONTROL g_CameraControls[] = 
{    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_FOCUS,   IDC_SLIDER_FOCUS,   IDS_FOCUS,    IDC_FOCUS_STATIC,   IDC_TXT_FOCUS_CURRENT,    IDC_CB_AUTO_FOCUS},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ZOOM,    IDC_SLIDER_ZOOM,    IDS_ZOOM,     IDC_ZOOM_STATIC,    IDC_TXT_ZOOM_CURRENT,     IDC_CB_AUTO_ZOOM},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_EXPOSURE,IDC_SLIDER_EXPOSURE,IDS_EXPOSURE, IDC_EXPOSURE_STATIC,IDC_TXT_EXPOSURE_CURRENT, IDC_CB_AUTO_EXPOSURE},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_IRIS,    IDC_SLIDER_IRIS,    IDS_IRIS,     IDC_IRIS_STATIC,    IDC_TXT_IRIS_CURRENT,     IDC_CB_AUTO_IRIS},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_TILT,    IDC_SLIDER_TILT,    IDS_TILT,     IDC_TILT_STATIC,    IDC_TXT_TILT_CURRENT,     IDC_CB_AUTO_TILT},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_PAN,     IDC_SLIDER_PAN,     IDS_PAN,      IDC_PAN_STATIC,     IDC_TXT_PAN_CURRENT,      IDC_CB_AUTO_PAN},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ROLL,    IDC_SLIDER_ROLL,    IDS_ROLL,     IDC_ROLL_STATIC,    IDC_TXT_ROLL_CURRENT,     IDC_CB_AUTO_ROLL},    
};

const ULONG NumCameraControls = sizeof(g_CameraControls) / sizeof(PROPSLIDECONTROL);


class CExtInCameraControls : public CPropPage
{
    PPROPSLIDECONTROL m_pPC;

public:
    ULONG m_ulNumValidControls;

    CExtInCameraControls(int DlgId, CSheet * pS); // : CPropPage(DlgId, pS);
    ~CExtInCameraControls();
    int SetActive();
    int QueryCancel();
    int DoCommand(WORD wCmdID,WORD hHow);
    int Apply();                            // return 0

    BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\pch.cpp ===
#include "pch.h"

            
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\page.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Page.cpp

Abstract:

    Debug functions, like DebugPrint and ASSERT.

Author:

    FelixA

Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"
#include "page.h"
#include "sheet.h"


///////////////////////////////////////////////////////////////////////////////
//
// Creates the Page
//
HPROPSHEETPAGE CPropPage::Create(HINSTANCE hInst, int iPageNum)
{
    PROPSHEETPAGE psp;

    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance     = hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(GetDlgID());
    psp.pfnDlgProc    = (DLGPROC)BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)&this->BaseCallback;
    psp.lParam        = (LPARAM)this;

    // Data members.
    SetInstance( hInst );
    SetPropPage(CreatePropertySheetPage(&psp));
    SetPageNum(iPageNum);
    return GetPropPage();
}


UINT CPropPage::BaseCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    // Get the this pointer, call its Callback method
    CPropPage * pSV=(CPropPage *)ppsp->lParam;
    if(pSV)
        return pSV->Callback(uMsg);
    return 1;
}

UINT CPropPage::Callback(UINT uMsg)
{
    return 1;    //OK fine - whatever
}

///////////////////////////////////////////////////////////////////////////////
//
// Sets the lParam to the 'this' pointer
// wraps up PSN_ messages and calls virtual functions
// calls off to your overridable DlgProc
//

BOOL CALLBACK CPropPage::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CPropPage * pSV = (CPropPage*)GetWindowLongPtr(hDlg,DWLP_USER);

    switch (uMessage)
    {
        case WM_HELP:
            if(pSV->m_pdwHelp)
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR)pSV->m_pdwHelp);
        break;

        case WM_CONTEXTMENU:
            if(pSV->m_pdwHelp)
                WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR)pSV->m_pdwHelp);
        break;

        case WM_INITDIALOG:
        {
            LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)lParam;
            pSV=(CPropPage*)psp->lParam;
            pSV->SetWindow(hDlg);
            SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM)pSV);
            pSV->SetInit(FALSE);
            pSV->SetChanged(FALSE);
        }
        break;

        case WM_SETFOCUS:
            DbgLog((LOG_TRACE,2,TEXT("WM_SetFocus")));
            break;

        // Override the Do Command to get a nice wrapped up feeling.
        case WM_COMMAND:
            if(pSV)
            {
                int iRet = pSV->DoCommand(LOWORD(wParam),HIWORD(wParam));
                if( !iRet )
                    pSV->Changed();
                return iRet;
            }
        break;

        case WM_HSCROLL:
        case WM_VSCROLL:
            if(pSV)
                pSV->Changed();
        break;

        // Some notifications are dealt with as member functions.
        case WM_NOTIFY:
        if(pSV)
            switch (((NMHDR FAR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    // We call out here specially so we can mark this page as having been init'd.
                    int iRet = pSV->SetActive();
                    pSV->SetInit(TRUE);
                    return iRet;
                }
                break;

                case PSN_APPLY:
                    if( pSV->GetChanged() )
                    {
                        int i=pSV->Apply();
                        if(!i)
                            pSV->SetChanged(FALSE);
                        return i;
                    }
                    return 0;
                    break;

                case PSN_QUERYCANCEL:
                    return pSV->QueryCancel();
                    break;

                default:
                    break;
            }
        break;
    }

    if(pSV)
        return pSV->DlgProc(hDlg,uMessage,wParam,lParam);
    else
        return FALSE;
}

//
// When the page is changed, call this.
//
void  CPropPage::Changed()
{
    if(GetInit())
    {
        PropSheet_Changed(GetParent(), GetWindow());
        SetChanged(TRUE);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// You can override this DlgProc if you want to handle specific messages
//
BOOL CALLBACK CPropPage::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Below are just default handlers for the virtual functions.
//
int CPropPage::SetActive() { return 0; }

int CPropPage::Apply() { OutputDebugString(TEXT("Default Apply")); return 1; }

int CPropPage::QueryCancel() { return 0; }

int CPropPage::DoCommand(WORD wCmdID,WORD hHow)
{
    switch( hHow )
    {
    case EN_CHANGE:        // typed text into edit controls
    case BN_CLICKED:    // click buttons on the page.
    case LBN_SELCHANGE:
            Changed();
        break;
    }
    return 1;    // not handled, just did Apply work.
}

///////////////////////////////////////////////////////////////////////////////
//
// Wizard Pages.
//
BOOL CALLBACK CWizardPage::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch ( uMessage)
    {
        // Some notifications are dealt with as member functions.
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                    return SetActive();

                case PSN_WIZBACK:
                    return Back();

                case PSN_WIZNEXT:
                    return Next();

                case PSN_WIZFINISH:
                    return Finish();

                case PSN_KILLACTIVE:    // this is how Next on a Wizard is dealt with
                    return KillActive();

                case PSN_APPLY:
                    if( GetChanged() )
                    {
                        int i=Apply();
                        if(!i)
                            SetChanged(FALSE);
                        return i;
                    }
                    return 0;

                case PSN_QUERYCANCEL:

                    return QueryCancel();
                    break;

                default:
                    break;
            }
        break;
    }
    return CPropPage::DlgProc(hDlg, uMessage, wParam, lParam);
}

int CWizardPage::KillActive()
{
    return 0;
}

int CWizardPage::SetActive()
{
    if( m_bLast )
        PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_FINISH);
    else if ( GetPageNum()==0 )
        PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT );
    else
        PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT | PSWIZB_BACK);
    return 0;
}

int CWizardPage::Back()
{ return 0; }

int CWizardPage::Next()
{ SetResult(0); return 1; }

int CWizardPage::Finish()
{ return 0; }

int CWizardPage::Apply()
{ return 0; }

int CWizardPage::QueryCancel()
{
    if(m_pSheet)
    {
        if( m_pSheet->QueryCancel(GetParent()) == IDOK )
        {
            SetResult(FALSE); // Allow cancel.
            return FALSE;
        }
        else
        {
            SetResult(TRUE);    // Prevent cancel..
            return TRUE;
        }
    }

    DbgLog((LOG_TRACE,2,TEXT("No CWizardSheet handler provided\r")));
    return 0;
}


void CPropPage::EnableControlArray(const UINT FAR * puControls, BOOL bEnable)
{
    while( *puControls )
        EnableWindow(GetDlgItem(*puControls++),bEnable);
}

/////////////////////////////////////////////////////////////////////////////////////
//
// Makes sure that a control is bound to a range for the spinner control
// returns and displays the bounded value.
//
/////////////////////////////////////////////////////////////////////////////////////
DWORD CPropPage::GetBoundedValue(UINT idEditControl, UINT idSpinner)
{
    BOOL    bUpdate            =    FALSE;    // do we need to correct the value?
    DWORD     dwCurrentValue    =    GetTextValue(GetDlgItem(idEditControl));
    DWORD_PTR dwRange            =    SendDlgItemMessage(GetWindow(), idSpinner, UDM_GETRANGE, 0, 0);

    if(dwCurrentValue>LOWORD(dwRange))
    {
        dwCurrentValue=LOWORD(dwRange);
        bUpdate=TRUE;
    }
    else
    if(dwCurrentValue<HIWORD(dwRange))
    {
        dwCurrentValue=HIWORD(dwRange);
        bUpdate=TRUE;
    }

    if(bUpdate)
        SetTextValue(GetDlgItem(idEditControl), dwCurrentValue);
    return dwCurrentValue;
}


/////////////////////////////////////////////////////////////////////////////////////
//
// Sets the text of a window, to a given value.
//
/////////////////////////////////////////////////////////////////////////////////////
void CPropPage::SetTextValue(HWND hWnd, DWORD dwVal)
{
    TCHAR szTemp[MAX_PATH];
    wsprintf(szTemp,TEXT("%d"),dwVal);
    SetWindowText(hWnd, szTemp);
}

/////////////////////////////////////////////////////////////////////////////////////
//
// Returns the value of the text of a window
//
/////////////////////////////////////////////////////////////////////////////////////
DWORD CPropPage::GetTextValue(HWND hWnd)
{
    TCHAR szTemp[MAX_PATH];
    GetWindowText(hWnd, szTemp, MAX_PATH-1);
    return _tcstol(szTemp,NULL,0);
}

///////////////////////////////////////////////////////////////////////////////////
//
// Finds the edit control and bounds in to the range of the spinner control.
//
///////////////////////////////////////////////////////////////////////////////////
void CPropPage::GetBoundedValueArray(UINT iCtrl, PSPIN_CONTROL pSpinner)
{
    while(pSpinner->uiEditCtrl)
    {
        if(pSpinner->uiEditCtrl == iCtrl )
        {
            GetBoundedValue(iCtrl, pSpinner->uiSpinCtrl);
            break;
        }
        pSpinner++;
    }
}

/////////////////////////////////////////////////////////////////////////////////////
//
// Returns the value associated with the selected ComboBox text string.
// Parameters:
//      hWnd of the parent dialog box
//      ID of the ComboBox
//      array of text and values
//  Returns:
//      Returns the value of the selected item in list.
//
/////////////////////////////////////////////////////////////////////////////////////
UINT CPropPage::ConfigGetComboBoxValue(int wID, COMBOBOX_ENTRY  * pCBE)
{
    int nIndex;
    HWND hWndCB = GetDlgItem(wID);

    nIndex = (int) SendMessage (hWndCB, CB_GETCURSEL, 0, 0L);
    nIndex = max (0, nIndex);   // LB_ERR is negative
    return pCBE[nIndex].wValue;

}

void CPropPage::SetSheet(CSheet *pSheet)
{
    m_pSheet=pSheet;
}

DWORD CPropPage::GetTickValue(HWND hSlider)
{
    return (DWORD)SendMessage(hSlider, TBM_GETPOS, 0, 0);
}

void CPropPage::SetTickValue(DWORD dwVal, HWND hSlider, HWND hCurrent)
{
    SendMessage(hSlider, TBM_SETPOS, TRUE, dwVal);

//#ifdef _DEBUG
    SetTextValue(hCurrent, dwVal);
//#endif
}

void CPropPage::ShowText (UINT uIDString, UINT uIDControl, DWORD dwFlags)
{
    TCHAR szString[256];

    ShowWindow(GetDlgItem(uIDControl), dwFlags == 0 ? SW_HIDE: SW_SHOW);

    if (dwFlags != 0) {
        LoadString(GetInstance(), uIDString, szString, sizeof(szString)/sizeof(TCHAR));
        SetWindowText(GetDlgItem(uIDControl), szString);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\imgsize.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ImgSize.h

Abstract:

    A list of standard image size supported by VFWWDM and image devices.

    This list of image sizes will be used in additional to 
    the defalut image size supported by the capture devices.

Author:
        
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/
   

//
// Aspect Ratio 1:1 (Square Pixel, computer uses), 4:3 (TV uses)
//
#define IMG_AR11_CIF_CX 320
#define IMG_AR11_CIF_CY 240

#define IMG_AR43_CIF_CX 352
#define IMG_AR43_CIF_CY 288

typedef struct {
    SIZE    size;           // Width * Height
    DWORD   dwFlags;        // _VALID, _DEFAULT, or _SELECTED
    DWORD   cntDRVideo;     // Number of valid KS_DATARANGE_VIDEO for this size
    PKS_DATARANGE_VIDEO *ppDRVideo;        // Dynamically allocated; max is the number of Device's DR_Video  
} STD_IMAGEFORMAT, * PSTD_IMAGEFORMAT;


//
// List of standard image size used for video conferencing
//
const STD_IMAGEFORMAT tblStdImageFormat[] = {

    {IMG_AR11_CIF_CX/4, IMG_AR11_CIF_CY/4, 0,0,0},        //  80 x  60

    {IMG_AR43_CIF_CX/4, IMG_AR43_CIF_CY/4, 0,0,0},        //  88 x  72

    {128,                96              , 0,0,0},        // 128 x  96

    {IMG_AR11_CIF_CX/2, IMG_AR11_CIF_CY/2, 0,0,0},        // 160 x 120    
    {IMG_AR43_CIF_CX/2, IMG_AR43_CIF_CY/2, 0,0,0},        // 176 x 144

    {240,                176             , 0,0,0},        // 240 x 176   // SP1; for *16

    {240,                180             , 0,0,0},        // 240 x 180
 
    {IMG_AR11_CIF_CX,   IMG_AR11_CIF_CY  , 0,0,0},        // 320 x 240
    {IMG_AR43_CIF_CX,   IMG_AR43_CIF_CY  , 0,0,0},        // 352 x 288

    {IMG_AR11_CIF_CX*2, IMG_AR11_CIF_CY*2, 0,0,0},        // 640 x 480
    {IMG_AR43_CIF_CX*2, IMG_AR43_CIF_CY*2, 0,0,0},        // 704 x 576

    {720,               480              , 0,0,0},        // 720 x 480
    {720,               576              , 0,0,0}         // 720 x 576
};


const ULONG  cntStdImageFormat = sizeof(tblStdImageFormat)/sizeof(STD_IMAGEFORMAT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\imgcls.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ImgCls.cpp

Abstract:

    This is a stream pin handle class for the interface with a streaming pin 
  connection including open/close a connection pin and set its streaming state.

Author:
    
    FelixA 1996
    
Modified: 

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"


#include <ks.h>
#include "imgcls.h"

// Registry values
TCHAR gszDataFormat[]       = TEXT("DataFormat");       
TCHAR gszAvgTimePerFrame[]  = TEXT("AvgTimePerFrame");
TCHAR gszBitmapInfo[]       = TEXT("BitmapInfo");

CImageClass::CImageClass()
      : m_hKS(0),
        m_dwXferBufSize(0),
        m_bStreamReady(FALSE),  // Set to FALSE when ikn transition of switing device.
        m_dwPendingReads(0),
        m_pXferBuf(0),
        m_bChannelStarted(FALSE),
        m_bFormatChanged(FALSE),
        m_bPrepared(FALSE),
        m_pDataFormat(NULL),
        m_dwAvgTimePerFrame(0),
        m_pbiHdr(NULL)          
/*++
Routine Description:
    Constructor.
--*/
{
}


CImageClass::~CImageClass()
/*++
Routine Description:
  When destroying the class, unprepare and then stop the channels.
--*/
{
    StopChannel();  // PAUSE->STOP

    //
    // now clean up data
    //
    DbgLog((LOG_TRACE,2,TEXT("Destroying the image class, m_hKS=%x"), m_hKS));

    if(m_pXferBuf) {
        VirtualFree(m_pXferBuf, 0 , MEM_RELEASE);
        m_pXferBuf = NULL;
    }

    if( m_hKS ) {
        DbgLog((LOG_TRACE,2,TEXT("Close m_hKS")));
        if(!CloseHandle(m_hKS)) {
            DbgLog((LOG_TRACE,1,TEXT("CloseHandle() failed with GetLastError()=0x%x"), GetLastError()));
        }
    }

    if(m_pDataFormat) {
        VirtualFree(m_pDataFormat, 0, MEM_RELEASE);
        m_pDataFormat = 0;
    }

    if(m_pbiHdr) {
        VirtualFree(m_pbiHdr, 0, MEM_RELEASE);
        m_pbiHdr = 0;
    }
}


void 
CImageClass::CacheDataFormat(
    PKSDATAFORMAT pDataFormat
    ) 
/*++
Routine Description:
  Cache data format of the active stream. Only caches the fixed size KSDATAFORMAT.  
  AvgTimePerFrame and variable size BITMAPINFOHEADER are cached separately.
--*/
{
    if(!pDataFormat) {
        DbgLog((LOG_ERROR,0,TEXT("CacheDataFormat: pDataFormat is NULL!")));
        ASSERT(pDataFormat);
        return;
    }

    //
    // Note: pDataFormat->FormatSize is variable size,
    //       but we only cache sizeof(KSDATAFORMAT).
    //

    if(m_pDataFormat == NULL) 
       m_pDataFormat = (PKSDATAFORMAT) VirtualAlloc(NULL, sizeof(KSDATAFORMAT), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);    
       
    if(!m_pDataFormat) {
        DbgLog((LOG_ERROR,0,TEXT("CacheDataFormat: Allocate m_pDataFormat failed; size %d"), sizeof(KSDATAFORMAT)));
        ASSERT(m_pDataFormat);
        return;
    }
    
    CopyMemory(m_pDataFormat, pDataFormat, sizeof(KSDATAFORMAT));
}


void 
CImageClass::CacheBitmapInfoHeader(
    PBITMAPINFOHEADER pbiHdr
    ) 
/*++
Routine Description:
  Cache dvariable size BITMAPINFOHEADER whose size is in biSize.  
--*/
{
    if(!pbiHdr) {
        DbgLog((LOG_ERROR,0,TEXT("CacheBitmapInfoHeader: pbiHdr is NULL!")));
        ASSERT(pbiHdr);
        return;
    }

    if(pbiHdr->biSize < sizeof(BITMAPINFOHEADER)) {
        ASSERT(pbiHdr->biSize >= sizeof(BITMAPINFOHEADER) && "Invalid biSize!");
        return;
    }


    //
    // Cache only up to sizeof(BITMAPINFOHEADER)
    //
    if(m_pbiHdr == NULL) {
       m_pbiHdr = (PBITMAPINFOHEADER) VirtualAlloc(NULL, sizeof(BITMAPINFOHEADER), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    } else if(m_pbiHdr->biSize != pbiHdr->biSize) {
        VirtualFree(m_pbiHdr, 0 , MEM_RELEASE);
        m_pbiHdr = (PBITMAPINFOHEADER) VirtualAlloc(NULL, sizeof(BITMAPINFOHEADER), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    }
       
    if(!m_pbiHdr) {
        DbgLog((LOG_ERROR,0,TEXT("CacheBitmapInfoHeader: Allocate m_pbiHdr failed; Sz %d"), sizeof(BITMAPINFOHEADER)));
        ASSERT(m_pbiHdr);
        return;
    }
    
    CopyMemory(m_pbiHdr, pbiHdr, sizeof(BITMAPINFOHEADER));
}


void 
CImageClass::SetDataFormatVideoToReg(
  )
/*++
Routine Description:
    Save the cached fixed sized KSDATAFORMAT, AvgTimePerFrame and variable-sized BITMAPINFOHEADER 
    of currently active stream.
--*/  
{
    //
    // Save KSDATAFORMAT (sizeof(KSDATFORMAT) only).
    //
    if(!m_pDataFormat) {
        DbgLog((LOG_ERROR,0,TEXT("SetDataFormatVideoToReg: m_pDataFormat is NULL!")));
        ASSERT(m_pDataFormat);
        return;
    }
    LONG lResult = SetRegistryValue(GetDeviceRegKey(), gszDataFormat, sizeof(KSDATAFORMAT), (LPBYTE) m_pDataFormat, REG_BINARY);
    ASSERT(ERROR_SUCCESS == lResult);


    //
    // Save frame rate
    //
    lResult = SetRegistryValue(GetDeviceRegKey(), gszAvgTimePerFrame, sizeof(DWORD), (LPBYTE) &m_dwAvgTimePerFrame, REG_DWORD);
    ASSERT(ERROR_SUCCESS == lResult);


    //
    // save BITMAPINFOHEADER (variable size)
    //
    if(!m_pbiHdr) {
        DbgLog((LOG_ERROR,0,TEXT("SetDataFormatVideoToReg: m_pbiHdr is NULL!")));
        ASSERT(m_pbiHdr);
        return;
    }

    ASSERT(m_pbiHdr->biSize >= sizeof(BITMAPINFOHEADER));
    if(m_pbiHdr->biSize >= sizeof(BITMAPINFOHEADER)) {
        // We only write up to sizeof(BITMAPINFOHEADER)
        lResult = SetRegistryValue(GetDeviceRegKey(), gszBitmapInfo, sizeof(BITMAPINFOHEADER), (LPBYTE) m_pbiHdr, REG_BINARY);    
        ASSERT(ERROR_SUCCESS == lResult);
    }
}



BOOL 
CImageClass::GetDataFormatVideoFromReg(
    ) 
/*++
Routine Description:
    Retrieve the persisted fixed sized KSDATAFORMAT, AvgTimePerFrame and variable-sized BITMAPINFOHEADER 
    to a locally cache variables.
--*/
{
    DWORD dwRegValueSize = 0, dwType;
    LONG lResult;
    BOOL bExistingFormat = TRUE;

    //
    // Get KSDATAFORMAT (only sizeof KSDATARANGE)
    //
    lResult = QueryRegistryValue(GetDeviceRegKey(), gszDataFormat, 0, 0, &dwType, &dwRegValueSize);

    if(ERROR_SUCCESS == lResult) {
        ASSERT(dwRegValueSize == sizeof(KSDATARANGE));
        ASSERT(dwType         == REG_BINARY);

        if(m_pDataFormat == NULL) {
            m_pDataFormat = (PKSDATARANGE) VirtualAlloc(NULL, sizeof(KSDATARANGE), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        } 

        if(!m_pDataFormat) {
            DbgLog((LOG_ERROR,0,TEXT("GetDataFormatVideoFromReg: Allocate m_pDataFormat failed; Size %d"), sizeof(KSDATARANGE)));
            ASSERT(m_pDataFormat);
            return FALSE;
        }

        lResult = QueryRegistryValue(GetDeviceRegKey(), gszDataFormat, sizeof(KSDATARANGE), (LPBYTE) m_pDataFormat, &dwType, &dwRegValueSize);
        ASSERT(m_pDataFormat->FormatSize >= sizeof(KSDATARANGE));

    } else {
        // Delete the stale DataFormat.
        if(m_pDataFormat) {
             VirtualFree(m_pDataFormat, 0 , MEM_RELEASE);
             m_pDataFormat = NULL;
        }
    }

    // If registry key was not defined, create a default.        
    if(!m_pDataFormat) {        
        m_pDataFormat = (PKSDATARANGE) VirtualAlloc(NULL, sizeof(KSDATARANGE), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

        if(m_pDataFormat) {
            ZeroMemory(m_pDataFormat, sizeof(KSDATARANGE));
            m_pDataFormat->FormatSize = sizeof(KSDATARANGE);
        }

        bExistingFormat = FALSE;
    }


    //
    // Initialize frame rate
    //
    lResult = QueryRegistryValue(GetDeviceRegKey(), gszAvgTimePerFrame, sizeof(DWORD), (LPBYTE) &m_dwAvgTimePerFrame, &dwType, &dwRegValueSize);


    //
    // Get BITMAPINFOHEADER
    //
    lResult = QueryRegistryValue(GetDeviceRegKey(), gszBitmapInfo, 0, 0, &dwType, &dwRegValueSize);

    if(ERROR_SUCCESS  == lResult && 
       dwRegValueSize == sizeof(BITMAPINFOHEADER)) {
        ASSERT(sizeof(BITMAPINFOHEADER) <= dwRegValueSize);
        ASSERT(dwType == REG_BINARY);

        if(m_pbiHdr == NULL) {
            // Get data up to sizeof(BITMAPINFOHEADER)
            m_pbiHdr = (PBITMAPINFOHEADER) VirtualAlloc(NULL, sizeof(BITMAPINFOHEADER), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);        

            if(!m_pbiHdr) {
                DbgLog((LOG_ERROR,0,TEXT("GetDataFormatVideoFromReg: Allocate m_pbiHdr failed; biSize %d"), dwRegValueSize));
                ASSERT(m_pbiHdr);
                return FALSE;
            }
        }

        // Get data up to sizeof(BITMAPINFOHEADER)
        lResult = QueryRegistryValue(GetDeviceRegKey(), gszBitmapInfo, sizeof(BITMAPINFOHEADER), (LPBYTE) m_pbiHdr, &dwType, &dwRegValueSize);
        ASSERT(m_pbiHdr->biSize == sizeof(BITMAPINFOHEADER));  // This is all we support.        

    } else {
        // Remove stale BitmapInfoHeader.
        if(m_pbiHdr) {
             VirtualFree(m_pbiHdr, 0 , MEM_RELEASE);
             m_pbiHdr = NULL;
        }
    }
   
    // If registry key was not defined, create a default BITMAPINFOHEADER with biSize set.    
    if(!m_pbiHdr) {        
        m_pbiHdr = (PBITMAPINFOHEADER) VirtualAlloc(NULL, sizeof(BITMAPINFOHEADER), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if(m_pbiHdr) {
            ZeroMemory(m_pbiHdr, sizeof(BITMAPINFOHEADER));
            m_pbiHdr->biSize = sizeof(BITMAPINFOHEADER);
        }
        bExistingFormat = FALSE;
    }

    return bExistingFormat;
}



DWORD CImageClass::GetImageOverlapped(
  LPBYTE pB, 
  BOOL bDirect, 
  DWORD * pdwBytesUsed,
  DWORD * pdwFlags,
  DWORD * pdwTimeCaptured)
/*++
Routine Description:
  Does overlapped reads of images, and translates them.
  if 'direct' then it reads directly into the buffer, no Translate buffer call.
  
Argument:

Return Value:

--*/
{
    *pdwBytesUsed = 0;

    if(GetDeviceRemoved())
       return DV_ERR_INVALHANDLE;

    if(!pB || !GetDriverHandle() || !m_hKS) {
        DbgLog((LOG_TRACE,1,TEXT("No buffer(%x), no driver(%x) or no PIN connection(%x); rtn DV_ERR_INVALHANDLE."), pB, GetDriverHandle(), m_hKS));
        return DV_ERR_INVALHANDLE;
    }

    if(!PrepareChannel()) {    
        DbgLog((LOG_TRACE,1,TEXT("Cannot set streaming state to KSSTATE_RUN !!")));
        return DV_ERR_UNPREPARED;
    }

    if(!StartChannel()) {
        DbgLog((LOG_TRACE,1,TEXT("Cannot set streaming state to KSSTATE_RUN !!")));
        return DV_ERR_UNPREPARED;
    }

    m_dwPendingReads++;

    //
    // Special code to get images from the StreamClass.
    //
    DWORD cbBytesReturned;
    KS_HEADER_AND_INFO SHGetImage;

    ZeroMemory(&SHGetImage,sizeof(SHGetImage));
    SHGetImage.StreamHeader.Data            = (LPDWORD) (bDirect ? pB : GetTransferBuffer());  
    DbgLog((LOG_TRACE,3,TEXT("\'Direct(%s); SHGetImage.StreamHeader.Data =0x%x"), bDirect?"TRUE":"FALSE", SHGetImage.StreamHeader.Data));

    SHGetImage.StreamHeader.Size            = sizeof (KS_HEADER_AND_INFO);
    SHGetImage.StreamHeader.FrameExtent     = GetTransferBufferSize();
    SHGetImage.FrameInfo.ExtendedHeaderSize = sizeof (KS_FRAME_INFO);



    HRESULT hr = 
         SyncDevIo(
             m_hKS,
             IOCTL_KS_READ_STREAM,
             &SHGetImage,
             sizeof(SHGetImage),
             &SHGetImage,
             sizeof(SHGetImage),
             &cbBytesReturned);

    //
    // If the Ioctl was timed out:
    //
    if(ERROR_IO_INCOMPLETE == HRESULT_CODE(hr)) {
        DbgLog((LOG_TRACE,1,TEXT("SyncDevIo() with LastError %x (?= ERROR_IO_INCOMPLETE %x); StreamState->STOP to reclaim buffer."), hr, ERROR_IO_INCOMPLETE));

        if(!StopChannel())       // PAUSE->STOP, set m_dwPendingReads to 0 if success.      
           m_dwPendingReads--;   // If failed, this pending read is probably suspended forever.

        return DV_ERR_NONSPECIFIC;
    } 

  
    if(SHGetImage.StreamHeader.FrameExtent < SHGetImage.StreamHeader.DataUsed) {
        DbgLog((LOG_ERROR,1,TEXT("BufSize=FrameExtended=%d < DataUsed=%d; OptionsFlags=0x%x"), SHGetImage.StreamHeader.FrameExtent, SHGetImage.StreamHeader.DataUsed, SHGetImage.StreamHeader.OptionsFlags));
        m_dwPendingReads--;
        ASSERT(SHGetImage.StreamHeader.FrameExtent >= SHGetImage.StreamHeader.DataUsed);
        return DV_ERR_SIZEFIELD;

    } else {
        if(NOERROR == hr) {
            *pdwBytesUsed = SHGetImage.StreamHeader.DataUsed; 
            if((SHGetImage.FrameInfo.dwFrameFlags & (KS_VIDEO_FLAG_P_FRAME | KS_VIDEO_FLAG_B_FRAME)) == KS_VIDEO_FLAG_I_FRAME)
                *pdwFlags |= VHDR_KEYFRAME;
        } else {
            *pdwBytesUsed = 0; 
        }
    }
  

    if(!bDirect) {
        if(NOERROR == hr) {
            CopyMemory(pB, SHGetImage.StreamHeader.Data, SHGetImage.StreamHeader.DataUsed);
        }
    }
    m_dwPendingReads--;

    return DV_ERR_OK;
}


BOOL CImageClass::StartChannel()
/*++
Routine Description:
  Starts the channel - takes us from Pause to Run (will also go Stop -> Pause if required)

Argument:

Return Value:

--*/
{
    if(m_bChannelStarted)
        return TRUE;
    //
    // Stop -> Pause if not already in Pause state.
    //
    if( PrepareChannel() )
        m_bChannelStarted = SetState(KSSTATE_RUN);

    return m_bChannelStarted;
}


BOOL CImageClass::PrepareChannel()
/*++
Routine Description:
  Prepares the channel. takes us from Stop -> Pause
  
Argument:

Return Value:

--*/
{
    if(!m_bPrepared)
        m_bPrepared=SetState(KSSTATE_PAUSE);

    return m_bPrepared;
}


BOOL CImageClass::StopChannel()
/*++
Routine Description:
  Stops the channel. Pause->Stop  
Argument:

Return Value:

--*/
{
    if(m_bChannelStarted) {
       if(UnprepareChannel()) {
            if(SetState( KSSTATE_STOP )) {
                m_bChannelStarted=FALSE;
                // If stop successfully, all pending reads are cleared.
                m_dwPendingReads = 0;
            } else {
                DbgLog((LOG_TRACE,1,TEXT("StopChannel: failed to set to STOP state!")));
            }
       } else {
          DbgLog((LOG_TRACE,1,TEXT("StopChannel: failed to set to PAUSE state!")));
       }

    } else {
        DbgLog((LOG_TRACE,1,TEXT("StopChannel: already stopped!")));
    }

    return m_bChannelStarted==FALSE;
}



BOOL CImageClass::UnprepareChannel()
/*++
Routine Description:
  Un-prepares the channel if it was previously prepared.
  Run->Pause.  

Argument:

Return Value:

--*/
{
    if(m_bPrepared) {
  
    if(SetState(KSSTATE_PAUSE))
        m_bPrepared=FALSE;
    }

    return m_bPrepared==FALSE;
}


BOOL CImageClass::SetState(
  KSSTATE ksState)
/*++
Routine Description:
  Sets the state of the Pin.

Argument:

Return Value:

--*/
{
    KSPROPERTY  ksProp={0};
    DWORD    cbRet;

    ksProp.Set  = KSPROPSETID_Connection ;
    ksProp.Id   = KSPROPERTY_CONNECTION_STATE;
    ksProp.Flags= KSPROPERTY_TYPE_SET;

    HRESULT hr = 
        SyncDevIo( 
            m_hKS, 
            IOCTL_KS_PROPERTY, 
            &ksProp, 
            sizeof(ksProp), 
            &ksState, 
            sizeof(KSSTATE), 
            &cbRet);

    if(hr != NOERROR) {
        DbgLog((LOG_TRACE,1,TEXT("SetState: failed with hr %x"), hr));
    }

    return NOERROR == hr;
}


BOOL 
CImageClass::GetAllocatorFraming(
    HANDLE PinHandle,
    PKSALLOCATOR_FRAMING pFraming
    )

/*++

Routine Description:
    Retrieves the allocator framing structure from the given pin.

Arguments:
    HANDLE PinHandle -
        handle of pin

    PKSALLOCATOR_FRAMING Framing -
        pointer to allocator framing structure

Return:
    TRUE (Succeeded) or FALSE.

--*/

{   
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;
    Property.Flags = KSPROPERTY_TYPE_GET;
    pFraming->Frames = 0;     // Will be overwritten by driver

    HRESULT hr = SyncDevIo(
        PinHandle, 
        IOCTL_KS_PROPERTY, 
        &Property, 
        sizeof(Property), 
        pFraming,
        sizeof(*pFraming),
        &BytesReturned );

    DbgLog((LOG_TRACE,1,TEXT("AllocFrm: hr %x, frm %d; Sz %d; Align %x"),
              hr,
              pFraming->Frames, 
              pFraming->FrameSize, 
              pFraming->FileAlignment)); 
    
    //
    // If not set (0), set to default.
    //
    if(hr != NOERROR  || 
       pFraming->Frames <= 1) {
        DbgLog((LOG_TRACE,1,TEXT("pFraming->Frames = %d change to 2"), pFraming->Frames));
        pFraming->Frames = 2;
    }   
        
    return NOERROR == hr;
}

BOOL
CImageClass::GetStreamDroppedFramesStastics(                                          
    KSPROPERTY_DROPPEDFRAMES_CURRENT_S *pDroppedFramesCurrent    
    )
/*++

Routine Description:
    Internal, general routine to get the only property for this property set.
    These information is dynamic so they are not cached.

Arguments:

Return Value:


--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;


    if(!m_hKS) {
        return FALSE;      
    }

    if (!pDroppedFramesCurrent) {
        return FALSE;      
    }


    Property.Set = PROPSETID_VIDCAP_DROPPEDFRAMES;
    Property.Id = KSPROPERTY_DROPPEDFRAMES_CURRENT;
    Property.Flags = KSPROPERTY_TYPE_GET;

    HRESULT hr = SyncDevIo(
        m_hKS, 
        IOCTL_KS_PROPERTY, 
        &Property, 
        sizeof(Property), 
        pDroppedFramesCurrent,
        sizeof(*pDroppedFramesCurrent),
        &BytesReturned );    
    
    if(NOERROR == hr) {
        DbgLog((LOG_TRACE,1,TEXT("Frame requirements: PicNum=%d, DropCount=%d, AvgFrameSize=%d"),
        (DWORD) pDroppedFramesCurrent->PictureNumber,
        (DWORD) pDroppedFramesCurrent->DropCount,
        (DWORD) pDroppedFramesCurrent->AverageFrameSize)); 
        return DV_ERR_OK;
    } else {
        pDroppedFramesCurrent->PictureNumber = 0;
        pDroppedFramesCurrent->DropCount = 0;
        pDroppedFramesCurrent->AverageFrameSize = 0;
        return DV_ERR_NOTSUPPORTED;
    }

    return NOERROR == hr;
}


BOOL 
CImageClass::ValidateImageSize(
   KS_VIDEO_STREAM_CONFIG_CAPS * pVideoCfgCaps,
   LONG  biWidth,
   LONG  biHeight
   )
{
   if (pVideoCfgCaps->OutputGranularityX == 0 || pVideoCfgCaps->OutputGranularityY == 0) {

      // Support only one size for this DataRangeVideo
      if (pVideoCfgCaps->InputSize.cx == biWidth && 
          pVideoCfgCaps->InputSize.cy == biHeight ) {

         return TRUE;
        }
      else {
         return FALSE;
        }
   } 
    else {   
      // Support multiple sizes so make sure that that fit the criteria
      if (pVideoCfgCaps->MinOutputSize.cx <= biWidth && 
         biWidth <= pVideoCfgCaps->MaxOutputSize.cx &&
         pVideoCfgCaps->MinOutputSize.cy <= biHeight && 
         biHeight <= pVideoCfgCaps->MaxOutputSize.cy &&   
         ((biWidth  % pVideoCfgCaps->OutputGranularityX) == 0) &&
         ((biHeight % pVideoCfgCaps->OutputGranularityY) == 0)) {

         return TRUE;
        }
      else {
         return FALSE;
        }
   }
}


PKSDATAFORMAT
CImageClass::VfWWDMDataIntersection(
    // It is a variable length structure, and its length is in ->FormatSize.
    // Most likely it is a KS_DATARANGE_VIDEO or KS_DATARANGE_VIDEO2
    PKSDATARANGE      pDataRange,
    PKSDATAFORMAT     pCurrentDataFormat,
    DWORD             AvgTimePerFrame,   // DWORD is big enought instead of ULONGLONG; average time per frame (100ns units)
    PBITMAPINFOHEADER pBMIHeader
    )
/*++
Routine Description:

    Given a KSDATARANGE, query driver for a acceptable KS_DATAFORMAT_VIDEOINFOHEADER and return it.
    Note: Caller is responsible for freeing this memory.

Argument:

Return Value:

--*/
{
    ULONG             BytesReturned;
    ULONG             ulInDataSize;
    PKSP_PIN          pKsPinHdr;  
    PKSMULTIPLE_ITEM  pMultipleItem;
    PKS_DATARANGE_VIDEO  pDRVideoQuery;
    PKS_BITMAPINFOHEADER pBMIHdrTemp;

    PKSDATAFORMAT     pDataFormatHdr = 0;   // return pointer


    //
    // We support only _VIDEOINFO for capture pin
    // Note: _VIDEOINFO2 only for the preview pin
    //
    if(pDataRange->Specifier != KSDATAFORMAT_SPECIFIER_VIDEOINFO) {    
        return 0;
    }


#if 0
    //
    // If there is an active format, make sure the new format type matches the comparing data range's format.
    //
    if(pCurrentDataFormat) {
        if(!IsEqualGUID (pCurrentDataFormat->MajorFormat, pDataRange->MajorFormat)) {
           DbgLog((LOG_TRACE,2,TEXT("DtaIntrSec: MajorFormat does not match!")));
           return 0;
        }

        if(!IsEqualGUID (pCurrentDataFormat->SubFormat, pDataRange->SubFormat)) {
           DbgLog((LOG_TRACE,2,TEXT("DtaIntrSec: SubFormat does not match!")));
           return 0;
        }
    }
#endif

    if(pBMIHeader) {
        //
        // Validate biCompression
        //
        if(((PKS_DATARANGE_VIDEO)pDataRange)->VideoInfoHeader.bmiHeader.biCompression != pBMIHeader->biCompression) {
            DbgLog((LOG_TRACE,1,TEXT("DtaIntrSec: DataRange biCompression(%x) != requested (%x)"),               
                ((PKS_DATARANGE_VIDEO)pDataRange)->VideoInfoHeader.bmiHeader.biCompression,
                pBMIHeader->biCompression));                            
           return 0;
        }

        //
        // Validate biBitCount; e.g.  (RGB565:16; RGB24:24)
        //
        if(((PKS_DATARANGE_VIDEO)pDataRange)->VideoInfoHeader.bmiHeader.biBitCount != pBMIHeader->biBitCount) {
            DbgLog((LOG_TRACE,1,TEXT("DtaIntrSec: DataRange biBitCount(%d) != requested (%d)"),               
                ((PKS_DATARANGE_VIDEO)pDataRange)->VideoInfoHeader.bmiHeader.biBitCount,
                pBMIHeader->biBitCount));                            
           return 0;
        }

       //
       // Validate image dimension
       //
       if (!ValidateImageSize ( &((PKS_DATARANGE_VIDEO)pDataRange)->ConfigCaps, pBMIHeader->biWidth, pBMIHeader->biHeight)) {
           DbgLog((LOG_TRACE,1,TEXT("DtaIntrSec: unsupported size (%d,%d) for pDataRange"), 
               pBMIHeader->biWidth, pBMIHeader->biHeight));
           return 0;
       }
    }


    if(AvgTimePerFrame) {
        //
        // Validate frame rate
        //
        if(AvgTimePerFrame < ((PKS_DATARANGE_VIDEO) pDataRange)->ConfigCaps.MinFrameInterval ||
            AvgTimePerFrame > ((PKS_DATARANGE_VIDEO) pDataRange)->ConfigCaps.MaxFrameInterval) {

            DbgLog((LOG_TRACE,1,TEXT("DtaIntrSec: %d OutOfRng (%d, %d)"),
                AvgTimePerFrame,
                (DWORD) ((PKS_DATARANGE_VIDEO) pDataRange)->ConfigCaps.MinFrameInterval,
                (DWORD) ((PKS_DATARANGE_VIDEO) pDataRange)->ConfigCaps.MaxFrameInterval 
                ));
#if 0  // Let driver decided            
            return 0;
#endif
        }
    }


    //
    // Prepare IntersectInfo->DataFormatBuffer which consistes of
    //    (In1) KSP_PIN 
    //    (In2) KSMULTIPLE_ITEM
    //    (In3) KS_DATARANGE_VIDEO whose size is in KSDATARANGE->FormatSize
    //
    ulInDataSize = sizeof(KSP_PIN) + sizeof(KSMULTIPLE_ITEM) + pDataRange->FormatSize;
    pKsPinHdr = (PKSP_PIN) new BYTE[ulInDataSize];
    if(!pKsPinHdr) { 
        DbgLog((LOG_TRACE,1,TEXT("DtaIntrSec: allocate pKsPinHdr failed!")));
        return 0;
    }

    ZeroMemory(pKsPinHdr, ulInDataSize);

    // (In1)
    pKsPinHdr->Property.Set   = KSPROPSETID_Pin;
    pKsPinHdr->Property.Id    = KSPROPERTY_PIN_DATAINTERSECTION;
    pKsPinHdr->Property.Flags = KSPROPERTY_TYPE_GET;
    pKsPinHdr->PinId    = GetCapturePinID();   
    pKsPinHdr->Reserved = 0;
    // (In2) 
    pMultipleItem = (PKSMULTIPLE_ITEM) (pKsPinHdr + 1);
    pMultipleItem->Size = pDataRange->FormatSize + sizeof(KSMULTIPLE_ITEM);
    pMultipleItem->Count = 1;
    // (In3) 
    pDRVideoQuery = (PKS_DATARANGE_VIDEO) (pMultipleItem + 1);
    memcpy(pDRVideoQuery, pDataRange, pDataRange->FormatSize);
    
#if 0 // Bug # 654933
    // Set a requirement that has been there for a long time.
    pDRVideoQuery->bFixedSizeSamples    = TRUE;  // Support only fixed sample size.
#endif

    //
    // Default as the DataRange advertised by the driver.
    // Since it is a data range, some of its varibles may be acceptable, such as    
    //     AvgTimePerFrame (frame rate), 
    //     biWidth, biHeight and biCompression (image dimension)
    //

    if(AvgTimePerFrame) {
        DbgLog((LOG_TRACE,1,TEXT("DtaIntrSec: FrmRate %d to %d msec/Frm"), 
             (ULONG) ((PKS_DATARANGE_VIDEO) pDataRange)->VideoInfoHeader.AvgTimePerFrame/10000, AvgTimePerFrame/10000));
        pDRVideoQuery->VideoInfoHeader.AvgTimePerFrame = AvgTimePerFrame;
    }

    if(pBMIHeader) {

        // Support only pDataRange->Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO
        pBMIHdrTemp = &pDRVideoQuery->VideoInfoHeader.bmiHeader;

        DbgLog((LOG_TRACE,1,TEXT("DtaIntrSec: OLD: %x:%dx%dx%d=%d to NEW: %x:%dx%dx%d=%d"), 
            pBMIHdrTemp->biCompression, pBMIHdrTemp->biWidth, pBMIHdrTemp->biHeight, pBMIHdrTemp->biBitCount, pBMIHdrTemp->biSizeImage,
            pBMIHeader->biCompression, pBMIHeader->biWidth, pBMIHeader->biHeight, pBMIHeader->biBitCount, pBMIHeader->biSizeImage));

        if(pBMIHeader->biWidth != 0 && pBMIHeader->biHeight != 0) {
            pBMIHdrTemp->biWidth       = pBMIHeader->biWidth;
            pBMIHdrTemp->biHeight      = pBMIHeader->biHeight;
            pBMIHdrTemp->biBitCount    = pBMIHeader->biBitCount;
        }    

        //
        // This field suppose to be filled by the driver but some don't so 
        // we set to a fix frame size. This may change by driver.
        //
        pBMIHdrTemp->biSizeImage   = pBMIHeader->biWidth * pBMIHeader->biHeight * pBMIHeader->biBitCount / 8;
    }




    DbgLog((LOG_TRACE,2,TEXT("DtaIntrSec: pKsPinHdr %x, pMultipleItem %x, pDataRange %x"), pKsPinHdr, pMultipleItem, pMultipleItem + 1));


    //
    // Query result buffer size, which has a format of     
    //    KS_DATAFORMAT_VIDEOINFOHEADER
    //    (Out1) KSDATAFORMAT            DataFormat;
    //    (Out2) KS_VIDEOINFOHEADER      VideoInfoHeader;  // or KS_VIDEOINFOHEADER2
    //

    // <Copied from KsProxy>
    // Perform the data intersection with the data range, first to obtain
    // the size of the resultant data format structure, then to retrieve
    // the actual data format.
    //
    
    HRESULT hr = 
        SyncDevIo(
            GetDriverHandle(),
            IOCTL_KS_PROPERTY,
            pKsPinHdr,
            ulInDataSize,
            NULL,
            0,
            &BytesReturned);

#if 1
//!! This goes away post-Beta!!    
    if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ULONG ItemSize;

        hr = SyncDevIo(
                GetDriverHandle(),
                IOCTL_KS_PROPERTY,
                pKsPinHdr,
                ulInDataSize,
                &ItemSize,
                sizeof(ItemSize),
                &BytesReturned);

        if(SUCCEEDED(hr)) {
            BytesReturned = ItemSize;
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        }
    }
#endif

    if(hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {

        ASSERT(BytesReturned >= sizeof(*pDataFormatHdr));

        pDataFormatHdr = (PKSDATAFORMAT) new BYTE[BytesReturned];
        if(!pDataFormatHdr) {
            delete [] pKsPinHdr;
            pKsPinHdr = NULL;
            return 0;
        }

        ZeroMemory(pDataFormatHdr, BytesReturned);


        hr = SyncDevIo(
                GetDriverHandle(),
                IOCTL_KS_PROPERTY,
                pKsPinHdr,
                ulInDataSize,
                pDataFormatHdr,
                BytesReturned,
                &BytesReturned);

        if(SUCCEEDED(hr)) {

            ASSERT(pDataFormatHdr->FormatSize == BytesReturned);
#if DBG
            //
            // Validate return frame rate and image dimension with requested
            //
            if(AvgTimePerFrame) {
                ASSERT(pDRVideoQuery->VideoInfoHeader.AvgTimePerFrame == AvgTimePerFrame && "FrameRate altered!");
            }

            if(pBMIHeader && pBMIHdrTemp) {
                ASSERT(pBMIHdrTemp->biWidth    == pBMIHeader->biWidth);
                ASSERT(pBMIHdrTemp->biHeight   == pBMIHeader->biHeight);
                ASSERT(pBMIHdrTemp->biBitCount == pBMIHeader->biBitCount);
            }
#endif

        } else {
            // Error so return NULL;
            delete [] pDataFormatHdr; 
            pDataFormatHdr = NULL;
        }
    }

    delete [] pKsPinHdr; 
    pKsPinHdr = 0;

    return pDataFormatHdr;
}



DWORD 
CImageClass::CreatePin(
    PKSDATAFORMAT     pCurrentDataFormat,
    DWORD             dwAvgTimePerFrame,
    PBITMAPINFOHEADER pbiNewHdr
    )
/*++
Routine Description:
    Mapper read data directly out of the capture pin and it is open in the routine, and it is also our assumtion that 
    every capture deive has a capture pin.  
    We are passed three selection criteria: DATAFORMAT, AvgTimePerFrame and BITMAPINFOHEADER.
    If they are present, then there must be a match; else, the first DATARANGE of the device is used.
--*/
{
    PKSMULTIPLE_ITEM pMultItemsHdr;
    PKSDATARANGE  pDataRange;
    PKSDATAFORMAT pDataFormat = NULL;

    pMultItemsHdr = GetDriverSupportedDataRanges();
    if(!pMultItemsHdr) {
        return DV_ERR_NONSPECIFIC;
    }

    //
    // First try to find a match using the persist value;
    // if there is no match and we were asked to use any format (!dwAvgTimePerFrame || !pbiNewHdr),
    // we try again and use any default range.
    //
    pDataRange = (PKSDATARANGE) (pMultItemsHdr + 1);
    for(ULONG i=0; i < pMultItemsHdr->Count; i++) {

        // Use persisted format
        pDataFormat = 
            VfWWDMDataIntersection(
                pDataRange,
                pCurrentDataFormat,
                dwAvgTimePerFrame ? dwAvgTimePerFrame : GetCachedAvgTimePerFrame(),
                pbiNewHdr ? pbiNewHdr : GetCachedBitmapInfoHeader());

        if(pDataFormat) 
            break;

        // Adjust pointer to next KS_DATAFORMAT_VIDEO/2
        // Note: KSDATARANGE is LONGLONG (16 bytes) aligned
        pDataRange = (PKSDATARANGE) ((PBYTE) pDataRange + ((pDataRange->FormatSize + 7) & ~7));
    }

    //
    // Data intersection results no match!
    //
    if(!pDataFormat) {
        if(!dwAvgTimePerFrame || !pbiNewHdr) {
            pDataRange = (PKSDATARANGE) (pMultItemsHdr + 1);
            for(ULONG i=0; i < pMultItemsHdr->Count; i++) {

                // Use default format
                pDataFormat = 
                    VfWWDMDataIntersection(
                        pDataRange,
                        0,    // No matching; so we take any format.
                        dwAvgTimePerFrame,
                        pbiNewHdr);

                if(pDataFormat) 
                    break;

                // Adjust pointer to next KS_DATAFORMAT_VIDEO/2
                pDataRange = (PKSDATARANGE) (((PBYTE) pDataRange) + ((pDataRange->FormatSize + 7) & ~7));
            }

            //
            // Data intersection results no match!
            //
            if(!pDataFormat) {
                return DV_ERR_NONSPECIFIC;
            }
        } else {
            return DV_ERR_NONSPECIFIC;
        }
    }


    //
    // Connect to a new PIN.
    //
    ULONG ulConnectStructSize = sizeof(KSPIN_CONNECT) + pDataRange->FormatSize;

    //
    // (1) KSPIN_CONNECT
    // (2) KS_DATAFORMAT_VIDEOINFOHEADER
    //     (2A) KSDATAFORMAT       
    //     (2B) KS_VIDEOINFOHEADER      
    //
    PKSPIN_CONNECT pKsPinConnectHdr = (PKSPIN_CONNECT) new BYTE[ulConnectStructSize];

    if(!pKsPinConnectHdr) {
        delete [] pDataFormat;
        pDataFormat = 0;
        return DV_ERR_NONSPECIFIC;
    }

    ZeroMemory(pKsPinConnectHdr, ulConnectStructSize);


    PKS_DATAFORMAT_VIDEOINFOHEADER pKsDRVideo = (PKS_DATAFORMAT_VIDEOINFOHEADER) (pKsPinConnectHdr+1);

    // (1) Set KSPIN_CONNECT
    pKsPinConnectHdr->PinId         = GetCapturePinID();  // sink
    pKsPinConnectHdr->PinToHandle   = NULL;        // no "connect to"
    pKsPinConnectHdr->Interface.Set = KSINTERFACESETID_Standard;
    pKsPinConnectHdr->Interface.Id  = KSINTERFACE_STANDARD_STREAMING;
    pKsPinConnectHdr->Medium.Set    = KSMEDIUMSETID_Standard;
    pKsPinConnectHdr->Medium.Id     = KSMEDIUM_STANDARD_DEVIO;
    pKsPinConnectHdr->Priority.PriorityClass    = KSPRIORITY_NORMAL;
    pKsPinConnectHdr->Priority.PrioritySubClass = 1;


    // (2) Copy KSDATAFORMAT
    CopyMemory(pKsDRVideo, pDataFormat, pDataFormat->FormatSize);

    // Get BITMAPINFOHEADER
    PKS_BITMAPINFOHEADER pBMInfoHdr = &pKsDRVideo->VideoInfoHeader.bmiHeader;   
    

    DWORD dwErr = 
        KsCreatePin( 
            GetDriverHandle(), 
            pKsPinConnectHdr, 
            GENERIC_READ | GENERIC_WRITE,   // Read stream, and READ/WRITE stream state.
            &m_hKS 
            ); 
    
    DbgLog((LOG_TRACE,1,TEXT("#KsCreatePin()# dwErr %x; hKS %x"), dwErr, m_hKS ));
    DbgLog((LOG_TRACE,1,TEXT("4CC(%x); (%d*%d*%d/8=%d); AvgTm %d"),
        pBMInfoHdr->biCompression,
        pBMInfoHdr->biWidth,
        pBMInfoHdr->biHeight,
        pBMInfoHdr->biBitCount,
        pBMInfoHdr->biSizeImage,
        (DWORD) (pKsDRVideo->VideoInfoHeader.AvgTimePerFrame/10000)
        ));

    if(dwErr || m_hKS == NULL || m_hKS == (HANDLE) -1) {     
        if(m_hKS == (HANDLE) -1) 
            m_hKS = 0;       

        delete [] pDataFormat;
        pDataFormat = 0;

        delete [] pKsPinConnectHdr;
        pKsPinConnectHdr = 0;

        return DV_ERR_NONSPECIFIC; // VFW_VIDSRC_PIN_OPEN_FAILED;
    }


    //
    // Format change is taking place.
    //
    LogFormatChanged(FALSE);


    //
    // Query how to best allocate frame
    //
    if(GetAllocatorFraming(m_hKS, &m_AllocatorFraming)) {
        ASSERT(m_AllocatorFraming.FrameSize == pBMInfoHdr->biSizeImage);
        pBMInfoHdr->biSizeImage = m_AllocatorFraming.FrameSize;  // BI_RGB can set biSizeImage to 0.
    }
    else {
        pBMInfoHdr->biSizeImage = m_AllocatorFraming.FrameSize = 
            pBMInfoHdr->biWidth * pBMInfoHdr->biHeight * pBMInfoHdr->biBitCount / 8;
    }


    //
    //  Allocate a temp transfer buffer if its size has changed.
    //
    if(m_pXferBuf == NULL || 
       m_AllocatorFraming.FrameSize != GetTransferBufferSize() ) {

        DbgLog((LOG_TRACE,1,TEXT("Chg XfImgBufSz %d to %d"), 
            GetTransferBufferSize(), 
            m_AllocatorFraming.FrameSize
            ));

        ASSERT(GetPendingReadCount() == 0);

        if(m_pXferBuf) {
            VirtualFree(m_pXferBuf, 0, MEM_RELEASE);
            SetTransferBufferSize(0);
        }

        m_pXferBuf = (LPBYTE) 
             VirtualAlloc (
                 NULL, 
                 m_AllocatorFraming.FrameSize,
                 MEM_COMMIT | MEM_RESERVE,
                 PAGE_READWRITE);

        ASSERT(m_pXferBuf);

        if(m_pXferBuf)
            SetTransferBufferSize(m_AllocatorFraming.FrameSize);
        else {
            ASSERT(m_pXferBuf && "Allocate transfer buffer has failed.");
        }
    }


    //
    // Cache this valid and currently used BITMAPINFO and save it to registry
    //
    // Note: pDataFormat->FormatSize is variable size,
    //       but we only cache sizeof(KSDATAFORMAT).
    CacheDataFormat(pDataFormat);
    CacheAvgTimePerFrame((DWORD) pKsDRVideo->VideoInfoHeader.AvgTimePerFrame);
    CacheBitmapInfoHeader((PBITMAPINFOHEADER) pBMInfoHdr);

    SetDataFormatVideoToReg(); 


    //
    // Free this allocated in VfWWDMDataIntersect
    //
    delete [] pDataFormat;
    pDataFormat = 0;

    delete [] pKsPinConnectHdr;
    pKsPinConnectHdr = 0;

    return DV_ERR_OK;
}

BOOL CImageClass::StreamReady()
{
    return m_bStreamReady;
}


// Called when the device is closed and ready to switching to a different one.
void CImageClass::NotifyReconnectionCompleted()
{
    DbgLog((LOG_TRACE,2,TEXT("NotifyReconnectionCompleted<<<<<<--------------------------")));
    m_bStreamReady = TRUE;
}

void CImageClass::NotifyReconnectionStarting()
{
    DbgLog((LOG_TRACE,2,TEXT("NotifyReconnectionStarting----------------------------------->>>>>>")));
    m_bStreamReady = FALSE;
}


BOOL CImageClass::DestroyPin()
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    BOOL bRet = TRUE;

    // Block read from application while switing device.
    // Read will resume when the pin is recreated.

    DbgLog((LOG_TRACE,1,TEXT("DestroyPin(): m_dwPendingReads = %d (0?)"), m_dwPendingReads));

    ASSERT(m_dwPendingReads == 0);
    if(m_dwPendingReads != 0) {

        HANDLE hEvent =  // NoSecurity, resetAuto, iniNonSignal, noName
            CreateEvent( NULL, TRUE, FALSE, NULL );
        switch(WaitForSingleObject(hEvent,5000)) {
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            break;
        }
    }

    ASSERT(m_dwPendingReads == 0);
    NotifyReconnectionStarting(); 

    DbgLog((LOG_TRACE,2,TEXT("Destroy PIN: m_hKS=%x"), m_hKS));

    if(m_hKS) {

        StopChannel();  // PAUSE->STOP     
        bRet = CloseHandle(m_hKS);

        m_hKS=NULL;  

        if(!bRet) {      
          DbgLog((LOG_TRACE,1,TEXT("Close PIN handled failed with GetLastError()=%d!"), GetLastError()));         
        }
    }

    return bRet;
}


  
DWORD CImageClass::SetBitmapInfo(
  PBITMAPINFOHEADER  pbiHdrNew,  
  DWORD  dwAvgTimePerFrame)
/*++
Routine Description:

  Change the standard bitmap information of the streaming pin connection. This change
  require 
  This function failed if driver is not yet open (return with DV_ERROR_INVALIDHANDLE).

  If pin handle exist, it is a 
  If Pin does not exist, 

  New Bitmapinfo include:
    width, height, compression (FourCC) and frame rate
  
Argument:
Return Value:

--*/
{
    //
    // Setting the bitmapinfo
    //
    DWORD dwRtn = DV_ERR_OK;    


    if(!GetDriverHandle())
        return DV_ERR_INVALHANDLE;


    if(pbiHdrNew) {
        if(pbiHdrNew->biCompression == KS_BI_BITFIELDS) {
            DbgLog((LOG_TRACE,1,TEXT("SetBmi: biCompr %d not supported"), pbiHdrNew->biCompression));
            return DV_ERR_BADFORMAT;  // unsupported video format
        }

        if(pbiHdrNew->biClrUsed > 0) {
            DbgLog((LOG_TRACE,1,TEXT("SetBmi: biClrUsed %d not supported"), pbiHdrNew->biClrUsed));
            return DV_ERR_BADFORMAT;  // unsupported video format
        }
    }

    DbgLog((LOG_TRACE,1,TEXT("SetBmi: 4CC:%x; %d*%d*%d/8?=%d"),
        pbiHdrNew->biCompression,
        pbiHdrNew->biWidth, pbiHdrNew->biHeight, pbiHdrNew->biBitCount, pbiHdrNew->biSizeImage));
    DbgLog((LOG_TRACE,1,TEXT("SetBmi: AvgTm %d to %d MsecPFrm"), GetCachedAvgTimePerFrame()/10000, dwAvgTimePerFrame/10000));

    // if dwAvgTimePerFrame is 0, this field is not checked.
    if (GetPinHandle() &&
        !m_bFormatChanged && // If this is set, it mean that user has change the format in VideoFormat dialog box.
        SameBIHdr(pbiHdrNew, dwAvgTimePerFrame))

        dwRtn = DV_ERR_OK;      
    else {
        NotifyReconnectionStarting();
#if 1
        if(GetPinHandle()) {
            DestroyPin();     
        }
#endif

        dwRtn = 
            CreatePin(
                GetCachedDataFormat(),  // Use current data format
                dwAvgTimePerFrame,
                pbiHdrNew
                );        
        NotifyReconnectionCompleted();
    }

    return dwRtn;
}


/*++
Routine Description:

  Copy and return the cached bitmapinfo 
  
Argument:
Return Value:

   return the biSize of BITMAPINFOHEADER.

--*/
DWORD CImageClass::GetBitmapInfo(PBITMAPINFOHEADER pbInfo, DWORD wSize)
{

    // Special case: 
    //     no existing PIN connection handle && no awaiting format
      
    if(m_hKS == 0 && m_pbiHdr && m_pbiHdr->biSizeImage == 0) {
        DbgLog((LOG_TRACE,1,TEXT("Tell Appl: No existing PIN handle and no awaiting fomrat!! rtn DV_ERR_ALLOCATED")));
        return 0;
    }

    // If wSize is 0, return it is query its size.
    if(wSize == 0) {
        return GetbiSize();
    }

    ASSERT(wSize <= GetbiSize());
    if(wSize <= GetbiSize()) {
        CopyMemory(pbInfo, m_pbiHdr, wSize);  
        if(pbInfo->biHeight < 0) {
            pbInfo->biHeight = -pbInfo->biHeight;
            DbgLog((LOG_TRACE,2,TEXT("Changed biHeight to %d"), pbInfo->biHeight));
        }
    }

    return GetbiSize();
}


DWORD CImageClass::SetTransferBufferSize(DWORD dw) 
{
    m_dwXferBufSize = dw; 
    return DV_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\imgcls.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ImgCls.h

Abstract:

    Header file for ImgCls.cpp

Author:
    
    FelixA 1996

Modified:
               
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "clsdrv.h"

#ifndef _IMGCLS_H
#define _IMGCLS_H


//
// Stream data structure
//
typedef struct {
    KSSTREAM_HEADER     StreamHeader;
    KS_FRAME_INFO        FrameInfo;
} KS_HEADER_AND_INFO;


class CImageClass : public CClassDriver
{
private:
    HANDLE    m_hKS;    
    BOOL m_bStreamReady;
    LONG m_dwPendingReads;

    KSALLOCATOR_FRAMING m_AllocatorFraming;

    BOOL GetAllocatorFraming( HANDLE PinHandle, PKSALLOCATOR_FRAMING pFraming);
    
    BOOL SetState(KSSTATE ksState);
    BOOL m_bPrepared;
    BOOL m_bChannelStarted;

    DWORD    m_dwXferBufSize; // Preview buffer size

    // Cached video format information
    // KS_DATAFORMAT_VIDEOINFOHEADER/2
    //     KSDATAFORMAT       
    //     KS_VIDEOINFOHEADER/2    
    // Note: pDataFormat->FormatSize is variable size,
    //       but we only cache sizeof(KSDATAFORMAT).
    PKSDATAFORMAT     m_pDataFormat;       // Cache the variable size data format
    DWORD             m_dwAvgTimePerFrame; // Frame rate
    PBITMAPINFOHEADER m_pbiHdr;            // Variable size BITMAPINFOHEADER with ->biSize.

    PBYTE   m_pXferBuf;  // Transfer byffer used only if data is not aligned.

    // This is set when the image format has changed in the video format dialog box.
    BOOL    m_bFormatChanged;    

    BOOL ValidateImageSize(KS_VIDEO_STREAM_CONFIG_CAPS * pVideoCfgCaps, LONG biWidth, LONG biHeight);

public:

    
    LONG GetPendingReadCount() { return m_dwPendingReads;}
    BOOL StreamReady();
    void NotifyReconnectionStarting();
    void NotifyReconnectionCompleted();


    DWORD GetAllocatorFramingCount()     {return m_AllocatorFraming.Frames;};
    DWORD GetAllocatorFramingSize()      {return m_AllocatorFraming.FrameSize;};
    DWORD GetAllocatorFramingAlignment() {return m_AllocatorFraming.FileAlignment;};

    BOOL GetStreamDroppedFramesStastics(KSPROPERTY_DROPPEDFRAMES_CURRENT_S *pDroppedFramesCurrent);

    void LogFormatChanged(BOOL bChanged) { m_bFormatChanged = bChanged; }

    HANDLE    GetPinHandle() const { return m_hKS; }


    //
    // Cache DATAFORMAT (sizeof(DATAFORMAT)), AvgTimePerFrame and BITMAPINFOHEADER
    //
    void CacheDataFormat(PKSDATAFORMAT pDataFormat);    
    void CacheAvgTimePerFrame(DWORD dwAvgTimePerFrame) {m_dwAvgTimePerFrame = dwAvgTimePerFrame;} 
    void CacheBitmapInfoHeader(PBITMAPINFOHEADER pbiHdr);   

    PKSDATAFORMAT     GetCachedDataFormat()       { return m_pDataFormat;}
    DWORD             GetCachedAvgTimePerFrame()  { return m_dwAvgTimePerFrame;}
    PBITMAPINFOHEADER GetCachedBitmapInfoHeader() { return m_pbiHdr;}


    DWORD GetbiSize()        { return m_pbiHdr ? sizeof(BITMAPINFOHEADER) : 0;}
    LONG GetbiWidth()        { return m_pbiHdr ? m_pbiHdr->biWidth       : 0; }
    LONG GetbiHeight()       { return m_pbiHdr ? m_pbiHdr->biHeight      : 0; }
    WORD GetbiBitCount()     { return m_pbiHdr ? m_pbiHdr->biBitCount    : 0; }
    DWORD GetbiSizeImage()   { return m_pbiHdr ? m_pbiHdr->biSizeImage   : 0; }
    DWORD GetbiCompression() { return m_pbiHdr ? m_pbiHdr->biCompression : 0; }

    BOOL SameBIHdr(PBITMAPINFOHEADER pbiHdr, DWORD dwAvgTimePerFrame) {
        //ASSERT(pbiHdr != 0);
        if (pbiHdr == 0)
            return FALSE;

        if (dwAvgTimePerFrame == 0)
            return (
                m_pbiHdr->biHeight     == pbiHdr->biHeight &&
                m_pbiHdr->biWidth      == pbiHdr->biWidth && 
                m_pbiHdr->biBitCount   == pbiHdr->biBitCount &&
                m_pbiHdr->biSizeImage  == pbiHdr->biSizeImage &&
                m_pbiHdr->biCompression== pbiHdr->biCompression);
        else 
            return (
                m_pbiHdr->biHeight     == pbiHdr->biHeight &&
                m_pbiHdr->biWidth      == pbiHdr->biWidth && 
                m_pbiHdr->biBitCount   == pbiHdr->biBitCount &&
                m_pbiHdr->biSizeImage  == pbiHdr->biSizeImage &&
                m_pbiHdr->biCompression== pbiHdr->biCompression &&
                dwAvgTimePerFrame    == m_dwAvgTimePerFrame);
    }

 

    // When a new driver is open, a new pin should be created as well.   E-Zu
    BOOL DestroyPin();

    DWORD CreatePin(PKSDATAFORMAT pCurrentDataFormat, DWORD dwAvgTimePerFrame, PBITMAPINFOHEADER pbiNewHdr);

    // This is how big the ReadFiles are.
    // this is also how much memory you should allocate to read into.
    DWORD GetTransferBufferSize() { return m_dwXferBufSize; }
    DWORD SetTransferBufferSize(DWORD dw);

    // Gets a pointer to the buffer that you would read into.
    PBYTE GetTransferBuffer() {return m_pXferBuf;}

    //
    // Bitmap functions.
    //
    DWORD GetBitmapInfo(PBITMAPINFOHEADER pbInfo, DWORD wSize);
    DWORD SetBitmapInfo(PBITMAPINFOHEADER pbInfo, DWORD NewAvgTimePerFrame);


    //
    // Performs the reading from the file, using the above virtuals to provide info.
    //
    // reads an images into pB
    // bDirect means reads directly into pB, without calling Translate buffer.
    //
    // Changed from BOOL to DWORD to accomondate compressed data (variable length!)
    // valid return (>= 0)
    // error return (< 0)
    DWORD GetImageOverlapped(LPBYTE pB, BOOL bDirect, DWORD * pdwBytesUsed, DWORD * pdwFlags, DWORD * pdwTimeCaptured);

    // Channel functions
    BOOL PrepareChannel();
    // a call to start, ensures that prepare has already been called.
    BOOL StartChannel();
    BOOL UnprepareChannel();
    BOOL StopChannel();

    CImageClass();
    ~CImageClass();

    void SetDataFormatVideoToReg();
    BOOL GetDataFormatVideoFromReg();

    PKSDATAFORMAT VfWWDMDataIntersection(PKSDATARANGE pDataRange, PKSDATAFORMAT pCurrentDataFormat, DWORD AvgTimePerFrame, PBITMAPINFOHEADER pBMIHeader);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\pch.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//

#if 0
#if DBG
#ifndef _DEBUG
#define _DEBUG
#endif
#ifndef DEBUG
#define DEBUG
#endif
#endif
#endif

#ifdef WIN95_BUILD
    #define FILE_DEVICE_KS 0x0000002f   // this is not in Memphis's winioctl.h but is in NT's
#endif


#include <streams.h>    // Include most of needed header files.
#include <winioctl.h>   // CTL_CODE, FILE_READ_ACCESS..etc
#include <commctrl.h>   // Page.cpp (UDM_GETRANGE, TBM_GETPOS) and Sheet.cpp (InitCommonControls)
#include <mmsystem.h>       // must go before <mmddk.h>
#undef DRVM_MAPPER_STATUS   // defined in mmsystem and redefine in mmddk.h; do so to avoid compile error.
#include <mmddk.h>
#include <msviddrv.h>  // LPVIDEO_STREAM_INIT_PARMS
#include <vfw.h>
#include <ks.h>
#include <ksmedia.h>

#include <tchar.h>
#include <wxdebug.h>

#define BITFIELDS_RGB16_DWORD_COUNT   3  // Number of DWORDs used for RGB mask with BITFIELD format
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\main.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Debug.cpp

Abstract:

    Entry point.

Author:

    FelixA 1996
    
Modified:    
                  
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

#include "sheet.h"
#include "resource.h"
#include "talk.h"
#include "extin.h"
#include "videoin.h"
#include "vfwimg.h"



HINSTANCE g_hInst;

LONG cntDllMain = 0;

extern "C" {

BOOL 
APIENTRY DllMain( 
   HANDLE   hModule, 
   DWORD    ul_reason_for_call, 
   LPVOID   lpReserved )
{

    switch( ul_reason_for_call ) {
    
        case DLL_PROCESS_ATTACH:
            cntDllMain++;
            DbgLog((LOG_TRACE,1,TEXT("DLL_PROCESS_ATTACH count = %d"), cntDllMain));
            g_hInst= (HINSTANCE) hModule;
            break;
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            cntDllMain--;
            DbgLog((LOG_TRACE,1,TEXT("DLL_PROCESS_DETACH count = %d"), cntDllMain));
        break;
    }

    return TRUE;
}
}  // extern 'C'


//
// Note, this does not seem to get called.
//
BOOL FAR PASCAL LibMain(HANDLE hInstance, WORD wHeapSize, LPSTR lpszCmdLine)
{
    // Save the Instance handle
    DbgLog((LOG_TRACE,2,TEXT("Vfw Buddy LibMain called")));
    g_hInst= (HINSTANCE) hInstance;
    return TRUE;
}


DWORD GetValue(LPSTR pszString)
{
    LPSTR szEnd;
    return strtol(pszString,&szEnd,0);
}

void GetArg(LPSTR pszDest, LPSTR * ppszTmp)
{
    LPSTR pszTmp;
    pszTmp=*ppszTmp;

    BOOL bQuotes=FALSE;
    BOOL bDone=FALSE;
    while(*pszTmp && !bDone)
    {
        // We dont copy quotes.
        if(*pszTmp=='"')
        {
            if(*(pszTmp+1)!='"')
            {
                bQuotes=!bQuotes;
                pszTmp++;
                continue;
            }
            else
                pszTmp++;
        }

        if(*pszTmp==' ' && !bQuotes)
        {
            bDone=TRUE;
            pszTmp++;
            continue;
        }
        *pszDest++=*pszTmp++;
    }
    *pszDest=0;
    *ppszTmp=pszTmp;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// VfwWdm()
//      Called by rundll.
//
// ENTRY:
//
// EXIT:
//  LRESULT - Return code suitable for return by file engine callback.
//
// NOTES:
//
// the rundll commandline looks like this
// rundll <dll16><comma><procname>[<space><params to be passed on>]
// rundll32 <dll32><comma><procname>[<space><params to be passed on>]
//
//////////////////////////////////////////////////////////////////////////////////////////

extern "C" {

//
// NOTE:  This par can only called in Win98 where there is a VfWWDM.drv
//

LONG WINAPI VfwWdm(HWND hWnd, HINSTANCE hInst, LPSTR lpszCmdLine, int nShow)
{
    char    szArgument[MAX_PATH];
    LPSTR    pszCmd=lpszCmdLine;
    HWND    hBuddy=NULL;
    HRESULT hRes;

#ifdef _DEBUG
    BOOL    bLocal=FALSE;
#endif
    DbgLog((LOG_TRACE,2,TEXT("VfwWDM has been loaded %d 0x%08x %s"),hWnd,hInst,lpszCmdLine));

    //
    // Process the command line
    //
    do {
        GetArg(szArgument,&pszCmd);
        if(strcmp(szArgument,"/HWND")==0) {

            GetArg(szArgument,&pszCmd);
            hBuddy=(HWND)GetValue(szArgument);
            DbgLog((LOG_TRACE,2,TEXT(">> hBuddy=%x << "), hBuddy));
        }

    } while (*szArgument);

#ifdef _DEBUG
    if(bLocal)     {

        DbgLog((LOG_TRACE,2,TEXT("Local tests are done here %d"),bLocal));
        switch(bLocal) {

            case 3:
                //g_VFWImage.OpenDriver();
                //g_VFWImage.PrepareChannel();
                //g_VFWImage.StartChannel();
                //g_VFWImage.CloseDriver();
            case 4:
                {
                CListenerWindow Listener(hBuddy, &hRes);
                if(SUCCEEDED(hRes)) {
                    hRes=Listener.Init(g_hInst, NULL, lpszCmdLine, nShow );
                    if(SUCCEEDED(hRes))
                        Listener.StartListening();                    // 'blocks' waiting for messages until told to exit
                    DbgLog((LOG_TRACE,2,TEXT("HResult = 0x%x"),hRes));
                } else {
                    DbgLog((LOG_ERROR,0,TEXT("Constructor ListenerWindow() hr %x; abort!"), hRes));
                }
                }
            break;

            default:
                DbgLog((LOG_TRACE,2,TEXT("No test number")));
            break;
        }
        return 0;
    }
#endif

    //
    // The listener currently uses HWNDs to talk over.
    //
    if(!hBuddy) {

        DbgLog((LOG_TRACE,1,TEXT("Really bad - not given a buddy to talk to")));
        return 0;
    }

    // E-Zu  Testing...  Should not to open the driver and pin until DRV_OPEN
    //
    DbgLog((LOG_TRACE,1,TEXT(">> 16bit hBuddy=%x << ")));
    CListenerWindow Listener(hBuddy, &hRes);
    if(SUCCEEDED(hRes)) { 
        hRes=Listener.Init(g_hInst, NULL, lpszCmdLine, nShow );
        if(SUCCEEDED(hRes))
            Listener.StartListening();                    // 'blocks' waiting for messages until told to exit
        DbgLog((LOG_TRACE,1,TEXT("HResult = 0x%x"),hRes));
    } else {
         DbgLog((LOG_ERROR,0,TEXT("Constructor ListenerWindow() hr %x; abort!"), hRes));
    }
    return 0;
}

} // end extern C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\page.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Page.cpp

Abstract:

    Header file for page.cpp.

Author:

    FelixA 1996

Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#ifndef __PAGEH
#define __PAGEH

#define PS_NORMAL 0
#define PS_FIRST 1
#define PS_LAST 2

//
// Forward references.
//
class CWizardSheet;
class CSheet;

typedef struct tegSPIN_CONTROL
{
    UINT    uiEditCtrl;    // the ID of the edit control
    UINT    uiSpinCtrl;    // the ID of the spin control
    WORD    wMin;        // the min value
    WORD    wMax;        // the max value
    WORD    wPropID;    // the propery ID to use to get the information
} SPIN_CONTROL, FAR * PSPIN_CONTROL;

typedef struct tag_combobox_entry {
   WORD wValue;
   LPCTSTR szText;
} COMBOBOX_ENTRY;


class CPropPage
{
public:
    void    ShowText (UINT uIDString, UINT uIDControl, DWORD dwFlags);
    void    Display(BOOL bDisplay) { m_bDisplay=bDisplay; }
    void    SetTickValue(DWORD dwVal, HWND hSlider, HWND hCurrent);
    DWORD    GetTickValue(HWND hSlider);
    void    SetSheet(CSheet *pSheet);
    UINT    ConfigGetComboBoxValue(int wID, COMBOBOX_ENTRY  * pCBE);
    void    GetBoundedValueArray(UINT iCtrl, PSPIN_CONTROL pSpinner);
    DWORD    GetTextValue(HWND hWnd);
    void    SetTextValue(HWND hWnd, DWORD dwVal);
    DWORD    GetBoundedValue(UINT idEditControl, UINT idSpinner);
    void    EnableControlArray(const UINT FAR * puControls, BOOL bEnable);

    CPropPage(int DlgID, CSheet * pS=0) : m_DlgID(DlgID), m_pdwHelp(NULL), m_pSheet(pS), m_bDisplay(TRUE) {};
    CPropPage(){};
    ~CPropPage() {};

    //
    HPROPSHEETPAGE Create(HINSTANCE hInst, int iPageNum);
    // These members deal with the PSN messages.
    virtual int SetActive();
    virtual int Apply();                            // return 0
    virtual int QueryCancel();
    virtual int DoCommand(WORD wCmdID,WORD hHow);    // return 0 if you handled this.

    BOOL    GetInit() const { return m_bInit; }
    BOOL    GetChanged() const { return m_bChanged; }
    void SetChanged(BOOL b) { m_bChanged=b; }

// REVIEW - how much of below can simply be Private?

    // We need to remember what our HWND is
    void SetWindow(HWND hDlg) { m_hDlg=hDlg; }
    HWND GetWindow() const { return m_hDlg; }
    HWND GetParent() const { return ::GetParent(m_hDlg); }

    //
    HWND GetDlgItem(int iD) const { return ::GetDlgItem(m_hDlg,iD); }

    // For displaying dialogs, we need our hInst to load resources.
    HINSTANCE GetInstance() const { return m_Inst;}
    void SetInstance(HINSTANCE h) { m_Inst=h; }

    // To send messages back to the sheet on Next, Back, Cancel etc.
    void SetResult(int i) { SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, i);}

    // We keep out dlg ID incase we need to refer to it
    void SetDlgID(int DlgID) { m_DlgID=DlgID; }
    int  GetDlgID() const    { return m_DlgID; }

    // Page numbering
    int  GetPageNum() const  { return m_PageNum; }
    void SetPageNum(int p)   { m_PageNum=p;}

    // Prop sheet page
    HPROPSHEETPAGE GetPropPage() const { return m_PropPage;}
    void SetPropPage( HPROPSHEETPAGE p) { m_PropPage=p; }

    // If you want your own dlg proc.
    virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    void Changed();

    // This method is called by the shell on cleanup - called by BaseCallback.
    virtual UINT Callback(UINT uMsg);

    //
    void SetHelp(DWORD * pHelp) { m_pdwHelp=pHelp; }

    CSheet * GetSheet() const { return m_pSheet; }

private:

    void SetInit(BOOL b) { m_bInit=b; }

    BOOL            m_bDisplay;
    BOOL            m_bInit;    // Has this page been init'd yet?
    BOOL            m_bChanged;    // have we changed the page - do we need Apply?
    int             m_DlgID;
    int             m_PageNum;
    HPROPSHEETPAGE  m_PropPage;
    HWND            m_hDlg;
    HINSTANCE       m_Inst;
    DWORD        *  m_pdwHelp;
    CSheet *        m_pSheet;


    // This guy sets the lParam to 'this' so your DlgProc can be called sensibly.
protected:
    static BOOL CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK BaseCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp); // LPFNPSPCALLBACK

};

class CWizardPage : public CPropPage
{
public:
    CWizardPage(int id,CWizardSheet * pSheet=NULL, BOOL bLast=FALSE)
        : CPropPage(id),m_bLast(bLast), m_pSheet(pSheet) {};
    ~CWizardPage(){};

    // Has its own DlgProc for buttons and stuff like that. allways call this if you
    // derive from CWizardPage.
    virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

    virtual int SetActive();    // does big fonts and buttons for you.
    virtual int Back();
    virtual int Next();
    virtual int Finish();
    virtual int Apply();
    virtual int QueryCancel();    // does the Yes/No stuff.
    virtual int KillActive();    // when Next is called.

    // Fonts for the pages.
    void SetBigFont( HFONT f ) { m_BigFont=f; }
    HFONT GetBigFont() const { return m_BigFont; }

    CWizardSheet * GetSheet() const { return m_pSheet; }

private:
    HFONT          m_BigFont;    // The bigfont for the title text.
    BOOL           m_bLast;
    CWizardSheet * m_pSheet;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\sheet.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Sheet.cpp

Abstract:

    Debug functions, like DebugPrint and ASSERT.

Author:

    FelixA 1996

Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"
#include "sheet.h"

CSheet::CSheet(HINSTANCE hInst, UINT iTitle, HWND hParent)
{
    mhInst=hInst;
    mPsh.dwSize        =    sizeof(mPsh);
    mPsh.dwFlags    =    PSH_DEFAULT;
    mPsh.hInstance    = hInst;
    mPsh.hwndParent = hParent;
    mPsh.pszCaption = MAKEINTRESOURCE(iTitle);
    mPsh.nPages = 0;
    mPsh.nStartPage = 0;
    mPsh.pfnCallback    = NULL;
    mPsh.phpage = mPages;

    InitCommonControls();
    SetInstance(hInst);
}

//
// Not used by CSheet, but required.
//
LRESULT    CSheet::WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    return 0;
}


//
//
//
int CSheet::Do()
{
    if(CurrentFreePage()==0)
        return 0;

    int iRet=(int)PropertySheet(&mPsh);
    return iRet;
}

BOOL CSheet::AddPage(CPropPage &Page)
{
    if(CurrentFreePage() > MAX_PAGES)
        return FALSE;

    mPages[CurrentFreePage()]=Page.Create(GetInstance(),CurrentFreePage());
    if(!mPages[CurrentFreePage()])
        return FALSE;

    Page.SetSheet(this);
    PageAdded();
    return TRUE;
}

BOOL CSheet::AddPage(CPropPage * pPage)
{
    if(CurrentFreePage() > MAX_PAGES)
        return FALSE;

    mPages[CurrentFreePage()]=pPage->Create(GetInstance(),CurrentFreePage());
    if(!mPages[CurrentFreePage()])
        return FALSE;

    // pPage->SetAutoFree(TRUE);
    pPage->SetSheet(this);
    PageAdded();
    return TRUE;
}

//
// For external people to hook onto my sheet?
//
BOOL CSheet::AddPage(HPROPSHEETPAGE hPage)
{
    if(CurrentFreePage() > MAX_PAGES)
        return FALSE;
    mPages[CurrentFreePage()]=hPage;
    if(!mPages[CurrentFreePage()])
        return FALSE;
    PageAdded();
    return TRUE;
}

int CSheet::RemovePage()
{
    return --mPsh.nPages;
}

BOOL CSheet::Remove(UINT iIndex)
{
    //
    // Remove this page
    //
    CopyMemory( &mPages[iIndex], &mPages[iIndex+1], MAX_PAGES-iIndex * sizeof(HPROPSHEETPAGE) );
    RemovePage();
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWizardSheet
//
int CWizardSheet::QueryCancel(HWND hwndParent, int iHow)
{
    if(m_CancelTitleID && m_CancelMessageID)
    {
        TCHAR szTitle[128];
        LoadString(GetInstance(),m_CancelTitleID,szTitle,sizeof(szTitle));
        TCHAR szMessage[256];
        LoadString(GetInstance(),m_CancelMessageID,szMessage,sizeof(szMessage));

        return MessageBox(hwndParent,szMessage,szTitle,iHow);
    }
    return IDOK;
}

int CWizardSheet::Do()
{
    mPsh.dwFlags |= PSH_WIZARD;
    return CSheet::Do();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by raytube.rc
//
#define IDS_APP_NAME                    1
#define IDS_TITLE                       2
#define IDS_ABOUT                       3
#define IDS_COL_NAME                    4
#define IDS_ERRBADPORT                  4
#define IDS_COL_SIZE                    5
#define IDS_COL_TYPE                    6
#define IDS_ERRBADCONFIG                6
#define IDS_COL_STATUS                  7
#define IDS_COL_SERVER                  8
#define IDS_VCAPPRODUCT                 16
#define IDS_EXTERNALIN_HEADING          17
#define IDS_SIZE_FORMAT                 18
#define IDS_VIDEOIN_HEADING             19
#define IDS_PAL8                        20
#define IDS_16BITRGB                    21
#define IDS_24BITRGB                    22
#define IDS_YUV411UNPACKED              23
#define IDS_SIZE_CUSTOM                 31
#define IDS_WND_CLASS                   32
#define IDS_PREFERRED_FORMAT            33
#define IDS_DEFAULT                     34
#define IDS_BI_RGB                      35
#define IDS_BI_RLE8                     36
#define IDS_BI_RLE4                     37
#define IDS_BI_BITFIELDS                38
#define IDS_DEFAULT_DEVICE_NAME         39
#define IDS_CONFIGURE_HEADING           40
#define IDS_FORMAT_DESC                 41
#define IDS_ANALOGVIDEO_NONE            42
#define IDS_ANALOGVIDEO_NTSC_M          43
#define IDS_ANALOGVIDEO_PAL_B           44
#define IDS_TXT_STREAMRATE              45
#define IDS_ZOOM                        46
#define IDS_FOCUS                       47
#define IDS_TILT                        48
#define IDS_EXPOSURE                    49
#define IDS_IRIS                        50
#define IDS_PAN                         51
#define IDS_ROLL                        52
#define IDS_BRIGHTNESS                  53
#define IDS_CONTRAST                    54
#define IDS_HUE                         55
#define IDS_SATURATION                  56
#define IDS_SHARPNESS                   57
#define IDS_WHITEBAL                    58
#define IDS_TXT_STREAM_STOP             59
#define IDS_TXT_SELECT_CAMERA           60
#define IDS_TXT_CURRENT_STATE           61
#define IDS_TXT_OPEN_FAILED             62
#define IDS_TXT_DEVICE_REMOVED          63
#define IDS_TXT_ANALOG_NOTSUPPORTED     64
#define IDS_TXT_WIDTH_HEIGHT            65
#define IDS_TXT_FORMAT_SELECTIONS       66
#define IDS_TXT_COMPRESSION             67
#define IDS_TXT_IMAGESIZE               68
#define IDS_GAMMA                       69
#define IDS_BACKLIGHT                   70
#define IDS_BPC_MSG                     71
#define IDS_BPC_MSG_TITLE               72
#define IDS_SHARED_DEVICE_NOT_AVAIL     73
#define IDS_DEV_INUSE_MSG               73
#define IDS_VIDEO_TUNER                 73
#define IDS_VIDEO_COMPOSITE             74
#define IDS_VIDEO_SVIDEO                75
#define IDS_AUDIO_TUNER                 76
#define IDS_SOURCE_UNDEFINED            77
#define IDI_CAMERA                      102
#define IDD_CAMERA_CONTROL              102
#define IDD_EXTIN_PHYSICAL              106
#define IDD_TEST5                       110
#define IDD_DLG_VFWEXT                  110
#define IDD_CHANGE_NAME_DLG             111
#define IDD_DIALOG1                     115
#define IDD_EXTIN_GENERAL               404
#define IDD_EXTIN_COLOR_SLIDERS         405
#define IDD_VIDEOIN                     406
#define IDD_EXTIN_COLOR                 408
#define IDD_IMGFORMAT_PAGE              409
#define IDC_DEVICE_LIST                 1000
#define IDC_CHANNEL_LIST                1001
#define IDC_VIDSRC_LIST                 1001
#define IDC_SOURCE                      1003
#define IDC_OPEN                        1005
#define IDC_PREPARE                     1006
#define IDC_START                       1007
#define IDC_STAT_FORMAT                 1007
#define IDC_CLOSE                       1008
#define IDC_SPIN_PAN                    1009
#define IDC_BITMAPINFO                  1009
#define IDC_SPIN_TILT                   1011
#define IDC_IMG_WIDTH                   1011
#define IDC_SPIN_ROLL                   1013
#define IDC_IMG_HEIGHT                  1013
#define IDC_SLIDER_WHITEBAL             1014
#define IDC_SPIN_X                      1015
#define IDC_SLIDER_BRIGHTNESS           1015
#define IDC_CHANGE_DEV                  1015
#define IDC_FORMAT                      1016
#define IDC_Y                           1016
#define IDC_SLIDER_CONTRAST             1016
#define IDC_CHANGE_CHANNEL              1016
#define IDC_CURRENT_NAME                1016
#define IDC_BRIGHTNESS                  1017
#define IDC_SPIN_Y                      1017
#define IDC_SLIDER_HUE                  1017
#define IDC_NEW_NAME                    1017
#define IDC_CONTRAST                    1018
#define IDC_Z                           1018
#define IDC_SLIDER_SATURATION           1018
#define IDC_HUE                         1019
#define IDC_SPIN_Z                      1019
#define IDC_SLIDER_SHARPNESS            1019
#define IDC_BRIGHTNESS_STATIC           1020
#define IDC_CONTRAST_STATIC             1021
#define IDC_HUE_STATIC                  1022
#define IDC_SLIDER_FRAMERATE            1023
#define IDC_TXT_WARN_DEVICECHANGE       1023
#define IDC_DEF_COLOR                   1024
#define IDC_SATURATION_STATIC           1025
#define IDC_SATURATION                  1026
#define IDC_TXT_BRIGHTNESS_MIN          1026
#define IDC_SLIDER_GAMMA                1026
#define IDC_SHARPNESS_STATIC            1027
#define IDC_SHARPNESS                   1028
#define IDC_FRAMERATE_STATIC            1028
#define IDC_SLIDER_BACKLIGHT            1028
#define IDC_TXT_BRIGHTNESS_MAX          1030
#define IDC_WHITE_STATIC                1031
#define IDC_WHITE                       1032
#define IDC_TXT_CONTRAST_MIN            1032
#define IDC_GAMMA_STATIC                1032
#define IDC_TXT_CONTRAST_MAX            1033
#define IDC_BACKLIGHT_STATIC            1033
#define IDC_BRIGHTNESS_VALUE            1034
#define IDC_TXT_BRIGHTNESS_CURRENT      1034
#define IDC_CONTRAST_VALUE              1035
#define IDC_TXT_CONTRAST_CURRENT        1035
#define IDC_HUE_VALUE                   1036
#define IDC_TXT_HUE_MIN                 1036
#define IDC_ZOOM_STATIC                 1036
#define IDC_SATURATION_VALUE            1037
#define IDC_TXT_SATURATION_MIN          1037
#define IDC_SLIDER_ZOOM                 1037
#define IDC_TXT_SHARPNESS_MIN           1038
#define IDC_FOCUS_STATIC                1038
#define IDC_SLIDER_FOCUS                1039
#define IDC_WHITE_VALUE                 1040
#define IDC_TILT_STATIC                 1040
#define IDC_STATIC_PAN                  1041
#define IDC_SLIDER_TILT                 1041
#define IDC_PAN                         1042
#define IDC_TXT_WHITE_MIN               1042
#define IDC_EXPOSURE_STATIC             1042
#define IDC_STATIC_X                    1043
#define IDC_TXT_HUE_MAX                 1043
#define IDC_SLIDER_EXPOSURE             1043
#define IDC_X                           1044
#define IDC_TXT_SATURATION_MAX          1044
#define IDC_IRIS_STATIC                 1044
#define IDC_TILT                        1045
#define IDC_TXT_SHARPNESS_MAX           1045
#define IDC_SLIDER_IRIS                 1045
#define IDC_STATIC_TILT                 1046
#define IDC_PAN_STATIC                  1046
#define IDC_STATIC_Y                    1047
#define IDC_TXT_WHITE_MAX               1047
#define IDC_SLIDER_PAN                  1047
#define IDC_STATIC_ROLL                 1048
#define IDC_TXT_HUE_CURRENT             1048
#define IDC_TXT_ZOOM_MIN                1048
#define IDC_ROLL                        1049
#define IDC_TXT_ZOOM_MAX                1049
#define IDC_STATIC_Z                    1050
#define IDC_TXT_SATURATION_CURRENT      1050
#define IDC_ROLL_STATIC                 1050
#define IDC_IMAGE_STATIC                1051
#define IDC_SLIDER_ROLL                 1051
#define IDC_ALIGNMENT_STATIC            1052
#define IDC_TXT_SHARPNESS_CURRENT       1052
#define IDC_TXT_ZOOM_CURRENT            1052
#define IDC_WIDTH                       1053
#define IDC_TXT_FRAMERATE_CURRENT       1053
#define IDC_TXT_FOCUS_MIN               1053
#define IDC_CKB_DEVICE_REMOVED          1053
#define IDC_HEIGHT                      1054
#define IDC_TXT_WHITE_CURRENT           1054
#define IDC_TXT_FOCUS_MAX               1054
#define IDC_CHB_OPEN_FAILED             1054
#define IDC_CKB_OPEN_FAILED             1054
#define IDC_SPIN_WIDTH                  1055
#define IDC_IMAGE_SIZE                  1055
#define IDC_TXT_FOCUS_CURRENT           1055
#define IDC_TXT_DEVICE_REMOVED          1055
#define IDC_TXT_GAMMA_CURRENT           1055
#define IDC_SPIN_HEIGHT                 1056
#define IDC_SPIN_BRIGHTNESS             1056
#define IDC_BITDEPTH                    1056
#define IDC_TXT_TILT_MIN                1056
#define IDC_TXT_OPEN_FAILED             1056
#define IDC_TXT_BACKLIGHT_CURRENT       1056
#define IDC_TXT_EXPOSURE_MIN            1057
#define IDC_CMB_COMPRESSION             1057
#define IDC_SPIN_CONTRAST               1058
#define IDC_TXT_IRIS_MIN                1058
#define IDC_CMB_COLORPLANE              1058
#define IDC_TXT_PAN_MIN                 1059
#define IDC_CMB_IMAGESIZE               1059
#define IDC_SPIN_HUE                    1060
#define IDC_TXT_ROLL_MIN                1060
#define IDC_EDT_ANALOGFORMAT            1060
#define IDC_STATIC_WIDTH                1061
#define IDC_TXT_TILT_MAX                1061
#define IDC_EDT_FRAMERATE               1061
#define IDC_STATIC_HEIGHT               1062
#define IDC_SPIN_SATURATION             1062
#define IDC_TXT_EXPOSURE_MAX            1062
#define IDC_STATIC_ANALOGFORMAT         1062
#define IDC_SPIN_SHARPNESS              1063
#define IDC_TXT_IRIS_MAX                1063
#define IDC_STATIC_FRAMERATE            1063
#define IDC_TXT_PAN_MAX                 1064
#define IDC_CB_AUTO_BRIGHTNESS          1064
#define IDC_TXT_ROLL_MAX                1065
#define IDC_CB_AUTO_CONTRAST            1065
#define IDC_TXT_TILT_CURRENT            1066
#define IDC_CB_AUTO_HUE                 1066
#define IDC_STATIC_IMAGE_SIZE           1067
#define IDC_TXT_EXPOSURE_CURRENT        1067
#define IDC_CB_AUTO_SATURATION          1067
#define IDC_SPIN_WHITE                  1068
#define IDC_STATIC_IMAGE_SIZE2          1068
#define IDC_TXT_IRIS_CURRENT            1068
#define IDC_CB_AUTO_SHARPNESS           1068
#define IDC_TXT_PAN_CURRENT             1069
#define IDC_CB_AUTO_WHITEBAL            1069
#define IDC_TXT_ROLL_CURRENT            1070
#define IDC_CB_AUTO_GAMMA               1070
#define IDC_CB_AUTO_BACKLIGHT           1071
#define IDC_STATIC_INFO_STREAMRATE      1073
#define IDC_CB_AUTO_ZOOM                1074
#define IDC_CB_AUTO_ZOOM2               1075
#define IDC_CB_AUTO_FOCUS               1075
#define IDC_STATIC_CURRENTSTATE         1075
#define IDC_CB_AUTO_ZOOM3               1076
#define IDC_CB_AUTO_TILT                1076
#define IDC_TXT_DEVICE_NOTSUPPORTED     1076
#define IDC_CB_AUTO_ZOOM4               1077
#define IDC_CB_AUTO_EXPOSURE            1077
#define IDC_TXT_VFWEXT_BRIGHTNESS       1077
#define IDC_CB_AUTO_ZOOM5               1078
#define IDC_CB_AUTO_IRIS                1078
#define IDC_CB_KSSTATE_STOP             1078
#define IDC_CB_AUTO_ZOOM6               1079
#define IDC_CB_AUTO_PAN                 1079
#define IDC_CB_KSSTATE_PAUSE            1079
#define IDC_CB_AUTO_ZOOM7               1080
#define IDC_CB_AUTO_ROLL                1080
#define IDC_CB_KSSTATE_RUN              1080
#define IDC_CB_BRIGHTNESS_AUTO          1081
#define IDC_EDT_VFWEXT_BRIGHTNESS       1082
#define IDC_EDT_IMAGESIZE               1083
#define IDC_TXT_WIDTH_HEIGHT            1085
#define IDC_TXT_FORMAT_SELECTIONS       1086
#define IDC_TXT_COMPRESSION             1087
#define IDC_TXT_IMAGESIZE               1088
#define IDC_MSG_DEVCHG                  1090
#define IDC_BTN_TVTUNER                 1091
#define IDC_BTN_CROSSBAR                1092
#define IDC_STATIC_VIDSRC               1093
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40015
#define _APS_NEXT_CONTROL_VALUE         1094
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\sheet.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// CSheet
// 

#ifndef __SHEETH
#define __SHEETH

#include "page.h"

#define MAX_PAGES 32

class CSheet
{
public:
    CSheet(HINSTANCE hInst, UINT iTitle=0, HWND hParent=NULL);
    ~CSheet() {};

    void SetInstance(HINSTANCE h) { mhInst=h;}

    int Do();

    BOOL AddPage(CPropPage & Page);
    BOOL AddPage(CPropPage * pPage);
    BOOL AddPage(HPROPSHEETPAGE hPage);
    BOOL Remove(UINT iIndex);

    // Call this if you new CSheet and want it to free itself when
    // all its pages are gone.
    int    RemovePage();
    void PageAdded() { mPsh.nPages++; }

    virtual LRESULT    WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

protected:
    HINSTANCE GetInstance() const { return mhInst; }
    PROPSHEETHEADER            mPsh;
    static UINT CALLBACK BaseCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp); // LPFNPSPCALLBACK

private:
    int  CurrentFreePage() const { return mPsh.nPages; }

    HINSTANCE                mhInst;
    HPROPSHEETPAGE            mPages[MAX_PAGES];
};

////////////////////////////////////////////////////////////////////////////////
//
// CWizardSheet
//
// Provides a QueryCancel message box handler.
//
class CWizardSheet : public CSheet
{
public:
    ~CWizardSheet(){};
    // Special Wizard things.
    CWizardSheet(HINSTANCE hInst, UINT iTitle=0,UINT iCancel=0) : CSheet(hInst,iTitle),
        m_CancelMessageID(iCancel),
        m_CancelTitleID(iTitle) {};
    int Do();
    int QueryCancel(HWND hwndParent=NULL,int iHow=MB_OKCANCEL | MB_ICONSTOP );
private:
    UINT m_CancelMessageID;
    UINT m_CancelTitleID;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\talkth.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    TalkTh.cpp

Abstract:

   This function handle most of the video capture; it used NUM_READ buffers
   to read data from driver and then copy it to the destination.
   It handle 16 bits client differently from 32bit client.

Author:

    Yee J. Wu (ezuwu) 1-April-98

Environment:

    User mode only

Revision History:

--*/


#include "pch.h"
#include "talkth.h"


#define CAPTURE_INIT_TIME 0xffffffff
//
// Used only by NTWDM's InStreamStart
//
CStreamingThread::CStreamingThread(
    DWORD dwAllocatorFramingCount,
    DWORD dwAllocatorFramingSize,
    DWORD dwAllocatorFramingAlignment,
    DWORD dwFrameInterval,
    CVFWImage * Image)
   :
    m_hThread(0),
    m_dwFrameInterval(dwFrameInterval),
    m_pImage(Image),
    m_hPinHandle(0),       // No handle, no capture.
    m_tmStartTime(CAPTURE_INIT_TIME),
    m_cntVHdr(0),
    m_lpVHdrNext(0),
    m_dwLastCapError(DV_ERR_OK)
{

    m_dwNumReads = dwAllocatorFramingCount > MAX_NUM_READS ? MAX_NUM_READS : dwAllocatorFramingCount;

    DbgLog((LOG_TRACE,2,TEXT("CStreamingThread(NT): Creating an event driven thread using %d frames"), m_dwNumReads));
    m_hEndEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_hEndEvent == NULL){
        DbgLog((LOG_TRACE,1,TEXT("!!! Failed to create an event")));
        m_status = error;
    }

    InitStuff();
}


//
// Creates N overlapped structures, and buffers into which it can
// read the images.
//
void CStreamingThread::InitStuff()
{
    if(m_pImage->BGf_OverlayMixerSupported()) {
        BOOL bRendererVisible;

        // Query its current state.
        if(DV_ERR_OK != m_pImage->BGf_GetVisible(&bRendererVisible)) {
            DbgLog((LOG_TRACE,1,TEXT("CapthreThread: Support renderer but cannot query its current state!!")));
        }

        //
        // Stop preview so that we can reconnect the capture pin
        // with a different format (in this case frame rate).
        //
        m_pImage->BGf_StopPreview(bRendererVisible);
    }
    m_pImage->StopChannel();



    // Different frame rate can trigger a reconnect
    // which will cause the pin handle to be changed.
    if(DV_ERR_OK !=
        m_pImage->SetFrameRate( m_dwFrameInterval )) {   // SetFrameRate expect 100nsec
        DbgLog((LOG_TRACE,1,TEXT("Set frame rate has failed. Serious, bail out.")));
    }

    m_hPinHandle = m_pImage->GetPinHandle();
    m_dwBufferSize = m_pImage->GetTransferBufferSize();

    DbgLog((LOG_TRACE,2,TEXT("Creating %d read buffers of %d on handle %d"), m_dwNumReads, m_dwBufferSize, m_hPinHandle));
    DWORD i;

    for(i=0;i<m_dwNumReads;i++){
        m_TransferBuffer[i] = 0;
    }

    for(i=0;i<m_dwNumReads;i++) {
        //
        // Allocate the buffers we'll need to do the reads
        //
        m_TransferBuffer[i] =
            (LPBYTE) VirtualAlloc (
                            NULL,
                            m_dwBufferSize,
                            MEM_COMMIT | MEM_RESERVE,
                            PAGE_READWRITE);
        ASSERT(m_TransferBuffer[i] != NULL);

        if(m_TransferBuffer[i] == NULL) {
            DbgLog((LOG_TRACE,1,TEXT("m_TransferBuffer[%d] allocation failed. LastError=%d"), i, GetLastError()));
            m_dwNumReads = i;
            if(i == 0){
                m_status = error;
            }
        } else {
            DbgLog((LOG_TRACE,2,TEXT("Aloc m_XBuf[%d] = 0x%x suceeded."), i, m_TransferBuffer[i]));
        }
    }

    for(i=0;i<m_dwNumReads;i++) {

        //
        // Create the overlapped structures
        //
        ZeroMemory( &(m_Overlap[i]), sizeof(OVERLAPPED) );
        m_Overlap[i].hEvent =  // NoSecurity, resetManual, iniNonSignal, noName
           CreateEvent( NULL, FALSE, FALSE, NULL );
        DbgLog((LOG_TRACE,2,TEXT("InitStuff: Event %d is 0x%08x bufsize=%d"),i, m_Overlap[i].hEvent, m_dwBufferSize ));
    }
}

//
// Thread is being cleaned up.
// Called from StopStreaming, just by using delete.
//
CStreamingThread::~CStreamingThread()
{

    DbgLog((LOG_TRACE,2,TEXT("~CStreamingThread: destroy this thread object.")));
}

//
// Main part of the tread, calls different code for 16 bit and
// 32 bit clients.
//
LPTHREAD_START_ROUTINE
CStreamingThread::ThreadMain(CStreamingThread * pCStrmTh)
{
    CVFWImage * m_pImage = pCStrmTh->m_pImage; //(CVFWImage *)lpThreadParam;

    DbgLog((LOG_TRACE,2,TEXT("::ThreadMain():Starting to process StreamingThread - submit the reads")));

    //
    // Main capture loop
    //
    pCStrmTh->SyncReadDataLoop();

    //
    // None of them should be blocking now.
    //

    for(DWORD i=0;i<pCStrmTh->m_dwNumReads;i++) {
        //
        // Free up the buffer only when the thread has stopped.
        //
        if(pCStrmTh->m_TransferBuffer[i]) {
            DbgLog((LOG_TRACE,2,TEXT("Freeing m_XfBuf[%d] = 0x%x."), i, pCStrmTh->m_TransferBuffer[i]));
            VirtualFree(pCStrmTh->m_TransferBuffer[i], 0, MEM_RELEASE);
            pCStrmTh->m_TransferBuffer[i] = NULL;
        }
    }

    //
    // Process uses this to see if we should terminate too.
    //
    pCStrmTh->m_dwBufferSize=0;

    //DWORD i;
    for(i=0;i<pCStrmTh->m_dwNumReads;i++) {

        if( pCStrmTh->m_Overlap[i].hEvent ) {
            SetEvent(pCStrmTh->m_Overlap[i].hEvent);
            CloseHandle(pCStrmTh->m_Overlap[i].hEvent);
            pCStrmTh->m_Overlap[i].hEvent = NULL;
        }
    }

    if(pCStrmTh->m_hEndEvent) {
        DbgLog((LOG_TRACE,1,TEXT("CloseHandle(pCStrmTh->m_hEndEvent)")));
        CloseHandle(pCStrmTh->m_hEndEvent);
        pCStrmTh->m_hEndEvent = 0;
    }

    // Close the thread handle
    if (pCStrmTh->m_hThread) {
        CloseHandle(pCStrmTh->m_hThread);
        pCStrmTh->m_hThread = 0;

    }

    DbgLog((LOG_TRACE,2,TEXT("ExitingThread() from CStreamingThread::ThreadMain()")));
    ExitThread(0);

    return 0;
}


/*++
*******************************************************************************
Routine:
    CStreamThread::Start

Description:
    Start up the InputWatcher Thread.
    Use ExitApp to clean all this up before ending.

Arguments:
    None.

Return Value:
    successful    if it worked.
    threadError    if the thread did not initialize properly (which might mean
        the input device did not initialize).

*******************************************************************************
--*/
EThreadError CStreamingThread::Start(UINT cntVHdr, LPVIDEOHDR lpVHdrHead, int iPriority)
{
    if(m_hPinHandle == 0) {
        DbgLog((LOG_TRACE,1,TEXT("!!! Want to start capture, but has no m_hPinHandle.")));
        return threadNoPinHandle;
    }

    if(IsRunning()) {
        DbgLog((LOG_TRACE,1,TEXT("!!! Can't start thread, already running")));
        return threadRunning;
    }

    if(!m_hEndEvent) {
        DbgLog((LOG_TRACE,1,TEXT("!!! No event, can't start thread")));
        return noEvent;
    }

    //
    // Initialize capture data elements
    //
    m_cntVHdr = cntVHdr;
    m_lpVHdrNext = lpVHdrHead;
#if 0
    m_tmStartTime = timeGetTime();
#else
    m_tmStartTime = CAPTURE_INIT_TIME;
#endif
    ASSERT(m_cntVHdr>0);
    ASSERT(m_lpVHdrNext!=0);


    m_bKillThread = FALSE;

    // Create a thread to watch for Input events.
    m_hThread =
        CreateThread(
             (LPSECURITY_ATTRIBUTES)NULL,
             0,
             (LPTHREAD_START_ROUTINE) ThreadMain,
             this,
             CREATE_SUSPENDED,
             &m_dwThreadID);


    if (m_hThread == NULL) {
        DbgLog((LOG_TRACE,1,TEXT("!!! Couldn't create the thread")));
        return threadError;
    }

    DbgLog((LOG_TRACE,1,TEXT("CStreamThread::Start successfully in CREATE_SUSPEND mode; Wait for ResumeThread().")));

    SetThreadPriority(m_hThread, iPriority);
    ResumeThread(m_hThread);

    DbgLog((LOG_TRACE,2,TEXT("Thread (m_hThread=%x)has created and Resume running."), m_hThread));

    return(successful);
}


/*++
*******************************************************************************
Routine:
    CStreamThread::Stop

Description:
    Cleanup stuff that must be done before exiting the app.  Specifically,
    this tells the Input Watcher Thread to stop.

Arguments:
    None.

Return Value:
    None.

*******************************************************************************
--*/
EThreadError CStreamingThread::Stop()
{
    if(IsRunning()) {

        DbgLog((LOG_TRACE,2,TEXT("Trying to stop the thread")));
        //
        // Set flag to tell thread to kill itself, and wake it up
        //
        m_bKillThread = TRUE;
        SetEvent(m_hEndEvent);

        // Signal m_hEndEvent to leave SyncReadDataLoop(), and then
        // continue exection in ThreadMain() with ExitThread(0).
        //
        // wait until thread has self-terminated, and clear the event.
        //
        DbgLog((LOG_TRACE,2,TEXT("STOP: Before WaitingForSingleObject; return when ExitThread()")));
        WaitForSingleObject(m_hThread, INFINITE);
        DbgLog((LOG_TRACE,1,TEXT("STOP: After WaitingForSingleObject; Thread stopped.")));
    }

    return successful;
}

BOOL CStreamingThread::IsRunning()
{
    return m_hThread!=NULL;
}


HANDLE CStreamingThread::GetEndEvent()
{
    return m_hEndEvent;
}


LPVIDEOHDR CStreamingThread::GetNextVHdr()
{
    LPVIDEOHDR lpVHdr;

	   //ASSERT(m_lpVHdrNext != NULL);
    if(m_lpVHdrNext == NULL){
		      DbgLog((LOG_TRACE,1,TEXT("!!!Queue is empty.!!!")));
		      return NULL;
    }


    DbgLog((LOG_TRACE,3,TEXT("m_lpVHdrNext=%x, ->dwFlags=%x; ->dwReserved[1]=%p"),
		        m_lpVHdrNext, m_lpVHdrNext->dwFlags, m_lpVHdrNext->dwReserved[1]));

    // Simplyfy this!!
    // This buffer must be (!VHDR_DONE && VHDR_PREPARED && VHDR_INQUEUE)
    if((m_lpVHdrNext->dwFlags & VHDR_DONE)     != VHDR_DONE     &&
		     (m_lpVHdrNext->dwFlags & VHDR_PREPARED) == VHDR_PREPARED &&
       (m_lpVHdrNext->dwFlags & VHDR_INQUEUE)  == VHDR_INQUEUE) {

        lpVHdr = m_lpVHdrNext;
        lpVHdr->dwFlags &= ~VHDR_INQUEUE;  // Indicate removed from queue

        m_lpVHdrNext = (LPVIDEOHDR) m_lpVHdrNext->dwReserved[1];

        return lpVHdr;
    } else {
		      DbgLog((LOG_TRACE,2,TEXT("No VideoHdr")));
        return NULL;
    }
}


//
//
//
#define SYNC_READ_MAX_WAIT_IN_MILLISEC    10000

DWORD
CStreamingThread::GetStartTime()
{
    if(m_tmStartTime == CAPTURE_INIT_TIME)
        return 0;
    else
        return (DWORD) m_tmStartTime;
}

void CStreamingThread::SyncReadDataLoop()
{
    LPVIDEOHDR lpVHdr;
    DWORD WaitResult, i;
    HANDLE WaitEvents[2] =  {GetEndEvent(), 0};

    BOOL bOverlaySupported = m_pImage->BGf_OverlayMixerSupported();


    DbgLog((LOG_TRACE,1,TEXT("Start SyncReadDataLoop...")));
    m_dwFrameCaptured  = 0;
    m_dwFrameDropped   = 0;   //   m_dwFrameNumber = m_dwFrameCaptured + DroppedFrame
    m_dwNextToComplete = 0;

    //
    // Put stream in the PAUSE state so we can issue SRB_READ
    //
#if 0  // ???? If enable, cannot preview while capture in overlay mode ????
    if(bOverlaySupported) {
        BOOL bRendererVisible;
        m_pImage->BGf_GetVisible(&bRendererVisible);
        DbgLog((LOG_TRACE,2,TEXT("SyncReadDataLoop: PausePreview, Render window %s"), bRendererVisible ? "Visible" : "Hide"));
        m_pImage->BGf_PausePreview(bRendererVisible);  // apply to all PINs
    }
#endif
    m_pImage->PrepareChannel();

    //
    // Pre-read in the PAUSE state
    //
    for(i=0;i<m_dwNumReads;i++) {     
        if(ERROR_SUCCESS != IssueNextAsyncRead(i)) {
            m_pImage->StopChannel();       // ->PAUSE->STOP
            return;
        }
    }

    //
    // Now we have buffers down, we can start the preview pin (if used)
    // and then the caprture pin.
    //
    if(bOverlaySupported) {
        BOOL bRendererVisible;
        m_pImage->BGf_GetVisible(&bRendererVisible);
        DbgLog((LOG_TRACE,2,TEXT("SyncReadDataLoop: StartPreview, Render window %s"), bRendererVisible ? "Visible" : "Hide"));
        m_pImage->BGf_StartPreview(bRendererVisible); // Apply to all PINs
    }
    m_pImage->StartChannel();

    while(1) {

        WaitEvents[1]=m_Overlap[m_dwNextToComplete].hEvent;
        WaitResult =
            WaitForMultipleObjectsEx(
                sizeof(WaitEvents)/sizeof(HANDLE),
                (CONST HANDLE*) WaitEvents,
                FALSE,                             // singnal on any event (not on ALL).
                SYNC_READ_MAX_WAIT_IN_MILLISEC,    // time-out interval in milliseconds
                TRUE);

        switch(WaitResult){

        case WAIT_OBJECT_0:  // EndEvent:
            //
            // Stop Capture pin and then Preview Pin (if used)
            //
            if(m_pImage->BGf_OverlayMixerSupported()) {
                // Stop both the capture
                BOOL bRendererVisible = FALSE;
                m_pImage->BGf_GetVisible(&bRendererVisible);
                m_pImage->BGf_StopPreview(bRendererVisible);
            }

            m_pImage->StopChannel();       // ->PAUSE->STOP
            DbgLog((LOG_TRACE,1,TEXT("SyncReadDataLoop: STOP streaming to reclaim buffer; assume all buffers are returned.")));
            m_pImage->m_bVideoInStopping = FALSE;
            return;

        case WAIT_IO_COMPLETION:
            DWORD cbBytesXfer;
            DbgLog((LOG_TRACE,1,TEXT("WAIT_IO_COMPLETION: m_dwNextToComplete=%d"), m_dwNextToComplete));

            // We call this mainly to get cbBytesXfer.
            if(GetOverlappedResult(
                m_hPinHandle,
                &m_Overlap[m_dwNextToComplete],
                &cbBytesXfer,
                FALSE)) {
                m_SHGetImage[m_dwNextToComplete].StreamHeader.DataUsed = cbBytesXfer;
            } else {
                DbgLog((LOG_TRACE,1,TEXT("GetOverlappedResult() has failed with GetLastError=%d"), GetLastError()));
                break;
            }
            // Purposely fall thru.
        case WAIT_OBJECT_0+1: // m_Overlap[m_dwNextToComplete].hEvent: set by DeviceIoControl()

            lpVHdr = GetNextVHdr();
            if(lpVHdr != NULL){

                if(m_SHGetImage[m_dwNextToComplete].StreamHeader.DataUsed > lpVHdr->dwBufferLength) {
                    DbgLog((LOG_TRACE,1,TEXT("DataUsed (%d) > lpVHDr->dwBufferLength(%d)"),m_SHGetImage[m_dwNextToComplete].StreamHeader.DataUsed, lpVHdr->dwBufferLength));
                    lpVHdr->dwBytesUsed = 0; // lpVHdr->dwBufferLength;
                } else
                   lpVHdr->dwBytesUsed = m_SHGetImage[m_dwNextToComplete].StreamHeader.DataUsed;

                if(m_tmStartTime == CAPTURE_INIT_TIME) {
                    lpVHdr->dwTimeCaptured = 0;
                    m_tmStartTime = timeGetTime();
                    DbgLog((LOG_TRACE,3,TEXT("%d) time=%d"), m_dwFrameCaptured, lpVHdr->dwTimeCaptured));
                } else {
                    lpVHdr->dwTimeCaptured = timeGetTime() - m_tmStartTime;
                    DbgLog((LOG_TRACE,3,TEXT("%d) time=%d"), m_dwFrameCaptured, lpVHdr->dwTimeCaptured));
                }

                CopyMemory((LPBYTE)lpVHdr->dwReserved[2], m_TransferBuffer[m_dwNextToComplete], lpVHdr->dwBytesUsed);
                lpVHdr->dwFlags |= VHDR_DONE;
                lpVHdr->dwFlags |= VHDR_KEYFRAME;  // In order to be drawn/displayed by AVICAP.
                m_dwFrameCaptured++;
                m_pImage->videoCallback(MM_DRVM_DATA, 0);
            } else {
                m_dwFrameDropped++;
                SetLastCaptureError(DV_ERR_NO_BUFFERS);
                DbgLog((LOG_TRACE,2,TEXT("Has data but no VideoHdr! Drop %d of %d, and read another one."), m_dwFrameDropped, m_dwFrameDropped+m_dwFrameCaptured));
            }

            if(ERROR_SUCCESS == IssueNextAsyncRead(m_dwNextToComplete)) {
                m_dwNextToComplete = (m_dwNextToComplete+1) % m_dwNumReads;
            } else {   
                //
                // If issuing async. read failed, we stop and quit capture.
                //
                m_pImage->StopChannel();       // ->PAUSE->STOP
                return;
            }
            break;

        case WAIT_TIMEOUT:
            // Try again since we do not know why it timed out!
            DbgLog((LOG_ERROR,1,TEXT("WAIT_TIMEOUT!! m_dwNextToComplete %d"), m_dwNextToComplete));
            if(m_pImage->StopChannel()){       // ->PAUSE->STOP
               if(m_pImage->StartChannel()) {  // ->PAUSE->RUN
                    m_dwNextToComplete = 0;
                    for(i=0;i<m_dwNumReads;i++)
                        if(ERROR_SUCCESS != IssueNextAsyncRead(i)) {
                            m_pImage->StopChannel();       // ->PAUSE->STOP
                            return;
                        }
                    break;
                }
            }
            DbgLog((LOG_TRACE,1,TEXT("SyncReadDataLoop: timeout(%d msec) and cannot restart the streaming; device is dead! QUIT."), SYNC_READ_MAX_WAIT_IN_MILLISEC));
            return;
        }
    }
}

//
// The streaming thread has it's own Read - doesn't use the Preview one
//
DWORD CStreamingThread::IssueNextAsyncRead(DWORD i)
{
    DWORD cbReturned;

    DbgLog((LOG_TRACE,3,TEXT("Start Read on buffer %d, file %d, size %d"),i,m_hPinHandle, m_dwBufferSize));

    ZeroMemory(&m_SHGetImage[i],sizeof(m_SHGetImage[i]));
    m_SHGetImage[i].StreamHeader.Size = sizeof (KS_HEADER_AND_INFO);
    m_SHGetImage[i].FrameInfo.ExtendedHeaderSize = sizeof (KS_FRAME_INFO);
    m_SHGetImage[i].StreamHeader.Data = m_TransferBuffer[i];
    m_SHGetImage[i].StreamHeader.FrameExtent = m_dwBufferSize;


    BOOL bRet =
      DeviceIoControl(
          m_hPinHandle,
          IOCTL_KS_READ_STREAM,
          &m_SHGetImage[i],
          sizeof(m_SHGetImage[i]),
          &m_SHGetImage[i],
          sizeof(m_SHGetImage[i]),
          &cbReturned,
          &m_Overlap[i]);

    if(bRet){
        SetEvent(m_Overlap[i].hEvent);
    } else {
        DWORD dwErr=GetLastError();
        switch(dwErr) {

        case ERROR_IO_PENDING:   // the overlapped IO is going to take place.
            //  Event is clear/reset by DeviceIoControl(): ClearEvent(m_Overlap[i].hEvent);
            break;

        case ERROR_DEVICE_REMOVED:
            DbgLog((LOG_ERROR,1,TEXT("IssueNextAsyncRead: ERROR_DEVICE_REMOVED %dL; Quit capture!"), dwErr));            
            return ERROR_DEVICE_REMOVED;
            break;

        default:   // Unexpected error has happened.
            DbgLog((LOG_ERROR,1,TEXT("IssueNextAsyncRead: Unknown dwErr %dL; Quit capture!"), dwErr));
            ASSERT(FALSE);
            return dwErr;
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\talk.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    talk.h

Abstract:

    Header file for talk.cpp

Author:

    FelixA 1996

Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#ifndef _TALK_H
#define _TALK_H

/////////////////////////////////////////////////////////////////////////////
//
// WM_USER+0x1234
// +    Method                        LPARAM
// +0    DRV_LOAD
// +1    DRV_FREE
// +2    DRV_OPEN                    LPVIDEO_OPEN_PARAMS
// +3    DRV_CLOSE
// +4    DVM_DIALOG                    Type of dialog
// +5    DVM_FORMAT                    Information required
// +6    Gets the BITMAP info structure (needs locked flat memory)
// +7    Set bitmap info.
// +8   EXTERNALIN_DIALOG            HWND parent
// +9   VIDEO_IN_DIALOG                HWND parent
// +10    SetDestBufferSize            BufferSize
// +50  Grab single frame            Destination
// +51    Set streaming destination    Dest or NULL to stop streaming.
// +52  Start streaming                Sampling rate.
//
// WPARAM is always the index to the open driver
//
/////////////////////////////////////////////////////////////////////////////
#define WM_16BIT                  (WM_USER+0x1234)
#define WM_1632_LOAD              (WM_16BIT+0)
#define WM_1632_FREE              (WM_16BIT+1)
#define WM_1632_OPEN              (WM_16BIT+2)
#define WM_1632_CLOSE             (WM_16BIT+3)
#define WM_1632_DIALOG            (WM_16BIT+4)

#define WM_1632_GETBITMAPINFO     (WM_16BIT+6)
#define WM_1632_SETBITMAPINFO     (WM_16BIT+7)

#define WM_1632_EXTERNALIN_DIALOG (WM_16BIT+8)
#define WM_1632_VIDEOIN_DIALOG    (WM_16BIT+9)
#define WM_1632_DESTBUFFER        (WM_16BIT+10)

#define WM_1632_GRAB              (WM_16BIT+50)
#define WM_1632_SETSTREAM         (WM_16BIT+51)
#define WM_1632_STARTSTREAM       (WM_16BIT+52)

#define WM_1632_UPDATE            (WM_16BIT+53)
#define WM_1632_OVERLAY           (WM_16BIT+54)

#define WM_1632_STREAM_INIT       (WM_16BIT+55)
#define WM_1632_STREAM_ADDBUFFER  (WM_16BIT+56)
#define WM_1632_STREAM_START      (WM_16BIT+57)
#define WM_1632_STREAM_STOP       (WM_16BIT+58)
#define WM_1632_STREAM_RESET      (WM_16BIT+59)
#define WM_1632_STREAM_FINI       (WM_16BIT+60)
#define WM_1632_STREAM_GETPOS     (WM_16BIT+61)
#define WM_1632_STREAM_GETERROR   (WM_16BIT+62)

#define WM_FGNOTIFY               (WM_16BIT+63)


#define DS_VFWWDM_ID    0x98


#include <msviddrv.h>  // LPVIDEO_STREAM_INIT_PARMS

#if 0  // All for getting the hCaptureEvent

#include <vfw.h>

// This structure is GlobalAlloc'd for each capture window instance.
// A pointer to the structure is stored in the Window extra bytes.
// Applications can retrieve a pointer to the stucture using
//    the WM_CAP_GET_CAPSTREAMPTR message.
// I: internal variables which the client app should not modify
// M: variables which the client app can set via Send/PostMessage

/*
VfW16. hwnd=0x5f8; dwResult=4300e4
VfW16. lpcs=0x2f1f0000
VfW16. 1->dwSize=5568 == 0x15c0
VfW16. 1->hwnd=0x0
VfW16. 1->hCaptureEvent=0x73f0


2f1f:00000000  000015c0 00000001 7f730000 00000000
2f1f:00000010  00000000 000005f8 004073f0 004073a0
2f1f:00000020  00000000 00000000 00000000 00000000
2f1f:00000030  00000000 00000000 00000000 00000000
2f1f:00000040  00000001 00000000 00000000 00000000
2f1f:00000050  00000000 00000000 00000000 00000000
2f1f:00000060  00000000 00000000 10cf0d20 10cf0d98
2f1f:00000070  10cf0d70 00000001 00000000 00000000

*/
typedef struct tagCAPSTREAM {
    DWORD           dwSize;                     // I: size of structure
/*
    UINT            uiVersion;                  // I: version of structure
    HINSTANCE       hInst;                      // I: our instance

    HANDLE          hThreadCapture;             // I: capture task handle
    DWORD           dwReturn;                   // I: capture task return val
*/
    DWORD           dwNotUsed0[4];
/*
    HWND            hwnd;                       // I: our hwnd
*/
    DWORD           hwnd;

/*
    // Use MakeProcInstance to create all callbacks !!!

    // Status, error callbacks
    CAPSTATUSCALLBACK   CallbackOnStatus;       // M: Status callback
    CAPERRORCALLBACK    CallbackOnError;        // M: Error callback
*/
    DWORD           dwNotUsed1[2];
/*
    // event used in capture loop to avoid polling
    HANDLE hCaptureEvent;
*/
    DWORD  hCaptureEvent;
    DWORD  hRing0CapEvt;


    // There are other structure but we do not nee them.
    // ...

} CAPSTREAM;
typedef CAPSTREAM FAR * LPCAPSTREAM;

#endif  // #include LPCAPSTREAM structure.

#ifndef WIN32
typedef enum {
    KSSTATE_STOP,
    KSSTATE_ACQUIRE,
    KSSTATE_PAUSE,
    KSSTATE_RUN
} KSSTATE, *PKSSTATE;
#endif

//
// All the information about a Channel - thats something someone has
// opened.
//
// This structure is used in boith 16 and 32bit code so
// we need watch its indirection is correct.
//        16-bit     32-bit
// BOOL      2          4
// WORD      2          2
// DWORD     4          4
// LPARAM    4          4
// HANDLE    2          4
// RECT      8         16
//
typedef struct {

    DWORD dwSize;  // Size of this structure.

    DWORD_PTR  pCVfWImage;

    // SendBuddyMessage(): SendMessage()
    // DVM_FRAME..etc.
    LPARAM lParam1_Sync;
    LPARAM lParam2_Sync;

    // SendBuddyMessageNotify(): PostMessage()
    // Like DVM_DIALOG

    LPARAM lParam1_Async;
    LPARAM lParam2_Async;

    WORD    bRel_Sync;  // BOOLEAN: 0=FALSE, else=TRUE
    WORD    msg_Sync;

    WORD    bRel_Async;
    WORD    msg_Async;

    DWORD   hClsCapWin;  // AVICAP capture window handle.

	   DWORD   fccType;			   // Capture 'vcap' or codec 'vidc'
	   DWORD   dwOpenType;			// Channel type VIDEO_EXTERNALIN, VIDEO_IN, VIDEO_OUT or VIDEO_EXTERNALOUT
	   DWORD   dwOpenFlags;		// Flags passed during channel open

    DWORD      dwState;    // KSSTATE_RUN and _PAUSE and _STOP
	   LPVIDEOHDR	lpVHdrNext;	// Pointer to first buffer header
	   LPVIDEOHDR	lpVHdrHead;	// Pointer to first buffer header
	   LPVIDEOHDR	lpVHdrTail;	// Pointer to first buffer header

    DWORD      dwVHdrCount;
	   DWORD      dwError;			   // Last error for this stream

    //
    // Need to expand this structure to keep track context relate to this channel;
    // so that we can
    //     1. guarantee reentrancy and
    //     2. support multiple instance of VfWWDM devices
    //

    // Three supported VfW channels with one device;
    // We will use have them access to the same WDM device context.
    LPBITMAPINFOHEADER lpbmiHdr;

    VIDEO_STREAM_INIT_PARMS vidStrmInitParms;

    DWORD  dwReserved;

    WORD   bVideoOpen;    // TRUE if DVM_STREAM_INIT has return DV_ERR_OK

   	WORD hTimer;

     // this currently apply only to VID_EXTOUT (overlay)
    RECT   rcSrc;
    RECT   rcDst;

    LONG* pdwChannel;

    DWORD dwFlags;     // 0 == close; 1 == open

} CHANNEL, *PCHANNEL;

// C++ to non-C++ linkage-specidfication
#ifdef WIN32
extern "C" {
#endif

PCHANNEL PASCAL VideoOpen( LPVIDEO_OPEN_PARMS lpOpenParms);
DWORD PASCAL VideoClose(PCHANNEL pChannel);
DWORD PASCAL VideoProcessMessage(PCHANNEL pChannel, UINT msg, LPARAM lParam1, LPARAM lParam2);

DWORD PASCAL FAR VideoDialog         (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL VideoFormat         (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL VideoGetChannelCaps (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL VideoUpdate         (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL VideoSrcRect        (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL VideoDstRect        (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL VideoGetErrorText   (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);

DWORD PASCAL InStreamGetError (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL InStreamGetPos   (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL InStreamInit     (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL InStreamFini     (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL InStreamAddBuffer(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL InStreamStart    (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL InStreamStop     (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);
DWORD PASCAL InStreamReset    (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2);

#ifdef WIN32
}
#endif


//
// We only define this stuff when included by C++
//
#ifdef __cplusplus
#include "wnd.h"
#include "vfwimg.h"

class CListenerWindow : public CWindow
{
    typedef CWindow BASECLASS;
public:
    CListenerWindow(HWND h, HRESULT* phr);
    //CListenerWindow(HWND h, CVFWImage & Image);
    ~CListenerWindow();
    LRESULT        WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT        InitInstance(int nCmdShow);
    void        StartListening() const;
    HWND        GetBuddy()    const { return m_hBuddy; }
#ifdef _DEBUG
    // This can only possible be used in the debug mode
    // when vfwwdm32.dll is launch by rundll32.exe by the debugger.
    void        SetBuddy(HWND h16New) { m_hBuddy = h16New; }
#endif
private:
    HWND        m_hBuddy;
    CRITICAL_SECTION m_csMsg;  // This is used to serial message, esp _FREE, _CLOSE and _OPEN
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\talk.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Talk.cpp

Abstract:

    The interface layer bwtween 16bit vfwwdm.drv and 32bit helper DLL.
    It use windows handle to post/send each others messages.

Author (OSR2):

    FelixA 1996

Modifed for Win98:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/


#include "pch.h"

#include "talk.h"
#include "extin.h"
#include "videoin.h"
#include "talkth.h"

#include "resource.h"


///////////////////////////////////////////////////////////////////////
CListenerWindow::CListenerWindow(
    HWND hWnd16,
    HRESULT* phr
    )
    : m_hBuddy(hWnd16)
/*++
Routine Description:

    Constructor.

Argument:

Return Value:

--*/
{
    DbgLog((LOG_TRACE,1,TEXT("______  hWnd16=%x _______"), m_hBuddy));
    _try {
        InitializeCriticalSection(&m_csMsg);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        
        *phr = GetExceptionCode();
        //
        // Make sure the destructor knows whether or not to delete this.
        //
        m_csMsg.LockSemaphore = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
CListenerWindow::~CListenerWindow()
/*++
Routine Description:

    Destroctor: release resoruce and destroy the hidden listener window.

Argument:

Return Value:

--*/
{
    WNDCLASS wndClass;
    DbgLog((LOG_TRACE,2,TEXT("Trying to destroy the 32bit listening window")));
    if (GetClassInfo(GetInstance(), GetAppName(), &wndClass) ) {
        HWND hwnd;
        DWORD err = 0;

        hwnd = GetWindow();

        if( (hwnd = FindWindow( GetAppName(), NULL )) != (HWND) 0 ) {
            if (UnregisterClass(GetAppName(), GetInstance()) == 0) {
                err = GetLastError();
                DbgLog((LOG_TRACE,1,TEXT("UnregisterClass failed (class not found or window still exist) with error=0x%x"), err));
            }
        }
        else {
            DbgLog((LOG_TRACE,1,TEXT("FindWindow failed with error=0x%d"), GetLastError()));

            if (UnregisterClass(GetAppName(), GetInstance()) == 0) {
                err = GetLastError();
                DbgLog((LOG_TRACE,1,TEXT("UnregisterClass failed (class not found or window still exist) with error=0x%d"), GetLastError()));
            }

        }
    }
    if (m_csMsg.LockSemaphore) {
        DeleteCriticalSection(&m_csMsg);
    }
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CListenerWindow::InitInstance(
    int nCmdShow)
/*++
Routine Description:

    Open the window handle on the 32bit size and send a message to signal its completion.
Argument:

Return Value:

--*/
{
    BASECLASS::InitInstance(nCmdShow);
    DbgLog((LOG_TRACE,1,TEXT("32Buddy is 0x%08lx (16bit one is %d) - telling 16bit guy we're loaded"),GetWindow(),GetBuddy()));
    SendMessage(GetBuddy(),WM_1632_LOAD,0,(LPARAM)GetWindow());
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
void CListenerWindow::StartListening() const
/*++
Routine Description:

    Listen to vfwwdm.drv's request.

Argument:

Return Value:

--*/
{
    MSG msg;

    DbgLog((LOG_TRACE,1,TEXT("StartListening: 32bit starting to listen (process msg)")));
    while(GetMessage(&msg, NULL, 0, 0)) {
        DispatchMessage(&msg);
    }
    DbgLog((LOG_TRACE,1,TEXT("StartListening: Left 32bit listening msg loop; quiting! To restart, load DLL again.")));
}

extern LONG cntDllMain;

/////////////////////////////////////////////////////////////////////////////
LRESULT CListenerWindow::WindowProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
/*++
Routine Description:

    Process 16bit request.

Argument:

Return Value:

--*/
{
    PCHANNEL pChannel = (PCHANNEL) lParam;
    DWORD dwRtn;
    DWORD FAR * pdwFlag;
    CVFWImage * pCVfWImage ;



    switch (message) {
    case WM_1632_LOAD: // DRV_LOAD:    // wParams are all the DRV_ messages.
        DbgLog((LOG_TRACE,2,TEXT("WM_1632_LOAD")));
        DbgLog((LOG_TRACE,2,TEXT("32bit: Strange, we've been asked to load again? %x:%x"),HIWORD(lParam),LOWORD(lParam)));
        break;

    case WM_CLOSE:
        DbgLog((LOG_TRACE,2,TEXT("WM_CLOSE begin:")));
        SendMessage(GetBuddy(),WM_1632_FREE,0,(LPARAM)GetWindow());
        DbgLog((LOG_TRACE,2,TEXT("WM_CLOSE end >>>>>>>>")));
        break;

    // Last message driver will receive before it is going away.
    case WM_1632_FREE:    // wParams are all the DRV_ messages.

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

        // If this is the last instance of this DLL, we are done.
        if(cntDllMain != 1) {
            DbgLog((LOG_TRACE,1,TEXT("WM_1632_FREE: cntDllMain=%d != 1; not ready to free resource;"), cntDllMain));
            break;

        } else {
            DbgLog((LOG_TRACE,1,TEXT("WM_1632_FREE: cntDllMain=%d ?= 1 ; PostQuitMessage()"), cntDllMain));
        }
        // Intentional fall thru to PostQuitMessage(1);
    case WM_DESTROY:
        DbgLog((LOG_TRACE,1,TEXT("WM_DESTROY: PostQuitMessage()")));
        PostQuitMessage(1);
        break;

    case WM_QUIT:
        DbgLog((LOG_TRACE,2,TEXT("WM_QUIT:")));
        break;

    case WM_1632_OPEN:    // DRV_OPEN:    // LPVIDEO_OPEN_PARMS
        if(wParam != DS_VFWWDM_ID) {
            DbgLog((LOG_TRACE,1,TEXT("Do not have a matching vfwwdm.drv")));
            return DV_ERR_NOTSUPPORTED;
        }

        // Wait for our turn
        DbgLog((LOG_TRACE,2,TEXT("WM_1632_OPEN: >>>>>>>>>>>Before EnterCriticalSection")));
        EnterCriticalSection(&m_csMsg);
        DbgLog((LOG_TRACE,2,TEXT("WM_1632_OPEN: <<<<<<<<<<<After EnterCriticalSection")));

        if(!(pCVfWImage = new CVFWImage(TRUE))) {
            DbgLog((LOG_TRACE,1,TEXT("Cannot create CVFWImage class. rtn DV_ERR_NOTSUPPORTED")));
            LeaveCriticalSection(&m_csMsg);
            return DV_ERR_NOTSUPPORTED;
        }

        if(!pCVfWImage->OpenDriverAndPin()) {
            if(pCVfWImage->BGf_GetDevicesCount(BGf_DEVICE_VIDEO) <= 0) {
                delete pCVfWImage;
                pCVfWImage = 0;
                LeaveCriticalSection(&m_csMsg);
                return 0;
            }

            // Asked to programatically open a target device; assume it is exclusive !!
            if(pCVfWImage->GetTargetDeviceOpenExclusively()) {
                delete pCVfWImage;
                pCVfWImage = 0;
                LeaveCriticalSection(&m_csMsg);
                return 0;

            } else {
                //
                // If we are here, it mean that:
                //    we have one or more capture device connected and enumerated,
                //    the last capture device is gone (unplugged/removed),
                // and we should bring up the device source dialog box for a user selection
                //
                if(DV_ERR_OK != DoExternalInDlg(GetInstance(), (HWND)0, pCVfWImage)) {
                    delete pCVfWImage;
                    pCVfWImage = 0;
                    LeaveCriticalSection(&m_csMsg);
                    return 0;
                }
            }
        } else {
            pChannel->pCVfWImage = (DWORD_PTR) pCVfWImage;
        }

#ifdef _DEBUG
        HWND    h16Buddy;
        h16Buddy = FindWindow(TEXT("MS:RayTubes16BitBuddy"), NULL);
        if (h16Buddy != NULL && GetBuddy() != h16Buddy) {
            DbgLog((LOG_TRACE,1,TEXT("Mmmmm !  16bitBuddy HWND has changed! OK if rundll32 was used.")));
            DbgLog((LOG_TRACE,1,TEXT(">> hBuddy: was(%x) is(%x) << "), GetBuddy(), h16Buddy));
            SetBuddy(h16Buddy);
        }
#endif
        pdwFlag = (DWORD *) pChannel->lParam1_Sync; //lParam;

        if(pdwFlag) {
            if(pCVfWImage->BGf_OverlayMixerSupported()) {
                *pdwFlag = 0x1;
            } else
                *pdwFlag = 0;
        }
        DbgLog((LOG_TRACE,1,TEXT("pdwFlag = 0x%x; *pdwFlag=0x%x"), pdwFlag, *pdwFlag));
        LeaveCriticalSection(&m_csMsg);
        return (DWORD_PTR) pCVfWImage;

    case WM_1632_CLOSE:    // DRV_CLOSE:
        DbgLog((LOG_TRACE,1,TEXT("WM_1332_CLOSE: begin---->")));
        // Wait for our turn
        DbgLog((LOG_TRACE,2,TEXT("WM_1632_CLOSE: >>>>>>>>>>>Before EnterCriticalSection")));
        EnterCriticalSection(&m_csMsg);
        DbgLog((LOG_TRACE,2,TEXT("WM_1632_CLOSE: <<<<<<<<<<<After EnterCriticalSection")));

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

        // If there are pending read. Stop streaming to reclaim buffers.
        if(pCVfWImage->GetPendingReadCount() > 0) {
            DbgLog((LOG_TRACE,1,TEXT("WM_1332_CLOSE:  there are %d pending IOs. Stop to reclaim them."), pCVfWImage->GetPendingReadCount()));
            if(pCVfWImage->BGf_OverlayMixerSupported()) {
                // Stop both the capture
                BOOL bRendererVisible = FALSE;
                pCVfWImage->BGf_GetVisible(&bRendererVisible);
                pCVfWImage->BGf_StopPreview(bRendererVisible);
            }
            pCVfWImage->StopChannel();  // This will set PendingCount to 0 is success.
        }

        // Allow closing only if no pending IOs.
        if(pCVfWImage->GetPendingReadCount() == 0) {
            dwRtn = pCVfWImage->CloseDriverAndPin();
            delete pCVfWImage;
        } else {
            DbgLog((LOG_TRACE,1,TEXT("WM_1332_CLOSE:  there are pending IO. REFUSE to close")));
            dwRtn = DV_ERR_NONSPECIFIC;
            ASSERT(pCVfWImage->GetPendingReadCount() == 0);
        }

        pChannel->bRel_Sync = TRUE;
        DbgLog((LOG_TRACE,1,TEXT("WM_1332_CLOSE: <------end")));

        LeaveCriticalSection(&m_csMsg);
        return dwRtn;

    // lParam1_Async: hWndParent;
    case WM_1632_EXTERNALIN_DIALOG:
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        DbgLog((LOG_TRACE,1,TEXT("pChannel=%x, pCVfWImage=%x"), pChannel, pCVfWImage));
        dwRtn = DoExternalInDlg(GetInstance(), (HWND)pChannel->lParam1_Async, pCVfWImage);

        if(DV_ERR_INVALHANDLE == dwRtn) {
        // It could be using a non-shareable device but being used at this time.
        // Let's tell user about it and perhaps, user can disable other video capture
        // applicationo and try again.
            if(pCVfWImage->UseOVMixer()) {
                DbgLog((LOG_TRACE,1,TEXT("This device use OVMixer() try again.")));
                dwRtn = DoExternalInDlg(GetInstance(), (HWND)pChannel->lParam1_Async, pCVfWImage);
            }
        }

        pChannel->bRel_Async = TRUE;
        SendMessage(GetBuddy(),WM_1632_DIALOG,wParam,(LPARAM)pChannel);
        return dwRtn;

    case WM_1632_VIDEOIN_DIALOG:
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        DbgLog((LOG_TRACE,1,TEXT("pChannel=%x, pCVfWImage=%x"), pChannel, pCVfWImage));
        dwRtn = DoVideoInFormatSelectionDlg(GetInstance(), (HWND)pChannel->lParam1_Async, pCVfWImage);
        pChannel->bRel_Async = TRUE;
        SendMessage(GetBuddy(),WM_1632_DIALOG,wParam,(LPARAM)pChannel);
        return dwRtn;

    // lParam1_Sync: &bmiHdr; lParam2_Sync: dwSize of LParam1_Sync
    case WM_1632_GETBITMAPINFO:
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->GetBitmapInfo((PBITMAPINFOHEADER)pChannel->lParam1_Sync, (DWORD) pChannel->lParam2_Sync);

    case WM_1632_SETBITMAPINFO:
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        if(! pCVfWImage->SetBitmapInfo((PBITMAPINFOHEADER)pChannel->lParam1_Sync, pCVfWImage->GetCachedAvgTimePerFrame())) {
            return DV_ERR_OK;
        } else
            return DV_ERR_INVALHANDLE;

    // _OVERLAY is called before _UPDATE
    case WM_1632_OVERLAY: // Update overlay window
        // Wait until the Close is completed
        DbgLog((LOG_TRACE,2,TEXT("WM_1632_OVERLAY: >>>>>>>>>>Before EnterCriticalSection")));
        EnterCriticalSection(&m_csMsg);
        DbgLog((LOG_TRACE,2,TEXT("WM_1632_OVERLAY: <<<<<<<<<<<After EnterCriticalSection")));

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

        if(pCVfWImage->StreamReady()) {
            HWND hClsCapWin;

            hClsCapWin = pCVfWImage->GetAvicapWindow();
            // If STREAM_INIT, set it visible;
            // if STREAM_FINI, remove its ownership and make it invisible.
            DbgLog((LOG_TRACE,2,TEXT("WM_1632_OVERLAY: >>>> %s hClsCapWin %x"),
                 (BOOL)pChannel->lParam1_Sync ? "ON":"OFF", hClsCapWin));


            if(pCVfWImage->IsOverlayOn() != (BOOL)pChannel->lParam1_Sync) {

                if((BOOL)pChannel->lParam1_Sync) {
                    // If this is a AVICAP client, then we know its client window handle.
                    if(hClsCapWin) {
                        DbgLog((LOG_TRACE,2,TEXT("A AVICAP client; so set its ClsCapWin(%x) as owner with (0x0, %d, %d)"), hClsCapWin, pCVfWImage->GetbiWidth(), pCVfWImage->GetbiHeight()));
                        pCVfWImage->BGf_OwnPreviewWindow(hClsCapWin, pCVfWImage->GetbiWidth(), pCVfWImage->GetbiHeight());
                    }
                    dwRtn = pCVfWImage->BGf_SetVisible((BOOL)pChannel->lParam1_Sync);
                } else {
                    dwRtn = pCVfWImage->BGf_SetVisible((BOOL)pChannel->lParam1_Sync);
                }

                pCVfWImage->SetOverlayOn((BOOL)pChannel->lParam1_Sync);
            }

        } else
            dwRtn = DV_ERR_OK;

        pChannel->bRel_Sync = TRUE;
        DbgLog((LOG_TRACE,2,TEXT("1632_OVERLAY<<<<:")));

        LeaveCriticalSection(&m_csMsg);
        return dwRtn;

    case WM_1632_UPDATE: // Update overlay window
        DbgLog((LOG_TRACE,2,TEXT("_UPDATE>>: GetFocus()=%x; GetForegroundWindow()=%x"), GetFocus(), GetForegroundWindow()));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

        if(pCVfWImage->StreamReady())
            dwRtn = pCVfWImage->BGf_UpdateWindow((HWND)pChannel->lParam1_Sync, (HDC)pChannel->lParam2_Sync);
        else
            dwRtn = DV_ERR_OK;
        pChannel->bRel_Sync = TRUE;
        DbgLog((LOG_TRACE,2,TEXT("_UPDATE<<: GetFocus()=%x; GetForegroundWindow()=%x"), GetFocus(), GetForegroundWindow()));

        return dwRtn;

    case WM_1632_GRAB: // fill the clients buffer with an image.
        if(!pChannel->lParam1_Sync)
            return DV_ERR_PARAM1;

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

        LPVIDEOHDR lpVHdr;
        BOOL bDirect;
        LPBYTE pData;

        lpVHdr = (LPVIDEOHDR) pChannel->lParam1_Sync;

        // To stream:
        //   1. Stream needs to be ready
        //   2. Right biSizeImage and its buffer size (if differnt, changin format!!)
        //
        if(pCVfWImage->ReadyToReadData((HWND) pChannel->hClsCapWin) &&
           pCVfWImage->GetbiSizeImage() == lpVHdr->dwBufferLength) {

            DbgLog((LOG_TRACE,3,TEXT("\'WM_1632_GRAB32: lpVHDr(0x%x); lpData(0x%x); dwReserved[3](0x%p), dwBufferLength(%d)"),
                  lpVHdr, lpVHdr->lpData, lpVHdr->dwReserved[3], lpVHdr->dwBufferLength));
            pData = (LPBYTE) lpVHdr->dwReserved[3];

            // Memory from AviCap is always sector align+8; a sector is 512 bytes.
            // Check alignment:
            //   If not alignment to the specification, we will use local allocated buffer (page align).
            //
            if((pCVfWImage->GetAllocatorFramingAlignment() & (ULONG_PTR) pData) == 0x0) {
                bDirect = TRUE;
            } else {
                bDirect = FALSE;
                DbgLog((LOG_TRACE,3,TEXT("WM_1632_GRAB: AviCap+pData(0x%p) & alignment(0x%x) => 0x%x > 0; Use XferBuf"),
                    pData, pCVfWImage->GetAllocatorFramingAlignment(),
                    pCVfWImage->GetAllocatorFramingAlignment() & (ULONG_PTR) pData));
            }

            dwRtn =
                pCVfWImage->GetImageOverlapped(
                                 (LPBYTE)pData,
                                 bDirect,
                                 &lpVHdr->dwBytesUsed,
                                 &lpVHdr->dwFlags,
                                 &lpVHdr->dwTimeCaptured);

            pChannel->bRel_Sync = TRUE;
            return dwRtn;

        } else {
            DbgLog((LOG_TRACE,1,TEXT("Stream not ready, or pCVfWImage->GetbiSizeImage()(%d) != lpVHdr->dwBufferLength(%d)"),
                  pCVfWImage->GetbiSizeImage(), lpVHdr->dwBufferLength));

            // Return suceeded but no data !!!
            lpVHdr->dwBytesUsed = 0;
            lpVHdr->dwFlags |= VHDR_DONE;

            pChannel->bRel_Sync = TRUE;
            return DV_ERR_OK;
        }

    case WM_1632_STREAM_INIT:
        DbgLog((LOG_TRACE,2,TEXT("**WM_1632_STREAM_INIT:**")));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->VideoStreamInit(pChannel->lParam1_Sync,pChannel->lParam2_Sync);

    case WM_1632_STREAM_FINI:
        DbgLog((LOG_TRACE,2,TEXT("**WM_1632_STREAM_FINI:**")));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->VideoStreamFini();

    case WM_1632_STREAM_START:
        DbgLog((LOG_TRACE,2,TEXT("**WM_1632_STREAM_START:**")));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->VideoStreamStart((WORD)pChannel->lParam1_Sync,(LPVIDEOHDR)pChannel->lParam2_Sync);

    case WM_1632_STREAM_STOP:
        DbgLog((LOG_TRACE,2,TEXT("**WM_1632_STREAM_STOP:**")));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->VideoStreamStop();

    case WM_1632_STREAM_RESET:
        DbgLog((LOG_TRACE,2,TEXT("**WM_1632_STREAM_RESET:**")));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->VideoStreamReset();

    case WM_1632_STREAM_GETPOS:
        DbgLog((LOG_TRACE,2,TEXT("**WM_1632_STREAM_GETPOS:**")));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->VideoStreamGetPos(pChannel->lParam1_Sync,pChannel->lParam2_Sync);

    case WM_1632_STREAM_GETERROR:
        DbgLog((LOG_TRACE,2,TEXT("**WM_1632_STREAM_GETERROR:**")));
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        return pCVfWImage->VideoStreamGetError(pChannel->lParam1_Sync,pChannel->lParam2_Sync);
#if 0
    case WM_DEVICECHANGE:
        DEV_BROADCAST_HDR * pDevBCHdr;
        switch(wParam) {
        case DBT_DEVICEREMOVEPENDING:
            pDevBCHdr = (DEV_BROADCAST_HDR *) lParam;
            DbgLog((LOG_TRACE,2,TEXT("WM_DEVICECHANGE, DBT_DEVICEREMOVEPENDING lParam %x"), lParam));
            break;
        case DBT_DEVICEREMOVECOMPLETE:
            pDevBCHdr = (DEV_BROADCAST_HDR *) lParam;
            DbgLog((LOG_TRACE,2,TEXT("WM_DEVICECHANGE, DBT_DEVICEREMOVECOMPLETE lParam %x"), lParam));
            break;
        default:
            DbgLog((LOG_TRACE,2,TEXT("WM_DEVICECHANGE wParam %x, lParam %x"), wParam, lParam));
        }
        break;
#endif
    default:
        DbgLog((LOG_TRACE,2,TEXT("Unsupported message: WM_16BIT %x; msg %x, wParam %x"), WM_16BIT, message, wParam));
        break;
    }

    return DefWindowProc(hWnd,message,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\talkth.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    TalkTh.h

Abstract:

    Header file for TalkTh.cpp.

    This thread performs streaming capture.
  
    When used by VFW16, it assumes things about the destination buffer.
        1) The first byte of the buffer is an 'exclusion' byte.
        that is, when the byte is zero, it can copy data into the buffer
        2) The destination is big enough to hold the data+4.
  
    When used by VFW32 or Quartz, create the object providing it with an event
    that will be used to signal a copy.
    The data will be copied into the buffer supplied by SetDestination.

Author:

    FelixA 1996

Modified:
    
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/ 
#ifndef _TALKTH_H
#define _TALKTH_H

#include "vfwimg.h"

enum EThreadError
{
    successful,
    error,
    threadError,
    threadRunning,          // thread is already running.
    noEvent,                // we couldn't create and event, thread can't start
    threadNoPinHandle
};


#define MAX_NUM_READS 32

class CStreamingThread //: public CLightThread
{
public:

    // Call from CreateThread(); thi smust be a static.
    static LPTHREAD_START_ROUTINE ThreadMain(CStreamingThread * object);    // decides if its 16bit or event driver

    // Call from other thread to start/stop capturing and this thread.
    EThreadError Start(UINT cntVHdr, LPVIDEOHDR lpVHdHead, int iPriority=THREAD_PRIORITY_NORMAL);

    EThreadError Stop();

    DWORD GetLastCaptureError() {return m_dwLastCapError;}
    DWORD GetFrameDropped() {return m_dwFrameDropped;}
    DWORD GetFrameCaptured() {return m_dwFrameCaptured;}
    DWORD GetStartTime();


    CStreamingThread(
        DWORD dwAllocatorFramingCount, 
        DWORD dwAllocatorFramingSize, 
        DWORD dwAllocatorFramingAlignment, 
        DWORD dwFrameInterval, 
        CVFWImage * Image );

    ~CStreamingThread();

private:

    void SetLastCaptureError(DWORD dwErr) {m_dwLastCapError = dwErr;}

    // 
    // Regarding this thread
    //
    EThreadError  m_status; 
    HANDLE        m_hThread;
    DWORD         m_dwThreadID;
    BOOL          m_bKillThread;
    HANDLE        m_hEndEvent;

    DWORD         m_dwLastCapError;

    EThreadError GetStatus();
    HANDLE  GetEndEvent();
    BOOL    IsRunning();

    //
    // This event, and SetDestination are used by 32bit guys who know about this.
    //
    void  InitStuff();

    //
    // It caller's, in other thread, context
    //
    CVFWImage * m_pImage;

    //
    //  Regarding setting up the capture environment
    //
    DWORD   m_dwFrameInterval;

    //
    // Things assumed to be constant while streaming
    //
    HANDLE  m_hPinHandle;
    DWORD   m_dwBufferSize;

    // 
    // Regarding capture data in this thread
    //
    DWORD   m_dwNumReads; // =NUM_READS;
    DWORD   m_dwNextToComplete;

    LPBYTE             m_TransferBuffer[MAX_NUM_READS];     // reads put in there
    OVERLAPPED         m_Overlap[MAX_NUM_READS];            // using an event in here to block
    KS_HEADER_AND_INFO m_SHGetImage[MAX_NUM_READS];

    // m_dwFrameNumber = m_dwFrameCaptured + m_dwFrameDropped
    // For 30FPS, it would take 1657 days to wrap this counter.
    // 0xFFFFFFFF = 4,294,967,295 / 30FPS / 60Sec / 60Min / 24Hour = 1657 days = 4.5 years
    DWORD      m_dwFrameCaptured;  
    DWORD      m_dwFrameDropped;  
#if 1
    DWORD      m_tmStartTime; 
#else
    LONGLONG   m_tmStartTime; 
#endif
    DWORD      m_cntVHdr;   
    LPVIDEOHDR m_lpVHdrNext;  

    void SyncReadDataLoop();
    DWORD IssueNextAsyncRead(DWORD i);  // starts an overlapped read 

    LPVIDEOHDR GetNextVHdr();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\vfwext.cpp ===
/*++

Copyright (c) 1997 -1999 Microsoft Corporation

Module Name:

    VfWExt.cpp

Abstract:

    VFW Extension dialog example

Author:

    Yee J. Wu (ezuwu) 15-October-97

Environment:

    User mode only

Revision History:

--*/


#include "pch.h"

#include <vfwext.h>
#include "resource.h"        // Test dialog ID

// Normally, this is obtained from DllEntry routine, like LibMain
extern HINSTANCE g_hInst;

//
// This structure is used to save the function pointers and host's straucture.
// Save a pointer to this structue in the dialog's DWL_USER's extra bytes.
//
typedef struct _VFWEXT_INFO {
    LPFNEXTDEVIO pfnDeviceIoControl;
    LPARAM lParam;
} VFWEXT_INFO, * PVFWEXT_INFO;

//
// Saving the above structure as a lParam has not yet working
// so this global variable is used.
//
PVFWEXT_INFO g_lParam;


// Function ptototype
// Note:
//    Calling convention in windef.h:
//    #define CALLBACK __stdcall

BOOL CALLBACK
VFWExtPageDlgProc(
    HWND    hDlg,
    UINT    uMessage,
    WPARAM    wParam,
    LPARAM    lParam);

UINT
VFWExtPageCallback(
   HWND hwnd,
   UINT uMsg,
   LPPROPSHEETPAGE ppsp);






HPROPSHEETPAGE CreateMyPage(
    LPFNEXTDEVIO pfnDeviceIoControl,
    LPARAM lParam)
/*++
Routine Description:

    Create a property sheet page

Argument:

Return Value:

--*/
{
    PROPSHEETPAGE psPage;

    // Need to free this when the dialog is close.
    PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) new BYTE[sizeof(VFWEXT_INFO)];
    if (pVfWExtInfo == 0)
        return 0;

    pVfWExtInfo->pfnDeviceIoControl = pfnDeviceIoControl;
    pVfWExtInfo->lParam                = lParam;

    psPage.dwSize        = sizeof(psPage);
    psPage.dwFlags        = PSP_USEREFPARENT | PSP_USECALLBACK;
    psPage.hInstance    = g_hInst;
    psPage.pszTemplate    = MAKEINTRESOURCE(IDD_DLG_VFWEXT);
    psPage.pfnDlgProc    = (DLGPROC)VFWExtPageDlgProc;
    psPage.pcRefParent    = 0;
    psPage.pfnCallback    = (LPFNPSPCALLBACK) VFWExtPageCallback;    // you should use the callback to know when your page gets destroyed
    psPage.lParam        = (LPARAM) pVfWExtInfo;

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psPage);

    //
    // Why doesn't psPage.lParam is passed as the lParam to WM_INITDIALOG ???
    // This is a hack ! (using global)
    //
    g_lParam = pVfWExtInfo;

    return hPage;
}

BOOL ExtDeviceIoControl(
    LPFNEXTDEVIO    pfnDeviceIoControl,
    LPARAM        lParam,
    DWORD        dwVfWFlags,
    DWORD        dwIoControlCode,
    LPVOID        lpInBuffer,
    DWORD        cbInBufferSize,
    LPVOID        lpOutBuffer,
    DWORD        cbOutBufferSize,
    LPDWORD        pcbReturned)
/*++
Routine Description:

    Call VfWWDM mapper's DeviceIoControl with an overalp structure.
    If the return is FALSE, wait for signal if the operation is pending.

Argument:

    see DeviceIoControl().

Return Value:

    TRUE: DeviceIoControl suceeded;  FALSE, otherwise.

--*/
{
    OVERLAPPED    ov;
    BOOL bRet;

    // Create the overlap structure including an event
    ov.Offset        = 0;
    ov.OffsetHigh    = 0;
    ov.hEvent        = CreateEvent( NULL, FALSE, FALSE, NULL );

    if (ov.hEvent == (HANDLE) 0) {

        bRet= FALSE;
        DbgLog((LOG_TRACE,1,TEXT("--CreateEvent has failed.")));
    } else {

        bRet = pfnDeviceIoControl (
                lParam,
                dwVfWFlags,
                dwIoControlCode,
                lpInBuffer,
                cbInBufferSize,
                lpOutBuffer,
                cbOutBufferSize,
                pcbReturned,
                &ov);

        //
        // If TRUE: then operation has succeeded and finished.
        // If FALSE, and this might be an async.(overlapped) operation, we wait.
        //
        if (!bRet && GetLastError() == ERROR_IO_PENDING)
            bRet = WaitForSingleObject( ov.hEvent, 2000 ) == WAIT_OBJECT_0;        // Wait 2000 msec

        // Release event
        CloseHandle(ov.hEvent);
    }

    return bRet;
}



BOOL GetPropertyValue(
    LPFNEXTDEVIO    pfnDeviceIoControl,
    LPARAM            lParam,
    GUID   guidPropertySet,  // like: KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    ULONG  ulPropertyId,     // like: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    PLONG  plValue,
    PULONG pulFlags,
    PULONG pulCapabilities)
/*++
Routine Description:

Argument:

Return Value:
    FALSE: not supported.
    TRUE: plValue, pulFlags and PulCapabilities are all valid.

--*/
{
    BOOL    bRet;
    DWORD    cbRet;


    KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;
    ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

    VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
    VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
    VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
    VideoProperty.Flags          = 0;

    if ((bRet = ExtDeviceIoControl(
                    pfnDeviceIoControl,
                    lParam,
                    VFW_USE_DEVICE_HANDLE,    // Use the DEVICE handle
                    IOCTL_KS_PROPERTY,
                    &VideoProperty,
                    sizeof(VideoProperty),
                    &VideoProperty,
                    sizeof(VideoProperty),
                    &cbRet))) {

        *plValue         = VideoProperty.Value;
        *pulFlags        = VideoProperty.Flags;
        *pulCapabilities = VideoProperty.Capabilities;
    }

    return bRet;
}



BOOL GetStreamState(
    LPFNEXTDEVIO    pfnDeviceIoControl,
    LPARAM            lParam,
    KSSTATE *        pdwKSState
    )
/*++
Routine Description:

    Get currect streaming state (STOP, PAUSE, or RUN) of the capture device.

Argument:

Return Value:

--*/
{
    KSPROPERTY    ksProp={0};
    DWORD        cbRet = FALSE;


    ksProp.Set    = KSPROPSETID_Connection ;
    ksProp.Id    = KSPROPERTY_CONNECTION_STATE;
    ksProp.Flags= KSPROPERTY_TYPE_GET;

    return ExtDeviceIoControl(
            pfnDeviceIoControl,
            lParam,
            VFW_USE_STREAM_HANDLE,    // Use the pin connection (stream) handle
            IOCTL_KS_PROPERTY,
            &ksProp,
            sizeof(ksProp),
            pdwKSState,
            sizeof(KSSTATE),
            &cbRet);
}



BOOL SetStreamState(
    LPFNEXTDEVIO    pfnDeviceIoControl,
    LPARAM            lParam,
    KSSTATE            ksState
    )
/*++
Routine Description:

      Sets current streaming state (STOP, PAUSE, or RUN) of the connection pin.

Argument:

Return Value:

--*/
{
    KSPROPERTY    ksProp={0};
    DWORD        cbRet = FALSE;


    ksProp.Set    = KSPROPSETID_Connection ;
    ksProp.Id    = KSPROPERTY_CONNECTION_STATE;
    ksProp.Flags= KSPROPERTY_TYPE_SET;

    return ExtDeviceIoControl(
            pfnDeviceIoControl,
            lParam,
            VFW_USE_STREAM_HANDLE,    // Use the pin connection (stream) handle
            IOCTL_KS_PROPERTY,
            &ksProp,
            sizeof(ksProp),
            &ksState,
            sizeof(KSSTATE),
            &cbRet);
}

BOOL HasDeviceChanged(
    LPFNEXTDEVIO    pfnDeviceIoControl,
    LPARAM            lParam)
/*++
Routine Description:

    return (BOOL) (Selected_Device == Currect_Stream_Device)

Argument:

Return Value:

--*/
{
    return pfnDeviceIoControl (
                lParam,
                VFW_QUERY_DEV_CHANGED,
                0,0,0,0,0,0, 0);
}


int ExtApply(
    HWND hDlg,
    PVFWEXT_INFO pVfWExtInfo)
/*++
Routine Description:

    Retrieve user's changes and set them accordingly.

Argument:

Return Value:

--*/
{
    if (pVfWExtInfo == 0)
        return 0;

    //
    // Query the current setting and set it.
    //
    KSSTATE ksState;

    if (SendMessage (GetDlgItem(hDlg, IDC_CB_KSSTATE_STOP),BM_GETCHECK, 0, 0) == BST_CHECKED)
        ksState = KSSTATE_STOP;
    if (SendMessage (GetDlgItem(hDlg, IDC_CB_KSSTATE_PAUSE),BM_GETCHECK, 0, 0) == BST_CHECKED)
        ksState = KSSTATE_PAUSE;
    if (SendMessage (GetDlgItem(hDlg, IDC_CB_KSSTATE_RUN),BM_GETCHECK, 0, 0) == BST_CHECKED)
        ksState = KSSTATE_RUN;


    if (SetStreamState(
            pVfWExtInfo->pfnDeviceIoControl,
            pVfWExtInfo->lParam,
            ksState)) {

        DbgLog((LOG_TRACE,2,TEXT("Stream has been set top RUN state.")));
    }

    return 0;
}




int ExtSetActive(
    HWND hDlg,
    PVFWEXT_INFO pVfWExtInfo)
/*++
Routine Description:

    Initialize the property page controls before they becomes visible.

Argument:

Return Value:

--*/
{
    BOOL bDeviceChanged;

    if (pVfWExtInfo == 0)
        return 0;

    bDeviceChanged = HasDeviceChanged(
                        pVfWExtInfo->pfnDeviceIoControl,
                        pVfWExtInfo->lParam);

    // If the selected device is not the current streaming device,
    // my controls are not valid so disable the entire dialog box.
    // If you like, you shoudl port a message in your dialog box.
    // This message is posted in the standard dialog box:
    //    "Selected capture source is not the current stream device;\nall controls are disabled."
    DbgLog((LOG_TRACE,2,TEXT("PageChange=%s"), bDeviceChanged ? "TRUE" : "FALSE"));
    EnableWindow(hDlg, !bDeviceChanged);
    if (bDeviceChanged)
        return 0;

    //
    //  Try host's DeviceIoControl
    //        (1) use device handle
    //      (2) use streaming handle
    //
    LONG lValue;
    ULONG ulFlags, ulCapabilities;

    if (GetPropertyValue(
            pVfWExtInfo->pfnDeviceIoControl,
            pVfWExtInfo->lParam,
            PROPSETID_VIDCAP_VIDEOPROCAMP,
            KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
            &lValue, &ulFlags, &ulCapabilities)) {

        TCHAR szValue[32];

        wsprintf(szValue, TEXT("%d"), lValue);
        SetWindowText(GetDlgItem(hDlg, IDC_EDT_VFWEXT_BRIGHTNESS), szValue);

        DbgLog((LOG_TRACE,2,TEXT("Brightness is supported: current value=%d, flags=0x%x, ulCapabilities=0x%x"), lValue, ulFlags, ulCapabilities));


        // Does the device support auto or manual mode
        if (ulCapabilities & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) {
            DbgLog((LOG_TRACE,2,TEXT("Auto mode is supported.")));

            SendMessage (GetDlgItem(hDlg, IDC_CB_BRIGHTNESS_AUTO),BM_SETCHECK, 1, 0);
        } else {
            EnableWindow(GetDlgItem(hDlg, IDC_CB_BRIGHTNESS_AUTO), FALSE);
        }


    } else {
        // This function is not supported.
    }

    //
    // Get current streaming state
    //
    KSSTATE KSState;

    if (GetStreamState(
            pVfWExtInfo->pfnDeviceIoControl,
            pVfWExtInfo->lParam,
            &KSState)) {

        switch (KSState) {

        case KSSTATE_STOP:
            SendMessage (GetDlgItem(hDlg, IDC_CB_KSSTATE_STOP),BM_SETCHECK, 1, 0);
            break;
        case KSSTATE_PAUSE:
            SendMessage (GetDlgItem(hDlg, IDC_CB_KSSTATE_PAUSE),BM_SETCHECK, 1, 0);
            break;
        case KSSTATE_RUN:
            SendMessage (GetDlgItem(hDlg, IDC_CB_KSSTATE_RUN),BM_SETCHECK, 1, 0);
            break;
        default:
            break;
        }
    }

    return 0;
}




BOOL CALLBACK
VFWExtPageDlgProc(
    HWND    hDlg,
    UINT    uMessage,
    WPARAM    wParam,
    LPARAM    lParam)
/*++
Routine Description:

    Process extension DLL's own property page.

Argument:

Return Value:

--*/
{

    // Retrieve your saved pointer
    PVFWEXT_INFO pVfWExtInfo = (PVFWEXT_INFO) GetWindowLongPtr(hDlg, DWLP_USER);


    switch (uMessage)
    {

        //
        // Set the DWL_USER to be your context pointer.
        //
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg,DWLP_USER, (LPARAM) g_lParam);
        break;

        //
        // When the user clicks on things,
        //
        case WM_COMMAND:
        break;

        //
        //
        //
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {

                case PSN_SETACTIVE:
                    // Whenever this page is selected,
                    // this is called right before it become visible.
                    ExtSetActive(hDlg, g_lParam);
                    break;

                //
                // The use has either dismissed the dialogs, or clicked OK/Apply
                //
                case PSN_APPLY:
                    ExtApply(hDlg, pVfWExtInfo);
                    break;

                //
                // The user clicked cancel - its NOT advised to do anything here
                // except talk to your device
                //
                case PSN_QUERYCANCEL:
                break;

            }
        break;

    }
    return FALSE;
}



UINT
VFWExtPageCallback(
   HWND hwnd,
   UINT uMsg,
   LPPROPSHEETPAGE ppsp)
/*++
Routine Description:

    See  PropSheetPageProc in MSDN

Argument:

Return Value:

--*/
{
    switch(uMsg)
    {
    case PSPCB_CREATE:
        return 1;    // allow creation.
        break;
    case PSPCB_RELEASE:
        return 0;    // ignored - clean up
        break;
    }
    return 0;
}



DWORD CALLBACK VFWWDMExtension(
    LPVOID                    pfnDeviceIoControl,
    LPFNADDPROPSHEETPAGE    pfnAddPropertyPage,
    LPARAM                    lParam)
/*++
Routine Description:

    This is the exported client function that vfwwdm mapper calls
    to pass pointers to callback functions.  These callback functions
    enable IHV's extension DLL to add its own property page to the
    standard property sheet.

Argument:

    pfnDeviceIcControl - pointer to mapper's DeviceIoControl function
        without the handle.

    pfsAddPropertyPage - After a property page is created, this function is
        callled    to add to the mapper's video dialog.

    lParam - this is a pointer to a structure that contain some internal state of
        the VfWWDM mapper, and the extension DLL need only to pass them back
        in the above two callback functions.

Return Value:

    A 32 bits DWORD that contains service request information to VfWWDM mapper.


--*/
{
    DWORD dwFlags = 0;

    //
    // Create my property page and then add it to the host's sheet.
    //
    HPROPSHEETPAGE hPage = CreateMyPage((LPFNEXTDEVIO) pfnDeviceIoControl, lParam);

    if (hPage) {
        if (pfnAddPropertyPage(hPage,lParam))
            dwFlags |= VFW_OEM_ADD_PAGE;
    }

    //
    // Purposely remove the camera control page
    //
    dwFlags |= VFW_HIDE_CAMERACONTROL_PAGE;



    return dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\vfwimg.cpp ===
/*++


Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    VfWImg.cpp

Abstract:

    This class serve between generic image class (ImgCls) and vfw client application.

Author:

    FelixA

Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

#include "vfwimg.h"
#include "extin.h"
#include "talkth.h"
#include "resource.h"


extern HINSTANCE g_hInst;



////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////
CVFWImage::CVFWImage(BOOL bUse16BitBuddy)
     :
      CCaptureGraph(
          BGf_PURPOSE_VFWWDM,
          BGf_PREVIEW_CHILD,
          CLSID_VideoInputDeviceCategory,
          CDEF_BYPASS_CLASS_MANAGER,
          CLSID_AudioInputDeviceCategory,
          0,
          g_hInst
          ),
      m_bUse16BitBuddy(bUse16BitBuddy),
      m_pStreamingThread(NULL),
      m_dwNumVDevices(0),
      m_dwNumADevices(0),
      m_bUseOVMixer(FALSE),
      m_hAvicapClient(0),
      m_bOverlayOn(FALSE),
      m_bNeedStartPreview(FALSE),
      m_bVideoInStarted(FALSE),
      m_bVideoInStopping(FALSE),
      m_pEnumVDevicesList(NULL),
      m_pEnumADevicesList(NULL)
  {
    DbgLog((LOG_TRACE,2,TEXT("Creating the VfW-WDM Mapper object")));

    m_dwNumVDevices =
        BGf_CreateCaptureDevicesList(BGf_DEVICE_VIDEO, &m_pEnumVDevicesList);  // return number of devices
    DbgLog((LOG_TRACE,1,TEXT("There are %d video capture devices enumerated."), m_dwNumVDevices));

    m_dwNumADevices =
        BGf_CreateCaptureDevicesList(BGf_DEVICE_AUDIO, &m_pEnumADevicesList);  // return number of devices
    DbgLog((LOG_TRACE,1,TEXT("There are %d audio capture devices enumerated."), m_dwNumADevices));

    //
    // The first occurrence of the matching FreiendlyName's DevicePath will be used.
    // It is possible that szFriendlyName to be differnt (to open device programatically);
    // the szFriendlyName is used, and previously saved DevicePath is ignored.
    //
    for(DWORD i = 0; m_pEnumVDevicesList != 0 && i < m_dwNumVDevices; i++) {
        if(_tcscmp(GetTargetDeviceFriendlyName(), m_pEnumVDevicesList[i].strFriendlyName) == 0) {
           SetDevicePathSZ(m_pEnumVDevicesList[i].strDevicePath);
           DbgLog((LOG_TRACE,1,TEXT("Open %s "), m_pEnumVDevicesList[i].strFriendlyName));
           break;
        }
    }

    //
    // Set and later open last saved unique device path
    // if device is not there, a client application needs to
    // propmpt user the video source dialog box to select another one.
    //
    TCHAR * pstrLastSavedDevicePath = GetDevicePath();
    if(pstrLastSavedDevicePath) {
        if(S_OK != BGf_SetObjCapture(BGf_DEVICE_VIDEO, pstrLastSavedDevicePath)) {
            DbgLog((LOG_TRACE,1,TEXT("BGf_SetObjCapture(BGf_DEVICE_VIDEO, pstrLastSavedDevicePath) failed; probably no such device path.")));
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////
CVFWImage::~CVFWImage()
{
    DbgLog((LOG_TRACE,2,TEXT("Destroying the VFW-WDM Mapper object")));

    if(m_pEnumVDevicesList) {
        BGf_DestroyCaptureDevicesList(m_pEnumVDevicesList);
        m_pEnumVDevicesList = 0;
    }
    m_dwNumVDevices = 0;

    if(m_pEnumADevicesList) {
        BGf_DestroyCaptureDevicesList(m_pEnumADevicesList);
        m_pEnumADevicesList = 0;
    }
    m_dwNumADevices = 0;

}


////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the frame rate to so many microseconds per frame.
//
////////////////////////////////////////////////////////////////////////////////////////
DWORD CVFWImage::SetFrameRate(DWORD dwNewAvgTimePerFrame)
{
    // Set a new frame rate requires creating a new stream
    // may call SetBitMapInfo and pass it dwMicroSecPerFrame -->
    DWORD dwCurFrameInterval = 
        GetCachedAvgTimePerFrame();

    PBITMAPINFOHEADER pBMHdr = 
        GetCachedBitmapInfoHeader();
        
    DbgLog((LOG_TRACE,2,TEXT("SetFrameRate: %d to %d"), GetCachedAvgTimePerFrame(), dwNewAvgTimePerFrame));


    if (!this->SetBitmapInfo(
                pBMHdr,             // use the existing bitmapinfor
                dwNewAvgTimePerFrame))        // unit=100nsec
        return DV_ERR_OK;
    else
        return DV_ERR_INVALHANDLE;
}



BOOL
CVFWImage::ReadyToReadData(
    HWND hClsCapWin)
{
    if(!StreamReady()) {
        DbgLog((LOG_TRACE,1,TEXT("ReadyToRead: Stream not started or created (switching device?)")));
        return FALSE;
    }


    // Some multithread application can call DVM_FRAME while its
    // the other thread is finishing the DVM_STREAM_STOP.
    if(m_bVideoInStopping) {
        DbgLog((LOG_TRACE,1,TEXT("ReadyToRead: VIDEO_IN capture is stopping; wait...")));
        return FALSE;
    }


    if(m_bNeedStartPreview) {
        if(!BGf_PreviewStarted()) {

            // Set only once and stay as READONLY
            if(hClsCapWin && !m_hAvicapClient)
                m_hAvicapClient = hClsCapWin;

            SetOverlayOn(FALSE);
            if(!BGf_StartPreview(FALSE)) {
                DbgLog((LOG_TRACE,1,TEXT("ReadyToReadData: Start preview failed.")));
                return FALSE;
            }
            return TRUE;
        }
    }

    return TRUE;
}



BOOL
CVFWImage::BuildWDMDevicePeviewGraph()
{
    DbgLog((LOG_TRACE,1,TEXT("######### IBuildWDMDevicePeviewGraph:")));

    if(BGf_PreviewGraphBuilt()) {
        DbgLog((LOG_TRACE,1,TEXT("Graph is already been built.")));
        return TRUE;
    }


    DbgLog((LOG_TRACE,1,TEXT(" (0) Set capture device path")));
    if(S_OK != BGf_SetObjCapture(BGf_DEVICE_VIDEO, GetDevicePath())) {
        DbgLog((LOG_TRACE,1,TEXT("SetObjCapture has failed. Device is: %s"),GetDevicePath()));
        return FALSE;
    }

    //
    // Special case:
    //    Need to know if OVMixer is used for the down stream graph.\
    //    This is needed for system that has BPC (WebTV) installed,
    //    it might be owning a non-shareable device that we are trying
    //    to open.  With this information, we can later prompt user with
    //    a message to ask them to do "somthing" to release the resource
    //    and continue (or retry).
    //
    DbgLog((LOG_TRACE,1,TEXT(" (1) Build up stream graph")));
    if(S_OK != BGf_BuildGraphUpStream(FALSE, &m_bUseOVMixer)) {
        DbgLog((LOG_TRACE,1,TEXT("Build capture graph has failed, and m_bUseOVMixer=%s"), m_bUseOVMixer?"Yes":"No"));
        return FALSE;
    }

    DbgLog((LOG_TRACE,1,TEXT(" (1.b) Route related audio pin ?? if avaiable.")));
    LONG idxIsRoutedTo = BGf_GetIsRoutedTo();
    if(idxIsRoutedTo >= 0) {
        if(BGf_RouteInputChannel(idxIsRoutedTo) != S_OK) {
            DbgLog((LOG_TRACE,1,TEXT("Cannot route input pin %d selected."), idxIsRoutedTo));
        }
    }

    return TRUE;
}



BOOL CVFWImage::
OpenThisDriverAndPin(TCHAR * pszSymbolicLink)
{
    if (pszSymbolicLink == NULL)
        return FALSE;

    //
    // Device path is unique for a capture device.
    //
    this->SetDevicePathSZ((TCHAR *)pszSymbolicLink);

    //
    // Build a WDM capture graph; have NOT started Preview!!
    //
    if(!BuildWDMDevicePeviewGraph()) {
         DbgLog((LOG_TRACE,1,TEXT("******* Failed to CreateCaptureGraph.*****")));
         return FALSE;
    }


    //
    // Obtain the handle of the graph for
    //  1. query/set proerty and,
    //  2. open the capture pin
    //
    DbgLog((LOG_TRACE,1,TEXT(" (3) Query and set device handle")));
    HANDLE hDevice = BGf_GetDeviceHandle(BGf_DEVICE_VIDEO);
    if(!hDevice) {
        DbgLog((LOG_TRACE,1,TEXT("Failed to get capture device handle; Fatal!>>>>.")));  // unlikely if graph is created.
        BGf_DestroyGraph();
        return FALSE;
    }


    //
    // Get Capture PIN's ID (it may not be 0?)
    //
    ULONG ulCapturePinID;
    if(NOERROR != BGf_GetCapturePinID(&ulCapturePinID))
        ulCapturePinID = 0;  // Default; but would BGf_GetCapturePinID() failed ??

    //
    // Based on the DevicePath (i.e. SymbolicLink), open this
    // registry key.  If it does not exist, create it.
    // Set the hDevice and query its advertised data range
    //

    SetDeviceHandle(hDevice, ulCapturePinID);


    //
    // Create/open device registry subkey in order to retrieve persisted values
    //
    CreateDeviceRegKey((LPCTSTR) pszSymbolicLink);

    DWORD dwRtn;
    DbgLog((LOG_TRACE,1,TEXT(" (4) CreatePin()")));
    //
    // Get persisted KSDATARANGE, AvgTimePerFrame and BITMAPINFOHEADER settings from registry.    
    // TRUE: existing format; FALSE: new device, no format saved.
    //
    if(GetDataFormatVideoFromReg()) {
        // Open an existing format
        dwRtn = CreatePin(
            GetCachedDataFormat(), 
            GetCachedAvgTimePerFrame(),
            GetCachedBitmapInfoHeader()
            );

    } else {
        // Open the first data range/format
        dwRtn = CreatePin(
            0, 
            0, 
            0
            );
    }

    if(DV_ERR_OK != dwRtn) {
        DbgLog((LOG_TRACE,1,TEXT("Pin connection creation failed so destroy the graph and quit.")));
        SetDeviceHandle(0, 0);
        BGf_DestroyGraph();
        return FALSE;
    }


    DbgLog((LOG_TRACE,1,TEXT(" (5) Render down stream if overlay mixer is supported.")));
    if(BGf_OverlayMixerSupported()) {
        m_bNeedStartPreview = TRUE;

        // When we render down stream, which will include a video renderer.
        // The render will become the active window until it disappear.
        if(S_OK != BGf_BuildGraphDownStream(NULL)) {
            DbgLog((LOG_TRACE,1,TEXT("Failed to render the preview pin.")));
            return FALSE;
        }

    } else {
        m_bNeedStartPreview = FALSE;
    }


    return TRUE;
}

BOOL CVFWImage::OpenDriverAndPin()
{
    TCHAR * pstrDevicePath;

    if(BGf_GetDevicesCount(BGf_DEVICE_VIDEO) <= 0)
        return FALSE;

    pstrDevicePath = BGf_GetObjCaptureDevicePath(BGf_DEVICE_VIDEO);
    if(!pstrDevicePath) {
        DbgLog((LOG_TRACE,1,TEXT("No deivce has been previously selected.")));
        return FALSE;
    }

    NotifyReconnectionStarting();
    if(OpenThisDriverAndPin(pstrDevicePath)) {
        // Ready to stream
        NotifyReconnectionCompleted();
        return TRUE;

    } else {
        // Since we did not open successfully, clean up.
        CloseDriverAndPin();
        DbgLog((LOG_TRACE,1,TEXT("Open this device or build graph has failed.")));
        return FALSE;
    }
}


BOOL CVFWImage::CloseDriverAndPin()
{

    // Start reconnection; stop incoming grab frame.
    NotifyReconnectionStarting();

    DbgLog((LOG_TRACE,1,TEXT("<0>Stop preview if it is on.")));
    if(BGf_PreviewGraphBuilt()) {
        if(BGf_OverlayMixerSupported()) {
            BGf_StopPreview(FALSE);
        }
    }
    StopChannel();

    DbgLog((LOG_TRACE,1,TEXT("<1>Destroy Pin")));
    if (!DestroyPin()) {
        // What do you do if PIN failed to close ?
    }

    // Remove the data range data
    DestroyDriverSupportedDataRanges();

    DbgLog((LOG_TRACE,1,TEXT("<2>Destroy graph")));
    BGf_DestroyGraph();

    DbgLog((LOG_TRACE,1,TEXT("<3>Done CloseDriverAndPin().")));

    return TRUE;
}


/*+++
 *
 * Streaming related function
 *
---*/

//
// This function is only valid if it is in WinNT;
// that is why we are checking m_hUse16BitBuddy flag.
//
void
CVFWImage::videoCallback(WORD msg, DWORD_PTR dw1)
{
    // LPVIDEO_STREAM_INIT_PARMS m_VidStrmInitParms;
    // invoke the callback function, if it exists.  dwFlags contains driver-
    // specific flags in the LOWORD and generic driver flags in the HIWORD
#if 1
    // Use this cappback if we are in NT.
    if(m_bUse16BitBuddy)
         return;

    if(m_VidStrmInitParms.dwCallback) {

        if(!DriverCallback (
			             m_VidStrmInitParms.dwCallback,      // client's callback DWORD
                HIWORD(m_VidStrmInitParms.dwFlags),        // callback flags
                0, // (HANDLE) m_VidStrmInitParms.hVideo,        // handle to the device
                msg,                                       // the message
                m_VidStrmInitParms.dwCallbackInst,         // client's instance data
                dw1,                                       // first DWORD
                0)) {                                      // second DWORD not used

             DbgLog((LOG_TRACE,1,TEXT("DriverCallback() msg=%x;dw1=%p has failed."),msg,dw1));
        } else {
             DbgLog((LOG_TRACE,3,TEXT("DriverCallback() OK with time=(%d) "), timeGetTime()));
        }
    } else {
        DbgLog((LOG_TRACE,1,TEXT("m_VidStrmInitParms.dwCallback is NULL")));
    }
#else
    switch(m_VidStrmInitParms.dwFlags & CALLBACK_TYPEMASK) {

    case CALLBACK_EVENT:
        if(m_VidStrmInitParms.dwCallback){
            if(!SetEvent((HANDLE)m_VidStrmInitParms.dwCallback)){
                DbgLog((LOG_TRACE,1,TEXT("SetEvent (Handle=%x) failed with GetLastError()=%d"), m_VidStrmInitParms.dwCallback, GetLastError()));
            }
        } else {
            DbgLog((LOG_TRACE,1,TEXT("CALLBACK_EVENT but dwCallback is NULL.")));
        }
        break;

    case CALLBACK_FUNCTION:
        if(m_VidStrmInitParms.dwCallback)
            if(!DriverCallback (m_VidStrmInitParms.dwCallback,      // client's callback DWORD
                HIWORD(m_VidStrmInitParms.dwFlags),        // callback flags
                (HANDLE) m_VidStrmInitParms.hVideo,        // handle to the device
                msg,                                       // the message
                m_VidStrmInitParms.dwCallbackInst,         // client's instance data
                dw1,                                       // first DWORD
                0)) {                                      // second DWORD not used
                 DbgLog((LOG_TRACE,2,TEXT("DriverCallback() msg=%x;dw1=%p has failed."),msg,dw1));
            }
        else {
            DbgLog((LOG_TRACE,2,TEXT("m_VidStrmInitParms.dwCallback is NULL")));
        }
        break;

    case CALLBACK_TASK: // same as CALLBACK_THREAD:
        DbgLog((LOG_TRACE,1,TEXT("videoCallback: CALLBACK_TASK/THREAD not supported!")));
        break;
    case CALLBACK_WINDOW:
        DbgLog((LOG_TRACE,1,TEXT("videoCallback: CALLBACK_WINDOW not supported!")));
        break;
    default:
        DbgLog((LOG_TRACE,1,TEXT("videoCallback: CALLBACK_* dwFlags=%x not supported!"), m_VidStrmInitParms.dwFlags & CALLBACK_TYPEMASK));
    }
#endif
}




/*+++
return:
     DV_ERR_OK,
     DV_ERR_ALLOCATED
     DV_ERR_NOMEM
---*/
DWORD CVFWImage::VideoStreamInit(LPARAM lParam1, LPARAM lParam2)
{
    LPVIDEO_STREAM_INIT_PARMS lpVidStrmInitParms = (LPVIDEO_STREAM_INIT_PARMS) lParam1;
    DWORD dwSize = (DWORD) lParam2;


    m_bVideoInStarted = FALSE;

    if (!lpVidStrmInitParms) {
		      DbgLog((LOG_TRACE,1,TEXT("VideoStreamInit: lpVidStrmInitParms is NULL. return DV_ERR_INVALIDHANDLE")));
        return DV_ERR_INVALHANDLE;
    }

    //
    // Save VIDEO_STREAM_INIT_PARMS for:
    //     dwCallback
    //     dwMicroSecPerFrame
    //
    m_VidStrmInitParms = *lpVidStrmInitParms;

    // 1. Callback
    switch(m_VidStrmInitParms.dwFlags & CALLBACK_TYPEMASK) {
    case CALLBACK_FUNCTION:
        DbgLog((LOG_TRACE,1,TEXT("CALLBACK_FUNCTION")));
        if(!m_VidStrmInitParms.dwCallback) {
            DbgLog((LOG_TRACE,1,TEXT("Is it a bad pointer; rtn DV_ERR_PARAM2.")));
            return DV_ERR_PARAM2;
        }

        if (!m_VidStrmInitParms.dwCallbackInst) {
            DbgLog((LOG_TRACE,1,TEXT("dwCallBackInst is NULL; rtn DV_ERR_PARAM2.")));
            return DV_ERR_PARAM2;
        }
        break;
    case CALLBACK_WINDOW:
        DbgLog((LOG_TRACE,1,TEXT("CALLBACK_WINDOW")));
        if(!m_VidStrmInitParms.dwCallback) {
            DbgLog((LOG_TRACE,1,TEXT("Is it a bad pointer; rtn DV_ERR_PARAM2.")));
            return DV_ERR_PARAM2;
        }

        break;
    //case CALLBACK_THREAD:
    case CALLBACK_TASK:     DbgLog((LOG_TRACE,1,TEXT("CALLBACK_TASK/THREAD"))); break;
    case CALLBACK_EVENT:    DbgLog((LOG_TRACE,1,TEXT("CALLBACK_EVENT"))); break;
    default: DbgLog((LOG_TRACE,1,TEXT("CALLBACK_*=%x"), m_VidStrmInitParms.dwFlags & CALLBACK_TYPEMASK));
    }

    // 2. FrameRate:
    // The max frame rate is 100FPS or 1/100*1,000,000 = 10,000 MicroSecPerFrame.
    if(m_VidStrmInitParms.dwMicroSecPerFrame < 10000) {
        DbgLog((LOG_TRACE,1,TEXT("We do not support frame rate greater than 100FPS. Rtn DV_ERR_BADFORMAT")));
        return DV_ERR_BADFORMAT; // or DV_ERR_PARAM1
    }
    DbgLog((LOG_TRACE,1,TEXT("StreamInit: %d MicroSec which is equvalent to %d FPS."),
          m_VidStrmInitParms.dwMicroSecPerFrame, 1000000/m_VidStrmInitParms.dwMicroSecPerFrame));

    //
    // Create an dedicated thread for capture.
    //
    m_pStreamingThread =
        new CStreamingThread(
                  GetAllocatorFramingCount(),
                  GetAllocatorFramingSize(),
                  GetAllocatorFramingAlignment(),
                  m_VidStrmInitParms.dwMicroSecPerFrame * 10,
                  this);

    videoCallback(MM_DRVM_OPEN, 0L); // Notify app we're open via callback

    return DV_ERR_OK;
}




/*+++
return:
     DV_ERR_OK
     DV_ERR_NOTSUPPORTED
---*/
DWORD CVFWImage::VideoStreamStart(UINT cntVHdr, LPVIDEOHDR lpVHdrHead)
{

    DbgLog((LOG_TRACE,2,TEXT("#### CapStart %d buf; lpHdr %x"), cntVHdr, lpVHdrHead));

    if(m_pStreamingThread) {
        if (threadError == m_pStreamingThread->Start(cntVHdr, lpVHdrHead, THREAD_PRIORITY_NORMAL)) { // THREAD_PRIORITY_HIGHEST)) {
            DbgLog((LOG_TRACE,1,TEXT("$$$$$ Thread start error $$$$$; rtn DV_ERR_NONSPECIFIC")));
            return DV_ERR_NONSPECIFIC;
        }
    } else {
        DbgLog((LOG_TRACE,1,TEXT("$$$$$ Cannot create an instance of CStreamingThread $$$$$; rtn DV_ERR_NONSPECIFIC")));
        return DV_ERR_NONSPECIFIC;
    }

    m_bVideoInStarted  = TRUE;

    return DV_ERR_OK;
}

/*+++
return:
     DV_ERR_OK,
     DV_ERR_NOTSUPPORTED
---*/
DWORD CVFWImage::VideoStreamStop()
{

	   DbgLog((LOG_TRACE,1,TEXT("#### Stop capture ####")));

    m_bVideoInStarted = FALSE;

    if(m_pStreamingThread) {
        m_bVideoInStopping = TRUE; // Stop in the capture thread.
        if (threadError == m_pStreamingThread->Stop()) {
            DbgLog((LOG_TRACE,1,TEXT("$$$$$ Thread start error $$$$$; rtn DV_ERR_NONSPECIFIC")));
            return DV_ERR_NONSPECIFIC;
        }

    } else {
        DbgLog((LOG_TRACE,1,TEXT("$$$$$ Cannot create an instance of CStreamingThread $$$$$; rtn DV_ERR_NONSPECIFIC")));

        return DV_ERR_NONSPECIFIC;
    }

    return DV_ERR_OK;
}

/*+++
return:
     DV_ERR_OK,
     DV_ERR_NOTSUPPORTED
---*/
DWORD CVFWImage::VideoStreamReset()
{
    VideoStreamStop();

    // No knowledge of BufferQueue!!

    return DV_ERR_OK;
}

/*+++
return:
     DV_ERR_OK,
     DV_ERR_NOTSUPPORTED
---*/
DWORD CVFWImage::VideoStreamGetError(LPARAM lParam1, LPARAM lParam2)
{
    DWORD * pdwErrCode = (DWORD *) lParam1;
    DWORD * pdwFramesDropped = (DWORD *) lParam2;



    if(m_pStreamingThread) {
        // Calculate the number of frame "should have" captured
        // less the actual capture to yield number of dropped frame count
#if 1
        *pdwFramesDropped =
            (timeGetTime()-m_pStreamingThread->GetStartTime())*10/this->GetCachedAvgTimePerFrame()
            - m_pStreamingThread->GetFrameCaptured();
#else
        KSPROPERTY_DROPPEDFRAMES_CURRENT_S DroppedFramesCurrent;
        if(GetStreamDroppedFramesStastics(&DroppedFramesCurrent)) {
            *pdwFramesDropped = (DWORD) DroppedFramesCurrent.DropCount;
        } else {
            *pdwFramesDropped = 0;
            return DV_ERR_NOTSUPPORTED;
        }
#endif

        *pdwErrCode = m_pStreamingThread->GetLastCaptureError();
    } else {
        return DV_ERR_NOTSUPPORTED;
    }

    return DV_ERR_OK;
}

/*+++
return:
     DV_ERR_OK,
     DV_ERR_NOTSUPPORTED
---*/
DWORD CVFWImage::VideoStreamGetPos(LPARAM lParam1, LPARAM lParam2)
{
    LPMMTIME lpmmTime = (LPMMTIME) lParam1;
    DWORD dwSize = (DWORD) lParam2;

    if(m_pStreamingThread) {

    } else {

    }

    return DV_ERR_NOTSUPPORTED;
}

/*+++
return:
     DV_ERR_OK,
     DV_ERR_STILLPLAYING
---*/
DWORD CVFWImage::VideoStreamFini()
{

    if(m_pStreamingThread) {
        delete m_pStreamingThread;
        m_pStreamingThread=NULL;
    }

    videoCallback(MM_DRVM_CLOSE, 0);

    return DV_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\videoin.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    VideoIn.cpp

Abstract:

    header file for Videoin.cpp

Author:

    FelixA 1996
    
     
Modified:
    
    Yee J. Wu (ezuwu) 15-October-97

Environment:

    User mode only

Revision History:

--*/


#ifndef VIDEOIN_H
#define VIDEOIN_H

#include "resource.h"

#include "sheet.h"
#include "page.h"
#include "vfwimg.h"
#include "imgsize.h"


DWORD 
DoVideoInFormatSelectionDlg(
    HINSTANCE hInst, 
    HWND hWndParent, 
    CVFWImage * pVFWImage);
//
// A sheet holds the pages relating to the image device.
//
class CVideoInSheet: public CSheet
{
    CVFWImage * m_pImage;   // the sheets get info about the driver from the Image class.

public:
    CVideoInSheet(CVFWImage * pImage, HINSTANCE hInst, UINT iTitle=0, HWND hParent=NULL)
       : m_pImage(pImage), CSheet( hInst,iTitle,hParent) {}
    CVFWImage * GetImage() { return m_pImage; }
};


// ---------------------------------
// I m a g e   F o r m a t   P a g e 
//----------------------------------

class CImageSelPage : public CPropPage
{

   PSTD_IMAGEFORMAT m_pTblImageFormat;
   ULONG m_cntSizeSupported;

   // Currently selected image format
   LONG  m_biWidthSel;
   LONG  m_biHeightSel;
   DWORD m_biCompressionSel;
   WORD  m_biBitCountSel;

public:
   // Virtual functions (overload here)
   int   SetActive();
   int   DoCommand(WORD wCmdID,WORD hHow);
   int   Apply();

   CImageSelPage(
      int   DlgId,
      PBITMAPINFOHEADER pbiHdr,
      ULONG cntDRVideo,

      PKS_DATARANGE_VIDEO  pDRVideo,

      CVFWImage   * VFWImage,
      ULONG * pcntSizeSuppported);

   ~CImageSelPage();

   BOOL IsDataReady();
   ULONG CreateStdImageFormatTable(ULONG cntDRVideo, PKS_DATARANGE_VIDEO pDRVideo); 
   BOOL IsSupportedDRVideo(PSIZE pSize, KS_VIDEO_STREAM_CONFIG_CAPS * pCfgCaps);
   BOOL FillImageFormatData(PSTD_IMAGEFORMAT pImageFormat);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\videoin.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    VideoFmt.cpp

Abstract:

    Deals with the video format of the deivce
        Data format (compression)
        Color plane (bits/PEXEL)
        Image size

Author:

    Yee J. Wu (ezuwu) 24-October-97

Environment:

    User mode only

Revision History:

--*/


#include "pch.h"

//#include <winreg.h>
//#include <winnt.h>
//#include <wingdi.h>
#include "clsdrv.h"
#include "imgcls.h"
#include "videoin.h"


// Get PBITMAPINFOHEADER from PKS_DATARANGE_VIDEO
#define PBIHDR(A)        (&(A->VideoInfoHeader.bmiHeader))
#define BIWIDTH(A)        (A->VideoInfoHeader.bmiHeader.biWidth)
#define BIHEIGHT(A)        (A->VideoInfoHeader.bmiHeader.biHeight)
#define BISIZEIMAGE(A)    (A->VideoInfoHeader.bmiHeader.biSizeImage)
#define BIBITCOUNT(A)    (A->VideoInfoHeader.bmiHeader.biBitCount)
#define BICOMPRESSION(A)    (A->VideoInfoHeader.bmiHeader.biCompression)
#define AVGTIMEPERFRAME(A)    (A->VideoInfoHeader.AvgTimePerFrame)
#define VIDEOSTANDARD(A)    (A->ConfigCaps.VideoStandard)

// Get PKS_VIDEO_STREAM_CONFIG_CAPS from PKS_DATARANGE_VIDEO
#define CFGCAPS(A)            (&(A->ConfigCaps))
#define CAPSMINFRAME(A)        (A->ConfigCaps.MinFrameInterval)
#define CAPSMAXFRAME(A)        (A->ConfigCaps.MaxFrameInterval)
#define CAPSMINOUTPUT(A)    (A->ConfigCaps.MinOutputSize)
#define CAPSMAXOUTPUT(A)    (A->ConfigCaps.MaxOutputSize)


DWORD DoVideoInFormatSelectionDlg(
    HINSTANCE hInst,
    HWND hWndParent,
    CVFWImage * pVFWImage)
/*++
Routine Description:

Argument:

Return Value:

--*/
{

    PKSMULTIPLE_ITEM pMultItemsHdr = pVFWImage->GetDriverSupportedDataRanges();

    ASSERT(pMultItemsHdr != NULL);
    if (pMultItemsHdr == 0) {
        DbgLog((LOG_TRACE,1,TEXT("No available data range to support this device.")));
        return DV_ERR_OK;
    }

    ASSERT(pMultItemsHdr->Count > 0);
    ASSERT(pMultItemsHdr->Size >= (sizeof(ULONG) * 2 + pMultItemsHdr->Count * sizeof(KS_DATARANGE_VIDEO)) );
    if (pMultItemsHdr->Count == 0) {
        DbgLog((LOG_TRACE,1,TEXT("pMultItemsHdr=0x%x, Size %d, Count %d"), pMultItemsHdr, pMultItemsHdr->Size, pMultItemsHdr->Count));
        return DV_ERR_OK;
    }


    CVideoInSheet Sheet(pVFWImage, hInst,IDS_VIDEOIN_HEADING, hWndParent);

    //
    // Image format selection page.
    //
    // To do : Query number of default image sizes supported
    //         if > 0, add page.
    //
    ULONG cntSizeSupported;
    CImageSelPage pImageSelPage(
                    IDD_IMGFORMAT_PAGE,
                    pVFWImage->GetCachedBitmapInfoHeader(),
                    pMultItemsHdr->Count,
                    (PKS_DATARANGE_VIDEO) (pMultItemsHdr+1),
                    pVFWImage,
                    &cntSizeSupported);

    if (cntSizeSupported == 0) {
        DbgLog((LOG_TRACE,1,TEXT("None of the standard size is supported by this device.")));
        return DV_ERR_OK;
    }

    Sheet.AddPage(pImageSelPage);

    if ( Sheet.Do() == IDOK ) {
        //
        // The apply will have been called on each page, so I don't think there
        // is much I need to do here.
        //
    }


    return DV_ERR_OK;
}

CImageSelPage::CImageSelPage(
    int                     DlgId,
    PBITMAPINFOHEADER    pbiHdr,
    ULONG                   cntDRVideo,
    PKS_DATARANGE_VIDEO     pDRVideo,
    CVFWImage               *pVFWImage,
    ULONG                   *pcntSizeSuppported)
    : CPropPage(DlgId),
      m_pTblImageFormat(0),
      m_cntSizeSupported(0)
{
    // Cache current image input format
    m_biWidthSel        = pbiHdr->biWidth;
    m_biHeightSel       = abs(pbiHdr->biHeight);
    m_biCompressionSel  = pbiHdr->biCompression;
    m_biBitCountSel     = pbiHdr->biBitCount;


    m_cntSizeSupported = CreateStdImageFormatTable(cntDRVideo, pDRVideo);
    *pcntSizeSuppported = m_cntSizeSupported;
}


CImageSelPage::~CImageSelPage()
{
    // Release memory.
    LONG i;

    if (m_pTblImageFormat) {
        for (i=0; i < cntStdImageFormat; i++) {
            if (m_pTblImageFormat[i].ppDRVideo)
                delete [] (m_pTblImageFormat[i].ppDRVideo);
        }

        delete [] m_pTblImageFormat;
        m_pTblImageFormat = 0;
    }
}

ULONG CImageSelPage::CreateStdImageFormatTable(
    ULONG                cntDRVideo,
    PKS_DATARANGE_VIDEO    pDRVideo)
/*++
Routine Description:

    Based a out supportd stand image sizes, we query device's data range and flags
    each entry.

Argument:

Return Value:

    Return number of image size supported

--*/
{
    ULONG i, j, cntValidSize = 0;


    if (cntDRVideo == 0 ||
        pDRVideo == NULL)
        return 0;

    m_pTblImageFormat = (PSTD_IMAGEFORMAT) new STD_IMAGEFORMAT[cntStdImageFormat];

    if (m_pTblImageFormat != NULL) {

        ZeroMemory(m_pTblImageFormat, sizeof(STD_IMAGEFORMAT) * (cntStdImageFormat));
        CopyMemory(m_pTblImageFormat, &tblStdImageFormat[0], sizeof(STD_IMAGEFORMAT) * cntStdImageFormat);

    } else {

        DbgLog((LOG_TRACE,1,TEXT("@@Allocate memory for the ImageSizeArray failed!")));
        return 0;
    }

    for (i = 0 ; i < cntStdImageFormat; i++) {

        // Pointer to an array of PKS_DATARANGE_VIDEO
        m_pTblImageFormat[i].ppDRVideo = (PKS_DATARANGE_VIDEO *) new PKS_DATARANGE_VIDEO [cntDRVideo];
        if (!m_pTblImageFormat[i].ppDRVideo) {

            // Release resource and reset the pointers.
            for (j = 0; j < i; i++) {
                if (m_pTblImageFormat[j].ppDRVideo) {
                    delete[] (m_pTblImageFormat[j].ppDRVideo);
                    m_pTblImageFormat[j].ppDRVideo = 0;
                }
            }

            delete [] m_pTblImageFormat;
            m_pTblImageFormat = 0;

            return 0;
        }
    }


    //
    // Return number of image size supported
    //
    PKS_DATARANGE_VIDEO pDRVideoTmp;

    for (i = 0; i < cntStdImageFormat; i++) {

        pDRVideoTmp = pDRVideo;
        for (j = 0; j < cntDRVideo; j++) {

            //
            // Filter out format with BI_BITFIELD and if a color table is needed.
            // RGB555 is supported.
            //
            if((pDRVideoTmp->VideoInfoHeader.bmiHeader.biCompression == KS_BI_RGB ||
                pDRVideoTmp->VideoInfoHeader.bmiHeader.biCompression >  0xff) &&       // For other FourCC, like YUV*
               pDRVideoTmp->VideoInfoHeader.bmiHeader.biClrUsed     == 0    
                ) {

                if (IsSupportedDRVideo(
                    &(m_pTblImageFormat[i].size),
                    &(pDRVideoTmp->ConfigCaps))) {

                    m_pTblImageFormat[i].ppDRVideo[m_pTblImageFormat[i].cntDRVideo] = pDRVideoTmp;
                    m_pTblImageFormat[i].cntDRVideo++;
                }
            }

            // Data rangte is variable size (->FormatSize)
            // Note: KSDATARANGE is LONGLONG (16 bytes) aligned
            pDRVideoTmp = (PKS_DATARANGE_VIDEO) ( (PBYTE) pDRVideoTmp + 
                 ((pDRVideoTmp->DataRange.FormatSize + 7) & ~7)   );
        }

        if (m_pTblImageFormat[i].cntDRVideo == 0) {
            // This is not supported.
        } else
            cntValidSize++;
    }

    return cntValidSize;
}


BOOL CImageSelPage::IsSupportedDRVideo(
    PSIZE                            pSize,
    KS_VIDEO_STREAM_CONFIG_CAPS        *pCfgCaps)
/*++
Routine Description:

    Based a out supportd stand image sizes, we query device's data range and flags
    each entry.

Argument:

Return Value:

    Return number of image size supported

--*/
{

    if (pCfgCaps->OutputGranularityX == 0 || pCfgCaps->OutputGranularityY == 0) {

        // Support only one size for this DataRangeVideo
        if (pCfgCaps->InputSize.cx == pSize->cx &&
            pCfgCaps->InputSize.cy == pSize->cy )

            return TRUE;
        else
            return FALSE;
    } else {

        // Support multiple sizes so make sure that that fit the criteria
        if (pCfgCaps->MinOutputSize.cx <= pSize->cx &&
            pSize->cx <= pCfgCaps->MaxOutputSize.cx &&
            pCfgCaps->MinOutputSize.cy <= pSize->cy &&
            pSize->cy <= pCfgCaps->MaxOutputSize.cy &&
            ((pSize->cx % pCfgCaps->OutputGranularityX) == 0) &&
            ((pSize->cy % pCfgCaps->OutputGranularityY) == 0))

            return TRUE;
        else
            return FALSE;
    }

}


int CImageSelPage::SetActive()
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    if( GetInit() )
        return 0;

    if (!IsDataReady())
        return 0;

    //
    // The formats are derived from the device itself. we just provide default
    //
    CVideoInSheet * pS = (CVideoInSheet*)GetSheet();

    if (!pS) {
        DbgLog((LOG_TRACE,1,TEXT("Cannot GetSheet() in CImageFormatPage constructor.  This page will have no response.")));
        return 1;
    }


    ULONG i;
    INT_PTR idxRtn;
    int idxSelSize=0, idxCurSize=0, cntValidSize=0;
    TCHAR szAddString[MAX_PATH];
    HWND hWndSize      = GetDlgItem(IDC_CMB_IMAGESIZE);

    ShowText (IDS_TXT_WIDTH_HEIGHT,      IDC_TXT_WIDTH_HEIGHT,      TRUE);
    ShowText (IDS_TXT_FORMAT_SELECTIONS, IDC_TXT_FORMAT_SELECTIONS, TRUE);
    ShowText (IDS_TXT_COMPRESSION,       IDC_TXT_COMPRESSION,       TRUE);
    ShowText (IDS_TXT_IMAGESIZE,         IDC_TXT_IMAGESIZE,         TRUE);

#ifndef _DEBUG
    ShowWindow(GetDlgItem(IDC_STATIC_ANALOGFORMAT), FALSE);
    ShowWindow(GetDlgItem(IDC_EDT_ANALOGFORMAT), FALSE);

    ShowWindow(GetDlgItem(IDC_STATIC_FRAMERATE), FALSE);
    ShowWindow(GetDlgItem(IDC_EDT_FRAMERATE), FALSE);
#endif

    for (i = 0; i < cntStdImageFormat; i++) {

        if (m_pTblImageFormat[i].cntDRVideo > 0) {

            if (m_biWidthSel  == m_pTblImageFormat[i].size.cx &&
                m_biHeightSel == m_pTblImageFormat[i].size.cy ) {
                idxCurSize = cntValidSize;
                idxSelSize = i;
            }

            cntValidSize++;

            wsprintf((LPTSTR)szAddString, TEXT("%d x %d"), m_pTblImageFormat[i].size.cx, m_pTblImageFormat[i].size.cy);
            idxRtn = SendMessage(hWndSize, CB_ADDSTRING, 0, (LPARAM)szAddString);

            if (idxRtn == CB_ERR) {

                DbgLog((LOG_TRACE,1,TEXT("Unable to CB_ADDSTRING ! Break...")));
                break;
            } else {

                if (SendMessage(hWndSize, CB_SETITEMDATA, idxRtn, (LPARAM) &(m_pTblImageFormat[i]))
                    == CB_ERR) {
                    DbgLog((LOG_TRACE,1,TEXT("CB_SETITEMDATA (idxRtn=%d, &(m_pTblImageFormat[i])=0x%x)) has failed! Break.."), idxRtn, &(m_pTblImageFormat[i])));
                    break;
                }
            }

        }
    }

    // Set current selection
    if (SendMessage (hWndSize, CB_SETCURSEL, idxCurSize, 0) == CB_ERR) {
        DbgLog((LOG_TRACE,1,TEXT("Unable to CB_SETCURSEL for hWdnFormat! ")));
    }

    // Fill biCompression, biCitCount and biSizeImage information
    FillImageFormatData(&m_pTblImageFormat[idxSelSize]);

    return 1;
}


BOOL CImageSelPage::FillImageFormatData(
    PSTD_IMAGEFORMAT pImageFormat)
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    if (!pImageFormat)
        return FALSE;

    PKS_DATARANGE_VIDEO *ppDRVideo = pImageFormat->ppDRVideo;


    if ( pImageFormat->cntDRVideo == 0 ||
         !ppDRVideo)
        return TRUE;

    ULONG i, k, cntSubtype;
    INT_PTR idxRtn;
    int idxSelFormat=0;
    HWND hWndFormat  = GetDlgItem(IDC_CMB_COMPRESSION);
    HWND hWndImageSize  = GetDlgItem(IDC_EDT_IMAGESIZE);

    // Use DShow routine to convert a subtype (GUID) to a user understandable text
    TCHAR  *DShowName;
    TCHAR  buf[5];
    GUID * pguidSubType;

    //
    // Display the Compression (FourCC + Color Plane)
    // Save the corresponding PKS_DATARANGE_VIDEO in the CB_SETITEMDATA
    // Display the ImageSize (This is useful for compressed data).
    //
    SendMessage (hWndFormat, CB_RESETCONTENT, 0, 0);

    for (i = cntSubtype = 0; i < pImageFormat->cntDRVideo; i++) {

        // Eliminate duplicates
        for(k = 0; k < i; k++) {
            if (IsEqualGUID (ppDRVideo[i]->DataRange.SubFormat, ppDRVideo[k]->DataRange.SubFormat)) {
                goto NextSubType;
            }
        }

        if (m_biCompressionSel == BICOMPRESSION(ppDRVideo[i]) &&
            m_biBitCountSel == BIBITCOUNT(ppDRVideo[i]) )
            idxSelFormat = cntSubtype; //i;

        cntSubtype++;

        pguidSubType = &ppDRVideo[i]->DataRange.SubFormat;

        DShowName = GetSubtypeName(pguidSubType);

        // Hack alert.  GetSubtypeName returns "UNKNOWN" if it isn't among the hardcoded
        // list of known RGB formats.  If this string ever changes, we're hosed!

        if(0 == _tcscmp (DShowName, TEXT ("UNKNOWN"))) {
                wsprintf (buf, TEXT("%c%c%c%c"),
                          (BYTE) ( pguidSubType->Data1        & 0xff),
                          (BYTE) ((pguidSubType->Data1 >> 8)  & 0xff),
                          (BYTE) ((pguidSubType->Data1 >> 16) & 0xff),
                          (BYTE) ((pguidSubType->Data1 >> 24) & 0xff)
                          );
            idxRtn = SendMessage(hWndFormat, CB_ADDSTRING, 0, (LPARAM) buf);

        } else {
            idxRtn = SendMessage(hWndFormat, CB_ADDSTRING, 0, (LPARAM) DShowName);

        }

        if (SendMessage(hWndFormat, CB_SETITEMDATA, idxRtn, (LPARAM) ppDRVideo[i]) == CB_ERR) {
            DbgLog((LOG_TRACE,1,TEXT("CB_SETITEMDATA (idxRtn=%d, ppDRVideo[i]=0x%x)) has failed! Break.."), idxRtn, ppDRVideo[i]));
            break;
        }
NextSubType:
        ;
    }

    // Size of this digital image
    SetTextValue(hWndImageSize, pImageFormat->size.cx * pImageFormat->size.cy * BIBITCOUNT(ppDRVideo[idxSelFormat]) / 8);

    // Set current selection
    if (SendMessage (hWndFormat, CB_SETCURSEL, idxSelFormat, 0) == CB_ERR) {
        DbgLog((LOG_TRACE,1,TEXT("Unable to CB_SETCURSEL for hWdnFormat! ")));
    }

#ifdef _DEBUG
    TCHAR szAddString[MAX_PATH];
    LONG lFrameRate = 0;

    if (AVGTIMEPERFRAME(ppDRVideo[idxSelFormat]) > 0)
        lFrameRate = (LONG) (((double) 10000000/ (double) AVGTIMEPERFRAME(ppDRVideo[idxSelFormat])) + 0.49);
    SetTextValue(GetDlgItem(IDC_EDT_FRAMERATE), lFrameRate);

    ZeroMemory(szAddString, sizeof(szAddString));
    if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) == KS_AnalogVideo_None)
        LoadString(GetInstance(), IDS_ANALOGVIDEO_NONE, szAddString, sizeof(szAddString)-1);
    else {
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_NTSC_M)
            wsprintf((LPTSTR)szAddString, TEXT("%s NTSC_M;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_NTSC_M_J)
            wsprintf((LPTSTR)szAddString, TEXT("%s NTSC_M_J;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_NTSC_433)
            wsprintf((LPTSTR)szAddString, TEXT("%s NTSC_433;"), szAddString);

        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_B)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_B;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_D)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_D;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_G)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_G;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_H)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_H;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_I)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_I;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_M)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_M;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_N)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_N;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_PAL_60)
            wsprintf((LPTSTR)szAddString, TEXT("%s PAL_60;"), szAddString);

        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_SECAM_B)
            wsprintf((LPTSTR)szAddString, TEXT("%s SECAM_B;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_SECAM_D)
            wsprintf((LPTSTR)szAddString, TEXT("%s SECAM_D;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_SECAM_G)
            wsprintf((LPTSTR)szAddString, TEXT("%s SECAM_G;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_SECAM_K)
            wsprintf((LPTSTR)szAddString, TEXT("%s SECAM_K;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_SECAM_K1)
            wsprintf((LPTSTR)szAddString, TEXT("%s SECAM_K1;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_SECAM_L)
            wsprintf((LPTSTR)szAddString, TEXT("%s SECAM_L;"), szAddString);
        if (VIDEOSTANDARD(ppDRVideo[idxSelFormat]) & KS_AnalogVideo_SECAM_L1)
            wsprintf((LPTSTR)szAddString, TEXT("%s SECAM_L1;"), szAddString);

        if (szAddString[0] == 0)
            wsprintf((LPTSTR)szAddString, TEXT("KS_AnalogVideoStandard: 0x%8.8x"), VIDEOSTANDARD(ppDRVideo[idxSelFormat]));
    }

    SetWindowText(GetDlgItem(IDC_EDT_ANALOGFORMAT), szAddString);
#endif

    return TRUE;
}


int CImageSelPage::DoCommand(
    WORD wCmdID,
    WORD hHow)
/*++
Routine Description:

Argument:

Return Value:

--*/
{

    if( !CPropPage::DoCommand(wCmdID,hHow) )
        return 0;

    if (!IsDataReady())
        return 1;

    switch (wCmdID) {
    case IDC_CMB_COMPRESSION:
        if (hHow == CBN_SELCHANGE ) {

            HWND hWndSize   = GetDlgItem(IDC_CMB_IMAGESIZE);
            INT_PTR idxSize = SendMessage( hWndSize, CB_GETCURSEL, 0, 0);
            PSTD_IMAGEFORMAT pImageFormat = (PSTD_IMAGEFORMAT) SendMessage(hWndSize, CB_GETITEMDATA, idxSize, 0 );

            HWND hWndFormat = GetDlgItem(wCmdID);
            INT_PTR idxFormat = SendMessage( hWndFormat, CB_GETCURSEL, 0, 0);
            PKS_DATARANGE_VIDEO pDRVideo = (PKS_DATARANGE_VIDEO) SendMessage(hWndFormat, CB_GETITEMDATA, idxFormat, 0 );

            // Update current biCompression and biBitCount
            if (pDRVideo && pImageFormat) {
                SetTextValue(
                    GetDlgItem(IDC_EDT_IMAGESIZE),
                    pImageFormat->size.cx *  pImageFormat->size.cy * BIBITCOUNT(pDRVideo) / 8);

                m_biCompressionSel = BICOMPRESSION(pDRVideo);
                m_biBitCountSel    = BIBITCOUNT(pDRVideo);;
            }
        }
        break;

    case IDC_CMB_IMAGESIZE:
        if (hHow == CBN_SELCHANGE ) {
            INT_PTR idxSize;

            HWND hWndSize = GetDlgItem(wCmdID);
            idxSize = SendMessage( hWndSize, CB_GETCURSEL, 0, 0);
            PSTD_IMAGEFORMAT pImageFormat = (PSTD_IMAGEFORMAT) SendMessage(hWndSize, CB_GETITEMDATA, idxSize, 0 );

            FillImageFormatData(pImageFormat);
        }
        break;

    default:
        DbgLog((LOG_TRACE,3,TEXT("Unknown command in CImageFormatPage (wCmdID=%d (0x%x))."), wCmdID, wCmdID));
        break;
    }

    return 1;
}

int CImageSelPage::Apply()
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    if (!IsDataReady())
        return 1;

    HWND hWndSize   = GetDlgItem(IDC_CMB_IMAGESIZE);
    HWND hWndFormat = GetDlgItem(IDC_CMB_COMPRESSION);

    INT_PTR idxSize = SendMessage( hWndSize, CB_GETCURSEL, 0, 0);
    PSTD_IMAGEFORMAT pImageFormat = (PSTD_IMAGEFORMAT) SendMessage(hWndSize, CB_GETITEMDATA, idxSize, 0 );

    INT_PTR idxFormat = SendMessage( hWndFormat, CB_GETCURSEL, 0, 0);
    PKS_DATARANGE_VIDEO pDRVideo = (PKS_DATARANGE_VIDEO) SendMessage(hWndFormat, CB_GETITEMDATA, idxFormat, 0 );

    ASSERT(pDRVideo != 0);
    if (!pDRVideo) {
        DbgLog((LOG_TRACE,1,TEXT("In Apply that pDRVideo is 0 from the selection !!")));
        return 0;
    }

    CVideoInSheet * pS = (CVideoInSheet*)GetSheet();
    if (pS) {


        PBITMAPINFOHEADER pbiHdr;

        CVFWImage * pVFWImage = pS->GetImage();
        if(!pVFWImage)
            return 0;

        pbiHdr = (PBITMAPINFOHEADER)
             VirtualAlloc(
                NULL, 
                sizeof(BITMAPINFOHEADER),          
                MEM_COMMIT | MEM_RESERVE,
                PAGE_READWRITE);

        if(pbiHdr) {
            ZeroMemory(pbiHdr, sizeof(BITMAPINFOHEADER));
        } else {
            DbgLog((LOG_ERROR,0,TEXT("Allocate memory failed; size %d\n"), sizeof(BITMAPINFOHEADER)));
            return 0;
        }
     

        //
        // It is possible a GRAB_FRAME can come and "admitted"
        // while changing format is taking place.
        // So let's stop here now (instead of in the DestroyPin();
        //
        pVFWImage->NotifyReconnectionStarting();

        // Put the pregview graph in STOP state and then
        // destroy its capture pin next
        if(pVFWImage->BGf_PreviewGraphBuilt()) {
            if(pVFWImage->BGf_OverlayMixerSupported()) {
                BOOL bRendererVisible = FALSE;
                pVFWImage->BGf_GetVisible(&bRendererVisible);
                if(pVFWImage->BGf_StopPreview(bRendererVisible)) {
                    DbgLog((LOG_TRACE,1,TEXT("PreviewGraph stopped")));
                } else {
                    DbgLog((LOG_TRACE,1,TEXT("FAILED to stop preview graph.")));
                }
            }
        }

        // Destroy this pin and recreate it when SetBitmapInfo is call.
        // STOP the capture pin streaming state to STOP as well.
        pVFWImage->DestroyPin();  // Will stop the pin before it is destroyed (disconnected).

        CopyMemory(pbiHdr, PBIHDR(pDRVideo), sizeof(BITMAPINFOHEADER));

        pbiHdr->biWidth  = pImageFormat->size.cx;
        pbiHdr->biHeight = pImageFormat->size.cy;
        // This is the biggest size required.
        // For comptressed data, this is bigger than necessary!!
        pbiHdr->biSizeImage = pbiHdr->biWidth * abs(pbiHdr->biHeight) * pbiHdr->biBitCount / 8;

        // Cache the image information and will be used to create pin
        // when SetBitMapInfo() is called.
        // Note:  The BiSizeImage is used to compare the capture buffer size
        pVFWImage->CacheDataFormat(&pDRVideo->DataRange);
        pVFWImage->CacheBitmapInfoHeader(pbiHdr);

        pVFWImage->LogFormatChanged(TRUE);

        // Change now since VfWWDM32.dll allocate buffer not VfWWDM.drv.
        pVFWImage->SetBitmapInfo(
                    pbiHdr,
                    pVFWImage->GetCachedAvgTimePerFrame());


        VirtualFree(pbiHdr, 0, MEM_RELEASE);
        pbiHdr = 0;
    }

    return 1;
}


BOOL CImageSelPage::IsDataReady()
/*++
Routine Description:

Argument:

Return Value:

--*/
{
    if (m_pTblImageFormat && m_cntSizeSupported > 0)
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\vmsg.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    vmsg.cpp

Abstract:

    This really is a C file and is the front end to all DVM_* messages

Author:

    Yee J. Wu (ezuwu) 1-April-98

Environment:

    User mode only

Revision History:

--*/



#include "pch.h"
#include "talk.h"

DWORD DoExternalInDlg(HINSTANCE hInst,HWND hP,CVFWImage * pImage);
DWORD DoVideoInFormatSelectionDlg(HINSTANCE hInst, HWND hP, CVFWImage * pVFWImage);


/**************************************************************************
 *
 *   vmsg.c
 *
 *   Video Message Processing
 *
 *   Microsoft Video for Windows Sample Capture Driver
 *   Chips & Technologies 9001 based frame grabbers.
 *
 *   Copyright (c) 1992-1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

extern HINSTANCE g_hInst;


#define MAX_IN_CHANNELS      10
#define MAX_CAPTURE_CHANNELS 10
#define MAX_DISPLAY_CHANNELS 10


//
// ??? Global ????
//
WORD gwDriverUsage    = 0;
WORD gwVidInUsage     = 0;
WORD gwVidExtInUsage  = 0;
WORD gwVidExtOutUsage = 0;
WORD gwVidOutUage     = 0;


RECT grcDestExtIn;
RECT grcSourceIn;


#if 1
/*
 Since all VFW channel deal with the same device and know that
 DRV_OPEN is called in the expected order; we will call the
 32bit buddy to Open and Create the pin and save it as
 part of the CHANNEL structure; so that any channel can refer to it.

 But how do we synchronizing them ?????
 There seem to have some "expected behaviour" so there might not be a problem;
 we may need to tune it for a disaster/unexpected cases (shutdown,...etc).

 Using Avicap32.dll:
     DRV_OPEN (in this order)
         VIDEO_IN
         VIDEO_EXTERNALIN
         VIDEO_EXTERNALOUT

     DRV_CLOSE
         VIDEO_EXTERNALOUT
         VIDEO_EXTERNALIN
         VIDEO_IN

*/
DWORD_PTR g_pContext;  // It is a pointer to a context; its onctent should never be used in the 16bit.
DWORD g_dwOpenFlags;
LPVOID g_pdwOpenFlags = (LPVOID)&g_dwOpenFlags;
#define OPENFLAG_SUPPORT_OVERLAY  0x01

PBITMAPINFOHEADER g_lpbmiHdr;

BOOL g_bVidInChannel= FALSE, g_bVidExtInChannel=FALSE, g_bVidExtOutChannel=FALSE;

LONG * g_pdwChannel;

#endif  // #ifndef WIN32





#ifdef WIN32
extern "C" {
#endif
/////////////////////////////////`////////////////////////////////////////////////////
//
// DRV_OPEN
// this currently does some H/W stuff
// and correctly calls off to ray to instatiate a context
// 32 bit guys supports only one at a time?
//
/////////////////////////////////////////////////////////////////////////////////////
PCHANNEL PASCAL VideoOpen( LPVIDEO_OPEN_PARMS lpOpenParms)
{
    PCHANNEL pChannel;
    LPDWORD	lpdwError = &lpOpenParms->dwError;
    DWORD		dwFlags = lpOpenParms->dwFlags;
	   DWORD		dwError;
    DWORD  dwChannel;
    //
    //  if this is the very first open then init the hardware.
    //
    *lpdwError = DV_ERR_OK;
	   dwError = DV_ERR_ALLOCATED;

    dwChannel = dwFlags & ( VIDEO_EXTERNALIN | VIDEO_IN | VIDEO_OUT | VIDEO_EXTERNALOUT);

    switch (dwChannel) {
    case VIDEO_IN:
         // If that channel is already open, assume it want to open another device.
         if(g_bVidInChannel) {
            g_pContext = 0;
            g_lpbmiHdr = 0;
            g_bVidInChannel = g_bVidExtInChannel = g_bVidExtOutChannel=FALSE;
         }
         break;
    case VIDEO_EXTERNALIN:
         // If that channel is already open, assume it want to open another device.
         if(g_bVidExtInChannel) {
            g_pContext = 0;
            g_lpbmiHdr = 0;
            g_bVidInChannel = g_bVidExtInChannel = g_bVidExtOutChannel=FALSE;
         }
         break;
    case VIDEO_EXTERNALOUT:
#if 1
         // If that channel is already open, assume it want to open another device.
         if(g_bVidExtOutChannel) {
            g_pContext = 0;
            g_lpbmiHdr = 0;
            g_bVidInChannel = g_bVidExtInChannel = g_bVidExtOutChannel=FALSE;
         }
         break;
#else
         DbgLog((LOG_TRACE,1,TEXT("Unsupported Channel type: 0x%x"), dwChannel));
         *lpdwError = DV_ERR_NOTDETECTED;
         return NULL;
#endif
    case VIDEO_OUT:
    default:
        DbgLog((LOG_TRACE,1,TEXT("Unsupported Channel type: 0x%x"), dwChannel));
        *lpdwError = DV_ERR_NOTDETECTED;
        return NULL;
    }

	//
    // get instance memory - this pointer returned to the client
	// contains useful information.
    //
	pChannel = (PCHANNEL) VirtualAlloc (NULL, sizeof(CHANNEL), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);


    if(pChannel == NULL) {
        *lpdwError = DV_ERR_NOMEM;
        DbgLog((LOG_TRACE,1,TEXT("pChannel=NULL, rtn DV_ERR_NOMEM"), pChannel));
        return (PCHANNEL) NULL;
    } else {
        DbgLog((LOG_TRACE,2,TEXT("pChannel=%lx"), pChannel));
    }

    //
    //  now that the hardware is allocated init our instance struct.
    //
    ZeroMemory(pChannel, sizeof(CHANNEL));
    pChannel->dwSize      = (DWORD) sizeof(CHANNEL);
    pChannel->pCVfWImage  = 0;

    pChannel->fccType		   = OPEN_TYPE_VCAP;
    pChannel->dwOpenType	 = dwChannel;
    pChannel->dwOpenFlags = dwFlags;
    pChannel->dwError		   = 0L;
    pChannel->lpbmiHdr    = 0;

    pChannel->bRel_Sync    = TRUE;
    pChannel->msg_Sync     = 0;
    pChannel->lParam1_Sync = 0;
    pChannel->lParam2_Sync = 0;

    pChannel->bRel_Async    = TRUE;
    pChannel->msg_Async     = 0;
    pChannel->lParam1_Async = 0;
    pChannel->lParam2_Async = 0;

    pChannel->bVideoOpen    = FALSE;
    pChannel->dwState = KSSTATE_STOP;

    // AVICAp has a predicatable open sequence, but non-AVICAp may not!
    if(!g_pContext) {

        // Allocate a common memory to save number of channel open for a device.
        // Not unitl this count is zero, the device is not closed.
	    g_pdwChannel = (LONG *) VirtualAlloc (NULL, sizeof(LONG), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if(g_pdwChannel == NULL) {
            dwError = DV_ERR_NOMEM;
            DbgLog((LOG_TRACE,1,TEXT("Cannot not allocate a g_pdwChannel structure.  Fatal!!")));
            goto error;
        }

        // Initialize it.
        *g_pdwChannel = 0;

        // All channels share the same bmiHdr
        // Accept BITFIELD format, which append three DWORD (RGB mask) after BITMAPINFOHEADER
        g_lpbmiHdr = (PBITMAPINFOHEADER) 
            VirtualAlloc(
                NULL, 
                sizeof(BITMAPINFOHEADER) + sizeof(DWORD) * BITFIELDS_RGB16_DWORD_COUNT, 
                MEM_COMMIT | MEM_RESERVE, 
                PAGE_READWRITE);

        if(g_lpbmiHdr == NULL) {
            VirtualFree(g_pdwChannel, 0 , MEM_RELEASE);
            g_pdwChannel = 0;

            dwError = DV_ERR_NOMEM;
            DbgLog((LOG_TRACE,1,TEXT("Cannot not allocate bmiHdr structure.  Fatal!!")));
            goto error;
        }


        g_pContext = (DWORD_PTR) new CVFWImage(FALSE);  // Not using 16bit buddy;i.e. 32bit only.

        if(!g_pContext) {
            DbgLog((LOG_TRACE,1,TEXT("Cannot create CVFWImage class. rtn DV_ERR_NOTDETECTED")));

            VirtualFree(g_pdwChannel, 0 , MEM_RELEASE), g_pdwChannel = 0;
            dwError = DV_ERR_NOTDETECTED;
            VirtualFree(pChannel->lpbmiHdr, 0 , MEM_RELEASE), g_lpbmiHdr = pChannel->lpbmiHdr = 0;
            goto error;
        }

        if(!((CVFWImage *)g_pContext)->OpenDriverAndPin()) {

            // There are at least one device, perhaps, the one that we want is not plugged in.
            if(((CVFWImage *)g_pContext)->BGf_GetDevicesCount(BGf_DEVICE_VIDEO) > 0) {

                // Asked to programatically open a target device; assume it is exclusive !!
                if(!((CVFWImage *)g_pContext)->GetTargetDeviceOpenExclusively()) {
                    //
                    // If we are here, it mean that:
                    //    we have one or more capture device connected and enumerated,
                    //    the last capture device is in use, gone (unplugged/removed), or not responsinding,
                    //    and we should bring up the device source dialog box for a user selection
                    // Return DV_ERR_OK only if a differnt device (path) has selected.
                    //
                    if(DV_ERR_OK != DoExternalInDlg(g_hInst, (HWND)0, (CVFWImage *)g_pContext)) {

	             		        VirtualFree(g_pdwChannel, 0 , MEM_RELEASE), g_pdwChannel = 0;
                        VirtualFree(pChannel->lpbmiHdr, 0 , MEM_RELEASE), g_lpbmiHdr = pChannel->lpbmiHdr = 0;
                        delete (CVFWImage*)g_pContext;
                        g_pContext = 0;
                        dwError = DV_ERR_NOTDETECTED;
                        goto error;
                    }
                } else {  // Open Exclusive

                    VirtualFree(g_pdwChannel, 0 , MEM_RELEASE), g_pdwChannel = 0;
                    VirtualFree(pChannel->lpbmiHdr, 0 , MEM_RELEASE), g_lpbmiHdr = pChannel->lpbmiHdr = 0;
                    delete (CVFWImage*)g_pContext;
                    g_pContext = 0;					
                    dwError = DV_ERR_NOTDETECTED;
                    goto error;
                }
            } else {   // No device is avaialble
                VirtualFree(g_pdwChannel, 0 , MEM_RELEASE), g_pdwChannel = 0;
                VirtualFree(pChannel->lpbmiHdr, 0 , MEM_RELEASE), g_lpbmiHdr = pChannel->lpbmiHdr = 0;
                delete (CVFWImage*)g_pContext;
                g_pContext = 0;					
                dwError = DV_ERR_NOTDETECTED;
                goto error;
            }
        } else {   // Open last saved device and its pin has suceeded.
        }

        if(g_pContext) {
            g_dwOpenFlags = ((CVFWImage *)g_pContext)->BGf_OverlayMixerSupported() ? OPENFLAG_SUPPORT_OVERLAY : 0;
        }
    }



    DbgLog((LOG_TRACE,2,TEXT("DRV_OPEN+VIDEO_*: ->pCVfWImage=0x%p; dwOpenFlags=0x%lx"), pChannel->pCVfWImage, g_dwOpenFlags));

    //
    //  make sure the channel is not already in use
    //
    switch ( dwFlags & ( VIDEO_EXTERNALIN | VIDEO_IN | VIDEO_EXTERNALOUT) ) {
    case VIDEO_IN:
        DbgLog((LOG_TRACE,2,TEXT("v1.5)VideoOpen: VIDEO_IN; open count = %d"), gwVidInUsage));
			     if(gwVidInUsage >= MAX_IN_CHANNELS) {
            dwError = DV_ERR_TOOMANYCHANNELS;
            DbgLog((LOG_TRACE,1,TEXT("Exceeded MAX open %d"), MAX_IN_CHANNELS));
				        goto error;
        }

        if(g_pContext) {
            gwVidInUsage++;
            pChannel->pCVfWImage = g_pContext;
            pChannel->pdwChannel = g_pdwChannel;
            pChannel->dwFlags = 1;
            *g_pdwChannel += 1;   // Increment number of channel htat use the same device.
            g_bVidInChannel = TRUE;
        } else {
             dwError = DV_ERR_NOTDETECTED;
            goto error;
        }

        pChannel->lpbmiHdr    = g_lpbmiHdr;    // Segmented address.
        if(!g_bVidExtInChannel && !g_bVidExtOutChannel)
            break;   // Continue to set bitmap
        else
            return pChannel;

    case VIDEO_EXTERNALIN:
        DbgLog((LOG_TRACE,2,TEXT("VideoOpen: VIDEO_EXTERNALIN")));
			     if( gwVidExtInUsage >= MAX_CAPTURE_CHANNELS) {
            dwError = DV_ERR_TOOMANYCHANNELS;
            DbgLog((LOG_TRACE,1,TEXT("Exceeded MAX open %d"), MAX_CAPTURE_CHANNELS));
				        goto error;
        }

        if(g_pContext) {
            gwVidExtInUsage++;
            pChannel->pCVfWImage = g_pContext;
            pChannel->pdwChannel = g_pdwChannel;
            pChannel->dwFlags = 1;
            *g_pdwChannel += 1;   // Increment number of channel htat use the same device.
            g_bVidExtInChannel = TRUE;
        } else {
            dwError=DV_ERR_NOTDETECTED;
            goto error;
        }

        pChannel->lpbmiHdr    = g_lpbmiHdr;    // Segmented address.

        if(!g_bVidInChannel && !g_bVidExtOutChannel)
            break;   // Continue to set bitmap
        else
            return pChannel;

    // Overlay support
    case VIDEO_EXTERNALOUT:
        DbgLog((LOG_TRACE,2,TEXT("VideoOpen: VIDEO_EXTERNALOUT; Overlay")));
			     if( gwVidExtOutUsage >= MAX_DISPLAY_CHANNELS) {
            dwError = DV_ERR_TOOMANYCHANNELS;
            DbgLog((LOG_TRACE,1,TEXT("Exceeded MAX open %d"), MAX_DISPLAY_CHANNELS));
				        goto error;
        }

        if(g_pContext && (g_dwOpenFlags & OPENFLAG_SUPPORT_OVERLAY)) {
            gwVidExtOutUsage++;
            pChannel->pCVfWImage = g_pContext;
            pChannel->pdwChannel = g_pdwChannel;
            pChannel->dwFlags = 1;
            *g_pdwChannel += 1;   // Increment number of channel htat use the same device.
            g_bVidExtOutChannel = TRUE;
        } else {
            dwError=DV_ERR_NOTDETECTED;
            goto error;
        }

        pChannel->lpbmiHdr    = g_lpbmiHdr;    // Segmented address.

        if(!g_bVidInChannel && !g_bVidExtInChannel)
            break;   // Continue to set bitmap
        else
            return pChannel;

    default:
        DbgLog((LOG_TRACE,1,TEXT("VideoOpen: Unsupported channel")));
        goto error;
    }

    //
    // Try to open the video source (camera or capture card) channel and ready for preview
    //
    if(pChannel->pCVfWImage) {

        gwDriverUsage++;
        DWORD dwSize;
        //
        // Get bitmapinfoheader size and then copy it.
        // Our bitmapinfoheader contains bitfield (additional 12 bytes)
        //
        dwSize = ((CVFWImage *) pChannel->pCVfWImage)->GetBitmapInfo((PBITMAPINFOHEADER)pChannel->lpbmiHdr, 0);
        ASSERT(dwSize <= sizeof(BITMAPINFOHEADER) + 12);
        dwSize = dwSize > (sizeof(BITMAPINFOHEADER) + 12) ? sizeof(BITMAPINFOHEADER) + 12 : dwSize;
        ((CVFWImage *) pChannel->pCVfWImage)->GetBitmapInfo((PBITMAPINFOHEADER)pChannel->lpbmiHdr, dwSize);
        if(*lpdwError != DV_ERR_OK) {
            goto error;
        }
        DbgLog((LOG_TRACE,2,TEXT("pChannel=0x%lx; pCVfWImage=0x%p"), pChannel, pChannel->pCVfWImage));
	    return pChannel;

    } else
        dwError=DV_ERR_NOTDETECTED;

error:
    DbgLog((LOG_TRACE,1,TEXT("DRV_OPEN: rtn error=%ld"), dwError ));

    if(pChannel) {
	    VirtualFree(pChannel, 0 , MEM_RELEASE), pChannel = 0;
    }
    *lpdwError = dwError;
    return NULL;
}
\
//////////////////////////////////////////////////////////////////////////////////////////
//
// DRV_CLOSE
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD PASCAL VideoClose(PCHANNEL pChannel)
{
    // Decrement the channel open counters

    DbgLog((LOG_TRACE,2,TEXT("VideoClose: pChannel=%lx; pChannel->dwOpenType=%lx"), pChannel, pChannel->dwOpenType));

    switch (pChannel->dwOpenType) {

    case VIDEO_EXTERNALIN:
        if(pChannel->pCVfWImage) {
            if(pChannel->dwFlags == 0) {
                DbgLog((LOG_TRACE,1,TEXT("VIDEO_EXTERNALIN: pChannel(%lx) is already closed.  Why close again ??")));
                return DV_ERR_OK;
            }
            pChannel->dwFlags = 0;
            gwVidExtInUsage--;
            *pChannel->pdwChannel -= 1;   // Decrement number of channel that use the same device.
            DbgLog((LOG_TRACE,2,TEXT("DRV_CLOSE; VIDEO_EXTERNALIN: gwCaptureUsage=%d, dwChannel=%d"), gwVidExtInUsage, *pChannel->pdwChannel));
            //pChannel->pCVfWImage = 0;
        } else {
            DbgLog((LOG_TRACE,1,TEXT("VideoClose:VIDEO_EXTERNALIN; but channel is not open!!")));
            return DV_ERR_OK;
        }

        break;

    case VIDEO_IN:
        // If started, or buffers in the queue,
        // don't let the close happen
        // ???
        if(pChannel->pCVfWImage) {
            if(pChannel->dwFlags == 0) {
                DbgLog((LOG_TRACE,1,TEXT("VIDEO_IN: pChannel(%lx) is already closed.  Why close again ??")));
                return DV_ERR_OK;
            }
            pChannel->dwFlags = 0;
            gwVidInUsage--;
            *pChannel->pdwChannel -= 1;   // Decrement number of channel that use the same device.
            DbgLog((LOG_TRACE,2,TEXT("DRV_CLOSE; VIDEO_IN: gwVideoInUsage=%d, dwChannel=%d"), gwVidInUsage, *pChannel->pdwChannel));

        } else {
            DbgLog((LOG_TRACE,1,TEXT("VideoClose:VIDEO_IN; but channel is not open!!")));
            return DV_ERR_OK;
        }
        break;

    case VIDEO_EXTERNALOUT:
        if(pChannel->pCVfWImage) {
            if(pChannel->dwFlags == 0) {
                DbgLog((LOG_TRACE,1,TEXT("VIDEO_EXTERNALOUT: pChannel(%lx) is already closed.  Why close again ??")));
                return DV_ERR_OK;
            }
            pChannel->dwFlags = 0;
            gwVidExtOutUsage--;
            *pChannel->pdwChannel -= 1;   // Decrement number of channel that use the same device.
            DbgLog((LOG_TRACE,2,TEXT("DRV_CLOSE; VIDEO_EXTERNALOUT: gwVidExtOutUsage=%d, dwChannel=%d"), gwVidExtOutUsage, *pChannel->pdwChannel));
            //pChannel->pCVfWImage = 0;
        } else {
            DbgLog((LOG_TRACE,1,TEXT("VideoClose:VIDEO_EXTERNALOUT; but channel is not open!!")));
            return DV_ERR_OK;
        }
        break;

    default:
        DbgLog((LOG_TRACE,1,TEXT("VideoClose() on Unknow channel")));
        return DV_ERR_OK;
    }


    // Only when channel count for the same device is 0, we close the deivice.
    //if(*pChannel->pdwChannel <= 0) {
    if(*pChannel->pdwChannel == 0) {  // == 0, to avoid free it again it application send to many _CLOSE.

        // If there are pending read. Stop streaming to reclaim buffers.
        if(((CVFWImage *)pChannel->pCVfWImage)->GetPendingReadCount() > 0) {
            DbgLog((LOG_TRACE,1,TEXT("WM_1332_CLOSE:  there are %d pending IOs. Stop to reclaim them."), ((CVFWImage *)pChannel->pCVfWImage)->GetPendingReadCount()));
            if(((CVFWImage *)pChannel->pCVfWImage)->BGf_OverlayMixerSupported()) {
                // Stop both the capture
                BOOL bRendererVisible = FALSE;
                ((CVFWImage *)pChannel->pCVfWImage)->BGf_GetVisible(&bRendererVisible);
                ((CVFWImage *)pChannel->pCVfWImage)->BGf_StopPreview(bRendererVisible);
            }
            ((CVFWImage *)pChannel->pCVfWImage)->StopChannel();  // This will set PendingCount to 0 is success.
        }

        if(((CVFWImage *)pChannel->pCVfWImage)->GetPendingReadCount() == 0) {

            ((CVFWImage *)pChannel->pCVfWImage)->CloseDriverAndPin();
            delete ((CVFWImage *)pChannel->pCVfWImage);
        } else {
            DbgLog((LOG_TRACE,1,TEXT("VideoClose:  there are %d pending IO. REFUSE to close"),
                ((CVFWImage *)pChannel->pCVfWImage)->GetPendingReadCount() ));
            ASSERT(((CVFWImage *)pChannel->pCVfWImage)->GetPendingReadCount() == 0);
            return DV_ERR_NONSPECIFIC;
        }

	    VirtualFree(pChannel->lpbmiHdr, 0 , MEM_RELEASE), pChannel->lpbmiHdr = 0;
    }

    pChannel->pCVfWImage = 0;
	VirtualFree(pChannel, 0 , MEM_RELEASE);
	pChannel = 0;

    return DV_ERR_OK;
}



//////////////////////////////////////////////////////////////////////////////////////////
//
// Show channel specific configuration dialogs
//
// lparam1 : (HWND) hWndParent
// lParam2 : (DWORD) dwFlags
//
// AVICAP does not seem to care about its return!!
//////////////////////////////////////////////////////////////////////////////////////////
DWORD PASCAL FAR VideoDialog (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    DWORD dwRet;
    DWORD dwFlags = (DWORD) lParam2;
    CVFWImage * pCVfWImage;


    DbgLog((LOG_TRACE,2,TEXT("videoDialog: lParam=%lx"), lParam1));

    switch (pChannel->dwOpenType) {

    case VIDEO_EXTERNALIN:        	
        if(dwFlags & VIDEO_DLG_QUERY) {
	           return DV_ERR_OK;       // Support the dialog
        }
        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        dwRet = DoExternalInDlg(g_hInst, (HWND)lParam1, pCVfWImage);
        return dwRet;				

    case VIDEO_IN:
        if(dwFlags & VIDEO_DLG_QUERY) {
            // This is only set if the client is using the AviCap interface.
            // Application like NetMeeting, that bypass AVICap, will be 0.
            pChannel->hClsCapWin = (DWORD) lParam1;
	           return DV_ERR_OK;						 // Support the dialog
        }

        pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
        dwRet = DoVideoInFormatSelectionDlg(g_hInst, (HWND) lParam1, pCVfWImage);
        return dwRet;

    case VIDEO_EXTERNALOUT:
		  case VIDEO_OUT:
    default:
        return DV_ERR_NOTSUPPORTED;
   }
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// handles DVM_GET_CHANNEL_CAPS message
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD PASCAL VideoGetChannelCaps (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    LPCHANNEL_CAPS lpCaps;
    DWORD          dwSizeChannelCaps;


    lpCaps = (LPCHANNEL_CAPS) lParam1;
    dwSizeChannelCaps = (DWORD) lParam2;

    if(!lpCaps) {
        DbgLog((LOG_TRACE,1,TEXT("VideoGetChannelCaps: lpCaps (LPARAM1) is NULL!")));
        return DV_ERR_PARAM1;
    }

    lpCaps-> dwFlags = 0L;

	   DbgLog((LOG_TRACE,2,TEXT("VideoChannelCaps:%d"),pChannel->dwOpenType));
	
    switch (pChannel->dwOpenType)
    {
    case VIDEO_EXTERNALIN:
			     // For this device, scaling happens during digitization
			     // into the frame buffer.
			     lpCaps-> dwFlags			         = 0; // VCAPS_CAN_SCALE;
			     lpCaps-> dwSrcRectXMod		    = 1; // Src undefined at present
			     lpCaps-> dwSrcRectYMod		    = 1;
			     lpCaps-> dwSrcRectWidthMod	 = 1;
			     lpCaps-> dwSrcRectHeightMod	= 1;
			     lpCaps-> dwDstRectXMod		    = 4;
			     lpCaps-> dwDstRectYMod		    = 2;
			     lpCaps-> dwDstRectWidthMod	 = 1;
			     lpCaps-> dwDstRectHeightMod	= 1;
		      break;

    case VIDEO_IN:
			     lpCaps-> dwFlags			         = 0;       // No scaling or clipping
			     lpCaps-> dwSrcRectXMod		    = 4;
			     lpCaps-> dwSrcRectYMod		    = 2;
			     lpCaps-> dwSrcRectWidthMod	 = 1;
			     lpCaps-> dwSrcRectHeightMod = 1;
			     lpCaps-> dwDstRectXMod		    = 4;
			     lpCaps-> dwDstRectYMod		    = 2;
			     lpCaps-> dwDstRectWidthMod	 = 1;
			     lpCaps-> dwDstRectHeightMod = 1;
		      break;

    case VIDEO_EXTERNALOUT:
        // This is called if DRV_OPEN of VIDEO_EXTERNALOUT has suceeded.
        DbgLog((LOG_TRACE,2,TEXT("Query VIDEO_EXTERNALOUT VideoChannelCap.")));
        lpCaps-> dwFlags			         = VCAPS_OVERLAY;       // Support overlay.
        lpCaps-> dwSrcRectXMod		    = 4;
        lpCaps-> dwSrcRectYMod		    = 2;
        lpCaps-> dwSrcRectWidthMod	 = 1;
        lpCaps-> dwSrcRectHeightMod = 1;
        lpCaps-> dwDstRectXMod		    = 4;
        lpCaps-> dwDstRectYMod		    = 2;
        lpCaps-> dwDstRectWidthMod	 = 1;
        lpCaps-> dwDstRectHeightMod = 1;
        break;

		  case VIDEO_OUT:
		  default:
			     return DV_ERR_NOTSUPPORTED;
    }
	return DV_ERR_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////
//
// Tell overlay channel to update due to move, resize ..etc.
//
// lparam1 : (HWND) hWnd
// lParam2 : (HDC) hDc
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD PASCAL VideoUpdate(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    DWORD dwRet;
    HWND hWnd = (HWND) lParam1;
    HDC hDC   = (HDC) lParam2;
    RECT RectWnd, RectClient;


    if(pChannel->dwOpenType != VIDEO_EXTERNALOUT)
        return DV_ERR_NOTSUPPORTED;

    GetWindowRect(hWnd, &RectWnd);
    GetClientRect(hWnd, &RectClient);

    DbgLog((LOG_TRACE,2,TEXT("DVM_UPDATE+VID_EXTOUT+_WND:    (LT:%dx%d, RB:%dx%d)"), RectWnd.left, RectWnd.top, RectWnd.right, RectWnd.bottom));
    DbgLog((LOG_TRACE,2,TEXT("DVM_UPDATE+VID_EXTOUT+_CLIENT: (LT:%dx%d, RB:%dx%d)"), RectClient.left, RectClient.top, RectClient.right, RectClient.bottom));


    CVFWImage * pCVfWImage;
    pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
    if(pCVfWImage->StreamReady())
        dwRet = pCVfWImage->BGf_UpdateWindow((HWND)lParam1,(HDC)lParam2);
    else
        dwRet = DV_ERR_OK;

    return dwRet;
}



//////////////////////////////////////////////////////////////////////////////////////////
//
// handles DVM_SRC_RECT and DVM_DST_RECT messages
// Video-capture drivers might support a source rectangle to specify a portion
// of an image that is digitized or transferred to the display. External-in
// ports use the source rectangle to specify the portion of the analog image
// digitized. External-out ports use the source rectangle to specify the portion
// of frame buffer shown on the external output.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
// TODO - the 32 bit guy needs to do all this as well.
//
//DWORD NEAR PASCAL VideoRectangles (PCHANNEL pChannel, BOOL fSrc, LPRECT lpRect, DWORD dwFlags)

DWORD PASCAL VideoSrcRect (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    static RECT rcMaxRect = {0, 0, 320, 240};
    LPRECT lpRect;
    DWORD dwFlags;


    lpRect = (LPRECT) lParam1;
    dwFlags = (DWORD) lParam2;

    if (lpRect == NULL)
        return DV_ERR_PARAM1;

    // Note: many of the uses of the rectangle functions are not actually
    // implemented by the sample driver, (or by Vidcap), but are included
    // here for future compatibility.
    DbgLog((LOG_TRACE,2,TEXT("    current: (LT:%dx%d, RB:%dx%d)"),
         pChannel->rcSrc.left, pChannel->rcSrc.right, pChannel->rcSrc.top, pChannel->rcSrc.bottom));
    DbgLog((LOG_TRACE,2,TEXT("    new:     (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));

    switch (pChannel->dwOpenType) {

    case VIDEO_IN:
        switch (dwFlags) {
        case VIDEO_CONFIGURE_SET:
        case VIDEO_CONFIGURE_SET | VIDEO_CONFIGURE_CURRENT:
            // Where in the frame buffer should we take
            // the image from?
            DbgLog((LOG_TRACE,2,TEXT("Set VIDEO_IN")));
            pChannel->rcSrc = *lpRect;
            return DV_ERR_OK;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT:
           	DbgLog((LOG_TRACE,2,TEXT("GET VideoIn Current size")));
            *lpRect =  pChannel->rcSrc;
            return DV_ERR_OK;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_MAX:
           	DbgLog((LOG_TRACE,2,TEXT("GET VideoIn MAX size")));
            *lpRect =  pChannel->rcSrc;
            return DV_ERR_OK;

        default:
            break;
        }

        DbgLog((LOG_TRACE,2,TEXT("VideoSrcRect: VIDEO_IN: dwFlags=0x%lx Not supported!"), dwFlags));
        return DV_ERR_NOTSUPPORTED;


    case VIDEO_EXTERNALOUT:
        DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+Enter: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
        switch (dwFlags) {
        case VIDEO_CONFIGURE_SET:
        case VIDEO_CONFIGURE_SET | VIDEO_CONFIGURE_CURRENT:
            // Where in the frame buffer should we take
            // the image from?
            if((lpRect->right - lpRect->left == pChannel->lpbmiHdr->biWidth) &&
               (lpRect->bottom - lpRect->top == pChannel->lpbmiHdr->biHeight)) {
                pChannel->rcSrc = *lpRect;
                DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+_SET+_CURRENT: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
                return DV_ERR_OK;
            }
            break;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT:
            *lpRect = pChannel->rcSrc;
            DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+_GET+_CURRENT: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
            return DV_ERR_OK;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_MAX:
            *lpRect = rcMaxRect;
            DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+_GET+_MAX: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
            return DV_ERR_OK;

        default:
            break;
        }

        DbgLog((LOG_TRACE,2,TEXT("!!VideoSrcRect: VIDEO_EXTERNALOUT: Not supported!!")));
        return DV_ERR_NOTSUPPORTED;


    case VIDEO_EXTERNALIN:
        DbgLog((LOG_TRACE,2,TEXT("VID_EXTIN+Enter: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
        switch (dwFlags) {
        case VIDEO_CONFIGURE_SET:
        case VIDEO_CONFIGURE_SET | VIDEO_CONFIGURE_CURRENT:
            pChannel->rcSrc = *lpRect;
            DbgLog((LOG_TRACE,2,TEXT("VID_EXTIN+_SET: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
            return DV_ERR_OK;
        default:
            break;
        }
        DbgLog((LOG_TRACE,1,TEXT("!!VideoSrcRect: VIDEO_EXTERNALIN: Not supported!!")));

        break;


    case VIDEO_OUT:
    default:
        DbgLog((LOG_TRACE,1,TEXT("VideoSrcRect: VIDEO_OUT dwFlags=%lx: Not supported!"), dwFlags));
        return DV_ERR_NOTSUPPORTED;
    }

    return DV_ERR_NOTSUPPORTED;
}

DWORD PASCAL VideoDstRect (PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    static RECT rcMaxRect = {0, 0, 320, 240};
    LPRECT lpRect;
    DWORD dwFlags;


    lpRect = (LPRECT) lParam1;
    dwFlags = (DWORD) lParam2;

    if (lpRect == NULL)
        return DV_ERR_PARAM1;

    DbgLog((LOG_TRACE,2,TEXT("    current: (LT:%dx%d, RB:%dx%d)"),
         pChannel->rcDst.left, pChannel->rcDst.right, pChannel->rcDst.top, pChannel->rcDst.bottom));
    DbgLog((LOG_TRACE,2,TEXT("    new:     (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));


    switch (pChannel->dwOpenType) {
    case VIDEO_EXTERNALIN:
        switch (dwFlags) {
        case VIDEO_CONFIGURE_SET:
        case VIDEO_CONFIGURE_SET | VIDEO_CONFIGURE_CURRENT:
            pChannel->rcDst = *lpRect;
            return DV_ERR_OK;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT:
           	DbgLog((LOG_TRACE,2,TEXT("Get ExternalIn current size %dx%d, %dx%d"),
								         grcDestExtIn.left, grcDestExtIn.right,
								         grcDestExtIn.top, grcDestExtIn.bottom));
            *lpRect = grcDestExtIn;
            return DV_ERR_OK;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_MAX:
            DbgLog((LOG_TRACE,2,TEXT("Get ExternalIn MAX size")));
            *lpRect = rcMaxRect;
            return DV_ERR_OK;

        default:
            break;
        }
        DbgLog((LOG_TRACE,1,TEXT("VideoDstRect: VIDEO_EXTERNALIN: dwFlags=%lx; Not supported!"), dwFlags));
        return DV_ERR_NOTSUPPORTED;

    case VIDEO_EXTERNALOUT:
        DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+Enter: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
        switch (dwFlags) {
        case VIDEO_CONFIGURE_SET:
        case VIDEO_CONFIGURE_SET | VIDEO_CONFIGURE_CURRENT:
            // Where in the frame buffer should we take
            // the image from?
            if((lpRect->right - lpRect->left == pChannel->lpbmiHdr->biWidth) &&
               (lpRect->bottom - lpRect->top == pChannel->lpbmiHdr->biHeight)) {
                pChannel->rcDst = *lpRect;
                DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+_SET+_CURRENT: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
                return DV_ERR_OK;
            }
            break;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT:
            *lpRect = pChannel->rcDst;
            DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+_GET+_CURRENT: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
            return DV_ERR_OK;

        case VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_MAX:
            *lpRect = rcMaxRect;
            DbgLog((LOG_TRACE,2,TEXT("VID_EXTOUT+_GET+_MAX: (LT:%dx%d, RB:%dx%d)"), lpRect->left, lpRect->top, lpRect->right, lpRect->bottom));
            return DV_ERR_OK;

        default:
            break;
        }

        DbgLog((LOG_TRACE,1,TEXT("VideoDstRect: VIDEO_EXTERNALOUT: dwFlags=%lx; Not supported!"), dwFlags));
        return DV_ERR_NOTSUPPORTED;

    case VIDEO_IN:
        return DV_ERR_OK;

    case VIDEO_OUT:
    default:
        DbgLog((LOG_TRACE,1,TEXT("VideoDstRect: VIDEO_OUT: dwFlags=%lx; Not supported!"), dwFlags));
        return DV_ERR_NOTSUPPORTED;
    }

}

//
//
//  Need to implement this
//
DWORD PASCAL VideoGetErrorText(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    DbgLog((LOG_TRACE,1,TEXT("Not implemented")));
    return DV_ERR_NOTSUPPORTED;

    if(lParam1) {
        if(LoadString(
            g_hInst,
            (WORD)  ((LPVIDEO_GETERRORTEXT_PARMS) lParam1) ->dwError,
            (LPTSTR)
            ((LPVIDEO_GETERRORTEXT_PARMS) lParam1) ->lpText,
            (int)   ((LPVIDEO_GETERRORTEXT_PARMS) lParam1) ->dwLength))
            return DV_ERR_OK;
       else
           return DV_ERR_PARAM1;

    } else {
        return DV_ERR_PARAM1;
    }

}

#if 0
//////////////////////////////////////////////////////////////////////////////////////////
//
//  handles ConfigureStorage message
//        lParam1 is lpszKeyFile
//        lParam2 is dwFlags
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD PASCAL VideoConfigureStorageMessage(PCHANNEL pChannel, UINT msg, LONG lParam1, LONG lParam2)
{
	DbgLog((LOG_TRACE,2,TEXT("VideoConfigureStorageMessage - streaming to %s"),(LPSTR)lParam1));

    if (lParam2 & VIDEO_CONFIGURE_GET)
        CT_LoadConfiguration ((LPSTR) lParam1);
    else if (lParam2 & VIDEO_CONFIGURE_SET)
        CT_SaveConfiguration ((LPSTR) lParam1);
    else
        return DV_ERR_FLAGS;

    return DV_ERR_OK;
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//
//  handles Configure messages for video
//        lParam1 is dwFlags
//        lParam2 is LPVIDEOCONFIGPARMS
//
//////////////////////////////////////////////////////////////////////////////////////////
/***************************************************************************
***************************************************************************/

DWORD PASCAL GetDestFormat(PCHANNEL pChannel, LPBITMAPINFOHEADER lpbi, DWORD dwSize)
{
    DWORD dwRtn = DV_ERR_OK;

    DbgLog((LOG_TRACE,2,TEXT("GetDestFormat: current(%ldx%ldx%d/8=%ld) ?= new(%ldx%ldx%d/8=%ld); dwSize=%ld"),
        lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount, lpbi->biSizeImage,
        pChannel->lpbmiHdr->biWidth, pChannel->lpbmiHdr->biHeight, pChannel->lpbmiHdr->biBitCount, pChannel->lpbmiHdr->biSizeImage,
        dwSize));

    // As long as the buffer is big enough to contain BITMAPINFOHEADER, we will get it.
    // But if it is less, that is an error.
    if (dwSize < sizeof(BITMAPINFOHEADER)) {
        DbgLog((LOG_TRACE,1,TEXT("GetDestFormat(): dwSize=%d < sizeoof(BITMAPINFOHEADER)=%d. Rtn DV_ERR_SIZEFIELD."), dwSize, sizeof(BITMAPINFOHEADER) ));
        return DV_ERR_SIZEFIELD;
    }

    //
    // Return the BITMAPINFOHEADER that has been cached
    // from DRV_OPEN and/or SetDestFormat()
    //
    CVFWImage * pCVfWImage ;
    pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;
    if(pCVfWImage) {
        DWORD dwSizeRtn;
        dwSizeRtn = pCVfWImage->GetBitmapInfo((PBITMAPINFOHEADER)lpbi, dwSize);
        ASSERT(dwSizeRtn >= sizeof(BITMAPINFOHEADER));
    } else {
        dwRtn = DV_ERR_INVALHANDLE;
        ASSERT(pCVfWImage);
    }

    return dwRtn;
}


/***************************************************************************
***************************************************************************/
//////////////////////////////////////////////////////////////////////////////////
//
// This routine can be called before the CopyBuffer and
// translation buffers are allocated, so beware!
//
// This allows irregular sized immages to be captures (not multiples of 40)
//
/////////////////////////////////////////////////////////////////////////////////
DWORD PASCAL SetDestFormat(PCHANNEL pChannel, LPBITMAPINFOHEADER lpbi, DWORD dwSize)
{
    DWORD dwRtn;

    DbgLog((LOG_TRACE,2,TEXT("SetDestFormat: current(%ldx%ldx%d/8=%ld) ?= new(%ldx%ldx%d/8=%ld)"),
        pChannel->lpbmiHdr->biWidth, pChannel->lpbmiHdr->biHeight, pChannel->lpbmiHdr->biBitCount, pChannel->lpbmiHdr->biSizeImage,
        lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount, lpbi->biSizeImage ));

    // Minimun size
    if(dwSize < sizeof(BITMAPINFOHEADER)) {
        DbgLog((LOG_TRACE,1,TEXT("SetDestFormat(): dwSize(%d) < sizeof(BITMAPINFOHEADER)(%d); return DV_ERROR_SIZEFIELD(%d)"), dwSize, sizeof(BITMAPINFOHEADER), DV_ERR_SIZEFIELD));
        return DV_ERR_SIZEFIELD;
    }


    //
    // Number of plane for the target device; must be 1.
    //
    if(lpbi->biPlanes != 1) {
        DbgLog((LOG_TRACE,1,TEXT("SetDestFormat Failed; return DV_ERR_BADFORMAT; biPlanes(%d) != 1."), lpbi->biPlanes));
        ASSERT(lpbi->biPlanes != 1);
        return DV_ERR_BADFORMAT;
    }


    //
    // Set new VIDEO_IN format; if needed, recreate the pin connection.
    //
    ASSERT(dwSize <= sizeof(BITMAPINFOHEADER) + sizeof(DWORD) * BITFIELDS_RGB16_DWORD_COUNT);
    CopyMemory(pChannel->lpbmiHdr, lpbi, dwSize);

    CVFWImage * pCVfWImage ;
    pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

    if((dwRtn =
        pCVfWImage->SetBitmapInfo(
            (PBITMAPINFOHEADER)pChannel->lpbmiHdr,
            pCVfWImage->GetCachedAvgTimePerFrame() )) != DV_ERR_OK) {
        DbgLog((LOG_TRACE,1,TEXT("SetDestFormat: SetBitmapInfo return 0x%x"), dwRtn));
    }

    //
    // Whether suceeded or fail, get the current bitmapinfo.
    // Verify: Now ask the driver if what was set was OK - trash what the user gave me?
    //

    pCVfWImage->GetBitmapInfo(
        (PBITMAPINFOHEADER)pChannel->lpbmiHdr, 
        sizeof(BITMAPINFOHEADER) 
        );


    if(dwRtn != DV_ERR_OK) {
        DbgLog((LOG_TRACE,1,TEXT("SetDestFormat: SetBitmapInfo has failed! with dwRtn=%d"), dwRtn));
        return DV_ERR_BADFORMAT; 
    }

    return DV_ERR_OK;
}



DWORD PASCAL VideoFormat(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    LPVIDEOCONFIGPARMS lpcp;
    LPDWORD	lpdwReturn;	// Return parameter from configure.
    LPVOID	lpData1;	    // Pointer to data1.
    DWORD	dwSize1;	     // size of data buffer1.
    LPVOID	lpData2;	    // Pointer to data2.
    DWORD	dwSize2;	     // size of data buffer2.
    LPARAM	dwFlags;

    if (pChannel-> dwOpenType != VIDEO_IN &&
        pChannel-> dwOpenType != VIDEO_EXTERNALIN ) {
        DbgLog((LOG_TRACE,1,TEXT("VideoFormat: not supported channel %d"), pChannel->dwOpenType));
        return DV_ERR_NOTSUPPORTED;
    }

	   DbgLog((LOG_TRACE,3,TEXT("VideoFormat: dwFlags=0x%lx; lpcp=0x%lx"), lParam1, lParam2));

    dwFlags		= lParam1;
    lpcp 		= (LPVIDEOCONFIGPARMS) lParam2;

    lpdwReturn	= lpcp-> lpdwReturn;
    lpData1		= lpcp-> lpData1;	
    dwSize1		= lpcp-> dwSize1;	
    lpData2		= lpcp-> lpData2;	
    dwSize2		= lpcp-> dwSize2;	

    /*
    The video-capture format globally defines the attributes of the images
    transferred from the frame buffer with the video-in channel. Attributes
    include image dimensions, color depth, and the compression format of images
    transferred. Applications use the DVM_FORMAT message to set or retrieve the
    format of the digitized image.
    */
    switch (dwFlags) {
    case (VIDEO_CONFIGURE_QUERY | VIDEO_CONFIGURE_SET):
    case (VIDEO_CONFIGURE_QUERY | VIDEO_CONFIGURE_GET):
    	   DbgLog((LOG_TRACE,3,TEXT("we support DVM_FORMAT")));
        return DV_ERR_OK;  // command is supported

    case VIDEO_CONFIGURE_QUERYSIZE:
    case (VIDEO_CONFIGURE_QUERYSIZE | VIDEO_CONFIGURE_GET):
        *lpdwReturn = ((CVFWImage *)pChannel->pCVfWImage)->GetbiSize();
        DbgLog((LOG_TRACE,3,TEXT("DVM_FORMAT, QuerySize return size %d"),*lpdwReturn));
        return DV_ERR_OK;

    case VIDEO_CONFIGURE_SET:
    case (VIDEO_CONFIGURE_SET | VIDEO_CONFIGURE_CURRENT):
        return (SetDestFormat(pChannel, (LPBITMAPINFOHEADER) lpData1, (DWORD) dwSize1));

    case VIDEO_CONFIGURE_GET:
    case (VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT):
        return (GetDestFormat(pChannel, (LPBITMAPINFOHEADER) lpData1, (DWORD) dwSize1));

    default:
        return DV_ERR_NOTSUPPORTED;
    }  //end of DVM_FORMAT switch

}


/*
 * Capture a frame
 * This function implements the DVM_FRAME message.
 */
DWORD PASCAL VideoFrame(PCHANNEL pChannel, LPARAM lParam1, LPARAM lParam2)
{
    LPVIDEOHDR lpVHdr;
    DWORD dwHdrSize;
#ifdef WIN32
    BOOL bDirect;
    LPBYTE pData;
    CVFWImage * pCVfWImage;
#endif

    lpVHdr    = (LPVIDEOHDR) lParam1;
    dwHdrSize = (DWORD) lParam2;

    if(pChannel->dwOpenType != VIDEO_IN)
        return DV_ERR_NOTSUPPORTED;

    if (lpVHdr == 0)
       return DV_ERR_PARAM1;

    if(lpVHdr->dwBufferLength < pChannel->lpbmiHdr->biSizeImage) {
        lpVHdr->dwBytesUsed = 0;
        DbgLog((LOG_TRACE,1,TEXT("VideoHdr dwBufferSize (%d) < frame size (%d)."), lpVHdr->dwBufferLength, pChannel->lpbmiHdr->biSizeImage));
        return DV_ERR_PARAM1;
    }

    if (dwHdrSize != sizeof(VIDEOHDR)) {
        DbgLog((LOG_TRACE,1,TEXT("lParam2=%d != sizeof(VIDEOHDR)=%d "), dwHdrSize, sizeof(VIDEOHDR)));
        //return DV_ERR_PARAM2;
    }

    pCVfWImage = (CVFWImage *)pChannel->pCVfWImage;

    // To stream:
    //   1. Stream needs to be ready
    //   2. Right biSizeImage and its buffer size (if differnt, changin format!!)
    //
    if(pCVfWImage->ReadyToReadData((HWND) pChannel->hClsCapWin) &&
       pCVfWImage->GetbiSizeImage() == lpVHdr->dwBufferLength) {

        DbgLog((LOG_TRACE,3,TEXT("\'WM_1632_GRAB32: lpVHDr(0x%x); lpData(0x%x); dwReserved[3](0x%p), dwBufferLength(%d)"),
              lpVHdr, lpVHdr->lpData, lpVHdr->dwReserved[3], lpVHdr->dwBufferLength));
        pData = (LPBYTE) lpVHdr->lpData;

        // Memory from AviCap is always sector align+8; a sector is 512 bytes.
        // Check alignment:
        //   If not alignment to the specification, we will use local allocated buffer (page align).
        //
        if((pCVfWImage->GetAllocatorFramingAlignment() & (ULONG_PTR) pData) == 0x0) {
            bDirect = TRUE;
        } else {
            bDirect = FALSE;
            DbgLog((LOG_TRACE,3,TEXT("WM_1632_GRAB: AviCap+pData(0x%p) & alignment(0x%x) => 0x%x > 0; Use XferBuf"),
                pData, pCVfWImage->GetAllocatorFramingAlignment(),
                pCVfWImage->GetAllocatorFramingAlignment() & (ULONG_PTR) pData));
        }

        return pCVfWImage->GetImageOverlapped(
                             (LPBYTE)pData,
                             bDirect,
                             &lpVHdr->dwBytesUsed,
                             &lpVHdr->dwFlags,
                             &lpVHdr->dwTimeCaptured);

    } else {
        DbgLog((LOG_TRACE,1,TEXT("pCVfWImage->GetbiSizeImage()(%d) <= lpVHdr->dwBufferLength(%d)"),
              pCVfWImage->GetbiSizeImage(), lpVHdr->dwBufferLength));
        // Return suceeded but no data !!!
        lpVHdr->dwBytesUsed = 0;
        lpVHdr->dwFlags |= VHDR_DONE;
        return DV_ERR_OK;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//  Main message handler
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD PASCAL VideoProcessMessage(PCHANNEL pChannel, UINT msg, LPARAM lParam1, LPARAM lParam2)
{
    if(DVM_START <= msg && msg <= DVM_STREAM_FREEBUFFER)
        if(!pChannel) {

            DbgLog((LOG_TRACE,1,TEXT("In VideoProcessMessage() but pChannel is NULL!! msg=0x%x"), msg));
            return DV_ERR_NOTSUPPORTED; // DV_ERR_NOTDETECTED;
        }


    switch(msg) {
    case DVM_GETERRORTEXT: /* lParam1 = LPVIDEO_GETERRORTEXT_PARMS */
        DbgLog((LOG_TRACE,2,TEXT("DVM_GETERRORTEXT:")));
        return VideoGetErrorText(pChannel, lParam1, lParam2);

    case DVM_DIALOG: /* lParam1 = hWndParent, lParam2 = dwFlags */			
        DbgLog((LOG_TRACE,2,TEXT("DVM_DIALOG:")));
				    return VideoDialog(pChannel, lParam1, lParam2);

    case DVM_FORMAT:
        DbgLog((LOG_TRACE,2,TEXT("DVM_FORMAT:")));
        return VideoFormat(pChannel, lParam1, lParam2);

    case DVM_FRAME:
        DbgLog((LOG_TRACE,3,TEXT("DVM_FRAME:")));
        return VideoFrame(pChannel, lParam1, lParam2);

    case DVM_GET_CHANNEL_CAPS:
        DbgLog((LOG_TRACE,2,TEXT("DVM_GET_CHANNEL_CAPS:")));
        return VideoGetChannelCaps(pChannel, lParam1, lParam2);

    case DVM_PALETTE:
    case DVM_PALETTERGB555:
        DbgLog((LOG_TRACE,2,TEXT("DVM_PALLETTE/RGB555:")));
			     return DV_ERR_NOTSUPPORTED;

    case DVM_SRC_RECT:
        DbgLog((LOG_TRACE,2,TEXT("DVM_SRC_RECT:")));
        return VideoSrcRect(pChannel, lParam1, lParam2);

    case DVM_DST_RECT:
        DbgLog((LOG_TRACE,2,TEXT("DVM_DST_RECT:")));
        return VideoDstRect(pChannel, lParam1, lParam2);

    case DVM_UPDATE:
        DbgLog((LOG_TRACE,2,TEXT("DVM_UPDATE:")));
        return VideoUpdate(pChannel, lParam1, lParam2);

    case DVM_CONFIGURESTORAGE:
        return DV_ERR_NOTSUPPORTED;
        // return VideoConfigureStorageMessage(pChannel, msg, lParam1, lParam2);

    case DVM_STREAM_INIT:
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_INIT: InStreamOpen()")));
        return InStreamInit(pChannel, lParam1, lParam2);

    case DVM_STREAM_FINI:
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_FINI: InStreamClose()")));
        return InStreamFini(pChannel, lParam1, lParam2);

    case DVM_STREAM_GETERROR:
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_GETERROR: InStreamError()")));
        return InStreamGetError(pChannel, lParam1, lParam2);

    case DVM_STREAM_GETPOSITION:
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_GETPOSITION: InStreamGetPos()")));
        return InStreamGetPos(pChannel, lParam1, lParam2);

    case DVM_STREAM_ADDBUFFER:
        DbgLog((LOG_TRACE,3,TEXT("DVM_STREAM_ADDBUFFER: InStreamAddBuffer(): %ld"), timeGetTime()));
        return InStreamAddBuffer(pChannel, lParam1, lParam2);

    case DVM_STREAM_RESET:
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_RESET: InStreamReset()")));
        return InStreamReset(pChannel, lParam1, lParam2);

    case DVM_STREAM_START:
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_START: InStreamStart()")));
        return InStreamStart(pChannel, lParam1, lParam2);

    case DVM_STREAM_STOP:
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_STOP: InStreamStop()")));
        return InStreamStop(pChannel, lParam1, lParam2);

    case DVM_STREAM_PREPAREHEADER:   // Handled by MSVideo
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_PREPAREHEADER: rtn DV_ERROR_NOTSUPPORTED")));
        return DV_ERR_NOTSUPPORTED;

    case DVM_STREAM_UNPREPAREHEADER: // Handled by MSVideo
        DbgLog((LOG_TRACE,2,TEXT("DVM_STREAM_UNPREPAREHEADER: rtn DV_ERROR_NOTSUPPORTED")));
        return DV_ERR_NOTSUPPORTED;

    default:
            return DV_ERR_NOTSUPPORTED;
    }
}

#ifdef WIN32
}  // #extern "C" {
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\wnd.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    Wnd.cpp

Abstract:

    A simple window class.

Author:

    FelixA 1996

Modified:

    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/


#include "pch.h"
#include "wnd.h"
#include "resource.h"


HRESULT CWindow::Init(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HRESULT hRes;
    mInstance=hInstance;
    if (!hPrevInstance)
        if( (hRes=InitApplication()) != S_OK)
            return hRes;
    if( (hRes=InitInstance(nCmdShow)) != S_OK)
        return hRes;
    mDidWeInit=TRUE;
    return hRes;
}

// Do any necessary cleanup of our class here.
CWindow::~CWindow()
{
}

HWND CWindow::FindCurrentWindow() const
{
    return FindWindow(GetAppName(),NULL);
}


//
//  FUNCTION: InitApplication(HANDLE)
//
//  PURPOSE: Initializes window data and registers window class
//
//  COMMENTS:
//
//       In this function, we initialize a window class by filling out a data
//       structure of type WNDCLASS and calling either RegisterClass or
//       the internal MyRegisterClass.
//
HRESULT CWindow::InitApplication()
{
    WNDCLASS  wc;
    HWND      hwnd;

    // Initialises some private member data.
    _tcscpy(mName, TEXT("MS:RayTubes32BitBuddy")); // Name of the 32bit class
    //LoadString( GetInstance(), IDS_WND_CLASS, mName, sizeof(mName));
#ifdef IDI_APPICON
    mIcon = LoadIcon(GetInstance(),MAKEINTRESOURCE(IDI_APPICON));
#else
    mIcon = NULL;
#endif

#ifdef IDR_MENU
    mAccelTable = LoadAccelerators (GetInstance(), MAKEINTRESOURCE(IDR_MENU));
#else
    mAccelTable = NULL;
#endif

    if( (hwnd=FindCurrentWindow()) )
    {
        SetForegroundWindow (hwnd);
        return ERROR_SINGLE_INSTANCE_APP;    // All ready running.
    }

    // Fill in window class structure with parameters that describe
    // the main window.
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = (WNDPROC)WndProc;    // Wrapper that sets up the correct WindowProc.
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 4;
    wc.hInstance     = GetInstance();
    wc.hIcon         = GetIcon();
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);

    // Since Windows95 has a slightly different recommended
    // format for the 'Help' menu, lets put this in the alternate menu like this:
#ifdef IDR_MENU
    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU);
#else
    wc.lpszMenuName  = NULL;
#endif
    wc.lpszClassName = GetAppName();

    if( RegisterClass(&wc) )
        return S_OK;
    return ERROR_CLASS_ALREADY_EXISTS;
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
HRESULT CWindow::InitInstance(int nCmdShow)
{
    HWND hWnd;

    hWnd = CreateWindowEx(WS_EX_TOOLWINDOW, GetAppName(), GetAppName(), WS_POPUP,
        -100, -100, 10, 10,
        NULL, NULL, GetInstance(), this);

    if (!hWnd)
        return ERROR_INVALID_WINDOW_HANDLE;

    return S_OK;
}


//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//  Sets the windowdata to have a this pointer, and goes off
//  and calls through it
//
LRESULT CALLBACK CWindow::WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    CWindow * pSV = (CWindow*)GetWindowLongPtr(hWnd,0);    // Gets our this pointer.

    if(message==WM_NCCREATE)
    {
        CREATESTRUCT * pC=(CREATESTRUCT *) lParam;
        pSV = (CWindow*)pC->lpCreateParams;
        pSV->mWnd=hWnd;
        SetWindowLongPtr(hWnd,0,(LPARAM)pSV);
    }

    if(pSV)
        return pSV->WindowProc(hWnd,message,wParam,lParam);
    else
        return DefWindowProc(hWnd,message,wParam,lParam);
}

//
//
//
HMENU CWindow::LoadMenu(LPCTSTR lpMenu) const
{
    return ::LoadMenu(mInstance,lpMenu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\vfwimg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    VfWImg.h

Abstract:

    Header file for VfWImg.cpp

Author:

    Yee J. Wu (ezuwu) 15-October-97

Environment:

    User mode only

Revision History:

--*/

#ifndef VFWIMG_H
#define VFWIMG_H

#include "imgcls.h"
#include <BldCapGf.h>



class CStreamingThread;


//
// CVFWImage IS specialisation of a CImageClass
//
class CVFWImage : public CImageClass,
                  public CCaptureGraph
{
private:


    //
    // This is set only if 32bit is loaded by the 16bit;
    // else this is 0
    //

    BOOL m_bUse16BitBuddy;


    //
    // Build graph methods
    //

    DWORD m_dwNumVDevices;
    EnumDeviceInfo * m_pEnumVDevicesList;

    DWORD m_dwNumADevices;
    EnumDeviceInfo * m_pEnumADevicesList;

    // This flags is used for OverLayMixer enable devices that
    // must start preview before it can read its capture pin,
    // like BT829 (VideoPortPin) but not sure about BT848 (PreviewPin+VIHdr2)
    BOOL m_bUseOVMixer;
    BOOL m_bNeedStartPreview;
    BOOL BuildWDMDevicePeviewGraph();

    BOOL m_bOverlayOn;   // StreamInit: TRUE;  StreamFini: FALSE



    //
    // Local Streaming methods
    //
    CStreamingThread * m_pStreamingThread;
    VIDEO_STREAM_INIT_PARMS m_VidStrmInitParms;

    BOOL m_bVideoInStarted;


    //
    // Cache AVICAP client client window handle
    //
    HWND m_hAvicapClient;


public:

    BOOL m_bVideoInStopping;  // Set this while stopping to prevent DVM_FRAME

    void Init();

    // Could be called from Capture loop (talkth.cpp)
    void videoCallback(WORD msg, DWORD_PTR dw1);

    DWORD SetFrameRate(DWORD dwMicroSecPerFrame);

    // When a new driver is added, a new pin should be created as well.  E-Zu
    BOOL OpenThisDriverAndPin(TCHAR * pszSymbolicLink);

    BOOL OpenDriverAndPin();
    BOOL CloseDriverAndPin();

    //
    // To do with getting the image, setting the destinatino buffer for the image etc.
    //


    // DVM_STREAM_*
    DWORD VideoStreamInit(LPARAM lParam1, LPARAM lParam2);
    DWORD VideoStreamFini();
    DWORD VideoStreamStart(UINT cntVHdr, LPVIDEOHDR lpVHdrHead);
    DWORD VideoStreamStop();
    DWORD VideoStreamReset();
    DWORD VideoStreamGetError(LPARAM lParam1, LPARAM lParam2);
    DWORD VideoStreamGetPos(LPARAM lParam1, LPARAM lParam2);

    CVFWImage(BOOL bUse16BitBuddy);
    ~CVFWImage();


    //
    // Deal with the device list
    //
    EnumDeviceInfo * GetCacheDevicesList() { return m_pEnumVDevicesList;}
    DWORD GetCacheDevicesCount() { return m_dwNumVDevices;}

    //
    // Graph related:
    //
    BOOL ReadyToReadData(HWND hClsCapWin);

    BOOL UseOVMixer() {return m_bUseOVMixer;}

    HWND GetAvicapWindow() {return m_hAvicapClient;}

    BOOL IsOverlayOn() {return m_bOverlayOn;}
    VOID SetOverlayOn(BOOL bState) {m_bOverlayOn = bState;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\volctrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ksproxy.rc
//
#define IDD_VOLPROP                     101
#define IDS_NAME                        102
#define IDD_ROUTEDIALOG                 103
#define IDD_PINDIALOG                   199
#define IDC_FORMATLIST                  1003
#define IDC_FORMATTREE                  1005
#define IDC_DATAROUTE                   1006
#define IDS_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\vfw\raytube\wnd.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ImgCls.h

Abstract:

    Header file for Wnd.cpp   
       must derive a class from this and over-ride the WindowProc

Author:
    
    FelixA 1996

Modified:
               
    Yee J. Wu (ezuwu) 15-May-97

Environment:

    User mode only

Revision History:

--*/


#ifndef _MYWINDOWH
#define _MYWINDOWH

#define MAX_APPNAME_LEN 64


class CWindow
{
public:
    CWindow() : mDidWeInit(FALSE), mWnd(NULL) {}
    // ERROR_SINGLE_INSTANCE_APP - instance already running.
    // ERROR_CLASS_ALREADY_EXISTS - failed to register class.
    // ERROR_INVALID_WINDOW_HANDLE - couldn't create the window of said class.
    // S_OK - managed to register the class.
    HRESULT Init(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);

    ~CWindow();
    HINSTANCE  GetInstance()    const {return mInstance;}
    HICON      GetIcon()        const {return mIcon;}
    BOOL       Inited()        const { return mDidWeInit; }
    HACCEL     GetAccelTable() const { return mAccelTable; }
    LPCTSTR     GetAppName()    const { return (LPCTSTR)mName; }
    HWND       GetWindow()        const { return mWnd; }

    HMENU      LoadMenu(LPCTSTR lpMenu)    const;
    HWND       FindCurrentWindow() const;
#if 0
    int        ErrMsg(int id, UINT flags=MB_OK);
#endif
    virtual LRESULT        WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)=0;

    // S_OK or any error that Init returns.
    virtual    HRESULT        InitInstance(int nCmdShow);

private:
    HRESULT    InitApplication();

private:
    HINSTANCE  mInstance;
    HICON      mIcon;
    BOOL       mDidWeInit;
    HACCEL     mAccelTable;
    TCHAR       mName[MAX_APPNAME_LEN];
    HWND       mWnd;

protected:
    static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\volctrl\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by timesw.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\volctrl\volctrl.h ===
#ifndef __VOLCTRL_H__
#define __VOLCTRL_H__

class CAdviseHolder; // forward declaration

class CVolumeControl : public CBasicAudio, public ISpecifyPropertyPages, public IKsFilterExtension
{
public:
    CVolumeControl(
        TCHAR *pName, 
        LPUNKNOWN pUnk, 
        HRESULT *phr
        );
    ~CVolumeControl(
        );
    STDMETHODIMP 
    NonDelegatingQueryInterface(
        REFIID riid, 
        void **ppv
        );
    STDMETHODIMP 
    QueryInterface(
        REFIID riid, 
        void **ppv
        );
    STDMETHODIMP_(ULONG) 
    AddRef(
        );
    STDMETHODIMP_(ULONG) 
    Release(
        );
    // IBasicAudio interface functions
    STDMETHODIMP 
    get_Volume(
        long *plVolume
        ); 
    STDMETHODIMP 
    put_Volume(
        long lVolume
        );
    STDMETHODIMP 
    get_Balance(
        long *plBalance
        );
    STDMETHODIMP 
    put_Balance(
        long lBalance
        );   
    // IDispatch interface functions
    STDMETHODIMP 
    GetTypeInfoCount(
        unsigned int *pctInfo
        );
    STDMETHODIMP 
    GetTypeInfo(unsigned int itInfo, 
        LCID lcid, 
        ITypeInfo **pptInfo
        );
    STDMETHODIMP 
    GetIDsOfNames(
        REFIID riid, 
        OLECHAR **rgszNames, 
        UINT cNames, 
        LCID lcid, 
        DISPID *rgdispid
        );
    STDMETHODIMP 
    Invoke(
        DISPID dispID, 
        REFIID riid, 
        LCID lcid,
        unsigned short wFlags, 
        DISPPARAMS *pDispParams,
        VARIANT *pVarResult, 
        EXCEPINFO *pExcepInfo,
        unsigned int  *puArgErr
        );
    
    // ISpecifyPropertyPages interface function
    STDMETHODIMP 
    GetPages(
        CAUUID * pPages
        );

    // IKsFilterExtension interface function
    STDMETHODIMP 
    KsPinNotify(
        int NotifyType,
        IKsPin *pKsPin,
        REFERENCE_TIME tStart
        );

protected:
    BOOL 
    isVolumeControlSupported(
        );

    BOOL 
    KsControl(
        HANDLE hDevice,
        DWORD dwIoControl,
        PVOID pvIn,
        ULONG cbIn,
        PVOID pvOut,
        ULONG cbOut,
        PULONG pcbReturned,
        BOOL fSilent
        );



    ULONG m_cRef;
    IUnknown *m_pUnkOuter;    // outer unknown
    HANDLE m_hKsPin;
    IKsPin *m_pKsPin;

    ITypeInfo *m_pITI;         // Type information
    WORD m_wLeft;           // left speaker
    WORD m_wRight;        // right speaker
    DWORD m_dwWaveVolume;  // wave device
    DWORD m_dwBalance;     // balance information
};

class CVolumeController : public CUnknown
{
public:
    STDMETHODIMP
    NonDelegatingQueryInterface(
        REFIID, 
        void **
        );
    STDMETHODIMP
    QueryInterface(
        REFIID, 
        void **
        );
    STDMETHODIMP_(ULONG) 
    NonDelegatingAddRef(
        void
        );
    STDMETHODIMP_(ULONG) 
    AddRef(
        void
        );
    STDMETHODIMP_(ULONG) 
    NonDelegatingRelease(
        void
        );    
    STDMETHODIMP_(ULONG) 
    Release(
        void
        ); 
    static CUnknown *
    CreateInstance(
        LPUNKNOWN punk, 
        HRESULT *hr
        );
    CVolumeController(
        LPUNKNOWN pUnkOuter, 
        HRESULT *phr
        );
    ~CVolumeController(
        );
    BOOL Init(
        );
private:
    ULONG m_cRef;
    IUnknown *m_pUnkOuter;                 // controlling unknown
    CVolumeControl *m_pCVol;
};


inline void ODS(char *szFormat, long lp1, long lp2)
{
    char buff[1024];

    sprintf(buff, szFormat, lp1, lp2);
    MessageBox(NULL, buff, "Debug Message", NULL);
}

// General purpose functions to convert from decibels to 
// amplitude and vice versa as well as symbolic consts

#define MAX_VOLUME_AMPLITUDE                            0xFFFFFFFFUL
#define MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL 0xFFFFUL
#define MIN_VOLUME_AMPLITUDE                            0x00000000UL
#define MIN_VOLUME_AMPLITUDE_SINGLE_CHANNEL 0x0000UL

// Maximum and minimum attenuations we can handle. Note that
// since 0xFFFF is taken as the reference, we can never have
// gain values.
#define MAX_DB_ATTENUATION                  10000
#define MIN_DB_ATTENUATION                  0

// Specific volume decibel limits for the SB16. In reality, this
// should be sufficient for all devices.
#define MAX_VOLUME_DB_SB16                  0
#define MIN_VOLUME_DB_SB16                  0x1F

// These 2 functions convert from 100ths of decibels to 
// amplitude values and vice versa. Slightly inappropriate
// names, but they'll do.
long DBToAmplitude(long lDB, int *nResult);
long AmplitudeToDB(long lAmp);
// bounds a value between a lower and upper bound, truncating
// if necessary
void bound(DWORD *plValToVound, DWORD dwLowerBound, DWORD dwUpperBound);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\volctrl\setdev.h ===
#ifndef __setdev_h__
#define __setdev_h__

#ifdef __cplusplus
extern "C"
{
#endif 

#ifndef __IDeviceIoControl_FWD_DEFINED__
#define __IDeviceIoControl_FWD_DEFINED__
typedef interface IDeviceIoControl IDeviceIoControl;
#endif  /* __IDeviceIoControl_FWD_DEFINED__ */


#ifndef __ISetDevCtrlInterface_FWD_DEFINED__
#define __ISetDevCtrlInterface_FWD_DEFINED__
typedef interface ISetDevCtrlInterface ISetDevCtrlInterface;
#endif  /* __ISetDevCtrlInterface_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifndef __IDeviceIoControl_INTERFACE_DEFINED__
#define __IDeviceIoControl_INTERFACE_DEFINED__

EXTERN_C const IID IID_IDeviceIoControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDeviceIoControl : public IUnknown
    {
    public:
        virtual HRESULT __stdcall KsControl( 
            /* [in] */ DWORD dwIoControlCode,
            /* [in] */ void  *lpInBuffer,
            /* [in] */ DWORD nInBufferSize,
            /* [out][in] */ void  *lpOutBuffer,
            /* [in] */ DWORD nOutBufferSize,
            /* [out] */ LPDWORD lpBytesReturned) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDeviceIoControlVtbl
    {
        
        HRESULT ( __stdcall  *QueryInterface )( 
            IDeviceIoControl  * This,
            /* [in] */ REFIID riid,
            /* [out] */ void  * *ppvObject);
        
        ULONG ( __stdcall  *AddRef )( 
            IDeviceIoControl  * This);
        
        ULONG ( __stdcall  *Release )( 
            IDeviceIoControl  * This);
        
        HRESULT ( __stdcall  *KsControl )( 
            IDeviceIoControl  * This,
            /* [in] */ DWORD dwIoControlCode,
            /* [in] */ void  *lpInBuffer,
            /* [in] */ DWORD nInBufferSize,
            /* [out][in] */ void  *lpOutBuffer,
            /* [in] */ DWORD nOutBufferSize,
            /* [out] */ LPDWORD lpBytesReturned);
        
    } IDeviceIoControlVtbl;

    interface IDeviceIoControl
    {
        CONST_VTBL struct IDeviceIoControlVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceIoControl_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDeviceIoControl_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDeviceIoControl_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDeviceIoControl_KsControl(This,dwIoControlCode,lpInBuffer,nInBufferSize,lpOutBuffer,nOutBufferSize,lpBytesReturned)    \
    (This)->lpVtbl -> KsControl(This,dwIoControlCode,lpInBuffer,nInBufferSize,lpOutBuffer,nOutBufferSize,lpBytesReturned)

#endif /* COBJMACROS */


#endif  /* C style interface */



#endif  /* __IDeviceIoControl_INTERFACE_DEFINED__ */


#ifndef __ISetDevCtrlInterface_INTERFACE_DEFINED__
#define __ISetDevCtrlInterface_INTERFACE_DEFINED__

EXTERN_C const IID IID_ISetDevCtrlInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISetDevCtrlInterface : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetDevCtrlInterface( 
            /* [in] */ IDeviceIoControl  *pID) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ISetDevCtrlInterfaceVtbl
    {
        
        HRESULT ( __stdcall  *QueryInterface )( 
            ISetDevCtrlInterface  * This,
            /* [in] */ REFIID riid,
            /* [out] */ void  * *ppvObject);
        
        ULONG ( __stdcall  *AddRef )( 
            ISetDevCtrlInterface  * This);
        
        ULONG ( __stdcall  *Release )( 
            ISetDevCtrlInterface  * This);
        
        HRESULT ( __stdcall  *SetDevCtrlInterface )( 
            ISetDevCtrlInterface  * This,
            /* [in] */ IDeviceIoControl  *pID);
        
    } ISetDevCtrlInterfaceVtbl;

    interface ISetDevCtrlInterface
    {
        CONST_VTBL struct ISetDevCtrlInterfaceVtbl  *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISetDevCtrlInterface_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISetDevCtrlInterface_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISetDevCtrlInterface_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISetDevCtrlInterface_SetDevCtrlInterface(This,pID)  \
    (This)->lpVtbl -> SetDevCtrlInterface(This,pID)

#endif /* COBJMACROS */


#endif  /* C style interface */


#endif  /* __ISetDevCtrlInterface_INTERFACE_DEFINED__ */


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\volctrl\volctrl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    volctrl.cpp

Abstract:
    Implements the IBasicAudio control functions which 
    handle volume control on an audio device using 
    DeviceIoControl calls.
    Also implements the CVolumeController class which is
    used to support the aggregation capabilities of the
    CVolumeControl object

    
Author:
    
    Thomas O'Rourke (tomor) 22-May-1996

Environment:

    user-mode


Revision History:


--*/
#include <streams.h>
#include <devioctl.h>
#include <initguid.h>
#include "ksguid.h"
#include <ks.h>
#include <ksmedia.h>
#include <wtypes.h>
#include <oaidl.h>
#include <ctlutil.h>
#include <ikspin.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <math.h>
#include "resource.h"
#include "volprop.h"
#include <olectlid.h>
#include "volctrl.h"
#include "kspguids.h"

CFactoryTemplate g_Templates[] = 
{
    {L"Volume Control Object",      &CLSID_VolumeControlObject, CVolumeController::CreateInstance },
    {L"Volume Control Properties",  &CLSID_VolumeControlProp,   CVolumeControlProperties::CreateInstance },
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);              

// Constructor  
CVolumeControl::CVolumeControl(
    TCHAR *pName, 
    LPUNKNOWN pUnk, 
    HRESULT *phr
    ) :
        CBasicAudio(
            pName, 
            pUnk, 
            phr
            ),
        m_pITI(NULL),
        m_cRef(0),
        m_pUnkOuter(pUnk),
        m_wRight(0),
        m_wLeft(0),
        m_dwWaveVolume(0),
        m_dwBalance(0),
        m_hKsPin(NULL),
        m_pKsPin(NULL)
{
}

// Destructor 
CVolumeControl::~CVolumeControl()
{
    if(m_pKsPin){
        m_pKsPin->Release();
        m_pKsPin = NULL;
    }
}

STDMETHODIMP 
CVolumeControl::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    return m_pUnkOuter-> QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) 
CVolumeControl::AddRef(
    )
{
    ++m_cRef;
    return m_pUnkOuter -> AddRef();
}

STDMETHODIMP_(ULONG) 
CVolumeControl::Release(
    )
{
    --m_cRef;
    return m_pUnkOuter -> Release();
}

STDMETHODIMP 
CVolumeControl::NonDelegatingQueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    if (riid == IID_IDispatch){
        return GetInterface((IDispatch *) this, ppv);
    } else if (riid == IID_IBasicAudio) {
        return GetInterface((IBasicAudio *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (riid == IID_IKsFilterExtension) {
        return GetInterface((IKsFilterExtension *) this, ppv);
    } else {  
        return CBasicAudio::NonDelegatingQueryInterface(riid, ppv);
    }
}

// This should be in a library, or helper object
BOOL 
CVolumeControl::KsControl(
    HANDLE hDevice,
    DWORD dwIoControl,
    PVOID pvIn,
    ULONG cbIn,
    PVOID pvOut,
    ULONG cbOut,
    PULONG pcbReturned,
    BOOL fSilent
    )
{
   BOOL fResult;
   OVERLAPPED ov;

   RtlZeroMemory( &ov, sizeof(OVERLAPPED));
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ))){
      return FALSE ;
   }

   fResult =
      DeviceIoControl( hDevice,
                       dwIoControl,
                       pvIn,
                       cbIn,
                       pvOut,
                       cbOut,
                       pcbReturned,
                       &ov ) ;


   if (!fResult){
      if (ERROR_IO_PENDING == GetLastError()){
         WaitForSingleObject(ov.hEvent, INFINITE) ;
         fResult = TRUE ;
      } else {
         fResult = FALSE ;
         if(!fSilent){
            MessageBox(NULL, "DeviceIoControl", "Failed", MB_OK);
         }
      }
   }

   CloseHandle(ov.hEvent) ;
   return fResult ;
}


STDMETHODIMP 
CVolumeControl::get_Volume(
    long *plVolume
    )
{
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME KsWaveVolume;
    DWORD cbBytesReturned;
    int nRes;
    BOOL bIOCallResult;

    if(!m_hKsPin){
        return E_FAIL;
    }

    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_GET;

    bIOCallResult = KsControl(
                        m_hKsPin,
                        (DWORD) IOCTL_KS_PROPERTY,                 // get prop
                        &KsProperty,                           // apt parameters
                        sizeof(KsProperty),
                        &KsWaveVolume,                         // output buffer pointer,
                        sizeof(KsWaveVolume),                  // and its size
                        &cbBytesReturned,
                        FALSE);

    if (bIOCallResult == FALSE){
        return E_FAIL; // unspecified failure -- for now
    }

    // The volume is returned in the ksWaveVolume structure, 
    // as decibel attenuations from the device volume. Convert 
    // them to left and right speaker values like we're used to 
    // and like waveOutGetVolume returns.
    m_wLeft        = (WORD) DBToAmplitude(KsWaveVolume.LeftAttenuation, &nRes); // let's ignore the return value
    m_wRight       = (WORD) DBToAmplitude(KsWaveVolume.RightAttenuation, &nRes);// function bounds values anyway
    m_dwWaveVolume = ((DWORD) m_wRight << (DWORD) (sizeof(WORD) * 8L)) + m_wLeft;
    
    // this is the volume we return -- the larger of the 2 speaker values. 
    // Notice that this in decibels rather than the familiar one we're used 
    // to. Since smaller attenuations mean larger amplitudes, we have the 
    // unusual min function here
    *plVolume = min(KsWaveVolume.LeftAttenuation, KsWaveVolume.RightAttenuation);
    // Bound this, just in case.
    bound((DWORD *) plVolume, MAX_VOLUME_DB_SB16, MIN_VOLUME_DB_SB16);
    // The balance is as below. 
    m_dwBalance = KsWaveVolume.LeftAttenuation - KsWaveVolume.RightAttenuation;
    // Same bound here as well 
    bound(&m_dwBalance, MAX_VOLUME_DB_SB16, MIN_VOLUME_DB_SB16);
    //  ODS("CKSProxy::get_Volume %ld %ld", *plVolume, 0L);
    return NOERROR;
}

STDMETHODIMP 
CVolumeControl::put_Volume(
    long lVolume
    )
{
    // This will be a DeviceIoControl put property call.
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME KsWaveVolume;
    DWORD cbBytesReturned;
    int nRes;
    BOOL bIOCallResult;

    if(!m_hKsPin){
        return E_FAIL;
    }

    // These values should be attenuation values wrt reference volume and balance
    // We should remember to bound them ...
    KsWaveVolume.LeftAttenuation  = lVolume;
    bound((DWORD *) &KsWaveVolume.LeftAttenuation, MAX_VOLUME_DB_SB16, MIN_VOLUME_DB_SB16);
    KsWaveVolume.RightAttenuation = max(lVolume - m_dwBalance, 0);
    bound((DWORD *) &KsWaveVolume.RightAttenuation, MAX_VOLUME_DB_SB16, MIN_VOLUME_DB_SB16);

    // Get the actual wave and speaker volume values.
    m_wLeft  = (WORD) DBToAmplitude(KsWaveVolume.LeftAttenuation,  &nRes);
    m_wRight = (WORD) DBToAmplitude(KsWaveVolume.RightAttenuation, &nRes);
    m_dwWaveVolume = max(m_wLeft, m_wRight);

    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_SET;

    bIOCallResult = KsControl(
                        m_hKsPin,
                        IOCTL_KS_PROPERTY,                  // set prop
                        &KsProperty,                                   
                        sizeof(KsProperty),
                        &KsWaveVolume,                                 // output buffer pointer,
                        sizeof(KsWaveVolume),                  // and its size
                        &cbBytesReturned,
                        FALSE);

    if (bIOCallResult == FALSE){
        return E_FAIL;   // unspecified failure -- for now
    }
    //  ODS("CKSProxy::put_Volume %ld %ld", lVolume, 0);
    return NOERROR;
}

STDMETHODIMP 
CVolumeControl::get_Balance(
    long *plBalance
    ) 
{ 
    long lVol;
    HRESULT hr;

    hr = get_Volume(&lVol);
    if (FAILED(hr)){
        return hr;
    }
    *plBalance = m_dwBalance; // that's really it.
    //  ODS("CKSProxy::get_Balance %ld %ld", *plBalance, 0);
    return NOERROR; 
}

STDMETHODIMP 
CVolumeControl::put_Balance(
    long lBalance
    )   
{ 
    long lVol;
    
    //  ODS("CKSProxy::put_Balance %ld %ld", lBalance, 0);
    m_dwBalance = lBalance; // set the desired balance 
    get_Volume(&lVol);              // get the present volume 
    // set the volume, so that 
    //      a. The present volume doesn't change.
    //      b. We get a new balance as required.
    return put_Volume(lVol);                
}

// IDispatch interface functions
STDMETHODIMP 
CVolumeControl::GetTypeInfoCount(
    unsigned int *pctInfo
    ) 
{ 
    *pctInfo = 1;
    return NOERROR;
}
    
STDMETHODIMP 
CVolumeControl::GetTypeInfo(
    unsigned int itInfo,
    LCID lcid, 
    ITypeInfo **pptInfo
    )
{ 
    HRESULT   hr;
    ITypeLib  *pITypeLib;
    ITypeInfo **ppITI = &m_pITI;
    static wchar_t   *lpszTLBFileName = L"VOLCTRL.TLB";

    if (itInfo != 0){
        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);
    }
    if (pptInfo == NULL){
        return ResultFromScode(E_POINTER);
    }

    *pptInfo=NULL;

    if (*ppITI == NULL) {
        // Try to load from registry information
        hr = LoadRegTypeLib(LIBID_VolumeControl, 1, 0, 
                            PRIMARYLANGID(lcid), &pITypeLib);
        if (FAILED(hr)){
            // failed, try direct name 
            hr = LoadTypeLib(lpszTLBFileName, &pITypeLib);
        }
        // no dice, we can't continue.
        if (FAILED(hr)){
            return hr;
        }
        
        // get type info
        hr = pITypeLib -> GetTypeInfoOfGuid(IID_IBasicAudio, ppITI);
        m_pITI = *ppITI;
        pITypeLib -> Release();
        if (FAILED(hr)){
            return hr;
        }
    }
    // already loaded, inc refcount, and we're done
    (*ppITI) -> AddRef();
    *pptInfo = *ppITI;
    return NOERROR;
}

STDMETHODIMP 
CVolumeControl::GetIDsOfNames(
    REFIID riid,
    OLECHAR **rgszNames, 
    UINT cNames, 
    LCID lcid, 
    DISPID *rgdispid
    )
{ 
    HRESULT   hr;
    ITypeInfo *pTI;

    if (riid != IID_NULL) {
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);
    }

    hr = GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr)){
        hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgdispid);
        pTI->Release();
    }
    return hr;
}

STDMETHODIMP 
CVolumeControl::Invoke(
    DISPID dispID, 
    REFIID riid, 
    LCID lcid, 
    unsigned short wFlags, 
    DISPPARAMS *pDispParams,
    VARIANT *pVarResult, 
    EXCEPINFO *pExcepInfo,
    unsigned int *puArgErr
    )
{ 
    HRESULT     hr;
    ITypeInfo  *pTI;
    LANGID      langID=PRIMARYLANGID(lcid);

    //riid is supposed to be IID_NULL always
    if (riid != IID_NULL){
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);
    }

    //Get the ITypeInfo for lcid
    hr=GetTypeInfo(0, lcid, &pTI);

    if (FAILED(hr)){
        return hr;
    }
    //Clear exceptions
    SetErrorInfo(0L, NULL);
    DispInvoke((IBasicAudio *)this, pTI, dispID, wFlags, 
                pDispParams, pVarResult, pExcepInfo, puArgErr);
    pTI->Release();
    return hr;
}


// ISpecifyPropertyPages interface function
STDMETHODIMP 
CVolumeControl::GetPages(
    CAUUID * pPages
    ) 
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID) * pPages->cElems);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_VolumeControlProp;

    return NOERROR;
} // GetPages

STDMETHODIMP 
CVolumeControl::KsPinNotify(
    int NotifyType,
    IKsPin *pKsPin,
    REFERENCE_TIME tStart
    )
/*++
    #define KSPIN_NOTIFY_CREATION 1
    This message tells us that the filter has created a pin and exposed it to the world.

    #define KSPIN_NOTIFY_CONNECTION 2
    This message tells us the pin has been successfully connected. We take this opportunity
    to see if it was an input pin, and then to see if it has volume control capability.
    If so we remember the handle to the pin.
--*/
{
    switch (NotifyType) {
    case KSPIN_NOTIFY_CREATION:
        break;
    case KSPIN_NOTIFY_CONNECTION:
        // Already have the volume pin...
        if(m_hKsPin != NULL){
            return NOERROR;
        }

        if(pKsPin == NULL)
            return E_FAIL;

        pKsPin->KsGetPinHandle(&m_hKsPin);

        // See if it has volume

        if(isVolumeControlSupported()) {
            m_pKsPin = pKsPin;
            pKsPin->AddRef();
        } else {
            m_hKsPin = NULL;
        }
        break;
    }

    return NOERROR;
}


BOOL 
CVolumeControl::isVolumeControlSupported()
/*++

Returns true if the handle to the pin supports volume changes
and false if not

--*/
{             
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME Volume;
    ULONG cbReturned;

    if(!m_hKsPin){
        return FALSE;
    }

    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_GET;

    // Just try to get the volume and see if it succeeds.

    if (KsControl(
        m_hKsPin, 
        IOCTL_KS_PROPERTY, 
        &KsProperty,
        sizeof(KsProperty), 
        &Volume,
        sizeof(Volume), 
        &cbReturned,
        TRUE
        )) {
        return TRUE;
    } else {
        return FALSE;
    }
}


long 
DBToAmplitude(
    long lDB, 
    int *nResult
    )
/*++ 

This function is passed a value that is in decibels We 
convert this to a amplitude value and return  it. We do 
error checking on the parameter to make sure that it is not
more than we want to handle.

--*/
{
    double lfAmp;

    if (lDB < MAX_VOLUME_DB_SB16){
        *nResult = -1;
        return MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL;
    }
    if (lDB > MIN_VOLUME_DB_SB16){
        *nResult = -1;
        return MIN_VOLUME_AMPLITUDE_SINGLE_CHANNEL;
    }
    lfAmp = MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL / pow(2.0, (double) lDB / 6);
    *nResult = 0;
    return (long) lfAmp;
}

long 
AmplitudeToDB(
    long lAmp
    )
/*++ 

This function is passed a volume amplitude value that it converts 
into decibel attenuation according to the rule, MAX_VOLUME = 0DB. 
The lowest attenuation possible is set to MAX_DB_ATTENUATION, so any volume 
amplitudes that are higher than this are arbitrarily chopped to MAX_DB_ATTENUATION
implicitly. 

 --*/
{
    if (lAmp == 0){
        return MAX_DB_ATTENUATION;
    }
    double lfDB = (log(MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL / lAmp) / log(2)) * 6;

    if (lfDB >= 100.0){
        lfDB = 100.0;
    }
    return (long) lfDB;
}


// Bounds a value between 2 others ...
void 
bound(
    DWORD *plValToBound, 
    DWORD dwLowerBound, 
    DWORD dwUpperBound
    )
{
    if (*plValToBound < dwLowerBound){
        *plValToBound = dwLowerBound;
    }
    if (*plValToBound > dwUpperBound){
        *plValToBound = dwUpperBound;
    }
}


CVolumeController::CVolumeController(
    IUnknown *pUnkOuter, 
    HRESULT *phr
    ) :
    CUnknown(
        NAME("Volume Controller"), 
        pUnkOuter, 
        phr
        )
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
}

CVolumeController::~CVolumeController()
{
    if (m_pCVol){
        delete m_pCVol;
        m_pCVol = NULL;
    }
}

BOOL 
CVolumeController::Init()
{
    HRESULT hr;

    IUnknown *pUnkOuter = m_pUnkOuter;

    if (pUnkOuter == NULL){
        pUnkOuter = (IUnknown *) this;
    }
    m_pCVol = new CVolumeControl(NAME("WDM Volume Control"), pUnkOuter, &hr);

    if (m_pCVol == NULL){
        return FALSE;
    }
    return TRUE;
}

HRESULT 
CVolumeController::NonDelegatingQueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    return QueryInterface(riid, ppv);
}


HRESULT 
CVolumeController::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    *ppv = NULL;

    if (riid == IID_IUnknown){
        *ppv = this;
        ((LPUNKNOWN) *ppv)->AddRef();
    }
    if (riid == IID_IBasicAudio || riid == IID_ISpecifyPropertyPages || 
        riid == IID_IDispatch  || riid == IID_IKsFilterExtension){
        m_pCVol->NonDelegatingQueryInterface(riid, ppv);
    }
    if (*ppv == NULL){
        return ResultFromScode(E_NOINTERFACE);
    }
    return NOERROR;
}

ULONG 
CVolumeController::NonDelegatingAddRef()
{
    return AddRef();
}


ULONG 
CVolumeController::AddRef()
{
    return ++m_cRef;
}

ULONG 
CVolumeController::NonDelegatingRelease()
{
    return Release();
}

ULONG 
CVolumeController::Release()
{
    if (--m_cRef != 0){
        return m_cRef;
    }
    // This is our signal to delete the volume also (see destructor for it)
    // It doesn't matter what our ref count on that object
    // is since the parent should have released it already
    delete this;
    return 0;
}

CUnknown *
CVolumeController::CreateInstance(
    LPUNKNOWN punk, 
    HRESULT *phr
    )
{
    CVolumeController *pCV = new CVolumeController(punk, phr);

    if (pCV == NULL){
        return pCV;
    }
    if (!pCV -> Init()){
        return NULL;
    }
    return pCV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\camera.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    camera.h

Abstract:

    Internal header.

--*/

class CCameraControlInterfaceHandler :
    public CUnknown,
    public IAMCameraControl {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CCameraControlInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    // Implement IAMCameraControl
    STDMETHODIMP GetRange( 
            IN  long  Property,
            OUT long  *pMin,
            OUT long  *pMax,
            OUT long  *pSteppingDelta,
            OUT long  *pDefault,
            OUT long  *pCapsFlags);
        
    STDMETHODIMP Set( 
            IN long Property,
            IN long lValue,
            IN long Flags);
        
    STDMETHODIMP Get( 
            IN long Property,
            OUT long *lValue,
            OUT long *lFlags);
        
private:
    HANDLE m_ObjectHandle;
};

typedef struct {
	KSPROPERTY_DESCRIPTION	  PropertyDescription;
	KSPROPERTY_MEMBERSHEADER  MembersHeader;
	KSPROPERTY_STEPPING_LONG  SteppingLong;
} CAMERACONTROL_MEMBERSLIST;

typedef struct {
	KSPROPERTY_DESCRIPTION	  PropertyDescription;
	KSPROPERTY_MEMBERSHEADER  MembersHeader;
    ULONG                     DefaultValue;
} CAMERACONTROL_DEFAULTLIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\camera.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    camera.cpp

Abstract:

    Implements IAMCameraControl 
    via KSPROPERTY_VIDCAP_CAMERACONTROL

--*/

#include "pch.h"
#include "wdmcap.h"
#include "camera.h"



CUnknown*
CALLBACK
CCameraControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a VPE Config
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CCameraControlInterfaceHandler(UnkOuter, NAME("IAMCameraControl"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CCameraControlInterfaceHandler::CCameraControlInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) :
    CUnknown(Name, UnkOuter, hr)
/*++

Routine Description:

    The constructor for the IAMCameraControl interface object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            IKsObject*  Object;

            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
            if (SUCCEEDED(*hr)) {
                m_ObjectHandle = Object->KsGetObjectHandle();
                if (!m_ObjectHandle) {
                    *hr = E_UNEXPECTED;
                }
                Object->Release();
            }
        } else {
            *hr = VFW_E_NEED_OWNER;
        }
    }
}


STDMETHODIMP
CCameraControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMCameraControl.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IAMCameraControl)) {
        return GetInterface(static_cast<IAMCameraControl*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CCameraControlInterfaceHandler::GetRange( 
     IN  long Property,
     OUT long *pMin,
     OUT long *pMax,
     OUT long *pSteppingDelta,
     OUT long *pDefault,
     OUT long *pCapsFlags
     )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_CAMERACONTROL_S  CameraControl;
	CAMERACONTROL_MEMBERSLIST   PropertyList;
    CAMERACONTROL_DEFAULTLIST   DefaultList;
    ULONG                       BytesReturned;

    CheckPointer(pMin, E_INVALIDARG);
    CheckPointer(pMax, E_INVALIDARG);
    CheckPointer(pSteppingDelta, E_INVALIDARG);
    CheckPointer(pDefault, E_INVALIDARG);
    CheckPointer(pCapsFlags, E_INVALIDARG);

    CameraControl.Property.Set = PROPSETID_VIDCAP_CAMERACONTROL;
    CameraControl.Property.Id = Property;
    CameraControl.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
    CameraControl.Flags = 0;  

    // First get the min, max and stepping values
    if (SUCCEEDED (::SynchronousDeviceControl(
                        m_ObjectHandle,
                        IOCTL_KS_PROPERTY,
                        &CameraControl,
                        sizeof(CameraControl),
                        &PropertyList,
                        sizeof(PropertyList),
                        &BytesReturned))) {

        // ? Proper way to check return size?
        if (BytesReturned < sizeof (PropertyList)) {
            return E_PROP_ID_UNSUPPORTED;
        }

        *pMin  = PropertyList.SteppingLong.Bounds.SignedMinimum;
		*pMax  = PropertyList.SteppingLong.Bounds.SignedMaximum;
		*pSteppingDelta = PropertyList.SteppingLong.SteppingDelta;
    } 
    else {
        return E_PROP_ID_UNSUPPORTED;
    }

    // Next, get the default value
    CameraControl.Property.Set = PROPSETID_VIDCAP_CAMERACONTROL;
    CameraControl.Property.Id = Property;
    CameraControl.Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;
    CameraControl.Flags = 0; 

    if (SUCCEEDED (::SynchronousDeviceControl(
                        m_ObjectHandle,
                        IOCTL_KS_PROPERTY,
                        &CameraControl,
                        sizeof(CameraControl),
                        &DefaultList,
                        sizeof(DefaultList),
                        &BytesReturned))) {
#if 0
        // ? Proper way to check return size?
        if (BytesReturned < sizeof (DefaultList)) {
            return E_PROP_ID_UNSUPPORTED;
        }
#endif
        
        *pDefault = DefaultList.DefaultValue;
    }
    else {
        return E_PROP_ID_UNSUPPORTED;
    }

    // Finally, get the capabilities by reading the current
    // value

    CameraControl.Property.Set = PROPSETID_VIDCAP_CAMERACONTROL;
    CameraControl.Property.Id = Property;
    CameraControl.Property.Flags = KSPROPERTY_TYPE_GET;
    CameraControl.Flags = 0;

    if (SUCCEEDED (::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &CameraControl,
                sizeof(CameraControl),
                &CameraControl,
                sizeof(CameraControl),
                &BytesReturned))) {

        *pCapsFlags = CameraControl.Capabilities;
    }
    else {
        return E_PROP_ID_UNSUPPORTED;
    }
        
    return S_OK;
}


STDMETHODIMP
CCameraControlInterfaceHandler::Set(
     IN long Property,
     IN long lValue,
     IN long lFlags
     )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_CAMERACONTROL_S  CameraControl;
    ULONG       BytesReturned;

    CameraControl.Property.Set = PROPSETID_VIDCAP_CAMERACONTROL;
    CameraControl.Property.Id = Property;
    CameraControl.Property.Flags = KSPROPERTY_TYPE_SET;
    CameraControl.Value = lValue;
    CameraControl.Flags = lFlags;
    CameraControl.Capabilities = 0;

    return ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &CameraControl,
                sizeof(CameraControl),
                &CameraControl,
                sizeof(CameraControl),
                &BytesReturned);
}


STDMETHODIMP
CCameraControlInterfaceHandler::Get( 
     IN long Property,
     OUT long *lValue,
     OUT long *lFlags
     )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_CAMERACONTROL_S  CameraControl;
    ULONG       BytesReturned;
    HRESULT     hr;

    CheckPointer(lValue, E_INVALIDARG);
    CheckPointer(lFlags, E_INVALIDARG);
    
    CameraControl.Property.Set = PROPSETID_VIDCAP_CAMERACONTROL;
    CameraControl.Property.Id = Property;
    CameraControl.Property.Flags = KSPROPERTY_TYPE_GET;
    CameraControl.Flags = 0;

    hr = ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &CameraControl,
                sizeof(CameraControl),
                &CameraControl,
                sizeof(CameraControl),
                &BytesReturned);

    if (SUCCEEDED (hr)) {
        *lValue = CameraControl.Value;
        *lFlags = CameraControl.Flags;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\volctrl\volprop.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    volprop.cpp

Abstract:

    Provides a generic Active Movie wrapper for a kernel mode filter (WDM-CSA).

Author:
    
    Thomas O'Rourke (tomor) 22-May-1996

Environment:

    user-mode


Revision History:


--*/
#include <streams.h>
#include <devioctl.h>
#include <ks.h>
#include <ikspin.h>
#include <wtypes.h>
#include <oaidl.h>
#include <ctlutil.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <math.h>
#include "resource.h"
#include "volprop.h"
#include <olectlid.h>
#include "volctrl.h"

//
// CreateInstance
//
//
CUnknown *CVolumeControlProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CVolumeControlProperties(lpunk, phr);
    if (punk == NULL) {
    *phr = E_OUTOFMEMORY;
    }
    return punk;
} // Createinstance


//
// CVolumeControlProperties::Constructor
//
// initialise a CVolumeControlProperties object.
CVolumeControlProperties::CVolumeControlProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage( NAME("Volume Control Property Page")
               , lpunk, phr, IDD_VOLPROP, IDS_NAME)
    , m_pBasicAudio(NULL)
    , m_iVolume(0)
    , m_hVolumeSupported(E_FAIL)
{
} // (constructor)


inline double log2(double x) { return log10(x) / log10(2); }

// Convert f (the volume value) to a slider position
// f runs from 0 to MIN_VOLUME_DB_SB16.
// p runs from 0 to 400.
// p = 100*(log2(f)-1)
int ConvertToPosition(int f)
{
    if (f < 1) return 0;
    // protect against errors - should not occur
    if (f > MIN_VOLUME_DB_SB16) f = MIN_VOLUME_DB_SB16;
    double x = f;
    x = 100.0 * (log2(x) - 1);
    // protect against rounding at the ends
    int p = (int) x;
    if (p < 0) p = 0;
    if (p > 400) p = 400;
    return p;
}


// Convert a slider position p to a volume value
// f runs from 0 to MIN_VOLUME_DB_SB16.
// p runs from 0 to 400.
// f = 2**(p/100 + 1)
int ConvertToDecibels(int p)
{
    if (p <= 0) return MAX_VOLUME_DB_SB16;
    // protect against errors - should not occur
    if (p > 400) p = 400;

    double x = p;
    x = pow(2, (x / 100) + 1);

    // protect against rounding at the ends
    int f = (int) x;
    if (f < MAX_VOLUME_DB_SB16) f = MAX_VOLUME_DB_SB16;
    if (f > MIN_VOLUME_DB_SB16) f = MIN_VOLUME_DB_SB16;

    return f;
}



BOOL CVolumeControlProperties::OnReceiveMessage
                (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (uMsg) {
    case WM_INITDIALOG:
        m_hwndSlider = CreateSlider(hwnd);
#ifdef DEBUG
        ASSERT(m_hwndSlider);
#endif
        return TRUE;    // I don't call setfocus...

    case WM_VSCROLL:
#ifdef DEBUG
        ASSERT(m_hwndSlider);
#endif
        OnSliderNotification(wParam);
        return TRUE;
    case WM_DESTROY:
        DestroyWindow(m_hwndSlider);
        return TRUE;

    default:
        return FALSE;

    }

} // OnReceiveMessage



//
// OnConnect
//
HRESULT CVolumeControlProperties::OnConnect(IUnknown * punk)
{
    //
    // Get IBasicAudio interface
    //

    if (m_pBasicAudio) // already initialized.
        return NOERROR;

    if (punk == NULL) 
    {
        DbgBreak("You can't call me with a NULL pointer!!");
        return(E_POINTER);
    }

    HRESULT hr = punk->QueryInterface(IID_IBasicAudio, (void **) &m_pBasicAudio);
    if (FAILED(hr)) {
        DbgBreak("Can't get IBasicAudio interface.");
        return E_NOINTERFACE;
    }

#ifdef DEBUG
    ASSERT(m_pBasicAudio);
#endif

    m_hVolumeSupported = m_pBasicAudio->get_Volume(&m_iVolume);
    return NOERROR;
} // OnConnect


//
// OnDisconnect
//
HRESULT CVolumeControlProperties::OnDisconnect()
{
    //
    // Release the interface
    //
    if (m_pBasicAudio == NULL) {
    return( E_UNEXPECTED);
    }

    m_pBasicAudio->Release();
    m_pBasicAudio = NULL;

    return(NOERROR);
} // OnDisconnect



//
// OnDeactivate
//
// Destroy the dialog
HRESULT CVolumeControlProperties::OnDeactivate(void) {

    //
    // Remember the volume value for the next Activate() call
    //
    m_pBasicAudio->get_Volume(&m_iVolume);
    return NOERROR;
} // OnDeactivate



//
// CreateSlider
//
// Create the slider (common control) to allow the user to
// adjust the volume rate
HWND CVolumeControlProperties::CreateSlider(HWND hwndParent)
{

    LONG XUnit = GetDialogBaseUnits();
    LONG YUnit = XUnit>>16;
    XUnit = XUnit & 0x0000ffff;

    HWND hwndSlider = CreateWindow( TRACKBAR_CLASS
                  , TEXT("")
                  , WS_CHILD | WS_VISIBLE | TBS_VERT | TBS_BOTH
                  , 15*XUnit          // x
                  , 0                 // y
                  , 5*XUnit           // width
                  , 5*YUnit           // Height
                  , hwndParent
                  , NULL              // menu
                  , g_hInst
                  , NULL              // CLIENTCREATESTRUCT
                  );
    if (hwndSlider == NULL) {
    DWORD dwErr = GetLastError();
    DbgLog((LOG_ERROR, 1
           , TEXT("Could not create window.  error code: 0x%x"), dwErr));
    return NULL;
    }

    // Set the Range
    SendMessage(hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(0, 400) );

    // The range is 0..400 which is converted into db 
    // where p is the slider position.  SeeConvertToDecibels() above.

    // This is how to set a tick at the default of 8db
    // which corresponds to 200 on the log scale.
    // we put another one at 16 db which corresponds to 300 on the log scale.
    SendMessage(hwndSlider, TBM_SETTIC, 0, 200L);
    SendMessage(hwndSlider, TBM_SETTIC, 0, 300L);
    

    // Set the slider position according to the value we obtain from
    // initialisation or from the last Deactivate() call.

    int iPos = ConvertToPosition(m_iVolume);
    SendMessage(hwndSlider, TBM_SETPOS, TRUE, iPos);
    return hwndSlider;
}  // CreateSlider


//
// OnSliderNotification
//
// Handle the notification meesages from the slider control
void CVolumeControlProperties::OnSliderNotification(WPARAM wParam)
{
    int iPos;

    if (m_hVolumeSupported != NOERROR)
    {
        SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, 0L);
        return; // don't move slider if not supported
    }
    switch (wParam) {
    case TB_BOTTOM:
    iPos = ConvertToPosition(0);
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, (LPARAM) iPos);
    break;

    case TB_TOP:
    iPos = ConvertToPosition(10000);
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, (LPARAM) iPos);
    break;

    case TB_PAGEDOWN:
    case TB_PAGEUP:
    break;

    case TB_THUMBPOSITION:
    case TB_ENDTRACK: {
        int iRate = (int) SendMessage(m_hwndSlider, TBM_GETPOS, 0, 0L);
        iRate = ConvertToDecibels(iRate);
        m_pBasicAudio->put_Volume(iRate);
    }
    break;

    case TB_THUMBTRACK: // default handling of these messages is ok.
    case TB_LINEDOWN:
    case TB_LINEUP:
    break;
    }
} // OnSliderNotification

#pragma warning(disable: 4514) // "unreferenced inline function has been removed"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\volctrl\volprop.h ===
#ifndef __VOLPROP_H__
#define __VOLPROP_H__
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// volProp.h
//
// This file is entirely concerned with the implementation of the
// properties page.



class CVolumeControlProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown * punk);
    HRESULT OnDisconnect(void);

    HRESULT OnDeactivate(void);

    CVolumeControlProperties(LPUNKNOWN lpunk, HRESULT *phr);

private:

    BOOL OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND        CreateSlider(HWND hwndParent);
    void        OnSliderNotification(WPARAM wParam);

    HWND        m_hwndSlider;   // handle of slider


    IBasicAudio *m_pBasicAudio;       // pointer to the IBasicAudio interface 
    long       m_iVolume;       // Remember volume between
                                // Deactivate / Activate calls.
    HRESULT    m_hVolumeSupported; // is volume control supported ?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\cextdev.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    CExtDev.cpp

Abstract:

    Implements IAMExtDevice 

--*/


#include "pch.h"  // Pre-compiled
#include <XPrtDefs.h>  // sdk\inc  
#include "EDevIntf.h"

// -----------------------------------------------------------------------------------
//
// CAMExtDevice
//
// -----------------------------------------------------------------------------------

CUnknown*
CALLBACK
CAMExtDevice::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by DirectShow code to create an instance of an IAMExtDevice
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CAMExtDevice(UnkOuter, NAME("IAMExtDevice"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 




CAMExtDevice::CAMExtDevice(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) 
    : CUnknown(Name, UnkOuter, hr)
    , m_KsPropertySet (NULL) 
/*++

Routine Description:

    The constructor for the IAMExtDevice interface object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer usizeof(DevCapabilities) - sizeof (KSPROPERTY)nknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsPropertySet), reinterpret_cast<PVOID*>(&m_KsPropertySet));
            if (SUCCEEDED(*hr)) 
                m_KsPropertySet->Release(); // Stay valid until disconnected            
            else 
                return;

            IKsObject *pKsObject;
            *hr = UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
            if (!FAILED(*hr)) {
                m_ObjectHandle = pKsObject->KsGetObjectHandle();
                ASSERT(m_ObjectHandle != NULL);
                pKsObject->Release();
            } else {
                *hr = VFW_E_NEED_OWNER;
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport:cannot find KsObject *hr %x"), *hr));
                return;
            }

        } else {
            *hr = VFW_E_NEED_OWNER;
            return;
        }
    } else {
        return;
    }
    
     
    if (!m_KsPropertySet) 
        *hr = E_PROP_ID_UNSUPPORTED;    
    else   
       GetCapabilities();    
}

                                             
CAMExtDevice::~CAMExtDevice(
    )
/*++

Routine Description:

    The destructor for the IAMExtDevice interface.

--*/
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying CAMExtDevice...")));
}


STDMETHODIMP
CAMExtDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMExtDevice.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IAMExtDevice)) {
        return GetInterface(static_cast<IAMExtDevice*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}
 

HRESULT 
CAMExtDevice::GetCapabilities(
    )
/*++

Routine Description:
    Get ALL device capabilites from the driver.

Arguments:

Return Value:

--*/
{
    HRESULT hr = S_OK;

    //
    // Request device to inqure its capabilities.
    //       
    KSPROPERTY_EXTDEVICE_S DevCapabilities;  // external device capabilities
    ULONG BytesReturned;
        
    RtlZeroMemory(&DevCapabilities, sizeof(KSPROPERTY_EXTDEVICE_S));
    RtlCopyMemory(&DevCapabilities.u.Capabilities, &m_DevCaps, sizeof(DEVCAPS)); 

    DevCapabilities.Property.Set   = PROPSETID_EXT_DEVICE;   
    DevCapabilities.Property.Id    = KSPROPERTY_EXTDEVICE_CAPABILITIES;       
    DevCapabilities.Property.Flags = KSPROPERTY_TYPE_GET;

    hr = 
        ExtDevSynchronousDeviceControl(
            m_ObjectHandle
           ,IOCTL_KS_PROPERTY
           ,&DevCapabilities
           ,sizeof (KSPROPERTY)
           ,&DevCapabilities
           ,sizeof(DevCapabilities)
           ,&BytesReturned
           );

    if (SUCCEEDED(hr)) {
        // Cache device capabilities.
        RtlCopyMemory(&m_DevCaps, &DevCapabilities.u.Capabilities, sizeof(DEVCAPS));
            
    } else {        
        DbgLog((LOG_ERROR, 0, TEXT("GetExtDevCapabilities failed hr %x; Use defaults."), hr));

        // 
        //   Could not get it from the driver ??  We set them to the default values.
        //
        m_DevCaps.CanRecord         = OATRUE;
        m_DevCaps.CanRecordStrobe   = OAFALSE;
        m_DevCaps.HasAudio          = OATRUE;
        m_DevCaps.HasVideo          = OATRUE;          
        m_DevCaps.UsesFiles         = OAFALSE;         
        m_DevCaps.CanSave           = OAFALSE;           
        m_DevCaps.DeviceType        = ED_DEVTYPE_VCR;  
        m_DevCaps.TCRead            = OATRUE;            
        m_DevCaps.TCWrite           = OATRUE;          
        m_DevCaps.CTLRead           = OAFALSE; 
        m_DevCaps.IndexRead         = OAFALSE; 
        m_DevCaps.Preroll           = 0L;    // ED_CAPABILITY_UNKNOWN
        m_DevCaps.Postroll          = 0L;    // ED_CAPABILITY_UNKNOWN
        m_DevCaps.SyncAcc           = ED_CAPABILITY_UNKNOWN; 
        m_DevCaps.NormRate          = ED_RATE_2997;          
        m_DevCaps.CanPreview        = OAFALSE;        
        m_DevCaps.CanMonitorSrc     = OATRUE;    
        m_DevCaps.CanTest           = OAFALSE;           
        m_DevCaps.VideoIn           = OAFALSE;           
        m_DevCaps.AudioIn           = OAFALSE; 
        m_DevCaps.Calibrate         = OAFALSE;
        m_DevCaps.SeekType          = ED_CAPABILITY_UNKNOWN;
        
    }
    DbgLog((LOG_TRACE, 1, TEXT("hr:%x; DevType %d"), hr, m_DevCaps.DeviceType));


    return hr;
}

HRESULT 
CAMExtDevice::GetCapability(
    long Capability, 
    long *pValue, 
    double *pdblValue 
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = S_OK;

    // always update all device capabilities when any capability function is queried.
    hr = GetCapabilities();
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    switch (Capability){
   
    case ED_DEVCAP_CAN_RECORD:
        *pValue = m_DevCaps.CanRecord;
        break;
    case ED_DEVCAP_CAN_RECORD_STROBE:
        *pValue = m_DevCaps.CanRecordStrobe;
        break;
    case ED_DEVCAP_HAS_AUDIO:
        *pValue = m_DevCaps.HasAudio;
        break;
    case ED_DEVCAP_HAS_VIDEO:  
        *pValue = m_DevCaps.HasVideo;
        break;
    case ED_DEVCAP_USES_FILES: 
        *pValue = m_DevCaps.UsesFiles;
        break;
    case ED_DEVCAP_CAN_SAVE:  
        *pValue = m_DevCaps.CanSave;
        break;
    case ED_DEVCAP_DEVICE_TYPE: 
        *pValue = m_DevCaps.DeviceType;
        break;
    case ED_DEVCAP_TIMECODE_READ:   
        *pValue = m_DevCaps.TCRead;
        break;
    case ED_DEVCAP_TIMECODE_WRITE: 
        *pValue = m_DevCaps.TCWrite;
        break;
    case ED_DEVCAP_CTLTRK_READ:    
        *pValue = m_DevCaps.CTLRead;
        break;
    case ED_DEVCAP_INDEX_READ:   
        *pValue = m_DevCaps.IndexRead;
        break;
    case ED_DEVCAP_PREROLL:   
        *pValue = m_DevCaps.Preroll;
        break;
    case ED_DEVCAP_POSTROLL:   
        *pValue = m_DevCaps.Postroll;
        break;
    case ED_DEVCAP_SYNC_ACCURACY:  
        *pValue = m_DevCaps.SyncAcc;
        break;
    case ED_DEVCAP_NORMAL_RATE:
        *pValue = m_DevCaps.NormRate;
        break;
    case ED_DEVCAP_CAN_PREVIEW:   
        *pValue = m_DevCaps.CanPreview;
        break;
    case ED_DEVCAP_CAN_MONITOR_SOURCES: 
        *pValue = m_DevCaps.CanMonitorSrc;
        break;
    case ED_DEVCAP_CAN_TEST:
        *pValue = m_DevCaps.CanTest;
        break;
    case ED_DEVCAP_VIDEO_INPUTS:    
        *pValue = m_DevCaps.VideoIn;
        break;
    case ED_DEVCAP_AUDIO_INPUTS:    
        *pValue = m_DevCaps.AudioIn;
        break;
    case ED_DEVCAP_NEEDS_CALIBRATING:
        *pValue = m_DevCaps.Calibrate;
        break;
    case ED_DEVCAP_SEEK_TYPE:
        *pValue = m_DevCaps.SeekType;
        break;
    default:
        hr = VFW_E_NOT_FOUND;
    } 

    return hr;
}        


HRESULT
CAMExtDevice::get_ExternalDeviceID(
    LPOLESTR * ppszData  
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    HRESULT hr = NOERROR;

    CheckPointer(ppszData, E_POINTER);
    *ppszData = NULL;

    //
    // Request device to inqure its capabilities.
    // This may take some time to complete.
    //       
    KSPROPERTY_EXTDEVICE_S DevProperty;  // external device capabilities
    ULONG BytesReturned;
        
    RtlZeroMemory(&DevProperty, sizeof(KSPROPERTY_EXTDEVICE_S));

    DevProperty.Property.Set   = PROPSETID_EXT_DEVICE;   
    DevProperty.Property.Id    = KSPROPERTY_EXTDEVICE_ID;       
    DevProperty.Property.Flags = KSPROPERTY_TYPE_GET;      

    hr = 
        ExtDevSynchronousDeviceControl(
            m_ObjectHandle
           ,IOCTL_KS_PROPERTY
           ,&DevProperty
           ,sizeof (KSPROPERTY)
           ,&DevProperty
           ,sizeof(DevProperty)
           ,&BytesReturned
           );

    if(SUCCEEDED(hr)) {
        *ppszData = (LPOLESTR) QzTaskMemAlloc(sizeof(DWORD) * 2 + sizeof(WCHAR));
        if(*ppszData != NULL) {
            RtlZeroMemory(*ppszData, sizeof(DWORD) * 2 + sizeof(WCHAR) );
            RtlCopyMemory(*ppszData, (PBYTE) &DevProperty.u.NodeUniqueID[0], sizeof(DWORD) * 2 );
        }
            
    } else {        
        DbgLog((LOG_ERROR, 1, TEXT("CAMExtDevice::get_ExternalDeviceID failed hr %x"), hr));         
    }

    return hr;
}


HRESULT
CAMExtDevice::get_ExternalDeviceVersion(
    LPOLESTR * ppszData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = NOERROR;

    CheckPointer(ppszData, E_POINTER);
    *ppszData = NULL;

    //
    // Request device to inqure its capabilities.
    // This may take some time to complete.
    //       
    KSPROPERTY_EXTDEVICE_S DevProperty;  // external device capabilities
    ULONG BytesReturned;
        
    RtlZeroMemory(&DevProperty, sizeof(KSPROPERTY_EXTDEVICE_S));
    DevProperty.Property.Set   = PROPSETID_EXT_DEVICE;   
    DevProperty.Property.Id    = KSPROPERTY_EXTDEVICE_VERSION;       
    DevProperty.Property.Flags = KSPROPERTY_TYPE_GET;  
    
    hr =
        ExtDevSynchronousDeviceControl(
            m_ObjectHandle
           ,IOCTL_KS_PROPERTY
           ,&DevProperty
           ,sizeof (KSPROPERTY)
           ,&DevProperty
           ,sizeof(DevProperty)
           ,&BytesReturned
           );

    if(SUCCEEDED(hr)) {
        *ppszData = (LPOLESTR) QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW((LPOLESTR)DevProperty.u.pawchString)));
        if(*ppszData != NULL) {
            lstrcpyW(*ppszData, (LPOLESTR)DevProperty.u.pawchString);
        }    
            
    } else {        
        DbgLog((LOG_ERROR, 1, TEXT("CAMExtDevice::get_ExternalDeviceVersion failed hr %x"), hr));         
    }

    return hr;
}


HRESULT
CAMExtDevice::put_DevicePower(
    long PowerMode
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = NOERROR;

    //
    // Check for valid power state
    //
    switch(PowerMode) {
    case  ED_POWER_OFF:
    case  ED_POWER_ON:
    case  ED_POWER_STANDBY:
        break;
    default:
        return E_INVALIDARG;
    }


    //
    // Request device to inqure its capabilities.
    // This may take some time to complete.
    //       
    KSPROPERTY_EXTDEVICE_S DevProperty;  // external device capabilities
    ULONG BytesReturned;

        
    RtlZeroMemory(&DevProperty, sizeof(KSPROPERTY_EXTDEVICE_S));
    DevProperty.Property.Set   = PROPSETID_EXT_DEVICE;   
    DevProperty.Property.Id    = KSPROPERTY_EXTDEVICE_POWER_STATE;       
    DevProperty.Property.Flags = KSPROPERTY_TYPE_SET;
    DevProperty.u.PowerState = PowerMode;
      
    hr = 
        ExtDevSynchronousDeviceControl(
            m_ObjectHandle
           ,IOCTL_KS_PROPERTY
           ,&DevProperty
           ,sizeof (KSPROPERTY)
           ,&DevProperty
           ,sizeof(DevProperty)
           ,&BytesReturned
           );

    if (SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, 1, TEXT("CAMExtDevice::put_DevicePower: %d suceeded"), PowerMode));         
            
    } else {        
        DbgLog((LOG_ERROR, 1, TEXT("CAMExtDevice::put_DevicePower failed hr %x"), hr));         
    }

    return hr;
}


HRESULT 
CAMExtDevice::get_DevicePower(
    long *pPowerMode
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = NOERROR;

    //
    // Request device to inqure its capabilities.
    // This may take some time to complete.
    //       
    KSPROPERTY_EXTDEVICE_S DevProperty;  // external device capabilities
    ULONG BytesReturned;
        
    RtlZeroMemory(&DevProperty, sizeof(KSPROPERTY_EXTDEVICE_S));
    DevProperty.Property.Set   = PROPSETID_EXT_DEVICE;   
    DevProperty.Property.Id    = KSPROPERTY_EXTDEVICE_POWER_STATE;       
    DevProperty.Property.Flags = KSPROPERTY_TYPE_GET;
    
    hr = 
        ExtDevSynchronousDeviceControl(
            m_ObjectHandle
           ,IOCTL_KS_PROPERTY
           ,&DevProperty
           ,sizeof (KSPROPERTY)
           ,&DevProperty
           ,sizeof(DevProperty)
           ,&BytesReturned
           );

    if (SUCCEEDED(hr)) {
        *pPowerMode = DevProperty.u.PowerState; 
            
    } else {        
        DbgLog((LOG_ERROR, 1, TEXT("CAMExtDevice::get_DevicePower failed hr %x"), hr));         
    }

    return hr;
}


HRESULT
CAMExtDevice::Calibrate(
    HEVENT hEvent, 
    long Mode, 
    long *pStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP 
CAMExtDevice::get_DevicePort(
    long FAR * pDevicePort)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = NOERROR;

    //
    // Request device to inqure its capabilities.
    // This may take some time to complete.
    //       
    KSPROPERTY_EXTDEVICE_S DevProperty;  // external device capabilities
    ULONG BytesReturned;
        
    RtlZeroMemory(&DevProperty, sizeof(KSPROPERTY_EXTDEVICE_S));
    DevProperty.Property.Set   = PROPSETID_EXT_DEVICE;   
    DevProperty.Property.Id    = KSPROPERTY_EXTDEVICE_PORT;       
    DevProperty.Property.Flags = KSPROPERTY_TYPE_GET; 
      
    hr =
        ExtDevSynchronousDeviceControl(
            m_ObjectHandle
           ,IOCTL_KS_PROPERTY
           ,&DevProperty
           ,sizeof (KSPROPERTY)
           ,&DevProperty
           ,sizeof(DevProperty)
           ,&BytesReturned
           );

    if (SUCCEEDED(hr)) {
        *pDevicePort = DevProperty.u.DevPort; 
            
    } else {        
        DbgLog((LOG_ERROR, 1, TEXT("CAMExtDevice::get_DevicePort failed hr %x"), hr));         
    }

    return hr;
}



STDMETHODIMP 
CAMExtDevice::put_DevicePort(
    long DevicePort
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\cextxprt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    CExtXPrt.cpp

Abstract:

    Implements IAMExtTransport

--*/


#include "pch.h"     // Pre-compiled.
#include "wdmcap.h"  // SynchronousDeviceControl()
#include <XPrtDefs.h>  // sdk\inc  
#include "EDevIntf.h"

#ifndef STATUS_MORE_ENTRIES
#define STATUS_MORE_ENTRIES              0x00000105L // ((NTSTATUS)0x00000105L)
#endif

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                   0x00000000L // ((NTSTATUS)0x00000000L)
#endif

#ifndef STATUS_REQUEST_NOT_ACCEPTED
#define STATUS_REQUEST_NOT_ACCEPTED      0xC00000D0L // ((NTSTATUS)0xC00000D0L)
#endif

#ifndef STATUS_REQUEST_ABORTED
#define STATUS_REQUEST_ABORTED           0xC0000240L // ((NTSTATUS)0xC0000240L)
#endif

#ifndef STATUS_NOT_SUPPORTED
#define STATUS_NOT_SUPPORTED             0xC00000BBL // ((NTSTATUS)0xC00000BBL)
#endif


STDMETHODIMP
ExtDevSynchronousDeviceControl(
    HANDLE Handle,
    ULONG IoControl,
    PVOID InBuffer,
    ULONG InLength,
    PVOID OutBuffer,
    ULONG OutLength,
    PULONG BytesReturned
    )
/*++

Routine Description:

    This device io control is specifically designed for external device that 
    may have additional status returned in ov.internal. This function performs 
    a synchronous Device I/O Control, waiting for the device to complete if 
    the call returns a Pending status.

Arguments:

    Handle -
        The handle of the device to perform the I/O on.

    IoControl -
        The I/O control code to send.

    InBuffer -
        The first buffer.

    InLength -
        The size of the first buffer.

    OutBuffer -
        The second buffer.

    OutLength -
        The size of the second buffer.

    BytesReturned -
        The number of bytes returned by the I/O.

Return Value:

    Returns NOERROR if the I/O succeeded.

--*/
{
    OVERLAPPED  ov;
    HRESULT     hr;
    DWORD       LastError;

    RtlZeroMemory(&ov, sizeof(ov));
    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL); 
    if ( !ov.hEvent ) {
        LastError = GetLastError();
        return HRESULT_FROM_WIN32(LastError);
    }
    if (!DeviceIoControl(
        Handle,
        IoControl,
        InBuffer,
        InLength,
        OutBuffer,
        OutLength,
        BytesReturned,
        &ov)) {
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            if (GetOverlappedResult(Handle, &ov, BytesReturned, TRUE)) {
                hr = NOERROR;
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
        }
    } else {
        //
        // DeviceIoControl returns TRUE on success, even if the success
        // was not STATUS_SUCCESS. It also does not set the last error
        // on any successful return. Therefore any of the successful
        // returns which standard properties can return are not returned.
        //
        switch (ov.Internal) {
        case STATUS_SUCCESS:       // Special case
            hr = NOERROR;
            break;
        case STATUS_MORE_ENTRIES:
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            break;
        // External device control is implemented as a property.
        // If device is not responding, this can result in timeout.
        case STATUS_TIMEOUT:
            hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
            break;
        // External device control: Device may reject this command.
        case STATUS_REQUEST_NOT_ACCEPTED:  // Special case
            hr = HRESULT_FROM_WIN32(ERROR_REQ_NOT_ACCEP);
            break; 
        // External device control: Device does not support this command.
        case STATUS_NOT_SUPPORTED:         // Special case
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            break;
        // External device control: Device may abort this command due to bus reset or device removal.
        case STATUS_REQUEST_ABORTED:       // Special case
            hr = HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED);
            break; 
        default:
            hr = NOERROR;
            ASSERT(FALSE && "Unknown ov.Internal");
            break;
        }
    }
    CloseHandle(ov.hEvent);
    return hr;
}

// -----------------------------------------------------------------------------------
//
// CAMExtTransport
//
// -----------------------------------------------------------------------------------

CUnknown*
CALLBACK
CAMExtTransport::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by DirectShow code to create an instance of an IAMExtTransport
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CAMExtTransport(UnkOuter, NAME("IAMExtTransport"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


DWORD
CAMExtTransport::MainThreadProc(
    )
{
    HRESULT hr;
    HANDLE EventHandles[4];

    DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc() has been called")));

    // Enable KSEvents to detect 
    //    surprise removal
    //    control interim response completion
    //    notify interim response completion
    hr = EnableNotifyEvent(m_hKSDevRemovedEvent,    &m_EvtDevRemoval,         KSEVENT_EXTDEV_NOTIFY_REMOVAL);   
    if(!SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("EnableNotifyEvent(m_EvtDevRemoved) not supported %x"), hr));
    }
    hr = EnableNotifyEvent(m_hKSNotifyInterimEvent, &m_EvtNotifyInterimReady, KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY);   
    if(!SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("EnableNotifyEvent(m_EvtNotifyInterimReady) not supported %x"), hr));;
    }
    hr = EnableNotifyEvent(m_hKSCtrlInterimEvent,   &m_EvtCtrlInterimReady,   KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY);   
    if(!SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("EnableNotifyEvent(m_EvtCtrlInterimReady) not supported %x"), hr));
    }

    EventHandles[0] = m_hKSNotifyInterimEvent; 
    EventHandles[1] = m_hKSCtrlInterimEvent; 
    EventHandles[2] = m_hThreadEndEvent;
    EventHandles[3] = m_hKSDevRemovedEvent;

    while (TRUE) {
    
        DbgLog((LOG_TRACE, 2, TEXT("CAMExtTransport:Waiting for DevCmd event to be signalled")));
        DWORD dw = WaitForMultipleObjects(4, EventHandles, FALSE, INFINITE);

        switch (dw) {

        // ** Pending control interim response is completed!
        // Set event to signal to get the final response in the other thread.
        case WAIT_OBJECT_0+1:  // CtrlInterim
            DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc, <m_hKSCtrlInterimEvent> Event Signalled; SetEvent(m_hCtrlInterimEvent)")));
            if(!SetEvent(m_hCtrlInterimEvent)) {
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::MainThreadProc, <Ctrl> SetEvent() failed LastError %dL"), GetLastError()));
            }
            ResetEvent(m_hKSCtrlInterimEvent);    // Manual reset to non-signal
            break;

        // ** Thread ended!
        // Retrieve any pending notify response and disable all event.
        case WAIT_OBJECT_0+2:
            // Thread ended and we should remove the pending Notify command
            DbgLog((LOG_TRACE, 1, TEXT("CAMExtTransport, m_hThreadEndEvent event thread exiting")));
            // Note: Purposely fall thru to retrieve the response of the Notify interm response.

        // ** Pending Notify response completed!
        case WAIT_OBJECT_0:

            // Protect from releasing the the wait event of the client so
            // we can get its interim response before this thread end.
            EnterCriticalSection(&m_csPendingData);
            DbgLog((LOG_TRACE, 1, TEXT("m_hKSNotifyInterimEvent signaled!")));

            if(WAIT_OBJECT_0 == dw && m_cntNotifyInterim > 0) {
                // Reset for next use
                DbgLog((LOG_TRACE, 1, TEXT("CWAIT_OBJECT_0: m_cntNotifyInterim %d"), m_cntNotifyInterim));
                m_cntNotifyInterim--;     // Since we allow only one command pending, this is either 0 or 1.
                ASSERT(m_cntNotifyInterim == 0 && "Notify Removed but count > 0");
            }

            if(m_bNotifyInterimEnabled && m_pExtXprtPropertyPending) {
                PKSPROPERTY_EXTXPORT_S pExtXPrtProperty;

                DWORD   cbBytesReturn;


                pExtXPrtProperty = m_pExtXprtPropertyPending;

                pExtXPrtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;   
                pExtXPrtProperty->Property.Id    = KSPROPERTY_EXTXPORT_STATE_NOTIFY;         
                pExtXPrtProperty->Property.Flags = KSPROPERTY_TYPE_GET;

                hr = 
                    ExtDevSynchronousDeviceControl(
                        m_ObjectHandle
                       ,IOCTL_KS_PROPERTY
                       ,pExtXPrtProperty
                       ,sizeof (KSPROPERTY)
                       ,pExtXPrtProperty
                       ,sizeof(KSPROPERTY_EXTXPORT_S)
                       ,&cbBytesReturn
                        );

                if(SUCCEEDED (hr)) {
                    // Add a switch to deal with differnt StatusItem
                    // This Tranposrt state but could be others.
                    DbgLog((LOG_TRACE, 1, TEXT("NotifyIntermResp: hr:%x, cbRtn:%d, Mode:%dL, State:%dL"),
                        hr, cbBytesReturn, pExtXPrtProperty->u.XPrtState.Mode-ED_BASE, pExtXPrtProperty->u.XPrtState.State-ED_BASE ));
                    *m_plValue = pExtXPrtProperty->u.XPrtState.State;
                    hr = NOERROR;
                } else {
                    DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::MainThreadProc SynchronousDeviceControl failed with hr %x"), hr));          
                }

                // Data from client; should we allocate this instead
                m_plValue = NULL;      
                m_pExtXprtPropertyPending = NULL;
                

                //
                // Save the final RC for clinet
                //
                SetLastError(HRESULT_CODE(hr));

                LeaveCriticalSection(&m_csPendingData);

                 //
                 // Tell Client data is ready.
                 //
                if(!SetEvent(m_hNotifyInterimEvent)) {
                    DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::MainThreadProc, SetEvent() failed LastError %dL"), GetLastError()));
                }

                delete pExtXPrtProperty;  // Temp data

            } else {
                LeaveCriticalSection(&m_csPendingData);
                DbgLog((LOG_ERROR, 1, TEXT("NotifyResp signal but data removed ? Enabled:%x, m_cntNotifyInterim:%d, pProperty:%x, plValue:%x"), 
                    &m_bNotifyInterimEnabled, m_cntNotifyInterim, m_pExtXprtPropertyPending, m_plValue));          
            }

            // If notify command, thread is still active; break to start over
            if(dw == WAIT_OBJECT_0) {
                ResetEvent(m_hKSNotifyInterimEvent);  // Manual reset to non-signal
                break;  // Another
            }

            // Thread has ended:
            goto CleanUp;
            
        // ** Device is removed!
        case WAIT_OBJECT_0+3:
            // Driver need to clean up the pening commands.
            DbgLog((LOG_TRACE, 1, TEXT("*********CAMExtTransport:Device removed******************")));
            EnterCriticalSection(&m_csPendingData);
            // Fro,m this point on, all call will return ERROR_DEVICE_REMOVED
            m_bDevRemoved = TRUE;
            SetEvent(m_hDevRemovedEvent);  // Signal application that this device is removed.

            // Driver will remove pending commands; clean up local variabled.
            if(m_cntNotifyInterim) {
                m_cntNotifyInterim--;     // Since we allow only one command pending, this is either 0 or 1.
                ASSERT(m_cntNotifyInterim == 0 && "Notify Removed but count > 0");
                m_bNotifyInterimEnabled = FALSE;
            }

            LeaveCriticalSection(&m_csPendingData);
            goto CleanUp;         

        // ** Unknown return from WFSO()
        default:
            DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport, UnExpected return from WFSO:%d"), dw));
            ASSERT(FALSE && "Unknow return from WFSO()");
            // Note: Purposely fall thru to end thread case to clean up
            goto CleanUp;
        }
    }

    return 1;

CleanUp:

    // If there is a pending control interim response,
    // set event to signal so it will try to get its final response 
    if(!SetEvent(m_hCtrlInterimEvent)) {
        DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::MainThreadProc, <Ctrl> SetEvent() failed LastError %dL"), GetLastError()));
    }

    //
    // Disable events when this thread is ended.
    //
    hr = DisableNotifyEvent(&m_EvtDevRemoval);
    if(!SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, 1, TEXT("DisableNotifyEvent(m_EvtDevRemoval) failed %x"), hr));
    }

    hr = DisableNotifyEvent(&m_EvtNotifyInterimReady);
    if(!SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, 1, TEXT("DisableNotifyEvent(m_EvtNotifyInterimReady) failed %x"), hr));
    }

    hr = DisableNotifyEvent(&m_EvtCtrlInterimReady);    
    if(!SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, 1, TEXT("DisableNotifyEvent(m_EvtCtrlInterimReady) failed %x"), hr));
    } 

    return 1; // shouldn't get here
}


DWORD
WINAPI
CAMExtTransport::InitialThreadProc(
    CAMExtTransport *pThread
    )
{
    return pThread->MainThreadProc();
}



HRESULT
CAMExtTransport::CreateThread(void)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 1, TEXT("CAMExtTransport::CreateThread() has been called")));

    if (m_hThreadEndEvent == NULL) {
        m_hThreadEndEvent = CreateEvent( NULL, TRUE, FALSE, NULL );\

        if (m_hThreadEndEvent != NULL) {
            DWORD ThreadId;
            m_hThread = 
                ::CreateThread( 
                    NULL
                    , 0
                    , (LPTHREAD_START_ROUTINE) (InitialThreadProc)
                    , (LPVOID) (this)
                    , 0
                    , &ThreadId
                    );

            if (m_hThread == NULL) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DbgLog((LOG_ERROR, 1, TEXT("CreateThread failed, hr %x"), hr));
                CloseHandle(m_hThreadEndEvent), m_hThreadEndEvent = NULL;

            } else {
                DbgLog((LOG_TRACE, 2, TEXT("m_hThreadEndEvent %x, m_hThread %x"),m_hThreadEndEvent, m_hThread));
            }

        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DbgLog((LOG_ERROR, 1, TEXT("CreateEvent failed hr %x"), hr));
        }
    } else {
        DbgLog((LOG_ERROR, 1, TEXT("CreateThread again ? use existing m_hThreadEndEvent %x, m_hThread %x"), m_hThreadEndEvent, m_hThread));
    }

    return hr;
}


void
CAMExtTransport::ExitThread(
    )
{
    //
    // Check if a thread was created
    //
    if (m_hThread) {
        ASSERT(m_hThreadEndEvent != NULL);

        // Tell the thread to exit        
        if (SetEvent(m_hThreadEndEvent)) {
            //
            // Synchronize with thread termination.
            //
            DbgLog((LOG_TRACE, 2, TEXT("CAMExtTransport: Wait for thread to terminate.")));
            WaitForSingleObjectEx(m_hThread, INFINITE, FALSE);  // Exit when thread terminate
            DbgLog((LOG_TRACE, 2, TEXT("CAMExtTransport: Thread terminated.")));

        } else {
            DbgLog((LOG_ERROR, 1, TEXT("ERROR: SetEvent(m_hThreadEndEvent) failed, GetLastError() %x"), GetLastError()));
        }

        CloseHandle(m_hThreadEndEvent), m_hThreadEndEvent = NULL;
        CloseHandle(m_hThread),         m_hThread = NULL;
    }
}


HRESULT 
CAMExtTransport::EnableNotifyEvent(
    HANDLE       hEvent,
    PKSEVENTDATA pEventData,
    ULONG   ulEventId
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = NOERROR;
    //
    // Thread is ready then we enable the event mechanism
    //
    if (m_hThread) {

        KSEVENT Event;
        DWORD BytesReturned;

        RtlZeroMemory(pEventData, sizeof(KSEVENTDATA));
        pEventData->NotificationType = KSEVENTF_EVENT_HANDLE;
        pEventData->EventHandle.Event = hEvent;
        pEventData->EventHandle.Reserved[0] = 0;
        pEventData->EventHandle.Reserved[1] = 0;

        Event.Set   = KSEVENTSETID_EXTDEV_Command;
        Event.Id    = ulEventId;
        Event.Flags = KSEVENT_TYPE_ENABLE;

        // Serial sending property
        hr = ::
             SynchronousDeviceControl
            ( m_ObjectHandle
            , IOCTL_KS_ENABLE_EVENT
            , &Event
            , sizeof(Event)
            , pEventData
            , sizeof(*pEventData)
            , &BytesReturned
            );

        if(FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("KS_ENABLE_EVENT hr %x, cbRtn %d"), hr, BytesReturned));    
        }
    }

    return hr;
}


HRESULT 
CAMExtTransport::DisableNotifyEvent(
    PKSEVENTDATA pEventData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = NOERROR;
    //
    // Thread is ready then we enable the event mechanism
    //
    if (m_hThread) {

        DWORD BytesReturned;

        hr = ::
             SynchronousDeviceControl
            ( m_ObjectHandle
            , IOCTL_KS_DISABLE_EVENT
            , pEventData
            , sizeof(*pEventData)
            , NULL
            , 0
            , &BytesReturned
            );
            
        if(FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("KS_DISABLE_EVENT hr %x"), hr));                      
        }
    }

    return hr;
}



CAMExtTransport::CAMExtTransport(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) 
    : CUnknown(Name, UnkOuter, hr)
    , m_KsPropertySet (NULL)

    , m_ObjectHandle(NULL)

    , m_hKSNotifyInterimEvent(NULL)
    , m_bNotifyInterimEnabled(FALSE)
    , m_hNotifyInterimEvent(NULL)

    , m_hKSCtrlInterimEvent(NULL)
    , m_bCtrlInterimEnabled(FALSE)
    , m_hCtrlInterimEvent(NULL)

// For asychronous operation
    , m_bDevRemovedEnabled(FALSE)
    , m_hDevRemovedEvent(FALSE)
    , m_hKSDevRemovedEvent(FALSE)

    , m_bDevRemoved(FALSE)

    , m_hThreadEndEvent(NULL)
    , m_hThread(NULL)

    , m_cntNotifyInterim(0)      
    , m_plValue(NULL) 
    , m_pExtXprtPropertyPending(NULL)
/*++

Routine Description:

    The constructor for the IAMExtTransport interface object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    DbgLog((LOG_TRACE, 1, TEXT("Constructing CAMExtTransport...")));

    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsPropertySet), reinterpret_cast<PVOID*>(&m_KsPropertySet));
            if (SUCCEEDED(*hr)) 
                m_KsPropertySet->Release(); // Stay valid until disconnected            
            else {
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport:cannot find KsPropertySet *hr %x"), *hr));
                return;
            }

            IKsObject *pKsObject;
            *hr = UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
            if (!FAILED(*hr)) {
                m_ObjectHandle = pKsObject->KsGetObjectHandle();
                ASSERT(m_ObjectHandle != NULL);
                pKsObject->Release();
            } else {
                *hr = VFW_E_NEED_OWNER;
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport:cannot find KsObject *hr %x"), *hr));
                return;
            }
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport:there is no UnkOuter, *hr %x"), *hr));
            return;
        }
    } else {
        DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::CAMExtTransport: *hr %x"), *hr));
        return;
    }
    
    
    if (SUCCEEDED(*hr)) {        
  
        // To serialize issuing command
        InitializeCriticalSection(&m_csPendingData);

        //
        // Initialize TRANSPORTBASICPARMS
        //
        RtlZeroMemory(&m_TranBasicParms, sizeof(m_TranBasicParms));
        m_TranBasicParms.TimeFormat     = ED_FORMAT_HMSF;
        m_TranBasicParms.TimeReference  = ED_TIMEREF_ATN;  
        m_TranBasicParms.Superimpose    = ED_CAPABILITY_UNKNOWN;  // MCI/VCR, UNKNOWN
        m_TranBasicParms.EndStopAction  = ED_MODE_STOP;           // When get to the end, what mode does it in
        m_TranBasicParms.RecordFormat   = ED_RECORD_FORMAT_SP;    // Standard Play only
        m_TranBasicParms.StepFrames     = ED_CAPABILITY_UNKNOWN;  // Panasonic, 1
        m_TranBasicParms.SetpField      = ED_CAPABILITY_UNKNOWN;  // Pansconic, 1 other 2
        m_TranBasicParms.Preroll        = ED_CAPABILITY_UNKNOWN;  // To be determine
        m_TranBasicParms.RecPreroll     = ED_CAPABILITY_UNKNOWN;  // To be determine
        m_TranBasicParms.Postroll       = ED_CAPABILITY_UNKNOWN;  // TBD
        m_TranBasicParms.EditDelay      = ED_CAPABILITY_UNKNOWN;  // EditCmd->Machine, 
        m_TranBasicParms.PlayTCDelay    = ED_CAPABILITY_UNKNOWN;  // From tape to interface (OS dependent)
        m_TranBasicParms.RecTCDelay     = ED_CAPABILITY_UNKNOWN;  // From controller to device (Device dependent)
        m_TranBasicParms.EditField      = ED_CAPABILITY_UNKNOWN;  // Field 1/2; => 1
        m_TranBasicParms.FrameServo     = ED_CAPABILITY_UNKNOWN;  // TRUE
        m_TranBasicParms.ColorFrameServo = ED_CAPABILITY_UNKNOWN; // UNKNOWN
        m_TranBasicParms.ServoRef       = ED_CAPABILITY_UNKNOWN;  // INTERNAL
        m_TranBasicParms.WarnGenlock    = OAFALSE;                // FALSE (external signal)
        m_TranBasicParms.SetTracking    = OAFALSE;                // FALSE
        m_TranBasicParms.Speed          = ED_RECORD_FORMAT_SP;    // ?(status) Plyaback speed => (_RECORDING_SPEED status cmd)
        m_TranBasicParms.CounterFormat  = OAFALSE;                // HMSF or number ?
        m_TranBasicParms.TunerChannel   = OAFALSE;                // FALSE
        m_TranBasicParms.TunerNumber    = OAFALSE;                // FALSE
        m_TranBasicParms.TimerEvent     = OAFALSE;                // FALSE
        m_TranBasicParms.TimerStartDay  = OAFALSE;                // FALSE
        m_TranBasicParms.TimerStartTime = OAFALSE;                // FALSE
        m_TranBasicParms.TimerStopDay   = OAFALSE;                // FALSE
        m_TranBasicParms.TimerStopTime  = OAFALSE;                // FALSE


        //
        // Initialize TRANSPORTVIDEOPARMS
        //
        RtlZeroMemory(&m_TranVidParms, sizeof(m_TranVidParms));
        m_TranVidParms.OutputMode = ED_PLAYBACK;
        m_TranVidParms.Input      = 0;  // use the first (zeroth) input as the default

        
        //
        // Initialize TRANSPORTAUDIOPARMS
        //
        RtlZeroMemory(&m_TranAudParms, sizeof(m_TranAudParms));
        m_TranAudParms.EnableOutput  = ED_AUDIO_ALL;
        m_TranAudParms.EnableRecord  = 0L;
        m_TranAudParms.Input         = 0;
        m_TranAudParms.MonitorSource = 0;        

        
        //
        // Initialize TRANSPORTSTATUS
        // 
        BOOL bRecordInhibit = FALSE;  
        GetStatus(ED_RECORD_INHIBIT, (long *)&bRecordInhibit);

        long lStorageMediaType = ED_MEDIA_NOT_PRESENT;
        GetStatus(ED_MEDIA_TYPE, &lStorageMediaType);        

        RtlZeroMemory(&m_TranStatus, sizeof(m_TranStatus));
        m_TranStatus.Mode             = ED_MODE_STOP;
        m_TranStatus.LastError        = 0L;
        m_TranStatus.MediaPresent     = lStorageMediaType == ED_MEDIA_NOT_PRESENT ? OAFALSE : OATRUE;
        m_TranStatus.RecordInhibit    = bRecordInhibit ? OATRUE : OAFALSE;
        m_TranStatus.ServoLock        = ED_CAPABILITY_UNKNOWN;
        m_TranStatus.MediaLength      = 0;
        m_TranStatus.MediaSize        = 0;
        m_TranStatus.MediaTrackCount  = 0;
        m_TranStatus.MediaTrackLength = 0;
        m_TranStatus.MediaTrackSide   = 0;
        m_TranStatus.MediaType        = ED_MEDIA_DVC;
        m_TranStatus.LinkMode         = OAFALSE;    // default to "linked"
        m_TranStatus.NotifyOn         = OAFALSE;    // disable event notification
    

        //
        // Allocate resource 
        //

        m_hDevRemovedEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);  // Manual reset and Non-signaled
        if(!m_hDevRemovedEvent) {        
            DbgLog((LOG_ERROR, 1, TEXT("Failed CreateEvent(m_hDevRemovedEvent), GetLastError() %x"), GetLastError()));            
            *hr = E_OUTOFMEMORY;
            return;
        } 
        m_hKSDevRemovedEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);  // Manual reset and Non-signaled
        if(!m_hKSDevRemovedEvent) {        
            DbgLog((LOG_ERROR, 1, TEXT("Failed CreateEvent(m_hKSDevRemovedEvent), GetLastError() %x"), GetLastError()));            
            *hr = E_OUTOFMEMORY;
            return;
        } 


        m_hNotifyInterimEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); // Manual reset and Non-signal
        if(!m_hNotifyInterimEvent) {        
            DbgLog((LOG_ERROR, 1, TEXT("Failed CreateEvent(m_hNotifyInterimEvent), GetLastError() %x"), GetLastError()));            
            *hr = E_OUTOFMEMORY;
            return;
        } 
        m_hKSNotifyInterimEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);  // Manual reset and Non-signaled
        if(!m_hKSNotifyInterimEvent) {        
            DbgLog((LOG_ERROR, 1, TEXT("Failed CreateEvent(m_hKSNotifyInterimEvent), GetLastError() %x"), GetLastError()));            
            *hr = E_OUTOFMEMORY;
            return;
        }


        m_hCtrlInterimEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); // Manual reset and Non-signal
        if(!m_hCtrlInterimEvent) {        
            DbgLog((LOG_ERROR, 1, TEXT("Failed CreateEvent(m_hCtrlInterimEvent), GetLastError() %x"), GetLastError()));            
            *hr = E_OUTOFMEMORY;
            return;
        }         
        m_hKSCtrlInterimEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);  // Manual reset and Non-signaled
        if(!m_hKSCtrlInterimEvent) {        
            DbgLog((LOG_ERROR, 1, TEXT("Failed CreateEvent(m_hKSCtrlInterimEvent), GetLastError() %x"), GetLastError()));            
            *hr = E_OUTOFMEMORY;
            return;
        }          

        //
        // Create a thread for processing transport state notification
        //
        *hr = CreateThread();
        if(FAILED(*hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CreateThread() failed hr %x"), *hr));
        }
    }
}


CAMExtTransport::~CAMExtTransport(
    )
/*++

Routine Description:

    The destructor for the IAMExtTransport interface.

--*/
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying CAMExtTransport...")));

    if (m_hKSNotifyInterimEvent || m_hKSCtrlInterimEvent || m_hKSDevRemovedEvent) {
        ExitThread();
        CloseHandle(m_hKSNotifyInterimEvent), m_hKSNotifyInterimEvent = NULL;
        CloseHandle(m_hKSCtrlInterimEvent),   m_hKSCtrlInterimEvent = NULL;
        CloseHandle(m_hKSDevRemovedEvent),    m_hKSDevRemovedEvent = NULL;
    }

    if(m_hCtrlInterimEvent) {
        DbgLog((LOG_TRACE, 1, TEXT("CAMExtTransport::Close hInterimEvent, Enabled %d, pProperty %x, plValue %x"), 
            m_bCtrlInterimEnabled, m_pExtXprtPropertyPending, m_plValue));                  
        ASSERT(!m_bCtrlInterimEnabled);
        CloseHandle(m_hCtrlInterimEvent), m_hCtrlInterimEvent = NULL;
    }

    if(m_hNotifyInterimEvent) {
        DbgLog((LOG_TRACE, 1, TEXT("CAMExtTransport::Close hInterimEvent, Enabled %d, cntNotifyInterim %d, pProperty %x, plValue %x"), 
            m_bNotifyInterimEnabled, m_cntNotifyInterim, m_pExtXprtPropertyPending, m_plValue));                  
        ASSERT(m_cntNotifyInterim == 0 && "Destroying this object but NotifyCount > 0");
        // ASSERT(!m_bNotifyInterimEnabled);
        CloseHandle(m_hNotifyInterimEvent), m_hNotifyInterimEvent = NULL;
    }

    DeleteCriticalSection(&m_csPendingData); 

}


STDMETHODIMP
CAMExtTransport::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMExtTransport.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IAMExtTransport)) {
        return GetInterface(static_cast<IAMExtTransport*>(this), ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 




HRESULT 
CAMExtTransport::GetCapability(
    long Capability, 
    long *pValue,
    double *pdblValue 
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TESTFLAG(Capability, OATRUE);

    //
    // Most of these command are related to the editing capability
    // When EditProperty is implemented, many capabilities will be enabled.
    //
    switch(Capability) {
    case ED_TRANSCAP_CAN_EJECT: // Can query this?
        return E_NOTIMPL;
        
    case ED_TRANSCAP_CAN_BUMP_PLAY:       
        return E_NOTIMPL;

    case ED_TRANSCAP_CAN_PLAY_BACKWARDS: 
        *pValue = OATRUE; break;   // Play backward, yes.
        
    case ED_TRANSCAP_CAN_SET_EE:
        return E_NOTIMPL;

    case ED_TRANSCAP_CAN_SET_PB:
        *pValue = OATRUE; break;   // ViewFinder

    case ED_TRANSCAP_CAN_DELAY_VIDEO_IN:    
    case ED_TRANSCAP_CAN_DELAY_VIDEO_OUT:        
    case ED_TRANSCAP_CAN_DELAY_AUDIO_IN:                
    case ED_TRANSCAP_CAN_DELAY_AUDIO_OUT: 
        return E_NOTIMPL;
        
    case ED_TRANSCAP_FWD_VARIABLE_MAX:     
    case ED_TRANSCAP_FWD_VARIABLE_MIN:
    case ED_TRANSCAP_REV_VARIABLE_MAX:
    case ED_TRANSCAP_REV_VARIABLE_MIN:
        return E_NOTIMPL;

    case ED_TRANSCAP_FWD_SHUTTLE_MAX:
    case ED_TRANSCAP_FWD_SHUTTLE_MIN:
    case ED_TRANSCAP_REV_SHUTTLE_MAX:
    case ED_TRANSCAP_REV_SHUTTLE_MIN:
        return E_NOTIMPL;

    case ED_TRANSCAP_NUM_AUDIO_TRACKS:
    case ED_TRANSCAP_LTC_TRACK:
    case ED_TRANSCAP_NEEDS_TBC:
    case ED_TRANSCAP_NEEDS_CUEING:
        return E_NOTIMPL;

    case ED_TRANSCAP_CAN_INSERT:
    case ED_TRANSCAP_CAN_ASSEMBLE:
    case ED_TRANSCAP_FIELD_STEP:   // SOme DV advance 1 frame some 1 field
    case ED_TRANSCAP_CLOCK_INC_RATE:
    case ED_TRANSCAP_CAN_DETECT_LENGTH:
        return E_NOTIMPL;

    case ED_TRANSCAP_CAN_FREEZE:
        *pValue = OATRUE; break;    // If this mean PLAY/RECORD PAUSE, yes.

    case ED_TRANSCAP_HAS_TUNER:
    case ED_TRANSCAP_HAS_TIMER:
    case ED_TRANSCAP_HAS_CLOCK:
        *pValue = OAFALSE; break;   // ViewFinder

    case ED_TRANSCAP_MULTIPLE_EDITS:
        return E_NOTIMPL;        

    case ED_TRANSCAP_IS_MASTER:
        *pValue = OATRUE; break;   // From filter graph point-of-view, DV is the master clock provider

    case ED_TRANSCAP_HAS_DT:
        *pValue = OAFALSE; break;   // ViewFinder
       
    default:
        return E_NOTIMPL;        
        break;
    }

    return S_OK;
}


HRESULT
CAMExtTransport::put_MediaState(
    long State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT  hr = S_OK;

    TESTFLAG(State, OAFALSE);


    // This might be different for a device other than a VCR, but:
    // ED_MEDIA_SPIN_UP: media inserted and not stopped
    // ED_MEDIA_SPIN_DOWN: media inserted and stopped
    // ED_MEDIA_UNLOAD: media ejected
    switch(State) {
    case ED_MEDIA_UNLOAD:         
        break;
    case ED_MEDIA_SPIN_UP:
    case ED_MEDIA_SPIN_DOWN:
       return E_NOTIMPL;
    }

// Add for AVC: LOAD MEDIUM
    // EJECT, OPEN_TRAY, or CLOSE_TRAY (all optional command)
    // Make sure capability support it first.

    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::get_MediaState(
    long FAR* pState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

// Add for AVC: LOAD MEDIUM, this is only a control CMD not a status cmd!!
    // Need to find status cmd that can query this info.
    // EJECT, OPEN_TRAY, or CLOSE_TRAY (all optional command)
    // Make sure capability support it first.

    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::put_LocalControl(
    long State
    )
/*++

Routine Description:
    Sets the state of the external device to local or remote control.

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::get_LocalControl(
    long FAR* pState
    )
/*++

Routine Description:
    Retrieve the state of the external device: local or remote.

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::GetStatus(
    long StatusItem, 
    long FAR* pValue
    )
/*++

Routine Description:
    Returns extended information about the external transport's staus.

Arguments:

Return Value:

--*/
{
    HRESULT hr = E_FAIL;
    LONG lTemp;

    TESTFLAG(StatusItem, OATRUE);

    // Device is removed and IOCTL will fail so return 
    // ERROR_DEVICE_REMOVED is much meaningful and efficient.
    if(m_bDevRemoved) {
        DbgLog((LOG_TRACE, 1, TEXT("DevRemoved:GetStatus(Item:%d)"), StatusItem));
        return ERROR_DEVICE_REMOVED;
    }

    switch(StatusItem){
    case ED_MODE_PLAY:
    case ED_MODE_FREEZE:    // Really "pause"
    //case ED_MODE_THAW:
    case ED_MODE_STEP_FWD:  // same as ED_MODE_STEP
    case ED_MODE_STEP_REV:      
    case ED_MODE_PLAY_FASTEST_FWD:    
    case ED_MODE_PLAY_SLOWEST_FWD:    
    case ED_MODE_PLAY_FASTEST_REV:    
    case ED_MODE_PLAY_SLOWEST_REV:       
    case ED_MODE_STOP:    
    case ED_MODE_FF:
    case ED_MODE_REW:  
    case ED_MODE_RECORD:
    case ED_MODE_RECORD_FREEZE:   
    case ED_MODE_RECORD_STROBE:
        get_Mode(&lTemp);  // Get current transport state and determine it if is the active mode.
        *pValue = lTemp == StatusItem ? OATRUE : OAFALSE;
        return S_OK;
     
    case ED_MODE_NOTIFY_ENABLE:
    case ED_MODE_NOTIFY_DISABLE:
    case ED_MODE_SHOT_SEARCH:
        return E_NOTIMPL;
        

    case ED_MODE:
        return get_Mode(pValue);

    // AVC: MEDIUM INFO: cassette_type+tape_grade_and_write_protect+tape present
    case ED_MEDIA_TYPE:
    case ED_RECORD_INHIBIT:     // REC lock
    case ED_MEDIA_PRESENT:
        break;

    case ED_MODE_CHANGE_NOTIFY:
        break;

    case ED_NOTIFY_HEVENT_GET:

        if(!m_bNotifyInterimEnabled &&  // If not being used.
            m_hNotifyInterimEvent) {

            // Initialize it!
            m_cntNotifyInterim = 0;
            m_bNotifyInterimEnabled = TRUE;
            *pValue = HandleToLong(m_hNotifyInterimEvent);

            // Non-signal
            ResetEvent(m_hNotifyInterimEvent);
            return NOERROR;

        } else {
            DbgLog((LOG_ERROR, 0, TEXT("GetStatus(ED_NOTIFY_HEVENT_GET): hr E_OUTOFMEMORY")));
            return E_OUTOFMEMORY;  // E_FAIL or probaly the reason why we do not hace a handle.
        }
        break;

    case ED_NOTIFY_HEVENT_RELEASE:
        // Reset them so KSEvent thread will act correctly.
        if(HandleToLong(m_hNotifyInterimEvent) == *pValue) {

            if(m_cntNotifyInterim > 0) {
                // Remove the pending notify command
                SetEvent(m_hKSNotifyInterimEvent);  // Signal its buddy KS event to retrieve the pending command                
                // When the listen thread process the KsNotifyInterimEvent, 
                // it will set (signal) NotifyInterimEvent.
                DWORD dwWaitStatus, 
                      dwWait = 10000; // In case that the processing thread terminated sooner, we wait for a fix time.
                dwWaitStatus = WaitForSingleObjectEx(m_hNotifyInterimEvent, dwWait, FALSE);  // Exit when thread terminate                
                DbgLog((LOG_TRACE, 1, TEXT("ED_NOTIFY_HEVENT_RELEASE: WaitSt:%d; m_cntNotifyInterim:%d"), dwWaitStatus, m_cntNotifyInterim)); 
                // ASSERT(dwWaitStatus == WAIT_OBJECT_0 && m_cntNotifyInterim == 0 && "Released  but NotifyCount > 0");
            }

            // Make sure that the thread that process the notify interim response 
            // will complete before this is executed since they share the same 
            // return variabled.
            EnterCriticalSection(&m_csPendingData);
            m_bNotifyInterimEnabled = FALSE;

            // Data from client; should we allocate this instead
            m_plValue         = NULL; 
            m_pExtXprtPropertyPending = NULL;

            LeaveCriticalSection(&m_csPendingData);

            return NOERROR;

        } else {
            DbgLog((LOG_ERROR, 0, TEXT("GetStatus(ED_NOTIFY_HEVENT_RELEASE): hr E_INVALIDARG")));
            return E_INVALIDARG;  // Is not the one we created.
        }
        break;

    case ED_CONTROL_HEVENT_GET:

        if(!m_bCtrlInterimEnabled  && // If not being used
            m_hCtrlInterimEvent) {

            m_bCtrlInterimEnabled = TRUE;
            *pValue = HandleToLong(m_hCtrlInterimEvent);

            // Non-signal
            ResetEvent(m_hCtrlInterimEvent);
            return NOERROR;

        } else {
            DbgLog((LOG_ERROR, 0, TEXT("GetStatus(ED_CONTROL_HEVENT_GET): hr E_OUTOFMEMORY")));
            return E_OUTOFMEMORY;  // E_FAIL or probaly the reason why we do not hace a handle.
        }
        break;

    case ED_CONTROL_HEVENT_RELEASE:
        // Reset them so KSEvent thread will act correctly.
        if(HandleToLong(m_hCtrlInterimEvent) == *pValue) {
            m_bCtrlInterimEnabled = FALSE;
            return NOERROR;

        } else {
            DbgLog((LOG_ERROR, 1, TEXT("GetStatus(ED_NOTIFY_HEVENT_RELEASE): hr E_INVALIDARG")));
            return E_INVALIDARG;  // Is not the one we created.
        }
        break;

    case ED_DEV_REMOVED_HEVENT_GET:

        if(!m_bDevRemovedEnabled  && // If not being used
            m_hDevRemovedEvent) {
            m_bDevRemovedEnabled = TRUE;

            *pValue = HandleToLong(m_hDevRemovedEvent);

            // Non-signal
            ResetEvent(m_hDevRemovedEvent);
            return NOERROR;

        } else {
            DbgLog((LOG_ERROR, 0, TEXT("GetStatus(ED_DEV_REMOVED_HEVENT_GET): hr E_OUTOFMEMORY")));
            return E_OUTOFMEMORY;  // E_FAIL or probaly the reason why we do not hace a handle.
        }
        break;

    case ED_DEV_REMOVED_HEVENT_RELEASE:
        // Reset them so KSEvent thread will act correctly.
        if(HandleToLong(m_hDevRemovedEvent) == *pValue) {

            m_bDevRemovedEnabled = FALSE;
            return NOERROR;

        } else {
            DbgLog((LOG_ERROR, 1, TEXT("GetStatus(ED_DEV_REMOVED_HEVENT_RELEASE): hr E_INVALIDARG")));
            return E_INVALIDARG;  // Is not the one we created.
        }
        break;

    // Not applicable to DVCR
    case ED_MEDIA_LENGTH:
    case ED_MEDIA_SIZE:
    case ED_MEDIA_TRACK_COUNT:
    case ED_MEDIA_TRACK_LENGTH:
    case ED_MEDIA_SIDE:         // DV has only one side
    case ED_LINK_MODE:          // Linked to graph's RUN, STOP and PAUSE state
    default:
        return E_NOTIMPL;
    }


    if(!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;

    } else if (StatusItem == ED_MODE_CHANGE_NOTIFY ) {

        DWORD cbBytesReturn;
        PKSPROPERTY_EXTXPORT_S pExtXPrtProperty;

        pExtXPrtProperty = (PKSPROPERTY_EXTXPORT_S) new KSPROPERTY_EXTXPORT_S;


        if(pExtXPrtProperty) {

            DbgLog((LOG_TRACE, 2, TEXT("GetStatus: issue ED_MODE_CHANGE_NOTIFY")));
                               
            RtlZeroMemory(pExtXPrtProperty, sizeof(KSPROPERTY_EXTXPORT_S));    
        
            //
            // Put data into structure
            //
            pExtXPrtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;   
            pExtXPrtProperty->Property.Id    = KSPROPERTY_EXTXPORT_STATE_NOTIFY;         
            pExtXPrtProperty->Property.Flags = KSPROPERTY_TYPE_SET;

            // Serial sending property
            EnterCriticalSection(&m_csPendingData);

            hr = 
                ExtDevSynchronousDeviceControl(
                    m_ObjectHandle
                   ,IOCTL_KS_PROPERTY
                   ,pExtXPrtProperty
                   ,sizeof(KSPROPERTY_EXTXPORT_S)
                   ,pExtXPrtProperty
                   ,sizeof(KSPROPERTY_EXTXPORT_S)
                   ,&cbBytesReturn
                   );

            // Serial sending property
            LeaveCriticalSection(&m_csPendingData);

            if(hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
                //
                // Save data and retrieve it again when the CmdEvent completion is signalled
                // to indicate the completion of this asychronous device operation
                //

                hr = E_PENDING;

                m_plValue    = pValue;
                m_pExtXprtPropertyPending = pExtXPrtProperty;

                m_cntNotifyInterim++;
                DbgLog((LOG_TRACE, 1, TEXT("CAMExtTransport::GetStatus, Enabled 0x%x, cntPendingCmd %d, pProperty %x, plValue %x"), 
                    &m_bNotifyInterimEnabled, m_cntNotifyInterim, m_pExtXprtPropertyPending, m_plValue));          
                ASSERT(m_cntNotifyInterim == 1 && "Pending command and NotifyCount > 1");
            }
        }

    } else {

        // Since we may need to wait for return notification
        // Need to dynamicaly allocate the property structure,
        // which includes an KSEVENT
        DWORD cbBytesReturn;
        PKSPROPERTY_EXTXPORT_S pExtXprtProperty;


        pExtXprtProperty = (PKSPROPERTY_EXTXPORT_S) new KSPROPERTY_EXTXPORT_S;

        if(pExtXprtProperty) {
            RtlZeroMemory(pExtXprtProperty, sizeof(KSPROPERTY_EXTXPORT_S));    

            switch(StatusItem){

            case ED_MEDIA_TYPE:
            case ED_RECORD_INHIBIT:
            case ED_MEDIA_PRESENT:
                pExtXprtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;   
                pExtXprtProperty->Property.Id    = KSPROPERTY_EXTXPORT_MEDIUM_INFO;         
                pExtXprtProperty->Property.Flags = KSPROPERTY_TYPE_GET;
                break;
            default:
                delete pExtXprtProperty;
                return E_NOTIMPL;
            }

            EnterCriticalSection(&m_csPendingData);

            hr = 
                ExtDevSynchronousDeviceControl(
                    m_ObjectHandle
                   ,IOCTL_KS_PROPERTY
                   ,pExtXprtProperty
                   ,sizeof (KSPROPERTY)
                   ,pExtXprtProperty
                   ,sizeof(KSPROPERTY_EXTXPORT_S)
                   ,&cbBytesReturn
                    );

            LeaveCriticalSection(&m_csPendingData);


            if(SUCCEEDED (hr)) {
                switch(StatusItem){
                case ED_MEDIA_TYPE:
                    *pValue = pExtXprtProperty->u.MediumInfo.MediaType;
                    break;
                case ED_RECORD_INHIBIT:
                    *pValue = pExtXprtProperty->u.MediumInfo.RecordInhibit;
                    break;
                case ED_MEDIA_PRESENT:
                    *pValue = pExtXprtProperty->u.MediumInfo.MediaPresent;
                    break;

                }

                DbgLog((LOG_TRACE, 2, TEXT("CAMExtTransport::GetStatus, hr %x, Bytes %d, StatusItem %d, Value %d"),
                    hr, cbBytesReturn, StatusItem, *pValue ));
            } else {
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::GetStatus, hr %x, Bytes %d, StatusItem %d, Value %d"),
                    hr, cbBytesReturn, StatusItem, *pValue ));
            }

            delete pExtXprtProperty;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}



#define CTYPE_CONTROL              0x00
#define CTYPE_STATUS               0x01
#define CTYPE_SPEC_INQ             0x02
#define CTYPE_NOTIFY               0x03
#define CTYPE_GEN_INQ              0x04
#define CTYPE_RESERVED_MAX         0x07

#define RESP_CODE_NOT_IMPLEMENTED  0x08
#define RESP_CODE_ACCEPTED         0x09
#define RESP_CODE_REJECTED         0x0a
#define RESP_CODE_IN_TRANSITION    0x0b
#define RESP_CODE_IMPLEMENTED      0x0c // also _STABLE
#define RESP_CODE_CHANGED          0x0d
#define RESP_CODE_INTERIM          0x0f 

#define MAX_AVC_CMD_PAYLOAD_SIZE    512 

HRESULT
CAMExtTransport::GetTransportBasicParameters(
    long Param,                                             
    long FAR* pValue,
    LPOLESTR * ppszData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = S_OK;  // == NOERROR

    TESTFLAG(Param, OATRUE);

    // Device is removed and IOCTL will fail so return 
    // ERROR_DEVICE_REMOVED is much meaningful and efficient.
    if(m_bDevRemoved) {
        DbgLog((LOG_TRACE, 1, TEXT("DevRemoved:GetTransportBasicParameters(Param:%d)"), Param));
        return ERROR_DEVICE_REMOVED;
    }

    //
    // Many parameters are related analog or disk so N/A.
    //
    switch(Param){
    case ED_TRANSBASIC_TIME_FORMAT:
        *pValue = m_TranBasicParms.TimeFormat;
        return S_OK;

    case ED_TRANSBASIC_TIME_REFERENCE:
        *pValue = m_TranBasicParms.TimeReference;
        return S_OK;

    case ED_TRANSBASIC_SUPERIMPOSE:
        return E_NOTIMPL;
        
    case ED_TRANSBASIC_END_STOP_ACTION:
        *pValue = m_TranBasicParms.EndStopAction;
        return S_OK;

    case ED_TRANSBASIC_RECORD_FORMAT:
        *pValue = m_TranBasicParms.RecordFormat;  // _SP, _LP, _EP
        return S_OK;

    case ED_TRANSBASIC_INPUT_SIGNAL:
    case ED_TRANSBASIC_OUTPUT_SIGNAL:
        break;

    case ED_TRANSBASIC_STEP_UNIT:
        *pValue = m_TranBasicParms.StepFrames;  // Unknown
        return S_OK;

    case ED_TRANSBASIC_STEP_COUNT:
        *pValue = m_TranBasicParms.SetpField;   // Unknown
        return S_OK;

    // Can return this to support frame accurate recording.
    case ED_TRANSBASIC_PREROLL:
    case ED_TRANSBASIC_RECPREROLL:
    case ED_TRANSBASIC_POSTROLL:
    case ED_TRANSBASIC_EDIT_DELAY:
    case ED_TRANSBASIC_PLAYTC_DELAY:
    case ED_TRANSBASIC_RECTC_DELAY:
        return E_NOTIMPL;

    case ED_TRANSBASIC_EDIT_FIELD:
    case ED_TRANSBASIC_FRAME_SERVO:
    case ED_TRANSBASIC_CF_SERVO:
    case ED_TRANSBASIC_SERVO_REF:
    case ED_TRANSBASIC_WARN_GL:
    case ED_TRANSBASIC_SET_TRACKING:
        return E_NOTIMPL;

    case ED_TRANSBASIC_BALLISTIC_1:
    case ED_TRANSBASIC_BALLISTIC_2:
    case ED_TRANSBASIC_BALLISTIC_3:
    case ED_TRANSBASIC_BALLISTIC_4:
    case ED_TRANSBASIC_BALLISTIC_5:
    case ED_TRANSBASIC_BALLISTIC_6:
    case ED_TRANSBASIC_BALLISTIC_7:
    case ED_TRANSBASIC_BALLISTIC_8:
    case ED_TRANSBASIC_BALLISTIC_9:
    case ED_TRANSBASIC_BALLISTIC_10:
    case ED_TRANSBASIC_BALLISTIC_11:
    case ED_TRANSBASIC_BALLISTIC_12:
    case ED_TRANSBASIC_BALLISTIC_13:
    case ED_TRANSBASIC_BALLISTIC_14:
    case ED_TRANSBASIC_BALLISTIC_15:
    case ED_TRANSBASIC_BALLISTIC_16:
    case ED_TRANSBASIC_BALLISTIC_17:
    case ED_TRANSBASIC_BALLISTIC_18:
    case ED_TRANSBASIC_BALLISTIC_19:
        *pValue = m_TranBasicParms.Ballistic[Param-ED_TRANSBASIC_BALLISTIC_1];
        return S_OK;
        
    case ED_TRANSBASIC_SETCLOCK:
        return E_NOTIMPL;

    // Use ED_RAW_EXT_DEV_CMD to send RAW AVC command only        
    case ED_RAW_EXT_DEV_CMD:
        break;
    default:
        return E_NOTIMPL;
    }

    if(!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;

    } else if ( Param == ED_TRANSBASIC_INPUT_SIGNAL || Param == ED_TRANSBASIC_OUTPUT_SIGNAL) {

        // Since we may need to wait for return notification
        // Need to dynamicaly allocate the property structure,
        // which includes an KSEVENT
        DWORD cbBytesReturn;
        PKSPROPERTY_EXTXPORT_S pExtXprtProperty;

        pExtXprtProperty = (PKSPROPERTY_EXTXPORT_S) new KSPROPERTY_EXTXPORT_S;

        if(pExtXprtProperty) {
            RtlZeroMemory(pExtXprtProperty, sizeof(KSPROPERTY_EXTXPORT_S)); 
            pExtXprtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;   
            pExtXprtProperty->Property.Id    = (Param == ED_TRANSBASIC_INPUT_SIGNAL ? 
                 KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE : KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE);         
            pExtXprtProperty->Property.Flags = KSPROPERTY_TYPE_GET;

            EnterCriticalSection(&m_csPendingData);
            hr = 
                ExtDevSynchronousDeviceControl(
                    m_ObjectHandle
                   ,IOCTL_KS_PROPERTY
                   ,pExtXprtProperty
                   ,sizeof (KSPROPERTY)
                   ,pExtXprtProperty
                   ,sizeof(KSPROPERTY_EXTXPORT_S)
                   ,&cbBytesReturn
                    );
            LeaveCriticalSection(&m_csPendingData);


            if(SUCCEEDED (hr)) {
                *pValue = pExtXprtProperty->u.SignalMode;
                DbgLog((LOG_TRACE, 2, TEXT("CAMExtTransport::GetTransportBasicParameters, hr %x, mode %x"),
                    hr, *pValue));                
            } else {
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::GetTransportBasicParameters, hr %x"),
                    hr));            
            }

            delete pExtXprtProperty;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    } else if ( Param == ED_RAW_EXT_DEV_CMD) {

        DWORD LastError = NOERROR;
        DWORD cbBytesReturn;
        PKSPROPERTY_EXTXPORT_S pExtXPrtProperty;       
        OVERLAPPED  ov;
        long lEvent = 0;
        HANDLE hEvent = NULL;
        HANDLE  EventHandles[2];
        DWORD   WaitStatus;
        HRESULT hrSet;  

        // Validate!
        if(!ppszData || !pValue)
            return ERROR_INVALID_PARAMETER;

        // Validate Command code
        BYTE CmdType = (BYTE) ppszData[0];
        if(CmdType > CTYPE_RESERVED_MAX) {
            DbgLog((LOG_ERROR, 0, TEXT("***** RAW_AVC; invalid cmdType [%x], [%x %x %x %x , %x %x %x %x]"), 
                CmdType, 
                (BYTE) ppszData[0],
                (BYTE) ppszData[1],
                (BYTE) ppszData[2],
                (BYTE) ppszData[3],
                (BYTE) ppszData[4],
                (BYTE) ppszData[5],
                (BYTE) ppszData[6],
                (BYTE) ppszData[7]
                ));

            // AVC command's CmdType is only valid from 0..7
            if(CmdType > CTYPE_RESERVED_MAX)
                return ERROR_INVALID_PARAMETER;
        }

        RtlZeroMemory(&ov, sizeof(OVERLAPPED));
        if (!(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL))) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        pExtXPrtProperty = (PKSPROPERTY_EXTXPORT_S) new KSPROPERTY_EXTXPORT_S;
        if(!pExtXPrtProperty) {
            CloseHandle(ov.hEvent);
            return E_FAIL;
        }
        // Serial sending property
        EnterCriticalSection(&m_csPendingData);  // Serialize in getting event

        //
        // Anticipate that this can result with an interim response        
        // Serialize issuing cmd among threads (COMIntf allows only one active cmd)        
        // Get an event, which will be signalled in COMIntf when the pending operation is completed.
        // Note that only Notify and Control cmd can result in Interim response.
        //
        if((BYTE) ppszData[0] == CTYPE_NOTIFY) {
            hr = GetStatus(ED_NOTIFY_HEVENT_GET, &lEvent);
            if(SUCCEEDED(hr))
                hEvent = LongToHandle(lEvent);
            DbgLog((LOG_TRACE, 2, TEXT("RAW_AVC; <Notify> hEvent %x"), hEvent));
        } 
        if((BYTE) ppszData[0] == CTYPE_CONTROL) {
            hr = GetStatus(ED_CONTROL_HEVENT_GET, &lEvent);
            if(SUCCEEDED(hr))
                hEvent = LongToHandle(lEvent);
            DbgLog((LOG_TRACE, 2, TEXT("RAW_AVC; <Control> hEvent %x"), hEvent));                                
        }

        if(FAILED(hr)) {
            LeaveCriticalSection(&m_csPendingData);
            DbgLog((LOG_ERROR, 0, TEXT("RAW_AVC; Get hEvent failed, hr %x"), hr));                        
            delete pExtXPrtProperty;
            pExtXPrtProperty = NULL;
            CloseHandle(ov.hEvent);
            return E_FAIL; 
        }

        RtlZeroMemory(pExtXPrtProperty, sizeof(KSPROPERTY_EXTXPORT_S));    
        
        //
        // Put data into structure
        //
        RtlCopyMemory(pExtXPrtProperty->u.RawAVC.Payload, ppszData, *pValue);
        pExtXPrtProperty->u.RawAVC.PayloadSize = *pValue;

        DbgLog((LOG_TRACE, 2, TEXT("RAW_AVC; Size %d; Payload %x; pProperty %x, PayloadRtn %x"), 
            *pValue, ppszData, pExtXPrtProperty, &pExtXPrtProperty->u.RawAVC));
            
        // Send this proerty; it is like issuing this AVC command
        pExtXPrtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;   
        pExtXPrtProperty->Property.Id    = KSPROPERTY_RAW_AVC_CMD;         
        pExtXPrtProperty->Property.Flags = KSPROPERTY_TYPE_SET;

#if 0
        if (!DeviceIoControl
                ( m_ObjectHandle
                , IOCTL_KS_PROPERTY
                , pExtXPrtProperty
                , sizeof(KSPROPERTY_EXTXPORT_S)
                , pExtXPrtProperty
                , sizeof(KSPROPERTY_EXTXPORT_S)
                , &cbBytesReturn
                , &ov
                )) {            
            
            // Serialize sending property
            LeaveCriticalSection(&m_csPendingData);

            // Function failed so find out the error code
            LastError = GetLastError();
            hr = HRESULT_FROM_WIN32(LastError);
            if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
                if (GetOverlappedResult(m_ObjectHandle, &ov, &cbBytesReturn, TRUE)) {
                    hr = NOERROR;
                } else {
                    LastError = GetLastError();
                    hr = HRESULT_FROM_WIN32(LastError);
                }
            }
            DbgLog((LOG_ERROR, 0, TEXT("RAW_AVC Set: Ioctl FALSE; LastError %dL; hr:0x%x"), LastError, hr));
        } 
        else {
            // Serialize sending property
            LeaveCriticalSection(&m_csPendingData);

            //
            // DeviceIoControl returns TRUE on success, even if the success
            // was not STATUS_SUCCESS. It also does not set the last error
            // on any successful return. Therefore any of the successful
            // returns which standard properties can return are not returned.
            //

            LastError = NOERROR;
            hr = NOERROR;

            //
            // ov.Internal valid when the GetOverlappedResult function returns 
            // without setting the extended error information to ERROR_IO_PENDING 
            //
            switch (ov.Internal) {
            case STATUS_SUCCESS:               // Normal case
                break;  // NOERROR
            case STATUS_MORE_ENTRIES:          // Special case
                // Wait for final response if there is a wait event
                if(hEvent) {
                    EventHandles[0] = hEvent;
                    EventHandles[1] = m_hThreadEndEvent;  // KSThread event
                    WaitStatus = WaitForMultipleObjects(2, EventHandles, FALSE, INFINITE);
                    if(WAIT_OBJECT_0 == WaitStatus) {
                        DbgLog((LOG_TRACE, 1, TEXT("RAW_AVC; FinalResp Rtn")));
                        // Get final response and its hr.
                    } else if (WAIT_OBJECT_0+1 == WaitStatus) {
                        DbgLog((LOG_TRACE, 0, TEXT("RAW_AVC;PENDING but m_hThreadEndEvent signalled")));
                    } else if (WAIT_FAILED == WaitStatus) {
                        LastError = GetLastError();
                        hr = HRESULT_FROM_WIN32(LastError);
                        DbgLog((LOG_ERROR, 0, TEXT("RAW_AVC,WAIT_FAILED;WaitStatus %x, LastErr %x"), WaitStatus, LastError));
                    } else {
                        // Wait for INFINITE so there is no other possible status.
                        DbgLog((LOG_ERROR, 0, TEXT("Unknown wait status:%x\n"), WaitStatus ));
                        ASSERT(FALSE && "Unknown wait status!");
                    }
                } else {
                    // Only control and notify command can have an interim response.
                    // In that case, an event must have been allocated so we cannot get here.
                    DbgLog((LOG_ERROR, 0, TEXT("No event for an interim response!\n") ));
                    ASSERT(FALSE && "Interim response but no event handle to wait!");
                }
                break;
            case STATUS_TIMEOUT:               // Special case
                hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
                break;
            case STATUS_REQUEST_NOT_ACCEPTED:  // Special case
                hr = HRESULT_FROM_WIN32(ERROR_REQ_NOT_ACCEP);
                break;
            case STATUS_NOT_SUPPORTED:         // Special case
                hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                break;
            case STATUS_REQUEST_ABORTED:       // Special case
                hr = HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED);
                break;                    ;
            default:
                DbgLog((LOG_ERROR, 0, TEXT("Unexpected ov.Internal code:%x; hr:%x"), ov.Internal, hr));
                ASSERT(FALSE && "Unexpected ov.Internal");
                break;                
            }
            if(NOERROR != HRESULT_CODE(hr)) {
                DbgLog((LOG_ERROR, 0, TEXT("SetRawAVC: ov.Internal:%x; hr:%x"), ov.Internal, hr));
            }
        }
#else
        hr = 
            ExtDevSynchronousDeviceControl(
                m_ObjectHandle
               ,IOCTL_KS_PROPERTY
               ,pExtXPrtProperty
               ,sizeof (KSPROPERTY_EXTXPORT_S)
               ,pExtXPrtProperty
               ,sizeof(KSPROPERTY_EXTXPORT_S)
               ,&cbBytesReturn
                );

        LeaveCriticalSection(&m_csPendingData);

        if(hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {        // Special case
            // Wait for final response if there is a wait event
            if(hEvent) {
                EventHandles[0] = hEvent;
                EventHandles[1] = m_hThreadEndEvent;  // KSThread event
                WaitStatus = WaitForMultipleObjects(2, EventHandles, FALSE, INFINITE);
                if(WAIT_OBJECT_0 == WaitStatus) {
                    DbgLog((LOG_TRACE, 1, TEXT("RAW_AVC; FinalResp Rtn")));
                    // Get final response and its hr.
                } else if (WAIT_OBJECT_0+1 == WaitStatus) {
                    DbgLog((LOG_TRACE, 0, TEXT("RAW_AVC;PENDING but m_hThreadEndEvent signalled")));
                } else if (WAIT_FAILED == WaitStatus) {
                    LastError = GetLastError();
                    hr = HRESULT_FROM_WIN32(LastError);
                    DbgLog((LOG_ERROR, 0, TEXT("RAW_AVC,WAIT_FAILED;WaitStatus %x, LastErr %x"), WaitStatus, LastError));
                } else {
                    // Wait for INFINITE so there is no other possible status.
                    DbgLog((LOG_ERROR, 0, TEXT("Unknown wait status:%x\n"), WaitStatus ));
                    ASSERT(FALSE && "Unknown wait status!");
                }
            } else {
                // Only control and notify command can have an interim response.
                // In that case, an event must have been allocated so we cannot get here.
                DbgLog((LOG_ERROR, 0, TEXT("No event for an interim response!\n") ));
                ASSERT(FALSE && "Interim response but no event handle to wait!");
            }
        }
#endif

        // The GET response IOCTL should return the response, but it might fail;
        // so the hr for SET command IOCTL is cached for proper return code
        hrSet = hr;

        // Release the wait event
        if(hEvent && (BYTE) ppszData[0] == CTYPE_NOTIFY)
            GetStatus(ED_NOTIFY_HEVENT_RELEASE, &lEvent);
        if(hEvent && (BYTE) ppszData[0] == CTYPE_CONTROL)
            GetStatus(ED_CONTROL_HEVENT_RELEASE, &lEvent);
        hEvent = NULL;

        // ********************************************************************************
        // Get the final result 
        // This is needed for final response of an interim response and for suceess command
        // **** This 2nd geet is needed since the SET cannot return the final result.******
        // ********************************************************************************

        // Always Get the final response. The worst case is the missing entry.or
        // ERROR_SET_NOT_FOUND; then we return the initial hr from issing the command.

        pExtXPrtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;
        pExtXPrtProperty->Property.Id    = KSPROPERTY_RAW_AVC_CMD;
        pExtXPrtProperty->Property.Flags = KSPROPERTY_TYPE_GET;
        
        EnterCriticalSection(&m_csPendingData);
#if 0
        if (!DeviceIoControl
                ( m_ObjectHandle
                , IOCTL_KS_PROPERTY
                , pExtXPrtProperty
                , sizeof(KSPROPERTY_EXTXPORT_S)
                , pExtXPrtProperty
                , sizeof(KSPROPERTY_EXTXPORT_S)
                , &cbBytesReturn
                , &ov
            )) {
            LeaveCriticalSection(&m_csPendingData);
    
            LastError = GetLastError();
            hr = HRESULT_FROM_WIN32(LastError);

            if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
                if (GetOverlappedResult(m_ObjectHandle, &ov, &cbBytesReturn, TRUE)) {
                    hr = NOERROR;
                } else {
                    LastError = GetLastError();
                    hr = HRESULT_FROM_WIN32(LastError);
                }
            }
            DbgLog((LOG_ERROR, 1, TEXT("RAW_AVC Set: Ioctl FALSE; LastError %dL; hr:0x%x"), LastError, hr));
        } else {
            LeaveCriticalSection(&m_csPendingData);

            // Possible return code:
            //     NOERROR                    0L   // ACCEPTED, IN_TRANSITION, STABLE, CHANGED
            //     ERROR_NOT_SUPPORTED       50L   // NOT_IMPLEMENTED
            //     ERROR_REQ_NOT_ACCEPTED    71L   // REJECTED
            //     ERROR_REQUEST_ABORTED   1235L   // Bus reset or device removal.
            //     ERROR_TIMEOUT           1460L   // Exceded 100msec

            LastError = NOERROR;
            hr = NOERROR;


            switch (ov.Internal) {
            case STATUS_TIMEOUT:               // Special case
                hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
                break;
            // REJECTED
            case STATUS_REQUEST_NOT_ACCEPTED:
                hr = HRESULT_FROM_WIN32(ERROR_REQ_NOT_ACCEP);
                break;
            // ACCEPTED or CHANGED                
            case STATUS_SUCCESS:
                break;  // NOERROR; Normal case
            case STATUS_NOT_SUPPORTED:         // Special case
                hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                break;
            case STATUS_REQUEST_ABORTED:       // Special case
                hr = HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED);
                break; 
            default:
                DbgLog((LOG_ERROR, 0, TEXT("SetRawAVC unknown ov.Internal:%x"), ov.Internal));
                ASSERT(FALSE && "Unexcepted ov.Internal for interim response");
                break;
            }
        } 
#else
        hr = 
            ExtDevSynchronousDeviceControl(
                m_ObjectHandle
               ,IOCTL_KS_PROPERTY
               ,pExtXPrtProperty
               ,sizeof (KSPROPERTY)
               ,pExtXPrtProperty
               ,sizeof(KSPROPERTY_EXTXPORT_S)
               ,&cbBytesReturn
                );
        LeaveCriticalSection(&m_csPendingData);
#endif

        //
        // Note: a driver may return STATUS_SUCCES (NOERROR) for any response, or a driver
        // may return a corresponding status code that matches its response code, such as 
        // 0x09 with STATUS_REQUEST_NOT_ACCEPTED (ERROR_REQ_NOT_ACCEP)
        //
        if(NOERROR             == HRESULT_CODE(hr) ||
           ERROR_REQ_NOT_ACCEP == HRESULT_CODE(hr) ||
           ERROR_NOT_SUPPORTED == HRESULT_CODE(hr)
           ) {

            // Copy the response codes
            *pValue = pExtXPrtProperty->u.RawAVC.PayloadSize;
            if(*pValue > MAX_AVC_CMD_PAYLOAD_SIZE) {
                ASSERT(*pValue <= MAX_AVC_CMD_PAYLOAD_SIZE && "Exceed max len; driver error?");  // Max payload size; driver error?
                *pValue = MAX_AVC_CMD_PAYLOAD_SIZE;  // Can only return to the max
            }
            RtlCopyMemory(ppszData, pExtXPrtProperty->u.RawAVC.Payload,  *pValue);
        }

        //
        // Only need to translate the response code to hr if a
        // driver return STATUS_SUCESS response.
        // 
        if(NOERROR == HRESULT_CODE(hr)) {

            // Translate the response code to the corresponding HRESULT code
            // This might be redundant but it is safer 
            switch((BYTE) ppszData[0]) {
            case RESP_CODE_ACCEPTED: 
            case RESP_CODE_IN_TRANSITION:
            case RESP_CODE_IMPLEMENTED:
                hr = NOERROR;  // Normal case.
                break;
            case RESP_CODE_REJECTED:
                hr = HRESULT_FROM_WIN32(ERROR_REQ_NOT_ACCEP);
                break;
            case RESP_CODE_NOT_IMPLEMENTED:
                hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                break;
            case RESP_CODE_CHANGED:
            case RESP_CODE_INTERIM:
                DbgLog((LOG_ERROR, 0, TEXT("Unexpected response code:%x:%x; hr:%x"),(BYTE) ppszData[0], (BYTE) ppszData[1], hr));
                ASSERT(FALSE && "Unexpected response code CHANGED or INTERIM!");
                hr = hrSet;
                break;
            default:
                DbgLog((LOG_ERROR, 0, TEXT("Unknown response code:%x:%x; hr:%x"),(BYTE) ppszData[0], (BYTE) ppszData[1], hr));
                ASSERT(FALSE && "Unknown response code!");
                hr = hrSet;
                break;
            }

            DbgLog((LOG_TRACE, 2, TEXT("RAW_AVC <Get>: hr %x, cByteRtn %d, PayloadSize %d"),
                hr, cbBytesReturn, *pValue ));

        } else {
            // If the response is not in the queue, it could be an invalid command to start with.
            if(ERROR_SET_NOT_FOUND == HRESULT_CODE(hr)) {
                hr = hrSet;  // Use initial hrSet from issing the AV/C command.
            }

            DbgLog((LOG_ERROR, 1, TEXT("RAW_AVC <Get>: Failed hr %x, cByteRtn %d, PayloadSize %d"),
                hr, cbBytesReturn, *pValue));          
        }        
        

        // 
        // For legacy reason, we will continue to return just the code part of the HRESULT
        //
        hr = HRESULT_CODE(hr);

        delete pExtXPrtProperty; 
        pExtXPrtProperty = NULL;
        CloseHandle(ov.hEvent);
        DbgLog((LOG_TRACE, 0, TEXT("RAW_AVC: completed with hr:0x%x (%dL); HRESULT:0x%x (%dL)"), hr, hr, 
            HRESULT_FROM_WIN32(hr), HRESULT_FROM_WIN32(hr))); 
    }
    return hr;
}



HRESULT
CAMExtTransport::SetTransportBasicParameters(
    long Param, 
    long Value,
    LPCOLESTR pszData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    // Device is removed and IOCTL will fail so return 
    // ERROR_DEVICE_REMOVED is much meaningful and efficient.
    if(m_bDevRemoved) {
        DbgLog((LOG_TRACE, 1, TEXT("DevRemoved:SetTransportBasicParameters(Param:%d)"), Param));
        return ERROR_DEVICE_REMOVED;
    }

    switch(Param){
    case ED_TRANSBASIC_TIME_FORMAT:
    case ED_TRANSBASIC_TIME_REFERENCE:
    case ED_TRANSBASIC_SUPERIMPOSE:
    case ED_TRANSBASIC_END_STOP_ACTION:
        return E_NOTIMPL;
        
    //  maybe enable this later.
    case ED_TRANSBASIC_RECORD_FORMAT:
    case ED_TRANSBASIC_INPUT_SIGNAL:
    case ED_TRANSBASIC_OUTPUT_SIGNAL:
        return E_NOTIMPL;

    case ED_TRANSBASIC_STEP_UNIT:
    case ED_TRANSBASIC_STEP_COUNT:
        return E_NOTIMPL;

    case ED_TRANSBASIC_PREROLL:
    case ED_TRANSBASIC_RECPREROLL:
    case ED_TRANSBASIC_POSTROLL:
    case ED_TRANSBASIC_EDIT_DELAY:
    case ED_TRANSBASIC_PLAYTC_DELAY:
    case ED_TRANSBASIC_RECTC_DELAY:
    case ED_TRANSBASIC_EDIT_FIELD:
    case ED_TRANSBASIC_FRAME_SERVO:
    case ED_TRANSBASIC_CF_SERVO:
    case ED_TRANSBASIC_SERVO_REF:
    case ED_TRANSBASIC_WARN_GL:
    case ED_TRANSBASIC_SET_TRACKING:
        return E_NOTIMPL;

    // Allow application to save its Ballictic value
    case ED_TRANSBASIC_BALLISTIC_1:
    case ED_TRANSBASIC_BALLISTIC_2:
    case ED_TRANSBASIC_BALLISTIC_3:
    case ED_TRANSBASIC_BALLISTIC_4:
    case ED_TRANSBASIC_BALLISTIC_5:
    case ED_TRANSBASIC_BALLISTIC_6:
    case ED_TRANSBASIC_BALLISTIC_7:
    case ED_TRANSBASIC_BALLISTIC_8:
    case ED_TRANSBASIC_BALLISTIC_9:
    case ED_TRANSBASIC_BALLISTIC_10:
    case ED_TRANSBASIC_BALLISTIC_11:
    case ED_TRANSBASIC_BALLISTIC_12:
    case ED_TRANSBASIC_BALLISTIC_13:
    case ED_TRANSBASIC_BALLISTIC_14:
    case ED_TRANSBASIC_BALLISTIC_15:
    case ED_TRANSBASIC_BALLISTIC_16:
    case ED_TRANSBASIC_BALLISTIC_17:
    case ED_TRANSBASIC_BALLISTIC_18:
    case ED_TRANSBASIC_BALLISTIC_19:
        m_TranBasicParms.Ballistic[Param-ED_TRANSBASIC_BALLISTIC_1] = Value;
        return S_OK;
        
    case ED_TRANSBASIC_SETCLOCK:
        return E_NOTIMPL;

    default:
        return E_NOTIMPL;
    }
}


HRESULT
CAMExtTransport::GetTransportVideoParameters(
    long Param, 
    long FAR* pValue
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = S_OK;

    TESTFLAG(Param, OATRUE);

    // Device is removed and IOCTL will fail so return 
    // ERROR_DEVICE_REMOVED is much meaningful and efficient.
    if(m_bDevRemoved) {
        DbgLog((LOG_TRACE, 1, TEXT("DevRemoved:GetTransportVideoParameters(Param:%d)"), Param));
        return ERROR_DEVICE_REMOVED;
    }

    switch (Param) {
    case ED_TRANSVIDEO_SET_OUTPUT:
    case ED_TRANSVIDEO_SET_SOURCE:
    default:
        return E_NOTIMPL;
    }

    return hr;
}


HRESULT
CAMExtTransport::SetTransportVideoParameters(
    long Param, 
    long Value
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // Use defaults; no change allows.
    return E_NOTIMPL; 
}


HRESULT
CAMExtTransport::GetTransportAudioParameters(
    long Param, 
    long FAR* pValue
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // Enable this when Edit Property Set are supported.
    return E_NOTIMPL;     
}


HRESULT
CAMExtTransport::SetTransportAudioParameters(
    long Param, 
    long Value
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL; 
}


HRESULT
CAMExtTransport::put_Mode(
    long Mode
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = S_OK;

    TESTFLAG(Mode, OATRUE);

    // Device is removed and IOCTL will fail so return 
    // ERROR_DEVICE_REMOVED is much meaningful and efficient.
    if(m_bDevRemoved) {
        DbgLog((LOG_TRACE, 1, TEXT("DevRemoved:DevRemoved: put_Mode(Mode:%d)"), Mode));
        return ERROR_DEVICE_REMOVED;
    }

    switch (Mode) {
    case ED_MODE_PLAY:
    case ED_MODE_FREEZE:  // Really "pause"
    //case ED_MODE_THAW:
    case ED_MODE_STEP_FWD:  // same as ED_MODE_STEP
    case ED_MODE_STEP_REV:    
    
    case ED_MODE_PLAY_FASTEST_FWD:    
    case ED_MODE_PLAY_SLOWEST_FWD:    
    case ED_MODE_PLAY_FASTEST_REV:    
    case ED_MODE_PLAY_SLOWEST_REV:    
    
    case ED_MODE_STOP:    
    case ED_MODE_FF:
    case ED_MODE_REW:
    
    case ED_MODE_RECORD:
    case ED_MODE_RECORD_STROBE:
    case ED_MODE_RECORD_FREEZE:
        break;
    case ED_MODE_NOTIFY_ENABLE:
    case ED_MODE_NOTIFY_DISABLE:
    case ED_MODE_SHOT_SEARCH:       
    default:
        hr = E_NOTIMPL;
        break;
    }


    if(!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;

    }
    else {

#if 0
        // Serial sending property
        EnterCriticalSection(&m_csPendingData);  // Serialize in getting event

        //
        // Anticipate that this can result with an interim response 
        //
        hr = GetStatus(ED_CONTROL_HEVENT_GET, (long *) &hEvent);
        if(!SUCCEEDED(hr)) {
            LeaveCriticalSection(&m_csPendingData);
            DbgLog((LOG_ERROR, 0, TEXT("CAMExtTransport::put_Mode Failed to get control event; hr:%x"), hr));
            return hr;
        }
#endif
        // Since we may need to wait for return notification
        // Need to dynamicaly allocate the property structure,
        // which includes an KSEVENT
        DWORD cbBytesReturn;
        PKSPROPERTY_EXTXPORT_S pExtXprtProperty = 
            (PKSPROPERTY_EXTXPORT_S) VirtualAlloc (
                            NULL, 
                            sizeof(KSPROPERTY_EXTXPORT_S),
                            MEM_COMMIT | MEM_RESERVE,
                            PAGE_READWRITE);
        
        if(pExtXprtProperty) {

            RtlZeroMemory(pExtXprtProperty, sizeof(KSPROPERTY_EXTXPORT_S));    

            pExtXprtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;   
            pExtXprtProperty->Property.Id    = KSPROPERTY_EXTXPORT_STATE;       
            pExtXprtProperty->Property.Flags = KSPROPERTY_TYPE_SET;
            pExtXprtProperty->u.XPrtState.Mode = Mode;  // Pass in

            EnterCriticalSection(&m_csPendingData);

            hr = 
                ExtDevSynchronousDeviceControl(
                    m_ObjectHandle
                   ,IOCTL_KS_PROPERTY
                   ,pExtXprtProperty
                   ,sizeof (KSPROPERTY)
                   ,pExtXprtProperty
                   ,sizeof(KSPROPERTY_EXTXPORT_S)
                   ,&cbBytesReturn
                    );

            LeaveCriticalSection(&m_csPendingData);


            if(SUCCEEDED(hr)) {
                m_TranStatus.Mode = Mode;

            } else {            
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::put_Mode Failed hr %x"), hr));
            }

            VirtualFree(pExtXprtProperty, 0, MEM_RELEASE);
        }
    }

    DbgLog((LOG_TRACE, 2, TEXT("CAMExtTransport::put_Mode hr %x, Mode %d"), hr, Mode));
   
    return hr;
}


HRESULT
CAMExtTransport::get_Mode(
    long FAR* pMode
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = E_FAIL;

    // Device is removed and IOCTL will fail so return 
    // ERROR_DEVICE_REMOVED is much meaningful and efficient.
    if(m_bDevRemoved) {
        DbgLog((LOG_TRACE, 1, TEXT("DevRemoved:get_Mode")));
        return ERROR_DEVICE_REMOVED;
    }

    //
    // THINK: Do we cache the transport state of ALWAYS requery ????
    // Since user can control the DV localy, it is safer to requery.
    //

    if(!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;

    } else {

        DWORD cbBytesReturn;
        PKSPROPERTY_EXTXPORT_S pExtXprtProperty;


        pExtXprtProperty = (PKSPROPERTY_EXTXPORT_S) new KSPROPERTY_EXTXPORT_S;

        if(pExtXprtProperty) {
        
            RtlZeroMemory(pExtXprtProperty, sizeof(KSPROPERTY_EXTXPORT_S));
            pExtXprtProperty->Property.Set   = PROPSETID_EXT_TRANSPORT;   
            pExtXprtProperty->Property.Id    = KSPROPERTY_EXTXPORT_STATE;         
            pExtXprtProperty->Property.Flags = KSPROPERTY_TYPE_GET;

            EnterCriticalSection(&m_csPendingData);

            hr = 
                ExtDevSynchronousDeviceControl(
                    m_ObjectHandle
                   ,IOCTL_KS_PROPERTY
                   ,pExtXprtProperty
                   ,sizeof (KSPROPERTY)
                   ,pExtXprtProperty
                   ,sizeof(KSPROPERTY_EXTXPORT_S)
                   ,&cbBytesReturn
                    );

            LeaveCriticalSection(&m_csPendingData);


            if(SUCCEEDED (hr)) {
                *pMode = pExtXprtProperty->u.XPrtState.State; // Mode;
                DbgLog((LOG_TRACE, 2, TEXT("CAMExtTransport::get_Mode, hr %x, BytesRtn %d, Mode %dL"),
                    hr, cbBytesReturn, *pMode ));
                
            } else {
                DbgLog((LOG_ERROR, 1, TEXT("CAMExtTransport::get_Mode, hr %x"), hr));           
            }

            delete pExtXprtProperty;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    return hr;
}


HRESULT
CAMExtTransport::put_Rate(
    double dblRate
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::get_Rate(
    double FAR* pdblRate
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::GetChase(
    long FAR* pEnabled, 
    long FAR* pOffset,
    HEVENT FAR* phEvent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::SetChase(
    long Enable, 
    long Offset, 
    HEVENT hEvent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::GetBump(
    long FAR* pSpeed, 
    long FAR* pDuration
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::SetBump(
    long Speed, 
    long Duration
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::get_AntiClogControl(
    long FAR* pEnabled
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::put_AntiClogControl(
    long Enable
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::GetEditPropertySet(
    long EditID, 
    long FAR* pState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::SetEditPropertySet(
    long FAR* pEditID, 
    long State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::GetEditProperty(
    long EditID,                                                                  
    long Param,                                  
    long FAR* pValue
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::SetEditProperty(
    long EditID, 
    long Param, 
    long Value
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::get_EditStart(
    long FAR* pValue
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}


HRESULT
CAMExtTransport::put_EditStart(
    long Value
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\dvcrpage.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// DVcrPage.cpp  Property page for DVcrControl
// 
// Revision: 1.00 3-28-99
//

#include "pch.h"
#include <tchar.h>
#include <XPrtDefs.h>  
#include "DVcrPage.h"
#include "resource.h"

         
// -------------------------------------------------------------------------
// CDVcrControlProperties
// -------------------------------------------------------------------------

CUnknown *
CALLBACK
CDVcrControlProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties::CreateInstance.")));

    CUnknown *punk = new CDVcrControlProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


DWORD
CDVcrControlProperties::MainThreadProc(
    )
{
    HRESULT hr;// End this Thread.
    HANDLE  EventHandles[3];
    long lEvent;
    HANDLE  hEvent = NULL;

    long lEventDevRemoved = 0;
    HANDLE  hEventDevRemoved = NULL;

    DWORD   WaitStatus;
    DWORD   dwFinalRC;
    LONG    lXPrtState;
    BOOL    bNotifyPending;


    //
    // Get an event from CPOMIntf to detect device removal
    //
    hr = m_pDVcrExtTransport->GetStatus(ED_DEV_REMOVED_HEVENT_GET, &lEventDevRemoved);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: Get hEventDevRemoved failed, hr %x"), hr));                        
        return 1; 
    } else {
        hEventDevRemoved = LongToHandle(lEventDevRemoved);
        DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc: Get hEventDevRemoved %x->%x"), lEventDevRemoved, hEventDevRemoved));
    }

    //
    // Get an event, which will be signalled in COMIntf when the pending operation is completed.
    //
    hr = m_pDVcrExtTransport->GetStatus(ED_NOTIFY_HEVENT_GET, &lEvent);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: Get hEvent failed, hr %x"), hr));
        
        hr = m_pDVcrExtTransport->GetStatus(ED_DEV_REMOVED_HEVENT_RELEASE, &lEventDevRemoved);
        DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc: Release hEventDevRemoved; hr:%x"), hr));                        
        if(FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: Release hEventDevRemoved failed, hr %x"), hr)); 
        }
        return 1; 
    } else {
        hEvent = LongToHandle(lEvent);
        DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc: Get hEventDevRemoved %x->%x"), lEvent, hEvent));
    }

    // Event to wait on                      
    EventHandles[0] = hEventDevRemoved;
    EventHandles[1] = m_hThreadEndEvent;
    EventHandles[2] = hEvent;

    while (m_hThread && hEvent && m_hThreadEndEvent && hEventDevRemoved) {
         
        // Maybe transport notify feature might be supported.
        // If it if E_PENDING is returned.
        lXPrtState = 0;
        // Try this only once.
        hr = m_pDVcrExtTransport->GetStatus(ED_MODE_CHANGE_NOTIFY, &lXPrtState);
        if(hr == E_PENDING) { 
            bNotifyPending = TRUE;
#ifdef DEBUG
            // Indicate notification capability; for debug only.
            ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_NOTIFY_ON), TRUE);        
#endif   
        } else {        
            bNotifyPending = FALSE;  // NO need to wait for this event.
            // The hEvent could be released here...

            // Unexpected (or error) behaviour has occurred;             
            switch(HRESULT_CODE(hr)) {
            case NOERROR:                 // STATUS_SUCCESS (Complete Notification sychronously ??)
                DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: GetStatus(ED_MODE_CHANGE_NOTIFY) complted sychronously? hr %x"), hr));            
                break;
            case ERROR_GEN_FAILURE:       // STATUS_UNSUCCESSFUL (rejected)
                DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: GetStatus(ED_MODE_CHANGE_NOTIFY) UNSUCCESSFUL, hr %x"), hr));            
                break;
            case ERROR_INVALID_FUNCTION:  // STATUS_NOT_IMPLEMENTED
                DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: GetStatus(ED_MODE_CHANGE_NOTIFY) NOT_IMPLEMENTED, hr %x"), hr));            
                break;
            case ERROR_CRC:               // STATUS_DEVICE_DATA_ERROR (Data did not get to device)
                // Most likely, device was not ready to accept another command, wait and try again.
                DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: GetStatus(ED_MODE_CHANGE_NOTIFY) CRC/DATA error! hr %x"), hr));            
                break;
            case ERROR_SEM_TIMEOUT:       // STATUS_IO_TIMEOUT (Operation not supported or device removed ?)
                DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: GetStatus(ED_MODE_CHANGE_NOTIFY) timeout! hr %x"), hr));            
                break;
            case ERROR_INVALID_PARAMETER: // STATUS_INVALID_PARAMETER 
                DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: GetStatus(ED_MODE_CHANGE_NOTIFY) invalid parameter! hr %x"), hr));            
                break;
            default:
                DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: GetStatus(ED_MODE_CHANGE_NOTIFY) unknown RC; hr %x"), hr));                        
            break;
            } 
        }

        // Waiting a event to trigger.
        WaitStatus = 
             WaitForMultipleObjects(
                bNotifyPending ? 3 : 2, // 3 if Notify XPrt cmd is supported
                EventHandles, 
                FALSE,                  // Return when one event is signalled
                INFINITE
                );

         // ** Device removed
        if(WAIT_OBJECT_0 == WaitStatus) {
            TCHAR szBuf[256];
            LoadString(g_hInst, IDS_DEV_REMOVED, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            SetDlgItemText(m_hwnd, IDC_TXT_TAPE_FORMAT, (LPCTSTR)szBuf);
            ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_WRITE_PROTECTED),FALSE);
            break;  // End this thread
         // ** Thread is ending
        } else if (WAIT_OBJECT_0+1 == WaitStatus) {
            DbgLog((LOG_TRACE, 1, TEXT("m_hThreadEndEvent event thread exiting")));
            break;  // End this Thread.
         // ** Pending XPrt notify command completed.
        } else if (WAIT_OBJECT_0+2 == WaitStatus) {
            dwFinalRC = GetLastError();  // COMIntf will properly SetLastError()
            DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc:GetStatus final RC %dL, XPrtState %dL->%dL"), dwFinalRC, m_lCurXPrtState, lXPrtState));
            UpdateTransportState(lXPrtState);
            
            ResetEvent(hEvent);  // Set to non-signal manually or this will be an infinite loop.
            // Wait for another interim response
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: WaitStatus %x, GetLastError() 0x%x"), WaitStatus, GetLastError()));                
            break;  // End this Thread.
        }
    }


    // Release event to detect device removal
    hr = m_pDVcrExtTransport->GetStatus(ED_DEV_REMOVED_HEVENT_RELEASE, &lEventDevRemoved);
    DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc: Release hEventDevRemoved; hr:%x"), hr));                        
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: Release hEventDevRemoved failed, hr %x"), hr));                        
    }

    // Since "lXPrtState" is local, we MUST tell COMIntf that we no longer need the event and wants to
    // to cancel(ignore) pending dev control cmd and do not write to "lXPrtState" after this.   
    hr = m_pDVcrExtTransport->GetStatus(ED_NOTIFY_HEVENT_RELEASE, &lEvent);
    DbgLog((LOG_TRACE, 1, TEXT("MainThreadProc: Release hEvent; hr:%x"), hr));                        
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("MainThreadProc: Release hEvent failed, hr %x"), hr));                        
    }

#ifdef DEBUG
    // Indicate notification capability; for debug only.
    ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_NOTIFY_ON), FALSE);        
#endif

    return 1; 
}


DWORD
WINAPI
CDVcrControlProperties::InitialThreadProc(
    CDVcrControlProperties *pThread
    )
{
    return pThread->MainThreadProc();
}



HRESULT
CDVcrControlProperties::CreateNotifyThread(void)
{
    HRESULT hr = NOERROR;

    if (m_hThreadEndEvent != NULL) {
        ASSERT(m_hThread == NULL);
        DWORD ThreadId;
        m_hThread = 
            ::CreateThread( 
                NULL
                , 0
                , (LPTHREAD_START_ROUTINE) (InitialThreadProc)
                , (LPVOID) (this)
                , 0
                , &ThreadId
                );

        if (m_hThread == NULL) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DbgLog((LOG_ERROR, 1, TEXT("CDVcrControlProperties: CreateNotifyThread() failed hr %x"), hr));
            CloseHandle(m_hThreadEndEvent), m_hThreadEndEvent = NULL;

        } else {
            DbgLog((LOG_TRACE, 2, TEXT("CDVcrControlProperties: CreateNotifyThread() ThreadEndEvent %ld, Thread %ld"),m_hThreadEndEvent, m_hThread));
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DbgLog((LOG_ERROR, 1, TEXT("CDVcrControlProperties:CreateNotifyThread, CreateEvent(m_hThreadEndEvent) failed hr %x"), hr));
    }

    return hr;
}



HRESULT
CDVcrControlProperties::ATNSearch(
    )
{
    HRESULT hr;
    TIMECODE_SAMPLE TimecodeSample;
    TCHAR szHH[4], szMM[4], szSS[4], szFF[4];
    int iHHFrom, iHH, iMMFrom, iMM, iSSFrom, iSS, iFFFrom, iFF, iNTSCDFAdjust;
    ULONG ulTrackNumToSearch;
    LONG cntByte = 8;
    BYTE RawAVCPkt[8] = {0x00, 0x20, 0x52, 0x20, 0xff, 0xff, 0xff, 0xff};  // ATN search take 8 bytes


    TimecodeSample.timecode.dwFrames = 0;
    TimecodeSample.dwFlags = ED_DEVCAP_TIMECODE_READ;
    hr = m_pDVcrTmCdReader->GetTimecode(&TimecodeSample);

    if(FAILED(hr)) {   
        // Load from string table
        MessageBox (NULL, TEXT("Could not read timecode!"), TEXT("Track number search"), MB_OK);
        return hr;
    }    

    iHHFrom = (TimecodeSample.timecode.dwFrames & 0xff000000) >> 24;
    iMMFrom = (TimecodeSample.timecode.dwFrames & 0x00ff0000) >> 16;
    iSSFrom = (TimecodeSample.timecode.dwFrames & 0x0000ff00) >> 8;
    iFFFrom =  TimecodeSample.timecode.dwFrames & 0x000000ff;

    //
    // Get user input and validate them
    //
    iHH = GetWindowText(GetDlgItem(m_hwnd, IDC_EDT_TC_HH), szHH, 4);
    if(iHH == 0) {
        goto InvalidParam;
    }
    iHH = _ttoi(szHH);
    if(iHH > 2 || iHH < 0) {
        goto InvalidParam;
    }

    iMM = GetWindowText(GetDlgItem(m_hwnd, IDC_EDT_TC_MM), szMM, 4);
    if(iMM == 0) {
        goto InvalidParam;
    }
    iMM = _ttoi(szMM);
    if(iMM > 59 || iMM < 0) {
        goto InvalidParam;
    }


    iSS = GetWindowText(GetDlgItem(m_hwnd, IDC_EDT_TC_SS), szSS, 4);
    if(iSS == 0) {
        goto InvalidParam;
    }
    iSS = _ttoi(szSS);
    if(iSS > 59 || iSS < 0) {
        goto InvalidParam;
    }


    iFF = GetWindowText(GetDlgItem(m_hwnd, IDC_EDT_TC_FF), szFF, 4);
    if(iFF == 0) {
        goto InvalidParam;
    }
    iFF = _ttoi(szFF);
    if(iFF >= 30 || iFF < 0) {
        goto InvalidParam;
    }

    if(m_lAvgTimePerFrame == 40) {      
        ulTrackNumToSearch = ((iHH * 3600 + iMM * 60 + iSS) * 25 + iFF) * 12 * 2;
    } else {
        //
        // Drop two frame every minutes
        //
        iNTSCDFAdjust = ((iHH * 60 + iMM) - (iHH * 60 + iMM) / 10) * 2;
        ulTrackNumToSearch = ((iHH * 3600 + iMM * 60 + iSS) * 30 + iFF - iNTSCDFAdjust) * 10 * 2;
    }


    DbgLog((LOG_ERROR, 0, TEXT("ATNSearch: %d:%d:%d:%d -> %d:%d:%d:%d (%d)"), 
        iHHFrom, iMMFrom, iSSFrom, iFFFrom, iHH, iMM, iSS, iFF, ulTrackNumToSearch));    

    RawAVCPkt[4] = (BYTE)  (ulTrackNumToSearch & 0x000000ff);
    RawAVCPkt[5] = (BYTE) ((ulTrackNumToSearch & 0x0000ff00) >> 8);
    RawAVCPkt[6] = (BYTE) ((ulTrackNumToSearch & 0x00ff0000) >> 16);

    DbgLog((LOG_ERROR, 0, TEXT("Send %d  [%x %x %x %x : %x %x %x %x]"), 
        cntByte,
        RawAVCPkt[0], RawAVCPkt[1], RawAVCPkt[2], RawAVCPkt[3], 
        RawAVCPkt[4], RawAVCPkt[5], RawAVCPkt[6], RawAVCPkt[7] ));
   

    // Start timer if it hasn;t.
    UpdateTimecodeTimer(TRUE);  // If timer has not already start, do no so we can see its progress
    hr = 
        m_pDVcrExtTransport->GetTransportBasicParameters(
            ED_RAW_EXT_DEV_CMD, 
            &cntByte, 
            (LPOLESTR *)RawAVCPkt
            );
    UpdateTimecodeTimer(FALSE);  // Turn it off and; ExitThread routine will update that.
    UpdateTimecode();

    DbgLog((LOG_ERROR, 0, TEXT("ATNSearch hr %x"), hr)); 
    return hr;

InvalidParam:

    MessageBox (NULL, TEXT("Invalid parameter!"), TEXT("Track number search"), MB_OK);

    return ERROR_INVALID_PARAMETER;
}



DWORD
WINAPI
CDVcrControlProperties::DoATNSearchThreadProc(
    CDVcrControlProperties *pThread
    )
{
    HRESULT hr;

    EnableWindow(GetDlgItem(pThread->m_hwnd, IDC_BTN_ATN_SEARCH), FALSE);

    hr = pThread->ATNSearch();

    LONG lCurXPrtState;
    hr = pThread->m_pDVcrExtTransport->get_Mode(&lCurXPrtState);

    if(SUCCEEDED(hr)) {
        pThread->UpdateTransportState(lCurXPrtState);   // Will also update timer.
    } else {
        DbgLog((LOG_ERROR, 0, TEXT("InitialCtrlCmdThreadProc: XPrt State %x, hr %x"), lCurXPrtState, hr));
    }

    EnableWindow(GetDlgItem(pThread->m_hwnd, IDC_BTN_ATN_SEARCH), TRUE);


    // Reset it since we are exiting
    pThread->m_hCtrlCmdThread = NULL;

    ::ExitThread(1);
    return 1;
    // Self terminating
}



HRESULT
CDVcrControlProperties::CreateCtrlCmdThread(void)
{
    HRESULT hr = NOERROR;

    if (m_hThreadEndEvent != NULL) {

        ASSERT(m_hCtrlCmdThread == NULL);
        DWORD ThreadId;
        m_hCtrlCmdThread = 
            ::CreateThread( 
                NULL
                , 0
                , (LPTHREAD_START_ROUTINE) (DoATNSearchThreadProc)
                , (LPVOID) (this)
                , 0
                , &ThreadId
                );

        if (m_hCtrlCmdThread == NULL) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DbgLog((LOG_ERROR, 0, TEXT("CDVcrControlProperties: CreateNotifyThread() failed hr %x"), hr));

        } else {
            DbgLog((LOG_TRACE, 2, TEXT("CDVcrControlProperties: CreateNotifyThread() ThreadEndEvent %ld, Thread %ld"),m_hThreadEndEvent, m_hThread));
        }

    } else {
        hr = E_FAIL;
        DbgLog((LOG_ERROR, 0, TEXT("CreateCtrlCmdThread, m_hCtrlCmdThread is NULL")));
    }

    return hr;
}



void
CDVcrControlProperties::ExitThread(
    )
{
    //
    // Check if a thread was created
    //
    if (m_hThread || m_hCtrlCmdThread) {
        ASSERT(m_hThreadEndEvent != NULL);

        // End the main thread and will cause the thread to exit        
        if (SetEvent(m_hThreadEndEvent)) {
            //
            // Synchronize with thread termination.
            //
            if(m_hCtrlCmdThread) {
                DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties:Wait for thread to terminate")));
                WaitForSingleObjectEx(m_hCtrlCmdThread, INFINITE, FALSE);  // Exit when thread terminate
                DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties: Thread terminated")));
                CloseHandle(m_hCtrlCmdThread),  m_hCtrlCmdThread = NULL;
            }

            if(m_hThread) {
                DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties:Wait for thread to terminate")));
                WaitForSingleObjectEx(m_hThread, INFINITE, FALSE);  // Exit when thread terminate
                DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties: Thread terminated")));
                CloseHandle(m_hThread),         m_hThread = NULL;
            }

            CloseHandle(m_hThreadEndEvent), m_hThreadEndEvent = NULL;

        } else {
            DbgLog((LOG_ERROR, 1, TEXT("SetEvent() failed hr %x"), GetLastError()));
        }
    }
}


//
// Constructor
//
// Create a Property page object 

CDVcrControlProperties::CDVcrControlProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("DVcrControl Property Page") 
                      , lpunk
                      , IDD_DVcrControlProperties 
                      , IDS_DVCRCONTROLPROPNAME
                      )
    , m_pDVcrExtDevice(NULL) 
    , m_pDVcrExtTransport(NULL) 
    , m_pDVcrTmCdReader(NULL) 
    , m_hThreadEndEvent(NULL)
    , m_hCtrlCmdThread(NULL)
    , m_hThread(NULL)
    , m_lCurXPrtState(ED_MODE_STOP)
    , m_bIConLoaded(FALSE)
    , m_bDevRemoved(FALSE)
    , m_bTimecodeUpdating(FALSE)
    , m_idTimer(0)
    , m_lAvgTimePerFrame(33)
    , m_lSignalMode(0)
    , m_lStorageMediumType(0)
{  
    DbgLog((LOG_TRACE, 1, TEXT("Constructing CDVcrControlProperties...")));
}

// destructor
CDVcrControlProperties::~CDVcrControlProperties()
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying CDVcrControlProperties...")));
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT 
CDVcrControlProperties::OnConnect(IUnknown *pUnknown)
{

    // Ask the filter for its control interface
    DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties::OnConnect.")));

    HRESULT 
    hr = pUnknown->QueryInterface(IID_IAMExtDevice,(void **)&m_pDVcrExtDevice);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("CDVcrControlProperties::OnConnect: IAMExtDevice failed with hr %x."), hr));
        return hr;
    }

    hr = pUnknown->QueryInterface(IID_IAMExtTransport,(void **)&m_pDVcrExtTransport);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("CDVcrControlProperties::OnConnect: IAMExtTransport failed with hr %x."), hr));
        m_pDVcrExtDevice->Release();
        m_pDVcrExtDevice = NULL;
        return hr;
    }

    hr = pUnknown->QueryInterface(IID_IAMTimecodeReader,(void **)&m_pDVcrTmCdReader);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("CDVcrControlProperties::OnConnect: IAMTimecodeReader failed with hr %x."), hr));
        m_pDVcrExtDevice->Release();
        m_pDVcrExtDevice = NULL;
        m_pDVcrExtTransport->Release();
        m_pDVcrExtTransport = NULL;
        return hr;
    }

    m_hThreadEndEvent = CreateEvent( NULL, TRUE, FALSE, NULL );


    LPOLESTR pName = NULL;
    char szBuf[MAX_PATH];

    //
    // For AVC device, it is the 64bit NodeUiqueID 
    //
    hr = m_pDVcrExtDevice->get_ExternalDeviceID(&pName);
    if(SUCCEEDED(hr)) {
        m_dwNodeUniqueID[0] = ((DWORD *)pName)[0];
        m_dwNodeUniqueID[1] = ((DWORD *)pName)[1];
        sprintf(szBuf, "%.8x:%.8x", m_dwNodeUniqueID[0], m_dwNodeUniqueID[1]);
        DbgLog((LOG_ERROR, 1, TEXT("DevID: %s"), szBuf));      
        QzTaskMemFree(pName), pName = NULL;
    } else {
        m_dwNodeUniqueID[0] = 0;
        m_dwNodeUniqueID[1] = 0;
    }


    // Get version; return AVC VCR subunit version, such as "2.0.1"
    hr = m_pDVcrExtDevice->get_ExternalDeviceVersion(&pName);
    if(SUCCEEDED(hr)) {
        WideCharToMultiByte(CP_ACP, 0, pName, -1, szBuf, MAX_PATH, 0, 0);
        DbgLog((LOG_ERROR, 1, TEXT("Version: %s"), szBuf));
        QzTaskMemFree(pName), pName = NULL;
    }


    //
    // Create a thread to track transport state change
    //
    hr = CreateNotifyThread();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("CDVcrControlProperties: CreateNotifyThread failed hr %x"), hr));    
    }     

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT 
CDVcrControlProperties::OnDisconnect()
{
    // Release the interface
    DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties::OnDisConnect.")));

    ExitThread();

    if (m_pDVcrExtDevice) {
        m_pDVcrExtDevice->Release();
        m_pDVcrExtDevice = NULL;
    }

    if (m_pDVcrExtTransport) {
        m_pDVcrExtTransport->Release();
        m_pDVcrExtTransport = NULL;
    }

    if (m_pDVcrTmCdReader) {
        m_pDVcrTmCdReader->Release();
        m_pDVcrTmCdReader = NULL;
    }

    return NOERROR;
}


//
// Load an icon to on top of the push button.
//
LRESULT 
CDVcrControlProperties::LoadIconOnTopOfButton(int IDD_PBUTTON, int IDD_ICON)
{
    HWND hWndPButton;
    HICON hIcon;

    hWndPButton = GetDlgItem (m_hwnd, IDD_PBUTTON);
    hIcon = (HICON) LoadImage(g_hInst, MAKEINTRESOURCE(IDD_ICON), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    //
    // Note:The system automatically deletes these resources when the process that created them terminates.
    // But if this property page is open/close many time, this will increase its working set size. 
    // To release resource, call DestroyIcon(hIcon)
    //
    return SendMessage(hWndPButton, BM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
}


//
// OnActivate
//
// Called on dialog creation

HRESULT 
CDVcrControlProperties::OnActivate(void)
{
    HRESULT hr;


    DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties::OnActivate.")));
       
#ifdef DEBUG
    // Show NodeUniqueID
    if(m_dwNodeUniqueID[0] && m_dwNodeUniqueID[1]) {
        TCHAR szBuf[32];
        _stprintf(szBuf, TEXT("ID: %.8x:%.8x"), m_dwNodeUniqueID[0], m_dwNodeUniqueID[1]);       
        SetDlgItemText(m_hwnd, IDC_EDT_AVC_RESP, (LPCTSTR)szBuf);        
    } 
#endif

    // Query and update tape information
    // This will tell us if there is a tape of not.
    // Tape/Media format (NTSC/PAL) and AvgTimePerFrame
    UpdateTapeInfo();


    // Device type is only valid if there is a tape;
    // That is why UpdateTapeInfo() is called prior to this.
    UpdateDevTypeInfo();


#ifndef DEBUG
    // Only Available for Debug build.    
    ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_AVC_SEND),FALSE);
    ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_AVC_SEND),FALSE);
    ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_AVC_RESP),FALSE);
#endif


    // Hide it and only show if verify that notify is on
    ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_NOTIFY_ON), FALSE);        

    
    // Set current transport state and tue control accordingly
    long lCurXPrtState;   
    hr = m_pDVcrExtTransport->get_Mode(&lCurXPrtState);
    DbgLog((LOG_ERROR, 0, TEXT("lCurXPrtState: %x, hr %x"), lCurXPrtState, hr));
    if(SUCCEEDED(hr))
        UpdateTransportState(lCurXPrtState); 


    // Get time code from current media position
    UpdateTimecode();    

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CDVcrControlProperties::OnDeactivate(void)
{
    m_bIConLoaded = FALSE;        // Not visible
    UpdateTimecodeTimer(FALSE);   // No need to update if not visible    
    DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties::OnDeactivate.")));
    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT 
CDVcrControlProperties::OnApplyChanges(void)
{
 
    DbgLog((LOG_TRACE, 1, TEXT("CDVcrControlProperties::OnApplyChanges.")));
    return NOERROR;
}



void
CDVcrControlProperties::UpdateTapeInfo(   
    )
{
    HRESULT hr;
    LONG lInSignalMode = 0;
    LONG lStorageMediumType = 0;
    BOOL bRecordInhibit = FALSE;
    TCHAR szBuf[256];

    // Input signal mode (NTSC/PAL, SD/SDL)
    // Set Medium info
    hr = m_pDVcrExtTransport->GetStatus(ED_MEDIA_TYPE, &lStorageMediumType);
 
    if(SUCCEEDED (hr)) {

        m_lStorageMediumType = lStorageMediumType;  // Cache it

        if(lStorageMediumType == ED_MEDIA_NOT_PRESENT) {
            LoadString(g_hInst, IDS_TAPE_FORMAT_NOT_INSERTED, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            SetDlgItemText(m_hwnd, IDC_TXT_TAPE_FORMAT, (LPCTSTR)szBuf);

            ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_TAPE_INSERTED),  TRUE);

            ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_WRITE_PROTECTED),FALSE);

        } else {
            // If it is present, it better be ED_MEDIA_DVC or _VHS
            ASSERT(lStorageMediumType == ED_MEDIA_DVC || lStorageMediumType == ED_MEDIA_VHS || lStorageMediumType == ED_MEDIA_NEO);

            ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_TAPE_INSERTED),FALSE);

            // There is a tape so get its tape format.
            if(S_OK == m_pDVcrExtTransport->GetTransportBasicParameters(ED_TRANSBASIC_INPUT_SIGNAL, &lInSignalMode, NULL)) {
                m_lSignalMode = lInSignalMode;  // Cache it
                switch(lInSignalMode) {
                case ED_TRANSBASIC_SIGNAL_525_60_SD:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_525_60_SD, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 33;  // 33 milli-sec (29.97 FPS)
                    break;
                case ED_TRANSBASIC_SIGNAL_525_60_SDL:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_525_60_SDL, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 33;  // 33 milli-sec (29.97 FPS)
                    break;
                case ED_TRANSBASIC_SIGNAL_625_50_SD:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_525_50_SD, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 40;  // 40 milli-sec (25FPS)
                    break;
                case ED_TRANSBASIC_SIGNAL_625_50_SDL:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_525_50_SDL, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 40;  // 40 milli-sec (25FPS)
                    break;
                case ED_TRANSBASIC_SIGNAL_MPEG2TS:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_MPEG2TS, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                case ED_TRANSBASIC_SIGNAL_2500_60_MPEG:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_2500_60_MPEG, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                case ED_TRANSBASIC_SIGNAL_1250_60_MPEG:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_1250_60_MPEG, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                case ED_TRANSBASIC_SIGNAL_0625_60_MPEG:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_0625_60_MPEG, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                case ED_TRANSBASIC_SIGNAL_2500_50_MPEG:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_2500_50_MPEG, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                case ED_TRANSBASIC_SIGNAL_1250_50_MPEG:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_1250_50_MPEG, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                case ED_TRANSBASIC_SIGNAL_0625_50_MPEG:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_0625_50_MPEG, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                case ED_TRANSBASIC_SIGNAL_UNKNOWN:
                    LoadString(g_hInst, IDS_TAPE_FORMAT_UNKNOWN, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                    m_lAvgTimePerFrame = 1;   // Not used for this format
                    break;
                default:
                    wsprintf(szBuf, TEXT("Format %x"), lInSignalMode);  // Unsupported but still want to know if it is used.
                    m_lAvgTimePerFrame = 33;  // 33 milli-sec (29.97 FPS); default
                    break;
                }            

                SetDlgItemText(m_hwnd, IDC_TXT_TAPE_FORMAT, (LPCTSTR)szBuf);
            }

            // Is it write protected ?
            ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_WRITE_PROTECTED),TRUE);
            m_pDVcrExtTransport->GetStatus(ED_RECORD_INHIBIT, (long *)&bRecordInhibit);
            if(bRecordInhibit)
                LoadString(g_hInst, IDS_TAPE_WRITE_PROTECTED, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            else
                LoadString(g_hInst, IDS_TAPE_WRITABLE, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            SetDlgItemText(m_hwnd, IDC_TXT_WRITE_PROTECTED, (LPCTSTR)szBuf);
        }
    } else {
        DbgLog((LOG_ERROR, 1, TEXT("Get ED_MEDIA_TYPE failed hr %x"), hr));
    }
}

void
CDVcrControlProperties::UpdateDevTypeInfo()
{
    HRESULT hr;
    LONG lPowerState = 0;
    LONG lDeviceType = 0;
    TCHAR szBuf[256];

    // Query power state
    hr = m_pDVcrExtDevice->get_DevicePower(&lPowerState);
    if(SUCCEEDED(hr)) {
        switch (lPowerState) {
        case ED_POWER_ON:
        default:          // Unknown power state
            ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_SET_POWER), FALSE);
            break;
        case ED_POWER_OFF:
        case ED_POWER_STANDBY:
            // Give user the option to turn it on.
            ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_SET_POWER), TRUE);
            break;
        }
    } else {
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_SET_POWER), FALSE);
    }

    // Note: Device type is only accurate if there is a tape in there.
    // It can return: 0 (Undetermined), ED_DEVTYPE_VCR or ED_DEVTYPE_CAMERA
    m_pDVcrExtDevice->GetCapability(ED_DEVCAP_DEVICE_TYPE, &lDeviceType, 0);
    DbgLog((LOG_TRACE, 1, TEXT("UpdateDevTypeInfo: DeviceType 0x%x"), lDeviceType)); 

    if(!m_bIConLoaded) {
        // Load resource used in the dialog box
        LoadIconOnTopOfButton(IDC_BTN_DV_PLAY,    IDI_PLAY);
        LoadIconOnTopOfButton(IDC_BTN_DV_PAUSE,   IDI_PAUSE);
        LoadIconOnTopOfButton(IDC_BTN_DV_STOP,    IDI_STOP_EJECT);
        LoadIconOnTopOfButton(IDC_BTN_DV_RWND,    IDI_RWND);
        LoadIconOnTopOfButton(IDC_BTN_DV_FFWD,    IDI_FFWD);
        LoadIconOnTopOfButton(IDC_BTN_DV_STEP_FWD,IDI_STEP_FWD);
        LoadIconOnTopOfButton(IDC_BTN_DV_STEP_REV,IDI_STEP_REV);
        LoadIconOnTopOfButton(IDC_BTN_DV_RECORD,  IDI_RECORD);
        LoadIconOnTopOfButton(IDC_BTN_DV_RECORD_PAUSE,IDI_RECORD_PAUSE);
        m_bIConLoaded = TRUE;
    }

    if(lDeviceType == 0) {
        // Pretend that we are VCR device with no tape!
        LoadString(g_hInst, IDS_DEVTYPE_VCR, szBuf, sizeof(szBuf)/sizeof(TCHAR));
        SetDlgItemText(m_hwnd, IDC_GBX_DEVICE_TYPE, szBuf);

        // Hide just about everything!
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),      FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_PLAY),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_PAUSE),  FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STOP),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RWND),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_FFWD),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RECORD), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RECORD_PAUSE), FALSE);

        
        ShowWindow(GetDlgItem(m_hwnd, IDC_GBX_TIMECODE), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_HH_COLON), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_MM_COLON), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_SS_COMMA), FALSE);

        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_HH), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_MM), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_SS), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_FF), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_ATN_BF), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_ATN),    FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_ATN_SEARCH), FALSE);


    } else if(lDeviceType == ED_DEVTYPE_VCR) {

        if(m_lStorageMediumType == ED_MEDIA_NEO) 
            LoadString(g_hInst, IDS_DEVTYPE_NEO, szBuf, sizeof(szBuf)/sizeof(TCHAR));
        else if(m_lStorageMediumType == ED_MEDIA_VHS) 
            LoadString(g_hInst, IDS_DEVTYPE_DVHS, szBuf, sizeof(szBuf)/sizeof(TCHAR));
        else 
            LoadString(g_hInst, IDS_DEVTYPE_VCR, szBuf, sizeof(szBuf)/sizeof(TCHAR));
        SetDlgItemText(m_hwnd, IDC_GBX_DEVICE_TYPE, szBuf);

        // Show everything!
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),      TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_PLAY),   TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_PAUSE),  TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STOP),   TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RWND),   TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_FFWD),   TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RECORD), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RECORD_PAUSE), TRUE);


        ShowWindow(GetDlgItem(m_hwnd, IDC_GBX_TIMECODE), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_HH_COLON), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_MM_COLON), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_SS_COMMA), TRUE);

        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_HH), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_MM), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_SS), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_FF), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_ATN_BF), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_ATN),    TRUE);
        switch(m_lSignalMode) {

        // DV should support ATN
        case ED_TRANSBASIC_SIGNAL_525_60_SD:
        case ED_TRANSBASIC_SIGNAL_525_60_SDL:
        case ED_TRANSBASIC_SIGNAL_625_50_SD:
        case ED_TRANSBASIC_SIGNAL_625_50_SDL:
        case ED_TRANSBASIC_SIGNAL_625_60_HD:
        case ED_TRANSBASIC_SIGNAL_625_50_HD:

        // MPEG2TS camcorder should support ATN
        case ED_TRANSBASIC_SIGNAL_2500_60_MPEG:
        case ED_TRANSBASIC_SIGNAL_1250_60_MPEG:
        case ED_TRANSBASIC_SIGNAL_0625_60_MPEG:
        case ED_TRANSBASIC_SIGNAL_2500_50_MPEG:
        case ED_TRANSBASIC_SIGNAL_1250_50_MPEG:
        case ED_TRANSBASIC_SIGNAL_0625_50_MPEG:

            ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_ATN_SEARCH), TRUE);
            break;

        // D-VHS does not support ATN
        case ED_TRANSBASIC_SIGNAL_MPEG2TS:
        default:
            ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_ATN_SEARCH), FALSE);  // No search for MPEG2TS format
        }

    } else {
        LoadString(g_hInst, IDS_DEVTYPE_CAMERA, szBuf, sizeof (szBuf)/sizeof(TCHAR));
        SetDlgItemText(m_hwnd, IDC_GBX_DEVICE_TYPE, szBuf);

        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),      FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_PLAY),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_PAUSE),  FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STOP),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RWND),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_FFWD),   FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),        FALSE);
        // Camera: can only RECORD and RECORD_PAUSE
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RECORD),       TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_RECORD_PAUSE), TRUE);


        ShowWindow(GetDlgItem(m_hwnd, IDC_GBX_TIMECODE), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_HH_COLON), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_MM_COLON), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_TXT_SS_COMMA), FALSE);

        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_HH), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_MM), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_SS), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_TC_FF), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_ATN_BF), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_EDT_ATN),    FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_ATN_SEARCH), FALSE);
    } 
}


void
CDVcrControlProperties::UpdateTimecodeTimer(
    bool bSetTimer
    )
{
    UINT uiAvgTimePerFrame;

    //
    // Since it can take up to 100msec (MSDV actually waits up to 200msec) 
    // to return from an AVC command, we should NOT send more than 5 (1000msec/200msec) AVC cmd to it.
    //
    uiAvgTimePerFrame = 500;  // 2 updates per second (TimeCode + ATN) = 4 updates


    if(bSetTimer && m_idTimer == 0) {
        m_idTimer = SetTimer(
            m_hwnd,             // handle to window for timer messages
            1,                  // timer identifier           
            uiAvgTimePerFrame, // time-out value : Need neeed be fast since it is just for UI
            0                   // pointer to timer procedure; 0 to use WM_TIMER
        );
        if(!m_idTimer) {
            DbgLog((LOG_ERROR, 1, TEXT("UpdateTimecodeTimer: SetTimer() error %x, AvgTimePerFrame %d"), GetLastError(), m_lAvgTimePerFrame));    
        } else {
            DbgLog((LOG_TRACE, 1, TEXT("UpdateTimecodeTimer: SetTimer(), TimerId %d, AvgTimePerFrame %d"), m_idTimer, m_lAvgTimePerFrame));    
        }
    }

    if(!bSetTimer && m_idTimer != 0) {
        if(!KillTimer(
            m_hwnd,      // handle to window that installed timer
            1 // uIDEvent   // timer identifier
            )) {
            DbgLog((LOG_ERROR, 1, TEXT("UpdateTimecodeTimer: KillTimer() error %x"), GetLastError()));    
        } else {
            DbgLog((LOG_TRACE, 1, TEXT("UpdateTimecodeTimer: KillTimer() suceeded")));    
        }

        m_idTimer = 0;
    }
}


void
CDVcrControlProperties::UpdateTransportState(
    long lNewXPrtState
    )
{

    bool bSetTimer = FALSE;


    switch(lNewXPrtState) {
    case ED_MODE_PLAY:   
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),        TRUE);
        bSetTimer = TRUE;
        break;

    case ED_MODE_STEP_FWD:
    case IDC_BTN_DV_STEP_REV:
        bSetTimer = FALSE;  // STEP need not constant updated
        break;

    case ED_MODE_FREEZE:
        // NOTE: Some DV cannot go from STOP->PLAY_PAUSE
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), TRUE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), TRUE);    
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),        TRUE);
        bSetTimer = FALSE;  // Freeze will have the same timecode
        break;
    case ED_MODE_PLAY_SLOWEST_FWD:
    case ED_MODE_PLAY_FASTEST_FWD:
    case ED_MODE_PLAY_SLOWEST_REV:
    case ED_MODE_PLAY_FASTEST_REV:
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), FALSE); 
        bSetTimer = TRUE;
        break;
    case ED_MODE_STOP:
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), FALSE);        
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),        FALSE);
        bSetTimer = FALSE;
        break;
    case ED_MODE_FF:
    case ED_MODE_REW:
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),        FALSE);
        bSetTimer = TRUE;  // timecode ??
        break;
    case ED_MODE_RECORD:
    case ED_MODE_RECORD_FREEZE:
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_REV), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_DV_STEP_FWD), FALSE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_CHK_SLOW),        FALSE);
        bSetTimer = FALSE;
        break;
    default:
        DbgLog((LOG_TRACE, 1, TEXT("Unknown ED_MODE: %x, bSetTimer %x, m_idTimer %x"), 
            lNewXPrtState, bSetTimer, m_idTimer));
        return;
        break;
    }

    DbgLog((LOG_TRACE, 1, TEXT("ED_MODE: %x, bSetTimer %x, m_idTimer %x"), 
        lNewXPrtState, bSetTimer, m_idTimer)); 
   
    // Set up timer to update timercode/ATN    
    UpdateTimecodeTimer(bSetTimer);

    // Can search if Xprt is in PAUSE mode and Timer is not set!
    EnableWindow(GetDlgItem(m_hwnd, IDC_BTN_ATN_SEARCH), !bSetTimer);

    m_lCurXPrtState = lNewXPrtState;
}


//
// Convert hour:minute:second:frame in binary coded decimal (BCD) 
// into a string and display it.
//

HRESULT 
CDVcrControlProperties::DisplayTimecode(PTIMECODE_SAMPLE pTimecodeSamp)
{
    TCHAR szBuf[32];

    if(pTimecodeSamp->dwFlags == ED_DEVCAP_TIMECODE_READ) {

        wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0xff000000) >> 24);
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_HH), szBuf))
            goto AbortDisplay;

        wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0x00ff0000) >> 16);
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_MM), szBuf))
            goto AbortDisplay;

        wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0x0000ff00) >> 8);
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_SS), szBuf))
            goto AbortDisplay;

        wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0x000000ff));
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_FF), szBuf))
            goto AbortDisplay;

    } if(pTimecodeSamp->dwFlags == ED_DEVCAP_RTC_READ) {

        if(pTimecodeSamp->timecode.dwFrames & 0x00000080) // Test the sign bit
            wsprintf(szBuf, TEXT("-%.2x"), (pTimecodeSamp->timecode.dwFrames & 0xff000000) >> 24);
        else
            wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0xff000000) >> 24);
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_HH), szBuf))
            goto AbortDisplay;

        wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0x00ff0000) >> 16);
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_MM), szBuf))
            goto AbortDisplay;

        wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0x0000ff00) >> 8);
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_SS), szBuf))
            goto AbortDisplay;

        // Special case
        if((pTimecodeSamp->timecode.dwFrames & 0x0000007f) == 0x7f)
            wsprintf(szBuf, TEXT("--"));  // To indicate no data!
        else
            wsprintf(szBuf, TEXT("%.2x"), (pTimecodeSamp->timecode.dwFrames & 0x0000007f));
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_TC_FF), szBuf))
            goto AbortDisplay;

    } else {            
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_ATN_BF), pTimecodeSamp->dwUser ? TEXT("1"):TEXT("0")))
            goto AbortDisplay;

        wsprintf(szBuf, TEXT("%d"), pTimecodeSamp->timecode.dwFrames );            
        if(!SetWindowText(GetDlgItem (m_hwnd, IDC_EDT_ATN), szBuf))
            goto AbortDisplay;
    }

    return NOERROR;

AbortDisplay:

    return GetLastError();
}

//
// Convert string (lower case only) string to number
//
HRESULT
CDVcrControlProperties::DVcrConvertString2Number(
    char *pszAvcRaw, PBYTE pbAvcRaw, PLONG pByteRtn)
{
    char szTemp[1024], *pszTemp, ch1, ch2;
    long cntStrLen = strlen(pszAvcRaw), i, j;

    // remove blank space
    pszTemp = pszAvcRaw;
    for (i=j=0; i < cntStrLen+1; i++) {
       if(*pszTemp != ' ') {
          szTemp[j] = *pszTemp;
          j++;
       }
       pszTemp++;
    }
    
    cntStrLen = j--;  // less eol char.

    // xlate two characters to one byte
    *pByteRtn = cntStrLen/2;
    // Only use lower case
    for (i=0; i < *pByteRtn; i++) {
        // Take two bytes and translte it to a number
        ch1 = szTemp[i*2]   > '9' ? szTemp[i*2] -   'a' + 10: szTemp[i*2] -   '0';
        ch2 = szTemp[i*2+1] > '9' ? szTemp[i*2+1] - 'a' + 10: szTemp[i*2+1] - '0';        
        *(pbAvcRaw+i) = ch1 * 16 + ch2;
        DbgLog((LOG_TRACE, 2, TEXT("%d) %.2x"), i, *(pbAvcRaw+i)));
    }

    return S_OK;
}


HRESULT
CDVcrControlProperties::DVcrConvertNumber2String(
    char *pszAvcRaw, PBYTE pbAvcRaw, LONG cntByte)
{
    long i;
    BYTE n;

    // Only accept lower case
    for (i=0; i < cntByte; i++) {
         n = *(pbAvcRaw+i);
         *(pszAvcRaw+i*3)   = n / 16 > 9 ? n / 16 + 'a'-10 : n / 16 + '0';
         *(pszAvcRaw+i*3+1) = n % 16 > 9 ? n % 16 + 'a'-10 : n % 16 + '0';
         *(pszAvcRaw+i*3+2) = ' ';
    }

    *(pszAvcRaw+i*3) = 0;

    return S_OK;
}

void
CDVcrControlProperties::UpdateTimecode(
    )
{
    HRESULT hr;
    TIMECODE_SAMPLE TimecodeSample;

    if(!m_pDVcrTmCdReader) 
        return;   

    m_bTimecodeUpdating = TRUE;

    TimecodeSample.timecode.dwFrames = 0;
    switch(m_lSignalMode) {
    case ED_TRANSBASIC_SIGNAL_525_60_SD:
    case ED_TRANSBASIC_SIGNAL_525_60_SDL:
    case ED_TRANSBASIC_SIGNAL_625_50_SD:
    case ED_TRANSBASIC_SIGNAL_625_50_SDL:
    case ED_TRANSBASIC_SIGNAL_625_60_HD:
    case ED_TRANSBASIC_SIGNAL_625_50_HD:
        TimecodeSample.dwFlags = ED_DEVCAP_TIMECODE_READ;
        break;
    case ED_TRANSBASIC_SIGNAL_MPEG2TS:
    case ED_TRANSBASIC_SIGNAL_2500_60_MPEG:
    case ED_TRANSBASIC_SIGNAL_1250_60_MPEG:
    case ED_TRANSBASIC_SIGNAL_0625_60_MPEG:
    case ED_TRANSBASIC_SIGNAL_2500_50_MPEG:
    case ED_TRANSBASIC_SIGNAL_1250_50_MPEG:
    case ED_TRANSBASIC_SIGNAL_0625_50_MPEG:
        TimecodeSample.dwFlags = ED_DEVCAP_RTC_READ;
        break;
    case ED_TRANSBASIC_SIGNAL_UNKNOWN:
    default:
        return;
    }

    //
    // Update as fast as it can so we don't care if this call failed!
    //
    hr = m_pDVcrTmCdReader->GetTimecode(&TimecodeSample);
    if(S_OK == hr) {
        DisplayTimecode(&TimecodeSample);                   

        // DV supports ATN.
        switch(m_lSignalMode) {
        case ED_TRANSBASIC_SIGNAL_525_60_SD:
        case ED_TRANSBASIC_SIGNAL_525_60_SDL:
        case ED_TRANSBASIC_SIGNAL_625_50_SD:
        case ED_TRANSBASIC_SIGNAL_625_50_SDL:
        case ED_TRANSBASIC_SIGNAL_625_60_HD:
        case ED_TRANSBASIC_SIGNAL_625_50_HD:

        // MPEG2 camcorder supports ATN
        case ED_TRANSBASIC_SIGNAL_2500_60_MPEG:
        case ED_TRANSBASIC_SIGNAL_1250_60_MPEG:
        case ED_TRANSBASIC_SIGNAL_0625_60_MPEG:
        case ED_TRANSBASIC_SIGNAL_2500_50_MPEG:
        case ED_TRANSBASIC_SIGNAL_1250_50_MPEG:
        case ED_TRANSBASIC_SIGNAL_0625_50_MPEG:

            TimecodeSample.dwFlags = ED_DEVCAP_ATN_READ;
            hr = m_pDVcrTmCdReader->GetTimecode(&TimecodeSample);
            if(S_OK == hr)
                 DisplayTimecode(&TimecodeSample);                
            break;

        // D-VHS does not support ATN
        case ED_TRANSBASIC_SIGNAL_MPEG2TS:
        default:
            break;
        }
    }    

    m_bTimecodeUpdating = FALSE;
}



//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR
CDVcrControlProperties::OnReceiveMessage( 
    HWND hwnd
    , UINT uMsg
    , WPARAM wParam
    , LPARAM lParam) 
{
    LRESULT hr = NOERROR;
    int iNotify = HIWORD (wParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        return (INT_PTR)TRUE;    

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDC_BTN_SET_POWER:
            if(m_pDVcrExtDevice) {
                hr = m_pDVcrExtDevice->put_DevicePower(ED_POWER_ON);
                if(SUCCEEDED(hr)) {
                    ShowWindow(GetDlgItem(m_hwnd, IDC_BTN_SET_POWER), FALSE);
                }
            }
            break;
        case IDC_BTN_DV_PLAY:
            if(m_pDVcrExtTransport) {
                hr = m_pDVcrExtTransport->put_Mode(ED_MODE_PLAY);
                if(NOERROR == hr)
                    UpdateTransportState(ED_MODE_PLAY);
            }
            break;

        case IDC_BTN_DV_PAUSE:
            if(m_pDVcrExtTransport) {
                hr = m_pDVcrExtTransport->put_Mode(ED_MODE_FREEZE);
                if(NOERROR == hr) {
                    UpdateTransportState(ED_MODE_FREEZE);
                    UpdateTimecode();  // No timer to update; so get it once
                }
            }
            break;

        case IDC_BTN_DV_STEP_FWD:
            if(m_pDVcrExtTransport) {
                hr = m_pDVcrExtTransport->put_Mode(ED_MODE_STEP_FWD);
                if(NOERROR == hr) {
                    UpdateTransportState(ED_MODE_STEP_FWD);  
                    UpdateTimecode();  // No timer to update; so get it once
                }
            }
            break;

        case IDC_BTN_DV_STEP_REV:
            if(m_pDVcrExtTransport) {
                hr = m_pDVcrExtTransport->put_Mode(ED_MODE_STEP_REV);
                if(NOERROR == hr) {
                    UpdateTransportState(ED_MODE_STEP_REV);      
                    UpdateTimecode();  // No timer to update; so get it once
                }
            }
            break;

        case IDC_BTN_DV_STOP:
            if(m_pDVcrExtTransport) {
                hr = m_pDVcrExtTransport->put_Mode(ED_MODE_STOP);
                if(NOERROR == hr) 
                    UpdateTransportState(ED_MODE_STOP);
            }
            break;  

        case IDC_BTN_DV_FFWD:
            if(m_pDVcrExtTransport) {
                LONG lCurXPrtState;
                // Get current transport state since it could be changed locally by a user.
                if(NOERROR != (hr = m_pDVcrExtTransport->get_Mode(&lCurXPrtState)))
                    break;
                else
                    m_lCurXPrtState = lCurXPrtState;
                if(m_lCurXPrtState == ED_MODE_STOP) {
                    hr = m_pDVcrExtTransport->put_Mode(ED_MODE_FF);
                    if(NOERROR == hr)
                        UpdateTransportState(ED_MODE_FF);
                } else {
                    LRESULT hrChecked;
                    long lMode;
                    hrChecked = SendMessage (GetDlgItem(m_hwnd, IDC_CHK_SLOW),BM_GETCHECK, 0, 0);
                    lMode = hrChecked == BST_CHECKED ? ED_MODE_PLAY_SLOWEST_FWD : ED_MODE_PLAY_FASTEST_FWD;
                    hr = m_pDVcrExtTransport->put_Mode(lMode);
                    if(NOERROR == hr)
                        UpdateTransportState(lMode);
                }            
            }
            break;

        case IDC_BTN_DV_RWND:
            if(m_pDVcrExtTransport) { 
                LONG lCurXPrtState;
                // Get current transport state since it could be changed locally by a user.
                if(NOERROR != (hr = m_pDVcrExtTransport->get_Mode(&lCurXPrtState)))
                    break;  
                else
                    m_lCurXPrtState = lCurXPrtState;                
                if(m_lCurXPrtState == ED_MODE_STOP) {
                    hr = m_pDVcrExtTransport->put_Mode(ED_MODE_REW);
                    if(NOERROR == hr)
                        UpdateTransportState(ED_MODE_REW);
                } else {
                    LRESULT hrChecked;
                    long lMode;

                    hrChecked = SendMessage (GetDlgItem(m_hwnd, IDC_CHK_SLOW),BM_GETCHECK, 0, 0);
                    lMode = hrChecked == BST_CHECKED ? ED_MODE_PLAY_SLOWEST_REV : ED_MODE_PLAY_FASTEST_REV;
                    hr = m_pDVcrExtTransport->put_Mode(lMode);
                    if(NOERROR == hr)
                        UpdateTransportState(lMode);
                }
            }
            break;         

        case IDC_BTN_DV_RECORD:
            if(m_pDVcrExtTransport) {             
                hr = m_pDVcrExtTransport->put_Mode(ED_MODE_RECORD);
                if(NOERROR == hr)
                    UpdateTransportState(ED_MODE_RECORD);
            }
            break; 

        case IDC_BTN_DV_RECORD_PAUSE:
            if(m_pDVcrExtTransport) {
                hr = m_pDVcrExtTransport->put_Mode(ED_MODE_RECORD_FREEZE);
                if(NOERROR == hr) 
                    UpdateTransportState(ED_MODE_RECORD_FREEZE);
            }
            break; 

        case IDC_BTN_TAPE_INSERTED:         
            // User press this to inform us that a tape has been inserted so update tape info.
            Sleep(3000);  // Give DV tape some time to settle.
            UpdateTapeInfo();
            UpdateDevTypeInfo();
            UpdateTimecode();
            return (INT_PTR)TRUE;
            break;

        case IDC_BTN_ATN_SEARCH:
             // Launch a thread to do ATNSearch()
             if(SUCCEEDED(CreateCtrlCmdThread())) {
             }
             return (INT_PTR)TRUE;

        case IDC_BTN_AVC_SEND: 
        {
            char szAvcRaw[512*2];  // need two character to represent one byte of number 
            BYTE bAvcRaw[512];
            LONG cntByte;

            GetWindowTextA(GetDlgItem(m_hwnd, IDC_EDT_AVC_SEND), szAvcRaw, 512);
            DbgLog((LOG_TRACE, 1, TEXT("%d bytes, %s"), strlen(szAvcRaw), szAvcRaw));
            DVcrConvertString2Number(szAvcRaw, bAvcRaw, &cntByte);          

            if(cntByte >= 3) {

                if(m_pDVcrExtTransport) {
                    hr = m_pDVcrExtTransport->GetTransportBasicParameters(ED_RAW_EXT_DEV_CMD, &cntByte, (LPOLESTR *)bAvcRaw);

                    // Always return the response frame 
                    if(cntByte >= 3) 
                        DVcrConvertNumber2String(szAvcRaw, bAvcRaw, cntByte);
#if 0
                    if(!SUCCEEDED (hr)) {
                        switch(HRESULT_CODE(hr)) {
                        case ERROR_CRC:               // STATUS_DEVICE_DATA_ERROR (Data did not get to device)
                            // Most likely, device was not ready to accept another command, wait and try again.
                            strcpy(szAvcRaw, "Device data error: busy!");
                            break;
                        case ERROR_SEM_TIMEOUT:       // STATUS_IO_TIMEOUT (Operation not supported or device removed ?)
                            strcpy(szAvcRaw, "Operation timed out!");
                            break;
                        case ERROR_INVALID_PARAMETER: // STATUS_INVALID_PARAMETER 
                            strcpy(szAvcRaw, "Invalid parameter!");
                            break;                        
                        }
                    }
#else
                    switch(hr) {
                    case NOERROR:
                    case ERROR_REQ_NOT_ACCEP:
                    case ERROR_NOT_SUPPORTED:
                        break;
                    case ERROR_TIMEOUT:
                        strcpy(szAvcRaw, "Command timedout!");
                        break;
                    case ERROR_REQUEST_ABORTED:
                        strcpy(szAvcRaw, "Command aborted!");
                        break;
                    case ERROR_INVALID_PARAMETER: // STATUS_INVALID_PARAMETER 
                        strcpy(szAvcRaw, "Invalid parameter!");
                        break; 
                    default:
                        DbgLog((LOG_ERROR, 0, TEXT("Unexpected hr:%x"), hr));
                        ASSERT(FALSE && "Unexpected hr");
                        if(!SUCCEEDED (hr)) {
                            strcpy(szAvcRaw, "Unexpected return code!");
                        }
                        break; 
                    }

#endif
                } else {
                    strcpy(szAvcRaw, "Transport interface not supported!");                 
                }

            } else 
                strcpy(szAvcRaw, "Entry (< 3) error!");

            SetWindowTextA(GetDlgItem(m_hwnd, IDC_EDT_AVC_RESP), szAvcRaw);
        }


        default:
            return (INT_PTR)FALSE;
            break;
        }

        break;


    case WM_TIMER:
        // Make sure to STOP timer update if application stop streaming
        // or the graph can never go into STOP state.
        if(!m_bTimecodeUpdating)
            UpdateTimecode();
        break;

    default:
        return (INT_PTR)FALSE;

    }


    if(NOERROR != hr) {      
        // Possibly the tape has been removed ?
        UpdateTapeInfo();        
    }

    return (INT_PTR)TRUE;
}


//
// SetDirty
//
// notifies the property page site of changes

void 
CDVcrControlProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\drop.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    drop.h

Abstract:

    Internal header.

--*/

class CDroppedFramesInterfaceHandler :
    public CUnknown,
    public IAMDroppedFrames {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CDroppedFramesInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    virtual ~CDroppedFramesInterfaceHandler(
             );

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    // Implement IAMDroppedFrames

    STDMETHODIMP  GetNumDropped( 
            /* [out] */ long *plDropped);
        
    STDMETHODIMP  GetNumNotDropped( 
            /* [out] */ long *plNotDropped);
        
    STDMETHODIMP  GetDroppedInfo( 
            /* [in] */  long lSize,
            /* [out] */ long *plArray,
            /* [out] */ long *plNumCopied);
        
    STDMETHODIMP  GetAverageFrameSize( 
            /* [out] */ long *plAverageSize);

    
private:
    IKsPropertySet * m_KsPropertySet;

    KSPROPERTY_DROPPEDFRAMES_CURRENT_S m_DroppedFramesCurrent;

    STDMETHODIMP GenericGetDroppedFrames (
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\dvcrpage.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  DVcrPage.h  DVcrControl property page

#ifndef _INC_DVCRCONTROL_H
#define _INC_DVCRCONTROL_H

// -------------------------------------------------------------------------
// CDVcrControlProperties class
// -------------------------------------------------------------------------

// Handles the property page

class CDVcrControlProperties : public CBasePropertyPage {

public:

    static CUnknown * CALLBACK CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    CDVcrControlProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CDVcrControlProperties();

    void    SetDirty();

    //
    // Utility functions.
    //  

    LRESULT LoadIconOnTopOfButton(int IDD_PBUTTON, int IDD_ICON);
    HRESULT DisplayTimecode(PTIMECODE_SAMPLE pTimecodeSample);

    HRESULT DVcrConvertString2Number(char *pszAvcRaw, PBYTE pbAvcRaw, PLONG pByteRtn);
    HRESULT DVcrConvertNumber2String(char *pszAvcRaw, PBYTE pbAvcRaw, LONG cntByte);

    void UpdateTimecodeTimer(bool bSetTimer);
    void UpdateTransportState(long lNewXPrtState);
    void UpdateTapeInfo(void);
    void UpdateDevTypeInfo();
    void UpdateTimecode(void);
    HRESULT ATNSearch(void);



    //
    // Thread used to issue and process asychronous operation
    //
    HRESULT CreateNotifyThread(void);
    static DWORD WINAPI InitialThreadProc(CDVcrControlProperties *pThread);
    DWORD MainThreadProc(void);
    void ExitThread(void);


    //
    // Thread used to issue and process control command operation, which can also be asychronous
    //
    HRESULT CreateCtrlCmdThread(void);
    static DWORD WINAPI DoATNSearchThreadProc(CDVcrControlProperties *pThread);


    //
    // The control interfaces
    //
    IAMExtDevice         *m_pDVcrExtDevice;
    IAMExtTransport      *m_pDVcrExtTransport;
    IAMTimecodeReader    *m_pDVcrTmCdReader;

    //
    // Use to wait for pending operation so the operation can complete synchronously    
    //

    HANDLE m_hThreadEndEvent;
    HANDLE m_hThread;
    HANDLE m_hCtrlCmdThread;


    // Tranport state can be change from PC or locally;
    // it is safer not to cache this and assume it is be accurate.    
    long m_lCurXPrtState;   // Current transport state

    BOOL m_bIConLoaded;

    // Flag to indicate if the device is removed
    BOOL m_bDevRemoved;

    // Since timecode is driven by a timer (EM_TIMER) and 
    // The update time is entrant.  
    // If this update timecode for UI purpose, the 2nd one will be ignored.
    BOOL m_bTimecodeUpdating;

    //
    // Use a timer to update timecode; 
    //
    LONG m_lAvgTimePerFrame;
    UINT_PTR m_idTimer;

    LONG m_lSignalMode;  // SDDV(NTSC.PAL) and MPEG2TS

    LONG m_lStorageMediumType;   // VCR, VHS, NEO
    //
    // ConfigROM Node Unique ID
    //
    DWORD m_dwNodeUniqueID[2];
};

#endif  // _INC_DVCRCONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\compress.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    compress.cpp

Abstract:

    Implements - 
        IAMVideoCompression via PROPSETID_VIDCAP_VIDEOCOMPRESSION
        IAMVideoControl via PROPSETID_VIDCAP_VIDEOCONTROL

--*/

#include "pch.h"
#include "wdmcap.h"
#include "compress.h"



CUnknown*
CALLBACK
CVideoCompressionInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of an
    IAMVideoCompression interface on a pin.
    It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CVideoCompressionInterfaceHandler(UnkOuter, NAME("IAMVideoCompression"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVideoCompressionInterfaceHandler::CVideoCompressionInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) 
    : CUnknown(Name, UnkOuter, hr)
    , m_pPin (NULL)
    , m_KsPropertySet (NULL)
    , m_PinFactoryID (0)

/*++

Routine Description:

    The constructor for the IAMVideoCompression interface object. Get
    IKsPropertySet interface on the parent.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            PIN_INFO PinInfo;

            *hr = UnkOuter->QueryInterface(IID_IPin,(void **)&m_pPin);
            if (FAILED(*hr)) {
                return;
            }
            
            if (SUCCEEDED (*hr = m_pPin->QueryPinInfo(&PinInfo))) {
                *hr =  PinInfo.pFilter->QueryInterface(__uuidof(IKsPropertySet), 
                            reinterpret_cast<PVOID*>(&m_KsPropertySet));
    
                // We immediately release this to prevent deadlock in the proxy
                // GShaw sez:  As long as the pin is alive, the interface will be valid

                if (SUCCEEDED(*hr)) {
                    m_KsPropertySet->Release();
                }

                PinInfo.pFilter->Release();
            }

            
            *hr = PinFactoryIDFromPin(
                    m_pPin,
                    &m_PinFactoryID);

            m_pPin->Release();

        } else {
            *hr = VFW_E_NEED_OWNER;
        }
    }
}


CVideoCompressionInterfaceHandler::~CVideoCompressionInterfaceHandler(
    )
/*++

Routine Description:

    The destructorthe IAMVideoCompression interface object.

--*/
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying CVideoCompressionInterfaceHandler...")));
}


STDMETHODIMP
CVideoCompressionInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMVideoCompression.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IAMVideoCompression)) {
        return GetInterface(static_cast<IAMVideoCompression*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CVideoCompressionInterfaceHandler::Set1( 
            /* [in] */ ULONG Property,
            /* [in] */ long Value)
{
    KSPROPERTY_VIDEOCOMPRESSION_S  VideoCompression;
    HRESULT     hr;

    if (!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;
    } 
    else {
        VideoCompression.StreamIndex = m_PinFactoryID;
        VideoCompression.Value = Value;

        hr = m_KsPropertySet->Set (
                PROPSETID_VIDCAP_VIDEOCOMPRESSION,
                Property,
                &VideoCompression.StreamIndex,
                sizeof(VideoCompression) - sizeof (KSPROPERTY),
                &VideoCompression,
                sizeof(VideoCompression));
    }
    return hr;
}
        

STDMETHODIMP
CVideoCompressionInterfaceHandler::Get1( 
            /* [in]  */ ULONG Property,
            /* [out] */ long *pValue)
{
    KSPROPERTY_VIDEOCOMPRESSION_S  VideoCompression;
    ULONG       BytesReturned;
    HRESULT     hr;

    if (!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;
    } 
    else {
        VideoCompression.StreamIndex = m_PinFactoryID;

        hr = m_KsPropertySet->Get (
                PROPSETID_VIDCAP_VIDEOCOMPRESSION,
                Property,
                &VideoCompression.StreamIndex,
                sizeof(VideoCompression) - sizeof (KSPROPERTY),
                &VideoCompression,
                sizeof(VideoCompression),
                &BytesReturned);
    }

    if (SUCCEEDED (hr)) {
        *pValue = VideoCompression.Value;
    }

    return hr;
}
        

STDMETHODIMP
CVideoCompressionInterfaceHandler::put_KeyFrameRate( 
            /* [in] */ long KeyFrameRate)
{
    return Set1 (KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,
                 KeyFrameRate);
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::get_KeyFrameRate( 
            /* [out] */ long *pKeyFrameRate)
{
    ValidateWritePtr (pKeyFrameRate, sizeof (long));

    return Get1 (KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,
                 pKeyFrameRate);
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::put_PFramesPerKeyFrame( 
            /* [in] */ long PFramesPerKeyFrame)
{
    return Set1 (KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME,
                 PFramesPerKeyFrame);
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::get_PFramesPerKeyFrame( 
            /* [out] */ long *pFramesPerKeyFrame)
{
    ValidateWritePtr (pFramesPerKeyFrame, sizeof (long));

    return Get1 (KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME,
                 pFramesPerKeyFrame);
}
        
// Kernel drivers use quality settings of 
// 0 to 10000
//
// DShow uses 0.0 to 1.0
//
STDMETHODIMP 
CVideoCompressionInterfaceHandler::put_Quality( 
            /* [in] */ double Quality)
{
    long Quality10000 = (ULONG) (Quality * 10000);

    if (Quality < 0.0 || Quality > 10000.0)
        return E_INVALIDARG;

    return Set1 (KSPROPERTY_VIDEOCOMPRESSION_QUALITY,
                 Quality10000);
}
    

// Kernel drivers use quality settings of 
// 0 to 10000
//
// DShow uses 0.0 to 1.0
//    
STDMETHODIMP 
CVideoCompressionInterfaceHandler::get_Quality( 
            /* [out] */ double *pQuality)
{
    HRESULT hr;
    long Quality10000;

    ValidateWritePtr (pQuality, sizeof (double));

    hr = Get1 (KSPROPERTY_VIDEOCOMPRESSION_QUALITY,
                 &Quality10000);

    if (SUCCEEDED (hr)) {
        *pQuality = (double) Quality10000 / 10000.0;
    }

    return hr;
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::put_WindowSize( 
            /* [in] */ DWORDLONG WindowSize)
{
   return E_PROP_ID_UNSUPPORTED;
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::get_WindowSize( 
            /* [out] */ DWORDLONG *pWindowSize)
{
   return E_PROP_ID_UNSUPPORTED;
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::GetInfo( 
            /* [size_is][out] */ WCHAR *pszVersion,
            /* [out][in] */ int *pcbVersion,
            /* [size_is][out] */ LPWSTR pszDescription,
            /* [out][in] */ int *pcbDescription,
            /* [out] */ long *pDefaultKeyFrameRate,
            /* [out] */ long *pDefaultPFramesPerKey,
            /* [out] */ double *pDefaultQuality,
            /* [out] */ long *pCapabilities)
{
    KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S  VideoCompressionCaps;
    ULONG       BytesReturned;
    HRESULT     hr;


    if (!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;
    } 
    else {
        VideoCompressionCaps.StreamIndex = m_PinFactoryID;

        hr = m_KsPropertySet->Get (
                    PROPSETID_VIDCAP_VIDEOCOMPRESSION,
                    KSPROPERTY_VIDEOCOMPRESSION_GETINFO,
                    &VideoCompressionCaps.StreamIndex,
                    sizeof(VideoCompressionCaps) - sizeof (KSPROPERTY),
                    &VideoCompressionCaps,
                    sizeof(VideoCompressionCaps),
                    &BytesReturned);
    }

    if (SUCCEEDED (hr)) {
        if (pszVersion) {
            ValidateWritePtr (pszVersion, *pcbVersion);
            *pszVersion = '\0'; // KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S does not have a "Version"
            *pcbVersion = 0;
        }
        if (pszDescription) {
            ValidateWritePtr (pszDescription, *pcbDescription);
            *pszDescription = '\0'; // KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S does not have a "Description"
            *pcbDescription = 0;
        }
        if (pDefaultKeyFrameRate) {
            ValidateWritePtr (pDefaultKeyFrameRate,  sizeof (*pDefaultKeyFrameRate));
            *pDefaultKeyFrameRate = VideoCompressionCaps.DefaultKeyFrameRate;
        }
        if (pDefaultPFramesPerKey) {
            ValidateWritePtr (pDefaultPFramesPerKey, sizeof (*pDefaultPFramesPerKey));
            *pDefaultPFramesPerKey = VideoCompressionCaps.DefaultPFrameRate;
        }
        if (pDefaultQuality) {
            ValidateWritePtr (pDefaultQuality,       sizeof (*pDefaultQuality));
            *pDefaultQuality = (double)VideoCompressionCaps.DefaultQuality / 10000.0;
        }
        if (pCapabilities) {
            ValidateWritePtr (pCapabilities,         sizeof (*pCapabilities));
            *pCapabilities = VideoCompressionCaps.Capabilities; 
        }
    }

    return hr;
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::OverrideKeyFrame( 
            /* [in] */ long FrameNumber)
{
   return E_PROP_ID_UNSUPPORTED;
}
        
STDMETHODIMP 
CVideoCompressionInterfaceHandler::OverrideFrameSize( 
            /* [in] */ long FrameNumber,
            /* [in] */ long Size)
{
   return E_PROP_ID_UNSUPPORTED;
}
        
 
// ---------------------------------------------------------------------
// IAMVideoControl
// ---------------------------------------------------------------------


CUnknown*
CALLBACK
CVideoControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a VideoControl
    Property Set handler. It is referred to in the g_Templates structure.
    Note that this is a filter property (not a pin property).

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CVideoControlInterfaceHandler(UnkOuter, NAME("IAMVideoControl"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVideoControlInterfaceHandler::CVideoControlInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) 
    : CUnknown(Name, UnkOuter, hr)
/*++

Routine Description:

    The constructor for the IAMVideoControl interface object. Just initializes
    everything to NULL and acquires IKsPropertySet from the parent.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            IKsObject*  Object;

            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
            if (SUCCEEDED(*hr)) {
                m_ObjectHandle = Object->KsGetObjectHandle();
                if (!m_ObjectHandle) {
                    *hr = E_UNEXPECTED;
                }
                Object->Release();
            }
        } else {
            *hr = VFW_E_NEED_OWNER;
        }
    }
}


CVideoControlInterfaceHandler::~CVideoControlInterfaceHandler(
    ) 
/*++

Routine Description:

    The destructor for the IAMVideoControl interface object.

--*/
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying CVideoControlInterfaceHandler...")));
}


STDMETHODIMP
CVideoControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMVideoControl.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IAMVideoControl)) {
        return GetInterface(static_cast<IAMVideoControl*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CVideoControlInterfaceHandler::GetCaps( 
            /* [in] */ IPin *pPin,
            /* [in] */ long *pCapsFlags)
/*++

Routine Description:

    Returns the capabilities of a pin.

Arguments:

    Pin -
        Pin handle to query

    Mode - 
        Returns available modes (KS_VideoControlFlag_*)

Return Value:

    Returns NOERROR, else some error.

--*/
{
    KSPROPERTY_VIDEOCONTROL_CAPS_S  VideoControl;
    ULONG       BytesReturned;
    HRESULT     hr;

    ValidateWritePtr (pCapsFlags, sizeof (*pCapsFlags));

    hr = PinFactoryIDFromPin (pPin, &VideoControl.StreamIndex);

    if (SUCCEEDED (hr)) {

        VideoControl.Property.Set = PROPSETID_VIDCAP_VIDEOCONTROL;
        VideoControl.Property.Id = KSPROPERTY_VIDEOCONTROL_CAPS;
        VideoControl.Property.Flags = KSPROPERTY_TYPE_GET;
    
        hr = ::SynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_PROPERTY,
                    &VideoControl,
                    sizeof(VideoControl),
                    &VideoControl,
                    sizeof(VideoControl),
                    &BytesReturned);
    
        if (SUCCEEDED (hr)) {
            *pCapsFlags = VideoControl.VideoControlCaps;
        }
    }
    return hr;
}
        
        
STDMETHODIMP 
CVideoControlInterfaceHandler::SetMode( 
            /* [in] */ IPin *pPin,
            /* [in] */ long Mode)
/*++

Routine Description:

    Sets the mode the current pin is using.  

Arguments:

    Pin -
        Pin handle to query

    Mode - 
        Sets the current mode using flags (KS_VideoControlFlag_*)

Return Value:

    Returns NOERROR, else some error.

--*/
{
    KSPROPERTY_VIDEOCONTROL_MODE_S  VideoControl;
    ULONG       BytesReturned;
    HRESULT     hr;

    VideoControl.Property.Set = PROPSETID_VIDCAP_VIDEOCONTROL;
    VideoControl.Property.Id = KSPROPERTY_VIDEOCONTROL_MODE;
    VideoControl.Property.Flags = KSPROPERTY_TYPE_SET;

    VideoControl.Mode = Mode;

    hr = PinFactoryIDFromPin (pPin, &VideoControl.StreamIndex);

    if (SUCCEEDED (hr)) {
        hr = ::SynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_PROPERTY,
                    &VideoControl,
                    sizeof(VideoControl),
                    &VideoControl,
                    sizeof(VideoControl),
                    &BytesReturned);
    }
    return hr;
}
        

STDMETHODIMP
CVideoControlInterfaceHandler::GetMode( 
            /* [in] */ IPin *pPin,
            /* [in] */ long *Mode)
/*++

Routine Description:

    Gets the mode the current pin is using.  

Arguments:

    Pin -
        Pin handle to query

    Mode - 
        Returns the current mode (KS_VideoControlFlag_*)

Return Value:

    Returns NOERROR, else some error.

--*/
{
    KSPROPERTY_VIDEOCONTROL_MODE_S  VideoControl;
    ULONG       BytesReturned;
    HRESULT     hr;

    ValidateWritePtr (Mode, sizeof (*Mode));

    hr = PinFactoryIDFromPin (pPin, &VideoControl.StreamIndex);

    if (SUCCEEDED (hr)) {

        VideoControl.Property.Set = PROPSETID_VIDCAP_VIDEOCONTROL;
        VideoControl.Property.Id = KSPROPERTY_VIDEOCONTROL_MODE;
        VideoControl.Property.Flags = KSPROPERTY_TYPE_GET;
    
        hr = ::SynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_PROPERTY,
                    &VideoControl,
                    sizeof(VideoControl),
                    &VideoControl,
                    sizeof(VideoControl),
                    &BytesReturned);
    
        if (SUCCEEDED (hr)) {
            *Mode = VideoControl.Mode;
        }
    }
    return hr;
}
        

STDMETHODIMP
CVideoControlInterfaceHandler::GetCurrentActualFrameRate( 
            /* [in]  */ IPin *pPin,
            /* [out] */ LONGLONG *ActualFrameRate)
/*++

Routine Description:

    Returns the current actual framerate.  
    This call is only valid on connected pins.

Arguments:

    Pin -
        Pin handle to query

    ActualFrameRate - 
        The current actual frame rate expressed in 100 nS units.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S VideoControl;
    ULONG       BytesReturned;
    HRESULT     hr;

    ValidateWritePtr (ActualFrameRate, sizeof (*ActualFrameRate));

    hr = PinFactoryIDFromPin (pPin, &VideoControl.StreamIndex);

    if (SUCCEEDED (hr)) {
        VideoControl.Property.Set = PROPSETID_VIDCAP_VIDEOCONTROL;
        VideoControl.Property.Id = KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE;
        VideoControl.Property.Flags = KSPROPERTY_TYPE_GET;
    
        hr = ::SynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_PROPERTY,
                    &VideoControl,
                    sizeof(VideoControl),
                    &VideoControl,
                    sizeof(VideoControl),
                    &BytesReturned);
    
        if (SUCCEEDED (hr)) {
            *ActualFrameRate = VideoControl.CurrentActualFrameRate;
        }
    }
    return hr;
}
        

STDMETHODIMP
CVideoControlInterfaceHandler::GetMaxAvailableFrameRate( 
            /* [in]  */ IPin *pPin,
            /* [in]  */ long iIndex,
            /* [in]  */ SIZE Dimensions,
            /* [out] */ LONGLONG *MaxAvailableFrameRate)
/*++

Routine Description:

    Returns the maximum frame rate given a Video DataRange and frame Dimensions.

Arguments:

    Pin -
        Pin handle to query

    iIndex -
        DataRange index

    Dimensions - 
        Size of the image

    MaxAvailableFrameRate -
        The highest frame rate at which the pin could be opened, expressed in 
        100 nS units.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S VideoControl;
    ULONG       BytesReturned;
    HRESULT     hr;

    ValidateWritePtr (MaxAvailableFrameRate, sizeof (*MaxAvailableFrameRate));

    hr = PinFactoryIDFromPin (pPin, &VideoControl.StreamIndex);

    if (SUCCEEDED (hr)) {
        VideoControl.Property.Set = PROPSETID_VIDCAP_VIDEOCONTROL;
        VideoControl.Property.Id = KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE;
        VideoControl.Property.Flags = KSPROPERTY_TYPE_GET;
    
        VideoControl.RangeIndex = iIndex;
        VideoControl.Dimensions = Dimensions;

        hr = ::SynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_PROPERTY,
                    &VideoControl,
                    sizeof(VideoControl),
                    &VideoControl,
                    sizeof(VideoControl),
                    &BytesReturned);
    
        if (SUCCEEDED (hr)) {
            *MaxAvailableFrameRate = VideoControl.CurrentMaxAvailableFrameRate;
        }
    }
    return hr;
}
        

STDMETHODIMP
CVideoControlInterfaceHandler::GetFrameRateList( 
            /* [in]  */ IPin *pPin,
            /* [in]  */ long iIndex,
            /* [in]  */ SIZE Dimensions,
            /* [out] */ long *ListSize,         // size in entries
            /* [out] */ LONGLONG **FrameRates)
/*++

Routine Description:

    Retrieves variable length list of frame rates supported for a pin,
    given a Video DataRange and frame Dimensions.  The caller is responsible
    for freeing the FrameRates buffer returned.

Arguments:

    Pin -
        Pin handle to query

    iIndex -
        DataRange index

    Dimensions - 
        Size of the image

    ListSize - 
        Returns the number of LONGLONG entries in the FrameRates list.

    FrameRates - 
        The list of LONGLONG framerates.  The caller is responsible for 
        freeing the memory allocated with CoTaskMemFree.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    PKSMULTIPLE_ITEM    MultipleItem;
    ULONG               BytesReturned;
    HRESULT             hr;
    KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S VideoControl;

    ValidateWritePtr (ListSize, sizeof (*ListSize));
    ValidateWritePtr (FrameRates, sizeof (*FrameRates));
        
    hr = PinFactoryIDFromPin (pPin, &VideoControl.StreamIndex);

    if (SUCCEEDED (hr)) {
        VideoControl.Property.Set = PROPSETID_VIDCAP_VIDEOCONTROL;
        VideoControl.Property.Id = KSPROPERTY_VIDEOCONTROL_FRAME_RATES;
        VideoControl.Property.Flags = KSPROPERTY_TYPE_GET;
    
        VideoControl.RangeIndex = iIndex;
        VideoControl.Dimensions = Dimensions;

        // First, just get the size
        hr = ::SynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_PROPERTY,
                    &VideoControl,
                    sizeof(VideoControl),
                    NULL,
                    0,
                    &BytesReturned);
    
        if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
            //
            // Allocate a buffer and query for the data.
            //
            MultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(new BYTE[BytesReturned]);
            if (!MultipleItem) {
                return E_OUTOFMEMORY;
            }
    
            hr = ::SynchronousDeviceControl(
                        m_ObjectHandle,
                        IOCTL_KS_PROPERTY,
                        &VideoControl,
                        sizeof(VideoControl),
                        MultipleItem,
                        BytesReturned,
                        &BytesReturned);
    

            if (SUCCEEDED (hr)) {
                *ListSize = MultipleItem->Count;
                //
                // Allocate a buffer the caller must free
                //
                *FrameRates = reinterpret_cast<LONGLONG*>(CoTaskMemAlloc(MultipleItem->Size));
                if (!*FrameRates) {
                    return E_OUTOFMEMORY;
                }
    
                memcpy (*FrameRates, MultipleItem + 1, MultipleItem->Size);
            }
            delete [] reinterpret_cast<BYTE*>(MultipleItem);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\drop.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    drop.cpp

Abstract:

    Implements IAMDroppedFrames 

--*/

#include "pch.h"
#include "wdmcap.h"
#include "drop.h"



CUnknown*
CALLBACK
CDroppedFramesInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of an IAMDroppedFrames
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CDroppedFramesInterfaceHandler(UnkOuter, NAME("IAMDroppedFrames"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CDroppedFramesInterfaceHandler::CDroppedFramesInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) 
    : CUnknown(Name, UnkOuter, hr)
    , m_KsPropertySet (NULL)
/*++

Routine Description:

    The constructor for the IAMDroppedFrames interface object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsPropertySet), reinterpret_cast<PVOID*>(&m_KsPropertySet));

            // We immediately release this to prevent deadlock in the proxy
            // GShaw sez:  As long as the pin is alive, the interface will be valid
#ifndef GSHAW_SEZ
            if (SUCCEEDED(*hr)) {
                m_KsPropertySet->Release();
            }
#endif
        } else {
            *hr = VFW_E_NEED_OWNER;
        }
    }
}


CDroppedFramesInterfaceHandler::~CDroppedFramesInterfaceHandler(
    )
/*++

Routine Description:

    The destructor for the IAMDroppedFrames interface.

--*/
{
#ifdef GSHAW_SEZ
    if (m_KsPropertySet) {
        m_KsPropertySet->Release();
        m_KsPropertySet = NULL;
    }
#endif
    DbgLog((LOG_TRACE, 1, TEXT("Destroying CDroppedFramesInterfaceHandler...")));
}


STDMETHODIMP
CDroppedFramesInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMDroppedFrames.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IAMDroppedFrames)) {
        return GetInterface(static_cast<IAMDroppedFrames*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CDroppedFramesInterfaceHandler::GenericGetDroppedFrames( 
    )
/*++

Routine Description:
    Internal, general routine to get the only property for this property set.

Arguments:

Return Value:


--*/
{
    KSPROPERTY_DROPPEDFRAMES_CURRENT_S DroppedFramesCurrent;
    ULONG       BytesReturned;
    HRESULT     hr;

    if (!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;
    }
    else {
        hr = m_KsPropertySet->Get (
            PROPSETID_VIDCAP_DROPPEDFRAMES,
            KSPROPERTY_DROPPEDFRAMES_CURRENT,
            &DroppedFramesCurrent.PictureNumber,
            sizeof(DroppedFramesCurrent) - sizeof (KSPROPERTY),
            &DroppedFramesCurrent,
            sizeof(DroppedFramesCurrent),
            &BytesReturned);
    }
    
    if (SUCCEEDED (hr)) {
        m_DroppedFramesCurrent = DroppedFramesCurrent;
    }
    else {
        m_DroppedFramesCurrent.PictureNumber = 0;
        m_DroppedFramesCurrent.DropCount = 0;
        m_DroppedFramesCurrent.AverageFrameSize = 0;
        hr = E_PROP_ID_UNSUPPORTED;
    }

    return hr;
}



STDMETHODIMP
CDroppedFramesInterfaceHandler::GetNumDropped( 
            /* [out] */ long *plDropped)
{
    HRESULT hr;

    CheckPointer(plDropped, E_POINTER);

    hr = GenericGetDroppedFrames();
    *plDropped = (long) m_DroppedFramesCurrent.DropCount;

    return hr;
}


STDMETHODIMP
CDroppedFramesInterfaceHandler::GetNumNotDropped( 
            /* [out] */ long *plNotDropped)
{
    HRESULT hr;

    CheckPointer(plNotDropped, E_POINTER);

    hr = GenericGetDroppedFrames();
    *plNotDropped = (long) (m_DroppedFramesCurrent.PictureNumber -
        m_DroppedFramesCurrent.DropCount);

    return hr;
}


STDMETHODIMP
CDroppedFramesInterfaceHandler::GetDroppedInfo( 
            /* [in] */ long lSize,
            /* [out] */ long *plArray,
            /* [out] */ long *plNumCopied)
{
   return E_PROP_ID_UNSUPPORTED;
}


STDMETHODIMP
CDroppedFramesInterfaceHandler::GetAverageFrameSize( 
            /* [out] */ long *plAverageSize)
{

    HRESULT hr;

    CheckPointer(plAverageSize, E_POINTER);

    hr = GenericGetDroppedFrames();
    *plAverageSize = (long) m_DroppedFramesCurrent.AverageFrameSize;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ctmcdrdr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    CTmCd.cpp

Abstract:

    Implements IAMTimecodeReader

--*/

#include "pch.h"      // Pre-compiled
#include <XPrtDefs.h>  // sdk\inc  
#include "EDevIntf.h"


// -----------------------------------------------------------------------------------
//
// CAMTcr
//
// -----------------------------------------------------------------------------------

CUnknown*
CALLBACK
CAMTcr::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by DirectShow code to create an instance of an IAMTimecodeReader
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CAMTcr(UnkOuter, NAME("IAMTimecodeReader"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 



CAMTcr::CAMTcr(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) 
    : CUnknown(Name, UnkOuter, hr)
    , m_KsPropertySet (NULL) 
    , m_ObjectHandle(NULL)
/*++

Routine Description:

    The constructor for the IAMTimecodeReader interface object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsPropertySet), reinterpret_cast<PVOID*>(&m_KsPropertySet));
            if (SUCCEEDED(*hr)) 
                m_KsPropertySet->Release(); // Stay valid until disconnected            
            else {
                DbgLog((LOG_ERROR, 1, TEXT("CAMTcr:cannot find KsPropertySet *hr %x"), *hr));
                return;
            }

            IKsObject *pKsObject;
            *hr = UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
            if (!FAILED(*hr)) {
                m_ObjectHandle = pKsObject->KsGetObjectHandle();
                ASSERT(m_ObjectHandle != NULL);
                pKsObject->Release();
            } else {
                *hr = VFW_E_NEED_OWNER;
                DbgLog((LOG_ERROR, 1, TEXT("CAMTcr:cannot find KsObject *hr %x"), *hr));
                return;
            }

        } else {
            DbgLog((LOG_ERROR, 1, TEXT("CAMTcr:there is no UnkOuter, *hr %x"), *hr));
            *hr = VFW_E_NEED_OWNER;
        }
    } else {
        DbgLog((LOG_ERROR, 1, TEXT("CAMTcr::CAMExtTransport: *hr %x"), *hr));
        return;
    }


    //
    // Allocate synchronization resource
    //
    InitializeCriticalSection(&m_csPendingData);
    // TODO: Try except in case of no memory.    

}


CAMTcr::~CAMTcr(
    )
/*++

Routine Description:

    The destructor for the IAMTimecodeReader interface.

--*/
{
    DbgLog((LOG_TRACE, 1, TEXT("Destroying CAMTcr...")));

    DeleteCriticalSection(&m_csPendingData); 
}


STDMETHODIMP
CAMTcr::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMTimecodeReader.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IAMTimecodeReader)) {
        return GetInterface(static_cast<IAMTimecodeReader*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 



HRESULT 
CAMTcr::GetTCRMode(
    long Param, 
    long FAR* pValue
    )
/*++
Routine Description:
--*/
{
    return E_NOTIMPL;
}


HRESULT 
CAMTcr::get_VITCLine(
    long * pLine
    )
/*++
Routine Description:
--*/
{
    return E_NOTIMPL;
}


HRESULT 
CAMTcr::put_VITCLine(
    long Line
    )
/*++
Routine Description:
--*/
{
    return E_NOTIMPL;
}


HRESULT 
CAMTcr::SetTCRMode(
    long Param, 
    long Value
    )
/*++

Routine Description:

    The destructor for the IAMTimecodeReader interface.

--*/
{
    return E_NOTIMPL;
}


HRESULT 
CAMTcr::GetTimecode( 
    PTIMECODE_SAMPLE pTimecodeSample
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = S_OK;
    
    switch(pTimecodeSample->dwFlags) {
    case ED_DEVCAP_TIMECODE_READ:
    case ED_DEVCAP_ATN_READ:
    case ED_DEVCAP_RTC_READ:
        break;
    default:
        return E_NOTIMPL;
    }

    if(!m_KsPropertySet) {
        hr = E_PROP_ID_UNSUPPORTED;

    } else {

        // Since we may need to wait for return notification
        // Need to dynamicaly allocate the property structure,
        // which includes an KSEVENT
        DWORD cbBytesReturned;
        PKSPROPERTY_TIMECODE_S pTmCdReaderProperty = 
            (PKSPROPERTY_TIMECODE_S) VirtualAlloc (
                            NULL, 
                            sizeof(KSPROPERTY_TIMECODE_S),
                            MEM_COMMIT | MEM_RESERVE,
                            PAGE_READWRITE);        
        if(pTmCdReaderProperty) {
            RtlZeroMemory(pTmCdReaderProperty, sizeof(KSPROPERTY_TIMECODE_S));
            
            pTmCdReaderProperty->Property.Set   = PROPSETID_TIMECODE_READER;
            pTmCdReaderProperty->Property.Id    = 
                    (pTimecodeSample->dwFlags == ED_DEVCAP_TIMECODE_READ ? 
                    KSPROPERTY_TIMECODE_READER : (pTimecodeSample->dwFlags == ED_DEVCAP_ATN_READ ? 
                    KSPROPERTY_ATN_READER : KSPROPERTY_RTC_READER));
            pTmCdReaderProperty->Property.Flags = KSPROPERTY_TYPE_GET;

            // Serialize since this routine is reentrant.
            EnterCriticalSection(&m_csPendingData);

            hr = 
                ExtDevSynchronousDeviceControl(
                    m_ObjectHandle
                   ,IOCTL_KS_PROPERTY
                   ,pTmCdReaderProperty
                   ,sizeof (KSPROPERTY)
                   ,pTmCdReaderProperty
                   ,sizeof(KSPROPERTY_TIMECODE_S)
                   ,&cbBytesReturned
                   );

            LeaveCriticalSection(&m_csPendingData);

            if(S_OK == hr) {

                // Driver only get these fileds for us 
                // so copy ONLY these two
                pTimecodeSample->dwUser            = pTmCdReaderProperty->TimecodeSamp.dwUser;
                pTimecodeSample->timecode.dwFrames = pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames;


                if(pTimecodeSample->dwFlags == ED_DEVCAP_TIMECODE_READ) {
                    DbgLog((LOG_TRACE, 2, TEXT("CAMTcr::GetTimecode (timecode) hr %x, %x == %d:%d:%d:%d"),
                        hr,
                        pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames,
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0xff000000) >> 24,  
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0x00ff0000) >> 16,
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0x0000ff00) >>  8,
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0x000000ff)
                        ));
                } if(pTimecodeSample->dwFlags == ED_DEVCAP_ATN_READ) {

                    DbgLog((LOG_TRACE, 2, TEXT("CAMTcr::GetTimecode (ATN) hr %x, BF %d, TrackNumber %d"),
                        hr, 
                        pTmCdReaderProperty->TimecodeSamp.dwUser,  
                        pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames
                        ));
                } if(pTimecodeSample->dwFlags == ED_DEVCAP_RTC_READ) {
                    DbgLog((LOG_TRACE, 2, TEXT("CAMTcr::GetTimecode (RTC) hr %x, %x == %d:%d:%d:%d"),
                        hr,
                        pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames,
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0xff000000) >> 24,  
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0x00ff0000) >> 16,
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0x0000ff00) >>  8,
                        (pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames & 0x0000007f)
                        ));
                } else {
                }
            } else {
                DbgLog((LOG_ERROR, 1, TEXT("CAMTcr::GetTimecode failed hr:0x%x (err_code:%dL)"), hr, HRESULT_CODE(hr)));
            }
          

            VirtualFree(pTmCdReaderProperty, 0, MEM_RELEASE);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\compress.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    compress.h

Abstract:

    Internal header.

--*/

class CVideoCompressionInterfaceHandler :
    public CUnknown,
    public IAMVideoCompression {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CVideoCompressionInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    virtual ~CVideoCompressionInterfaceHandler(
        void);

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    // Implement IAMVideoCompression

    STDMETHODIMP put_KeyFrameRate( 
            /* [in] */ long KeyFrameRate);
        
    STDMETHODIMP get_KeyFrameRate( 
            /* [out] */ long *pKeyFrameRate);
        
    STDMETHODIMP put_PFramesPerKeyFrame( 
            /* [in] */ long PFramesPerKeyFrame);
        
    STDMETHODIMP get_PFramesPerKeyFrame( 
            /* [out] */ long *pPFramesPerKeyFrame);
        
    STDMETHODIMP put_Quality( 
            /* [in] */ double Quality);
        
    STDMETHODIMP get_Quality( 
            /* [out] */ double *pQuality);
        
    STDMETHODIMP put_WindowSize( 
            /* [in] */ DWORDLONG WindowSize);
        
    STDMETHODIMP get_WindowSize( 
            /* [out] */ DWORDLONG *pWindowSize);
        
    STDMETHODIMP GetInfo( 
            /* [size_is][out] */ WCHAR *pszVersion,
            /* [out][in] */ int *pcbVersion,
            /* [size_is][out] */ LPWSTR pszDescription,
            /* [out][in] */ int *pcbDescription,
            /* [out] */ long *pDefaultKeyFrameRate,
            /* [out] */ long *pDefaultPFramesPerKey,
            /* [out] */ double *pDefaultQuality,
            /* [out] */ long *pCapabilities);
        
    STDMETHODIMP OverrideKeyFrame( 
            /* [in] */ long FrameNumber);
        
    STDMETHODIMP OverrideFrameSize( 
            /* [in] */ long FrameNumber,
            /* [in] */ long Size);
        
        
private:
    IPin           * m_pPin;
    IKsPropertySet * m_KsPropertySet;
    ULONG            m_PinFactoryID;

    // Generic routines used by above

    STDMETHODIMP Set1 (ULONG Property, long Value);
    STDMETHODIMP Get1 (ULONG Property, long *Value);
};


class CVideoControlInterfaceHandler :
    public CUnknown,
    public IAMVideoControl {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CVideoControlInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    virtual ~CVideoControlInterfaceHandler(
        void);

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);

    // Implement IAMVideoControl

    STDMETHODIMP GetCaps(
        /* [in]  */ IPin *pPin,
        /* [out] */ long *pCapsFlags);
    
    STDMETHODIMP SetMode( 
        /* [in]  */ IPin *pPin,
        /* [in]  */ long Mode);
    
    STDMETHODIMP GetMode( 
        /* [in]  */ IPin *pPin,
        /* [out] */ long *Mode);
    
    STDMETHODIMP GetCurrentActualFrameRate( 
        /* [in]  */ IPin *pPin,
        /* [out] */ LONGLONG *ActualFrameRate);
    
    STDMETHODIMP GetMaxAvailableFrameRate( 
        /* [in]  */ IPin *pPin,
        /* [in]  */ long iIndex,
        /* [in]  */ SIZE Dimensions,
        /* [out] */ LONGLONG *MaxAvailableFrameRate);
    
    STDMETHODIMP GetFrameRateList( 
        /* [in]  */ IPin *pPin,
        /* [in]  */ long iIndex,
        /* [in]  */ SIZE Dimensions,
        /* [out] */ long *ListSize,
        /* [out] */ LONGLONG **FrameRates);

private:

    HANDLE m_ObjectHandle;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\edevintf.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    EDevIntf.h

Abstract:

    This header contain structures and peroperty sets for 
    interfacing to an external device, like a DV.
    The code is modeled after DirectShow's Vcrctrl Sample 
    (VCR Control Filter). It contain IAMExtDevice, 
    IAMExtTransport, and IAMTimecodeReader interfaces, and 
    a new interface IAMAdvancedAVControl() is added
    for additional advanced device controls.

    Note:  (From DShow DDK)
        The VCR control sample filter, Vcrctrl, is a simple 
        implementation of the external device control interfaces 
        that DirectShow provides. Vcrctrl provides basic transport 
        control and SMPTE timecode-reading capabilities for certain 
        Betacam and SVHS videocassette recorders with RS-422 or RS-232 
        serial interfaces (see source code for specific machine types 
        supported).

    Note:  some methods in IAM* interfaces may not be 
           used and will return not implemented.           

Created:

    September 23, 1998    

    Yee J. Wu


Revision:

   0.5

--*/

#ifndef __EDevIntf__
#define __EDevIntf__


#include "edevctrl.h"  /* constants, GUIS and structure */


// a macro to screen for the "Test" flag
#define TESTFLAG(a,b) if( a & 0x80000000 ) return b



//---------------------------------------------------------
// Structures 
//---------------------------------------------------------

// Note: Many structure or fields are designed orginally for 
//       VCR controls; so some effort will be made to make them
//       more generic.

//---------------------------------------------------------
// PROPSETID_EXTDEVICE
//---------------------------------------------------------
/*

From DSHOW DDK:

IAMExtDevice Interface

The IAMExtDevice interface is the base interface for controlling 
external devices. You can implement this interface to control numerous 
types of devices; however, the current DirectShow implementation is 
specific to VCRs. The IAMExtDevice interface controls general settings 
of external hardware and is intended to be used in combination with the 
IAMExtTransport interface, which controls a VCR's more specific settings. 
You can also implement the IAMTimecodeReader, IAMTimecodeGenerator, and 
IAMTimecodeDisplay interfaces if your filter manages SMPTE (Society of 
Motion Picture and Television Engineers) timecode, and the external 
device has the appropriate features. 

*/


// Reuse from DShow Vcrctrl Sample (VCR Control Filter). 
class CAMExtDevice : public CUnknown, public IAMExtDevice
{
public:

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter, 
        HRESULT* hr);

    CAMExtDevice(
        LPUNKNOWN UnkOuter, 
        TCHAR* Name, 
        HRESULT* hr);

    virtual ~CAMExtDevice();

    // override this to say what interfaces we support where
    DECLARE_IUNKNOWN 
        STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid, 
            void ** ppv);    
 
    /* IAMExtDevice methods */
    STDMETHODIMP GetCapability (long Capability, long FAR* pValue, double FAR* pdblValue);
    STDMETHODIMP get_ExternalDeviceID(LPOLESTR * ppszData);
    STDMETHODIMP get_ExternalDeviceVersion(LPOLESTR * ppszData);
    STDMETHODIMP put_DevicePower(long PowerMode);
    STDMETHODIMP get_DevicePower(long FAR* pPowerMode);
    STDMETHODIMP Calibrate(HEVENT hEvent, long Mode, long FAR* pStatus);
    STDMETHODIMP get_DevicePort(long FAR * pDevicePort);
    STDMETHODIMP put_DevicePort(long DevicePort);

private:
    IKsPropertySet * m_KsPropertySet;
    DEVCAPS m_DevCaps;                  // Cache current external device capabilities
    // Device handle	
    HANDLE m_ObjectHandle;
    HRESULT GetCapabilities(void);      // Get all device capabilities from device driver
};




//---------------------------------------------------------
// PROPSETID_EXTXPORT
//---------------------------------------------------------

/*
From DSHOW DDK:

IAMExtTransport Interface

The IAMExtTransport interface provides methods that control specific 
behaviors of an external VCR. These methods generally set and get the 
transport properties, which relate to how the VCR and the computer 
exchange data. Because this interface controls specific behaviors of 
transport, it must be implemented in combination with the IAMExtDevice 
interface, which controls an external device's general behaviors. If 
you want to control an external device other than a VCR, you have two 
options. Either use the methods you need and return E_NOTIMPL for the 
rest, or design a new interface and aggregate it with IAMExtDevice. 

*/

STDMETHODIMP
ExtDevSynchronousDeviceControl(
    HANDLE Handle,
    ULONG IoControl,
    PVOID InBuffer,
    ULONG InLength,
    PVOID OutBuffer,
    ULONG OutLength,
    PULONG BytesReturned
    );

// Reuse from DShow Vcrctrl Sample (VCR Control Filter). 
class CAMExtTransport : public CUnknown, public IAMExtTransport
{
public:

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CAMExtTransport(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    virtual ~CAMExtTransport(
             );

    DECLARE_IUNKNOWN
    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    /* IAMExtTransport methods */
    STDMETHODIMP GetCapability (long Capability, long FAR* pValue,
        double FAR* pdblValue);
    STDMETHODIMP put_MediaState(long State);
    STDMETHODIMP get_MediaState(long FAR* pState);
    STDMETHODIMP put_LocalControl(long State);
    STDMETHODIMP get_LocalControl(long FAR* pState);
    STDMETHODIMP GetStatus(long StatusItem, long FAR* pValue);
    STDMETHODIMP GetTransportBasicParameters(long Param, long FAR* pValue,
           LPOLESTR * ppszData);
    STDMETHODIMP SetTransportBasicParameters(long Param, long Value,
           LPCOLESTR pszData);
    STDMETHODIMP GetTransportVideoParameters(long Param, long FAR* pValue);
    STDMETHODIMP SetTransportVideoParameters(long Param, long Value);
    STDMETHODIMP GetTransportAudioParameters(long Param, long FAR* pValue);
    STDMETHODIMP SetTransportAudioParameters(long Param, long Value);
    STDMETHODIMP put_Mode(long Mode);
    STDMETHODIMP get_Mode(long FAR* pMode);
    STDMETHODIMP put_Rate(double dblRate);
    STDMETHODIMP get_Rate(double FAR* pdblRate);
    STDMETHODIMP GetChase(long FAR* pEnabled, long FAR* pOffset,
       HEVENT FAR* phEvent);
    STDMETHODIMP SetChase(long Enable, long Offset, HEVENT hEvent);
    STDMETHODIMP GetBump(long FAR* pSpeed, long FAR* pDuration);
    STDMETHODIMP SetBump(long Speed, long Duration);
    STDMETHODIMP get_AntiClogControl(long FAR* pEnabled);
    STDMETHODIMP put_AntiClogControl(long Enable);
    STDMETHODIMP GetEditPropertySet(long EditID, long FAR* pState);
    STDMETHODIMP SetEditPropertySet(long FAR* pEditID, long State);
    STDMETHODIMP GetEditProperty(long EditID, long Param, long FAR* pValue);
    STDMETHODIMP SetEditProperty(long EditID, long Param, long Value);
    STDMETHODIMP get_EditStart(long FAR* pValue);
    STDMETHODIMP put_EditStart(long Value);


private:
    IKsPropertySet * m_KsPropertySet;

    TRANSPORTSTATUS     m_TranStatus;         // current status
    TRANSPORTVIDEOPARMS m_TranVidParms;   // keep all capabilities, etc. here
    TRANSPORTAUDIOPARMS m_TranAudParms;
    TRANSPORTBASICPARMS m_TranBasicParms;
  
    // a bunch of properties we want to remember
    VCRSTATUS m_VcrStatus;  // raw status from VCR

	// Device handle	
    HANDLE m_ObjectHandle;
	
	
    //
	// These evetns are used to wait for pending operation so the operation can complete synchronously		
    // For AVC Cmd that result in Interim response;
    // KS event is siganl in the driver to indicate interim response is complted.
    // The other event is passed to application (Yes, we trust them) and is signalled when KS event is signal.    
    //

    // *** Notify interim command
    BOOL   m_bNotifyInterimEnabled;
	HANDLE m_hNotifyInterimEvent;    // Return to client to wait on.
	HANDLE m_hKSNotifyInterimEvent;  // KSEvent for driver to signal
    KSEVENTDATA m_EvtNotifyInterimReady;
    // Data that is awaiting completion	
    long *                    m_plValue;         // Data from client; should we allocate this instead
    PKSPROPERTY_EXTXPORT_S    m_pExtXprtPropertyPending;   // data structure that we allocated
    // When releasing this event, if this count is >0, signal the event.
	LONG                      m_cntNotifyInterim;         // Allow only one pending (0 or 1).

    // *** Control interim command
	HANDLE m_hKSCtrlInterimEvent;
    BOOL   m_bCtrlInterimEnabled;    // Return to client to wait on.
	HANDLE m_hCtrlInterimEvent;      // KSEvent for driver to signal
    KSEVENTDATA m_EvtCtrlInterimReady;

    // *** Detect device removal
    BOOL   m_bDevRemovedEnabled;     
	HANDLE m_hDevRemovedEvent;       // Return to client to wait on.
	HANDLE m_hKSDevRemovedEvent;     // KSEVent to detect removal of a device.
    KSEVENTDATA m_EvtDevRemoval;     
    // This is initialze to FALSE.  When a device is removed, 
    // subsequent call into this interface will return ERROR_DEVIFCE_REMOVED.
    BOOL   m_bDevRemoved;

    // Signal thread is ending and clean up.
	HANDLE m_hThreadEndEvent;
	
    // Serial thread execution
	CRITICAL_SECTION m_csPendingData;

	// 2nd thread handle	
	HANDLE m_hThread;
	
	// Methods used to create and by 2nd thread to process asychronous operation	
    HRESULT CreateThread(void);
    static DWORD WINAPI InitialThreadProc(CAMExtTransport *pThread);
    DWORD MainThreadProc(void);
    void ExitThread(void);

    HRESULT EnableNotifyEvent(HANDLE hEvent, PKSEVENTDATA pEventData, ULONG   ulEventId);
    HRESULT DisableNotifyEvent(PKSEVENTDATA pEventData);
};




//---------------------------------------------------------
// PROPSETID_TIMECODE
//---------------------------------------------------------

/*

From DSHOW DDK:

IAMTimecodeReader Interface

You can implement the IAMTimecodeReader interface to read SMPTE 
(Society of Motion Picture and Television Engineers) or MIDI timecode 
from an external device. It contains properties and methods that 
specify the timecode format that an external device should read, and 
how it is embedded in the media. It is expected that you will use 
this interface with the IAMExtDevice and IAMExtTransport interfaces 
to control an external device, such as a VCR, which can read timecode 
data. 

*/



// Reuse from DShow Vcrctrl Sample (VCR Control Filter). 
class CAMTcr : public CUnknown, public IAMTimecodeReader
{
public:

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CAMTcr(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    virtual ~CAMTcr();

    DECLARE_IUNKNOWN
    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    /* IAMTimecodeReader methods */
    STDMETHODIMP GetTCRMode( long Param, long FAR* pValue);
    STDMETHODIMP SetTCRMode( long Param, long Value);
    STDMETHODIMP put_VITCLine( long Line);
    STDMETHODIMP get_VITCLine( long FAR* pLine);
    STDMETHODIMP GetTimecode( PTIMECODE_SAMPLE pTimecodeSample);

private:                             
    IKsPropertySet * m_KsPropertySet;

    HANDLE m_ObjectHandle;

    // Serialize thread execution
	CRITICAL_SECTION m_csPendingData;
	
    TIMECODE_SAMPLE m_TimecodeSample;
};



#endif // __EDevIntf__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatav1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ksdatav1.h
//
//--------------------------------------------------------------------------

#ifndef __KSDATAV1__
#define __KSDATAV1__

class CVideo1DataTypeHandler :
    public CUnknown,
    public IKsDataTypeHandler,
    public IKsDataTypeCompletion
{

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsDataTypeHandler
    
    STDMETHODIMP 
    KsCompleteIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation, 
        IN BOOL Cancelled
        );
        
    STDMETHODIMP 
    KsIsMediaTypeInRanges(
        IN PVOID DataRanges
        );
        
    STDMETHODIMP 
    KsPrepareIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation
        );
    
    STDMETHODIMP 
    KsQueryExtendedSize( 
        IN ULONG* ExtendedSize
        );
        
    STDMETHODIMP 
    KsSetMediaType(
        const AM_MEDIA_TYPE *AmMediaType
        );
 
	 // IKsDataTypeCompletion

    STDMETHODIMP
	 KsCompleteMediaType(
        HANDLE FilterHandle,
        ULONG PinFactoryId,
        AM_MEDIA_TYPE* AmMediaType
		  );
 
private:
    CLSID           m_ClsID;
    CMediaType     *m_MediaType;
    LPUNKNOWN       m_PinUnknown;
    BOOL            m_fDammitOVMixerUseMyBufferCount;
    BOOL            m_fCheckedIfDammitOVMixerUseMyBufferCount;

    CVideo1DataTypeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
        
    ~CVideo1DataTypeHandler();
        
};

#endif // __KSDATAV1__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatava.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksdataVA.cpp

Abstract:

    This module implements the IKsDataTypeHandler interface for 
    Analog Video format (Specifier) types.

Author:

    Jay Borseth (jaybo) 30-May-1997

--*/

#include "pch.h"
#include "ksdatava.h"


CUnknown*
CALLBACK
CAnalogVideoDataTypeHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of a
    data type handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( LOG_TRACE, 1, TEXT("CAnalogVideoDataTypeHandler::CreateInstance()")));

    Unknown = 
        new CAnalogVideoDataTypeHandler( 
                UnkOuter, 
                NAME("AnalogVideo Data Type Handler"), 
                FORMAT_AnalogVideo,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CAnalogVideoDataTypeHandler::CAnalogVideoDataTypeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown(Name, UnkOuter, hr),
    m_ClsID(ClsID),
    m_MediaType(NULL)
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
} 


CAnalogVideoDataTypeHandler::~CAnalogVideoDataTypeHandler()
{
    if (m_MediaType) {
        delete m_MediaType;
    }
}


STDMETHODIMP
CAnalogVideoDataTypeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsDataTypeHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IKsDataTypeHandler)) {
        return GetInterface(static_cast<IKsDataTypeHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP 
CAnalogVideoDataTypeHandler::KsCompleteIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation, 
    IN BOOL Cancelled
    )

/*++

Routine Description:
    Clean up the extended header and complete I/O operation.
    
    In the default case for major type == KSDATAFORMAT_TYPE_VIDEO, there
    is no work to do, just return S_OK.

Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation
    
    IN BOOL Cancelled
        Set if the I/O operation was cancelled.

Return:
    S_OK

--*/

{
    return S_OK;
}

STDMETHODIMP 
CAnalogVideoDataTypeHandler::KsPrepareIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation
    )

/*++

Routine Description:
    Intialize the extended header and prepare sample for I/O operation.
    
    In the default case for major type == KSDATAFORMAT_TYPE_VIDEO, there
    is no work to do, just return S_OK.

Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation

Return:
    S_OK

--*/

{
    return S_OK;
}

STDMETHODIMP 
CAnalogVideoDataTypeHandler::KsIsMediaTypeInRanges(
    IN PVOID DataRanges
)

/*++

Routine Description:
    Validates that the given media type is within the provided data ranges.

Arguments:
    IN PVOID DataRanges -
        pointer to data ranges which is a KSMULTIPLE_ITEM structure followed
        by ((PKSMULTIPLEITEM) DataRanges)->Count data range structures.

Return:
    S_OK if match found, S_FALSE if not found, or an appropriate error code.

--*/

{
    ULONG                       u;
    PKS_DATARANGE_ANALOGVIDEO   AnalogVideoRange;
    PKSMULTIPLE_ITEM            MultipleItem;
    
    DbgLog((LOG_TRACE, 1, TEXT("CAnalogVideoDataTypeHandler::KsIsMediaTypeInRanges")));
    
    ASSERT( *m_MediaType->Type() == MEDIATYPE_AnalogVideo );
    
    MultipleItem = (PKSMULTIPLE_ITEM) DataRanges;
    
    for (u = 0, AnalogVideoRange = (PKS_DATARANGE_ANALOGVIDEO) (MultipleItem + 1);
            u < MultipleItem->Count; 
            u++, AnalogVideoRange = 
                (PKS_DATARANGE_ANALOGVIDEO)((PBYTE)AnalogVideoRange + 
                    ((AnalogVideoRange->DataRange.FormatSize + 7) & ~7))) {
    
        //
        // Only validate those in the range that match the format specifier.
        //
        
        if ((AnalogVideoRange->DataRange.FormatSize < sizeof( KS_DATARANGE_ANALOGVIDEO )) ||
            AnalogVideoRange->DataRange.MajorFormat != MEDIATYPE_AnalogVideo) {
            continue;
        }

        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if (((AnalogVideoRange->DataRange.SubFormat != *m_MediaType->Subtype()) &&
             (AnalogVideoRange->DataRange.SubFormat != KSDATAFORMAT_SUBTYPE_WILDCARD)) || 
             (AnalogVideoRange->DataRange.Specifier != *m_MediaType->FormatType())) {
            continue;
        }

        //
        // Verify that we have an intersection with the specified format and 
        // our audio format dictated by our specific requirements.
        //
        
        if (*m_MediaType->FormatType() == FORMAT_AnalogVideo) {
 
            //
            // We have found a match.
            //
            
            return S_OK;
            
        } else {
        
            //
            // We match on the wildcard.
            //
            
            return S_OK;
        }
    }
    
    return VFW_E_INVALIDMEDIATYPE;
}

STDMETHODIMP 
CAnalogVideoDataTypeHandler::KsQueryExtendedSize( 
    OUT ULONG* ExtendedSize
)

/*++

Routine Description:
    Returns the extended size for each stream header. 
    
    In the default case for major type == KSDATAFORMAT_TYPE_VIDEO, 
    the extended size is KS_VBI_FRAME_INFO.

Arguments:
    OUT ULONG* ExtendedSize -
        pointer to receive the extended size.

Return:
    S_OK

--*/

{
    *ExtendedSize = 0; 
    return S_OK;
}
    

STDMETHODIMP 
CAnalogVideoDataTypeHandler::KsSetMediaType(
    const AM_MEDIA_TYPE *AmMediaType
    )

/*++

Routine Description:
    Sets the media type for this instance of the data handler.

Arguments:
    const AM_MEDIA_TYPE *AmMediaType -
        pointer to the media type

Return:
    S_OK

--*/

{
    if (m_MediaType) {
        return E_FAIL;
    }
    if (m_MediaType = new CMediaType( *AmMediaType )) {
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatav2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ksdatav2.h
//
//--------------------------------------------------------------------------

#ifndef __KSDATAV2__
#define __KSDATAV2__

class CVideo2DataTypeHandler :
    public CUnknown,
    public IKsDataTypeHandler,
    public IKsDataTypeCompletion
{

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsDataTypeHandler
    
    STDMETHODIMP 
    KsCompleteIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation, 
        IN BOOL Cancelled
        );
        
    STDMETHODIMP 
    KsIsMediaTypeInRanges(
        IN PVOID DataRanges
        );
        
    STDMETHODIMP 
    KsPrepareIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation
        );
    
    STDMETHODIMP 
    KsQueryExtendedSize( 
        IN ULONG* ExtendedSize
        );
        
    STDMETHODIMP 
    KsSetMediaType(
        const AM_MEDIA_TYPE *AmMediaType
        );
        
	 // IKsDataTypeCompletion

    STDMETHODIMP
	 KsCompleteMediaType(
        HANDLE FilterHandle,
        ULONG PinFactoryId,
        AM_MEDIA_TYPE* AmMediaType
		  );
        
private:
    CLSID           m_ClsID;
    CMediaType     *m_MediaType;
    LPUNKNOWN       m_PinUnknown;
    BOOL            m_fDammitOVMixerUseMyBufferCount;
    BOOL            m_fCheckedIfDammitOVMixerUseMyBufferCount;

    CVideo2DataTypeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
        
    ~CVideo2DataTypeHandler();
        
};

#endif // __KSDATAV2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatava.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ksdatava.h
//
//--------------------------------------------------------------------------

#ifndef __KSDATAVA__
#define __KSDATAVA__

class CAnalogVideoDataTypeHandler :
    public CUnknown,
    public IKsDataTypeHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsDataTypeHandler
    
    STDMETHODIMP 
    KsCompleteIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation, 
        IN BOOL Cancelled
        );
        
    STDMETHODIMP 
    KsIsMediaTypeInRanges(
        IN PVOID DataRanges
        );
        
    STDMETHODIMP 
    KsPrepareIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation
        );
    
    STDMETHODIMP 
    KsQueryExtendedSize( 
        IN ULONG* ExtendedSize
        );
        
    STDMETHODIMP 
    KsSetMediaType(
        const AM_MEDIA_TYPE *AmMediaType
        );
        
        
private:
    CLSID       m_ClsID;
    CMediaType  *m_MediaType;

    CAnalogVideoDataTypeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
        
    ~CAnalogVideoDataTypeHandler();
        
};

#endif // __KSDATAVA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatav2.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksdataV2.cpp

Abstract:

    This module implements the IKsDataTypeHandler interface for 
    VIDEOINFOHEADER2 CMediaType format (Specifier) types.

Author:

    Jay Borseth (jaybo) 30-May-1997

--*/

#include "pch.h"
#include "wdmcap.h"
#include "ksdatav2.h"


CUnknown*
CALLBACK
CVideo2DataTypeHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of a
    data type handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( LOG_TRACE, 1, TEXT("CVideo2DataTypeHandler::CreateInstance()")));

    Unknown = 
        new CVideo2DataTypeHandler( 
                UnkOuter, 
                NAME("Video2 Data Type Handler"), 
                FORMAT_VideoInfo2,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVideo2DataTypeHandler::CVideo2DataTypeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown(Name, UnkOuter, hr),
    m_ClsID(ClsID),
    m_MediaType(NULL),
    m_PinUnknown (UnkOuter),
    m_fDammitOVMixerUseMyBufferCount (FALSE),
    m_fCheckedIfDammitOVMixerUseMyBufferCount (FALSE)
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
//    ASSERT (m_PinUnknown);
} 


CVideo2DataTypeHandler::~CVideo2DataTypeHandler()
{
    if (m_MediaType) {
        delete m_MediaType;
    }
}


STDMETHODIMP
CVideo2DataTypeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsDataTypeHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IKsDataTypeHandler)) {
        return GetInterface(static_cast<IKsDataTypeHandler*>(this), ppv);
    }
    else if (riid ==  __uuidof(IKsDataTypeCompletion)) {
        return GetInterface(static_cast<IKsDataTypeCompletion*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP 
CVideo2DataTypeHandler::KsCompleteIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation, 
    IN BOOL Cancelled
    )

/*++

Routine Description:
    Clean up the extended header and complete I/O operation.
    
Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation
    
    IN BOOL Cancelled
        Set if the I/O operation was cancelled.

Return:
    S_OK

--*/

{
    HRESULT                     hr;
    IMediaSample2               *Sample2;
    AM_SAMPLE2_PROPERTIES       SampleProperties;
    PKS_FRAME_INFO              pFrameInfo;

    DbgLog(( LOG_TRACE, 5, TEXT("CVideo2DataTypeHandler::KsCompleteIoOperation")));
    
    pFrameInfo = (PKS_FRAME_INFO) ((KSSTREAM_HEADER *) StreamHeader + 1);

    // Verify we're getting back the sizeof extended header
    KASSERT (pFrameInfo->ExtendedHeaderSize == sizeof (KS_FRAME_INFO));

    if (IoOperation == KsIoOperation_Read) {

        LONGLONG NextFrame = pFrameInfo->PictureNumber + 1;

        // Get the frame number and put it into the MediaTime
        Sample->SetMediaTime (&pFrameInfo->PictureNumber, 
                              &NextFrame);

        DbgLog((LOG_TRACE, 3, TEXT("PictureNumber = %ld"), 
            pFrameInfo->PictureNumber));

        // Copy over the field polarity and IBP flags on a write

        if (pFrameInfo->dwFrameFlags) {

            if (SUCCEEDED( Sample->QueryInterface(
                                __uuidof(IMediaSample2),
                                reinterpret_cast<PVOID*>(&Sample2) ) )) {

                hr = Sample2->GetProperties(
                                sizeof( SampleProperties ), 
                                reinterpret_cast<PBYTE> (&SampleProperties) );

                //
                // Modify the field polarity and IBP flags
                //

                SampleProperties.dwTypeSpecificFlags = pFrameInfo->dwFrameFlags;

                hr = Sample2->SetProperties(
                                sizeof( SampleProperties ), 
                                reinterpret_cast<PBYTE> (&SampleProperties) );

                Sample2->Release();
            }
            else {
                DbgLog(( LOG_ERROR, 0, TEXT("CVideo2DataTypeHandler::KsPrepareIoOperation, QI IMediaSample2 FAILED")));
            }

        }  // endif (pFrameInfo->dwFrameFlags)


        if (IoOperation == KsIoOperation_Read) {
            IDirectDrawMediaSample          *DDMediaSample = NULL;
            IDirectDrawSurface              *DDSurface = NULL;
            IDirectDrawSurfaceKernel        *DDSurfaceKernel = NULL;
            RECT                             DDRect;

            // 
            // Post Win98 path
            //
            if (m_fDammitOVMixerUseMyBufferCount 
                && pFrameInfo->hDirectDraw
                && pFrameInfo->hSurfaceHandle) {
    
                // Verify the pin is valid
                if (!m_PinUnknown) {
                    DbgLog((LOG_ERROR,0,TEXT("m_PinUnknown is NULL")));
                    goto CleanUp;
                }
        
                // Get DDMediaSample
                hr = Sample->QueryInterface(__uuidof(IDirectDrawMediaSample),
                                    reinterpret_cast<PVOID*>(&DDMediaSample) );
                if (FAILED(hr)) {
                    DbgLog((LOG_TRACE,5,TEXT("QueryInterface for IDirectDrawMediaSample failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
    
                // hack alert!  We originally unlocked the surface when sending it down to the 
                // kernel driver.  Now we relock and then unlock again just to get the 
                // IDirectDrawSurface
    
                hr = DDMediaSample->LockMediaSamplePointer ();
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("LockMediaSamplePointer failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
    
                // Get the surface and unlock it AGAIN
                // Note that DDSurface is NOT AddRef'd by this call !!!
                hr = DDMediaSample->GetSurfaceAndReleaseLock( 
                                        &DDSurface,
                                        &DDRect);
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("GetSurfaceAndReleaseLock failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
        
                // Get IDirectDrawSurfaceKernel
                hr = DDSurface->QueryInterface(IID_IDirectDrawSurfaceKernel,
                                    reinterpret_cast<PVOID*>(&DDSurfaceKernel) );
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("IDirectDrawSurfaceKernel failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
        
                // Release the Kernel Handle
                hr = DDSurfaceKernel->ReleaseKernelHandle ();
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("ReleaseKernelHandle failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
            }
            else {
                //
                // In Win98, no cleanup was done!!!
                //

            }


    CleanUp:
            if (DDMediaSample) {
                DDMediaSample->Release();
            }
    
            if (DDSurfaceKernel) {
                DDSurfaceKernel->Release();
            }
        }
    }
    
    return S_OK;
}

STDMETHODIMP 
CVideo2DataTypeHandler::KsPrepareIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation
    )

/*++

Routine Description:
    Intialize the extended header and prepare sample for I/O operation.
    
Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation

Return:
    S_OK

--*/

{
    HRESULT                     hr;
    IMediaSample2               *Sample2;
    AM_SAMPLE2_PROPERTIES       SampleProperties;
    PKS_FRAME_INFO              pFrameInfo;

    DbgLog(( LOG_TRACE, 5, TEXT("CVideo2DataTypeHandler::KsPrepareIoOperation")));

    pFrameInfo = (PKS_FRAME_INFO) ((KSSTREAM_HEADER *) StreamHeader + 1);
    pFrameInfo->ExtendedHeaderSize = sizeof (KS_FRAME_INFO);

    if (IoOperation == KsIoOperation_Write) {
        //
        // Copy over the field polarity and IBP flags on a write
        //
        if (SUCCEEDED( Sample->QueryInterface(
                        __uuidof(IMediaSample2),
                        reinterpret_cast<PVOID*>(&Sample2) ) )) {
            hr = Sample2->GetProperties(
                        sizeof( SampleProperties ), 
                        reinterpret_cast<PBYTE> (&SampleProperties) );
            Sample2->Release();
            pFrameInfo->dwFrameFlags = SampleProperties.dwTypeSpecificFlags;
        }
        else {
            DbgLog(( LOG_ERROR, 0, TEXT("CVideo2DataTypeHandler::KsPrepareIoOperation, QI IMediaSample2 FAILED")));
        }
        return S_OK;
    }

    if (IoOperation == KsIoOperation_Read) {

        // The extended header is presumed to be zeroed out!

        // When using the OverlayMixer, we need to get the user mode
        // handles to DirectDraw and to the surface, unlock the surface
        // and stuff the handles into the extended header

        // Note that the surface handle is left unlocked, but the DD handle is released

        IDirectDrawMediaSample          *DDMediaSample = NULL;
        IDirectDrawSurface              *DDSurface = NULL;
        IDirectDrawSurfaceKernel        *DDSurfaceKernel = NULL;
        HANDLE                           DDSurfaceKernelHandle;
        IDirectDrawMediaSampleAllocator *DDMediaSampleAllocator = NULL;
        IDirectDraw                     *DD = NULL;
        IDirectDrawKernel               *DDKernel = NULL;
        HANDLE                           DDKernelHandle;
        RECT                             DDRect;
        IKsPin                          *KsPin = NULL;
        IMemAllocator                   *MemAllocator = NULL;          

        // Verify the pin is valid
        if (!m_PinUnknown) {
            DbgLog((LOG_ERROR,0,TEXT("m_PinUnknown is NULL")));
            goto CleanUp;
        }

        //
        // Step 1, get a whole bunch of garbage, just to get 
        // the DirectDrawKernel handle.  If the display driver
        // doesn't support Overlay flipping in the kernel, then bail.
        //

        // Get IKsPin
        hr = m_PinUnknown->QueryInterface(__uuidof(IKsPin),
                            reinterpret_cast<PVOID*>(&KsPin) );
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR,0,TEXT("IKsPin failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        //
        // If the pin doesn't support the 
        // "I really want to use the number of buffers I request" property
        // then follow the new code path, else use the Win98 gold version
        //
        if (!m_fCheckedIfDammitOVMixerUseMyBufferCount) {
            IKsPropertySet *KsPropertySet;
            DWORD           dwBytesReturned;

            m_fCheckedIfDammitOVMixerUseMyBufferCount = TRUE;

            hr = KsPin->QueryInterface(__uuidof(IKsPropertySet),
                                reinterpret_cast<PVOID*>(&KsPropertySet) );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IKsPropertySet failed, hr = 0x%x"), hr));
                goto CleanUp;
            }

            hr = KsPropertySet->Get (PROPSETID_ALLOCATOR_CONTROL,
                                KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,
                                NULL,                               // LPVOID pInstanceData,
                                0,                                  // DWORD cbInstanceData,
                                &m_fDammitOVMixerUseMyBufferCount,    // LPVOID pPropData,
                                sizeof (m_fDammitOVMixerUseMyBufferCount),
                                &dwBytesReturned);

            KsPropertySet->Release();

            if (m_fDammitOVMixerUseMyBufferCount) {
                DbgLog((LOG_TRACE,1,TEXT("Stream Supports PROPSETID_ALLOCATOR_CONTROL, KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT for OVMixer")));
            }
        }

        //
        // The Post Win98 path, if driver supports kernel flipping explicitely
        //
        if (m_fDammitOVMixerUseMyBufferCount) {

            // Get the allocator but don't AddRef
            MemAllocator = KsPin->KsPeekAllocator (KsPeekOperation_PeekOnly);
    
            if (!MemAllocator) {
                DbgLog((LOG_ERROR,0,TEXT("MemAllocator is NULL, hr = 0x%x"), hr));
                goto CleanUp;
            }
            
            // Get the SampleAllocator
            hr = MemAllocator->QueryInterface(__uuidof(IDirectDrawMediaSampleAllocator),
                            reinterpret_cast<PVOID*>(&DDMediaSampleAllocator) );
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDrawMediaSampleAllocator failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get IDirectDraw
            // Note that IDirectDraw is NOT Addref'd by this call!!!
            hr = DDMediaSampleAllocator->GetDirectDraw(&DD);
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDraw failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get IDirectDrawKernel
            hr = DD->QueryInterface(IID_IDirectDrawKernel,
                            reinterpret_cast<PVOID*>(&DDKernel) );
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDrawKernel failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Verify that kernel flip is available
            DDKERNELCAPS KCaps;
            KCaps.dwSize = sizeof (DDKERNELCAPS);
            hr = DDKernel->GetCaps (&KCaps);
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetCaps failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            if (!(KCaps.dwCaps & DDKERNELCAPS_FLIPOVERLAY)) {
                DbgLog((LOG_ERROR,0,TEXT("GetCaps failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // to get DDKernelHandle
            hr = DDKernel->GetKernelHandle ((ULONG_PTR*)&DDKernelHandle);
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetKernelHandle failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            // Release the handle immediately
            hr = DDKernel->ReleaseKernelHandle ();  
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("ReleaseKernelHandle failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            //
            // Step 2, get a whole bunch of garbage, just to get 
            // the DirectDrawSurfaceKernel handle.
            //
    
            // Get DDMediaSample
            hr = Sample->QueryInterface(__uuidof(IDirectDrawMediaSample),
                                reinterpret_cast<PVOID*>(&DDMediaSample) );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("QueryInterface for IDirectDrawMediaSample failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get the surface and unlock it
            // Note that DDSurface is NOT AddRef'd by this call !!!
            // We keep the sample unlocked until the sample is returned, since a locked sample takes
            // the Win16 Lock
            hr = DDMediaSample->GetSurfaceAndReleaseLock( 
                                    &DDSurface,
                                    &DDRect);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetSurfaceAndReleaseLock failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get IDirectDrawSurfaceKernel
            hr = DDSurface->QueryInterface(IID_IDirectDrawSurfaceKernel,
                                reinterpret_cast<PVOID*>(&DDSurfaceKernel) );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDrawSurfaceKernel failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get the Kernel Handle
            hr = DDSurfaceKernel->GetKernelHandle ((ULONG_PTR*)&DDSurfaceKernelHandle);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetKernelHandle failed, hr = 0x%x"), hr));
                goto CleanUp;
            }

            //
            // The point of it all, stuff the handles into the sample extended header
            // so the driver can do a kernel flip
            //
            pFrameInfo->DirectDrawRect = DDRect;
            pFrameInfo->hDirectDraw = DDKernelHandle;
            pFrameInfo->hSurfaceHandle = DDSurfaceKernelHandle;
    
        }
        //
        // Else, do exactly what was done in Win98
        //
        else {
                      // First unlock the sample and get the surface handle
            if (SUCCEEDED( Sample->QueryInterface(
                                __uuidof(IDirectDrawMediaSample),
                                reinterpret_cast<PVOID*>(&DDMediaSample) ))) {

                hr = DDMediaSample->GetSurfaceAndReleaseLock( 
                                &DDSurface,
                                &DDRect);

                ASSERT (SUCCEEDED (hr));

                pFrameInfo->hSurfaceHandle = (HANDLE) DDSurface;
                pFrameInfo->DirectDrawRect = DDRect;

                // Now get the DDraw handle from the allocator
                if (m_PinUnknown && SUCCEEDED( m_PinUnknown->QueryInterface(
                                    __uuidof(IKsPin),
                                    reinterpret_cast<PVOID*>(&KsPin) ))) {

                    // Get the allocator but don't AddRef
                    MemAllocator = KsPin->KsPeekAllocator (KsPeekOperation_PeekOnly);

                    if (MemAllocator) {

                        if (SUCCEEDED( MemAllocator->QueryInterface(
                                        __uuidof(IDirectDrawMediaSampleAllocator),
                                        reinterpret_cast<PVOID*>(&DDMediaSampleAllocator) ))) {
    
                            hr = DDMediaSampleAllocator->GetDirectDraw(
                                        &DD);
    
                            ASSERT (SUCCEEDED (hr));
    
                            pFrameInfo->hDirectDraw = (HANDLE) DD;
                        }
                        else {
                            ASSERT (FALSE);
                            DbgLog(( LOG_ERROR, 0, TEXT("QI IDirectDrawMediaSampleAllocator FAILED")));
                        }
                    }
                    else {
                        ASSERT (FALSE);
                        DbgLog(( LOG_ERROR, 0, TEXT("Peek Allocator FAILED")));

                    }
                }
                else {
                    ASSERT (FALSE);
                    DbgLog(( LOG_ERROR, 0, TEXT("QI IKSPIN FAILED")));
                }
            }
        }


CleanUp:
        if (DDMediaSample) {
            DDMediaSample->Release();
        }

        if (DDSurfaceKernel) {
            DDSurfaceKernel->Release();
        }

        if (KsPin) {
            KsPin->Release ();
        }

        if (DDMediaSampleAllocator) {
            DDMediaSampleAllocator->Release();
        }

        if (DDKernel) {
            DDKernel->Release();
        }
    }

    return S_OK;
}

STDMETHODIMP 
CVideo2DataTypeHandler::KsIsMediaTypeInRanges(
    IN PVOID DataRanges
)

/*++

Routine Description:
    Validates that the given media type is within the provided data ranges.

Arguments:
    IN PVOID DataRanges -
        pointer to data ranges which is a KSMULTIPLE_ITEM structure followed
        by ((PKSMULTIPLEITEM) DataRanges)->Count data range structures.

Return:
    S_OK if match found, S_FALSE if not found, or an appropriate error code.

--*/

{
    ULONG                   u;
    PKS_DATARANGE_VIDEO2    Video2Range;
    PKSMULTIPLE_ITEM        MultipleItem;
    
    DbgLog((LOG_TRACE, 1, TEXT("CVideo2DataTypeHandler::KsIsMediaTypeInRanges")));
    
    ASSERT( *m_MediaType->Type() == KSDATAFORMAT_TYPE_VIDEO );
    
    MultipleItem = (PKSMULTIPLE_ITEM) DataRanges;
    
    for (u = 0, Video2Range = (PKS_DATARANGE_VIDEO2) (MultipleItem + 1);
         u < MultipleItem->Count; 
         u++, Video2Range = 
                (PKS_DATARANGE_VIDEO2)((PBYTE)Video2Range + 
                ((Video2Range->DataRange.FormatSize + 7) & ~7))) {
    
        //
        // Only validate those in the range that match the format specifier.
        //
        if (((Video2Range->DataRange.FormatSize < sizeof( KSDATARANGE )) ||
             (Video2Range->DataRange.MajorFormat != KSDATAFORMAT_TYPE_WILDCARD)) &&
            ((Video2Range->DataRange.FormatSize < sizeof( KS_DATARANGE_VIDEO)) ||
             (Video2Range->DataRange.MajorFormat != KSDATAFORMAT_TYPE_VIDEO) )) {
            continue;
        }
        
        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if (((Video2Range->DataRange.SubFormat != *m_MediaType->Subtype()) && 
             (Video2Range->DataRange.SubFormat != KSDATAFORMAT_SUBTYPE_WILDCARD)) || 
            ((Video2Range->DataRange.Specifier != *m_MediaType->FormatType()) &&
             (Video2Range->DataRange.Specifier != KSDATAFORMAT_SPECIFIER_WILDCARD))) {
            continue;
        }


        //
        // Verify that we have an intersection with the specified format
        //
        
        if ((*m_MediaType->FormatType() == FORMAT_VideoInfo2) &&
            (Video2Range->DataRange.Specifier == 
                KSDATAFORMAT_SPECIFIER_VIDEOINFO2)) { 
                
            KS_VIDEOINFOHEADER2         *VideoInfoHeader2;
            KS_BITMAPINFOHEADER         *BitmapInfoHeader;
            KS_VIDEO_STREAM_CONFIG_CAPS *ConfigCaps;

            //
            // Verify that the data range size is correct
            //   
            
            if ((Video2Range->DataRange.FormatSize < sizeof( KS_DATARANGE_VIDEO2 )) ||
                m_MediaType->FormatLength() < sizeof( VIDEOINFOHEADER )) {
                continue;
            }
            
            VideoInfoHeader2 = (KS_VIDEOINFOHEADER2*) m_MediaType->Format();
            BitmapInfoHeader = &VideoInfoHeader2->bmiHeader;
            ConfigCaps = &Video2Range->ConfigCaps;
            RECT rcDest;
            int Width, Height;

            // The destination bitmap size is defined by biWidth and biHeight
            // if rcTarget is NULL.  Otherwise, the destination bitmap size
            // is defined by rcTarget.  In the latter case, biWidth may
            // indicate the "stride" for DD surfaces.

            if (IsRectEmpty (&VideoInfoHeader2->rcTarget)) {
                SetRect (&rcDest, 0, 0, 
                    BitmapInfoHeader->biWidth, abs(BitmapInfoHeader->biHeight)); 
            }
            else {
                rcDest = VideoInfoHeader2->rcTarget;
            }

            //
            // Check the validity of the cropping rectangle, rcSource
            //

            if (!IsRectEmpty (&VideoInfoHeader2->rcSource)) {

                Width  = VideoInfoHeader2->rcSource.right - VideoInfoHeader2->rcSource.left;
                Height = VideoInfoHeader2->rcSource.bottom - VideoInfoHeader2->rcSource.top;

                if (Width  < ConfigCaps->MinCroppingSize.cx ||
                    Width  > ConfigCaps->MaxCroppingSize.cx ||
                    Height < ConfigCaps->MinCroppingSize.cy ||
                    Height > ConfigCaps->MaxCroppingSize.cy) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVideo2DataTypeHandler, CROPPING SIZE FAILED")));
                    continue;
                }

                if ((ConfigCaps->CropGranularityX != 0) &&
                    (ConfigCaps->CropGranularityY != 0) &&
                    ((Width  % ConfigCaps->CropGranularityX) ||
                     (Height % ConfigCaps->CropGranularityY) )) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVideo2DataTypeHandler, CROPPING SIZE GRANULARITY FAILED")));
                    continue;
                }

                if ((ConfigCaps->CropAlignX != 0) &&
                    (ConfigCaps->CropAlignY != 0) &&
                    (VideoInfoHeader2->rcSource.left  % ConfigCaps->CropAlignX) ||
                    (VideoInfoHeader2->rcSource.top   % ConfigCaps->CropAlignY) ) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVideo2DataTypeHandler, CROPPING ALIGNMENT FAILED")));
                    
                    continue;
                }
            }

            //
            // Check the destination size, rcDest
            //

            Width  = rcDest.right - rcDest.left;
            Height = abs (rcDest.bottom - rcDest.top);

            if (Width  < ConfigCaps->MinOutputSize.cx ||
                Width  > ConfigCaps->MaxOutputSize.cx ||
                Height < ConfigCaps->MinOutputSize.cy ||
                Height > ConfigCaps->MaxOutputSize.cy) {

                DbgLog((LOG_TRACE, 0, TEXT("CVideo2DataTypeHandler, DEST SIZE FAILED")));
                continue;
            }
            if ((ConfigCaps->OutputGranularityX != 0) &&
                (ConfigCaps->OutputGranularityX != 0) &&
                (Width  % ConfigCaps->OutputGranularityX) ||
                (Height % ConfigCaps->OutputGranularityY) ) {

                DbgLog((LOG_TRACE, 0, TEXT("CVideo2DataTypeHandler, DEST GRANULARITY FAILED")));
                continue;
            }

#ifdef IT_BREAKS_TO_MANY_THINGS_TO_VERIFY_FRAMERATE
            //
            // Check the framerate, AvgTimePerFrame
            //

            if (VideoInfoHeader2->AvgTimePerFrame < ConfigCaps->MinFrameInterval ||
                VideoInfoHeader2->AvgTimePerFrame > ConfigCaps->MaxFrameInterval) {

                DbgLog((LOG_TRACE, 0, TEXT("CVideo2DataTypeHandler, AVGTIMEPERFRAME FAILED")));
                continue;
            }
#endif            
           
            //
            // We have found a match.
            //
            
            return S_OK;
            
        }
        else {
            //
            // We always match on the wildcard specifier.
            //

            return S_OK;
        }

    }
    
    return VFW_E_INVALIDMEDIATYPE;
}

STDMETHODIMP 
CVideo2DataTypeHandler::KsQueryExtendedSize( 
    OUT ULONG* ExtendedSize
)

/*++

Routine Description:
    Returns the extended size for each stream header. 
    
    In the default case for major type == KSDATAFORMAT_TYPE_VIDEO2, 
    the extended size is KS_FRAME_INFO.

Arguments:
    OUT ULONG* ExtendedSize -
        pointer to receive the extended size.

Return:
    S_OK

--*/

{
    *ExtendedSize = sizeof (KS_FRAME_INFO);
    return S_OK;
}
    

STDMETHODIMP 
CVideo2DataTypeHandler::KsSetMediaType(
    const AM_MEDIA_TYPE *AmMediaType
    )

/*++

Routine Description:
    Sets the media type for this instance of the data handler.

Arguments:
    const AM_MEDIA_TYPE *AmMediaType -
        pointer to the media type

Return:
    S_OK

--*/

{
    if (m_MediaType) {
        return E_FAIL;
    }
    if (m_MediaType = new CMediaType( *AmMediaType )) {
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}


STDMETHODIMP
CVideo2DataTypeHandler::KsCompleteMediaType(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    AM_MEDIA_TYPE* AmMediaType
    )

/*++

Routine Description:
    Calls upon the driver to do a DataIntersection to get the biSizeImage parameter

Arguments:
    FilterHandle - Handle to the parent filter
    PinFactoryId - Index of the pin we're talking about
   AmMediaType -   pointer to the media type

Return:
    S_OK if the MediaType is valid.

--*/
{
    return CompleteDataFormat(
            FilterHandle,
            PinFactoryId,
            (CMediaType*) AmMediaType
    );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatav1.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksdataV1.cpp

Abstract:

    This module implements the IKsDataTypeHandler interface for 
    VIDEOINFOHEADER CMediaType format (Specifier) types.

Author:

    Jay Borseth (jaybo) 30-May-1997

--*/

#include "pch.h"
#include "wdmcap.h"
#include "ksdatav1.h"


CUnknown*
CALLBACK
CVideo1DataTypeHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of a
    data type handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( LOG_TRACE, 1, TEXT("CVideo1DataTypeHandler::CreateInstance()")));

    Unknown = 
        new CVideo1DataTypeHandler( 
                UnkOuter, 
                NAME("Video1 Data Type Handler"), 
                FORMAT_VideoInfo,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVideo1DataTypeHandler::CVideo1DataTypeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown(Name, UnkOuter, hr),
    m_ClsID(ClsID),
    m_MediaType(NULL),
    m_PinUnknown (UnkOuter),
    m_fDammitOVMixerUseMyBufferCount (FALSE),
    m_fCheckedIfDammitOVMixerUseMyBufferCount (FALSE)
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
//    ASSERT (m_PinUnknown);
} 


CVideo1DataTypeHandler::~CVideo1DataTypeHandler()
{
    if (m_MediaType) {
        delete m_MediaType;
    }
}


STDMETHODIMP
CVideo1DataTypeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsDataTypeHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IKsDataTypeHandler)) {
        return GetInterface(static_cast<IKsDataTypeHandler*>(this), ppv);
    }
    else if (riid ==  __uuidof(IKsDataTypeCompletion)) {
        return GetInterface(static_cast<IKsDataTypeCompletion*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP 
CVideo1DataTypeHandler::KsCompleteIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation, 
    IN BOOL Cancelled
    )

/*++

Routine Description:
    Clean up the extended header and complete I/O operation.
    
Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation
    
    IN BOOL Cancelled
        Set if the I/O operation was cancelled.

Return:
    S_OK

--*/

{
    HRESULT                     hr;
    IMediaSample2               *Sample2;
    AM_SAMPLE2_PROPERTIES       SampleProperties;
    PKS_FRAME_INFO              pFrameInfo;

    DbgLog(( LOG_TRACE, 5, TEXT("CVideo1DataTypeHandler::KsCompleteIoOperation")));
    
    pFrameInfo = (PKS_FRAME_INFO) ((KSSTREAM_HEADER *) StreamHeader + 1);

    // Verify we're getting back the sizeof extended header
    KASSERT (pFrameInfo->ExtendedHeaderSize == sizeof (KS_FRAME_INFO));

    if (IoOperation == KsIoOperation_Read) {

        LONGLONG NextFrame = pFrameInfo->PictureNumber + 1;

        // Get the frame number and put it into the MediaTime
        Sample->SetMediaTime (&pFrameInfo->PictureNumber, 
                              &NextFrame);

        DbgLog((LOG_TRACE, 3, TEXT("PictureNumber = %ld"), 
            pFrameInfo->PictureNumber));

        // Copy over the field polarity and IBP flags on a write

        if (pFrameInfo->dwFrameFlags) {

            if (SUCCEEDED( Sample->QueryInterface(
                                __uuidof(IMediaSample2),
                                reinterpret_cast<PVOID*>(&Sample2) ) )) {

                hr = Sample2->GetProperties(
                                sizeof( SampleProperties ), 
                                reinterpret_cast<PBYTE> (&SampleProperties) );

                //
                // Modify the field polarity and IBP flags
                //

                SampleProperties.dwTypeSpecificFlags = pFrameInfo->dwFrameFlags;

                hr = Sample2->SetProperties(
                                sizeof( SampleProperties ), 
                                reinterpret_cast<PBYTE> (&SampleProperties) );

                Sample2->Release();
            }
            else {
                DbgLog(( LOG_ERROR, 0, TEXT("CVideo1DataTypeHandler::KsCompleteIoOperation, QI IMediaSample2 FAILED")));
            }

        }  // endif (pFrameInfo->dwFrameFlags)


        if (IoOperation == KsIoOperation_Read) {
            IDirectDrawMediaSample          *DDMediaSample = NULL;
            IDirectDrawSurface              *DDSurface = NULL;
            IDirectDrawSurfaceKernel        *DDSurfaceKernel = NULL;
            RECT                             DDRect;

            // 
            // Post Win98 path
            //
            if (m_fDammitOVMixerUseMyBufferCount 
                && pFrameInfo->hDirectDraw
                && pFrameInfo->hSurfaceHandle) {
    
                // Verify the pin is valid
                if (!m_PinUnknown) {
                    DbgLog((LOG_ERROR,0,TEXT("m_PinUnknown is NULL")));
                    goto CleanUp;
                }
        
                // Get DDMediaSample
                hr = Sample->QueryInterface(__uuidof(IDirectDrawMediaSample),
                                    reinterpret_cast<PVOID*>(&DDMediaSample) );
                if (FAILED(hr)) {
                    DbgLog((LOG_TRACE,5,TEXT("QueryInterface for IDirectDrawMediaSample failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
    
                // hack alert!  We originally unlocked the surface when sending it down to the 
                // kernel driver.  Now we relock and then unlock again just to get the 
                // IDirectDrawSurface
    
                hr = DDMediaSample->LockMediaSamplePointer ();
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("LockMediaSamplePointer failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
    
                // Get the surface and unlock it AGAIN
                // Note that DDSurface is NOT AddRef'd by this call !!!
                hr = DDMediaSample->GetSurfaceAndReleaseLock( 
                                        &DDSurface,
                                        &DDRect);
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("GetSurfaceAndReleaseLock failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
        
                // Get IDirectDrawSurfaceKernel
                hr = DDSurface->QueryInterface(IID_IDirectDrawSurfaceKernel,
                                    reinterpret_cast<PVOID*>(&DDSurfaceKernel) );
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("IDirectDrawSurfaceKernel failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
        
                // Release the Kernel Handle
                hr = DDSurfaceKernel->ReleaseKernelHandle ();
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("ReleaseKernelHandle failed, hr = 0x%x"), hr));
                    goto CleanUp;
                }
            }
            else {
                //
                // In Win98, no cleanup was done!!!
                //

            }


    CleanUp:
            if (DDMediaSample) {
                DDMediaSample->Release();
            }
    
            if (DDSurfaceKernel) {
                DDSurfaceKernel->Release();
            }
        }
    }
    
    return S_OK;
}

STDMETHODIMP 
CVideo1DataTypeHandler::KsPrepareIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation
    )

/*++

Routine Description:
    Intialize the extended header and prepare sample for I/O operation.
    
Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation

Return:
    S_OK

--*/

{
    HRESULT                     hr;
    IMediaSample2               *Sample2;
    AM_SAMPLE2_PROPERTIES       SampleProperties;
    PKS_FRAME_INFO              pFrameInfo;

    DbgLog(( LOG_TRACE, 5, TEXT("CVideo1DataTypeHandler::KsPrepareIoOperation")));

    pFrameInfo = (PKS_FRAME_INFO) ((KSSTREAM_HEADER *) StreamHeader + 1);
    pFrameInfo->ExtendedHeaderSize = sizeof (KS_FRAME_INFO);

    if (IoOperation == KsIoOperation_Write) {
        //
        // Copy over the field polarity and IBP flags on a write
        //
        if (SUCCEEDED( Sample->QueryInterface(
                        __uuidof(IMediaSample2),
                        reinterpret_cast<PVOID*>(&Sample2) ) )) {
            hr = Sample2->GetProperties(
                        sizeof( SampleProperties ), 
                        reinterpret_cast<PBYTE> (&SampleProperties) );
            Sample2->Release();
            pFrameInfo->dwFrameFlags = SampleProperties.dwTypeSpecificFlags;
        }
        else {
            DbgLog(( LOG_ERROR, 0, TEXT("CVideo1DataTypeHandler::KsPrepareIoOperation, QI IMediaSample2 FAILED")));
        }
        return S_OK;
    }

    if (IoOperation == KsIoOperation_Read) {

        // The extended header is presumed to be zeroed out!

        // When using the OverlayMixer, we need to get the user mode
        // handles to DirectDraw and to the surface, unlock the surface
        // and stuff the handles into the extended header

        // Note that the surface handle is left unlocked, but the DD handle is released

        IDirectDrawMediaSample          *DDMediaSample = NULL;
        IDirectDrawSurface              *DDSurface = NULL;
        IDirectDrawSurfaceKernel        *DDSurfaceKernel = NULL;
        HANDLE                           DDSurfaceKernelHandle;
        IDirectDrawMediaSampleAllocator *DDMediaSampleAllocator = NULL;
        IDirectDraw                     *DD = NULL;
        IDirectDrawKernel               *DDKernel = NULL;
        HANDLE                           DDKernelHandle;
        RECT                             DDRect;
        IKsPin                          *KsPin = NULL;
        IMemAllocator                   *MemAllocator = NULL;          

        // Verify the pin is valid
        if (!m_PinUnknown) {
            DbgLog((LOG_ERROR,0,TEXT("m_PinUnknown is NULL")));
            goto CleanUp;
        }

        //
        // Step 1, get a whole bunch of garbage, just to get 
        // the DirectDrawKernel handle.  If the display driver
        // doesn't support Overlay flipping in the kernel, then bail.
        //

        // Get IKsPin
        hr = m_PinUnknown->QueryInterface(__uuidof(IKsPin),
                            reinterpret_cast<PVOID*>(&KsPin) );
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR,0,TEXT("IKsPin failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        //
        // If the pin doesn't support the 
        // "I really want to use the number of buffers I request" property
        // then follow the new code path, else use the Win98 gold version
        //
        if (!m_fCheckedIfDammitOVMixerUseMyBufferCount) {
            IKsPropertySet *KsPropertySet;
            DWORD           dwBytesReturned;

            m_fCheckedIfDammitOVMixerUseMyBufferCount = TRUE;

            hr = KsPin->QueryInterface(__uuidof(IKsPropertySet),
                                reinterpret_cast<PVOID*>(&KsPropertySet) );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IKsPropertySet failed, hr = 0x%x"), hr));
                goto CleanUp;
            }

            hr = KsPropertySet->Get (PROPSETID_ALLOCATOR_CONTROL,
                                KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,
                                NULL,                               // LPVOID pInstanceData,
                                0,                                  // DWORD cbInstanceData,
                                &m_fDammitOVMixerUseMyBufferCount,    // LPVOID pPropData,
                                sizeof (m_fDammitOVMixerUseMyBufferCount),
                                &dwBytesReturned);

            KsPropertySet->Release();

            if (m_fDammitOVMixerUseMyBufferCount) {
                DbgLog((LOG_TRACE,1,TEXT("Stream Supports PROPSETID_ALLOCATOR_CONTROL, KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT for OVMixer")));
            }
        }

        //
        // The Post Win98 path, if driver supports kernel flipping explicitely
        //
        if (m_fDammitOVMixerUseMyBufferCount) {

            // Get the allocator but don't AddRef
            MemAllocator = KsPin->KsPeekAllocator (KsPeekOperation_PeekOnly);
    
            if (!MemAllocator) {
                DbgLog((LOG_ERROR,0,TEXT("MemAllocator is NULL, hr = 0x%x"), hr));
                goto CleanUp;
            }
            
            // Get the SampleAllocator
            hr = MemAllocator->QueryInterface(__uuidof(IDirectDrawMediaSampleAllocator),
                            reinterpret_cast<PVOID*>(&DDMediaSampleAllocator) );
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDrawMediaSampleAllocator failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get IDirectDraw
            // Note that IDirectDraw is NOT Addref'd by this call!!!
            hr = DDMediaSampleAllocator->GetDirectDraw(&DD);
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDraw failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get IDirectDrawKernel
            hr = DD->QueryInterface(IID_IDirectDrawKernel,
                            reinterpret_cast<PVOID*>(&DDKernel) );
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDrawKernel failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Verify that kernel flip is available
            DDKERNELCAPS KCaps;
            KCaps.dwSize = sizeof (DDKERNELCAPS);
            hr = DDKernel->GetCaps (&KCaps);
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetCaps failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            if (!(KCaps.dwCaps & DDKERNELCAPS_FLIPOVERLAY)) {
                DbgLog((LOG_ERROR,0,TEXT("GetCaps failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // to get DDKernelHandle
            hr = DDKernel->GetKernelHandle ((ULONG_PTR*) &DDKernelHandle);
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetKernelHandle failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            // Release the handle immediately
            hr = DDKernel->ReleaseKernelHandle ();  
            if (FAILED (hr)) {
                DbgLog((LOG_ERROR,0,TEXT("ReleaseKernelHandle failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            //
            // Step 2, get a whole bunch of garbage, just to get 
            // the DirectDrawSurfaceKernel handle.
            //
    
            // Get DDMediaSample
            hr = Sample->QueryInterface(__uuidof(IDirectDrawMediaSample),
                                reinterpret_cast<PVOID*>(&DDMediaSample) );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("QueryInterface for IDirectDrawMediaSample failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get the surface and unlock it
            // Note that DDSurface is NOT AddRef'd by this call !!!
            // We keep the sample unlocked until the sample is returned, since a locked sample takes
            // the Win16 Lock
            hr = DDMediaSample->GetSurfaceAndReleaseLock( 
                                    &DDSurface,
                                    &DDRect);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetSurfaceAndReleaseLock failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get IDirectDrawSurfaceKernel
            hr = DDSurface->QueryInterface(IID_IDirectDrawSurfaceKernel,
                                reinterpret_cast<PVOID*>(&DDSurfaceKernel) );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("IDirectDrawSurfaceKernel failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
    
            // Get the Kernel Handle
            hr = DDSurfaceKernel->GetKernelHandle ((ULONG_PTR*) &DDSurfaceKernelHandle);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,0,TEXT("GetKernelHandle failed, hr = 0x%x"), hr));
                goto CleanUp;
            }

            //
            // The point of it all, stuff the handles into the sample extended header
            // so the driver can do a kernel flip
            //
            pFrameInfo->DirectDrawRect = DDRect;
            pFrameInfo->hDirectDraw = DDKernelHandle;
            pFrameInfo->hSurfaceHandle = DDSurfaceKernelHandle;
    
        }
        //
        // Else, do exactly what was done in Win98
        //
        else {
                      // First unlock the sample and get the surface handle
            if (SUCCEEDED( Sample->QueryInterface(
                                __uuidof(IDirectDrawMediaSample),
                                reinterpret_cast<PVOID*>(&DDMediaSample) ))) {

                hr = DDMediaSample->GetSurfaceAndReleaseLock( 
                                &DDSurface,
                                &DDRect);

                ASSERT (SUCCEEDED (hr));

                pFrameInfo->hSurfaceHandle = (HANDLE) DDSurface;
                pFrameInfo->DirectDrawRect = DDRect;

                // Now get the DDraw handle from the allocator
                if (m_PinUnknown && SUCCEEDED( m_PinUnknown->QueryInterface(
                                    __uuidof(IKsPin),
                                    reinterpret_cast<PVOID*>(&KsPin) ))) {

                    // Get the allocator but don't AddRef
                    MemAllocator = KsPin->KsPeekAllocator (KsPeekOperation_PeekOnly);

                    if (MemAllocator) {

                        if (SUCCEEDED( MemAllocator->QueryInterface(
                                        __uuidof(IDirectDrawMediaSampleAllocator),
                                        reinterpret_cast<PVOID*>(&DDMediaSampleAllocator) ))) {
    
                            hr = DDMediaSampleAllocator->GetDirectDraw(
                                        &DD);
    
                            ASSERT (SUCCEEDED (hr));
    
                            pFrameInfo->hDirectDraw = (HANDLE) DD;
                        }
                        else {
                            ASSERT (FALSE);
                            DbgLog(( LOG_ERROR, 0, TEXT("QI IDirectDrawMediaSampleAllocator FAILED")));
                        }
                    }
                    else {
                        ASSERT (FALSE);
                        DbgLog(( LOG_ERROR, 0, TEXT("Peek Allocator FAILED")));

                    }
                }
                else {
                    ASSERT (FALSE);
                    DbgLog(( LOG_ERROR, 0, TEXT("QI IKSPIN FAILED")));
                }
            }
        }


CleanUp:
        if (DDMediaSample) {
            DDMediaSample->Release();
        }

        if (DDSurfaceKernel) {
            DDSurfaceKernel->Release();
        }

        if (KsPin) {
            KsPin->Release ();
        }

        if (DDMediaSampleAllocator) {
            DDMediaSampleAllocator->Release();
        }

        if (DDKernel) {
            DDKernel->Release();
        }
    }

    return S_OK;
}

STDMETHODIMP 
CVideo1DataTypeHandler::KsIsMediaTypeInRanges(
    IN PVOID DataRanges
)

/*++

Routine Description:
    Validates that the given media type is within the provided data ranges.

Arguments:
    IN PVOID DataRanges -
        pointer to data ranges which is a KSMULTIPLE_ITEM structure followed
        by ((PKSMULTIPLEITEM) DataRanges)->Count data range structures.

Return:
    S_OK if match found, S_FALSE if not found, or an appropriate error code.

--*/

{
    ULONG               u;
    PKS_DATARANGE_VIDEO  Video1Range;
    PKSMULTIPLE_ITEM    MultipleItem;
    
    DbgLog((LOG_TRACE, 1, TEXT("CVideo1DataTypeHandler::KsIsMediaTypeInRanges")));
    
    ASSERT( *m_MediaType->Type() == KSDATAFORMAT_TYPE_VIDEO );
    
    MultipleItem = (PKSMULTIPLE_ITEM) DataRanges;
    
    for (u = 0, Video1Range = (PKS_DATARANGE_VIDEO) (MultipleItem + 1);
         u < MultipleItem->Count; 
         u++, Video1Range = 
                (PKS_DATARANGE_VIDEO)((PBYTE)Video1Range + 
                    ((Video1Range->DataRange.FormatSize + 7) & ~7))) {

        //
        // Only validate those in the range that match the format specifier.
        //
        if (((Video1Range->DataRange.FormatSize < sizeof( KSDATARANGE )) ||
             (Video1Range->DataRange.MajorFormat != KSDATAFORMAT_TYPE_WILDCARD)) &&
            ((Video1Range->DataRange.FormatSize < sizeof( KS_DATARANGE_VIDEO)) ||
             (Video1Range->DataRange.MajorFormat != KSDATAFORMAT_TYPE_VIDEO) )) {
            continue;
        }
        
        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if (((Video1Range->DataRange.SubFormat != *m_MediaType->Subtype()) && 
             (Video1Range->DataRange.SubFormat != KSDATAFORMAT_SUBTYPE_WILDCARD)) || 
            ((Video1Range->DataRange.Specifier != *m_MediaType->FormatType()) &&
             (Video1Range->DataRange.Specifier != KSDATAFORMAT_SPECIFIER_WILDCARD))) {
            continue;
        }

        //
        // Verify that we have an intersection with the specified format
        //
        
        if ((*m_MediaType->FormatType() == FORMAT_VideoInfo) &&
            (Video1Range->DataRange.Specifier == 
                KSDATAFORMAT_SPECIFIER_VIDEOINFO)) { 
                
            VIDEOINFOHEADER             *VideoInfoHeader;
            BITMAPINFOHEADER            *BitmapInfoHeader;
            KS_VIDEO_STREAM_CONFIG_CAPS *ConfigCaps;

            //
            // Verify that the data range size is correct
            //   
            
            if ((Video1Range->DataRange.FormatSize < sizeof( KS_DATARANGE_VIDEO )) ||
                m_MediaType->FormatLength() < sizeof( VIDEOINFOHEADER )) {
                continue;
            }
            
            VideoInfoHeader = (VIDEOINFOHEADER*) m_MediaType->Format();
            BitmapInfoHeader = &VideoInfoHeader->bmiHeader;
            ConfigCaps = &Video1Range->ConfigCaps;
            RECT rcDest;
            int Width, Height;

            // The destination bitmap size is defined by biWidth and biHeight
            // if rcTarget is NULL.  Otherwise, the destination bitmap size
            // is defined by rcTarget.  In the latter case, biWidth may
            // indicate the "stride" for DD surfaces.

            if (IsRectEmpty (&VideoInfoHeader->rcTarget)) {
                SetRect (&rcDest, 0, 0, 
                    BitmapInfoHeader->biWidth, abs (BitmapInfoHeader->biHeight)); 
            }
            else {
                rcDest = VideoInfoHeader->rcTarget;
            }

            //
            // Check the validity of the cropping rectangle, rcSource
            //

            if (!IsRectEmpty (&VideoInfoHeader->rcSource)) {

                Width  = VideoInfoHeader->rcSource.right - VideoInfoHeader->rcSource.left;
                Height = VideoInfoHeader->rcSource.bottom - VideoInfoHeader->rcSource.top;

                if (Width  < ConfigCaps->MinCroppingSize.cx ||
                    Width  > ConfigCaps->MaxCroppingSize.cx ||
                    Height < ConfigCaps->MinCroppingSize.cy ||
                    Height > ConfigCaps->MaxCroppingSize.cy) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVideo1DataTypeHandler, CROPPING SIZE FAILED")));
                    continue;
                }

                if ((ConfigCaps->CropGranularityX != 0) &&
                    (ConfigCaps->CropGranularityY != 0) &&
                    ((Width  % ConfigCaps->CropGranularityX) ||
                     (Height % ConfigCaps->CropGranularityY) )) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVideo1DataTypeHandler, CROPPING SIZE GRANULARITY FAILED")));
                    continue;
                }

                if ((ConfigCaps->CropAlignX != 0) &&
                    (ConfigCaps->CropAlignY != 0) &&
                    (VideoInfoHeader->rcSource.left  % ConfigCaps->CropAlignX) ||
                    (VideoInfoHeader->rcSource.top   % ConfigCaps->CropAlignY) ) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVideo1DataTypeHandler, CROPPING ALIGNMENT FAILED")));
                    
                    continue;
                }
            }

            //
            // Check the destination size, rcDest
            //

            Width  = rcDest.right - rcDest.left;
            Height = abs (rcDest.bottom - rcDest.top);

            if (Width  < ConfigCaps->MinOutputSize.cx ||
                Width  > ConfigCaps->MaxOutputSize.cx ||
                Height < ConfigCaps->MinOutputSize.cy ||
                Height > ConfigCaps->MaxOutputSize.cy) {

                DbgLog((LOG_TRACE, 0, TEXT("CVideo1DataTypeHandler, DEST SIZE FAILED")));
                continue;
            }
            if ((ConfigCaps->OutputGranularityX != 0) &&
                (ConfigCaps->OutputGranularityX != 0) &&
                (Width  % ConfigCaps->OutputGranularityX) ||
                (Height % ConfigCaps->OutputGranularityY) ) {

                DbgLog((LOG_TRACE, 0, TEXT("CVideo1DataTypeHandler, DEST GRANULARITY FAILED")));
                continue;
            }

#ifdef IT_BREAKS_TO_MANY_THINGS_TO_VERIFY_FRAMERATE
            //
            // Check the framerate, AvgTimePerFrame
            //
            if (VideoInfoHeader->AvgTimePerFrame < ConfigCaps->MinFrameInterval ||
                VideoInfoHeader->AvgTimePerFrame > ConfigCaps->MaxFrameInterval) {

                DbgLog((LOG_TRACE, 0, TEXT("CVideo1DataTypeHandler, AVGTIMEPERFRAME FAILED")));
                continue;
            }
#endif
            //
            // We have found a match.
            //
            
            return S_OK;
            
        }
        else {
            //
            // We always match on the wildcard specifier.
            //

            return S_OK;
        }
    }
    
    return VFW_E_INVALIDMEDIATYPE;
}

STDMETHODIMP 
CVideo1DataTypeHandler::KsQueryExtendedSize( 
    OUT ULONG* ExtendedSize
)

/*++

Routine Description:
    Returns the extended size for each stream header. 
    
    In the default case for major type == KSDATAFORMAT_TYPE_VIDEO, 
    the extended size is KS_FRAME_INFO.

Arguments:
    OUT ULONG* ExtendedSize -
        pointer to receive the extended size.

Return:
    S_OK

--*/

{
    *ExtendedSize = sizeof (KS_FRAME_INFO);
    return S_OK;
}
    

STDMETHODIMP 
CVideo1DataTypeHandler::KsSetMediaType(
    const AM_MEDIA_TYPE *AmMediaType
    )

/*++

Routine Description:
    Sets the media type for this instance of the data handler.

Arguments:
    const AM_MEDIA_TYPE *AmMediaType -
        pointer to the media type

Return:
    S_OK

--*/

{
    if (m_MediaType) {
        return E_FAIL;
    }
    if (m_MediaType = new CMediaType( *AmMediaType )) {
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}


STDMETHODIMP
CVideo1DataTypeHandler::KsCompleteMediaType(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    AM_MEDIA_TYPE* AmMediaType
    )

/*++

Routine Description:
    Calls upon the driver to do a DataIntersection to get the biSizeImage parameter

Arguments:
    FilterHandle - Handle to the parent filter
    PinFactoryId - Index of the pin we're talking about
   AmMediaType -   pointer to the media type

Return:
    S_OK if the MediaType is valid.

--*/
{
    return CompleteDataFormat(
            FilterHandle,
            PinFactoryId,
            (CMediaType*) AmMediaType
    );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatavb.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ksdatavb.h
//
//--------------------------------------------------------------------------

#ifndef __KSDATAVB__
#define __KSDATAVB__

class CVBIDataTypeHandler :
    public CUnknown,
    public IKsDataTypeHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsDataTypeHandler
    
    STDMETHODIMP 
    KsCompleteIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation, 
        IN BOOL Cancelled
        );
        
    STDMETHODIMP 
    KsIsMediaTypeInRanges(
        IN PVOID DataRanges
        );
        
    STDMETHODIMP 
    KsPrepareIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation
        );
    
    STDMETHODIMP 
    KsQueryExtendedSize( 
        IN ULONG* ExtendedSize
        );
        
    STDMETHODIMP 
    KsSetMediaType(
        const AM_MEDIA_TYPE *AmMediaType
        );
        
        
private:
    CLSID       m_ClsID;
    CMediaType  *m_MediaType;

    CVBIDataTypeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
        
    ~CVBIDataTypeHandler();
        
};

#endif // __KSDATAVB__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\kseditor.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// kseditor.cpp  KsEditor, edits KS properties backed by
//               1) Trackbar
//               2) Editbox
//               3) Auto checkbox
//                  or any combination of the above 
//

#include "pch.h"
#include "kseditor.h"

// -------------------------------------------------------------------------
// CKSPropertyEditor class
// -------------------------------------------------------------------------

// Handles a single KS property

// Constructor
CKSPropertyEditor::CKSPropertyEditor (
        HWND  hDlg,
        ULONG IDLabel,
        ULONG IDTrackbarControl,
        ULONG IDAutoControl,
        ULONG IDEditControl,
        ULONG IDProperty
    ) 
    : m_hDlg (hDlg)
    , m_hWndTrackbar (NULL)
    , m_hWndEdit (NULL)
    , m_hWndAuto (NULL)
    , m_IDLabel (IDLabel)
    , m_IDTrackbarControl (IDTrackbarControl)
    , m_IDAutoControl (IDAutoControl)
    , m_IDEditControl (IDEditControl)
    , m_IDProperty (IDProperty)
    , m_Active (FALSE)
    , m_CurrentValue (0)
    , m_CurrentFlags (0)
    , m_CanAutoControl (FALSE)
    , m_TrackbarOffset (0)
{
}

// An Init function is necessary since pure virtual functions
// can't be called within the Constructor

BOOL 
CKSPropertyEditor::Init (
    ) 
{
    HRESULT hr;

    if (m_IDLabel) {
        EnableWindow (GetDlgItem (m_hDlg, m_IDLabel), FALSE);
    }
    if (m_IDTrackbarControl) {
        m_hWndTrackbar = GetDlgItem (m_hDlg, m_IDTrackbarControl);
        EnableWindow (m_hWndTrackbar, FALSE);
    }
    if (m_IDAutoControl) {
        m_hWndAuto = GetDlgItem (m_hDlg, m_IDAutoControl);
        EnableWindow (m_hWndAuto, FALSE);
    }
    if (m_IDEditControl) {
        m_hWndEdit = GetDlgItem (m_hDlg, m_IDEditControl);
        EnableWindow (m_hWndEdit, FALSE);
    }

    // Get the current value and any associated flags
    hr = GetValue();
    m_OriginalValue = m_CurrentValue;
    m_OriginalFlags = m_CurrentFlags;

    // Only enable the control if we can read the current value

    m_Active = (SUCCEEDED (hr));

    if (!m_Active) 
        return FALSE;

    // Get the range, stepping, default, and capabilities
    hr = GetRange ();

    if (FAILED (hr)) {
        // Special case, if no trackbar and no edit box, treat the
        // autocheck box as a boolean to control the property
        if (m_hWndTrackbar || m_hWndEdit) {
            DbgLog(( LOG_TRACE, 1, TEXT("KSEditor, GetRangeFailed, ID=%d"), m_IDProperty));
            m_Active = FALSE;
            return FALSE;
        }
    }
    else {
        if (m_CurrentValue > m_Max || m_CurrentValue < m_Min) {
            DbgLog(( LOG_TRACE, 1, TEXT("KSEditor, Illegal initial value ID=%d, value=%d"), 
                    m_IDProperty, m_CurrentValue));
        }
    }

    if (m_hWndTrackbar) {
        EnableWindow (m_hWndTrackbar, TRUE);
        // Trackbars don't handle negative values, so slide everything positive
        if (m_Min < 0)
            m_TrackbarOffset = -m_Min;
        SendMessage(m_hWndTrackbar, TBM_SETRANGE, FALSE, 
            MAKELONG(m_Min + m_TrackbarOffset, m_Max + m_TrackbarOffset) );
        // Check the following
        SendMessage(m_hWndTrackbar, TBM_SETLINESIZE, FALSE, (LPARAM) m_SteppingDelta);
        SendMessage(m_hWndTrackbar, TBM_SETPAGESIZE, FALSE, (LPARAM) m_SteppingDelta);
//        SendMessage(m_hWndTrackbar, TBM_SETAUTOTICS, TRUE,  (LPARAM) 

        UpdateTrackbar ();
    }

    if (m_hWndEdit) {
        UpdateEditBox ();
        EnableWindow (m_hWndEdit, TRUE);
    }

    if (m_hWndAuto) {
        // if the control has an auto setting, enable the auto checkbox
        m_CanAutoControl = CanAutoControl();
        EnableWindow (m_hWndAuto, m_CanAutoControl);
        if (m_CanAutoControl) {
            Button_SetCheck (m_hWndAuto, GetAuto ());
        }
    }

    if (m_IDLabel) {
        EnableWindow (GetDlgItem (m_hDlg, m_IDLabel), TRUE);
    }

    return TRUE;
}

// destructor
CKSPropertyEditor::~CKSPropertyEditor (
    )
{
}

BOOL
CKSPropertyEditor::OnApply (
    )
{
    m_OriginalValue = m_CurrentValue;
    m_OriginalFlags = m_CurrentFlags;

    return TRUE;
}

BOOL
CKSPropertyEditor::OnDefault (
    )
{
    HRESULT hr;

    if (!m_Active)
        return FALSE;

    m_CurrentValue = m_OriginalValue = m_DefaultValue;
    m_CurrentFlags = m_OriginalFlags;

    hr = SetValue ();

    UpdateEditBox ();
    UpdateTrackbar ();
    UpdateAuto ();

    return TRUE;
}



BOOL
CKSPropertyEditor::OnScroll (
    ULONG nCommand, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HRESULT hr;
    int pos;
    int command = LOWORD (wParam);

    if (command != TB_ENDTRACK &&
        command != TB_THUMBTRACK &&
        command != TB_LINEDOWN &&
        command != TB_LINEUP &&
        command != TB_PAGEUP &&
        command != TB_PAGEDOWN)
            return FALSE;

    ASSERT (IsWindow ((HWND) lParam));
        
    if (!m_Active)
        return FALSE;

    pos = (int) SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L);

    m_CurrentValue = pos - m_TrackbarOffset;

    hr = SetValue();
    UpdateEditBox ();
    
    return TRUE;
}

BOOL
CKSPropertyEditor::OnEdit (
    ULONG nCommand, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    // TODO
    // look for EN_
    

    UpdateTrackbar ();

    return TRUE;
}


BOOL
CKSPropertyEditor::OnAuto (
    ULONG nCommand, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    SetAuto (Button_GetCheck (m_hWndAuto));

    return TRUE;
}


BOOL
CKSPropertyEditor::OnCancel (
    )
{
    m_CurrentValue = m_OriginalValue;
    m_CurrentFlags = m_OriginalFlags;

    SetValue ();

    return TRUE;
}

BOOL
CKSPropertyEditor::UpdateEditBox (
    )
{
    if (m_hWndEdit) {
        SetDlgItemInt (m_hDlg, m_IDEditControl, m_CurrentValue, TRUE);
    }
  
    return TRUE;
}


BOOL
CKSPropertyEditor::UpdateTrackbar (
    )
{
    if (m_hWndTrackbar) {
        SendMessage(m_hWndTrackbar, TBM_SETPOS, TRUE, 
            (LPARAM) m_CurrentValue + m_TrackbarOffset);
    }
    return TRUE;
}

BOOL
CKSPropertyEditor::UpdateAuto (
    )
{
    if (m_hWndAuto) {
        if (CanAutoControl() ) {
            m_CanAutoControl = GetAuto ();
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pch.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    pch.h

Abstract:

    Precompiled header for kswdmcap.ax
    
--*/

// Windows
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <memory.h>
#include <stdio.h>

#include <winioctl.h>
#include <basetsd.h>

// DShow
#include <streams.h>
#include <amstream.h>
#include <dvdmedia.h>

// DDraw
#include <ddraw.h>
#include <ddkernel.h>

// KS
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#ifndef FILE_DEVICE_KS
#define FILE_DEVICE_KS 0x0000002f  // This is not in Win98's winioctl.h
#endif

#if DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\ksdatavb.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksdataVB.cpp

Abstract:

    This module implements the IKsDataTypeHandler interface for 
    FORMAT_VBI (KSDATAFORMAT_SPECIFIER_VBI) CMediaType.

Author:

    Jay Borseth (jaybo) 30-May-1997

--*/

#include "pch.h"
#include "ksdatavb.h"


CUnknown*
CALLBACK
CVBIDataTypeHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of a
    data type handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( LOG_TRACE, 1, TEXT("CVBIDataTypeHandler::CreateInstance()")));

    Unknown = 
        new CVBIDataTypeHandler( 
                UnkOuter, 
                NAME("VBI Data Type Handler"), 
                KSDATAFORMAT_SPECIFIER_VBI,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVBIDataTypeHandler::CVBIDataTypeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown(Name, UnkOuter, hr),
    m_ClsID(ClsID),
    m_MediaType(NULL)
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
} 


CVBIDataTypeHandler::~CVBIDataTypeHandler()
{
    if (m_MediaType) {
        delete m_MediaType;
    }
}


STDMETHODIMP
CVBIDataTypeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsDataTypeHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IKsDataTypeHandler)) {
        return GetInterface(static_cast<IKsDataTypeHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP 
CVBIDataTypeHandler::KsCompleteIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation, 
    IN BOOL Cancelled
    )

/*++

Routine Description:
    Clean up the extended header and complete I/O operation.
    
Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation
    
    IN BOOL Cancelled
        Set if the I/O operation was cancelled.

Return:
    S_OK

--*/

{
    HRESULT                     hr;
    IMediaSample2               *Sample2;
    AM_SAMPLE2_PROPERTIES       SampleProperties;
    PKS_VBI_FRAME_INFO          pFrameInfo;

    DbgLog(( LOG_TRACE, 5, TEXT("CVBIDataTypeHandler::KsCompleteIoOperation")));

    pFrameInfo = (PKS_VBI_FRAME_INFO) ((KSSTREAM_HEADER *) StreamHeader + 1);

    // Verify we're getting back the sizeof extended header
    KASSERT (pFrameInfo->ExtendedHeaderSize == sizeof (KS_VBI_FRAME_INFO));

    if (IoOperation == KsIoOperation_Read) {

        // Get the frame number and put it into the MediaTime
        Sample->SetMediaTime (&pFrameInfo->PictureNumber, 
                              &pFrameInfo->PictureNumber);

        DbgLog((LOG_TRACE, 3, TEXT("PictureNumber = %ld"), 
            pFrameInfo->PictureNumber));

        // Copy over the field polarity and IBP flags on a write

        if (pFrameInfo->dwFrameFlags) {

            if (SUCCEEDED( Sample->QueryInterface(
                                __uuidof(IMediaSample2),
                                reinterpret_cast<PVOID*>(&Sample2) ) )) {

                hr = Sample2->GetProperties(
                                sizeof( SampleProperties ), 
                                reinterpret_cast<PBYTE> (&SampleProperties) );

                //
                // Modify the field polarity and IBP flags
                //

                SampleProperties.dwTypeSpecificFlags = pFrameInfo->dwFrameFlags;

                hr = Sample2->SetProperties(
                                sizeof( SampleProperties ), 
                                reinterpret_cast<PBYTE> (&SampleProperties) );

                Sample2->Release();
            }
            else {
                DbgLog(( LOG_ERROR, 0, TEXT("CVideo1DataTypeHandler::KsPrepareIoOperation, QI IMediaSample2 FAILED")));
            }

        }  // endif (pFrameInfo->dwFrameFlags)
       
    }
    else {
        // Nothing to do when completing a write
    }
    
    return S_OK;
}

STDMETHODIMP 
CVBIDataTypeHandler::KsPrepareIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation
    )

/*++

Routine Description:
    Intialize the extended header and prepare sample for I/O operation.
    
    In the default case for major type == KSDATAFORMAT_TYPE_VBI, there
    is no work to do, just return S_OK.

Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation

Return:
    S_OK

--*/

{
    HRESULT                     hr;
    IMediaSample2               *Sample2;
    AM_SAMPLE2_PROPERTIES       SampleProperties;
    PKS_VBI_FRAME_INFO          pVBIFrameInfo;

    DbgLog(( LOG_TRACE, 5, TEXT("CVBIDataTypeHandler::KsPrepareIoOperation")));


    pVBIFrameInfo = (PKS_VBI_FRAME_INFO) ((KSSTREAM_HEADER *) StreamHeader + 1);
    pVBIFrameInfo->ExtendedHeaderSize = sizeof (KS_VBI_FRAME_INFO);

    if (IoOperation == KsIoOperation_Read) {
        // Nothing to do, the stream header is already zeroed out
    }
    else {
        //
        // Copy over the field polarity and IBP flags on a write
        //
        if (SUCCEEDED( Sample->QueryInterface(
                        __uuidof(IMediaSample2),
                        reinterpret_cast<PVOID*>(&Sample2) ) )) {
            hr = Sample2->GetProperties(
                        sizeof( SampleProperties ), 
                        reinterpret_cast<PBYTE> (&SampleProperties) );
            Sample2->Release();
            pVBIFrameInfo->dwFrameFlags = SampleProperties.dwTypeSpecificFlags;
        }
        else {
            DbgLog(( LOG_ERROR, 0, TEXT("CVBIDataTypeHandler::KsPrepareIoOperation, QI IMediaSample2 FAILED")));
        }
    }
    return S_OK;
}

STDMETHODIMP 
CVBIDataTypeHandler::KsIsMediaTypeInRanges(
    IN PVOID DataRanges
)

/*++

Routine Description:
    Validates that the given media type is within the provided data ranges.

Arguments:
    IN PVOID DataRanges -
        pointer to data ranges which is a KSMULTIPLE_ITEM structure followed
        by ((PKSMULTIPLEITEM) DataRanges)->Count data range structures.

Return:
    S_OK if match found, S_FALSE if not found, or an appropriate error code.

--*/

{
    ULONG                   u;
    PKS_DATARANGE_VIDEO_VBI VBIRange;
    PKSMULTIPLE_ITEM        MultipleItem;
    
    DbgLog((LOG_TRACE, 3, TEXT("CVBIDataTypeHandler::KsIsMediaTypeInRanges")));
    
    ASSERT( *m_MediaType->Type() == KSDATAFORMAT_TYPE_VBI );
    
    MultipleItem = (PKSMULTIPLE_ITEM) DataRanges;
    
    for (u = 0, VBIRange = (PKS_DATARANGE_VIDEO_VBI) (MultipleItem + 1);
            u < MultipleItem->Count; 
            u++, 
            VBIRange = (PKS_DATARANGE_VIDEO_VBI)((PBYTE)VBIRange + 
                       ((VBIRange->DataRange.FormatSize + 7) & ~7))) {
    
        //
        // Only validate those in the range that match the format specifier.
        //
        if (((VBIRange->DataRange.FormatSize < sizeof( KSDATARANGE )) ||
             (VBIRange->DataRange.MajorFormat != KSDATAFORMAT_TYPE_WILDCARD)) &&
            ((VBIRange->DataRange.FormatSize < sizeof( KS_DATARANGE_VIDEO_VBI)) ||
             (VBIRange->DataRange.MajorFormat != KSDATAFORMAT_TYPE_VBI) )) {
            continue;
        }
        
        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if (((VBIRange->DataRange.SubFormat != *m_MediaType->Subtype()) && 
             (VBIRange->DataRange.SubFormat != KSDATAFORMAT_SUBTYPE_WILDCARD)) || 
            ((VBIRange->DataRange.Specifier != *m_MediaType->FormatType()) &&
             (VBIRange->DataRange.Specifier != KSDATAFORMAT_SPECIFIER_WILDCARD))) {
            continue;
        }
        //
        // Verify that we have an intersection with the specified format
        //
        
        if (*m_MediaType->FormatType() == KSDATAFORMAT_SPECIFIER_VBI) {

#if 0
// TODO
                
            VBIINFOHEADER             *VBIInfoHeader;
            VBIINFOHEADER            *VBIInfoHeader;
            KS_VIDEO_STREAM_CONFIG_CAPS *ConfigCaps;

            //
            // Verify that the data range size is correct
            //   
            
            if ((VBIRange->DataRange.FormatSize != sizeof( KS_DATARANGE_VIDEO_VBI )) ||
                m_MediaType->FormatLength() < sizeof( VBIINFOHEADER )) {
                continue;
            }
            
            VBIInfoHeader = (VBIINFOHEADER*) m_MediaType->Format();
            VBIInfoHeader = &VBIInfoHeader->bmiHeader;
            ConfigCaps = &VBIRange->ConfigCaps;
            RECT rcDest;
            int Width, Height;

            // The destination bitmap size is defined by biWidth and biHeight
            // if rcTarget is NULL.  Otherwise, the destination bitmap size
            // is defined by rcTarget.  In the latter case, biWidth may
            // indicate the "stride" for DD surfaces.

            if (IsRectEmpty (&VBIInfoHeader->rcTarget)) {
                SetRect (&rcDest, 0, 0, 
                    VBIInfoHeader->biWidth, VBIInfoHeader->biHeight); 
            }
            else {
                rcDest = VBIInfoHeader->rcTarget;
            }

            //
            // Check the validity of the cropping rectangle, rcSource
            //

            if (!IsRectEmpty (&VBIInfoHeader->rcSource)) {

                Width  = VBIInfoHeader->rcSource.right - VBIInfoHeader->rcSource.left;
                Height = VBIInfoHeader->rcSource.bottom - VBIInfoHeader->rcSource.top;

                if (Width  < ConfigCaps->MinCroppingSize.cx ||
                    Width  > ConfigCaps->MaxCroppingSize.cx ||
                    Height < ConfigCaps->MinCroppingSize.cy ||
                    Height > ConfigCaps->MaxCroppingSize.cy) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVBIDataTypeHandler, CROPPING SIZE FAILED")));
                    continue;
                }

                if (Width  % ConfigCaps->CropGranularityX ||
                    Height % ConfigCaps->CropGranularityY ) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVBIDataTypeHandler, CROPPING SIZE GRANULARITY FAILED")));
                    continue;
                }

                if (VBIInfoHeader->rcSource.left  % ConfigCaps->CropAlignX ||
                    VBIInfoHeader->rcSource.top   % ConfigCaps->CropAlignY ) {

                    DbgLog((LOG_TRACE, 0, TEXT("CVBIDataTypeHandler, CROPPING ALIGNMENT FAILED")));
                    
                    continue;
                }
            }

            //
            // Check the destination size, rcDest
            //

            Width  = rcDest.right - rcDest.left;
            Height = rcDest.bottom - rcDest.top;

            if (Width  < ConfigCaps->MinOutputSize.cx ||
                Width  > ConfigCaps->MaxOutputSize.cx ||
                Height < ConfigCaps->MinOutputSize.cy ||
                Height > ConfigCaps->MaxOutputSize.cy) {

                DbgLog((LOG_TRACE, 0, TEXT("CVBIDataTypeHandler, DEST SIZE FAILED")));
                continue;
            }
            if (Width  % ConfigCaps->OutputGranularityX ||
                Height % ConfigCaps->OutputGranularityY ) {

                DbgLog((LOG_TRACE, 0, TEXT("CVBIDataTypeHandler, DEST GRANULARITY FAILED")));
                continue;
            }

            //
            // Check the framerate, AvgTimePerFrame
            //

            if (VBIInfoHeader->AvgTimePerFrame < ConfigCaps->MinFrameInterval ||
                VBIInfoHeader->AvgTimePerFrame > ConfigCaps->MaxFrameInterval) {

                DbgLog((LOG_TRACE, 0, TEXT("CVBIDataTypeHandler, AVGTIMEPERFRAME FAILED")));
                continue;
            }
#endif //TODO            
           
            //
            // We have found a match.
            //
            
            return S_OK;
            
        }
        else {
            //
            // We always match on the wildcard specifier.
            //

            return S_OK;
        }
    }
    
    return VFW_E_INVALIDMEDIATYPE;
}

STDMETHODIMP 
CVBIDataTypeHandler::KsQueryExtendedSize( 
    OUT ULONG* ExtendedSize
)

/*++

Routine Description:
    Returns the extended size for each stream header. 
    
    In the default case for major type == KSDATAFORMAT_TYPE_VBI, 
    the extended size is KS_VBI_FRAME_INFO.

Arguments:
    OUT ULONG* ExtendedSize -
        pointer to receive the extended size.

Return:
    S_OK

--*/

{
    *ExtendedSize = sizeof (KS_VBI_FRAME_INFO);
    return S_OK;
}
    

STDMETHODIMP 
CVBIDataTypeHandler::KsSetMediaType(
    const AM_MEDIA_TYPE *AmMediaType
    )

/*++

Routine Description:
    Sets the media type for this instance of the data handler.

Arguments:
    const AM_MEDIA_TYPE *AmMediaType -
        pointer to the media type

Return:
    S_OK

--*/

{
    if (m_MediaType) {
        return E_FAIL;
    }
    if (m_MediaType = new CMediaType( *AmMediaType )) {
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pcamera.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  pcamera.h  CameraControl property page

#ifndef _INC_PCAMERACONTROL_H
#define _INC_PCAMERACONTROL_H

#define NUM_CAMERA_CONTROLS (KSPROPERTY_CAMERACONTROL_FOCUS + 1)

// -------------------------------------------------------------------------
// CCameraControlProperty class
// -------------------------------------------------------------------------

// Handles a single property

class CCameraControlProperty : public CKSPropertyEditor 
{

public:
    CCameraControlProperty (
        HWND hDlg, 
        ULONG IDLabel,
        ULONG IDTrackbarControl, 
        ULONG IDAutoControl,
        ULONG IDEditControl,
        ULONG IDProperty,
        IAMCameraControl * pInterface);

    ~CCameraControlProperty ();

    //
    // Base class pure virtual overrides
    // 
    HRESULT GetValue (void);
    HRESULT SetValue (void);
    HRESULT GetRange (void); 
    BOOL CanAutoControl (void);
    BOOL GetAuto (void);
    BOOL SetAuto (BOOL fAuto);

    // The control interface
    IAMCameraControl        *m_pInterface;
};


// -------------------------------------------------------------------------
// CCameraControlProperties class
// -------------------------------------------------------------------------

// Handles the property page

class CCameraControlProperties : public CBasePropertyPage {

public:

    static CUnknown * CALLBACK CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

#if 0
    // Make it bigger
    STDMETHODIMP GetPageInfo(PROPPAGEINFO *pPageInfo) {
        HRESULT hr;
        hr = CBasePropertyPage::GetPageInfo (pPageInfo);
        pPageInfo->size.cx *= 2;
        pPageInfo->size.cy *= 2; 
        return hr;
    };
#endif

private:

    CCameraControlProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CCameraControlProperties();

    void    SetDirty();

    int     m_NumProperties;

    // The control iterface
    IAMCameraControl   *m_pCameraControl;

    // The array of controls
    CCameraControlProperty  *m_Controls [NUM_CAMERA_CONTROLS];

};

#endif  // _INC_PCAMERACONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pcamera.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// pcamera.cpp  Property page for CameraControl
//

#include "pch.h"
#include "kseditor.h"
#include "pcamera.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CCameraControlProperty
// -------------------------------------------------------------------------


// Handles a single property

CCameraControlProperty::CCameraControlProperty (
        HWND hDlg, 
        ULONG IDLabel,
        ULONG IDTrackbarControl,
        ULONG IDAutoControl,
        ULONG IDEditControl,
        ULONG IDProperty,
        IAMCameraControl * pInterface
    )
    : CKSPropertyEditor (
                hDlg, 
                IDLabel,
                IDTrackbarControl,
                IDAutoControl,
                IDEditControl,
                IDProperty
                )
    , m_pInterface (pInterface)
{
	INITCOMMONCONTROLSEX cc;

    cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
    cc.dwICC = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

    InitCommonControlsEx(&cc); 
}

// destructor
CCameraControlProperty::~CCameraControlProperty (
    )
{
}

// Must set m_CurrentValue and m_CurrentFlags
HRESULT 
CCameraControlProperty::GetValue (void)
{
    if (!m_pInterface)
        return E_NOINTERFACE;

    return m_pInterface->Get( 
                m_IDProperty,
                &m_CurrentValue,
                &m_CurrentFlags);
}

// Set from m_CurrentValue and m_CurrentFlags
HRESULT 
CCameraControlProperty::SetValue (void)
{
    if (!m_pInterface)
        return E_NOINTERFACE;

    return m_pInterface->Set( 
                m_IDProperty,
                m_CurrentValue,
                m_CurrentFlags);
}

HRESULT 
CCameraControlProperty::GetRange ()
{
    if (!m_pInterface)
        return E_NOINTERFACE;

    return m_pInterface->GetRange( 
                m_IDProperty,
                &m_Min,
                &m_Max,
                &m_SteppingDelta,
                &m_DefaultValue,
                &m_CapsFlags);
}

BOOL 
CCameraControlProperty::CanAutoControl (void)
{
    return m_CapsFlags & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
}

BOOL 
CCameraControlProperty::GetAuto (void)
{
    GetValue ();

    return m_CurrentFlags & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO; 
}

BOOL 
CCameraControlProperty::SetAuto (
     BOOL fAuto
     )
{
    m_CurrentFlags = (fAuto ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : 0);
    SetValue ();

    return TRUE; 
}
         
// -------------------------------------------------------------------------
// CCameraControlProperties
// -------------------------------------------------------------------------

CUnknown *
CALLBACK
CCameraControlProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CCameraControlProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CCameraControlProperties::CCameraControlProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("CameraControl Property Page") 
                        , lpunk
                        , IDD_CameraControlProperties 
                        , IDS_CAMERACONTROLPROPNAME
                        )
    , m_pCameraControl(NULL) 
    , m_NumProperties (NUM_CAMERA_CONTROLS)
{

}

// destructor
CCameraControlProperties::~CCameraControlProperties()
{

}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT 
CCameraControlProperties::OnConnect(IUnknown *pUnknown)
{
    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_IAMCameraControl,(void **)&m_pCameraControl);
    if (FAILED(hr)) {
        return hr;
    }

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT 
CCameraControlProperties::OnDisconnect()
{
    // Release the interface

    if (m_pCameraControl == NULL) {
        return E_UNEXPECTED;
    }

    m_pCameraControl->Release();
    m_pCameraControl = NULL;

    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT 
CCameraControlProperties::OnActivate(void)
{
    // Create all of the controls

    m_Controls [0] = new CCameraControlProperty (
                        m_hwnd, 
                        IDC_Pan_Label, 
                        IDC_Pan,
                        IDC_Pan_Auto,
                        IDC_Pan_Edit,
                        KSPROPERTY_CAMERACONTROL_PAN,
                        m_pCameraControl);
    m_Controls [1] = new CCameraControlProperty (
                        m_hwnd, 
                        IDC_Tilt_Label, 
                        IDC_Tilt, 
                        IDC_Tilt_Auto,
                        IDC_Tilt_Edit,
                        KSPROPERTY_CAMERACONTROL_TILT,
                        m_pCameraControl);    
    m_Controls [2] = new CCameraControlProperty (
                        m_hwnd, 
                        IDC_Roll_Label, 
                        IDC_Roll, 
                        IDC_Roll_Auto,
                        IDC_Roll_Edit,
                        KSPROPERTY_CAMERACONTROL_ROLL,
                        m_pCameraControl);   
    m_Controls [3] = new CCameraControlProperty (
                        m_hwnd, 
                        IDC_Zoom_Label, 
                        IDC_Zoom, 
                        IDC_Zoom_Auto,
                        IDC_Zoom_Edit,
                        KSPROPERTY_CAMERACONTROL_ZOOM,
                        m_pCameraControl);   
    m_Controls [4] = new CCameraControlProperty (
                        m_hwnd, 
                        IDC_Exposure_Label, 
                        IDC_Exposure, 
                        IDC_Exposure_Auto,
                        IDC_Exposure_Edit,
                        KSPROPERTY_CAMERACONTROL_EXPOSURE,
                        m_pCameraControl);   
    m_Controls [5] = new CCameraControlProperty (
                        m_hwnd, 
                        IDC_Iris_Label, 
                        IDC_Iris, 
                        IDC_Iris_Auto,
                        IDC_Iris_Edit,
                        KSPROPERTY_CAMERACONTROL_IRIS,
                        m_pCameraControl);   
    m_Controls [6] = new CCameraControlProperty (
                        m_hwnd, 
                        IDC_Focus_Label, 
                        IDC_Focus,
                        IDC_Focus_Auto,
                        IDC_Focus_Edit,
                        KSPROPERTY_CAMERACONTROL_FOCUS,
                        m_pCameraControl);   

    for (int j = 0; j < m_NumProperties; j++) {
        m_Controls[j]->Init();
    }

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CCameraControlProperties::OnDeactivate(void)
{
    for (int j = 0; j < m_NumProperties; j++) {
        delete m_Controls[j];
    }

    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT 
CCameraControlProperties::OnApplyChanges(void)
{
    for (int j = 0; j < m_NumProperties; j++) {
        m_Controls[j]->OnApply();
    }

    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR
CCameraControlProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    int iNotify = HIWORD (wParam);
    int j;

    switch (uMsg) {

    case WM_INITDIALOG:
        return (INT_PTR)TRUE;    // I don't call setfocus...

    case WM_HSCROLL:
    case WM_VSCROLL:
        // Process all of the Trackbar messages
        for (j = 0; j < m_NumProperties; j++) {
            if (m_Controls[j]->GetTrackbarHWnd () == (HWND) lParam) {
                m_Controls[j]->OnScroll (uMsg, wParam, lParam);
                SetDirty();
            }
        }
        break;
        

    case WM_COMMAND:

        // Process all of the auto checkbox messages
        for (j = 0; j < m_NumProperties; j++) {
            if (m_Controls[j]->GetAutoHWnd () == (HWND) lParam) {
                m_Controls[j]->OnAuto (uMsg, wParam, lParam);
                SetDirty();
                break;
            }
        }

        // Process all of the edit box messages
        for (j = 0; j < m_NumProperties; j++) {
            if (m_Controls[j]->GetEditHWnd () == (HWND) lParam) {
                m_Controls[j]->OnEdit (uMsg, wParam, lParam);
                SetDirty();
                break;
            }
        }
        
        switch (LOWORD(wParam)) {

        case IDC_CAMERACONTROL_DEFAULT:
            for (j = 0; j < m_NumProperties; j++) {
                m_Controls[j]->OnDefault();
            }
            break;

        
        default:
            break;

        }

        break;

    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// SetDirty
//
// notifies the property page site of changes

void 
CCameraControlProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\kseditor.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  KSEditor.h  CameraControl property page

#ifndef _INC_KSPROPERTYEDITOR_H
#define _INC_KSPROPERTYEDITOR_H

// -------------------------------------------------------------------------
// CKSPropertyEditor class
// -------------------------------------------------------------------------

// Handles a single KS property

class CKSPropertyEditor {

public:
    CKSPropertyEditor (
        HWND hDlg, 
        ULONG IDLabel,
        ULONG IDTrackbarControl, 
        ULONG IDAutoControl,
        ULONG IDEditControl,
        ULONG IDProperty);

    virtual ~CKSPropertyEditor ();
    BOOL Init ();

    HWND GetTrackbarHWnd () {return m_hWndTrackbar;};
    HWND GetAutoHWnd ()     {return m_hWndAuto;};
    HWND GetEditHWnd ()     {return m_hWndEdit;};

    BOOL UpdateEditBox ();
    BOOL UpdateTrackbar ();
    BOOL UpdateAuto ();

    BOOL OnUpdateAll ();      // Reinitialize all settings
    BOOL OnApply ();
    BOOL OnCancel ();
    BOOL OnDefault ();
    BOOL OnScroll (ULONG nCommand, WPARAM wParam, LPARAM lParam);
    BOOL OnAuto (ULONG nCommand, WPARAM wParam, LPARAM lParam);
    BOOL OnEdit (ULONG nCommand, WPARAM wParam, LPARAM lParam);

    // Pure virtual functions to get actual property values
    // the ranges, and whether the property supports an
    // auto checkbox

protected:
    virtual HRESULT GetValue (void) PURE;
    virtual HRESULT SetValue (void) PURE;
    virtual HRESULT GetRange (void) PURE; 
    virtual BOOL CanAutoControl (void) PURE;
    virtual BOOL GetAuto (void) PURE;
    virtual BOOL SetAuto (BOOL fAuto) PURE;

    ULONG                   m_IDProperty;       // KS property ID

    // The following are used by GetValue and SetValue
    LONG                    m_CurrentValue;
    LONG                    m_CurrentFlags;

    // The following must be set by GetRange
    LONG                    m_Min;
    LONG                    m_Max;
    LONG                    m_SteppingDelta;
    LONG                    m_DefaultValue;
    LONG                    m_CapsFlags;

private:
    BOOL                    m_Active;
    LONG                    m_OriginalValue;
    LONG                    m_OriginalFlags;
    HWND                    m_hDlg;             // Parent
    HWND                    m_hWndTrackbar;     // This control
    HWND                    m_hWndAuto;         // Auto checkbox
    HWND                    m_hWndEdit;         // Edit window
    ULONG                   m_IDLabel;          // ID of label
    ULONG                   m_IDTrackbarControl;// ID of trackbar
    ULONG                   m_IDAutoControl;    // ID of auto checkbox
    ULONG                   m_IDEditControl;    // ID of edit control
    BOOL                    m_CanAutoControl;
    LONG                    m_TrackbarOffset;   // Handles negative trackbar offsets
};

#endif // define _INC_KSPROPERTYEDITOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pformat.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  pformat.h  Video Decoder property page

#ifndef _INC_PVIDEOSTREAMCONFIG_H
#define _INC_PVIDEOSTREAMCONFIG_H

// This list of image sizes will be used in additional to 
// the defalut image size supported by the capture devices.
//
// Aspect Ratio 1:1 (Square Pixel, computer uses), 4:3 (TV uses)
//
#define IMG_AR11_CIF_CX 320
#define IMG_AR11_CIF_CY 240

#define IMG_AR43_CIF_CX 352
#define IMG_AR43_CIF_CY 288

#define STDIMGSIZE_VALID          0x00000001
#define STDIMGSIZE_DEFAULT        0x00000002
#define STDIMGSIZE_SELECTED       0x00000004
#define STDIMGSIZE_BIHEIGHT_NEG   0x00000008
#define STDIMGSIZE_DUPLICATED     0x80000000  // An item can be valid but duplicated.

typedef struct {
	SIZE    size;
	DWORD	Flags;
    int     RangeIndex;
} IMAGESIZE, * PIMAGESIZE;

// -------------------------------------------------------------------------
// CVideoStreamConfigProperties class
// -------------------------------------------------------------------------

// Handles the property page

class CVideoStreamConfigProperties : public CBasePropertyPage {

public:

    static CUnknown * CALLBACK CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    CVideoStreamConfigProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CVideoStreamConfigProperties();

    void    SetDirty();

    // The control interfaces
    IAMStreamConfig            *m_pVideoStreamConfig;
    IAMAnalogVideoDecoder      *m_pAnalogVideoDecoder;
    IAMVideoCompression        *m_pVideoCompression;
    IAMVideoControl            *m_pVideoControl;

    LONG                        m_VideoControlCaps;
    LONG                        m_VideoControlCurrent;

    IPin                       *m_pPin;

    BOOL                        m_CanSetFormat;  // if we understand this format
    TCHAR                       m_UnsupportedTypeName[MAX_PATH]; 

    int                         m_RangeCount;
    VIDEO_STREAM_CONFIG_CAPS    m_RangeCaps;

    int                         m_VideoStandardsCount;
    long                        m_VideoStandardsBitmask;
    long                       *m_VideoStandardsList;
    long                        m_VideoStandardCurrent;
    long                        m_VideoStandardOriginal;

    GUID                       *m_SubTypeList;
    int                         m_ColorSpaceCount;
    GUID                        m_SubTypeCurrent;
    CMediaType                 *m_CurrentMediaType;
    int                         m_CurrentWidth;
    int                         m_CurrentHeight;
    
    REFERENCE_TIME              m_DefaultAvgTimePerFrame;
    double                      m_FramesPerSec;
    double                     *m_FrameRateList;
    int                         m_FrameRateListSize;
    double                      m_MaxFrameRate;
    double                      m_MinFrameRate;
    double                      m_DefaultFrameRate;

    long                        m_CompressionCapabilities;
    long                        m_KeyFrameRate;
    long                        m_PFramesPerKeyFrame;
    double                      m_Quality;

    BOOL                        m_FirstGetCurrentMediaType;

    HWND                        m_hWndVideoStandards; 
    HWND                        m_hWndCompression;
    HWND                        m_hWndOutputSize;
    HWND                        m_hWndFrameRate;
    HWND                        m_hWndFrameRateSpin;
    HWND                        m_hWndFlipHorizontal;

    HWND                        m_hWndStatus; 
    HWND                        m_hWndIFrameInterval;
    HWND                        m_hWndIFrameIntervalSpin;
    HWND                        m_hWndPFrameInterval;
    HWND                        m_hWndPFrameIntervalSpin;
    HWND                        m_hWndQuality;
    HWND                        m_hWndQualitySlider;

    IMAGESIZE                  *m_ImageSizeList;

    HRESULT InitialRangeScan (void);
    HRESULT OnVideoStandardChanged (void);
    HRESULT OnCompressionChanged (void);
    HRESULT OnImageSizeChanged (void);

    BOOL    ValidateImageSize(
	            VIDEO_STREAM_CONFIG_CAPS * pVideoCfgCaps, 
	            SIZE * pSize);

    HRESULT GetCurrentMediaType (void);
    HRESULT CreateFrameRateList (int RangeIndex, SIZE SizeImage);

    HRESULT InitDialog (void);
    BOOL    OnFrameRateChanged (int Increment);

};

#endif  // _INC_PVIDEOSTREAMCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pprocamp.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// pprocamp.cpp  Video Proc Amp Property page 
//

#include "pch.h"
#include "kseditor.h"
#include "pprocamp.h"
#include "resource.h"

// -------------------------------------------------------------------------
// CAVideoProcAmpProperty class
// -------------------------------------------------------------------------

// Handles a single property

CAVideoProcAmpProperty::CAVideoProcAmpProperty (
        HWND hDlg,
        ULONG IDLabel,
        ULONG IDTrackbarControl,
        ULONG IDAutoControl,
        ULONG IDEditControl,
        ULONG IDProperty,
        IAMVideoProcAmp * pInterface
    )
    : CKSPropertyEditor (
                hDlg, 
                IDLabel,
                IDTrackbarControl,
                IDAutoControl,
                IDEditControl,
                IDProperty
                )
    , m_pInterface (pInterface)
{
	INITCOMMONCONTROLSEX cc;

    cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
    cc.dwICC = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

    InitCommonControlsEx(&cc); 
}

// destructor
CAVideoProcAmpProperty::~CAVideoProcAmpProperty (
    )
{
}

// Must set m_CurrentValue and m_CurrentFlags
HRESULT 
CAVideoProcAmpProperty::GetValue (void)
{
    if (!m_pInterface)
        return E_NOINTERFACE;

    return m_pInterface->Get( 
                m_IDProperty,
                &m_CurrentValue,
                &m_CurrentFlags);
}

// Set from m_CurrentValue and m_CurrentFlags
HRESULT 
CAVideoProcAmpProperty::SetValue (void)
{
    if (!m_pInterface)
        return E_NOINTERFACE;

    return m_pInterface->Set( 
                m_IDProperty,
                m_CurrentValue,
                m_CurrentFlags);
}

HRESULT 
CAVideoProcAmpProperty::GetRange ()
{
    if (!m_pInterface)
        return E_NOINTERFACE;

    return m_pInterface->GetRange( 
                m_IDProperty,
                &m_Min,
                &m_Max,
                &m_SteppingDelta,
                &m_DefaultValue,
                &m_CapsFlags);
}

// Ugly, nasty stuff follows !!!
// The Auto checkbox handling is overloaded to handle setting
// of properties that are just BOOLs

BOOL 
CAVideoProcAmpProperty::CanAutoControl (void)
{
    // If no trackbar and no edit, then this is a BOOL value
    if (!GetTrackbarHWnd() && !GetEditHWnd()) {
       return m_CapsFlags & KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL;
    }
    else {
        return m_CapsFlags & KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;
    }
}

BOOL 
CAVideoProcAmpProperty::GetAuto (void)
{
    // If no trackbar and no edit, then this is a BOOL value
    if (!GetTrackbarHWnd() && !GetEditHWnd()) {
        GetValue();
        return (BOOL) m_CurrentValue;
    }
    else {
        return (BOOL) (m_CurrentFlags & KSPROPERTY_CAMERACONTROL_FLAGS_AUTO); 
    }
}

BOOL 
CAVideoProcAmpProperty::SetAuto (
     BOOL fAuto
     )
{
    // If no trackbar and no edit, then this is a BOOL value
    if (!GetTrackbarHWnd() && !GetEditHWnd()) {
        m_CurrentValue = fAuto;
    }
    else {
        m_CurrentFlags = (fAuto ? KSPROPERTY_CAMERACONTROL_FLAGS_AUTO : 
                                  KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL);
    }
    SetValue ();

    return TRUE;
}
         
// -------------------------------------------------------------------------
// CVideoProcAmpProperties
// -------------------------------------------------------------------------

CUnknown *
CALLBACK
CVideoProcAmpProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CVideoProcAmpProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CVideoProcAmpProperties::CVideoProcAmpProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("VideoProcAmp Property Page") 
                        , lpunk
                        , IDD_VideoProcAmpProperties
                        , IDS_VIDEOPROCAMPPROPNAME)
    , m_pVideoProcAmp(NULL) 
    , m_NumProperties (NUM_PROCAMP_CONTROLS)
{

}

// destructor
CVideoProcAmpProperties::~CVideoProcAmpProperties()
{

}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT 
CVideoProcAmpProperties::OnConnect(IUnknown *pUnknown)
{
    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_IAMVideoProcAmp,(void **)&m_pVideoProcAmp);
    if (FAILED(hr)) {
        return hr;
    }

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT 
CVideoProcAmpProperties::OnDisconnect()
{
    // Release the interface

    if (m_pVideoProcAmp == NULL) {
        return E_UNEXPECTED;
    }

    m_pVideoProcAmp->Release();
    m_pVideoProcAmp = NULL;

    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT 
CVideoProcAmpProperties::OnActivate(void)
{
    // Create all of the controls

    m_Controls [0] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        0, 
                        IDC_Brightness,
                        IDC_Brightness_Auto,
                        IDC_Brightness_Edit,
                        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
                        m_pVideoProcAmp);
    m_Controls [1] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        IDC_Contrast_Label, 
                        IDC_Contrast, 
                        IDC_Contrast_Auto,
                        IDC_Contrast_Edit,
                        KSPROPERTY_VIDEOPROCAMP_CONTRAST,
                        m_pVideoProcAmp);    
    m_Controls [2] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        IDC_Hue_Label, 
                        IDC_Hue, 
                        IDC_Hue_Auto,
                        IDC_Hue_Edit,
                        KSPROPERTY_VIDEOPROCAMP_HUE,
                        m_pVideoProcAmp);   
    m_Controls [3] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        IDC_Saturation_Label, 
                        IDC_Saturation, 
                        IDC_Saturation_Auto,
                        IDC_Saturation_Edit,
                        KSPROPERTY_VIDEOPROCAMP_SATURATION,
                        m_pVideoProcAmp);   
    m_Controls [4] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        IDC_Sharpness_Label, 
                        IDC_Sharpness, 
                        IDC_Sharpness_Auto,
                        IDC_Sharpness_Edit,
                        KSPROPERTY_VIDEOPROCAMP_SHARPNESS,
                        m_pVideoProcAmp);   
    m_Controls [5] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        IDC_Gamma_Label, 
                        IDC_Gamma, 
                        IDC_Gamma_Auto,
                        IDC_Gamma_Edit,
                        KSPROPERTY_VIDEOPROCAMP_GAMMA,
                        m_pVideoProcAmp);   
    m_Controls [6] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        0, 
                        0, // This property is a BOOL 
                        IDC_ColorEnable_Auto,
                        0, // This property is a BOOL
                        KSPROPERTY_VIDEOPROCAMP_COLORENABLE,
                        m_pVideoProcAmp);   
    m_Controls [7] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        IDC_WhiteBalance_Label, 
                        IDC_WhiteBalance, 
                        IDC_WhiteBalance_Auto,
                        IDC_WhiteBalance_Edit,
                        KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,
                        m_pVideoProcAmp);   
    m_Controls [8] = new CAVideoProcAmpProperty (
                        m_hwnd, 
                        IDC_BacklightCompensation_Label, 
                        IDC_BacklightCompensation, 
                        IDC_BacklightCompensation_Auto,
                        IDC_BacklightCompensation_Edit,
                        KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,
                        m_pVideoProcAmp);

    for (int j = 0; j < m_NumProperties; j++) {
        m_Controls[j]->Init();
    }

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CVideoProcAmpProperties::OnDeactivate(void)
{
    for (int j = 0; j < m_NumProperties; j++) {
        delete m_Controls[j];
    }

    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT 
CVideoProcAmpProperties::OnApplyChanges(void)
{
    for (int j = 0; j < m_NumProperties; j++) {
        m_Controls[j]->OnApply();
    }

    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR
CVideoProcAmpProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    int iNotify = HIWORD (wParam);
    int j;

    switch (uMsg) {

    case WM_INITDIALOG:
        return (INT_PTR)TRUE;    // I don't call setfocus...

    case WM_HSCROLL:
    case WM_VSCROLL:
        // Process all of the Trackbar messages
        for (j = 0; j < m_NumProperties; j++) {
            if (m_Controls[j]->GetTrackbarHWnd () == (HWND) lParam) {
                m_Controls[j]->OnScroll (uMsg, wParam, lParam);
                SetDirty();
            }
        }
        break;
        

    case WM_COMMAND:

        // Process all of the auto checkbox messages
        for (j = 0; j < m_NumProperties; j++) {
            if (m_Controls[j]->GetAutoHWnd () == (HWND) lParam) {
                m_Controls[j]->OnAuto (uMsg, wParam, lParam);
                SetDirty();
                break;
            }
        }

        // Process all of the edit box messages
        for (j = 0; j < m_NumProperties; j++) {
            if (m_Controls[j]->GetEditHWnd () == (HWND) lParam) {
                m_Controls[j]->OnEdit (uMsg, wParam, lParam);
                SetDirty();
                break;
            }
        }
        
        switch (LOWORD(wParam)) {

        case IDC_VIDEOPROCAMP_DEFAULT:
            for (j = 0; j < m_NumProperties; j++) {
                m_Controls[j]->OnDefault();
            }
            break;
        
        default:
            break;

        }

        break;

    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// SetDirty
//
// notifies the property page site of changes

void 
CVideoProcAmpProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pprocamp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  pprocamp.h  CameraControl property page

#ifndef _INC_PVIDEOPROCAMP_H
#define _INC_PVIDEOPROCAMP_H

#define NUM_PROCAMP_CONTROLS (KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION + 1)

// -------------------------------------------------------------------------
// CAVideoProcAmpProperty class
// -------------------------------------------------------------------------

// Handles a single property

class CAVideoProcAmpProperty : public CKSPropertyEditor 
{

public:
    CAVideoProcAmpProperty (
        HWND hDlg, 
        ULONG IDLabel,
        ULONG IDTrackbarControl, 
        ULONG IDAutoControl,
        ULONG IDEditControl,
        ULONG IDProperty,
        IAMVideoProcAmp * pInterface);

    ~CAVideoProcAmpProperty ();

    //
    // Base class pure virtual overrides
    // 
    HRESULT GetValue (void);
    HRESULT SetValue (void);
    HRESULT GetRange (void); 
    BOOL CanAutoControl (void);
    BOOL GetAuto (void);
    BOOL SetAuto (BOOL fAuto);

    // The control interface
    IAMVideoProcAmp        *m_pInterface;
};


// -------------------------------------------------------------------------
// CVideoProcAmpProperties class
// -------------------------------------------------------------------------

// Handles the property page

class CVideoProcAmpProperties : public CBasePropertyPage {

public:

    static CUnknown * CALLBACK CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

#if 0
    // Make it bigger
    STDMETHODIMP GetPageInfo(PROPPAGEINFO *pPageInfo) {
        HRESULT hr;
        hr = CBasePropertyPage::GetPageInfo (pPageInfo);
        pPageInfo->size.cx = 300; //240;
        pPageInfo->size.cy = 200; //146;
        return hr;
    };
#endif

private:

    CVideoProcAmpProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CVideoProcAmpProperties();

    void    SetDirty();

    int     m_NumProperties;

    // The control iterface
    IAMVideoProcAmp   *m_pVideoProcAmp;

    // The array of controls
    CAVideoProcAmpProperty  *m_Controls [NUM_PROCAMP_CONTROLS];

};

#endif  // _INC_PVIDEOPROCAMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pformat.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// pformat.cpp  Property page for IAMStreamConfig
//

#include "pch.h"
#include <tchar.h>
#include "wdmcap.h"
#include "kseditor.h"
#include "pformat.h"
#include "resource.h"


//
// List of standard image sizes
//
const IMAGESIZE sizeStdImage[] = {

    // X                Y                Flags  RangeIndex

    {0,                 0,                 0,     0},    // Default size goes here

   {IMG_AR11_CIF_CX/4, IMG_AR11_CIF_CY/4,  0,     0},    //  80 x  60

   {IMG_AR43_CIF_CX/4, IMG_AR43_CIF_CY/4,  0,     0},    //  88 x  72

   {128,               96,                 0,     0},    // 128 x  96

   {IMG_AR11_CIF_CX/2, IMG_AR11_CIF_CY/2,  0,     0},    // 160 x 120   
   {IMG_AR43_CIF_CX/2, IMG_AR43_CIF_CY/2,  0,     0},    // 176 x 144

   {240,               176,                0,     0},    // 240 x 176, Not in 98 Gold
                                                         //   NetShow requested above

   {240,               180,                0,     0},    // 240 x 180
 
   {IMG_AR11_CIF_CX,   IMG_AR11_CIF_CY  ,  0,     0},    // 320 x 240
   {IMG_AR43_CIF_CX,   IMG_AR11_CIF_CY  ,  0,     0},    // 352 x 240, added Millen/Neptune
   {IMG_AR43_CIF_CX,   IMG_AR43_CIF_CY  ,  0,     0},    // 352 x 288

   {640,               240              ,  0,     0},    // 640 x 240, Not in 98 Gold
   {640,               288              ,  0,     0},    // 640 x 288, Not in 98 Gold

   {IMG_AR11_CIF_CX*2, IMG_AR11_CIF_CY*2,  0,     0},    // 640 x 480
   {IMG_AR43_CIF_CX*2, IMG_AR43_CIF_CY*2,  0,     0},    // 704 x 576

                                                         // ATI request begin
   {720,               240              ,  0,     0},    // 720 x 240, Not in 98 Gold
   {720,               288              ,  0,     0},    // 720 x 288, Not in 98 Gold

   {720,               480              ,  0,     0},    // 720 x 480, Not in 98 Gold
   {720,               576              ,  0,     0},    // 720 x 576, Not in 98 Gold
                                                         // ATI request end
} ;

const ULONG  NumberOfImageSizes = sizeof(sizeStdImage)/sizeof(IMAGESIZE);

// List of default frame rates
// Note that 29.97 and 59.94 are computed to be equal to the typical values
// used in the DataRange structure.
// If this list is ever changed, be sure to change the defaults for 
// NTSC and PAL-SECAM immediately following!

const double DefaultFrameRateList[] = 
{   1.0/60.0,  // 1 frame per minute
    1.0/30.0,
    1.0/25.0,
    1.0/10.0,
    1.0/ 4.0,
    1.0/ 2.0,

     1.0,    2.0,    3.0,    4.0,    5.0,    6.0,    7.0,    8.0,    9.0,   10.0,
    11.0,   12.0,   13.0,   14.0,   15.0,   16.0,   17.0,   18.0,   19.0,   20.0,
    21.0,   22.0,   23.0,   24.0,   25.0,   26.0,   27.0,   
    
    28.0,   29.0,   30.0*1000/1001 /*29.97... per AES/SMPTE */,  30.0,

    31.0,   32.0,   33.0,   34.0,   35.0,   36.0,   37.0,   38.0,   39.0,   40.0,
    41.0,   42.0,   43.0,   44.0,   45.0,   46.0,   47.0,   48.0,   49.0,   50.0,
    51.0,   52.0,   53.0,   54.0,   55.0,   56.0,   57.0,   
    
    58.0,   59.0,   60.0*1000/1001 /*59.94... per AES/SMPTE*/,  60.0,

    61.0,   62.0,   63.0,   64.0,   65.0,   66.0,   67.0,   68.0,   69.0,   70.0,
    71.0,   72.0,   73.0,   74.0,   75.0,   76.0,   77.0,   78.0,   79.0,   80.0,
    81.0,   82.0,   83.0,   84.0,   85.0,   86.0,   87.0,   88.0,   89.0,   90.0,
    91.0,   92.0,   93.0,   94.0,   95.0,   96.0,   97.0,   98.0,   99.0,  100.0
};
         
const int DefaultFrameRateListSize = sizeof(DefaultFrameRateList)/sizeof(DefaultFrameRateList[0]);
const int DefaultPALFrameRateIndex = 30;    // 25.00 fps
const int DefaultNTSCFrameRateIndex = 35;   // 29.97... fps

// -------------------------------------------------------------------------
// CVideoStreamConfigProperties
// -------------------------------------------------------------------------

CUnknown *
CALLBACK
CVideoStreamConfigProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CVideoStreamConfigProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CVideoStreamConfigProperties::CVideoStreamConfigProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("VideoStreamConfig Property Page") 
                        , lpunk
                        , IDD_VideoStreamConfigProperties 
                        , IDS_VIDEOSTREAMCONFIGPROPNAME
                        )
    , m_pVideoStreamConfig (NULL)
    , m_pAnalogVideoDecoder (NULL)
    , m_pVideoCompression (NULL)
    , m_pVideoControl (NULL)
    , m_SubTypeList (NULL)
    , m_VideoStandardsList (NULL)
    , m_CurrentMediaType (NULL)
    , m_VideoStandardCurrent (0)
    , m_FrameRateList (NULL)
    , m_pPin (NULL)
    , m_VideoControlCaps (0)
    , m_VideoControlCurrent (0)
    , m_CanSetFormat (FALSE)
    , m_FirstGetCurrentMediaType (TRUE)
{
    INITCOMMONCONTROLSEX cc;

    cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
    cc.dwICC = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

    InitCommonControlsEx(&cc); 
}

// destructor
CVideoStreamConfigProperties::~CVideoStreamConfigProperties()
{

}

// Scan the list of ranges, and determine the available VideoStandards
// and Compression FOURCCs.
// This routine should only be called once at dialog initialization

HRESULT
CVideoStreamConfigProperties::InitialRangeScan ()
{
    int         lSize;
    int         j;
    HRESULT     hr;
    CMediaType *pmt = NULL;

    m_VideoStandardsBitmask = 0;
    m_VideoStandardsCount = 0;
    m_ColorSpaceCount = 0;
    m_RangeCount = 0;

    if (!m_pVideoStreamConfig) {
       return S_FALSE;
    }

    hr = m_pVideoStreamConfig->GetNumberOfCapabilities (&m_RangeCount, &lSize);
    DbgLog(( LOG_TRACE, 1, TEXT("VideoStreamConfig::ScanForVideoStandards, NumberOfRanges=%d"), m_RangeCount));

    ASSERT (SUCCEEDED (hr));
    ASSERT (lSize == sizeof (VIDEO_STREAM_CONFIG_CAPS));

    // If we don't understand the internals of the format, m_CanSetFormat will
    // be FALSE when this returns

    hr = GetCurrentMediaType();

    if (!SUCCEEDED(hr) || !m_CanSetFormat) {
        return S_FALSE;
    }

    m_VideoStandardsList = new long [m_RangeCount];
    m_SubTypeList = new GUID [m_RangeCount];

    if (!m_VideoStandardsList || !m_SubTypeList ) {

        DbgLog(( LOG_TRACE, 1, TEXT("VideoStreamConfig::ScanForVideoStandards ERROR new")));
        return S_FALSE;
    }

    for (j = 0; j < m_RangeCount; j++) {
        pmt = NULL;

        hr = m_pVideoStreamConfig->GetStreamCaps (j, 
                (AM_MEDIA_TYPE **) &pmt, (BYTE *)&m_RangeCaps);

        ASSERT (SUCCEEDED (hr));
        ASSERT (*pmt->Type() == MEDIATYPE_Video);

        m_VideoStandardsList[j] = m_RangeCaps.VideoStandard;
        m_VideoStandardsBitmask |= m_RangeCaps.VideoStandard;

        m_SubTypeList[j] = *pmt->Subtype();

        // Verify that the FOURCCs and Subtypes match!

        if (*pmt->FormatType() == FORMAT_VideoInfo) {
            VIDEOINFOHEADER *VidInfoHdr = (VIDEOINFOHEADER*) pmt->Format();

            ASSERT (IsEqualGUID (GetBitmapSubtype(&VidInfoHdr->bmiHeader), *pmt->Subtype()));
        }
        else if (*pmt->FormatType() == FORMAT_VideoInfo2) {
            VIDEOINFOHEADER2 *VidInfoHdr = (VIDEOINFOHEADER2*)pmt->Format ();

            ASSERT (IsEqualGUID (GetBitmapSubtype(&VidInfoHdr->bmiHeader), *pmt->Subtype()));
        }
        else if (*pmt->FormatType() == FORMAT_MPEGVideo) {
            MPEG1VIDEOINFO *MPEG1VideoInfo = (MPEG1VIDEOINFO*)pmt->Format ();
            VIDEOINFOHEADER *VidInfoHdr = &MPEG1VideoInfo->hdr;

            // Possibly perform sanity checking here
        }
        else if (*pmt->FormatType() == FORMAT_MPEG2Video) {
            MPEG2VIDEOINFO *MPEG2VideoInfo = (MPEG2VIDEOINFO*)pmt->Format ();
            VIDEOINFOHEADER2 *VidInfoHdr = &MPEG2VideoInfo->hdr;

            // Possibly perform sanity checking here
        }
        else {
            ASSERT (*pmt->FormatType() == FORMAT_VideoInfo  || 
                    *pmt->FormatType() == FORMAT_VideoInfo2 ||
                    *pmt->FormatType() == FORMAT_MPEGVideo  ||
                    *pmt->FormatType() == FORMAT_MPEG2Video );
        }

        DeleteMediaType (pmt);
    }


    return hr;
}

// Whenever the videostandard changes, reinit the compression listbox
// and also the outputsize listbox

HRESULT
CVideoStreamConfigProperties::OnVideoStandardChanged ()
{
    int     j, k;
    int     CurrentIndex = 0;
    int     MatchIndex = 0;
    int     SubtypeIndex = 0;
    int     EntriesThusfar;
    TCHAR   buf[80];
    TCHAR  *DShowName;

    
    ComboBox_ResetContent (m_hWndCompression);

    if (!m_CanSetFormat) {
        ComboBox_AddString (m_hWndCompression, m_UnsupportedTypeName);
        ComboBox_SetCurSel (m_hWndCompression, 0); 
    }

    if (!m_pVideoStreamConfig || !m_CanSetFormat)
        return S_FALSE;

    for (j = 0; j < m_RangeCount; j++) {

        if ((m_VideoStandardsList[j] &  m_VideoStandardCurrent) || 
            (m_VideoStandardsList[j] == m_VideoStandardCurrent)) {

            // Eliminate duplicates
            EntriesThusfar = ComboBox_GetCount (m_hWndCompression);

            for (k = 0; k < EntriesThusfar; k++) {
                int DataRangeIndex = (int)ComboBox_GetItemData (m_hWndCompression, k);

                if (IsEqualGUID (m_SubTypeList[j], m_SubTypeList[DataRangeIndex])) {
                    goto NextSubType;
                }
            }

            DShowName = GetSubtypeName(&m_SubTypeList[j]);

            // Hack alert.  GetSubtypeName returns "UNKNOWN" if it isn't among the hardcoded
            // list of known RGB formats.  If this string ever changes, we're hosed!

            if (0 == lstrcmp (DShowName, TEXT ("UNKNOWN"))) {
                if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_MPEG2_VIDEO)) {
                    _stprintf (buf, TEXT ("MPEG-2 Video"));
                }
                else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_MPEG1Payload) ||
                         IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_MPEG1Packet)) {
                    _stprintf (buf, TEXT ("MPEG-1 Video"));
                }
                else {
                    _stprintf (buf, TEXT("%c%c%c%c"), 
                          (BYTE) ( m_SubTypeList[j].Data1        & 0xff),
                          (BYTE) ((m_SubTypeList[j].Data1 >> 8)  & 0xff),
                          (BYTE) ((m_SubTypeList[j].Data1 >> 16) & 0xff),
                          (BYTE) ((m_SubTypeList[j].Data1 >> 24) & 0xff)
                          );
                }
                ComboBox_AddString (m_hWndCompression, buf);
            }
            else {
                ComboBox_AddString (m_hWndCompression, DShowName);
            }
            // Set the item data to the range index
            ComboBox_SetItemData(m_hWndCompression, CurrentIndex, j);

            if (*m_CurrentMediaType->Subtype() == m_SubTypeList[j]) {
                MatchIndex = CurrentIndex;
                SubtypeIndex = j;
            }
            CurrentIndex++;
        }
NextSubType:
        ;
    }
    ComboBox_SetCurSel (m_hWndCompression, MatchIndex); 
    m_SubTypeCurrent = m_SubTypeList[SubtypeIndex];

    // If no formats are available, disable format selection
    m_CanSetFormat = (ComboBox_GetCount (m_hWndCompression) > 0);

    return S_OK;
}


// Whenever the compression changes, reinit the outputsize listbox

HRESULT
CVideoStreamConfigProperties::OnCompressionChanged ()
{
    int     j, k;
    int     IndexOfCurrentMediaType = 0;
    HRESULT hr;
    TCHAR   buf [80];

    ComboBox_ResetContent (m_hWndOutputSize);

    if (!m_pVideoStreamConfig || !m_CanSetFormat)
        return S_FALSE;
    
    // Reinit the image size array, all flags are zero'd

   CopyMemory (m_ImageSizeList, &sizeStdImage[0], sizeof(IMAGESIZE) * NumberOfImageSizes);

    // Associate the current compression index with the right range index
    j = ComboBox_GetCurSel (m_hWndCompression);
    j = (int)ComboBox_GetItemData (m_hWndCompression, j);

    ASSERT (j >= 0 && j < m_RangeCount);
    m_SubTypeCurrent = m_SubTypeList[j];

    for (j = 0; j < m_RangeCount; j++) {
        if ((m_SubTypeList[j] == m_SubTypeCurrent) &&
            ((m_VideoStandardsList[j] &  m_VideoStandardCurrent) ||
             (m_VideoStandardsList[j] == m_VideoStandardCurrent))) {

            CMediaType * pmt = NULL;
    
            hr = m_pVideoStreamConfig->GetStreamCaps (j, 
                    (AM_MEDIA_TYPE **) &pmt, (BYTE *)&m_RangeCaps);
    
            // Initialize the default size, if it isn't already set
            if (m_ImageSizeList[0].size.cx == 0) {
                if (*pmt->FormatType() == FORMAT_VideoInfo) {
                    VIDEOINFOHEADER *VidInfoHdr = (VIDEOINFOHEADER*) pmt->Format();

                    m_ImageSizeList[0].size.cx = VidInfoHdr->bmiHeader.biWidth;
                    m_ImageSizeList[0].size.cy = VidInfoHdr->bmiHeader.biHeight;
                }
                else if (*pmt->FormatType() == FORMAT_VideoInfo2) {
                    VIDEOINFOHEADER2 *VidInfoHdr = (VIDEOINFOHEADER2*)pmt->Format ();
        
                    m_ImageSizeList[0].size.cx = VidInfoHdr->bmiHeader.biWidth;
                    m_ImageSizeList[0].size.cy = VidInfoHdr->bmiHeader.biHeight;
                }
                else if (*pmt->FormatType() == FORMAT_MPEGVideo) {
                    MPEG1VIDEOINFO *MPEG1VideoInfo = (MPEG1VIDEOINFO*)pmt->Format ();
                    VIDEOINFOHEADER *VidInfoHdr = &MPEG1VideoInfo->hdr;
        
                    m_ImageSizeList[0].size.cx = VidInfoHdr->bmiHeader.biWidth;
                    m_ImageSizeList[0].size.cy = VidInfoHdr->bmiHeader.biHeight;
                }
                else if (*pmt->FormatType() == FORMAT_MPEG2Video) {
                    MPEG2VIDEOINFO *MPEG2VideoInfo = (MPEG2VIDEOINFO*)pmt->Format ();
                    VIDEOINFOHEADER2 *VidInfoHdr = &MPEG2VideoInfo->hdr;
        
                    m_ImageSizeList[0].size.cx = VidInfoHdr->bmiHeader.biWidth;
                    m_ImageSizeList[0].size.cy = VidInfoHdr->bmiHeader.biHeight;
                }
                else {
                    ASSERT (*pmt->FormatType() == FORMAT_VideoInfo  || 
                            *pmt->FormatType() == FORMAT_VideoInfo2 ||
                            *pmt->FormatType() == FORMAT_MPEGVideo  ||
                            *pmt->FormatType() == FORMAT_MPEG2Video );
                }
            }
            for (k = 0; k < NumberOfImageSizes; k++) {
                if (ValidateImageSize (&m_RangeCaps, &m_ImageSizeList[k].size)) {
                     m_ImageSizeList[k].Flags = STDIMGSIZE_VALID;
                     m_ImageSizeList[k].RangeIndex = j;
                }
            }
    
            DeleteMediaType (pmt);
        }
    }

    for (k = 0; k < NumberOfImageSizes; k++) {
        int index;

        if (m_ImageSizeList[k].Flags & STDIMGSIZE_VALID) {
            _stprintf (buf, (k == 0) ? TEXT ("%d x %d  (default)") : TEXT("%d x %d"), m_ImageSizeList[k].size.cx, m_ImageSizeList[k].size.cy);
            ComboBox_AddString (m_hWndOutputSize, buf);
            // The item data is the index in the master table
            index = ComboBox_GetCount(m_hWndOutputSize) - 1;
            ComboBox_SetItemData(m_hWndOutputSize, 
                    index, k);
            if (m_ImageSizeList[k].size.cx == m_CurrentWidth) {
                IndexOfCurrentMediaType = index;
            }

        }
    }
    ComboBox_SetCurSel (m_hWndOutputSize, IndexOfCurrentMediaType); 

    hr = OnImageSizeChanged ();

    return hr;
}

// Whenever the image size changes, reinit the framerate list

HRESULT
CVideoStreamConfigProperties::OnImageSizeChanged ()
{
    int     SelectedSizeIndex;
    int     SizeTableIndex;
    int     SelectedColorFormatIndex;
    int     RangeIndex;
    SIZE    SizeImage;
    HRESULT hr;

    if (!m_pVideoStreamConfig || !m_CanSetFormat)
        return S_FALSE;

    SelectedSizeIndex = ComboBox_GetCurSel (m_hWndOutputSize);
    SizeTableIndex = (int)ComboBox_GetItemData (m_hWndOutputSize, SelectedSizeIndex);

    SelectedColorFormatIndex = ComboBox_GetCurSel (m_hWndCompression);
    RangeIndex = m_ImageSizeList[SizeTableIndex].RangeIndex;

    SizeImage.cx = m_ImageSizeList[SizeTableIndex].size.cx;
    SizeImage.cy = m_ImageSizeList[SizeTableIndex].size.cy;

    hr = CreateFrameRateList (RangeIndex, SizeImage);

    return hr;
}


BOOL 
CVideoStreamConfigProperties::ValidateImageSize(
   VIDEO_STREAM_CONFIG_CAPS * pVideoCfgCaps, 
   SIZE * pSize)
{
   if (pVideoCfgCaps->OutputGranularityX == 0 || pVideoCfgCaps->OutputGranularityY == 0) {

      // Support only one size for this DataRangeVideo
      if (pVideoCfgCaps->InputSize.cx == pSize->cx && 
          pVideoCfgCaps->InputSize.cy == pSize->cy ) {

         return TRUE;
        }
      else {
         return FALSE;
        }
   } 
    else {   
      // Support multiple sizes so make sure that that fit the criteria
      if (pVideoCfgCaps->MinOutputSize.cx <= pSize->cx && 
         pSize->cx <= pVideoCfgCaps->MaxOutputSize.cx &&
         pVideoCfgCaps->MinOutputSize.cy <= pSize->cy && 
         pSize->cy <= pVideoCfgCaps->MaxOutputSize.cy &&   
         ((pSize->cx % pVideoCfgCaps->OutputGranularityX) == 0) &&
         ((pSize->cy % pVideoCfgCaps->OutputGranularityY) == 0)) {

         return TRUE;
        }
      else {
         return FALSE;
        }
   }
}


// Fill the list boxes with all of the format information
HRESULT
CVideoStreamConfigProperties::InitDialog ()
{
    TCHAR  *ptc;
    HRESULT hr;

    // Capture format window handles
    m_hWndVideoStandards = GetDlgItem (m_hwnd, IDC_FORMAT_VideoStandard);;
    m_hWndCompression = GetDlgItem (m_hwnd, IDC_FORMAT_Compression);
    m_hWndOutputSize = GetDlgItem (m_hwnd, IDC_FORMAT_OutputSize);
    m_hWndFrameRate = GetDlgItem (m_hwnd, IDC_FORMAT_FrameRate);
    m_hWndFrameRateSpin = GetDlgItem (m_hwnd, IDC_FORMAT_FrameRateSpin);
    m_hWndFlipHorizontal = GetDlgItem (m_hwnd, IDC_FORMAT_FlipHorizontal);

    // Compression window handles
    m_hWndStatus = GetDlgItem (m_hwnd, IDC_Status);
    m_hWndIFrameInterval = GetDlgItem (m_hwnd, IDC_COMPRESSION_IFrameInterval);
    m_hWndIFrameIntervalSpin = GetDlgItem (m_hwnd, IDC_COMPRESSION_IFrameIntervalSpin);
    m_hWndPFrameInterval = GetDlgItem (m_hwnd, IDC_COMPRESSION_PFrameInterval);
    m_hWndPFrameIntervalSpin = GetDlgItem (m_hwnd, IDC_COMPRESSION_PFrameIntervalSpin);
    m_hWndQuality = GetDlgItem (m_hwnd, IDC_COMPRESSION_Quality_Edit);
    m_hWndQualitySlider = GetDlgItem (m_hwnd, IDC_COMPRESSION_Quality_Slider);

    if (m_pAnalogVideoDecoder) {
        if (SUCCEEDED (hr = m_pAnalogVideoDecoder->get_TVFormat( 
            &m_VideoStandardCurrent))) {
        }
    }

    // Enumerate all of the dataranges

    hr = InitialRangeScan ();

    // 24 May 99, jaybo
    // Moved these functions earlier so that we can detect whether the existing
    // format is valid, and hence disable the controls if necessary

    OnVideoStandardChanged ();
    OnCompressionChanged ();

    // Disable controls which are unavailable
    if (FAILED (hr) || !m_CanSetFormat || !m_pVideoStreamConfig || !m_VideoStandardsList || !m_SubTypeList) {
        EnableWindow (m_hWndVideoStandards, FALSE);
        EnableWindow (m_hWndCompression, FALSE);
        EnableWindow (m_hWndOutputSize, FALSE);
        EnableWindow (m_hWndFrameRate, FALSE);
        EnableWindow (m_hWndFrameRateSpin, FALSE);
    }
    if (!m_pVideoCompression) {
        // No compression interface available
        EnableWindow (m_hWndIFrameInterval, FALSE);
        EnableWindow (m_hWndIFrameIntervalSpin, FALSE);
        EnableWindow (m_hWndPFrameInterval, FALSE);
        EnableWindow (m_hWndPFrameIntervalSpin, FALSE);
        EnableWindow (m_hWndQuality, FALSE);
        EnableWindow (m_hWndQualitySlider, FALSE);
    }
    else {
        TCHAR buf[80];
        WCHAR pszVersion [160];
        int cbVersion = sizeof (pszVersion)/sizeof(WCHAR);
        WCHAR pszDescription[160];
        int cbDescription = sizeof (pszDescription)/sizeof(WCHAR);

        hr = m_pVideoCompression->GetInfo( 
            pszVersion,
            &cbVersion,
            pszDescription,
            &cbDescription,
            &m_KeyFrameRate,
            &m_PFramesPerKeyFrame,
            &m_Quality,
            &m_CompressionCapabilities);
        
        if (hr == S_OK) {
            if (m_CompressionCapabilities & KS_CompressionCaps_CanKeyFrame) {
                // IFrameInterval
                hr = m_pVideoCompression->get_KeyFrameRate (&m_KeyFrameRate);
                _stprintf (buf, TEXT("%d"), m_KeyFrameRate);
                Edit_SetText(m_hWndIFrameInterval, buf);  
                SendMessage (m_hWndIFrameIntervalSpin, 
                            UDM_SETRANGE, 0L, 
                            MAKELONG (1000, 1));
                SendMessage (m_hWndIFrameIntervalSpin, 
                            UDM_SETPOS, 0, 
                            MAKELONG( m_KeyFrameRate, 0));
                SendMessage (m_hWndIFrameIntervalSpin, 
                            UDM_SETBUDDY, WPARAM (m_hWndIFrameInterval), 0);
            }
            else {
                EnableWindow (m_hWndIFrameInterval, FALSE);
                EnableWindow (m_hWndIFrameIntervalSpin, FALSE);
            }
            if (m_CompressionCapabilities & KS_CompressionCaps_CanBFrame) {
                // PFrameInterval
                hr = m_pVideoCompression->get_PFramesPerKeyFrame (&m_PFramesPerKeyFrame);
                _stprintf (buf, TEXT("%d"), m_PFramesPerKeyFrame);
                Edit_SetText(m_hWndPFrameInterval, buf);  
                SendMessage (m_hWndPFrameIntervalSpin, 
                            UDM_SETRANGE, 0L, 
                            MAKELONG (1000, 1));
                SendMessage (m_hWndPFrameIntervalSpin, 
                            UDM_SETPOS, 0,
                            MAKELONG (m_PFramesPerKeyFrame, 0));
                SendMessage (m_hWndPFrameIntervalSpin, 
                            UDM_SETBUDDY, WPARAM (m_hWndPFrameInterval), 0);
            }
            else {
                EnableWindow (m_hWndPFrameInterval, FALSE);
                EnableWindow (m_hWndPFrameIntervalSpin, FALSE);
            }
            if (m_CompressionCapabilities & KS_CompressionCaps_CanQuality) {
                // Quality
                hr = m_pVideoCompression->get_Quality (&m_Quality);
                _stprintf (buf, TEXT("%.3lf"), m_Quality);
                Edit_SetText(m_hWndQuality, buf);  
                
                SendMessage(m_hWndQualitySlider, TBM_SETRANGE, FALSE, 
                    MAKELONG(0, 1000) );
                SendMessage(m_hWndQualitySlider, TBM_SETPOS, TRUE, 
                    (LPARAM) (m_Quality * 1000));
                SendMessage(m_hWndQualitySlider, TBM_SETLINESIZE, FALSE, (LPARAM) 100);
                SendMessage(m_hWndQualitySlider, TBM_SETPAGESIZE, FALSE, (LPARAM) 100);
            }
        }
    }

    // IAMVideoControl gets the framerate list and flip image capabilities
    if (m_pVideoControl) {
        if (SUCCEEDED (m_pVideoControl->GetCaps(m_pPin, &m_VideoControlCaps))) {
            hr = m_pVideoControl->GetMode(m_pPin, &m_VideoControlCurrent);
            ASSERT (SUCCEEDED (hr));
        }
    }
    if ((m_VideoControlCaps & VideoControlFlag_FlipHorizontal) == 0) {
        EnableWindow (m_hWndFlipHorizontal, FALSE);
    }
    else {
        Button_SetCheck(m_hWndFlipHorizontal, 
            m_VideoControlCurrent & VideoControlFlag_FlipHorizontal);
    }

    ptc = StringFromTVStandard (m_VideoStandardCurrent);
    if ( !ptc )
		ptc = TEXT("[Unknown]");

	Static_SetText(m_hWndVideoStandards, ptc);
    
    return hr;
}



//
// OnConnect
//
// Give us the filter to communicate with

HRESULT 
CVideoStreamConfigProperties::OnConnect(IUnknown *pUnknown)
{
    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_IAMStreamConfig,(void **)&m_pVideoStreamConfig);
    if (FAILED(hr)) {
        return hr;
    }

    // Only available if pin supports the property set
    hr = pUnknown->QueryInterface(IID_IAMVideoCompression,(void **)&m_pVideoCompression);

    //
    // See if IAMAnalogVideoDecoder or IAMVideoConfig
    // is available on the parent filter
    //
    PIN_INFO PinInfo;
    hr = pUnknown->QueryInterface(IID_IPin,(void **)&m_pPin);
    if (FAILED(hr)) {
        return hr;
    }

    if (SUCCEEDED (hr = m_pPin->QueryPinInfo(&PinInfo))) {
        // Only available if device supports the property set
        hr = PinInfo.pFilter->QueryInterface(
                            IID_IAMAnalogVideoDecoder, 
                            (void **) &m_pAnalogVideoDecoder);
#if 1
        if (FAILED (hr)) {
            // Special case for Philips 7146 and other devices which separate the 
            // analog video decoder from the bus master device, 
            // Look upstream for IAMAnalogVideoDecoder by creating an ICaptureGraphBuilder, 
            // attaching the current graph and have it do the work of searching
            ICaptureGraphBuilder *pCaptureBuilder;
            hr = CoCreateInstance((REFCLSID)CLSID_CaptureGraphBuilder,
                        NULL, CLSCTX_INPROC, (REFIID)IID_ICaptureGraphBuilder,
                        (void **)&pCaptureBuilder);
            if (SUCCEEDED (hr)) {
                FILTER_INFO FilterInfo;
                hr = PinInfo.pFilter->QueryFilterInfo (&FilterInfo);
                if (SUCCEEDED (hr)) {
                    IGraphBuilder *pGraphBuilder;
                    hr = FilterInfo.pGraph->QueryInterface(
                                        IID_IGraphBuilder, 
                                        (void **) &pGraphBuilder);
                    if (SUCCEEDED (hr)) {
                        hr = pCaptureBuilder->SetFiltergraph(pGraphBuilder);
                        if (SUCCEEDED (hr)) {
                            hr = pCaptureBuilder->FindInterface(&LOOK_UPSTREAM_ONLY,
                                PinInfo.pFilter, 
                                IID_IAMAnalogVideoDecoder, 
                                (void **)&m_pAnalogVideoDecoder);
                        }
                        pGraphBuilder->Release();
                    }
                    FilterInfo.pGraph->Release();
                }
                pCaptureBuilder->Release();
            }
        }
#endif        
        // Only available if device supports the property set
        hr = PinInfo.pFilter->QueryInterface(
                            IID_IAMVideoControl,
                            (void **)&m_pVideoControl);
    
        PinInfo.pFilter->Release();
    }

    m_ImageSizeList = new IMAGESIZE [NumberOfImageSizes];

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT 
CVideoStreamConfigProperties::OnDisconnect()
{
    // Release the interface

    if (m_pVideoStreamConfig != NULL) {
        m_pVideoStreamConfig->Release();
        m_pVideoStreamConfig = NULL;
    }

    if (m_pVideoCompression != NULL) {
        m_pVideoCompression->Release();
        m_pVideoCompression = NULL;
    }

    if (m_pVideoControl != NULL) {
        m_pVideoControl->Release();
        m_pVideoControl = NULL;
    }

    if (m_pAnalogVideoDecoder != NULL) {
        m_pAnalogVideoDecoder->Release();
        m_pAnalogVideoDecoder = NULL;
    }

    if (m_VideoStandardsList) {
        delete[] m_VideoStandardsList;
        m_VideoStandardsList = NULL;
    }

    if (m_SubTypeList) {
        delete[] m_SubTypeList;
        m_SubTypeList = NULL;
    }

    if (m_ImageSizeList) {
        delete[] m_ImageSizeList;
        m_ImageSizeList = NULL;
    }

    if (m_CurrentMediaType) {
        DeleteMediaType (m_CurrentMediaType);
        m_CurrentMediaType = NULL;
    }    

    if (m_FrameRateList) {
        delete[] m_FrameRateList;
        m_FrameRateList = NULL;
    }

    if (m_pPin) {
        m_pPin->Release();
        m_pPin = NULL;
    }
    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT 
CVideoStreamConfigProperties::OnActivate(void)
{
    // Create all of the controls


    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CVideoStreamConfigProperties::OnDeactivate(void)
{

    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT 
CVideoStreamConfigProperties::OnApplyChanges(void)
{
    int     SelectedSizeIndex;
    int     SizeTableIndex;
    int     SelectedColorFormatIndex;
    int     RangeIndex;
    HRESULT hr;

    if (m_CanSetFormat) {
        SelectedSizeIndex = ComboBox_GetCurSel (m_hWndOutputSize);
        SizeTableIndex = (int)ComboBox_GetItemData (m_hWndOutputSize, SelectedSizeIndex);
    
        SelectedColorFormatIndex = ComboBox_GetCurSel (m_hWndCompression);
        RangeIndex = m_ImageSizeList[SizeTableIndex].RangeIndex;
    
        CMediaType * pmt = NULL;
        
        hr = m_pVideoStreamConfig->GetStreamCaps (RangeIndex, 
                        (AM_MEDIA_TYPE **) &pmt, 
                        (BYTE *)&m_RangeCaps);
        
        if (FAILED (hr)) {
            return S_FALSE;
        }
    
        if (*pmt->FormatType() == FORMAT_VideoInfo) {
            VIDEOINFOHEADER *VidInfoHdr = (VIDEOINFOHEADER*) pmt->Format();
    
            VidInfoHdr->bmiHeader.biWidth  = m_ImageSizeList[SizeTableIndex].size.cx;
            VidInfoHdr->bmiHeader.biHeight = m_ImageSizeList[SizeTableIndex].size.cy;
            VidInfoHdr->AvgTimePerFrame = (REFERENCE_TIME) ((1.0 / m_FramesPerSec) * 1e7);
        }
        else if (*pmt->FormatType() == FORMAT_VideoInfo2) {
            VIDEOINFOHEADER2 *VidInfoHdr = (VIDEOINFOHEADER2*)pmt->Format ();
    
            VidInfoHdr->bmiHeader.biWidth  = m_ImageSizeList[SizeTableIndex].size.cx;
            VidInfoHdr->bmiHeader.biHeight = m_ImageSizeList[SizeTableIndex].size.cy;
            VidInfoHdr->AvgTimePerFrame = (REFERENCE_TIME) ((1.0 / m_FramesPerSec) * 1e7);
        }
        else if (*pmt->FormatType() == FORMAT_MPEGVideo) {
            MPEG1VIDEOINFO *MPEG1VideoInfo = (MPEG1VIDEOINFO*)pmt->Format ();
            VIDEOINFOHEADER *VidInfoHdr = &MPEG1VideoInfo->hdr;

            VidInfoHdr->bmiHeader.biWidth  = m_ImageSizeList[SizeTableIndex].size.cx;
            VidInfoHdr->bmiHeader.biHeight = m_ImageSizeList[SizeTableIndex].size.cy;
            VidInfoHdr->AvgTimePerFrame = (REFERENCE_TIME) ((1.0 / m_FramesPerSec) * 1e7);
        }
        else if (*pmt->FormatType() == FORMAT_MPEG2Video) {
            MPEG2VIDEOINFO *MPEG2VideoInfo = (MPEG2VIDEOINFO*)pmt->Format ();
            VIDEOINFOHEADER2 *VidInfoHdr = &MPEG2VideoInfo->hdr;
            
            VidInfoHdr->bmiHeader.biWidth  = m_ImageSizeList[SizeTableIndex].size.cx;
            VidInfoHdr->bmiHeader.biHeight = m_ImageSizeList[SizeTableIndex].size.cy;
            VidInfoHdr->AvgTimePerFrame = (REFERENCE_TIME) ((1.0 / m_FramesPerSec) * 1e7);
        }
        else {
            ASSERT (*pmt->FormatType() == FORMAT_VideoInfo  || 
                    *pmt->FormatType() == FORMAT_VideoInfo2 ||
                    *pmt->FormatType() == FORMAT_MPEGVideo  ||
                    *pmt->FormatType() == FORMAT_MPEG2Video );
        }

#if 0
        //
        // On Win98 prior to OSR1, ie GOLD we must call PerformDataIntersection.  
        // Note that in OSR1 (and NT) KsProxy was updated to perform a DataIntersection on a ::SetFormat internally.
        //

        OSVERSIONINFO VerInfo;
        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        GetVersionEx (&VerInfo);

        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {

            // Perform the data intersection, which allows the driver to set
            // the biSizeImage field
            
            hr = PerformDataIntersection(
                    m_pPin,
                    RangeIndex,
                    pmt);
        
            ASSERT (SUCCEEDED (hr));
        
            if (FAILED(hr)) {
                DeleteMediaType (pmt);
                return hr;
            }
        }
#endif
    
        hr = m_pVideoStreamConfig->SetFormat(pmt);
        if (FAILED (hr)) {
            TCHAR TitleBuf[256];
            TCHAR TextBuf[256];
    
            LoadString(g_hInst, IDS_ERROR_CONNECTING_TITLE, TitleBuf, sizeof (TitleBuf)/sizeof(TCHAR));
            LoadString(g_hInst, IDS_ERROR_CONNECTING, TextBuf, sizeof (TextBuf)/sizeof(TCHAR));
            MessageBox (NULL, TextBuf, TitleBuf, MB_OK);
        }
    
        DeleteMediaType (pmt);
    
        GetCurrentMediaType ();
    }

    // Set the horizontal flip using IAMVideoControl
    if (IsWindowEnabled (m_hWndFlipHorizontal)) { 
        hr = m_pVideoControl->GetMode(m_pPin, &m_VideoControlCurrent);
        ASSERT (SUCCEEDED (hr));

        // clear the flipped bit and then reset it according to checkbox
        m_VideoControlCurrent &= ~VideoControlFlag_FlipHorizontal;
        m_VideoControlCurrent |= 
                (BST_CHECKED & Button_GetState(m_hWndFlipHorizontal)) ?
                VideoControlFlag_FlipHorizontal : 0;
        
        hr = m_pVideoControl->SetMode(m_pPin, m_VideoControlCurrent);
    }
    
    // Now set the compression properties
    if (m_pVideoCompression) {
        BOOL Translated;
        TCHAR buf[80];

        // IFrameInterval
        if (m_CompressionCapabilities & KS_CompressionCaps_CanKeyFrame) {
            m_KeyFrameRate = (long) GetDlgItemInt (m_hwnd, IDC_COMPRESSION_IFrameInterval, &Translated, FALSE);
            hr = m_pVideoCompression->put_KeyFrameRate (m_KeyFrameRate);
            ASSERT (SUCCEEDED (hr));
            hr = m_pVideoCompression->get_KeyFrameRate (&m_KeyFrameRate);
            ASSERT (SUCCEEDED (hr));
            _stprintf (buf, TEXT("%d"), m_KeyFrameRate);
            Edit_SetText(m_hWndIFrameInterval, buf);  
        }

        // PFrameInterval
        if (m_CompressionCapabilities & KS_CompressionCaps_CanBFrame) {
            m_PFramesPerKeyFrame = (long) GetDlgItemInt (m_hwnd, IDC_COMPRESSION_PFrameInterval, &Translated, FALSE);
            hr = m_pVideoCompression->put_PFramesPerKeyFrame (m_PFramesPerKeyFrame);
            ASSERT (SUCCEEDED (hr));
            hr = m_pVideoCompression->get_PFramesPerKeyFrame (&m_PFramesPerKeyFrame);
            ASSERT (SUCCEEDED (hr));
            _stprintf (buf, TEXT("%d"), m_PFramesPerKeyFrame);
            Edit_SetText(m_hWndPFrameInterval, buf);  
        }

        // Quality
        Edit_GetText(m_hWndQuality, buf, sizeof (buf)/sizeof(TCHAR));
        TCHAR *StopScan;
        m_Quality = _tcstod (buf, &StopScan);
        hr = m_pVideoCompression->put_Quality (m_Quality);
        ASSERT (SUCCEEDED (hr));
        hr = m_pVideoCompression->get_Quality (&m_Quality);
        ASSERT (SUCCEEDED (hr));
        _stprintf (buf, TEXT("%.3lf"), m_Quality);
        Edit_SetText(m_hWndQuality, buf);  
        SendMessage(m_hWndQualitySlider, TBM_SETPOS, TRUE, 
            (LPARAM) (m_Quality * 1000));

    }
    
    return NOERROR;
}

//
// Since IAMStreamConfig::GetFormat only returns a valid
// setting after IAMStreamConfig::SetFormat has been called,
// this function will return try to use GetFormat, and if that
// fails, will just return the default format for the first
// datarange.
//
// Sets m_CurrentFormat, m_CurrentWidth, m_CurrentHeight, m_FramesPerSec
//
// m_CanSetFormat is TRUE on exit if we understand the internals of this format
//
HRESULT 
CVideoStreamConfigProperties::GetCurrentMediaType (void)
{
    HRESULT hr;

    m_CanSetFormat = FALSE;

    if (m_CurrentMediaType) {
        DeleteMediaType (m_CurrentMediaType);
        m_CurrentMediaType = NULL;
    }

    // This gets either a previously set format, the connected format, 
    // or the 0th format if one hasn't been set via ::SetFormat and the pin is unconnected
    hr = m_pVideoStreamConfig->GetFormat ((AM_MEDIA_TYPE**) &m_CurrentMediaType);

    //
    // Only perform the scan and match of TVFormats the first time through
    //
    if (m_pAnalogVideoDecoder && m_FirstGetCurrentMediaType) {
        ULONG VideoStandard = 0;
        AM_MEDIA_TYPE * pmtTemp = NULL;
        BOOL fFirst = TRUE;

        VIDEO_STREAM_CONFIG_CAPS RangeCaps;

        m_pAnalogVideoDecoder->get_TVFormat((long *) &VideoStandard);

        // Get the first MediaType and see if it matches ::GetFormat()
        // to verify whether the format has been previously set or not
        hr = m_pVideoStreamConfig->GetStreamCaps (0, 
            &pmtTemp, 
            (BYTE *)&RangeCaps);

        if (SUCCEEDED(hr)) {
           const CMediaType *cmtTemp = (CMediaType*) pmtTemp;

           if (*m_CurrentMediaType == *cmtTemp) {
              AM_MEDIA_TYPE *pmtTemp2;
      
              // we're using the 0th DATARANGE with an analog video decoder
              // so we have to search for DATARANGE that matches the video standard 
              // currently in use

              for (int j = 0; j < m_RangeCount; j++) {
                  pmtTemp2 = NULL;
                  hr = m_pVideoStreamConfig->GetStreamCaps (j, 
                      (AM_MEDIA_TYPE**) &pmtTemp2, 
                      (BYTE *)&RangeCaps);
      
                  if ((RangeCaps.VideoStandard &  (ULONG) VideoStandard) || 
                      (RangeCaps.VideoStandard == VideoStandard)) {
                        // found a match, use this as the default format
                        DeleteMediaType (m_CurrentMediaType);
                        m_CurrentMediaType = (CMediaType*) pmtTemp2;
                        break;
                  }
                  else {
                     DeleteMediaType (pmtTemp2);
                  }
               }
           }
           DeleteMediaType (pmtTemp);
        } 
    } // endif analog video decoder

    if (SUCCEEDED (hr)) {
        if ((*m_CurrentMediaType->FormatType() == FORMAT_VideoInfo) &&
            (*m_CurrentMediaType->Type()       == MEDIATYPE_Video)) {
            VIDEOINFOHEADER *VidInfoHdr = (VIDEOINFOHEADER*) m_CurrentMediaType->Format();

            m_CurrentWidth = VidInfoHdr->bmiHeader.biWidth;
            m_CurrentHeight = VidInfoHdr->bmiHeader.biHeight;
            m_DefaultAvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
            ASSERT (m_DefaultAvgTimePerFrame != 0);
            m_FramesPerSec =  1.0 / ((double) m_DefaultAvgTimePerFrame / 1e7);
            m_CanSetFormat = TRUE;
        }
        else if ((*m_CurrentMediaType->FormatType() == FORMAT_VideoInfo2) &&
                 (*m_CurrentMediaType->Type()       == MEDIATYPE_Video)) {
            VIDEOINFOHEADER2 *VidInfoHdr = (VIDEOINFOHEADER2*)m_CurrentMediaType->Format ();

            m_CurrentWidth = VidInfoHdr->bmiHeader.biWidth;
            m_CurrentHeight = VidInfoHdr->bmiHeader.biHeight;
            m_DefaultAvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
            ASSERT (m_DefaultAvgTimePerFrame != 0);
            m_FramesPerSec =  1.0 / ((double) m_DefaultAvgTimePerFrame / 1e7);
            m_CanSetFormat = TRUE;
        }
        else if ((*m_CurrentMediaType->FormatType() == FORMAT_MPEGVideo) &&
                 (*m_CurrentMediaType->Type()       == MEDIATYPE_Video)) {
            MPEG1VIDEOINFO *MPEG1VideoInfo = (MPEG1VIDEOINFO*)m_CurrentMediaType->Format ();
            VIDEOINFOHEADER *VidInfoHdr = &MPEG1VideoInfo->hdr;

            m_CurrentWidth = VidInfoHdr->bmiHeader.biWidth;
            m_CurrentHeight = VidInfoHdr->bmiHeader.biHeight;
            m_DefaultAvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
            ASSERT (m_DefaultAvgTimePerFrame != 0);
            m_FramesPerSec =  1.0 / ((double) m_DefaultAvgTimePerFrame / 1e7);
            m_CanSetFormat = TRUE;
        }
        else if ((*m_CurrentMediaType->FormatType() == FORMAT_MPEG2Video) &&
                 (*m_CurrentMediaType->Type()       == MEDIATYPE_Video)) {
            MPEG2VIDEOINFO *MPEG2VideoInfo = (MPEG2VIDEOINFO*)m_CurrentMediaType->Format ();
            VIDEOINFOHEADER2 *VidInfoHdr = &MPEG2VideoInfo->hdr;

            m_CurrentWidth = VidInfoHdr->bmiHeader.biWidth;
            m_CurrentHeight = VidInfoHdr->bmiHeader.biHeight;
            m_DefaultAvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
            ASSERT (m_DefaultAvgTimePerFrame != 0);
            m_FramesPerSec =  1.0 / ((double) m_DefaultAvgTimePerFrame / 1e7);
            m_CanSetFormat = TRUE;
        }
        else {
            const GUID      *SubType = m_CurrentMediaType->Subtype();
            ULONG            Data1 = SubType->Data1;
            TCHAR           *DShowName = GetSubtypeName(SubType);

            // Hack alert.  GetSubtypeName returns "UNKNOWN" if it isn't among the hardcoded
            // list of known RGB formats.  If this string ever changes, we're hosed!

            if (0 == lstrcmp (DShowName, TEXT ("UNKNOWN"))) {
                if (Data1 == 0) {
                    lstrcpy (m_UnsupportedTypeName, TEXT ("UNKNOWN"));
                } else {
                    _stprintf (m_UnsupportedTypeName, TEXT("%c%c%c%c"), 
                                (BYTE) ( Data1        & 0xff),
                                (BYTE) ((Data1 >> 8)  & 0xff),
                                (BYTE) ((Data1 >> 16) & 0xff),
                                (BYTE) ((Data1 >> 24) & 0xff));
                }
            }
            else {
                lstrcpyn (m_UnsupportedTypeName, DShowName, sizeof (m_UnsupportedTypeName));
            }
            hr = S_FALSE;
        }
    }

    m_FirstGetCurrentMediaType = FALSE;

    return hr;
}

// Called whenever a new data range is selected to create a list of available frame rates
// Fills a list with either the driver supplied list of frame rates,
// or with the available frame rates within the default list.

HRESULT
CVideoStreamConfigProperties::CreateFrameRateList (int RangeIndex, SIZE SizeImage)
{
    int     j, k;
    HRESULT hr;

    CMediaType * pmt = NULL;
    
    hr = m_pVideoStreamConfig->GetStreamCaps (RangeIndex, 
                    (AM_MEDIA_TYPE **) &pmt, 
                    (BYTE *)&m_RangeCaps);

    DeleteMediaType (pmt);
    
    m_MaxFrameRate = 1.0 / (m_RangeCaps.MinFrameInterval / 1e7);
    m_MinFrameRate = 1.0 / (m_RangeCaps.MaxFrameInterval / 1e7);
    m_DefaultFrameRate = 1.0 / (m_DefaultAvgTimePerFrame / 1e7);

    if (m_FrameRateList) {
        delete[] m_FrameRateList;
        m_FrameRateList = NULL;
    }

    // See if the driver can provide a frame rate list
    if (m_pVideoControl) {
        LONGLONG * FrameRates;
        long ListSize;

        if (SUCCEEDED (hr = m_pVideoControl->GetFrameRateList( 
                    m_pPin,
                    RangeIndex,
                    SizeImage,
                    &ListSize,
                    &FrameRates) )) 
        {


            m_FrameRateListSize = (int) ListSize;
            m_FrameRateList = new double [m_FrameRateListSize];
            if (!m_FrameRateList) {
                return E_FAIL;
            }

            // Copy from the default list into the available list
            for (j = 0; j < m_FrameRateListSize; j++) {
                if (FrameRates[j] == 0 ) {
                    m_FrameRateList[j] = 0.0;
                }
                else {
                    m_FrameRateList[j] = 1.0 / (FrameRates[j] / 1e7); 
                }
            }

            // free the memory allocated for the frameratelist
            CoTaskMemFree(FrameRates);
        }
    }

    //
    // Driver didn't supply a list, create a default list
    //
    if (m_FrameRateList == NULL) {
        // First figure out how many of the default rates 
        // are within the current DataRange
        for (j = k = 0; j < DefaultFrameRateListSize; j++) {
            if (DefaultFrameRateList [j] >= m_MinFrameRate && 
                DefaultFrameRateList [j] <= m_MaxFrameRate) {
                k++;
            }
        }
        if (k == 0) // handle single framerates
            k = 1;

        m_FrameRateListSize = k;
        m_FrameRateList = new double [m_FrameRateListSize];
        if (!m_FrameRateList) {
            return E_FAIL;
        }

        // Copy from the default list into the available list
        for (j = k = 0; j < DefaultFrameRateListSize; j++) {
            if (DefaultFrameRateList [j] >= m_MinFrameRate && 
                DefaultFrameRateList [j] <= m_MaxFrameRate) {
                m_FrameRateList[k] = DefaultFrameRateList [j];
                k++;
            }
        }
        if (k == 0) {  // the case of no matches
            m_FrameRateList[0] = m_DefaultFrameRate;
        }
    }

    SendMessage (m_hWndFrameRateSpin, 
                UDM_SETRANGE, 0L, 
                MAKELONG (m_FrameRateListSize - 1, 0));

    // Find the index of the default capture rate 
    for (j = k = 0; j < m_FrameRateListSize; j++) {
        if (m_FrameRateList [j] >= m_DefaultFrameRate - 0.0001 /* fudge */) {
            k = j;  
            break;
        }
    }

    SendMessage( m_hWndFrameRateSpin, 
                UDM_SETPOS, 0L, 
                MAKELONG( k, 0));

    OnFrameRateChanged (k);

    return S_OK;
}

BOOL 
CVideoStreamConfigProperties::OnFrameRateChanged (int Value)
{
    if (Value < 0)
        Value = 0;
    else if (Value >= m_FrameRateListSize)
        Value = m_FrameRateListSize - 1;

    m_FramesPerSec = m_FrameRateList [Value];

    TCHAR buf [80];
    _stprintf (buf, TEXT("%.3lf"), m_FramesPerSec);
    Edit_SetText (m_hWndFrameRate, buf);

    return TRUE;
}

//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR
CVideoStreamConfigProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    int iNotify = HIWORD (wParam);
    TCHAR buf [80];

    switch (uMsg) {

    case WM_INITDIALOG:
        m_hwnd = hwnd;
        InitDialog ();   // fill the listboxes
        return (INT_PTR)TRUE;    // I don't call setfocus...

    case WM_NOTIFY:
        {
            int idCtrl = (int) wParam;    
            LPNMUPDOWN lpnmud = (LPNMUPDOWN) lParam;
            if (lpnmud->hdr.hwndFrom == m_hWndFrameRateSpin) {
                OnFrameRateChanged (lpnmud->iPos + lpnmud->iDelta);
                SetDirty();
            }
        }
        break;

    case WM_VSCROLL:
    case WM_HSCROLL:
        {
        int pos;
        int command = LOWORD (wParam);
    
        ASSERT (IsWindow ((HWND) lParam));
        if ((HWND) lParam != m_hWndQualitySlider)
            return (INT_PTR)FALSE;

        if (command != TB_ENDTRACK &&
            command != TB_THUMBTRACK &&
            command != TB_LINEDOWN &&
            command != TB_LINEUP &&
            command != TB_PAGEUP &&
            command != TB_PAGEDOWN)
                return (INT_PTR)FALSE;
            
        pos = (int) SendMessage(m_hWndQualitySlider, TBM_GETPOS, 0, 0L);
    
        m_Quality = (double) pos / 1000;
        _stprintf (buf, TEXT("%.3lf"), m_Quality);
        Edit_SetText(m_hWndQuality, buf);  
        
        }
        break;

    case WM_COMMAND:
              
        iNotify = HIWORD (wParam);
        switch (LOWORD(wParam)) {

        case IDC_FORMAT_FrameRate:
            if (iNotify == EN_KILLFOCUS) {
                BOOL Changed = FALSE;

                Edit_GetText(m_hWndFrameRate, buf, sizeof (buf)/sizeof(TCHAR));
                TCHAR *StopScan;
                m_FramesPerSec = _tcstod (buf, &StopScan);
                if (m_FramesPerSec < m_MinFrameRate) {
                    m_FramesPerSec = m_MinFrameRate;
                    Changed = TRUE;
                }
                else if (m_FramesPerSec > m_MaxFrameRate) {
                    m_FramesPerSec = m_MaxFrameRate;
                    Changed = TRUE;
                }
                if (Changed) {
                    _stprintf (buf, TEXT("%.3lf"), m_FramesPerSec);
                    Edit_SetText (m_hWndFrameRate, buf);
                }
            }
            break;

        case IDC_FORMAT_Compression:
            if (iNotify == CBN_SELCHANGE) {
                OnCompressionChanged ();
            }
            break;

        case IDC_FORMAT_OutputSize:
            if (iNotify == CBN_SELCHANGE) {
                OnImageSizeChanged ();
            }
            break;
#if 0
        // These don't need to be handled dynamically
        // just read the current settings on Apply
        case IDC_COMPRESSION_IFrameInterval:
            if (iNotify == EN_KILLFOCUS) {
                // Add edit field range validation as a nicety.            }
      
            break;

        case IDC_COMPRESSION_PFrameInterval:
            if (iNotify == EN_KILLFOCUS) {
                // Add edit field range validation as a nicety.            }
            break;

        case IDC_COMPRESSION_Quality_Edit:
            if (iNotify == EN_KILLFOCUS) {
                // Add edit field range validation as a nicety.
            }
            break;
#endif

        default:
            break;

        }

        SetDirty();
        break;

    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// SetDirty
//
// notifies the property page site of changes

void 
CVideoStreamConfigProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pviddec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  pviddec.h  Video Decoder property page

#ifndef _INC_PVIDEODECODER_H
#define _INC_PVIDEODECODER_H


// -------------------------------------------------------------------------
// CVideoDecoderProperties class
// -------------------------------------------------------------------------

// Handles the property page

class CVideoDecoderProperties : public CBasePropertyPage {

public:

    static CUnknown * CALLBACK CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

#if 0
    // Make it bigger
    STDMETHODIMP GetPageInfo(PROPPAGEINFO *pPageInfo) {
        HRESULT hr;
        hr = CBasePropertyPage::GetPageInfo (pPageInfo);
        pPageInfo->size.cx *= 2;
        pPageInfo->size.cy *= 2; 
        return hr;
    };
#endif

private:

    CVideoDecoderProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CVideoDecoderProperties();

    void InitPropertiesDialog();
    void Update ();

    void    SetDirty();

    // The control iterface
    IAMAnalogVideoDecoder   *m_pVideoDecoder;

    UINT_PTR                m_TimerID;

    long                    m_VCRLocking;
    long                    m_OutputEnable;
    long                    m_NumberOfLines;
    long                    m_CurrentVideoStandard;
    long                    m_AllSupportedStandards;
    long                    m_HorizontalLocked;

    HWND                    m_hWndVCRLocking;
    HWND                    m_hWndVideoStandards;
    HWND                    m_hWndOutputEnable;
    HWND                    m_hWndNumberOfLines;
    HWND                    m_hWndSignalDetected;
};

#endif  // _INC_PVIDEODECODER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\procamp.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    procamp.cpp

Abstract:

    Implements IAMVideoProcAmp 
    via KSPROPERTY_VIDCAP_VIDEOPROCAMP

--*/

#include "pch.h"
#include "wdmcap.h"
#include "procamp.h"



CUnknown*
CALLBACK
CVideoProcAmpInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a VPE Config
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CVideoProcAmpInterfaceHandler(UnkOuter, NAME("IAMVideoProcAmp"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVideoProcAmpInterfaceHandler::CVideoProcAmpInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) :
    CUnknown(Name, UnkOuter, hr)
/*++

Routine Description:

    The constructor for the IAMVideoProcAmp interface object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            IKsObject*  Object;

            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
            if (SUCCEEDED(*hr)) {
                m_ObjectHandle = Object->KsGetObjectHandle();
                if (!m_ObjectHandle) {
                    *hr = E_UNEXPECTED;
                }
                Object->Release();
            }
        } else {
            *hr = VFW_E_NEED_OWNER;
        }
    }
}


STDMETHODIMP
CVideoProcAmpInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMVideoProcAmp.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==  __uuidof(IAMVideoProcAmp)) {
        return GetInterface(static_cast<IAMVideoProcAmp*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CVideoProcAmpInterfaceHandler::GetRange( 
     IN  long Property,
     OUT long *pMin,
     OUT long *pMax,
     OUT long *pSteppingDelta,
     OUT long *pDefault,
     OUT long *pCapsFlags
     )
/*++

Routine Description:
    Get the Range supported by this property

Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEOPROCAMP_S  VideoProcAmp;
	VIDEOPROCAMP_MEMBERSLIST   PropertyList;
    VIDEOPROCAMP_DEFAULTLIST   DefaultList;
    ULONG                      BytesReturned;

    CheckPointer(pMin, E_INVALIDARG);
    CheckPointer(pMax, E_INVALIDARG);
    CheckPointer(pSteppingDelta, E_INVALIDARG);
    CheckPointer(pDefault, E_INVALIDARG);
    CheckPointer(pCapsFlags, E_INVALIDARG);

    VideoProcAmp.Property.Set = PROPSETID_VIDCAP_VIDEOPROCAMP;
    VideoProcAmp.Property.Id = Property;
    VideoProcAmp.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
    VideoProcAmp.Flags = 0;  


    // First get the min, max and stepping values
    if (SUCCEEDED (::SynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &PropertyList,
        sizeof(PropertyList),
        &BytesReturned))) {

        // ? Proper way to check return size?
        if (BytesReturned < sizeof (PropertyList)) {
            return E_PROP_ID_UNSUPPORTED;
        }

        *pMin  = PropertyList.SteppingLong.Bounds.SignedMinimum;
		*pMax  = PropertyList.SteppingLong.Bounds.SignedMaximum;
		*pSteppingDelta = PropertyList.SteppingLong.SteppingDelta;
    } 
    else {
        return E_PROP_ID_UNSUPPORTED;
    }

    // Next, get the default value
    VideoProcAmp.Property.Set = PROPSETID_VIDCAP_VIDEOPROCAMP;
    VideoProcAmp.Property.Id = Property;
    VideoProcAmp.Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;
    VideoProcAmp.Flags = 0; // ??? 

    if (SUCCEEDED (::SynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &DefaultList,
        sizeof(DefaultList),
        &BytesReturned))) {
#if 0
        // ? Proper way to check return size?
        if (BytesReturned < sizeof (DefaultList)) {
            return E_PROP_ID_UNSUPPORTED;
        }
#endif        
        *pDefault = DefaultList.DefaultValue;
    }
    else {
        return E_PROP_ID_UNSUPPORTED;
    }


    // Finally, get the current value, just to retrieve
    // the Capabilities flag

    VideoProcAmp.Property.Set = PROPSETID_VIDCAP_VIDEOPROCAMP;
    VideoProcAmp.Property.Id = Property;
    VideoProcAmp.Property.Flags = KSPROPERTY_TYPE_GET;
    VideoProcAmp.Flags = 0;

    if (SUCCEEDED (::SynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &BytesReturned))){

        *pCapsFlags = VideoProcAmp.Capabilities;
    }
    else {
        return E_PROP_ID_UNSUPPORTED;
    }

    return S_OK;
}


STDMETHODIMP
CVideoProcAmpInterfaceHandler::Set(
     IN long Property,
     IN long lValue,
     IN long lFlags
     )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEOPROCAMP_S  VideoProcAmp;
    ULONG       BytesReturned;

    VideoProcAmp.Property.Set = PROPSETID_VIDCAP_VIDEOPROCAMP;
    VideoProcAmp.Property.Id = Property;
    VideoProcAmp.Property.Flags = KSPROPERTY_TYPE_SET;
    VideoProcAmp.Value = lValue;
    VideoProcAmp.Flags = lFlags;
    VideoProcAmp.Capabilities = 0;

    return ::SynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &BytesReturned);
}


STDMETHODIMP
CVideoProcAmpInterfaceHandler::Get( 
     IN long Property,
     OUT long *lValue,
     OUT long *lFlags
     )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEOPROCAMP_S  VideoProcAmp;
    ULONG       BytesReturned;
    HRESULT     hr;

    CheckPointer(lValue, E_INVALIDARG);
    CheckPointer(lFlags, E_INVALIDARG);

    VideoProcAmp.Property.Set = PROPSETID_VIDCAP_VIDEOPROCAMP;
    VideoProcAmp.Property.Id = Property;
    VideoProcAmp.Property.Flags = KSPROPERTY_TYPE_GET;
    VideoProcAmp.Flags = 0;

    hr = ::SynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &VideoProcAmp,
        sizeof(VideoProcAmp),
        &BytesReturned);

    if (SUCCEEDED (hr)) {
        *lValue = VideoProcAmp.Value;
        *lFlags = VideoProcAmp.Flags;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\pviddec.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// pviddec.cpp  Property page for AnalogVideoDecoder
//

#include "pch.h"
#include "wdmcap.h"
#include "kseditor.h"
#include "pviddec.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CVideoDecoderProperties
// -------------------------------------------------------------------------

CUnknown *
CALLBACK
CVideoDecoderProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CVideoDecoderProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CVideoDecoderProperties::CVideoDecoderProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("VideoDecoder Property Page") 
                        , lpunk
                        , IDD_VideoDecoderProperties 
                        , IDS_VIDEODECODERPROPNAME
                        )
    , m_pVideoDecoder(NULL) 
    , m_TimerID (0)
{
	INITCOMMONCONTROLSEX cc;

    cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
    cc.dwICC = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

    InitCommonControlsEx(&cc); 
}

// destructor
CVideoDecoderProperties::~CVideoDecoderProperties()
{

}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT 
CVideoDecoderProperties::OnConnect(IUnknown *pUnknown)
{
    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_IAMAnalogVideoDecoder,(void **)&m_pVideoDecoder);
    if (FAILED(hr)) {
        return hr;
    }

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT 
CVideoDecoderProperties::OnDisconnect()
{
    // Release the interface

    if (m_pVideoDecoder == NULL) {
        return E_UNEXPECTED;
    }

    m_pVideoDecoder->Release();
    m_pVideoDecoder = NULL;

    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT 
CVideoDecoderProperties::OnActivate(void)
{
    // Create all of the controls

    m_TimerID= SetTimer (m_hwnd, 678, 300, NULL );

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CVideoDecoderProperties::OnDeactivate(void)
{
    if (m_TimerID)
        KillTimer (m_hwnd, m_TimerID);

    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT 
CVideoDecoderProperties::OnApplyChanges(void)
{
    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR
CVideoDecoderProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    long CurrentStandard;
    int j;
    int iNotify;
    HRESULT hr;

    switch (uMsg) {

    case WM_INITDIALOG:
        m_hwnd = hwnd;
        InitPropertiesDialog(); 
        return (INT_PTR)TRUE;    

    case WM_TIMER:
        Update ();
        break;

    case WM_COMMAND:

        iNotify = HIWORD (wParam);

        switch (LOWORD(wParam)) {
        
        case IDC_VCRLocking:
            if (iNotify == BN_CLICKED) {
                m_VCRLocking = BST_CHECKED & Button_GetState (m_hWndVCRLocking);
                hr = m_pVideoDecoder->put_VCRHorizontalLocking (m_VCRLocking);
                SetDirty();
            }
            break;

        case IDC_OutputEnable:
            if (iNotify == BN_CLICKED) {
                m_OutputEnable = BST_CHECKED & Button_GetState (m_hWndOutputEnable);
                hr = m_pVideoDecoder->put_OutputEnable (m_OutputEnable);
                SetDirty();
            }
            break;
     
        case IDC_VIDEOSTANDARD:
            if (iNotify == CBN_SELCHANGE) {
                j = ComboBox_GetCurSel (m_hWndVideoStandards);
                CurrentStandard = (long)ComboBox_GetItemData(m_hWndVideoStandards, j);
                if (CurrentStandard != m_CurrentVideoStandard) {
                    hr = m_pVideoDecoder->put_TVFormat (CurrentStandard);
                    m_CurrentVideoStandard = CurrentStandard;
                    SetDirty();
                }
            }
            break;

        default:
            break;

        }

        break;

    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// InitPropertiesDialog
//
//
void CVideoDecoderProperties::InitPropertiesDialog() 
{
    long j;
    long CurrentStd;
    TCHAR * ptc;
    int  CurrentIndex = 0;
    int  SelectedIndex;
    HRESULT hr;

    m_hWndVideoStandards = GetDlgItem (m_hwnd, IDC_VIDEOSTANDARD);
    m_hWndVCRLocking = GetDlgItem (m_hwnd, IDC_VCRLocking);
    m_hWndOutputEnable = GetDlgItem (m_hwnd, IDC_OutputEnable);
    m_hWndNumberOfLines = GetDlgItem (m_hwnd, IDC_LinesDetected);
    m_hWndSignalDetected = GetDlgItem (m_hwnd, IDC_SignalDetected);

    hr = m_pVideoDecoder->get_TVFormat (&m_CurrentVideoStandard);

    // List of all supported formats
    hr = m_pVideoDecoder->get_AvailableTVFormats (&m_AllSupportedStandards);

    for (CurrentIndex = 0, j = 1; j; j <<= 1) {

        CurrentStd = m_AllSupportedStandards & j;

        // Special case of progressive, ie. Video Standard is "None"
        // in which TVStd is zero.

        if (CurrentStd || ((CurrentIndex == 0) && (m_AllSupportedStandards == 0))) {
            ptc = StringFromTVStandard (CurrentStd);

            if ((CurrentStd) == m_CurrentVideoStandard)
                SelectedIndex = CurrentIndex;

            ComboBox_AddString (m_hWndVideoStandards, ptc);

            // Tag the combobox entry with the video standard
            ComboBox_SetItemData(m_hWndVideoStandards, CurrentIndex, CurrentStd);

            CurrentIndex++;
        }
    }

    ComboBox_SetCurSel (m_hWndVideoStandards, SelectedIndex);

    // VCR Locking
    hr = m_pVideoDecoder->get_VCRHorizontalLocking (&m_VCRLocking);
    if (FAILED(hr)) {
        EnableWindow (m_hWndVCRLocking, FALSE);
    }

    // Output Enable
    hr = m_pVideoDecoder->get_OutputEnable (&m_OutputEnable);
    if (FAILED(hr)) {
        EnableWindow (m_hWndOutputEnable, FALSE);
    }

    // Number of lines
    hr = m_pVideoDecoder->get_NumberOfLines (&m_NumberOfLines);
    if (FAILED(hr)) {
        EnableWindow (m_hWndNumberOfLines, FALSE);
    }
    
    // Horizontal Locked
    hr = m_pVideoDecoder->get_HorizontalLocked (&m_HorizontalLocked);
    if (FAILED(hr)) {
        EnableWindow (m_hWndSignalDetected, FALSE);
    }

    Update();
}

//
// Update
//
//
void CVideoDecoderProperties::Update() 
{
    HRESULT hr;

    // VCR Locking
    hr = m_pVideoDecoder->get_VCRHorizontalLocking (&m_VCRLocking);
    if (SUCCEEDED(hr)) {
        Button_SetCheck (m_hWndVCRLocking, m_VCRLocking);
    }

    // Output Enable
    hr = m_pVideoDecoder->get_OutputEnable (&m_OutputEnable);
    if (SUCCEEDED(hr)) {
        Button_SetCheck (m_hWndOutputEnable, m_OutputEnable);
    }

    // Number of lines
    hr = m_pVideoDecoder->get_NumberOfLines (&m_NumberOfLines);
    if (SUCCEEDED(hr)) {
        TCHAR buf[40];
        wsprintf (buf, TEXT("%d"), m_NumberOfLines);
        Static_SetText (m_hWndNumberOfLines, buf);
    }

    // Horizontal locked
    hr = m_pVideoDecoder->get_HorizontalLocked (&m_HorizontalLocked);
    if (SUCCEEDED(hr)) {
        TCHAR buf[40];
        wsprintf (buf, TEXT("%d"), m_HorizontalLocked);
        Static_SetText (m_hWndSignalDetected, buf);
    }
}


//
// SetDirty
//
// notifies the property page site of changes

void 
CVideoDecoderProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\procamp.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    procamp.h

Abstract:

    Internal header.

--*/

class CVideoProcAmpInterfaceHandler :
    public CUnknown,
    public IAMVideoProcAmp {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CVideoProcAmpInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    // Implement IAMVideoProcAmp
    STDMETHODIMP GetRange( 
            IN  long  Property,
            OUT long  *pMin,
            OUT long  *pMax,
            OUT long  *pSteppingDelta,
            OUT long  *pDefault,
            OUT long  *pCapsFlags);
        
    STDMETHODIMP Set( 
            IN long Property,
            IN long lValue,
            IN long Flags);
        
    STDMETHODIMP Get( 
            IN long Property,
            OUT long *lValue,
            OUT long *lFlags);
        
private:
    HANDLE m_ObjectHandle;
};

typedef struct {
	KSPROPERTY_DESCRIPTION	    PropertyDescription;
	KSPROPERTY_MEMBERSHEADER    MembersHeader;
	KSPROPERTY_STEPPING_LONG    SteppingLong;
} VIDEOPROCAMP_MEMBERSLIST;

typedef struct {
	KSPROPERTY_DESCRIPTION	    PropertyDescription;
	KSPROPERTY_MEMBERSHEADER    MembersHeader;
    ULONG                       DefaultValue;
} VIDEOPROCAMP_DEFAULTLIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WDMCAP.rc
//
#define IDS_CAMERACONTROLPROPNAME       1
#define IDS_VIDEOPROCAMPPROPNAME        2
#define IDS_VIDEODECODERPROPNAME        3
#define IDS_VIDEOSTREAMCONFIGPROPNAME   4
#define IDS_ERROR_CONNECTING_TITLE      5
#define IDS_ERROR_CONNECTING            6
#define IDS_DVCRCONTROLPROPNAME         7
#define IDS_DEVTYPE_VCR                 8
#define IDS_DEVTYPE_CAMERA              9
#define IDS_TAPE_FORMAT_NOT_INSERTED    10
#define IDS_TAPE_FORMAT_525_60_SD       11
#define IDS_TAPE_FORMAT_525_60_SDL      12
#define IDS_TAPE_FORMAT_525_50_SD       13
#define IDS_TAPE_FORMAT_525_50_SDL      14
#define IDS_TAPE_WRITE_PROTECTED        15
#define IDS_TAPE_WRITABLE               16
#define IDS_DEV_REMOVED                 17
#define IDS_TAPE_FORMAT_MPEG2TS         18
#define IDS_TAPE_FORMAT_2500_60_MPEG    19
#define IDS_TAPE_FORMAT_1250_60_MPEG    20
#define IDS_TAPE_FORMAT_0625_60_MPEG    21
#define IDS_TAPE_FORMAT_2500_50_MPEG    22
#define IDS_TAPE_FORMAT_1250_50_MPEG    23
#define IDS_TAPE_FORMAT_0625_50_MPEG    24
#define IDS_DEVTYPE_NEO                 25
#define IDS_DEVTYPE_DVHS                26
#define IDS_TAPE_FORMAT_UNKNOWN         27
#define IDD_VideoProcAmpProperties      101
#define IDD_CameraControlProperties     102
#define IDD_VideoDecoderProperties      103
#define IDD_VideoStreamConfigProperties 104
#define IDD_DVcrControlProperties       105
#define IDI_PLAY                        106
#define IDD_PROPPAGE_CAMERA             107
#define IDI_PAUSE                       108
#define IDI_RWND                        110
#define IDI_FFWD                        111
#define IDI_RECORD                      113
#define IDI_STOP_EJECT                  114
#define IDI_STEP_FWD                    115
#define IDI_STEP_REV                    116
#define IDI_RECORD_PAUSE                118
#define IDC_Contrast                    1000
#define IDC_Hue                         1001
#define IDC_Brightness                  1002
#define IDC_Saturation                  1003
#define IDC_Sharpness                   1004
#define IDC_Gamma                       1005
#define IDC_ColorEnable                 1006
#define IDC_WhiteBalance                1007
#define IDC_BacklightCompensation       1008
#define IDC_Brightness_Edit             1009
#define IDC_Contrast_Edit               1010
#define IDC_Hue_Edit                    1011
#define IDC_Saturation_Edit             1012
#define IDC_Sharpness_Edit              1013
#define IDC_Gamma_Edit                  1014
#define IDC_WhiteBalance_Edit           1015
#define IDC_BacklightCompensation_Edit  1016
#define IDC_Pan                         1016
#define IDC_Pan_Edit                    1017
#define IDC_Pan_Auto                    1018
#define IDC_Tilt                        1019
#define IDC_Tilt_Edit                   1020
#define IDC_Tilt_Auto                   1021
#define IDC_Roll                        1022
#define IDC_Roll_Edit                   1023
#define IDC_Exposure                    1024
#define IDC_Iris                        1025
#define IDC_Focus                       1026
#define IDC_Zoom_Edit                   1027
#define IDC_Exposure_Edit               1028
#define IDC_Iris_Edit                   1029
#define IDC_Focus_Edit                  1030
#define IDC_Roll_Auto                   1031
#define IDC_Zoom_Auto                   1032
#define IDC_Exposure_Auto               1033
#define IDC_Iris_Auto                   1034
#define IDC_Focus_Auto                  1035
#define IDC_CAMERACONTROL_DEFAULT       1036
#define IDC_Brightness_Label            1037
#define IDC_Contrast_Label              1038
#define IDC_Hue_Label                   1039
#define IDC_Saturation_Label            1040
#define IDC_Sharpness_Label             1041
#define IDC_Gamma_Label                 1042
#define IDC_WhiteBalance_Label          1043
#define IDC_BacklightCompensation_Label 1044
#define IDC_Pan_Label                   1045
#define IDC_Tilt_Label                  1046
#define IDC_Roll_Label                  1047
#define IDC_Zoom_Label                  1048
#define IDC_Exposure_Label              1049
#define IDC_Iris_Label                  1050
#define IDC_Focus_Label                 1051
#define IDC_VIDEOPROCAMP_DEFAULT        1052
#define IDC_VCRLocking                  1053
#define IDC_OutputEnable                1055
#define IDC_LinesDetected               1056
#define IDC_FORMAT_VideoStandard        1057
#define IDC_SignalDetected              1057
#define IDC_FORMAT_Compression          1058
#define IDC_FORMAT_OutputSize           1059
#define IDC_VIDEOSTANDARD               1060
#define IDC_FORMAT_FrameRate            1060
#define IDC_COMPRESSION_Quality_Slider  1061
#define IDC_COMPRESSION_IFrameInterval  1063
#define IDC_COMPRESSION_PFrameInterval  1064
#define IDC_COMPRESSION_Quality_Edit    1065
#define IDC_FORMAT_FrameRateSpin        1067
#define IDC_FORMAT_FlipHorizontal       1068
#define IDC_COMPRESSION_IFrameIntervalSpin 1069
#define IDC_COMPRESSION_PFrameIntervalSpin 1070
#define IDC_Status                      1071
#define IDC_BTN_DV_PLAY                 1072
#define IDC_BTN_DV_PAUSE                1073
#define IDC_BTN_DV_STOP                 1074
#define IDC_BTN_DV_FFWD                 1075
#define IDC_BTN_DV_RWND                 1076
#define IDC_EDT_INPUT_SIGNAL            1078
#define IDC_BTN_DV_RECORD               1079
#define IDC_EDT_TAPE_INFO               1080
#define IDC_EDT_OUTPUT_SIGNAL           1081
#define IDC_BTN_DV_RECORD_PAUSE         1082
#define IDC_CHK_WRITE_PROTECTED         1084
#define IDC_STATIC_DEV_IDVERSION        1085
#define IDC_STATIC_TIMECODE             1088
#define IDC_RDO_Camera                  1090
#define IDC_RDO_VCR                     1091
#define IDC_EDIT1                       1092
#define IDC_EDT_AVC_SEND                1092
#define IDC_EDT_AVC_RESP                1094
#define IDC_BTN_AVC_SEND                1095
#define IDC_TXT_RESPONSE                1096
#define IDC_BTN_DV_STEP_REV             1097
#define IDC_BTN_DV_STEP_FWD             1098
#define IDC_CHK_MIC_SUPPORTED           1099
#define IDC_BacklightCompensation_Auto  1100
#define IDC_CHK_SLOW                    1100
#define IDC_Brightness_Auto             1101
#define IDC_ColorEnable_Auto            1102
#define IDC_Contrast_Auto               1103
#define IDC_Gamma_Auto                  1104
#define IDC_Hue_Auto                    1105
#define IDC_Saturation_Auto             1106
#define IDC_BTN_ATN_SEARCH              1106
#define IDC_Sharpness_Auto              1107
#define IDC_WhiteBalance_Auto           1108
#define IDC_EDT_TC_HH                   1109
#define IDC_EDT_TC_MM                   1110
#define IDC_EDT_TC_SS                   1111
#define IDC_EDT_TC_FF                   1112
#define IDC_EDT_ATN                     1113
#define IDC_EDT_ATN_BF                  1117
#define IDC_GBX_DEVICE_TYPE             1118
#define IDC_TXT_TAPE_FORMAT             1123
#define IDC_TXT_WRITE_PROTECTED         1124
#define IDC_BTN_TAPE_INSERTED           1125
#define IDC_TXT_NOTIFY_ON               1126
#define IDC_GBX_TIMECODE                1127
#define IDC_TXT_HH_COLON                1128
#define IDC_TXT_MM_COLON                1129
#define IDC_TXT_SS_COMMA                1130
#define IDC_TXT_DEVICE_ID               1133
#define IDC_BTN_SET_POWER               1134
#define IDC_Zoom                        2000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        119
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1135
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\viddec.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    viddec.cpp

Abstract:

    Implements IAMAnalogVideoDecoder 
    via PROPSETID_VIDCAP_VIDEODECODER

--*/

#include "pch.h"
#include "wdmcap.h"
#include "viddec.h"



CUnknown*
CALLBACK
CAnalogVideoDecoderInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a VPE Config
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CAnalogVideoDecoderInterfaceHandler(UnkOuter, NAME("IAMAnalogVideoDecoder"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CAnalogVideoDecoderInterfaceHandler::CAnalogVideoDecoderInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) 
    : CUnknown(Name, UnkOuter, hr)
    , m_HaveCaps (FALSE)
/*++

Routine Description:

    The constructor for the IAMAnalogVideoDecoder interface object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (SUCCEEDED(*hr)) {
        if (UnkOuter) {
            IKsObject*  Object;

            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
            if (SUCCEEDED(*hr)) {
                m_ObjectHandle = Object->KsGetObjectHandle();
                if (!m_ObjectHandle) {
                    *hr = E_UNEXPECTED;
                }
                Object->Release();
            }
        } else {
            *hr = VFW_E_NEED_OWNER;
        }
    }
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IAMAnalogVideoDecoder.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{

    if (riid ==  __uuidof(IAMAnalogVideoDecoder)) {
        return GetInterface(static_cast<IAMAnalogVideoDecoder*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::GenericGetCaps( 
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_CAPS_S  VideoDecoderCaps;
    ULONG       BytesReturned;
    HRESULT     hr;

    if (m_HaveCaps)
        return S_OK;

    VideoDecoderCaps.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    VideoDecoderCaps.Property.Id = KSPROPERTY_VIDEODECODER_CAPS;
    VideoDecoderCaps.Property.Flags = KSPROPERTY_TYPE_GET;

    hr = ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &VideoDecoderCaps,
                sizeof(VideoDecoderCaps),
                &VideoDecoderCaps,
                sizeof(VideoDecoderCaps),
                &BytesReturned);
    
    if (SUCCEEDED (hr)) {
        m_Caps = VideoDecoderCaps;
        m_Caps.StandardsSupported &= 
           (KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_Mask | KS_AnalogVideo_SECAM_Mask);
        m_HaveCaps = TRUE;
    }
    else {
        m_Caps.StandardsSupported = 0;
        m_Caps.Capabilities = 0;
        m_Caps.SettlingTime = 0;
        m_Caps.HSyncPerVSync = 1;
        hr = E_PROP_ID_UNSUPPORTED;
    }

    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::GenericGetStatus( 
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_STATUS_S  DecoderStatus;
    ULONG       BytesReturned;
    HRESULT     hr;

    // Wait for the device to settle
    ASSERT (m_Caps.SettlingTime < 200);     // Sanity check
    Sleep (m_Caps.SettlingTime);

    DecoderStatus.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    DecoderStatus.Property.Id = KSPROPERTY_VIDEODECODER_STATUS;
    DecoderStatus.Property.Flags = KSPROPERTY_TYPE_GET;

    hr = ::SynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &DecoderStatus,
        sizeof(DecoderStatus),
        &DecoderStatus,
        sizeof(DecoderStatus),
        &BytesReturned);

    if (SUCCEEDED (hr)) {
        m_Status = DecoderStatus;
    }
    else {
        m_Status.NumberOfLines = 0;
        m_Status.SignalLocked = 0;
        hr = E_PROP_ID_UNSUPPORTED;
    }
    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::get_AvailableTVFormats( 
    /* OUT */ long *lAnalogVideoStandard
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    HRESULT     hr;

    hr = GenericGetCaps();
            
    if (SUCCEEDED (hr)) {
        *lAnalogVideoStandard = m_Caps.StandardsSupported;
    }
    else {
       *lAnalogVideoStandard = AnalogVideo_None;
    }
    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::put_TVFormat( 
    /* IN */ long lAnalogVideoStandard
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_S  VideoDecoder;
    ULONG       BytesReturned;

    VideoDecoder.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    VideoDecoder.Property.Id = KSPROPERTY_VIDEODECODER_STANDARD;
    VideoDecoder.Property.Flags = KSPROPERTY_TYPE_SET;

    VideoDecoder.Value = lAnalogVideoStandard;

    return ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &VideoDecoder,
                sizeof(VideoDecoder),
                &VideoDecoder,
                sizeof(VideoDecoder),
                &BytesReturned);
    
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::get_TVFormat( 
    OUT long *plAnalogVideoStandard
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_S  VideoDecoder;
    ULONG       BytesReturned;
    HRESULT     hr;

    VideoDecoder.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    VideoDecoder.Property.Id = KSPROPERTY_VIDEODECODER_STANDARD;
    VideoDecoder.Property.Flags = KSPROPERTY_TYPE_GET;

    hr = ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &VideoDecoder,
                sizeof(VideoDecoder),
                &VideoDecoder,
                sizeof(VideoDecoder),
                &BytesReturned);

    if (SUCCEEDED (hr)) {
        *plAnalogVideoStandard = VideoDecoder.Value;
    }
    else {
       *plAnalogVideoStandard = AnalogVideo_None;
    }

    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::get_HorizontalLocked( 
    OUT long  *plLocked
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    HRESULT     hr;

    hr = GenericGetCaps();

    hr = E_PROP_ID_UNSUPPORTED;

    *plLocked = AMTUNER_HASNOSIGNALSTRENGTH;

    if (m_Caps.Capabilities & KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED) {

        hr = GenericGetStatus ();
        if (SUCCEEDED (hr)) {
            *plLocked = m_Status.SignalLocked;
        }
    }
    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::put_VCRHorizontalLocking( 
    IN long lVCRHorizontalLocking
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_S  VideoDecoder;
    ULONG       BytesReturned;
    HRESULT     hr;

    hr = GenericGetCaps();
    
    if (!(m_Caps.Capabilities & KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING)) {
        return E_PROP_ID_UNSUPPORTED;
    }

    VideoDecoder.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    VideoDecoder.Property.Id = KSPROPERTY_VIDEODECODER_VCR_TIMING;
    VideoDecoder.Property.Flags = KSPROPERTY_TYPE_SET;
    VideoDecoder.Value = lVCRHorizontalLocking;

    hr = ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &VideoDecoder,
                sizeof(VideoDecoder),
                &VideoDecoder,
                sizeof(VideoDecoder),
                &BytesReturned);

    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::get_VCRHorizontalLocking( 
    OUT long  *plVCRHorizontalLocking
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_S  VideoDecoder;
    ULONG       BytesReturned;
    HRESULT     hr;

    hr = GenericGetCaps();
    
    if (!(m_Caps.Capabilities & KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING)) {
        return E_PROP_ID_UNSUPPORTED;
    }

    VideoDecoder.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    VideoDecoder.Property.Id = KSPROPERTY_VIDEODECODER_VCR_TIMING;
    VideoDecoder.Property.Flags = KSPROPERTY_TYPE_GET;

    hr = ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &VideoDecoder,
                sizeof(VideoDecoder),
                &VideoDecoder,
                sizeof(VideoDecoder),
                &BytesReturned);

    if (SUCCEEDED (hr)) {
        *plVCRHorizontalLocking = VideoDecoder.Value;
    }
    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::get_NumberOfLines( 
    OUT long  *plNumberOfLines
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    HRESULT     hr;

    hr = GenericGetStatus ();
    if (SUCCEEDED (hr)) {
        *plNumberOfLines = m_Status.NumberOfLines;
    }
    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::put_OutputEnable( 
    IN long lOutputEnable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_S  VideoDecoder;
    ULONG       BytesReturned;
    HRESULT     hr;

    hr = GenericGetCaps();
    
    if (!(m_Caps.Capabilities & KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT)) {
        return E_PROP_ID_UNSUPPORTED;
    }

    VideoDecoder.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    VideoDecoder.Property.Id = KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE;
    VideoDecoder.Property.Flags = KSPROPERTY_TYPE_SET;
    VideoDecoder.Value = lOutputEnable;

    hr = ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &VideoDecoder,
                sizeof(VideoDecoder),
                &VideoDecoder,
                sizeof(VideoDecoder),
                &BytesReturned);

    return hr;
}


STDMETHODIMP
CAnalogVideoDecoderInterfaceHandler::get_OutputEnable( 
    OUT long  *plOutputEnable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    KSPROPERTY_VIDEODECODER_S  VideoDecoder;
    ULONG       BytesReturned;
    HRESULT     hr;

    hr = GenericGetCaps();
    
    if (!(m_Caps.Capabilities & KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT)) {
        return E_PROP_ID_UNSUPPORTED;
    }

    VideoDecoder.Property.Set = PROPSETID_VIDCAP_VIDEODECODER;
    VideoDecoder.Property.Id = KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE;
    VideoDecoder.Property.Flags = KSPROPERTY_TYPE_GET;

    hr = ::SynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                &VideoDecoder,
                sizeof(VideoDecoder),
                &VideoDecoder,
                sizeof(VideoDecoder),
                &BytesReturned);

    if (SUCCEEDED (hr)) {
        *plOutputEnable = VideoDecoder.Value;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\wdmcap.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    wdmcap.cpp

Abstract:

    g_Templates and utility routines

--*/

#include "pch.h"

// Interface handlers
#include "wdmcap.h"
#include "camera.h"
#include "procamp.h"
#include "viddec.h"
#include "compress.h"
#include "drop.h"

// DataFormat handlers
#include "ksdatav1.h"
#include "ksdatav2.h"
#include "ksdatava.h"
#include "ksdatavb.h"

// Property page handlers
#include "kseditor.h"
#include "pprocamp.h"
#include "pcamera.h"
#include "pviddec.h"
#include "pformat.h"

#include "EDevIntf.h"   // CAMExtDevice, CAMExtTransport and CAMTcr
#include "DVcrPage.h"   // CDVcrControlProperties

#include <initguid.h>

//
// need to Defined in uuids.h
//
// {81E9DD62-78D5-11d2-B47E-006097B3391B}
//OUR_GUID_ENTRY(CLSID_DVcrControlPropertyPage, 
//0x81e9dd62, 0x78d5, 0x11d2, 0xb4, 0x7e, 0x0, 0x60, 0x97, 0xb3, 0x39, 0x1b)

//
// Temporarily defining it here until this make into uuids.lib
// 
// == CLSID_DVcrControlPropertyPage
//


GUID DVcrControlGuid= {0x81e9dd62, 0x78d5, 0x11d2, 0xb4, 0x7e, 0x0, 0x60, 0x97, 0xb3, 0x39, 0x1b};



//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] = 
{

    // --- DShow Interfaces ---
    {L"IAMExtDevice",                       &IID_IAMExtDevice, 
        CAMExtDevice::CreateInstance, NULL, NULL},
    {L"IAMExtTransport",                    &IID_IAMExtTransport, 
        CAMExtTransport::CreateInstance, NULL, NULL},
    {L"IAMTimecodeReader",                  &IID_IAMTimecodeReader, 
        CAMTcr::CreateInstance, NULL, NULL},

    {L"IAMCameraControl",                   &IID_IAMCameraControl, 
        CCameraControlInterfaceHandler::CreateInstance, NULL, NULL},
    {L"IAMVideoProcAmp",                    &IID_IAMVideoProcAmp,  
        CVideoProcAmpInterfaceHandler::CreateInstance, NULL, NULL},
    {L"IAMAnalogVideoDecoder",              &IID_IAMAnalogVideoDecoder,  
        CAnalogVideoDecoderInterfaceHandler::CreateInstance, NULL, NULL},
    {L"IAMVideoCompression",                &IID_IAMVideoCompression,  
        CVideoCompressionInterfaceHandler::CreateInstance, NULL, NULL},
    {L"IAMDroppedFrames",                   &IID_IAMDroppedFrames,  
        CDroppedFramesInterfaceHandler::CreateInstance, NULL, NULL},
    {L"IAMVideoControl",                    &IID_IAMVideoControl,
        CVideoControlInterfaceHandler::CreateInstance, NULL, NULL},

    // --- Data handlers ---
    {L"KsDataTypeHandlerVideo",             &FORMAT_VideoInfo,  
        CVideo1DataTypeHandler::CreateInstance, NULL, NULL},
    {L"KsDataTypeHandlerVideo2",            &FORMAT_VideoInfo2, 
        CVideo2DataTypeHandler::CreateInstance, NULL, NULL},
    {L"KsDataTypeHandlerAnalogVideo",       &FORMAT_AnalogVideo, 
        CAnalogVideoDataTypeHandler::CreateInstance, NULL, NULL},
    {L"KsDataTypeHandlerVBI",               &KSDATAFORMAT_SPECIFIER_VBI, 
        CVBIDataTypeHandler::CreateInstance, NULL, NULL},

    // --- Property page handlers ---
    {L"DVcrControl Property Page",         &DVcrControlGuid, // &CLSID_DVcrControlPropertyPage,  
        CDVcrControlProperties::CreateInstance, NULL, NULL},

    {L"VideoProcAmp Property Page",         &CLSID_VideoProcAmpPropertyPage,  
        CVideoProcAmpProperties::CreateInstance, NULL, NULL},
    {L"CameraControl Property Page",        &CLSID_CameraControlPropertyPage,  
        CCameraControlProperties::CreateInstance, NULL, NULL},
    {L"VideoDecoder Property Page",         &CLSID_AnalogVideoDecoderPropertyPage,  
        CVideoDecoderProperties::CreateInstance, NULL, NULL},
    {L"VideoStreamConfig Property Page",    &CLSID_VideoStreamConfigPropertyPage,  
        CVideoStreamConfigProperties::CreateInstance, NULL, NULL},
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}



STDMETHODIMP
SynchronousDeviceControl(
    HANDLE      Handle,
    DWORD       IoControl,
    PVOID       InBuffer,
    ULONG       InLength,
    PVOID       OutBuffer,
    ULONG       OutLength,
    PULONG      BytesReturned
    )
/*++

Routine Description:

    Performs a synchronous Device I/O Control, waiting for the device to
    complete if the call returns a Pending status.

Arguments:

    Handle -
        The handle of the device to perform the I/O on.

    IoControl -
        The I/O control code to send.

    InBuffer -
        The first buffer.

    InLength -
        The size of the first buffer.

    OutBuffer -
        The second buffer.

    OutLength -
        The size of the second buffer.

    BytesReturned -
        The number of bytes returned by the I/O.

Return Value:

    Returns NOERROR if the I/O succeeded.

--*/
{
    OVERLAPPED  ov;
    HRESULT     hr;

    RtlZeroMemory(&ov, sizeof(OVERLAPPED));
    if (!(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL))) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!DeviceIoControl(
        Handle,
        IoControl,
        InBuffer,
        InLength,
        OutBuffer,
        OutLength,
        BytesReturned,
        &ov)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {

            if (GetOverlappedResult(Handle, &ov, BytesReturned, TRUE)) {
                hr = NOERROR;
            } else {

                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    } else {
        hr = NOERROR;
    }
    CloseHandle(ov.hEvent);
    return hr;
}

//
// StringFromTVStandard
//
TCHAR * StringFromTVStandard(long TVStd) 
{
    TCHAR * ptc;

    switch (TVStd) {
        case 0:                      ptc = TEXT("None");        break;
        case AnalogVideo_NTSC_M:     ptc = TEXT("NTSC_M");      break;
        case AnalogVideo_NTSC_M_J:   ptc = TEXT("NTSC_M_J");    break;
        case AnalogVideo_NTSC_433:   ptc = TEXT("NTSC_433");    break;

        case AnalogVideo_PAL_B:      ptc = TEXT("PAL_B");       break;
        case AnalogVideo_PAL_D:      ptc = TEXT("PAL_D");       break;
        case AnalogVideo_PAL_G:      ptc = TEXT("PAL_G");       break;
        case AnalogVideo_PAL_H:      ptc = TEXT("PAL_H");       break;
        case AnalogVideo_PAL_I:      ptc = TEXT("PAL_I");       break;
        case AnalogVideo_PAL_M:      ptc = TEXT("PAL_M");       break;
        case AnalogVideo_PAL_N:      ptc = TEXT("PAL_N");       break;
        case AnalogVideo_PAL_60:     ptc = TEXT("PAL_60");      break;

        case AnalogVideo_SECAM_B:    ptc = TEXT("SECAM_B");     break;
        case AnalogVideo_SECAM_D:    ptc = TEXT("SECAM_D");     break;
        case AnalogVideo_SECAM_G:    ptc = TEXT("SECAM_G");     break;
        case AnalogVideo_SECAM_H:    ptc = TEXT("SECAM_H");     break;
        case AnalogVideo_SECAM_K:    ptc = TEXT("SECAM_K");     break;
        case AnalogVideo_SECAM_K1:   ptc = TEXT("SECAM_K1");    break;
        case AnalogVideo_SECAM_L:    ptc = TEXT("SECAM_L");     break;
        case AnalogVideo_SECAM_L1:   ptc = TEXT("SECAM_L1");    break;
        default: 
            ptc = TEXT("[Unknown]");
            break;
    }
    return ptc;
}


#ifdef DEBUG
//
// DisplayMediaType -- (DEBUG ONLY)
//
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt)
{

    // Dump the GUID types and a short description

    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription));
    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("Media Type Description")));
    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt->Subtype())));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->cbFormat));

    // Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));


} // DisplayMediaType
#endif

STDMETHODIMP
PinFactoryIDFromPin(
        IPin  * pPin,
        ULONG * PinFactoryID)
/*++

Routine Description:

    Returns the PinFactoryID for an IPin

Arguments:

    pPin -
    
        The DShow pin handle

    PinFactoryID -
    
        Destination for the PinFactoryID

Return Value:

    Returns NOERROR if the IPin is valid

--*/
{
    HRESULT hr = E_INVALIDARG;

    *PinFactoryID = 0;

    if (pPin) {
        IKsPinFactory * PinFactoryInterface;

        hr = pPin->QueryInterface(__uuidof(IKsPinFactory), reinterpret_cast<PVOID*>(&PinFactoryInterface));
        if (SUCCEEDED(hr)) {
            hr = PinFactoryInterface->KsPinFactory(PinFactoryID);
            PinFactoryInterface->Release();
        }
    }
    return hr;
}

STDMETHODIMP
FilterHandleFromPin(
        IPin  * pPin,
        HANDLE * pParent)
/*++

Routine Description:

    Returns the handle of the parent given an IPin *

Arguments:

    pPin -
    
        The DShow pin handle

    pParent -
    
        The parent filter's file handle

Return Value:

    Returns NOERROR if the IPin is valid

--*/
{
    HRESULT hr = E_INVALIDARG;

    *pParent = NULL;

    if (pPin) {
        PIN_INFO PinInfo;
        IKsObject *pKsObject;

        if (SUCCEEDED (hr = pPin->QueryPinInfo(&PinInfo))) {
            if (SUCCEEDED (hr = PinInfo.pFilter->QueryInterface(
                                __uuidof(IKsObject), 
                                (void **) &pKsObject))) {
                *pParent = pKsObject->KsGetObjectHandle();
                pKsObject->Release();
            }
            PinInfo.pFilter->Release();
        }
    }
    return hr;
}


STDMETHODIMP
PerformDataIntersection(
    IPin * pPin,
    int Position,
    CMediaType* MediaType
    )
/*++

Routine Description:

    Returns the specified media type on the Pin Factory Id. This is done
    by querying the list of data ranges, and performing a data intersection
    on the specified data range, producing a data format. Then converting
    that data format to a media type.
    
    All this hocus pocus, just to get biSizeImage filled in correctly!

Arguments:

    pPin -
        The Direct Show pin handle
        
    Position -
        The zero-based position to return. This corresponds to the data range
        item.

    MediaType -
        The media type to initialize.  This is used on input to get
        biWidth and biHeight.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT             hr;
    PKSMULTIPLE_ITEM    MultipleItem;
    HANDLE              FilterHandle;
    ULONG               PinFactoryId;
    UINT                Width, Height;
    REFERENCE_TIME      AvgTimePerFrame;

    if ((Position < 0) || (pPin == NULL) || (MediaType == NULL)) {
        return E_INVALIDARG;
    }

    if (FAILED (hr = FilterHandleFromPin (pPin, &FilterHandle))) {
        return hr;
    }

    if (FAILED (hr = PinFactoryIDFromPin (pPin, &PinFactoryId))) {
        return hr;
    }

    //
    // Here is how this function differs from KsGetMediaType
    // We stuff in the biWidth and biHeight into the DataRange
    //
    if (*MediaType->FormatType() == FORMAT_VideoInfo) {
        VIDEOINFOHEADER *VidInfoHdr = (VIDEOINFOHEADER*) MediaType->Format();
    
        Width = VidInfoHdr->bmiHeader.biWidth;
        Height = VidInfoHdr->bmiHeader.biHeight;
        AvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
    }
    else if (*MediaType->FormatType() == FORMAT_VideoInfo2) {
        VIDEOINFOHEADER2 *VidInfoHdr = (VIDEOINFOHEADER2*)MediaType->Format ();
    
        Width = VidInfoHdr->bmiHeader.biWidth;
        Height = VidInfoHdr->bmiHeader.biHeight;
        AvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
    }
    else {
        return E_INVALIDARG;
    }

    //
    // Retrieve the list of data ranges supported by the Pin Factory Id.
    //
    hr = ::RedundantKsGetMultiplePinFactoryItems(
        FilterHandle,
        PinFactoryId,
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
        reinterpret_cast<PVOID*>(&MultipleItem));
    if (FAILED(hr)) {
        hr = ::RedundantKsGetMultiplePinFactoryItems(
            FilterHandle,
            PinFactoryId,
            KSPROPERTY_PIN_DATARANGES,
            reinterpret_cast<PVOID*>(&MultipleItem));
        if (FAILED(hr)) {
            return hr;
        }
    }
    //
    // Ensure that this is in range.
    //
    if ((ULONG)Position < MultipleItem->Count) {
        PKSDATARANGE        DataRange;
        PKSP_PIN            Pin;
        PKSMULTIPLE_ITEM    RangeMultipleItem;
        ULONG               BytesReturned;


        DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);
        //
        // Increment to the correct data range element.
        //
        for (; Position--; ) {
            DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
        }
        Pin = reinterpret_cast<PKSP_PIN>(new BYTE[sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize]);
        if (!Pin) {
            CoTaskMemFree(MultipleItem);
            return E_OUTOFMEMORY;
        }
        Pin->Property.Set = KSPROPSETID_Pin;
        Pin->Property.Id = KSPROPERTY_PIN_DATAINTERSECTION;
        Pin->Property.Flags = KSPROPERTY_TYPE_GET;
        Pin->PinId = PinFactoryId;
        Pin->Reserved = 0;
        //
        // Copy the data range into the query.
        //
        RangeMultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(Pin + 1);
        RangeMultipleItem->Size = DataRange->FormatSize + sizeof(*RangeMultipleItem);
        RangeMultipleItem->Count = 1;
        memcpy(RangeMultipleItem + 1, DataRange, DataRange->FormatSize);

        
        if (*MediaType->FormatType() == FORMAT_VideoInfo) {
            KS_DATARANGE_VIDEO *DataRangeVideo = (PKS_DATARANGE_VIDEO) (RangeMultipleItem + 1);
            KS_VIDEOINFOHEADER *VideoInfoHeader = &DataRangeVideo->VideoInfoHeader;

            VideoInfoHeader->bmiHeader.biWidth = Width;
            VideoInfoHeader->bmiHeader.biHeight = Height;
            VideoInfoHeader->AvgTimePerFrame = AvgTimePerFrame;

        }
        else if (*MediaType->FormatType() == FORMAT_VideoInfo2) {
            KS_DATARANGE_VIDEO2 *DataRangeVideo2 = (PKS_DATARANGE_VIDEO2) (RangeMultipleItem + 1);
            KS_VIDEOINFOHEADER2 *VideoInfoHeader = &DataRangeVideo2->VideoInfoHeader;

            VideoInfoHeader->bmiHeader.biWidth = Width;
            VideoInfoHeader->bmiHeader.biHeight = Height;
            VideoInfoHeader->AvgTimePerFrame = AvgTimePerFrame;
        }
        else {
            ASSERT (FALSE);
        }
        //
        // Perform the data intersection with the data range, first to obtain
        // the size of the resultant data format structure, then to retrieve
        // the actual data format.
        //
        hr = ::SynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            Pin,
            sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize,
            NULL,
            0,
            &BytesReturned);
#if 1
//!! This goes away post-Beta!!
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            ULONG       ItemSize;

            DbgLog((LOG_TRACE, 0, TEXT("Filter does not support zero length property query!")));
            hr = ::SynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize,
                &ItemSize,
                sizeof(ItemSize),
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                BytesReturned = ItemSize;
                hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            }
        }
#endif
        if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
            PKSDATAFORMAT       DataFormat;

            ASSERT(BytesReturned >= sizeof(*DataFormat));
            DataFormat = reinterpret_cast<PKSDATAFORMAT>(new BYTE[BytesReturned]);
            if (!DataFormat) {
                delete [] (PBYTE)Pin;
                CoTaskMemFree(MultipleItem);
                return E_OUTOFMEMORY;
            }
            hr = ::SynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize,
                DataFormat,
                BytesReturned,
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                ASSERT(DataFormat->FormatSize == BytesReturned);
                //
                // Initialize the media type based on the returned data format.
                //
                MediaType->SetType(&DataFormat->MajorFormat);
                MediaType->SetSubtype(&DataFormat->SubFormat);
                MediaType->SetTemporalCompression(DataFormat->Flags & KSDATAFORMAT_TEMPORAL_COMPRESSION);
                MediaType->SetSampleSize(DataFormat->SampleSize);
                if (DataFormat->FormatSize > sizeof(*DataFormat)) {
                    if (!MediaType->SetFormat(reinterpret_cast<BYTE*>(DataFormat + 1), DataFormat->FormatSize - sizeof(*DataFormat))) {
                        hr = E_OUTOFMEMORY;
                    }
                }
                MediaType->SetFormatType(&DataFormat->Specifier);
            }
            delete [] reinterpret_cast<BYTE*>(DataFormat);
        }
        delete [] reinterpret_cast<BYTE*>(Pin);
    } else {
        hr = VFW_S_NO_MORE_ITEMS;
    }
    CoTaskMemFree(MultipleItem);
    return hr;
}


STDMETHODIMP
RedundantKsGetMultiplePinFactoryItems(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG PropertyId,
    PVOID* Items
    )
/*++

Routine Description:

    Retrieves variable length data from Pin property items. Queries for the
    data size, allocates a buffer, and retrieves the data.

Arguments:

    FilterHandle -
        The handle of the filter to query.

    PinFactoryId -
        The Pin Factory Id to query.

    PropertyId -
        The property in the Pin property set to query.

    Items -
        The place in which to put the buffer containing the data items. This
        must be deleted with CoTaskMemFree if the function succeeds.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    HRESULT     hr;
    KSP_PIN     Pin;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    //
    // Query for the size of the data.
    //
    hr = ::SynchronousDeviceControl(
        FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        NULL,
        0,
        &BytesReturned);
#if 1
//!! This goes away post-Beta!!
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ULONG       ItemSize;

        DbgLog((LOG_TRACE, 0, TEXT("Filter does not support zero length property query!")));
        hr = ::SynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            &Pin,
            sizeof(Pin),
            &ItemSize,
            sizeof(ItemSize),
            &BytesReturned);
        if (SUCCEEDED(hr)) {
            BytesReturned = ItemSize;
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        }
    }
#endif
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // Allocate a buffer and query for the data.
        //
        *Items = CoTaskMemAlloc(BytesReturned);
        if (!*Items) {
            return E_OUTOFMEMORY;
        }
        hr = ::SynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            &Pin,
            sizeof(Pin),
            *Items,
            BytesReturned,
            &BytesReturned);
        if (FAILED(hr)) {
            CoTaskMemFree(*Items);
        }
    }
    return hr;
}


STDMETHODIMP 
IsMediaTypeInRange(
    IN PKSDATARANGE DataRange,
    IN CMediaType* MediaType
)

/*++

Routine Description:
    Validates that the given media type for VideoInfoHeader1 or VideoInfoHeader2
    is within the provided data range.

Arguments:
    IN PVOID DataRange -
        pointer to a data ranges 

    MediaType -
        The media type to check.
        
Return:
    S_OK if match found, E_FAIL if not found, or an appropriate error code.

--*/

{
    PKS_DATARANGE_VIDEO          Video1Range;
    PKS_DATARANGE_VIDEO2         Video2Range;
    KS_VIDEO_STREAM_CONFIG_CAPS *ConfigCaps;
    VIDEOINFOHEADER             *VideoInfoHeader1;
    VIDEOINFOHEADER2            *VideoInfoHeader2;
    BITMAPINFOHEADER            *BitmapInfoHeader;
    RECT                         rcDest;
    RECT                         rcSource;
    RECT                         rcTarget;
    int                          SourceWidth, SourceHeight;
    int                          Width, Height;

    DbgLog((LOG_TRACE, 3, TEXT("IsMediaTypeInRange")));
    
    if ( *MediaType->Type() != KSDATAFORMAT_TYPE_VIDEO)
        return E_FAIL;

    if ((*MediaType->FormatType() == FORMAT_VideoInfo) &&
            (DataRange->Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO) &&
            (*MediaType->Subtype() == DataRange->SubFormat)) {
        Video1Range = (PKS_DATARANGE_VIDEO) DataRange;
        VideoInfoHeader1 = (VIDEOINFOHEADER*) MediaType->Format();
        BitmapInfoHeader = &VideoInfoHeader1->bmiHeader;
        ConfigCaps = &Video1Range->ConfigCaps;

        if ((Video1Range->DataRange.FormatSize < sizeof( KS_DATARANGE_VIDEO )) ||
            MediaType->FormatLength() < sizeof( VIDEOINFOHEADER )) {
            return E_FAIL;
        }
        rcSource = VideoInfoHeader1->rcSource;
        rcTarget = VideoInfoHeader1->rcTarget;
        Width = BitmapInfoHeader->biWidth;
        Height = BitmapInfoHeader->biHeight;

    }
    else if ((*MediaType->FormatType() == FORMAT_VideoInfo2) &&
            (DataRange->Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO2) &&
            (*MediaType->Subtype() == DataRange->SubFormat)) {

        Video2Range = (PKS_DATARANGE_VIDEO2) DataRange;
        VideoInfoHeader2 = (VIDEOINFOHEADER2*) MediaType->Format();
        BitmapInfoHeader = &VideoInfoHeader2->bmiHeader;
        ConfigCaps = &Video2Range->ConfigCaps;

        if ((Video2Range->DataRange.FormatSize < sizeof( KS_DATARANGE_VIDEO2 )) ||
            MediaType->FormatLength() < sizeof( VIDEOINFOHEADER2 )) {
            return E_FAIL;
        }
        rcSource = VideoInfoHeader2->rcSource;
        rcTarget = VideoInfoHeader2->rcTarget;
        Width = BitmapInfoHeader->biWidth;
        Height = BitmapInfoHeader->biHeight;

    }
    else {
        return E_FAIL;
    }
    // The destination bitmap size is defined by biWidth and biHeight
    // if rcTarget is NULL.  Otherwise, the destination bitmap size
    // is defined by rcTarget.  In the latter case, biWidth may
    // indicate the "stride" for DD surfaces.

    if (IsRectEmpty (&rcTarget)) {
        SetRect (&rcDest, 0, 0, Width, abs (Height)); 
    }
    else {
        rcDest = rcTarget;
    }

    Width  = rcDest.right - rcDest.left;
    Height = abs (rcDest.bottom - rcDest.top);
    SourceWidth  = rcSource.right - rcSource.left;
    SourceHeight = rcSource.bottom - rcSource.top;

    //
    // Check the validity of the cropping rectangle, rcSource
    //

    if (!IsRectEmpty (&rcSource)) {

        if (SourceWidth  < ConfigCaps->MinCroppingSize.cx ||
            SourceWidth  > ConfigCaps->MaxCroppingSize.cx ||
            SourceHeight < ConfigCaps->MinCroppingSize.cy ||
            SourceHeight > ConfigCaps->MaxCroppingSize.cy) {

            DbgLog((LOG_TRACE, 5, TEXT("IsMediaTypeInRange, CROPPING SIZE FAILED")));
            return E_FAIL;
        }

        if ((ConfigCaps->CropGranularityX != 0) &&
            (ConfigCaps->CropGranularityY != 0) &&
            ((SourceWidth  % ConfigCaps->CropGranularityX) ||
             (SourceHeight % ConfigCaps->CropGranularityY) )) {

            DbgLog((LOG_TRACE, 5, TEXT("IsMediaTypeInRange, CROPPING SIZE GRANULARITY FAILED")));
            return E_FAIL;
        }

        if ((ConfigCaps->CropAlignX != 0) &&
            (ConfigCaps->CropAlignY != 0) &&
            (rcSource.left  % ConfigCaps->CropAlignX) ||
            (rcSource.top   % ConfigCaps->CropAlignY) ) {

            DbgLog((LOG_TRACE, 5, TEXT("IsMediaTypeInRange, CROPPING ALIGNMENT FAILED")));
            return E_FAIL;
        }
    }

    //
    // Check the destination size, rcDest
    //

    if (Width  < ConfigCaps->MinOutputSize.cx ||
        Width  > ConfigCaps->MaxOutputSize.cx ||
        Height < ConfigCaps->MinOutputSize.cy ||
        Height > ConfigCaps->MaxOutputSize.cy) {

        DbgLog((LOG_TRACE, 5, TEXT("IsMediaTypeInRange, DEST SIZE FAILED")));
        return E_FAIL;
    }
    if ((ConfigCaps->OutputGranularityX != 0) &&
        (ConfigCaps->OutputGranularityX != 0) &&
        (Width  % ConfigCaps->OutputGranularityX) ||
        (Height % ConfigCaps->OutputGranularityY) ) {

        DbgLog((LOG_TRACE, 5, TEXT("IsMediaTypeInRange, DEST GRANULARITY FAILED")));
        return E_FAIL;
    }

#ifdef IT_BREAKS_TOO_MANY_THINGS_TO_VERIFY_FRAMERATE
    //
    // Check the framerate, AvgTimePerFrame
    //
    if (VideoInfoHeader->AvgTimePerFrame < ConfigCaps->MinFrameInterval ||
        VideoInfoHeader->AvgTimePerFrame > ConfigCaps->MaxFrameInterval) {

        DbgLog((LOG_TRACE, 0, TEXT("CVideo1DataTypeHandler, AVGTIMEPERFRAME FAILED")));
        return E_FAIL;
    }
#endif
    //
    // We have found a match.
    //
    
    return S_OK;
}


STDMETHODIMP
CompleteDataFormat(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    CMediaType* MediaType
    )
/*++

Routine Description:

    Completes a partial MediaType by performing a DataIntersection.
    
Arguments:

    PinFactoryId -
        The stream Id
        
    MediaType -
        The media type to initialize.  This is used on input to get
        biWidth and biHeight.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT             hr;
    PKSMULTIPLE_ITEM    MultipleItem = NULL;
    UINT                Width, Height;
    REFERENCE_TIME      AvgTimePerFrame;
    PKSP_PIN            Pin;
    PKSDATARANGE        DataRange;
	 BOOL						Found = FALSE;

    if (*MediaType->FormatType() == FORMAT_VideoInfo) {
        VIDEOINFOHEADER *VidInfoHdr = (VIDEOINFOHEADER*) MediaType->Format();
    
        Width = VidInfoHdr->bmiHeader.biWidth;
        Height = VidInfoHdr->bmiHeader.biHeight;
        AvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
    }
    else if (*MediaType->FormatType() == FORMAT_VideoInfo2) {
        VIDEOINFOHEADER2 *VidInfoHdr = (VIDEOINFOHEADER2*)MediaType->Format ();
    
        Width = VidInfoHdr->bmiHeader.biWidth;
        Height = VidInfoHdr->bmiHeader.biHeight;
        AvgTimePerFrame = VidInfoHdr->AvgTimePerFrame;
    }
    else {
        return E_INVALIDARG;
    }

    //
    // Retrieve the list of data ranges supported by the Pin Factory Id.
    //
    hr = ::RedundantKsGetMultiplePinFactoryItems(
        FilterHandle,
        PinFactoryId,
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
        reinterpret_cast<PVOID*>(&MultipleItem));
    if (FAILED(hr) || !MultipleItem) {
        hr = ::RedundantKsGetMultiplePinFactoryItems(
            FilterHandle,
            PinFactoryId,
            KSPROPERTY_PIN_DATARANGES,
            reinterpret_cast<PVOID*>(&MultipleItem));
        if (FAILED(hr) || !MultipleItem) {
            return hr;
        }
    }

    //
    // Loop through all of the DataRanges on this pin looking for a match
    //
    DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);

    for (ULONG j = 0; 
            !Found && (j < MultipleItem->Count); 
            j++, 
            DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7))) {

        PKSMULTIPLE_ITEM    RangeMultipleItem;
        ULONG               BytesReturned;

        hr = VFW_S_NO_MORE_ITEMS;

        // Verify we've matched the DataRange here!!!
        hr = IsMediaTypeInRange(
                DataRange,
                MediaType);
        if (FAILED (hr)) {
            continue;
        }

        Pin = reinterpret_cast<PKSP_PIN>(new BYTE[sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize]);
        if (!Pin) {
            CoTaskMemFree(MultipleItem);
            return E_OUTOFMEMORY;
        }
    
        Pin->Property.Set = KSPROPSETID_Pin;
        Pin->Property.Id = KSPROPERTY_PIN_DATAINTERSECTION;
        Pin->Property.Flags = KSPROPERTY_TYPE_GET;
        Pin->PinId = PinFactoryId;
        Pin->Reserved = 0;

        //
        // Copy the data range into the query.
        //
        RangeMultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(Pin + 1);
        RangeMultipleItem->Size = DataRange->FormatSize + sizeof(*RangeMultipleItem);
        RangeMultipleItem->Count = 1;
        memcpy(RangeMultipleItem + 1, DataRange, DataRange->FormatSize);

        
        if (*MediaType->FormatType() == FORMAT_VideoInfo) {
            KS_DATARANGE_VIDEO *DataRangeVideo = (PKS_DATARANGE_VIDEO) (RangeMultipleItem + 1);
            KS_VIDEOINFOHEADER *VideoInfoHeader = &DataRangeVideo->VideoInfoHeader;

            VideoInfoHeader->bmiHeader.biWidth = Width;
            VideoInfoHeader->bmiHeader.biHeight = Height;
            VideoInfoHeader->AvgTimePerFrame = AvgTimePerFrame;

        }
        else if (*MediaType->FormatType() == FORMAT_VideoInfo2) {
            KS_DATARANGE_VIDEO2 *DataRangeVideo2 = (PKS_DATARANGE_VIDEO2) (RangeMultipleItem + 1);
            KS_VIDEOINFOHEADER2 *VideoInfoHeader = &DataRangeVideo2->VideoInfoHeader;

            VideoInfoHeader->bmiHeader.biWidth = Width;
            VideoInfoHeader->bmiHeader.biHeight = Height;
            VideoInfoHeader->AvgTimePerFrame = AvgTimePerFrame;
        }
        else {
            ASSERT (FALSE);
        }
        //
        // Perform the data intersection with the data range, first to obtain
        // the size of the resultant data format structure, then to retrieve
        // the actual data format.
        //
        hr = ::SynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            Pin,
            sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize,
            NULL,
            0,
            &BytesReturned);
#if 1
//!! This goes away post-Beta!!
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            ULONG       ItemSize;

            DbgLog((LOG_TRACE, 0, TEXT("Filter does not support zero length property query!")));
            hr = ::SynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize,
                &ItemSize,
                sizeof(ItemSize),
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                BytesReturned = ItemSize;
                hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            }
        }
#endif
        if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
            PKSDATAFORMAT       DataFormat;

            ASSERT(BytesReturned >= sizeof(*DataFormat));
            DataFormat = reinterpret_cast<PKSDATAFORMAT>(new BYTE[BytesReturned]);
            if (!DataFormat) {
                delete [] (PBYTE)Pin;
                CoTaskMemFree(MultipleItem);
                return E_OUTOFMEMORY;
            }
            hr = ::SynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize,
                DataFormat,
                BytesReturned,
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                ASSERT(DataFormat->FormatSize == BytesReturned);
                //
                // Initialize the media type based on the returned data format.
                //
                MediaType->SetType(&DataFormat->MajorFormat);
                MediaType->SetSubtype(&DataFormat->SubFormat);
                MediaType->SetTemporalCompression(DataFormat->Flags & KSDATAFORMAT_TEMPORAL_COMPRESSION);
                MediaType->SetSampleSize(DataFormat->SampleSize);
                if (DataFormat->FormatSize > sizeof(*DataFormat)) {
                    if (!MediaType->SetFormat(reinterpret_cast<BYTE*>(DataFormat + 1), DataFormat->FormatSize - sizeof(*DataFormat))) {
                        hr = E_OUTOFMEMORY;
                    }
                }
                MediaType->SetFormatType(&DataFormat->Specifier);
					 Found = TRUE;
            }
            delete [] reinterpret_cast<BYTE*>(DataFormat);
        }

        delete [] reinterpret_cast<BYTE*>(Pin);

    } // for all DataRanges

    CoTaskMemFree(MultipleItem);

    return Found ? S_OK : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\wdmcap.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    wdmcap.h

Abstract:

    Internal header.

--*/

STDMETHODIMP
SynchronousDeviceControl(
    HANDLE      Handle,
    DWORD       IoControl,
    PVOID       InBuffer,
    ULONG       InLength,
    PVOID       OutBuffer,
    ULONG       OutLength,
    PULONG      BytesReturned
    );

TCHAR * 
StringFromTVStandard(long TVStd);


#ifdef DEBUG
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt);
#endif

STDMETHODIMP
PinFactoryIDFromPin(
        IPin  * pPin,
        ULONG * PinFactoryID);

STDMETHODIMP
FilterHandleFromPin(
        IPin  * pPin,
        HANDLE * pParent);

STDMETHODIMP
PerformDataIntersection(
    IPin * pPin,
    int Position,
    CMediaType* MediaType
    );

STDMETHODIMP
RedundantKsGetMultiplePinFactoryItems(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG PropertyId,
    PVOID* Items
    );

STDMETHODIMP 
IsMediaTypeInRange(
    IN PKSDATARANGE DataRange,
    IN CMediaType* MediaType
);

STDMETHODIMP
CompleteDataFormat(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    CMediaType* MediaType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcap\viddec.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    viddec.h

Abstract:

    Internal header.

--*/

class CAnalogVideoDecoderInterfaceHandler :
    public CUnknown,
    public IAMAnalogVideoDecoder {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CAnalogVideoDecoderInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    // Implement IAMAnalogVideoDecoder

    STDMETHODIMP get_AvailableTVFormats( 
            /* [out] */ long *lAnalogVideoStandard);
        
    STDMETHODIMP put_TVFormat( 
            /* [in] */ long lAnalogVideoStandard);
        
    STDMETHODIMP get_TVFormat( 
            /* [out] */ long  *plAnalogVideoStandard);
        
    STDMETHODIMP get_HorizontalLocked( 
            /* [out] */ long  *plLocked);
        
    STDMETHODIMP put_VCRHorizontalLocking( 
            /* [in] */ long lVCRHorizontalLocking);
        
    STDMETHODIMP get_VCRHorizontalLocking( 
            /* [out] */ long  *plVCRHorizontalLocking);
        
    STDMETHODIMP get_NumberOfLines( 
            /* [out] */ long  *plNumberOfLines);
        
    STDMETHODIMP put_OutputEnable( 
            /* [in] */ long lOutputEnable);
        
    STDMETHODIMP get_OutputEnable( 
            /* [out] */ long  *plOutputEnable);

        
private:
    HANDLE                              m_ObjectHandle;
    BOOL                                m_HaveCaps;
    KSPROPERTY_VIDEODECODER_CAPS_S      m_Caps;
    KSPROPERTY_VIDEODECODER_STATUS_S    m_Status;

    STDMETHODIMP GenericGetStatus ();
    STDMETHODIMP GenericGetCaps ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcapgf\bldcapgf.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    BldCapGf.cpp

Abstract:

    A class for building a capture graph to stream video.
    It is basically reusing amcap.cpp and making it a c++ class.
    This is built into a static link library.

    Its current clients:

        VfW-WDM mapper
        TWAIN still capture
        others..

Author:

    Yee J. Wu    24-April-97

Environment:

    User mode only

Revision History:

--*/


#include "pch.h"      // mainly stream.h

#include <string.h>
#include <tchar.h>

#include <ks.h>       // KSSTATE
#include <ksproxy.h>  // __STREAMS__, pKsObject->KsGetObjectHandle()

#include "BldCapGf.h"

#if 0  // This static linked lib cannot (?) has its own string table ?
#include "resource.h"
#else // so we hardcoded this int its client; at this time vfwwdm32.dll
#define IDS_VIDEO_TUNER                 73
#define IDS_VIDEO_COMPOSITE             74
#define IDS_VIDEO_SVIDEO                75
#define IDS_AUDIO_TUNER                 76
#define IDS_SOURCE_UNDEFINED            77
#endif




CCaptureGraph::CCaptureGraph(
    BGf_PURPOSE PurposeFlags,
    BGf_PREVIEW PreviewFlags,
    REFCLSID clsidVideoDeviceClass,
    DWORD    dwVideoEnumFlags,
    REFCLSID clsidAudioDeviceClass,
    DWORD    dwAudioEnumFlags,
    HINSTANCE hInstance
    ) :

    m_hInstance(hInstance),
    m_PurposeFlags(PurposeFlags),
    m_PreviewFlags(PreviewFlags),
    m_clsidVideoDeviceClass(clsidVideoDeviceClass),
    m_dwVideoEnumFlags(dwVideoEnumFlags),

    m_clsidAudioDeviceClass(clsidAudioDeviceClass),
    m_dwAudioEnumFlags(dwAudioEnumFlags),

    m_pObjVCaptureCurrent(0),
    m_ObjListVCapture(NAME("WDM Video Capture Devices List")),
    m_pVideoEnumMoniker(0),

    m_pObjACaptureCurrent(0),
    m_ObjListACapture(NAME("WDM Audio Capture Devices List")),
    m_pAudioEnumMoniker(0),

    m_pBuilder(0),
    m_pVCap(0),
    m_pXBar1(0),
    m_pXBar2(0),
    m_pFg(0),
    m_pMEEx(0),
    m_bSetChild(FALSE),
    m_pVW(0),
    m_lWindowStyle(0),
    m_hWndClient(0),
    m_lLeft(0),
    m_lTop(0),
    m_lWidth(0),
    m_lHeight(0),

    m_fPreviewGraphBuilt(FALSE),
    m_fPreviewing(FALSE),

    m_pIAMVC(0),
    m_pIAMVSC(0),
    m_pIAMDF(0),
    m_pIAMDlg(0),
    m_pIAMTV(0),
    m_pIAMXBar1(0),
    m_pIAMXBar2(0),
    m_XBar1InPinCounts(0),
    m_XBar1OutPinCounts(0),

    m_pACap(0),
    m_pIAMASC(0),
    m_fCapAudio(FALSE)
    //m_fCapAudioIsRelevant(FALSE)
{
    // Validate clsidVideoDeviceClass and dwVideoEnumFlags
    // since they are cache here and never change again.
    // ???

    // Initialize the COM library
    // Its client may have already initialized the COM library;
    // Since we rely on it, we will call it again and if it fail; it probably will not matter.
    DbgLog((LOG_TRACE,2,TEXT("Creating CCaptureGraph")));

    HRESULT hr= CoInitialize(0);
    if(hr != S_OK) {
        DbgLog((LOG_TRACE,1,TEXT("CoInitialize() rtn %x"), hr));

    }

    //
    // Build the Device List
    //
    EnumerateCaptureDevices(BGf_DEVICE_VIDEO, clsidVideoDeviceClass, dwVideoEnumFlags);
    EnumerateCaptureDevices(BGf_DEVICE_AUDIO, clsidAudioDeviceClass, dwAudioEnumFlags);
}


//
// Destructor.
//
CCaptureGraph::~CCaptureGraph()
{

    DbgLog((LOG_TRACE,2,TEXT("Destroying CCaptureGraph")));

    if(m_pVideoEnumMoniker) m_pVideoEnumMoniker->Release(), m_pVideoEnumMoniker = NULL;
    if(m_pAudioEnumMoniker) m_pAudioEnumMoniker->Release(), m_pAudioEnumMoniker = NULL;


    // Teardown graph and free reosurce
    if(BGf_PreviewGraphBuilt())
        BGf_DestroyGraph();

    DestroyObjList(BGf_DEVICE_AUDIO);
    DestroyObjList(BGf_DEVICE_VIDEO);

    CoUninitialize();
}



//
// Free WDM capture device object list.
//
void
CCaptureGraph::DestroyObjList(
    BGf_DEVICE_TYPE DeviceType)
{
    CObjCapture * pObjCapture;

    // Free the existing list and build a new one.
    if(DeviceType == BGf_DEVICE_VIDEO) {
        while(m_ObjListVCapture.GetCount() > 0) {
            pObjCapture = (CObjCapture *) m_ObjListVCapture.RemoveHead();
            delete pObjCapture;
        }
    } else if(DeviceType == BGf_DEVICE_AUDIO) {
        while(m_ObjListACapture.GetCount() > 0) {
            pObjCapture = (CObjCapture *) m_ObjListACapture.RemoveHead();
            delete pObjCapture;
        }
    } else
        // Unknow device type?
        return;
}



//
// Enumerate WDM capture devices
//
LONG
CCaptureGraph::EnumerateCaptureDevices(
    BGf_DEVICE_TYPE DeviceType,
    REFCLSID clsidDeviceClass,
    DWORD dwEnumFlags)
{
    HRESULT hr;
    LONG lCapObjCount = 0;
    CObjCapture * pObjCapture;


    if(DeviceType != BGf_DEVICE_VIDEO &&
       DeviceType != BGf_DEVICE_AUDIO) {
        DbgLog((LOG_TRACE,1,TEXT("Unknown device type (%d)"), DeviceType));
        return 0;
    }

    // Free the existing list and build a new one.
    DestroyObjList(DeviceType);


    //
    // Enuemrate cpnnectd capture devices
    //
    ICreateDevEnum *pCreateDevEnum;
    hr = CoCreateInstance(
            CLSID_SystemDeviceEnum,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_ICreateDevEnum,
            (void**)&pCreateDevEnum);

    if(S_OK != hr) {
        DbgLog((LOG_TRACE,1,TEXT("CoCreateInstance() failed; hr=%x"), hr));
        return 0;
    }

    IEnumMoniker *pEnumMoniker;

    hr = pCreateDevEnum->CreateClassEnumerator(
            clsidDeviceClass,
            &pEnumMoniker,
            dwEnumFlags);

    pCreateDevEnum->Release();


    if(hr == S_OK) {

        hr = pEnumMoniker->Reset();

        ULONG cFetched;
        IMoniker *pM;

        // Device name; limited to MAX_PATH length !!
        TCHAR szFriendlyName[MAX_PATH], szDevicePath[MAX_PATH], szExtensionDLL[MAX_PATH];

        while(hr = pEnumMoniker->Next(1, &pM, &cFetched), hr==S_OK) {

            IPropertyBag *pPropBag = 0;;
            pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(pPropBag) {

                VARIANT var;

                // Get "FriendlyName" of the device
                var.vt = VT_BSTR;
                hr = pPropBag->Read(L"FriendlyName", &var, 0);
                if (hr == S_OK) {
#ifndef _UNICODE
                    WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1,
                        szFriendlyName, MAX_PATH, 0, 0);
#else
                    _tcsncpy(szFriendlyName, var.bstrVal, MAX_PATH-1);
#endif
                    DbgLog((LOG_TRACE,2,TEXT("Friendlyname = %s"), szFriendlyName));
                    SysFreeString(var.bstrVal);
                } else {
                    DbgLog((LOG_TRACE,1,TEXT("No FriendlyName registry value") ));
                    //
                    // No one can use a "No name" device; skip!
                    //
                    goto NextDevice;
                }

                //Extension DLL name: optional
                var.vt = VT_BSTR;
                hr = pPropBag->Read(L"ExtensionDLL", &var, 0);
                if (hr == S_OK) {
#ifndef _UNICODE
                    WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1,
                        szExtensionDLL, MAX_PATH, 0, 0);
#else
                    _tcsncpy(szExtensionDLL, var.bstrVal, MAX_PATH-1);
#endif
                    DbgLog((LOG_TRACE,2,TEXT("ExtensionDLL: %s"), szExtensionDLL));
                    SysFreeString(var.bstrVal);
                } else {
                    _tcscpy(szExtensionDLL, TEXT(""));
                    DbgLog((LOG_TRACE,2,TEXT("No ExtensionDLL")));
                }

                // Get DevicePath of the device and highlight the
                // item if it maches the currect selection
                var.vt = VT_BSTR;
                hr = pPropBag->Read(L"DevicePath", &var, 0);
                if (hr == S_OK) {
#ifndef _UNICODE
                    WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1,
                        szDevicePath, MAX_PATH, 0, 0);
#else
                    _tcsncpy(szDevicePath, var.bstrVal, MAX_PATH-1);
#endif
                    SysFreeString(var.bstrVal);
                } else {
                    DbgLog((LOG_TRACE,1,TEXT("No DevicePath registry value.")));
                    //
                    // Must be an installation problem, skip!
                    //
                    goto NextDevice;
                }

                // Create a object and add it to the object list.
                pObjCapture = new CObjCapture(szDevicePath, szFriendlyName, szExtensionDLL);
                if(DeviceType == BGf_DEVICE_VIDEO)
                   m_ObjListVCapture.AddTail(pObjCapture);
                else
                   m_ObjListACapture.AddTail(pObjCapture);

                lCapObjCount++;
NextDevice:
                pPropBag->Release();
            }

            pM->Release();
        } // While
#if 0
        pEnumMoniker->Release();
#else
        // Save for later use.
        if(DeviceType == BGf_DEVICE_VIDEO)
            m_pVideoEnumMoniker = pEnumMoniker;
        else
            m_pAudioEnumMoniker = pEnumMoniker;
#endif

        DbgLog((LOG_TRACE,1,TEXT("Detected %d capture device(s)."), lCapObjCount));

    } else {
        DbgLog((LOG_TRACE,1,TEXT("pCreateDevEnum->CreateClassEnumerator() failed; hr=%x"), hr));
    }




    return lCapObjCount;
}


//
// Copy device info content.
//
void
CCaptureGraph::DuplicateObjContent(
    EnumDeviceInfo * pDstEnumDeviceInfo,
    CObjCapture * pSrcObjCapture)
{
    if(!pDstEnumDeviceInfo ||
       !pSrcObjCapture) {
        DbgLog((LOG_TRACE,1,TEXT("DuplicateObjContent: pDstEnumDeviceInfo =%x; pSrcObjCapture=%x"), pDstEnumDeviceInfo, pSrcObjCapture));
        return;
    }

    pDstEnumDeviceInfo->dwSize = sizeof(EnumDeviceInfo);
    pDstEnumDeviceInfo->dwFlags= 0;

    CopyMemory(pDstEnumDeviceInfo->strDevicePath,   pSrcObjCapture->GetDevicePath(),   _MAX_PATH);
    CopyMemory(pDstEnumDeviceInfo->strFriendlyName, pSrcObjCapture->GetFriendlyName(), _MAX_PATH);
    //CopyMemory(pDstEnumDeviceInfo->strDescription,  pSrcObjCapture->GetDescription(),  _MAX_PATH);
    CopyMemory(pDstEnumDeviceInfo->strExtensionDLL, pSrcObjCapture->GetExtensionDLL(), _MAX_PATH);
}


//
// Number of WDM capture devices enumerated.
//
LONG
CCaptureGraph::BGf_GetDevicesCount(BGf_DEVICE_TYPE DeviceType)
{
    if(DeviceType == BGf_DEVICE_VIDEO) {
        return (LONG) m_ObjListVCapture.GetCount();
    } else if (DeviceType == BGf_DEVICE_AUDIO) {
        return (LONG) m_ObjListACapture.GetCount();
    } else
        return 0;
}


//
// Dynamically create a capture dvice list.
//
LONG
CCaptureGraph::BGf_CreateCaptureDevicesList(
    BGf_DEVICE_TYPE DeviceType,
    EnumDeviceInfo ** ppEnumDevicesList)
{
    EnumDeviceInfo * pTemp;
    LONG i;

    if(BGf_GetDevicesCount(DeviceType) == 0) {
        DbgLog((LOG_TRACE,1,TEXT("There is no capture device")));
        return 0;
    }


    pTemp = (EnumDeviceInfo *) new EnumDeviceInfo[BGf_GetDevicesCount(DeviceType)];
    if(!pTemp) {
        DbgLog((LOG_TRACE,1,TEXT("Cannot allocate EnumDeviceInfo[QueryDevicesCount()=%d]"), BGf_GetDevicesCount(DeviceType)));
        return 0;
    }

    *ppEnumDevicesList = pTemp;

    CObjCapture * pNext;
    POSITION pos;

    if(DeviceType == BGf_DEVICE_VIDEO) {
        pos = m_ObjListVCapture.GetHeadPosition();
        for(i=0; pos && i<m_ObjListVCapture.GetCount(); i++){
            pNext = m_ObjListVCapture.GetNext(pos);
            DuplicateObjContent(pTemp ,pNext);
            pTemp++;
        }
    } else {
        pos = m_ObjListACapture.GetHeadPosition();
        for(i=0; pos && i<m_ObjListACapture.GetCount(); i++){
            pNext = m_ObjListACapture.GetNext(pos);
            DuplicateObjContent(pTemp ,pNext);
            pTemp++;
        }
    }

    return BGf_GetDevicesCount(DeviceType);
}


//
// Re-enumerated WDM capture devices and create device list.
//
LONG
CCaptureGraph::BGf_CreateCaptureDevicesListUpdate(
    BGf_DEVICE_TYPE DeviceType,
    EnumDeviceInfo ** ppEnumDeviceList)
{
    // Do we need to validate: clsidVideoDeviceClass, dwVideoEnumFlags??
    EnumerateCaptureDevices(BGf_DEVICE_VIDEO, m_clsidVideoDeviceClass, m_dwVideoEnumFlags);

    // Can there be PnP audio capture device??
    // EnumerateCaptureDevices(BGf_DEVICE_AUDIO, m_clsidAudioDeviceClass, m_dwAudioEnumFlags);

    return BGf_CreateCaptureDevicesList(DeviceType, ppEnumDeviceList);
}


//
// Free device list.
//
void
CCaptureGraph::BGf_DestroyCaptureDevicesList(
    EnumDeviceInfo * pEnumDeviceList)
{
    delete [] pEnumDeviceList;
}



//
// Set target capture device with a pointer to the object.
//
HRESULT
CCaptureGraph::SetObjCapture(
    BGf_DEVICE_TYPE DeviceType,
    CObjCapture * pObjCaptureNew)
{
    // Cache this pointer as well as its content
    if(DeviceType == BGf_DEVICE_VIDEO) {
        m_pObjVCaptureCurrent = pObjCaptureNew;
        DuplicateObjContent(&m_EnumVDeviceInfoCurrent, m_pObjVCaptureCurrent);
    } else {
        m_pObjACaptureCurrent = pObjCaptureNew;
        DuplicateObjContent(&m_EnumADeviceInfoCurrent, m_pObjACaptureCurrent);
    }

    return S_OK;
}


//
// Set target capture device from a device path.
//
HRESULT
CCaptureGraph::BGf_SetObjCapture(
    BGf_DEVICE_TYPE DeviceType,
    TCHAR *pstrDevicePath)
{
    int i = 0;
    BOOL bFound = FALSE;
    CObjCapture * pNext;
    POSITION pos;

    if(DeviceType == BGf_DEVICE_VIDEO) {
        pos = m_ObjListVCapture.GetHeadPosition();
        while(pos && !bFound) {
            pNext = m_ObjListVCapture.GetNext(pos);
            // DevicePath is unique
            if(_tcscmp(pstrDevicePath, pNext->GetDevicePath()) == 0) {
                bFound = TRUE;
                SetObjCapture(DeviceType, pNext);
            }
        }
    } else {
        pos = m_ObjListACapture.GetHeadPosition();
        while(pos && !bFound) {
            pNext = m_ObjListACapture.GetNext(pos);
            // DevicePath is unique
            if(_tcscmp(pstrDevicePath, pNext->GetDevicePath()) == 0) {
                bFound = TRUE;
                SetObjCapture(DeviceType, pNext);
            }
        }
    }

    // Note: succeeded(rtn)
    if(bFound)
       return S_OK;
    else
       return E_INVALIDARG;
}



//
// Set target capture device
// Given a EnumDeviceInfo, we make sure that it is in the device list and cache it.
//
HRESULT
CCaptureGraph::BGf_SetObjCapture(
    BGf_DEVICE_TYPE DeviceType,
    EnumDeviceInfo * pEnumDeviceInfo,
    DWORD dwEnumDeviceInfoSize)
{
    if(dwEnumDeviceInfoSize != sizeof(EnumDeviceInfo)) {
        DbgLog((LOG_TRACE,1,TEXT("EnumDeviceSize (%d) does not match ours (%d)"),
              dwEnumDeviceInfoSize, sizeof(EnumDeviceInfo)));
        return E_INVALIDARG;
    }

    return BGf_SetObjCapture(DeviceType, pEnumDeviceInfo->strDevicePath);
}



//
// Get capture device path; if there is only one enumerated WDm capture
// device, make it the selected device.
//
TCHAR *
CCaptureGraph::BGf_GetObjCaptureDevicePath(
    BGf_DEVICE_TYPE DeviceType)
{

    if(DeviceType == BGf_DEVICE_VIDEO) {
        if(m_pObjVCaptureCurrent) {
           return m_pObjVCaptureCurrent->GetDevicePath();
        } else {
            //
            // SPECIAL CASE: if there is only one device why ask user; that is the one!!
            //
            if(BGf_GetDevicesCount(BGf_DEVICE_VIDEO) == 1) {
                DbgLog((LOG_TRACE,2,TEXT("Special case: (!default || default not active) && only 1 VCap device enumerated.")));

                CObjCapture * pObjCap;
                POSITION pos = m_ObjListVCapture.GetHeadPosition();

                if(pos) {
                    pObjCap = m_ObjListVCapture.GetNext(pos);
                    if(pObjCap) {
                        SetObjCapture(DeviceType, pObjCap);
                        return m_pObjVCaptureCurrent->GetDevicePath();
                    }
                }
            }
            return 0;
        }
    } else {
        if(m_pObjACaptureCurrent) {
           return m_pObjACaptureCurrent->GetDevicePath();
        } else {
            //
            // SPECIAL CASE: if there is only one device why ask user; that is the one!!
            //
            if(BGf_GetDevicesCount(BGf_DEVICE_AUDIO) == 1) {
                DbgLog((LOG_TRACE,2,TEXT("Special case: (!default || default not active) && only 1 ACap device enumerated.")));

                CObjCapture * pObjCap;
                POSITION pos = m_ObjListACapture.GetHeadPosition();

                if(pos) {
                    pObjCap = m_ObjListACapture.GetNext(pos);
                    if(pObjCap) {
                        SetObjCapture(DeviceType, pObjCap);
                        return m_pObjACaptureCurrent->GetDevicePath();
                    }
                }
            }
            return 0;
        }
    }
}


//
// Get WDM device's friendly name
//
TCHAR *
CCaptureGraph::BGf_GetObjCaptureFriendlyName(BGf_DEVICE_TYPE DeviceType)
{
    if(DeviceType == BGf_DEVICE_VIDEO) {
        if(m_pObjVCaptureCurrent) {
            return m_pObjVCaptureCurrent->GetFriendlyName();
        } else {
            DbgLog((LOG_TRACE,1,TEXT("There is no active video device.")));
            return 0;
        }
    } else {
        if(m_pObjACaptureCurrent) {
            return m_pObjACaptureCurrent->GetFriendlyName();
        } else {
            DbgLog((LOG_TRACE,1,TEXT("There is no active audio device.")));
            return 0;
        }
    }
}

//
// Get WDM driver's corresponding extension DLL
//
TCHAR *
CCaptureGraph::BGf_GetObjCaptureExtensionDLL(BGf_DEVICE_TYPE DeviceType)
{
    if(DeviceType == BGf_DEVICE_VIDEO) {
        if(m_pObjVCaptureCurrent) {
            return m_pObjVCaptureCurrent->GetExtensionDLL();
        } else {
            DbgLog((LOG_TRACE,1,TEXT("There is no active video device.")));
            return 0;
        }
    } else {
        if(m_pObjACaptureCurrent) {
            return m_pObjACaptureCurrent->GetExtensionDLL();
        } else {
            DbgLog((LOG_TRACE,1,TEXT("There is no active audio device.")));
            return 0;
        }
    }
}



//
// Get current capture object.
//
HRESULT
CCaptureGraph::BGf_GetObjCapture(
    BGf_DEVICE_TYPE DeviceType,
    EnumDeviceInfo * pEnumDeviceInfo,
    DWORD dwEnumDeviceInfoSize)
{
    if(dwEnumDeviceInfoSize != sizeof(EnumDeviceInfo)) {
        DbgLog((LOG_TRACE,1,TEXT("EnumDeviceSize (%d) does not match ours (%d)"),
              dwEnumDeviceInfoSize, sizeof(EnumDeviceInfo)));
        return FALSE;
    }

    if(DeviceType == BGf_DEVICE_VIDEO) {
        CopyMemory(pEnumDeviceInfo->strDevicePath,   m_EnumVDeviceInfoCurrent.strDevicePath,   _MAX_PATH);
        CopyMemory(pEnumDeviceInfo->strFriendlyName, m_EnumVDeviceInfoCurrent.strFriendlyName, _MAX_PATH);
        CopyMemory(pEnumDeviceInfo->strExtensionDLL, m_EnumVDeviceInfoCurrent.strExtensionDLL, _MAX_PATH);
    } else {
        CopyMemory(pEnumDeviceInfo->strDevicePath,   m_EnumADeviceInfoCurrent.strDevicePath,   _MAX_PATH);
        CopyMemory(pEnumDeviceInfo->strFriendlyName, m_EnumADeviceInfoCurrent.strFriendlyName, _MAX_PATH);
        CopyMemory(pEnumDeviceInfo->strExtensionDLL, m_EnumADeviceInfoCurrent.strExtensionDLL, _MAX_PATH);
    }

    return TRUE;
}





HRESULT
CCaptureGraph::BGf_BuildGraphUpStream(
    BOOL bAddAudioFilter,
    BOOL * pbUseOVMixer)
/*++

Routine Description:

Arguments:

Return Value:

    S_OK or E_FAIL

--*/
{
    HRESULT hr;
    BOOL bFound;
    TCHAR achDevicePath[_MAX_PATH];
    TCHAR achFriendlyName[_MAX_PATH];


    //++++++++++++++
    // 0. VALIDATION
    //--------------

    // Graphis already built.
    if(m_pVCap != NULL) {
        DbgLog((LOG_TRACE,1,TEXT("BuildGraph: graph is already been built; need to tear it down before rebuild.")));
        return E_INVALIDARG;
    }

    // Make sure a device has been selected and set.
    if(!m_pObjVCaptureCurrent) {
        DbgLog((LOG_TRACE,1,TEXT("BuildGraph: Choose a device first before we can build a graph.")));
        return E_INVALIDARG;
    }



    //++++++++++++++++++++++
    // Build graph begin:
    //    1. Find the capture device and bind to this capture object.
    //    2. Insert this object to the graph builder
    //    3. Find all its related interfaces.
    //    4. Set its media type/format
    //    5. Query its pins/device handle
    //----------------------

    DbgLog((LOG_TRACE,2,TEXT("-->>>BuildGraph: Start build a new graph<<<--.")));

    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //    1a. Find the VIDEO capture device and bind to this capture object.
    //---------------------------------------------------------------------
    m_pVideoEnumMoniker->Reset();
    ULONG cFetched;
    IMoniker *pM;
    m_pVCap = NULL;
    bFound = FALSE;

    while(hr = m_pVideoEnumMoniker->Next(1, &pM, &cFetched), hr==S_OK && !bFound) {
        // Find what we want based on the DevicePath that we had used to CreateFile()
        // Get its name, and instantiate it.
        IPropertyBag *pBag;
        achFriendlyName[0] = 0;
        hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
        if(SUCCEEDED(hr)) {
            VARIANT var;
            var.vt = VT_BSTR;
            hr = pBag->Read(L"DevicePath", &var, NULL);
            if(hr == NOERROR) {
#ifndef _UNICODE
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achDevicePath, _MAX_PATH, NULL, NULL);
#else
                _tcsncpy(achDevicePath, var.bstrVal, MAX_PATH-1);
#endif
                SysFreeString(var.bstrVal);

                if(_tcscmp(m_EnumVDeviceInfoCurrent.strDevicePath, achDevicePath) == 0) {// same Devicepath used to CreateFile()
                    bFound = TRUE;
                    hr = pBag->Read(L"FriendlyName", &var, NULL);

                    if(hr == NOERROR) {
#ifndef _UNICODE
                        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achFriendlyName, 80, NULL, NULL);
#else
                        _tcsncpy(achFriendlyName, var.bstrVal, MAX_PATH-1);
#endif
                        DbgLog((LOG_TRACE,2,TEXT("BindToObject() this device: %s"), achFriendlyName));
                        SysFreeString(var.bstrVal);
                    }
                }
            }
            pBag->Release();
        }

        if(bFound)
            // locate the object identified by the moniker and return a pointer to one of its interfaces
            //     IBaseFilter *pVCap, *pACap;
            hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**)&m_pVCap);
        pM->Release();      
    }  // While

    if(m_pVCap == NULL) {
        DbgLog((LOG_TRACE,1,TEXT("Error %x: Cannot create video capture filter"), hr));
        goto InitCapFiltersFail;
    } else {
        // With a valid m_pVCap, we can make this query.
        *pbUseOVMixer = BGf_OverlayMixerSupported();
        DbgLog((LOG_TRACE,2,TEXT("Info: bUseOVMixer=%s"), *pbUseOVMixer?"Yes":"No"));
    }


    // Add audio capture filter.
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //    1b. Find the AUDIO capture device and bind to this capture object.
    //---------------------------------------------------------------------
    BGf_GetObjCaptureDevicePath(BGf_DEVICE_AUDIO);  // Trigger setting the default audio capture device.

    if(!bAddAudioFilter || !m_pAudioEnumMoniker || !m_pObjACaptureCurrent)
        goto SkipAudio;

    m_pAudioEnumMoniker->Reset();

    m_pACap = NULL;
    bFound = FALSE;

    while(hr = m_pAudioEnumMoniker->Next(1, &pM, &cFetched), hr==S_OK && !bFound) {
        // Find what we want based on the DevicePath that we had used to CreateFile()
        // Get its name, and instantiate it.
        IPropertyBag *pBag;
        achFriendlyName[0] = 0;
        hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
        if(SUCCEEDED(hr)) {
            VARIANT var;
            var.vt = VT_BSTR;
            hr = pBag->Read(L"DevicePath", &var, NULL);
            if(hr == NOERROR) {
#ifndef _UNICODE
                WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achDevicePath, _MAX_PATH, NULL, NULL);
#else
                _tcsncpy(achDevicePath, var.bstrVal, MAX_PATH-1);
#endif
                SysFreeString(var.bstrVal);

                if(_tcscmp(m_EnumADeviceInfoCurrent.strDevicePath, achDevicePath) == 0) {// same Devicepath used to CreateFile()
                    bFound = TRUE;
                    hr = pBag->Read(L"FriendlyName", &var, NULL);

                    if(hr == NOERROR) {
#ifndef _UNICODE
                        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achFriendlyName, 80, NULL, NULL);
#else
                        _tcsncpy(achFriendlyName, var.bstrVal, MAX_PATH-1);
#endif
                        DbgLog((LOG_TRACE,2,TEXT("BindToObject() this device: %s"), achFriendlyName));
                        SysFreeString(var.bstrVal);
                    }
                }
            }
            pBag->Release();
        }

        if(bFound)
            // locate the object identified by the moniker and return a pointer to one of its interfaces
            //     IBaseFilter *pVCap, *pACap;
            hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**)&m_pACap);
        pM->Release();      
    }  // While

    if(m_pACap == NULL) {
        DbgLog((LOG_TRACE,1,TEXT("Error %x: Cannot create video capture filter"), hr));
        goto InitCapFiltersFail;
    } else {
        // If we have successfully chosen a audio filter, that means we want to capture audio.
        m_fCapAudio = TRUE;
    }


SkipAudio:

    //
    // Instantiate graph builder
    //
    if(NOERROR !=
        CoCreateInstance(
            (REFCLSID)CLSID_CaptureGraphBuilder,
            NULL,
            CLSCTX_INPROC,
            (REFIID)IID_ICaptureGraphBuilder,
            (void **)&m_pBuilder)) {
        DbgLog((LOG_TRACE,1,TEXT("Cannot initiate graph builder.")));
        goto InitCapFiltersFail;
    }


    //
    // make a filtergraph, give it to the graph builder and put the video
    // capture filter in the graph
    //
    if(NOERROR !=
        CoCreateInstance(
            CLSID_FilterGraph,
            NULL,
            CLSCTX_INPROC,
            IID_IGraphBuilder,
            (LPVOID *) &m_pFg)) {

        DbgLog((LOG_TRACE,1,TEXT("Cannot make a filter graph.")));
        goto InitCapFiltersFail;
    } else {
        if(NOERROR !=
            m_pBuilder->SetFiltergraph(m_pFg)) {
                DbgLog((LOG_TRACE,1,TEXT("Cannot give graph to builder")));
            goto InitCapFiltersFail; 
        }
    }


    //++++++++++++++++++++++++++++++++++++++++++++++
    //    2. Insert this object to the graph builder
    //----------------------------------------------
    hr = m_pFg->AddFilter(m_pVCap, NULL);
    if(hr != NOERROR) {
        DbgLog((LOG_TRACE,1,TEXT("Error %x: Cannot add VIDEO capture fitler to filtergraph"), hr));
        goto InitCapFiltersFail;
    }

    if(bAddAudioFilter && m_pACap) {
        hr = m_pFg->AddFilter(m_pACap, NULL);
        if(hr != NOERROR) {
            DbgLog((LOG_TRACE,1,TEXT("Error %x: Cannot add AUDIO capture filter to filtergraph"), hr));
            goto InitCapFiltersFail;
        }
    }

    // potential debug output - what the graph looks like
    //DumpGraph(m_pFg, 2);

    //+++++++++++++++++++++++++++++++++++++++
    //    3. Find all its related interfaces.
    //---------------------------------------

    // Calling FindInterface below will result in building the upstream
    // section of the capture graph (any WDM TVTuners or Crossbars we might
    // need).
#if DBG || defined(_DEBUG)
    DWORD dwTime1, dwTime2;
    dwTime1 = timeGetTime();
#endif
    // we use this interface to get the name of the driver
    // Don't worry if it doesn't work:  This interface may not be available
    // until the pin is connected, or it may not be available at all.
    hr = m_pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, m_pVCap, IID_IAMVideoCompression, (void **)&m_pIAMVC);

#if DBG || defined(_DEBUG)
    dwTime2 = timeGetTime();
    DbgLog((LOG_TRACE,2,TEXT("====>Elapsed time calling first FindInterface()=%d msec"), dwTime2 - dwTime1));
#endif

    // !!! What if this interface isn't supported?
    // we use this interface to set the frame rate and get the capture size
    hr = m_pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, m_pVCap, IID_IAMStreamConfig, (void **)&m_pIAMVSC);
    if(hr != NOERROR) {
        // this means we can't set frame rate (non-DV only)
        DbgLog((LOG_TRACE,1,TEXT("Error %x: Cannot find VCapture:IAMStreamConfig"), hr));
    }

    // we use this interface to bring up the 3 dialogs
    // NOTE:  Only the VfW capture filter supports this.  This app only brings
    // up dialogs for legacy VfW capture drivers, since only those have dialogs
    hr = m_pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, m_pVCap, IID_IAMVfwCaptureDialogs, (void **)&m_pIAMDlg);


    //
    // Find if TVTuner interface
    //
    if(S_OK == m_pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, m_pVCap, IID_IAMTVTuner, (void **)&m_pIAMTV)) {
        // Get/put a default channel; maybe last persisted channel
        LONG lChannel, lVideoSubChannel, lAudioSubChannel;
        if(S_OK == m_pIAMTV->get_Channel(&lChannel, &lVideoSubChannel, &lAudioSubChannel)) {
            m_pIAMTV->put_Channel(lChannel, lVideoSubChannel, lAudioSubChannel);
        }
    }


    //
    // Query cross bar interfaces and their base filters (use for routing).
    //
    if(S_OK == m_pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, m_pVCap, IID_IAMCrossbar, (void **)&m_pIAMXBar1)) {
        // Query first cross bar's (video source/output) pin counts
        m_pIAMXBar1->get_PinCounts(&m_XBar1OutPinCounts, &m_XBar1InPinCounts);

        // If there is an interface, find its filter.
        if(S_OK == m_pIAMXBar1->QueryInterface(IID_IBaseFilter, (void **)&m_pXBar1)) {
            // If there is a base filter, find its up stream has another cross bar interface.
            hr = m_pBuilder->FindInterface(&LOOK_UPSTREAM_ONLY, m_pXBar1, IID_IAMCrossbar, (void **)&m_pIAMXBar2);
            if(hr == S_OK)
                // Find the base filter for 2nd cross bar
                m_pIAMXBar2->QueryInterface(IID_IBaseFilter, (void **)&m_pXBar2);
        }
    } else {
        // If Overlay mixer is supported, that mean it must has a crossbar.
        // And if cannot find crossbar, we shoudl fail !!
        if(BGf_OverlayMixerSupported()) {
            DbgLog((LOG_TRACE,1,TEXT("Canot find crossbar but use OVMixer.")));
#if 0
               // Wrong assumption:
               // Not all device has a video port need to have a crossbar
            goto InitCapFiltersFail;
#endif
        }
    }

    if(!BGf_OverlayMixerSupported()) {
        // potential debug output - what the graph looks like
        //  If overlay is supported, we will dump the graph when its downstream is rendered.
        DumpGraph(m_pFg, 2);
    }

    return S_OK;

InitCapFiltersFail:
    FreeCapFilters();
    return E_FAIL;
}


//
// Get in pin counts of the capture filter.
//
LONG
CCaptureGraph::BGf_GetInputChannelsCount()
{
    return m_XBar1InPinCounts;
}


//
// Where does the output pin 0 route to ?
//
LONG
CCaptureGraph::BGf_GetIsRoutedTo()
{
    LONG idxInPin;

    // Assuming one output pin. 
    if(m_pIAMXBar1) {
        m_pIAMXBar1->get_IsRoutedTo(0, &idxInPin);
        return idxInPin;
    }

    return -1;  // This is an error since index start from 0
}

#define MAX_PINNAME_LEN 128
//
// For a given cross bar filter, find its input pins.
//
LONG
CCaptureGraph::BGf_CreateInputChannelsList(
    PTCHAR ** ppaPinNames)
{

    LONG i, j, idxPinRelated, lPhyType;
    LONG cntNumVideoInput = 0;
    PTCHAR * paPinNames;  // an array of ptrs to str

    if(!m_pIAMXBar1 || m_XBar1InPinCounts == 0)
        return 0;

    paPinNames = (PTCHAR *) new PTCHAR[m_XBar1InPinCounts];
    if(!paPinNames)
        return 0;

    for(i=0; i<m_XBar1InPinCounts; i++) {
        paPinNames[i] = (PTCHAR) new TCHAR[MAX_PINNAME_LEN];
        if(!paPinNames[i]) {
            for(j=0; j < i; j++)
                delete paPinNames[j];
            delete [] paPinNames;
            DbgLog((LOG_TRACE,1,TEXT("CreateInputChannelsList:Failed to allocate resource.")));
            return 0;
        }
    }


    for(i=0; i<m_XBar1InPinCounts; i++) {

        if(S_OK ==
            m_pIAMXBar1->get_CrossbarPinInfo(
                    TRUE,
                    i,
                    &idxPinRelated,
                    &lPhyType)) {

            // We only interested in Video input
            // anything less than PhysConn_Audio_Tuner=0x1000 is Video input.
            if(lPhyType < PhysConn_Audio_Tuner) {
                // This list is not complete!! but that is all we support at this time.
                switch(lPhyType) {
                case PhysConn_Video_Tuner:
                    LoadString(m_hInstance, IDS_VIDEO_TUNER, paPinNames[i], MAX_PINNAME_LEN);
                    break;
                case PhysConn_Video_Composite:
                    LoadString(m_hInstance, IDS_VIDEO_COMPOSITE, paPinNames[i], MAX_PINNAME_LEN);
                    break;
                case PhysConn_Video_SVideo:
                    LoadString(m_hInstance, IDS_VIDEO_SVIDEO, paPinNames[i], MAX_PINNAME_LEN);
                    break;
                case PhysConn_Audio_Tuner:
                    LoadString(m_hInstance, IDS_AUDIO_TUNER, paPinNames[i], MAX_PINNAME_LEN);
                    break;
                default:
                    LoadString(m_hInstance, IDS_SOURCE_UNDEFINED, paPinNames[i], MAX_PINNAME_LEN);
                    break;
                }
                DbgLog((LOG_TRACE,2,TEXT("%s(%d), idxIn=%d:idxRelated=%d"), paPinNames[i], lPhyType, i, idxPinRelated));
                cntNumVideoInput++;
            }
        }
    }

    *ppaPinNames = paPinNames;

    return cntNumVideoInput; // m_XBar1InPinCounts;
}


//
// Destroy the allocated array.
// The danger is the number of pins, can that changed? while user request this ?  YES!!
//
void
CCaptureGraph::BGf_DestroyInputChannelsList(
    PTCHAR * paPinNames)
{
    LONG i;

    if(paPinNames) {
        for(i=0; i < m_XBar1InPinCounts; i++)
            delete paPinNames[i];

        delete paPinNames;
    }
}


//
// Does the selected input pin support TVTuner ?
//
BOOL
CCaptureGraph::BGf_SupportTVTunerInterface()
{
    if(m_pIAMTV && m_pIAMXBar1 && m_pXBar1) {
        // This device support a Tuner input but is that channel routed to PhysConn_Video_Tuner ?        
        LONG idxInPin;
        // Assume the outpin is pin index 0.
        if(S_OK == m_pIAMXBar1->get_IsRoutedTo(0, &idxInPin)) {
            LONG idxInPinRelated, lPhyType = -1;
            if(S_OK ==
                m_pIAMXBar1->get_CrossbarPinInfo(
                    TRUE,
                    idxInPin,
                    &idxInPinRelated,
                    &lPhyType)) {
                 return lPhyType == PhysConn_Video_Tuner;
            }
        }
    }

    return FALSE;
}



//
// Find a matching in/out pin in a filter and route them
//
HRESULT
CCaptureGraph::RouteInToOutPins(
    IAMCrossbar * pIAMXBar,
    LONG idxInPin)
{

    // Get in/out pin counts
    LONG cntInPins, cntOutPins;

    if(S_OK !=
        pIAMXBar->get_PinCounts(&cntOutPins, &cntInPins))
        return E_FAIL;

    // Route an input pin to a acceptable output pin.
    for(LONG i=0; i<cntOutPins; i++) {
        if(S_OK == pIAMXBar->CanRoute(i, idxInPin)) {
            if(S_OK == pIAMXBar->Route(i, idxInPin)) {
                DbgLog((LOG_TRACE,2,TEXT("Route [%d]:[%d]"), idxInPin, i));
                return S_OK;
            }
        }
    }

    return E_FAIL;
}


//
// Royte the related pin in a crossbar; mainly use for routing the audio pin.
//
HRESULT
CCaptureGraph::RouteRelatedPins(
    IAMCrossbar * pIAMXBar,
    LONG idxInPin)
{
    //
    // Look for its related audio input pin;
    // if found, route it its matching output pin.
    //

    // Get in/out pin counts
    LONG cntInPins, cntOutPins;
    if(S_OK !=
        pIAMXBar->get_PinCounts(&cntOutPins, &cntInPins))
        return E_FAIL;

    // Find its related input pin
    LONG idxInPinRelated = -1;
    LONG lPhyType;
    if(S_OK !=
        pIAMXBar->get_CrossbarPinInfo(
                TRUE,
                idxInPin,
                &idxInPinRelated,
                &lPhyType)) {
        return E_FAIL;
    }

    // Route the related input pin to a acceptable output pin.
    if(idxInPinRelated >= 0 && idxInPinRelated < cntInPins) {     // Validate
        return RouteInToOutPins(pIAMXBar, idxInPinRelated);
    }

    return S_OK;    // If there is related pin to route, that is OK.
}

//
// Find corresponding IPIN from an index in a filter.
//
HRESULT
CCaptureGraph::FindIPinFromIndex(
    IBaseFilter * pFilter,
    LONG idxInPin,
    IPin ** ppPin)
{
    IEnumPins *pins;
    IPin * pP  =0;
    ULONG n;

    *ppPin = 0;

    if(SUCCEEDED(pFilter->EnumPins(&pins))) {
        LONG i=0;
        while(pins->Next(1, &pP, &n) == S_OK) {
            if(i == idxInPin) {
                *ppPin = pP;
                pins->Release();
                return S_OK;
            }
            pP->Release();
            i++;
        }
        pins->Release();
    }

    return E_FAIL;
}


//
// Find corresponding index of an IPIN in a crossbar.
//
HRESULT
CCaptureGraph::FindIndexFromIPin(
    IBaseFilter * pFilter,
    IAMCrossbar * pIAMXBar,
    IPin * pPin,
    LONG *pidxInPin)

{
    HRESULT hrResult = E_FAIL;
    LONG cntInPins, cntOutPins;
    IEnumPins *pins;
    IPin * pP =0;
    ULONG n;
    PIN_INFO pinInfo1, pinInfo2;

    if(S_OK != pIAMXBar->get_PinCounts(&cntOutPins, &cntInPins)) {
       return hrResult;
    }

    if(SUCCEEDED(pPin->QueryPinInfo(&pinInfo1))) {
      if(SUCCEEDED(pFilter->EnumPins(&pins))) {
         LONG i=0;
         while(pins->Next(1, &pPin, &n) == S_OK) {
            if(SUCCEEDED(pPin->QueryPinInfo(&pinInfo2))) {
               pinInfo2.pFilter->Release();
               if((pinInfo1.dir == pinInfo2.dir) &&
                     wcscmp(pinInfo1.achName, pinInfo2.achName) == 0) {
                  hrResult = S_OK;
                  pPin->Release();
                  if(pinInfo1.dir == PINDIR_OUTPUT) {
                     *pidxInPin = i - cntInPins;
                     break;
                   } else {
                     *pidxInPin = i;
                     break;
                   }
                }
            }
            pPin->Release();
            i++;
         } // endwhile
         pins->Release();
      } // if QueryPinInfo
      pinInfo1.pFilter->Release();
   }

   return hrResult;
}


//
// Given an index of an output pin, route the signals.
//
HRESULT
CCaptureGraph::BGf_RouteInputChannel(
    LONG idxInPin)
{
    HRESULT hr;

    //
    // 1st XBar
    //
    // 1.Route input to a matching output pin
    // 2.Look for its related audio input pin;
    //   if found, route it its matching output pin.
    //
    if(m_pXBar1 && m_pIAMXBar1) {

        hr = RouteInToOutPins(m_pIAMXBar1, idxInPin);
        if(hr != S_OK) return hr;

        hr = RouteRelatedPins(m_pIAMXBar1, idxInPin);
        if(hr != S_OK) return hr;

    } else {
        DbgLog((LOG_TRACE,1,TEXT("BGf_RouteInputChannel: there is no m_pIAMXBar1")));
        return E_FAIL;
    }

    //
    // 2nd upstream XBar (if there is one!)
    //
    // 1.find (IPin*) pInPinSelected from idxInSelected
    // 2.find (IPin*) pOutPinSelected from pInPinSelected "->ConnectedTo()"
    // 3.find idxOutSelected from pOutPinSelected
    // 4.find idxInRoutedTo from idxOutSelected "->get_IsRoutedTo()"
    // 5.RouteRelatedPins using idxInRoutedTo
    //
    if(m_pXBar2 && m_pIAMXBar2) {

        IPin * pInPin1  =0;   // Input pin of XBar1
        IPin * pOutPin2 =0;   // Output pin of XBar2
        LONG idxOutPin2, idxInPin2;

        // 1.
        hr = FindIPinFromIndex(m_pXBar1, idxInPin, &pInPin1);
        DbgLog((LOG_TRACE,2,TEXT("XBar1[%d]:[?]"),idxInPin));
        if(hr != S_OK) return hr;

        // 2.
        hr = pInPin1->ConnectedTo(&pOutPin2);
        pInPin1->Release();
        if(hr != S_OK) return hr;

        // 3.
        hr = FindIndexFromIPin(m_pXBar2, m_pIAMXBar2, pOutPin2, &idxOutPin2);
        pOutPin2->Release();
        DbgLog((LOG_TRACE,2,TEXT("XBar2[?]:[%d]"), idxOutPin2));
        if(hr != S_OK) return hr;

        // 4.
        hr = m_pIAMXBar2->get_IsRoutedTo(idxOutPin2, &idxInPin2);
        DbgLog((LOG_TRACE,2,TEXT("XBar2[%d]:[%d]"), idxInPin2, idxOutPin2));
        if(hr != S_OK || idxInPin2 < 0) return hr;

        // 5.
        //hr = RouteInToOutPins(m_pIAMXBar2, idxInPin2);  // Not needed or 4 won;t work!!
        //if(hr != S_OK) return hr;
        hr = RouteRelatedPins(m_pIAMXBar2, idxInPin2);
        if(hr != S_OK) return hr;
    }

    return S_OK;
}


//
// Render the preview pin - even if there is not preview pin, the capture
// graph builder will use a smart tee filter and provide a preview.
//

HRESULT
CCaptureGraph::BGf_BuildGraphDownStream(
    TCHAR * pstrCapFilename)
{
    if(S_OK ==
        m_pBuilder->RenderStream(
            &PIN_CATEGORY_PREVIEW,
            m_pVCap,
            NULL,    // Compressor
            NULL)) {  // Renderer


        if(m_pVW) {
            DbgLog((LOG_TRACE,1,TEXT("BGf_BuildGraphDownStream: m_pVW is not NULL!!!")));
            ASSERT(m_pVW == NULL);
            m_pVW->Release();
            m_pVW = 0;
        }

        if(NOERROR !=
            m_pBuilder->FindInterface(&PIN_CATEGORY_PREVIEW, m_pVCap, IID_IVideoWindow, (void **)&m_pVW)) {

            // VfWWDM only care about rendering its Preview/VP pin to use the overlay mixer
            if(m_PurposeFlags == BGf_PURPOSE_VFWWDM) {           
                DbgLog((LOG_TRACE,1,TEXT("Search via PIN_CATEGORY_VIDEOPORT/Preview but cannot find its window m_pVW.")));
                return E_FAIL;

            } else {
                if(NOERROR !=
                    m_pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, m_pVCap, IID_IVideoWindow, (void **)&m_pVW)) {
                    DbgLog((LOG_TRACE,1,TEXT("Search via PIN_CATEGORY_CAPTURE/PIN_CATEGORY_CAPTURE but cannot find its window m_pVW.")));
                    return E_FAIL;
                }
            }
        }


        // Get Overlay Window's default position
        if(m_pVW) {

            // Its original owner
            m_pVW->get_Owner((OAHWND*)&m_hWndOwner);

            m_pVW->GetWindowPosition(&m_lLeft, &m_lTop, &m_lWidth, &m_lHeight);
            DbgLog((LOG_TRACE,2,TEXT("O.M. Windows hWndOwner %x, Position(%dx%d, %d, %d)"), m_hWndOwner, m_lLeft, m_lTop, m_lWidth, m_lHeight));

            /*
            Many simple applications require a displayed window
            when a filter graph is set to the running state.
            AutoShow defaults to OATRUE so that when the graph changes
            state to paused or running, the window is visible (it also
            is set as the foreground window). It will remain visible on
            all subsequent state changes to paused or running. If you
            close the window while the stream is running, the window
            will not automatically reappear. If you stop and restart
            the stream, however, the window will automatically reappear.
            */
            //
            // turned auto show off so we have full control of
            // renderer window's visibility.
            //
            LONG lAutoShow = 0;

            if(S_OK == m_pVW->get_AutoShow(&lAutoShow)) {
                DbgLog((LOG_TRACE,2,TEXT("StartPreview: default AutoShow is %s"), lAutoShow==-1?"On":"Off"));
                if(lAutoShow == -1) {
                    if(S_OK != m_pVW->put_AutoShow(0)) {
                        DbgLog((LOG_TRACE,1,TEXT("CanNOT set render to AutoShow(0) when set to PAUSE or RUN.")));
                    } else {
                        DbgLog((LOG_TRACE,2,TEXT("Set render to AutoShow(0:OAFALSE) when set to RUN or PAUSE.")));
                    }
                }
            }

            // Cache original window style and use it to restore to its original state.
            if(S_OK == m_pVW->get_WindowStyle(&m_lWindowStyle)) {
                DbgLog((LOG_TRACE,2,TEXT("lWindowStyle=0x%x, WS_OVERLAPPEDWINDOW=0x%x, WS_CHILD=0x%x"), m_lWindowStyle, WS_OVERLAPPEDWINDOW, WS_CHILD));
            }
        }

        DbgLog((LOG_TRACE,2,TEXT("BGf_BuildGraphDownStream: After ->RenderStream(), m_pVW=%x"), m_pVW));

        m_fPreviewGraphBuilt = TRUE;
    } else {
        m_fPreviewGraphBuilt = FALSE;
        DbgLog((LOG_TRACE,2,TEXT("This graph cannot render the preview stream!")));
    }

    // May want to insert additional filter to render the capture stream
    // AVIMUX, File Writer (pstrCapFilename)..etc.


    // potential debug output - what the graph looks like
    DumpGraph(m_pFg, 2);

    if(m_fPreviewGraphBuilt)
        return S_OK;
    else {
        return E_FAIL;
    }
}


IMediaEventEx *
CCaptureGraph::BGf_RegisterMediaEventEx(
    HWND hWndNotify,
    long lMsg,
    long lInstanceData)
{
    HRESULT hr;

    if(m_pFg) {
        // now ask the filtergraph to tell us when something is completed or aborted
        // (EC_COMPLETE, EC_USERABORT, EC_ERRORABORT).  This is how we will find out
        // if the disk gets full while capturing
        hr = m_pFg->QueryInterface(IID_IMediaEventEx, (void **)&m_pMEEx);
        if(hr == NOERROR) {
         m_pMEEx->SetNotifyWindow(PtrToLong(hWndNotify), lMsg, (long)lInstanceData);
        }

        return m_pMEEx;
    }

    return NULL;
}

//
// Build a preview graph from a given device path.
//
HRESULT
CCaptureGraph::BGf_BuildPreviewGraph(
    TCHAR * pstrVideoDevicePath,
    TCHAR * pstrAudioDevicePath,
    TCHAR * pstrCapFilename)
{
    BOOL bUseOVMixer;

    if(BGf_PreviewGraphBuilt()) {
        DbgLog((LOG_TRACE,1,TEXT("Graph is already been built.")));
        return S_OK;
    }

    //
    // Set video and audio (optional) device as the current capture devices
    // and to be added the the capture graph
    //
    if(!pstrVideoDevicePath) {
        return E_FAIL;
    }
    if(S_OK != BGf_SetObjCapture(BGf_DEVICE_VIDEO, pstrVideoDevicePath)) {
        DbgLog((LOG_TRACE,1,TEXT("SetObjCapture has failed. Video Device is: %s"),pstrVideoDevicePath));
        return E_FAIL;
    }
    // Optional
    if(pstrAudioDevicePath) {
        if(S_OK != BGf_SetObjCapture(BGf_DEVICE_AUDIO, pstrAudioDevicePath)) {
            DbgLog((LOG_TRACE,1,TEXT("SetObjCapture has failed. Audio Device is: %s"),pstrAudioDevicePath));
            return E_FAIL;
        }
    }


    //
    // Build upstream (Add the audio filter if present)
    //
    if(S_OK != BGf_BuildGraphUpStream(pstrAudioDevicePath != 0, &bUseOVMixer)) {
        DbgLog((LOG_TRACE,1,TEXT("Build capture graph has failed!!")));
        return E_FAIL;
    }


    //
    // Route the related audio pin
    //
    LONG idxIsRoutedTo = BGf_GetIsRoutedTo();
    if(idxIsRoutedTo >= 0) {
        if(S_OK != BGf_RouteInputChannel(idxIsRoutedTo)) {
            DbgLog((LOG_TRACE,1,TEXT("Cannot route input pin %d selected."), idxIsRoutedTo));
        }
    }


    //
    // Render its down stream;
    //
    if(S_OK != BGf_BuildGraphDownStream(pstrCapFilename)) {
        DbgLog((LOG_TRACE,1,TEXT("Failed to render the preview pin.")));
        return E_FAIL;
    }


    return S_OK;
}


//
// Query the device handle from the video capture filter
//
HANDLE
CCaptureGraph::BGf_GetDeviceHandle(BGf_DEVICE_TYPE DeviceType)
{
    HANDLE hDevice = 0;
    IKsObject *pKsObject;

    if(DeviceType == BGf_DEVICE_VIDEO) {
        if(m_pVCap) {
            // Obtain the device/fitler handle so we can communicate with it for such thing as device properties.
            if(NOERROR ==
                m_pVCap->QueryInterface(__uuidof(IKsObject), (void **) &pKsObject) ) {

                hDevice = pKsObject->KsGetObjectHandle();
                DbgLog((LOG_TRACE,2,TEXT("BuildGraph: hDevice = pKsObject->KsGetObjectHandle() = %x"), hDevice));
                pKsObject->Release();
            }
        }
    } else {
        if(m_pACap) {
            // Obtain the device/fitler handle so we can communicate with it for such thing as device properties.
            if(NOERROR ==
                m_pACap->QueryInterface(__uuidof(IKsObject), (void **) &pKsObject) ) {

                hDevice = pKsObject->KsGetObjectHandle();
                DbgLog((LOG_TRACE,2,TEXT("BuildGraph: hDevice = pKsObject->KsGetObjectHandle() = %x"), hDevice));
                pKsObject->Release();
            }
        }
    }

    return hDevice;
}

//
// Query the device handle from the video capture filter
//
HRESULT
CCaptureGraph::BGf_GetCapturePinID(DWORD *pdwPinID)
{
    HRESULT hr = E_FAIL;

    if(m_pVCap) {

        IPin * pIPin;
        hr = m_pBuilder->FindInterface(
             &PIN_CATEGORY_CAPTURE,
             m_pVCap,
             IID_IPin,
             (void **)&pIPin);

        if (pIPin) {
            IKsPinFactory * PinFactoryInterface;

            hr = pIPin->QueryInterface(__uuidof(IKsPinFactory), reinterpret_cast<PVOID*>(&PinFactoryInterface));
            if (SUCCEEDED(hr)) {
                hr = PinFactoryInterface->KsPinFactory(pdwPinID);
                PinFactoryInterface->Release();
            }

            pIPin->Release();
        }
    }

    DbgLog((LOG_TRACE,2,TEXT("BGf_GetCapturePinID: hr %x, PinID %d"), hr, *pdwPinID));

    return hr;
}



//
// Determine if an overlay mixer can be or is used in a graph
// This may apply to VfWWDM only.
//
BOOL
CCaptureGraph::BGf_OverlayMixerSupported()
{
    ULONG n;
    GUID guidPin;
    HRESULT hrRet = E_FAIL;

    if(!m_pVCap)
        return FALSE;

    IEnumPins *pins;
    if(S_OK == m_pVCap->EnumPins(&pins)) {
        IPin *pPin;
        BOOL bFound = FALSE;
        while(!bFound && S_OK!=hrRet && S_OK==pins->Next(1,&pPin,&n)) {
            IKsPropertySet *pKs;
            DWORD dw;

            if(S_OK == pPin->QueryInterface(IID_IKsPropertySet, (void **)&pKs)) {
                if(pKs->Get(AMPROPSETID_Pin, AMPROPERTY_PIN_CATEGORY, NULL, 0, &guidPin, sizeof(GUID), &dw) == S_OK) {
                    // Only Preview and VP pin can do Overlay
                    if(guidPin == PIN_CATEGORY_VIDEOPORT) {
                        DbgLog((LOG_TRACE,2,TEXT("This filter support a VP pin.")));
                        bFound = TRUE;
                        hrRet = S_OK;
                    }
                    else if(guidPin == PIN_CATEGORY_PREVIEW) {
                        DbgLog((LOG_TRACE,2,TEXT("This filter support a Preview pin.")));
                        bFound = TRUE;

                        IEnumMediaTypes *pEnum;
                        if(NOERROR ==
                            pPin->EnumMediaTypes(&pEnum)) {

                            ULONG u;
                            AM_MEDIA_TYPE *pmt;
                            pEnum->Reset();
                            while(hrRet != S_OK && NOERROR == pEnum->Next(1, &pmt, &u)) {

                                if(IsEqualGUID(pmt->formattype, FORMAT_VideoInfo2)) {
                                    DbgLog((LOG_TRACE,2,TEXT("This filter support a Preview pin with VideoInfo2.")));
                                    hrRet = S_OK;
                                }
#if 1 // Even though it might not use OVmixer,
      // it is still a preview pin!!
      // With this, this while loop will exist after 1st Enum and hrRet == S_OK
                                else
                                  hrRet = S_OK;
#endif

                                DeleteMediaType(pmt);
                            }
                            pEnum->Release();
                        }
                    }   
                }
                pKs->Release();
            }
            pPin->Release();
        } // while
        pins->Release();
    }

    return hrRet == S_OK;
}

//
// Show stand alone TV tuner property page.
//
void
CCaptureGraph::ShowTvTunerPage(HWND hWnd)
{
    HRESULT hr;

    if(!m_pIAMTV)
        return;

    ISpecifyPropertyPages *pSpec;
    CAUUID cauuid;
    hr = m_pIAMTV->QueryInterface(IID_ISpecifyPropertyPages, (void **)&pSpec);
    RECT rc;
    if(!hWnd) {
        GetWindowRect(hWnd, &rc);
        DbgLog((LOG_TRACE,1,TEXT("xxxxxxxxx  %d %d"), rc.left, rc.top));
    }
    if(hr == S_OK) {
        hr = pSpec->GetPages(&cauuid);
        hr = OleCreatePropertyFrame(
                    hWnd,
                    hWnd ? rc.left : 30,
                    hWnd ? rc.top : 30,
                    NULL, 1,
                    (IUnknown **)&m_pIAMTV, cauuid.cElems,
                    (GUID *)cauuid.pElems, 0, 0, NULL);
    CoTaskMemFree(cauuid.pElems);
    pSpec->Release();
    }
}



//
//  Claim ownership of the render window and set its intial window position.
//
HRESULT
CCaptureGraph::BGf_OwnPreviewWindow(
    HWND hWndClient,
    LONG lWidth,
    LONG lHeight)
{

    // Find Preview window (ActiveMovie OverlayMixer video renderer window)
    // This will go through a possible decoder, find the video renderer it's
    // connected to, and get the IVideoWindow interface on it
    // If the capture filter doesn't have a preview pin, and preview is being
    // faked up with a smart tee filter, the interface will actually be on
    // the capture pin, not the preview pin
    if(!m_pVW) {

        if(NOERROR !=
            m_pBuilder->FindInterface(&PIN_CATEGORY_PREVIEW, m_pVCap, IID_IVideoWindow, (void **)&m_pVW)) {

            // VfWWDM only care about rendering its Preview/VP pin to use the overlay mixer
            if(m_PurposeFlags == BGf_PURPOSE_VFWWDM) {           
                DbgLog((LOG_TRACE,1,TEXT("Search via PIN_CATEGORY_VIDEOPORT/Preview but cannot find its window m_pVW.")));
                return E_FAIL;

            } else {
                if(NOERROR !=
                    m_pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, m_pVCap, IID_IVideoWindow, (void **)&m_pVW)) {
                    DbgLog((LOG_TRACE,1,TEXT("Search via PIN_CATEGORY_CAPTURE/PIN_CATEGORY_CAPTURE but cannot find its window m_pVW.")));
                    return E_FAIL;
                }
            }
        }
    }

    if(!m_bSetChild) {
        DbgLog((LOG_TRACE,2,TEXT("Get the preview window to be a child of our app's window.")));
        if(m_hWndClient != hWndClient) {

            // This can be called to change the owning window. Setting the owner is done
            // through this function, however to make the window a true child window the
            // style must also be set to WS_CHILD. After resetting the owner to NULL an
            // application should also set the style to WS_OVERLAPPED | WS_CLIPCHILDREN.
            //
            // We cannot lock the object here because the SetParent causes an interthread
            // SendMessage to the owner window. If they are in GetState we will sit here
            // incomplete with the critical section locked therefore blocking out source
            // filter threads from accessing us. Because the source thread can't enter us
            // it can't get buffers or call EndOfStream so the GetState will not complete

            // This call also does a InvalidateRect(,NULL,TRUE).



            if(S_OK != m_pVW->put_Owner(PtrToLong(hWndClient))) {    // Client own the window now
                DbgLog((LOG_TRACE,1,TEXT(" can't put_Owner(hWndClient)")));
                return E_FAIL;

            } else {

                /*
                The video renderer passes messages to the specified message drain
                by calling the Microsoft Win32 PostMessage function. These messages
                allow you to write applications that include user interaction, such
                as applications that require mouse clicks on specific areas of the
                video display. An application can have a close relationship with the
                video window and know at certain time points to look for user interaction.
                When the renderer passes a message to the drain, it sends the parameters,
                such as the client-area coordinates, exactly as generated.
                */
                if(S_OK != m_pVW->put_MessageDrain(PtrToLong(hWndClient))) {
                    DbgLog((LOG_TRACE,1,TEXT(" can't put_MessageDrain((OAHWND)hWndClient)")));
                }

                LONG lWindowStyle;
                if(S_OK == m_pVW->get_WindowStyle(&lWindowStyle)) {
                    DbgLog((LOG_TRACE,2,TEXT("lWindowStyle=0x%x, WS_OVERLAPPEDWINDOW=0x%x, WS_CHILD=0x%x"), lWindowStyle, WS_OVERLAPPEDWINDOW, WS_CHILD));

                    lWindowStyle = m_lWindowStyle;
                    lWindowStyle &= ~WS_OVERLAPPEDWINDOW;
                    lWindowStyle &= ~WS_CLIPCHILDREN;
                    lWindowStyle |= WS_CHILD | SW_SHOWNOACTIVATE;

                    if(S_OK != m_pVW->put_WindowStyle(lWindowStyle)) {    // you are now a child
                        DbgLog((LOG_TRACE,1,TEXT(" can't put_WindowStyle(%x)"), lWindowStyle));
                    } else {
                        m_bSetChild = TRUE;
                    }
                }

                // Cache the client/owner/parent window
                m_hWndClient = hWndClient;

                // give the preview window all the client drawing area
                // Updated cached client area.
                if(lWidth > 0 && lHeight > 0) {
                    DbgLog((LOG_TRACE,2,TEXT("BGf_OwnPreviewWindow:SetWindowPosition(%d, %d, %d, %d)"), 0, 0, lWidth, lHeight));
                    m_pVW->SetWindowPosition(0, 0, lWidth, lHeight);
                    m_pVW->GetWindowPosition(&m_lLeft, &m_lTop, &m_lWidth, &m_lHeight);
                }
            }
        }
    }

    return NOERROR;
}


//
//  Claim ownership of the render window and set its intial window position.
//
HRESULT
CCaptureGraph::BGf_UnOwnPreviewWindow(
    BOOL bVisible)
{

    DbgLog((LOG_TRACE,2,TEXT("BGf_UnOwnPreviewWindow: bSetChild %d, UnOwn and set it %s"),
        m_bSetChild, bVisible?"VISIBLE":"HIDDEN" ));

    if(m_bSetChild) {
#if 1
        HWND hWndFocus1, hWndForeground1;
        HWND hWndFocus2, hWndForeground2;


        hWndFocus1 = GetFocus();
        hWndForeground1 = GetForegroundWindow();
#endif
        // Set to new visible state only if different from current.
        BGf_SetVisible(bVisible);


        // restore its style and owner
        // 46cf,0000 = WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_CAPTION |
        //             WS_SYSMENU | WS_THICKFRAME | WS_GROUP | WS_TABSTOP
        LONG lWindowStyle = m_lWindowStyle;

        m_pVW->put_WindowStyle(lWindowStyle); // Follow put_Owner advise.
        m_pVW->put_Owner(PtrToLong(m_hWndOwner));

        m_lWindowStyle = 0;
        m_bSetChild = FALSE;
        m_hWndClient = 0;

#if 1
        //
        // Focus and Forground will change after restore to its original owner (0),
        // So we restore its focus and foreground window
        //
        hWndFocus2 = GetFocus();
        hWndForeground2 = GetForegroundWindow();

        if(hWndFocus1 != hWndFocus2)
            SetFocus(hWndFocus1);

        if(hWndForeground1 != hWndForeground2)
            SetForegroundWindow(hWndForeground1);
#endif
        return TRUE;
    }
    return FALSE;

}

//
// Query renderer's owner's window position and set it
//
DWORD
CCaptureGraph::BGf_UpdateWindow(
    HWND hWndApp,
    HDC hDC)
{

    if(!m_fPreviewGraphBuilt || !m_pVW)
        return DV_ERR_NONSPECIFIC;

    //
    // Get the preview window to be a child of our app's window
    //
    if(!hWndApp && !m_hWndClient) {
        DbgLog((LOG_TRACE,1,TEXT("Cannot BGf_UpdateWindow() where client window is NULL!")));
        return DV_ERR_NONSPECIFIC;
    }

    RECT rc;
    GetClientRect(hWndApp, &rc);
    DbgLog((LOG_TRACE,2,TEXT("GetClientRect(hwnd=%x); (%dx%d), %d, %d"), hWndApp, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top));
    if(FAILED(BGf_OwnPreviewWindow(hWndApp ? hWndApp : m_hWndClient, rc.right-rc.left, rc.bottom-rc.top))) {
        DbgLog((LOG_TRACE,1,TEXT("BGf_UpdateWindow: Cannot set owner of the video renderer window!")));
        return DV_ERR_NONSPECIFIC;
    }

    DbgLog((LOG_TRACE,2,TEXT("UpdateWindow: hWndApp=%x; pVW=%x"), hWndApp, m_pVW));

    // Want to update?  Preview first.
    if(!m_fPreviewing) {
        long lVisible;
        m_pVW->get_Visible(&lVisible);
        DbgLog((LOG_TRACE,2,TEXT("Want to update ?  Preview first!")));

        // Start preview but do not change its current state.
        if(!BGf_StartPreview(lVisible == -1)) {
            return DV_ERR_NONSPECIFIC;
        }
    }

    // give the preview window all our space but where the status bar is
    GetClientRect(hWndApp ? hWndApp : m_hWndClient, &rc);

#if 1
    // this is one way to guarantee window refresh.
    m_pVW->SetWindowPosition(0+1, 0+1, rc.right-2, rc.bottom-2);
#endif
    m_pVW->SetWindowPosition(0, 0, rc.right, rc.bottom);
    // Update cached position
    m_pVW->GetWindowPosition(&m_lLeft, &m_lTop, &m_lWidth, &m_lHeight);

    return DV_ERR_OK;
}

//
// Tuen on/off preview graph;
// designed for DVM_STREAM_INIT/FINI for VIDEO_EXTERNALOUT channel.
//
DWORD
CCaptureGraph::BGf_SetVisible(
    BOOL bVisible)
{

    if(!m_fPreviewGraphBuilt || !m_pVW)
        return DV_ERR_NONSPECIFIC;

    if(!m_fPreviewing) {
        DbgLog((LOG_TRACE,1,TEXT("BGf_SetVisible:It is not previewing yet!")));
        return DV_ERR_NONSPECIFIC;
    }

    //
    // Only if current state is different from new state, set it.
    //
    LONG lVisible;
    m_pVW->get_Visible(&lVisible);

    // OATRUE (-1), the window is shown. If it is set to OAFALSE (0), hidden.
#if 1
    if((lVisible == 0  && bVisible) ||
       (lVisible == -1 && !bVisible)) {
#else
     // Always set
     if (1) {
#endif

        // Set it to visible does not guarantee to trigger renderer window to be refreshed,
        // but set its position does.
        if(bVisible) {
            // Set to its original size does not trigger refresh, so we set it a little smaller than back.
            m_pVW->put_Visible(bVisible?-1:0);

            m_pVW->GetWindowPosition(&m_lLeft, &m_lTop, &m_lWidth, &m_lHeight);
            DbgLog((LOG_TRACE,2,TEXT("WindwoPosition=(%dx%d, %d, %d)"), m_lLeft, m_lTop, m_lWidth, m_lHeight));
#if 1
            m_pVW->SetWindowPosition(1, 1, m_lWidth-2, m_lHeight-2);
#endif
            m_pVW->SetWindowPosition(0, 0, m_lWidth,   m_lHeight  );
        } else {
#if 1
            // show only one pixel so it will still be "visible".
            m_pVW->SetWindowPosition(-m_lWidth+1, -m_lHeight+1, m_lWidth, m_lHeight);
#endif
        }
    }

    return DV_ERR_OK;
}


//
// Query the SHOW state of the renderer.
//
DWORD
CCaptureGraph::BGf_GetVisible(
    BOOL *pbVisible)
{
    LONG lVisible;
    if(m_pVW) {
        // OATRUE (-1), the window is shown. If it is set to OAFALSE (0),
        m_pVW->get_Visible(&lVisible);

        *pbVisible = lVisible == -1;
        DbgLog((LOG_TRACE,2,TEXT("IVideoWindow is %s."), *pbVisible ? "Visible" : "Hidden"));
        return DV_ERR_OK;
    }
    return DV_ERR_NONSPECIFIC;
}



//
// Start previewing;
//
BOOL
CCaptureGraph::BGf_StartPreview(
    BOOL bVisible)
{
    // way ahead of you
    if(m_fPreviewing)
        return TRUE;

    if (!m_fPreviewGraphBuilt)
        return FALSE;

    // run the graph
    IMediaControl *pMC = NULL;
    HRESULT hr = m_pFg->QueryInterface(IID_IMediaControl, (void **)&pMC);

    if(SUCCEEDED(hr)) {

        // Start streaming...
        hr = pMC->Run();
        if(FAILED(hr)) {
            // stop parts that ran
            pMC->Stop();
        } else {
            // Must go before BGf_SetVisible.
            m_fPreviewing = TRUE;
            BGf_SetVisible(bVisible);
        }
        pMC->Release();
    }

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE,1,TEXT("Error %x: CanNOT set filter to RUN state."), hr));
        return FALSE;
    }

    return TRUE;
}


//
// Pause previewing;
//
BOOL
CCaptureGraph::BGf_PausePreview(
    BOOL bVisible)
{
    if (!m_fPreviewGraphBuilt)
        return FALSE;

    // pause the graph
    IMediaControl *pMC = NULL;
    HRESULT hr = m_pFg->QueryInterface(IID_IMediaControl, (void **)&pMC);

    if(SUCCEEDED(hr)) {

        // Pause streaming...
        hr = pMC->Pause();
        if(FAILED(hr)) {
            // stop parts that ran
            pMC->Stop();
        } else {
            // Must go before BGf_SetVisible.
            BGf_SetVisible(bVisible);
        }
        pMC->Release();
    }

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE,1,TEXT("Error %x: set filter to PAUSE state."), hr));
        return FALSE;
    }

    return TRUE;
}

//
// stop the preview graph
//
BOOL
CCaptureGraph::BGf_StopPreview(
    BOOL bVisible)
{
    // way ahead of you
    if (!m_fPreviewing) {
       return FALSE;
    }


    IMediaControl *pMC = NULL;
    HRESULT hr = m_pFg->QueryInterface(IID_IMediaControl, (void **)&pMC);

    if(SUCCEEDED(hr)) {
        // stop the graph
        hr = pMC->Stop();
        DbgLog((LOG_TRACE,1,TEXT("Preview graph to STOP state, hr %x"), hr));
        pMC->Release();
    }

    if (FAILED(hr)) {
        DbgLog((LOG_TRACE,1,TEXT("Error %x: Cannot stop preview graph"), hr));
        return FALSE;
    }

    m_fPreviewing = FALSE;

    return TRUE;
}


//
// Tear down everything downstream of the capture filters, so we can build
// a different capture graph.  Notice that we never destroy the capture filters
// and WDM filters upstream of them, because then all the capture settings
// we've set would be lost.
//
void
CCaptureGraph::BGf_DestroyGraph()
{
    DbgLog((LOG_TRACE,2,TEXT("BGf_DestroyGraph: 1")));
    if(m_pVW) {
        if(m_fPreviewing) {
            DbgLog((LOG_TRACE,2,TEXT("BGf_DestroyGraph:Stop previewing is it is still running !!")));
            BGf_StopPreview(FALSE);
        }

        // Calling from a 16bit application will hang here if put_Owner() is called.
        // DbgLog((LOG_TRACE,2,TEXT("put_Owner()")));
        // m_pVW->put_Owner(m_hWndOwner); // NULL);

        m_pVW->put_WindowStyle(m_lWindowStyle); // Follow put_Owner advise.
        m_pVW->put_Visible(OAFALSE);
        m_pVW->Release();
        m_pVW = NULL;

        m_lLeft = m_lTop = m_lWidth = m_lHeight = 0;
    }

    DbgLog((LOG_TRACE,2,TEXT("BGf_DestroyGraph: 2")));
    if(m_pVCap)
        NukeDownstream(m_pVCap);
    if(m_pACap)
        NukeDownstream(m_pACap);

    m_bSetChild  = FALSE;
    m_hWndClient = 0;
    m_XBar1InPinCounts = 0;
    m_XBar1OutPinCounts = 0;

    m_fPreviewGraphBuilt = FALSE;


    // potential debug output - what the graph looks like
    //if (m_pFg) DumpGraph(m_pFg, 2);
    DbgLog((LOG_TRACE,2,TEXT("BGf_DestroyGraph: 3")));

    FreeCapFilters();
}



//
// Tear down everything downstream of a given filter
//
void
CCaptureGraph::NukeDownstream(IBaseFilter *pf)
{
    IPin *pP, *pTo;
    ULONG u;
    IEnumPins *pins = NULL;
    PIN_INFO pininfo;

    HRESULT hr = pf->EnumPins(&pins);
    pins->Reset();
    while(hr == NOERROR) {
        DbgLog((LOG_TRACE,2,TEXT("RemoveFilter.......")));
        hr = pins->Next(1, &pP, &u);
        if(hr == S_OK && pP) {
            pP->ConnectedTo(&pTo);
            if(pTo) {
                hr = pTo->QueryPinInfo(&pininfo);
                if(hr == NOERROR) {
                    if(pininfo.dir == PINDIR_INPUT) {
                        NukeDownstream(pininfo.pFilter);
                        m_pFg->Disconnect(pTo);
                        m_pFg->Disconnect(pP);
                        m_pFg->RemoveFilter(pininfo.pFilter);
                    }
                    pininfo.pFilter->Release();
                }
                pTo->Release();
            }
            pP->Release();
        }
    }

    if(pins)
        pins->Release();
}



//
// Release capture filters and the graph builder
//
void
CCaptureGraph::FreeCapFilters()
{

    // Filters
    DbgLog((LOG_TRACE,2,TEXT("FreeCapFilters: Filters")));
    if(m_pVCap)     m_pVCap->Release(),     m_pVCap = NULL;
    if(m_pACap)     m_pACap->Release(),     m_pACap = NULL;
    if(m_pXBar1)    m_pXBar1->Release(),    m_pXBar1 = NULL;
    if(m_pXBar2)    m_pXBar2->Release(),    m_pXBar2 = NULL;

    // IAM*
    DbgLog((LOG_TRACE,2,TEXT("FreeCapFilters: IAM*")));
    if(m_pIAMASC)   m_pIAMASC->Release(),   m_pIAMASC = NULL;
    if(m_pIAMVSC)   m_pIAMVSC->Release(),   m_pIAMVSC = NULL;

    if(m_pIAMVC)    m_pIAMVC->Release(),    m_pIAMVC = NULL;
    if(m_pIAMDlg)   m_pIAMDlg->Release(),   m_pIAMDlg = NULL;

    if(m_pIAMTV)    m_pIAMTV->Release(),    m_pIAMTV = NULL;
    if(m_pIAMXBar2) m_pIAMXBar2->Release(), m_pIAMXBar2 = NULL;
    if(m_pIAMXBar1) m_pIAMXBar1->Release(), m_pIAMXBar1 = NULL;

    if(m_pIAMDF)    m_pIAMDF->Release(),    m_pIAMDF = NULL;

    if(m_pMEEx)     m_pMEEx->Release(),     m_pMEEx = NULL;

    // Builder and graph
    if(m_pFg)       m_pFg->Release(),        m_pFg = NULL;

    if(m_pBuilder)  m_pBuilder->Release(),   m_pBuilder = NULL;

    DbgLog((LOG_TRACE,2,TEXT("FreeCapFilters: Done!")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcapgf\ccapobj.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    CCapObj.cpp

Abstract:

    A class for a capture device object

Author:
    
    Yee J. Wu    24-April-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"         // mainly stream.h

#include "CCapObj.h"


CObjCapture::CObjCapture(
    TCHAR * pstrDevicePath,        
    TCHAR * pstrFriendlyName,
    TCHAR * pstrExtensionDLL 
    )    
    :
    CBaseObject(NAME("A Capture Device"))
/*++

Routine Description:

    The constructor 

Arguments:

 

Return Value:

    Nothing.

--*/
{
 
    CopyMemory(m_strDevicePath,   pstrDevicePath,   _MAX_PATH);
    CopyMemory(m_strFriendlyName, pstrFriendlyName, _MAX_PATH);
    CopyMemory(m_strExtensionDLL, pstrExtensionDLL, _MAX_PATH);

}

CObjCapture::~CObjCapture()
/*++

Routine Description:

    The constructor 

Arguments:

 

Return Value:

    Nothing.

--*/
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcapgf\ccapobj.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    CCapObj.h

Abstract:

    Header file for CCapObj.cpp

Author:
    
    Yee J. Wu  24-April-97

Environment:

    User mode only

Revision History:

--*/

#ifndef CCAPOBJ_H
#define CCAPOBJ_H

class CBaseObject;


class CObjCapture : public CBaseObject
{
private:

    TCHAR m_strDevicePath[_MAX_PATH];    // The unique device path
    TCHAR m_strFriendlyName[_MAX_PATH];
    TCHAR m_strExtensionDLL[_MAX_PATH]; 

public:

    CObjCapture(
        TCHAR * pstrDevicePath, 
        TCHAR * pstrFriendlyName,
        TCHAR * pstrExtensionDLL);  
    ~CObjCapture(); 

    TCHAR * GetDevicePath()   { return m_strDevicePath;}
    TCHAR * GetFriendlyName() { return m_strFriendlyName;}
    TCHAR * GetExtensionDLL() { return m_strExtensionDLL;}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcapgf\bldcapgf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    BldCapGf.h

Abstract:

    Header file for BldCapGf.cpp

Author:
    
    Yee J. Wu   24-April-97

Environment:

    User mode only

Revision History:

--*/


#include "CCapObj.h"


#ifndef BLDCAPGF_H
#define BLDCAPGF_H

typedef enum {
   BGf_DEVICE_VIDEO,
   BGf_DEVICE_AUDIO
} BGf_DEVICE_TYPE, *PBGf_DEVICE_TYPE;

//
// Customize for differnt clients
//
typedef enum {
    BGf_PURPOSE_VFWWDM,
    BGf_PURPOSE_STILL,
    BGf_PURPOSE_ATLCONTROL,
    BGf_PURPOSE_OTHER
} BGf_PURPOSE, *PBGf_PURPOSE;


typedef enum {
    BGf_PREVIEW_OVERLAPPED,
    BGf_PREVIEW_CHILD,
    BGf_PREVIEW_WINDOWLESS,
    BGf_PREVIEW_DONTCARE
} BGf_PREVIEW, *PBGf_PREVIEW;

//
// Device Info Link List struct
//
typedef struct _EnumDeviceInfo {
    DWORD dwSize;
    TCHAR strFriendlyName[_MAX_PATH];
    TCHAR strDevicePath[_MAX_PATH];         
    TCHAR strExtensionDLL[_MAX_PATH];    
    DWORD dwFlags;
} EnumDeviceInfo;


//
// This capture graph class contain many filters to build a complete graph.
// It has one base filter/device, like BT8T829 or BT848, from which  
// an upstream or/and down stream graph is built.
//
// Its base filter contain input and output pin(s).
//

class CCaptureGraph
{
private:

    HINSTANCE m_hInstance;

    // **********************
    // Enumeration parameters
    // **********************

    BGf_PURPOSE m_PurposeFlags;
    BGf_PREVIEW m_PreviewFlags;
    REFCLSID m_clsidVideoDeviceClass;
    DWORD    m_dwVideoEnumFlags;    
    REFCLSID m_clsidAudioDeviceClass;
    DWORD    m_dwAudioEnumFlags;  


    // *************
    // Graph builder
    // *************
    ICaptureGraphBuilder *m_pBuilder;
    IGraphBuilder *m_pFg;

    //
    // Event 
    //
    IMediaEventEx *m_pMEEx;


    // Current state
    BOOL m_fPreviewGraphBuilt;
    BOOL m_fPreviewing;



    typedef CGenericList <CObjCapture> CObjDeviceList;

    // **********
    // V I D E O:
    // **********

    // Cache this since it is used in many placed. It is reset when asked to re-enumerate the device list.    
    IEnumMoniker  *m_pVideoEnumMoniker;
    // A list of enumerated video capture devices.
    CObjDeviceList m_ObjListVCapture;  
    // Current video capture object.
    CObjCapture   *m_pObjVCaptureCurrent;
    // Extract key information from the current device object and cache here for easy access.    
    EnumDeviceInfo m_EnumVDeviceInfoCurrent;

    // Video filter
    IBaseFilter *m_pVCap;    

    // CrossBar filters
    IBaseFilter *m_pXBar1;    
    IBaseFilter *m_pXBar2;    

    LONG m_XBar1InPinCounts;
    LONG m_XBar1OutPinCounts;


    // IVideoWindow*
    // Client window to overly image to.    
    HWND m_hWndClient;
    IVideoWindow *m_pVW;
    LONG m_lWindowStyle;   // Original VideoRendererWindow style
    HWND m_hWndOwner;      // Original owner of the VRWindow
    BOOL m_bSetChild;

    // Set/GetWindowPosition
    LONG m_lLeft,
         m_lTop,
         m_lWidth,
         m_lHeight;


    // IAM*
    IAMVideoCompression *m_pIAMVC;
    IAMStreamConfig *m_pIAMVSC;      
    IAMDroppedFrames *m_pIAMDF;
    IAMVfwCaptureDialogs *m_pIAMDlg;
    IAMTVTuner *m_pIAMTV;
    IAMCrossbar *m_pIAMXBar1;  
    IAMCrossbar *m_pIAMXBar2; 


    // **********
    // A U D I O:
    // **********

    IEnumMoniker  *m_pAudioEnumMoniker;
    CObjDeviceList m_ObjListACapture;  
    CObjCapture   *m_pObjACaptureCurrent;
    EnumDeviceInfo m_EnumADeviceInfoCurrent;    
    IBaseFilter *m_pACap;
    IAMStreamConfig *m_pIAMASC;     
    BOOL m_fCapAudio;


    //
    // Object related private functions
    //
    HRESULT SetObjCapture(BGf_DEVICE_TYPE DeviceType, CObjCapture * pObjCaptureNew);  
    void DuplicateObjContent(EnumDeviceInfo * pDstEnumDeviceInfo, CObjCapture * pSrcObjCapture);


    // Pin route and connection methods
    HRESULT RouteInToOutPins(IAMCrossbar * pIAMXBar, LONG idxInPin);
    HRESULT RouteRelatedPins(IAMCrossbar * pIAMXBar, LONG idxInPin);
    HRESULT FindIPinFromIndex(IBaseFilter * pFilter, LONG idxInPin, IPin ** ppPin);
    HRESULT FindIndexFromIPin(IBaseFilter * pFilter, IAMCrossbar * pIAMXBar, IPin * pPin, LONG *pidxInPin);

    // Local method to enumerate devices        
    LONG EnumerateCaptureDevices(
        BGf_DEVICE_TYPE DeviceType,
        REFCLSID clsidDeviceClass,
        DWORD dwEnumFlags);

    // Destroy graph helper
    void DestroyObjList(BGf_DEVICE_TYPE DeviceType);
    void NukeDownstream(IBaseFilter *pf);
    void FreeCapFilters();

public:

    CCaptureGraph(  
        BGf_PURPOSE PurposeFlags,
        BGf_PREVIEW PreviewFlags,   
        REFCLSID clsidVideoDeviceClass,  // such as CLSID_VideoinputDeviceCategory,
        DWORD    dwVideoEnumFlags,       // such as CDEF_BYPASS_CLASS_MANAGER
        REFCLSID clsidAudioDeviceClass,
        DWORD    dwAudioEnumFlags,
        HINSTANCE hInstance
        );             
    ~CCaptureGraph();


    //
    // Allocate an array of EnumDeviceInfo, one for each enumerated device.
    // Client must call DestroyCaptureDevicesList to free this array.
    //                                               
    LONG BGf_CreateCaptureDevicesList(      BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo ** ppEnumDevicesList);  // return number of devices
    LONG BGf_CreateCaptureDevicesListUpdate(BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo ** ppEnumDevicesList);  // return number of devices      
    void BGf_DestroyCaptureDevicesList(      EnumDeviceInfo  *  pEnumDevicesList);
    LONG BGf_GetDevicesCount(BGf_DEVICE_TYPE DeviceType); // return number of devices in the device list.



    //
    // Set/Get target capture device
    //
    HRESULT BGf_SetObjCapture(BGf_DEVICE_TYPE DeviceType, TCHAR * pstrDevicePath);
    HRESULT BGf_SetObjCapture(BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo * pEnumDeviceInfo, DWORD dwEnumDeviceInfoSize);

    HRESULT BGf_GetObjCapture(BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo * pEnumDeviceInfo, DWORD dwEnumDeviceInfoSize);
    TCHAR * BGf_GetObjCaptureDevicePath(BGf_DEVICE_TYPE DeviceType);
    TCHAR * BGf_GetObjCaptureFriendlyName(BGf_DEVICE_TYPE DeviceType);
    TCHAR * BGf_GetObjCaptureExtensionDLL(BGf_DEVICE_TYPE DeviceType);






    //
    // Build an upstream graph using the selected capture device.
    // Can query its input and output pins.
    //
    HRESULT BGf_BuildGraphUpStream(BOOL bAddAudioFilter, BOOL * pbUseOVMixer);
    virtual HRESULT BGf_BuildGraphDownStream(TCHAR * pstrCapFilename);          // Customize for STILL, VFWWDM,..others.
    virtual HRESULT BGf_BuildPreviewGraph(TCHAR * pstrVideoDevicePath, TCHAR * pstrAudioDevicePath, TCHAR * pstrCapFilename);  // Preview, Capture(need filename??)
    BOOL BGf_PreviewGraphBuilt() { return m_fPreviewGraphBuilt; }
    HANDLE BGf_GetDeviceHandle(BGf_DEVICE_TYPE DeviceType);  // return device handle of the capture filter.
    HRESULT BGf_GetCapturePinID(DWORD *pdwID);  // Get the PinID of the CAPTURE pin

    //
    // Register a notification 
    //
    IMediaEventEx * BGf_RegisterMediaEventEx(HWND hWndNotify, long lMsg, long lInstanceData);

    //
    // Teardown graph and free resources
    //
    void BGf_DestroyGraph();



    //
    // Based on an analog input(Tuner, Composit or SVideo), program the cross switches.
    //
    LONG BGf_CreateInputChannelsList(PTCHAR ** ppaPinNames);  // return number of pins   
    void BGf_DestroyInputChannelsList(PTCHAR *   paPinNames);     
    HRESULT BGf_RouteInputChannel(LONG idxInPin);
    LONG BGf_GetIsRoutedTo();
    LONG BGf_GetInputChannelsCount();



    //
    // Overlay Mixer
    //

    BOOL BGf_OverlayMixerSupported();  

    DWORD BGf_UpdateWindow(HWND hWndApp, HDC hDC);  // Main overlay function
    HRESULT BGf_OwnPreviewWindow(HWND hWndClient, LONG lWidth, LONG lHeight);  // Make the OM window a child of the client. 
    HRESULT BGf_UnOwnPreviewWindow(BOOL bVisible);
    DWORD BGf_SetVisible(BOOL bStart);                 // Turn on or off OM window (Visible/insivible)
    DWORD BGf_GetVisible(BOOL *pVisible); // Query the VISIBLE state of IVideoWindow



    //
    // Set/get streaming Property
    //
    BOOL BGf_StartPreview(BOOL bVisible);
    BOOL BGf_PausePreview(BOOL bVisible);
    BOOL BGf_StopPreview(BOOL bVisible);

    BOOL BGf_PreviewStarted() { return m_fPreviewing;}


    //
    // For current DS vfwwdm use only; may not needed them in the future.
    //
    BOOL BGf_SupportTVTunerInterface();
    BOOL BGf_SupportXBarInterface()    { return m_pIAMXBar1 != NULL;}
    void ShowTvTunerPage(HWND hWnd);
    void ShowCrossBarPage(HWND hWnd);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\wdmcapgf\pch.h ===
#if 0   // DBG
#ifndef _DEBUG
#define _DEBUG
#endif
#ifndef DEBUG
#define DEBUG
#endif
#endif
//
// use Non MFC based generic template list classes
//
#include <streams.h>   // This include just about enerything !!
#include <vfw.h>       // DVM_ERR_*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\mainfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       mainfrm.cpp
//
//--------------------------------------------------------------------------

// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "winlog.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\cwinlogr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       cwinlogr.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CWinLog.rc
//

#define IDM_CWINLOG_CLEARLOG            710
#define IDM_CWINLOG_COPY                711
#define IDM_CWINLOG_SELECTALL           712
#define IDM_CWINLOG_SAVEAS              713
#define IDM_CWINLOG_READONLY            714
#define IDM_CWINLOG_PROPERTIES          715

#define IDR_MENU_CWINLOG_CONTEXT_MENU   811
#define IDR_ACCEL_CWINLOG               812

#define IDS_CWINLOG_LOG_EVERYTHING      840
#define IDS_CWINLOG_LOG_NOISE           841
#define IDS_CWINLOG_LOG_INFO            842
#define IDS_CWINLOG_LOG_WARNINGS        843
#define IDS_CWINLOG_LOG_ERRORS          844
#define IDS_CWINLOG_LOG_FATALERRORS     845
#define IDS_CWINLOG_LOG_NOTHING         846
#define IDD_DIALOG_CWINLOG_PROPERTIES   890

#define IDC_COMBO_SEVERITY_WINDOW       900
#define IDC_COMBO_SEVERITY_LOGFILE      901
#define IDC_COMBO_SEVERITY_DEBUGGER     902
#define IDC_CHECK_AUTOPOPUP             903
#define IDC_CHECK_QUICKLOGGING          904
#define IDC_CHECK_BREAKTODEBUGGER       905
#define IDC_EDIT_LOG_FILENAME           906
#define IDC_BUTTON_CLEARLOG             907

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\mainfrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       mainfrm.h
//
//--------------------------------------------------------------------------

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__B4A31629_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
#define AFX_MAINFRM_H__B4A31629_C03D_11D1_A47A_00C04FA3544A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__B4A31629_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\cwinlogt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       cwinlogt.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	CWinLogT.cpp
//
//	Test case for class CWinLog.
//
//	This file can be copied and used as an example.
//
//	HISTORY
//	23-Feb-1998	Dan Morin	Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CWinLog.h"

void
WinLog_LogTest1(CWinLog * pWinLog)
	{
	Assert(pWinLog != NULL);
	pWinLog->LogStringPrintfCo(crGreen,
		"// \n"
		"// This is a test routine to test the CWinLog object.\n"
		"// \n"
		"// The CWinLog object is a non-MFC control to log text for debugging.\n"
		"// The control log information into the window you are currently\n"
		"// reading, to a .log file and to the debugger (if connected).\n"
		"// \n"
		"// If you want to use the CWinLog control into your project, all you\n"
		"// need is to copy the following files: CWinLog.cpp, CWinLog.h, CWinLog.rc\n"
		"// and CWinLogR.h.  For more details, read comments in file CWinLog.cpp.\n"
		"// \n"
		"// Dan Morin (March 1998)\n"
		"// \n\n"
		);

	pWinLog->LogStringPrintfEx(eSeverityNull, crAutoSelect, "THIS LINE SHOULD NOT BE DISPLAYED");
	pWinLog->LogStringPrintf("NOR SHOULD THIS ONE");
	pWinLog->LogStringPrintfCo(crRed, "AND NOT THIS ONE");
	pWinLog->LogStringPrintf("AND NEVER THIS ONE");


	pWinLog->LogStringPrintfEx(eSeverityNoise | LST_mskfAddEOL, crAutoSelect, "\n\nThis is a noisy message");
	pWinLog->LogStringPrintf("\tMore noise");

	pWinLog->LogStringPrintfEx(eSeverityInfo, crAutoSelect, "\n\nThis is informational text.\n");
	pWinLog->LogStringPrintf("\tMore informational text (");
	pWinLog->LogStringPrintfCo(RGB(100, 100, 100), "same severity, ");
	pWinLog->LogStringPrintfCo(RGB(200, 0, 0), "but with varying ");
	pWinLog->LogStringPrintfCo(crGreen, "colors");
	pWinLog->LogStringPrintfCo(crAutoSelect, ").\n");

	pWinLog->LogStringPrintfEx(eSeverityWarning, crAutoSelect, "\nWarning\n");
	pWinLog->LogStringPrintf("\tMore Warning\n");
	pWinLog->LogStringPrintfCo(crYellow, "\tWarning ");
	pWinLog->LogStringPrintf("(with different color)\n");
	pWinLog->LogStringPrintfCo(crAutoSelect, "\tWarning: Do not run with sharp scissors.\n");
	
	pWinLog->LogStringPrintfEx(eSeverityLevelHigh | LST_mskfAddEOL, crAutoSelect, "\nHigh Severity");
	pWinLog->LogStringPrintf("\tHigh Severity\n");
	pWinLog->LogStringPrintfCo(RGB(200, 20, 0), "\tHigh Severity (with different color)\n");

	pWinLog->LogStringPrintfEx(eSeverityFatalError, crAutoSelect, "\n*** Fatal Error ***\n");
	pWinLog->LogStringPrintf("\tMore Fatal Text\n");
	pWinLog->LogStringPrintfSev(eSeverityFatalError | LSI_mskfNeverDisplayPopup, "Silent Fatal Error \n");
	pWinLog->LogStringPrintf("\tAnother fatal error \n\n");

	pWinLog->LogStringPrintfEx(eSeverityInfo, crGreen, "Info...");
	pWinLog->LogStringPrintfEx(eSeverityWarning, crCurrentDefault, "Wrn...");
	pWinLog->LogStringPrintfEx(eSeverityError, crCurrentDefault, "Err...");

	pWinLog->LogStringPrintfEx(eSeverityError, crAutoSelect, "Err ");
	pWinLog->LogStringPrintf("(AutoColor)...\n");

	//pWinLog->LogStringPrintfEx(eSeverityNone | LSI_mskfAlwaysDisplayPopup, crAutoSelect, "\nThe End.\n:)\n");
	} // WinLog_LogTest1()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\cwinlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       cwinlog.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	CWinLog.h
//
//	HISTORY
//	23-Feb-1998	Dan Morin	Creation.
/////////////////////////////////////////////////////////////////////

#ifndef __CWINLOG_H_INCLUDED__
#define __CWINLOG_H_INCLUDED__

#ifdef __AFX_H__
	//	The project is compiled with MFC
	#define __USE_MFC__
#endif
#ifndef __AFXRES_H__
	// Edit commands (copied from VC\mfc\include\afxres.h)
	#define ID_EDIT_CLEAR                   0xE120
	#define ID_EDIT_CLEAR_ALL               0xE121
	#define ID_EDIT_COPY                    0xE122
	#define ID_EDIT_CUT                     0xE123
	#define ID_EDIT_FIND                    0xE124
	#define ID_EDIT_PASTE                   0xE125
	#define ID_EDIT_PASTE_LINK              0xE126
	#define ID_EDIT_PASTE_SPECIAL           0xE127
	#define ID_EDIT_REPEAT                  0xE128
	#define ID_EDIT_REPLACE                 0xE129
	#define ID_EDIT_SELECT_ALL              0xE12A
	#define ID_EDIT_UNDO                    0xE12B
	#define ID_EDIT_REDO                    0xE12C
#endif	

#ifndef TRACE1
#define TRACE1(sz, arg1)	// Redefine the macro to do nothing
#endif
#ifndef LENGTH
#define LENGTH(rg)	(sizeof(rg)/(sizeof(rg)[0]))
#endif
#ifndef Assert
#define Assert	ASSERT
#define Report	Assert		// The macro Report() is there to report an unsual situation (which is not necessary an error)
#endif
#ifndef INOUT
#define INOUT
#endif


extern HINSTANCE g_hInstanceSave;	// You may want to initialize yourself if you are not using MFC

///////////////////////////////////////
enum SEVERITY_LEVEL_ENUM	// Severity/importance of a string
	{
	eSeverityNull			= 0,	// Do not log this message

	eSeverityLevelNone		= 1,	// Message is not important at all.
	eSeverityLevelLowest	= 2,
	eSeverityLevelLow		= 3,
	eSeverityLevelMedium	= 4,
	eSeverityLevelHigh		= 5,
	eSeverityLevelHighest	= 6,
	eSeverityLevelExtreme	= 7,
	
	// Aliases for severity levels
	eSeverityNone			= eSeverityLevelNone,		// This string is not important at all
	eSeverityNoise			= eSeverityLevelLowest,		// A noisy message
	eSeverityInfo			= eSeverityLevelLow,		// Something informational to the user
	eSeverityWarning		= eSeverityLevelMedium,		// Display a warning to user
	eSeverityError			= eSeverityLevelHigh,		// Display an error to user
	eSeverityCriticalError	= eSeverityLevelHighest,	// The error is quite serious
	eSeverityFatalError		= eSeverityLevelExtreme,	// Display a fatal error to user

	// Values to initialize the thresholds for m_localwindow, m_debugger and m_logfile
	eSeverityThresholdLowest		= 0,	// Log everything
	eSeverityThresholdHighest		= 10,	// Do not log anything

	// Misc values
	eSeverityMask		= 0xF,
	};


///////////////////////////////////////
//	Those colors have been chosen to look good on 4, 8, 16 and 24 bpp.
#define crBlack				RGB(0, 0, 0)
#define crGreen				RGB(0, 128, 0)
#define crBlue				RGB(0, 0, 196)
#define crDarkBlue			RGB(0, 0, 128)
#define crYellow			RGB(128, 128, 0)
#define crOrange			RGB(255, 128, 0)
#define crRed				RGB(150, 0,0)
#define crRedHot			RGB(255, 0,0)

//	Special values for RGB() macro
#define crCurrentDefault	(0xFF000001)	// Use the default current color
#define crAutoSelect		(0xFF000002)	// Automatically choose the color (depending on the severity)

COLORREF AutoSelectColor(SEVERITY_LEVEL_ENUM eSeverity);

///////////////////////////////////////
//	Flags for TLogStringInfo.uFlags
#define LSI_mskmReserved			0x0000FFFF	// Flags that are reserved internally
#define LSI_mskmPublicFlags			0xFFFF0000	// Flags that can be shared by outsiders
#define LST_mskfAddEOL				0x00010000	// Append a '\n' at the end of string
#define LSI_mskfAlwaysDisplayPopup	0x00020000	// Always display a popup window for this message
#define LSI_mskfNeverDisplayPopup	0x00040000	// Never display a popup window for this message

///////////////////////////////////////
//	Structure to log a string entry.
struct TLogStringInfo
	{
	UINT uFlags;			// Various flags
	LPCTSTR pszText;		// Text we want to log
	va_list * pvaList;		// Extra arguments
	int cchIndent;			// Number of characters we want to indent text before inserting string
	SEVERITY_LEVEL_ENUM eSeverityLevel;		// Severity of the message
	COLORREF crTextColor;	// Color we want to write the text to whe window
	};


/////////////////////////////////////////////////////////////////////
class CWinLog
{
protected:
	TCHAR m_szLogFilename[_MAX_PATH];	// Name for the log file
	CHARFORMAT m_cfCharFormat;		// Character format (font, size, color) of text to be inserted
	SEVERITY_LEVEL_ENUM m_eSeverityPreviousEntry; // Keep a copy of the previous severity level
	COLORREF m_crTextColorPreviousEntry;	// Keep a copy of the previous color

public:
	struct
		{
		SEVERITY_LEVEL_ENUM eSeverityThreshold;		// Level of security we want to log to the window
		BOOL fAutoDisplayPopup;			// Display a popup on severe errors
		HWND hwnd;			// Handle of the window
		int cLinesMax;		// Maximum number of lines to keep in the window (before flushing)
		int cAddText;		// Number of times we added text before flushing the buffer
		BOOL fImmediateUpdate;	// Don't wait until the system is idle to update the window
		} m_localwindow;
	struct
		{
		SEVERITY_LEVEL_ENUM eSeverityThreshold;		// Level of security we want to log to the debugger
		BOOL fBreakpoint;		// Force a breakpoint after displaying the string
		} m_debugger;
	struct
		{
		SEVERITY_LEVEL_ENUM eSeverityThreshold;		// Level of security we want to log to the file
		FILE * paFile;
		} m_logfile;


public:
	CWinLog(LPCTSTR pszLogFilename = NULL);
	~CWinLog();

public:
	void LocalWindow_Create(HWND hwndParent);
	void LocalWindow_ResizeWithinParent(HWND hwndParent);
	void LocalWindow_SetFocus();
	void LocalWindow_SetReadOnly(BOOL fReadOnly);
	void LocalWindow_SetDefaultFont(COLORREF crTextColor = crCurrentDefault, int cyTextHeight = 0, LPCTSTR pszFaceName = NULL);
	void LocalWindow_AddText(LPCTSTR pszText, COLORREF crTextColor = crCurrentDefault);
	void LocalWindow_LimitLines();
	void LocalWindow_UpdateNow();
	void LocalWindow_OnCommand(UINT uCommandId);

	void LogString(const TLogStringInfo * pLogStringInfo);
	void LogStringPrintfExVa(int nSeverityFlags, COLORREF crTextColor, LPCTSTR pszTextFmt, va_list vaList);
	void LogStringPrintfEx(int nSeverityFlags, COLORREF crTextColor, LPCTSTR pszTextFmt, ...);
	void LogStringPrintfSev(int nSeverityFlags, LPCTSTR pszTextFmt, ...);
	void LogStringPrintfCo(COLORREF crTextColor, LPCTSTR pszTextFmt, ...);
	void LogStringPrintf(LPCTSTR pszTextFmt, ...);

	void CreateLogFile();
	void WriteDebugSettingsToDisk();
	void ReadDebugSettingsFromDisk();
	void GetFilenameLog(OUT LPTSTR pszFilename, int cchBufferMax);
	void GetFilenameDebugSettings(OUT LPTSTR pszFilename, int cchBufferMax);

}; // CWinLog


#endif // __CWINLOG_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\cwinlog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       cwinlog.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//  CWinLog.cpp
//
//  Control to log text for debugging.  The object CWinLog can
//  send debugging information to a window, a file or directy
//  to the debugger.
//
//  INTEGRATION
//  The class CWinLog was designed to be plug & play.  That is,
//  you need to copy the following files into your project:
//      CWinLog.h   - Header file
//      CWinLog.cpp - Implementation file
//      CWinLog.rc  - Resource file
//      CWinLogR.h  - Resource include file
//  And compile those file with the rest of your project.
//
//  If you are NOT using MFC, just create your own file stdafx.h
//  with the necessary includes to make your project compile.
//
//  WHAT IT DOES
//  The constructor creates a log (.log) file in the current directory. It will
//  also try to open the debug setting (.dbs) file to restore its configuration
//  from the previous session.  You may optionally create a local window to log
//  information and allow the user to view the log without the usage of a debugger
//  or having to wait for the application to terminate to view the .log file.
//  The local window is OPTIONAL. You may use the CWinLog object without having
//  any UI in your project (say, for instance a command line application).
//
//  USAGE
//  Here is a sample of code to get you started.
//      CWinLog g_winlog;       // Global variable
//      g_winlog.LocalWindow_Create(hwndParent);    // Create a local window
//      g_winlog.LogStringPrintf("Openning file %s...\n", szFilename);
//  You may also want to forward the WM_SIZE message so the log window
//  automatically resize to its parent.
//
//  ORIGINAL SOURCE
//  The original source is located in \nt\private\amovie\filters.ks\winlog\
//  You can do "enlist -s \\RASTAMAN\NTWIN -p ks" to get the source code.
//
//  HISTORY
//  23-Feb-1998 Dan Morin   Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"     // Standard include files
#include "CWinlog.h"    // Header file for the CWinLog class
#include "CWinLogR.h"   // Resource include symbols for CWinLog class

HINSTANCE g_hInstanceSave;      // Instance handle of the module to load the resources

///////////////////////////////////////
//  It is recommended you define your own d_szAppName in stdafx.h to
//  match the name of your application module.  If d_szAppName is
//  not defined, then a default string will be provided.
//
//  EXAMPLE
//  #define d_szAppName     "My Application"    // Used by the CWinLog object
//
#ifndef d_szAppName
#define d_szAppName "CWinLog"       // Used by the CWinLog object
#endif

///////////////////////////////////////
//  The variable g_szAppName is used within this file for the following:
//      - Display the caption of message boxes
//      - Create the .log file
//      - Create the .dbs file
const TCHAR g_szAppName[] = d_szAppName;

static HINSTANCE g_hInstanceRichEdit;   // Library for the rich-edit control
static WNDPROC g_pfnWndProcRichEditOld; // Subclassing of the rich-edit control
static HACCEL g_hAcceleratorsRichEdit;  // Accelerators for the rich-edit control


//  Dialog proc for the properties/options of the CLogWin class
BOOL CALLBACK DlgProcWinLogProperties(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//
//  Small wrappers
//
int
MsgBox(LPCTSTR pszMessage, UINT uFlags = MB_OK | MB_ICONINFORMATION)
    {
    return ::MessageBox(::GetActiveWindow(), pszMessage, g_szAppName, uFlags);
    }

void
MenuItem_Enable(HMENU hmenu, UINT uCommandId, BOOL fEnable)
    {
    ::EnableMenuItem(hmenu, uCommandId, fEnable ? (MF_BYCOMMAND | MF_ENABLED) : (MF_BYCOMMAND | MF_GRAYED));
    }
void
MenuItem_Check(HMENU hmenu, UINT uCommandId, BOOL fCheck)
    {
    ::CheckMenuItem(hmenu, uCommandId, fCheck ? (MF_BYCOMMAND | MF_CHECKED) : (MF_BYCOMMAND | MF_UNCHECKED));
    }
BOOL
RichEdit_FIsReadOnly(HWND hwnd)
    {
    return !!(::GetWindowLong(hwnd, GWL_STYLE) & ES_READONLY);
    }
void
RichEdit_SetReadOnly(HWND hwnd, BOOL fReadOnly)
    {
    ::SendMessage(hwnd, EM_SETREADONLY, fReadOnly, 0);
    }
enum { _cchMaxText = 100000000 };   // Maximum number of characters in buffer (arbitrary chosen)
void
RichEdit_MoveCursorToEnd(HWND hwnd)
    {
    ::SendMessage(hwnd, EM_SETSEL, (WPARAM)_cchMaxText, (LPARAM)_cchMaxText);   // Move the insertion point to the end of text
    }
void
RichEdit_ScrollToEnd(HWND hwnd)
    {
    ::SendMessage(hwnd, EM_SETSEL, (WPARAM)_cchMaxText, (LPARAM)_cchMaxText);
    ::SendMessage(hwnd, EM_SCROLLCARET, 0, 0);
    }
void
RichEdit_SetSelection(HWND hwnd, int iStart, int iEnd)
    {
    CHARRANGE cr = { iStart, iEnd };
    ::SendMessage(hwnd, EM_EXSETSEL, 0, IN (LPARAM)&cr);
    }
void
RichEdit_SelectAll(HWND hwnd)
    {
    CHARRANGE cr = { 0, -1 };
    ::SendMessage(hwnd, EM_EXSETSEL, 0, IN (LPARAM)&cr);
    }
CHARRANGE
RichEdit_GetSelection(HWND hwnd)
    {
    CHARRANGE cr = { 0 };
    ::SendMessage(hwnd, EM_EXGETSEL, 0, OUT (LPARAM)&cr);
    return cr;
    }
void
RichEdit_ClearSelection(HWND hwnd)
    {
    ::SendMessage(hwnd, EM_REPLACESEL, TRUE /* fCanUndo */, NULL);
    }
void
RichEdit_ReplaceSelection(HWND hwnd, LPCTSTR pszText)
    {
    ::SendMessage(hwnd, EM_REPLACESEL, FALSE /* fCanUndo */, IN (LPARAM)pszText);
    }

/////////////////////////////////////////////////////////////////////////////
//  RichEdit_FSaveAs()
//
//  Write the content of the rich-edit control into a text file.
//  This routine invoke the common save-as dialog.
//
//  Return TRUE if the content of the edit control was written to file.
//  Return FALSE is the user clicked on the cancel button or if an error occured.
//
BOOL
RichEdit_FSaveAs(HWND hwndRichEdit)
    {
    Assert(IsWindow(hwndRichEdit));
    OPENFILENAME ofn = { 0 };
    TCHAR szFileName[_MAX_PATH];
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hwndRichEdit;
    ofn.hInstance = g_hInstanceSave;
    ofn.lpstrFilter = _T("Text Files (*.txt; *.log)\0*.txt;*.log\0All Files (*.*)\0*.*\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = LENGTH(szFileName);
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = _T("txt");
    szFileName[0] = 0;

    // Invoke the common save-as dialog
    if (!::GetSaveFileName(&ofn))
        return FALSE;

    DWORD dwNumberOfBytesWritten;
    HANDLE hfile = ::CreateFile(
        szFileName,
        GENERIC_WRITE,
        0,          // No Sharing
        NULL,       // Security attributes
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL);
    Report((hfile != INVALID_FILE_HANDLE) && "Unable to create file");
    if (hfile == INVALID_FILE_HANDLE)
        return FALSE;
    int cLine = ::SendMessage(hwndRichEdit, EM_GETLINECOUNT, 0, 0);
    UINT cchBuffer;
    TCHAR szBuffer[2000];       // Buffer for a line
    for (int i = 0; i < cLine; i++)
        {
        *(WORD *)szBuffer = LENGTH(szBuffer) - 2;
        cchBuffer = ::SendMessage(hwndRichEdit, EM_GETLINE, i, OUT (LPARAM)szBuffer);
        BOOL fSuccess = ::WriteFile(hfile, szBuffer, cchBuffer, OUT &dwNumberOfBytesWritten, NULL);
        Report(fSuccess != FALSE);
        Report(dwNumberOfBytesWritten == cchBuffer);
        }
    ::CloseHandle(hfile);
    return TRUE;
    } // RichEdit_FSaveAs()



/////////////////////////////////////////////////////////////////////
//  RichEdit_FTranslateAccelerator()
//
//  Routine that translates a virtual key into a menu command.
//  Return TRUE if the key has been handled, oherwise return FALSE
//  meaning the key should be forwarded to the default handler,
//
//  REMARK
//  It is possible some keystrokes do not generate accelerators.
//  This is probably because your main application has already
//  an accelerator entry for that particular keystroke.  What you
//  can do is to forward the command to the log window
//  via the method LocalWindow_OnCommand().  The other alternative
//  is to remove the accelerator entry in the accelerator table.
//
BOOL
RichEdit_FTranslateAccelerator(HWND hwnd, WPARAM wParam, LPARAM lParam)
    {
    Assert(IsWindow(hwnd));
    MSG msg = { 0 };
    msg.hwnd = hwnd;
    msg.message = WM_KEYDOWN;
    msg.wParam = wParam;
    msg.lParam = lParam;
    Report(g_hAcceleratorsRichEdit != NULL && "Accelerators not loaded");
    if (TranslateAccelerator(hwnd, g_hAcceleratorsRichEdit, IN &msg))
        return TRUE;
    return FALSE;
    }


/////////////////////////////////////////////////////////////////////
//  RichEdit_OnCommand()
//
//  Dispatch a command.
//
LRESULT
RichEdit_OnCommand(HWND hwnd, UINT uCommandId)
    {
    Assert(IsWindow(hwnd));
    switch (uCommandId)
        {
    case ID_EDIT_CLEAR:
    case IDM_CWINLOG_CLEARLOG:
        SetWindowText(hwnd, NULL);      // Clear the whole log
        break;
    case ID_EDIT_COPY:
    case IDM_CWINLOG_COPY:
        {
        CHARRANGE cr = RichEdit_GetSelection(hwnd);
        if (cr.cpMin == cr.cpMax)
            RichEdit_SelectAll(hwnd);   // Select the entire text
        (void)::SendMessage(hwnd, WM_COPY, 0, 0);
        }
        break;
    case ID_EDIT_CUT:
        (void)::SendMessage(hwnd, WM_CUT, 0, 0);
        break;
    case ID_EDIT_PASTE:
        (void)::SendMessage(hwnd, WM_PASTE, 0, 0);
        break;
    case ID_EDIT_SELECT_ALL:
    case IDM_CWINLOG_SELECTALL:
        RichEdit_SelectAll(hwnd);
        break;
    case ID_EDIT_UNDO:
        return (BOOL)::SendMessage(hwnd, EM_UNDO, 0, 0);
        break;
    case IDM_CWINLOG_READONLY:  // Toggle the read-only flag
        RichEdit_SetReadOnly(hwnd, !RichEdit_FIsReadOnly(hwnd));
        break;
    case ID_FILE_SAVE:
    case ID_FILE_SAVE_AS:
    case IDM_CWINLOG_SAVEAS:
        (void)RichEdit_FSaveAs(hwnd);
        break;
    case IDM_CWINLOG_PROPERTIES:
        {
        CWinLog * pWinLog = (CWinLog *)GetWindowLong(hwnd, GWL_USERDATA);
        Assert(pWinLog != NULL);
        DialogBoxParam(g_hInstanceSave, MAKEINTRESOURCE(IDD_DIALOG_CWINLOG_PROPERTIES),
            hwnd, DlgProcWinLogProperties, (LPARAM)pWinLog);
        }
        break;
        } // switch
    return 0;
    } // RichEdit_OnCommand()


/////////////////////////////////////////////////////////////////////
//  Extensions to the rich-edit control
LRESULT CALLBACK
WndProcRichEditEx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    UINT uCommandId;
    switch (uMsg)
        {
    case WM_KEYDOWN:
        if (!RichEdit_FTranslateAccelerator(hwnd, wParam, lParam))
            goto DoDefault;
        return 0;

    case WM_RBUTTONDOWN:
        SetFocus(hwnd);
        return 0;

    case WM_RBUTTONUP:
        {
        HMENU haMenu = ::LoadMenu(g_hInstanceSave, MAKEINTRESOURCE(IDR_MENU_CWINLOG_CONTEXT_MENU));
        Report(haMenu != NULL && "Cannot load context menu");
        HMENU hSubMenu = GetSubMenu(haMenu, 0);
        // Initialize the menu
        int cchText = GetWindowTextLength(hwnd);
        MenuItem_Enable(hSubMenu, IDM_CWINLOG_COPY, cchText > 0);
        MenuItem_Enable(hSubMenu, IDM_CWINLOG_CLEARLOG, cchText > 0);
        MenuItem_Enable(hSubMenu, IDM_CWINLOG_SELECTALL, cchText > 0);
        MenuItem_Enable(hSubMenu, IDM_CWINLOG_SAVEAS, cchText > 0);
        MenuItem_Check(hSubMenu, IDM_CWINLOG_READONLY, RichEdit_FIsReadOnly(hwnd));
        POINT pt;
        ::GetCursorPos(OUT &pt);
        uCommandId = ::TrackPopupMenu(
            hSubMenu,
            TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
            pt.x, pt.y,
            0, ::GetParent(hwnd), NULL);
        ::DestroyMenu(haMenu);
        if (uCommandId != 0)
            RichEdit_OnCommand(hwnd, uCommandId);
        return 0;
        }

    case WM_COMMAND:
        RichEdit_OnCommand(hwnd, LOWORD(wParam));
        break;
        } // switch

DoDefault:
    Assert(g_pfnWndProcRichEditOld != NULL);
    return CallWindowProc(g_pfnWndProcRichEditOld, hwnd, uMsg, wParam, lParam);
    } // WndProcRichEditEx()


/////////////////////////////////////////////////////////////////////
//  Initialize a combo box with a choice of severity thresholds
void
ComboBox_InitSeverityThresholdList(HWND hwndCombo, SEVERITY_LEVEL_ENUM eSeverityThresholdSelect)
    {
    Assert(IsWindow(hwndCombo));
    struct _TSeverityUI
        {
        SEVERITY_LEVEL_ENUM eSeverity;
        UINT idsString;         // String from the resource
        };
    const _TSeverityUI rgSeverity[] =
        {
        { eSeverityNone, IDS_CWINLOG_LOG_EVERYTHING },
        { eSeverityNoise, IDS_CWINLOG_LOG_NOISE },
        { eSeverityInfo, IDS_CWINLOG_LOG_INFO },
        { eSeverityWarning, IDS_CWINLOG_LOG_WARNINGS },
        { eSeverityError, IDS_CWINLOG_LOG_ERRORS },
        { eSeverityFatalError, IDS_CWINLOG_LOG_FATALERRORS },
        { eSeverityThresholdHighest, IDS_CWINLOG_LOG_NOTHING }
        };

    int iItemSelect = 0;
    for (int i = 0; i < LENGTH(rgSeverity); i++)
        {
        TCHAR szText[200];
        szText[0] = '\0';
        ::LoadString(g_hInstanceSave, rgSeverity[i].idsString, OUT szText, LENGTH(szText));
        Assert(lstrlen(szText) > 0 && "Unable to load string");
        int iItem = ::SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)szText);
        Report(iItem >= 0 && "Unable to add item");
        SEVERITY_LEVEL_ENUM eSeverityT =  rgSeverity[i].eSeverity;
        SendMessage(hwndCombo, CB_SETITEMDATA, iItem, eSeverityT);
        if (eSeverityThresholdSelect >= eSeverityT)
            iItemSelect = iItem;
        } // for
    SendMessage(hwndCombo, CB_SETCURSEL, iItemSelect, 0);
    } // ComboBox_InitSeverityThresholdList()


////////////////////////////////////////////////////////////////////////////
void
ComboBox_GetSelectedSeverityThreshold(HWND hwndCombo, OUT SEVERITY_LEVEL_ENUM * peSeverityThreshold)
    {
    Assert(IsWindow(hwndCombo));
    Assert(peSeverityThreshold != NULL);

    int iItem = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    Report(iItem != CB_ERR && "Combobox has no item selected");
    LONG lData = SendMessage(hwndCombo, CB_GETITEMDATA, iItem, 0);
    Report(lData != CB_ERR && "Cannot extract item data from combobox");
    if (lData != CB_ERR)
        *peSeverityThreshold = (SEVERITY_LEVEL_ENUM)lData;
    }


/////////////////////////////////////////////////////////////////////
//  Dialog for the properties/options of the CWndLog class
BOOL CALLBACK
DlgProcWinLogProperties(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CWinLog * pThis;

    pThis = (CWinLog *)GetWindowLong(hdlg, GWL_USERDATA);
    switch (uMsg)
        {
    case WM_INITDIALOG:
        {
        pThis = (CWinLog *)lParam;
        Assert(pThis != NULL);
        SetWindowLong(hdlg, GWL_USERDATA, (LONG)pThis);
        ComboBox_InitSeverityThresholdList(GetDlgItem(hdlg, IDC_COMBO_SEVERITY_WINDOW),
            pThis->m_localwindow.eSeverityThreshold);
        ComboBox_InitSeverityThresholdList(GetDlgItem(hdlg, IDC_COMBO_SEVERITY_DEBUGGER),
            pThis->m_debugger.eSeverityThreshold);
        ComboBox_InitSeverityThresholdList(GetDlgItem(hdlg, IDC_COMBO_SEVERITY_LOGFILE),
            pThis->m_logfile.eSeverityThreshold);
        CheckDlgButton(hdlg, IDC_CHECK_AUTOPOPUP, pThis->m_localwindow.fAutoDisplayPopup);
        CheckDlgButton(hdlg, IDC_CHECK_QUICKLOGGING, !pThis->m_localwindow.fImmediateUpdate);
        CheckDlgButton(hdlg, IDC_CHECK_BREAKTODEBUGGER, pThis->m_debugger.fBreakpoint);
        TCHAR szT[_MAX_PATH];
        pThis->GetFilenameLog(OUT szT, LENGTH(szT));
        SetDlgItemText(hdlg, IDC_EDIT_LOG_FILENAME, szT);
        }
        return FALSE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
            {
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            break;
        case IDOK:
            ComboBox_GetSelectedSeverityThreshold(GetDlgItem(hdlg, IDC_COMBO_SEVERITY_WINDOW),
                OUT &pThis->m_localwindow.eSeverityThreshold);
            ComboBox_GetSelectedSeverityThreshold(GetDlgItem(hdlg, IDC_COMBO_SEVERITY_DEBUGGER),
                OUT &pThis->m_debugger.eSeverityThreshold);
            ComboBox_GetSelectedSeverityThreshold(GetDlgItem(hdlg, IDC_COMBO_SEVERITY_LOGFILE),
                OUT &pThis->m_logfile.eSeverityThreshold);
            pThis->m_localwindow.fAutoDisplayPopup = IsDlgButtonChecked(hdlg, IDC_CHECK_AUTOPOPUP);
            pThis->m_localwindow.fImmediateUpdate = !IsDlgButtonChecked(hdlg, IDC_CHECK_QUICKLOGGING);
            pThis->m_debugger.fBreakpoint = IsDlgButtonChecked(hdlg, IDC_CHECK_BREAKTODEBUGGER);
            pThis->WriteDebugSettingsToDisk();  // Write the settings to disk
            EndDialog(hdlg, TRUE);
            break;
        case IDC_BUTTON_CLEARLOG:   // Clear the log
            pThis->CreateLogFile();
            break;
            }
        break;
        } // swtich

    return FALSE;
    } // DlgProcWinLogProperties()


/////////////////////////////////////////////////////////////////////
//  MakeFullPathFilename()
//
//  Make a filename in the directory the application is currently running
//  This routine will return a string representing the full path of the filename.
void
MakeFullPathFilename(
    LPTSTR pszFilename,         // OUT: Buffer receiving the full path
    int cchBufferMax,           // Length of output buffer in character
    LPCTSTR pszFilenameBody,    // Short file name (eg: "CWinLog"
    LPCTSTR pszExtension)       // Extension of file without the dot (eg: "log", "dbs")
    {
    Assert(pszFilename != NULL);
    Assert(cchBufferMax >= _MAX_PATH);
    Assert(pszFilenameBody != NULL);
    Assert(lstrlen(pszFilenameBody) > 0);
    Assert(pszExtension != NULL);
    Assert(lstrlen(pszExtension) > 0);

    TCHAR szPath[_MAX_PATH];
    ::GetCurrentDirectory(LENGTH(szPath), OUT szPath);

    wsprintf(OUT pszFilename, "%s\\%s.%s", szPath, pszFilenameBody, pszExtension);
    Assert(lstrlen(pszFilename) < cchBufferMax && "Buffer overrun... Your application will crash soon!!!.");
    } // MakeFullPathFilename()


/////////////////////////////////////////////////////////////////////
//  Select the text color based on the severity of a message.
COLORREF
AutoSelectColor(SEVERITY_LEVEL_ENUM eSeverity)
    {
    if (eSeverity < eSeverityWarning)
        {
        if (eSeverity <= eSeverityNoise)
            return crBlack;
        return crBlue;
        }
    if (eSeverity > eSeverityWarning)
        {
        if (eSeverity > eSeverityError)
            return crRedHot;
        return crRed;
        }
    return crOrange;
    } // AutoSelectColor()




/////////////////////////////////////////////////////////////////////
//  CWinLog()
//
//  This is the constructor of the CWinLog object.  Typically an
//  application would only have one instance of this class.
//
//  The constructor will also create a log file in the current directory.
//
CWinLog::CWinLog(LPCTSTR pszLogFilename)
    {
    if (pszLogFilename == NULL)
        pszLogFilename = g_szAppName;
    Assert(lstrlen(pszLogFilename) < LENGTH(m_szLogFilename));
    lstrcpy(OUT m_szLogFilename, IN pszLogFilename);

    ZeroMemory(OUT &m_cfCharFormat, sizeof(m_cfCharFormat));
    m_eSeverityPreviousEntry = eSeverityInfo;
    m_crTextColorPreviousEntry = crBlack;
    ZeroMemory(OUT &m_localwindow, sizeof(m_localwindow));
    ZeroMemory(OUT &m_debugger, sizeof(m_debugger));
    ZeroMemory(OUT &m_logfile, sizeof(m_logfile));
    m_localwindow.eSeverityThreshold = eSeverityInfo;
    m_localwindow.fAutoDisplayPopup = FALSE;
    m_localwindow.fImmediateUpdate = TRUE;
    m_localwindow.cLinesMax = 0;        // Maximum number of lines (0 means no limit)
    m_debugger.eSeverityThreshold = eSeverityError;
    m_logfile.eSeverityThreshold = eSeverityError;
    CreateLogFile();    // Create the log file to start recording events
    ReadDebugSettingsFromDisk();    // Read the settings from disk (if any)
    }


/////////////////////////////////////////////////////////////////////
CWinLog::~CWinLog()
    {
    if (m_logfile.paFile != NULL)
        {
        fflush(m_logfile.paFile);
        fclose(m_logfile.paFile);
        m_logfile.paFile = NULL;
        }
    WriteDebugSettingsToDisk(); // Write the current debug settings to disk
    }


/////////////////////////////////////////////////////////////////////
//  CreateLogFile()
//
//  Create a new log file in the current directory.
//
//  If the log file already exists or the file was already opened,
//  the file and its content will be reset.
//
void
CWinLog::CreateLogFile()
    {
    if (m_logfile.paFile != NULL)
        fclose(m_logfile.paFile);
    TCHAR szFilename[_MAX_PATH];
    GetFilenameLog(OUT szFilename, LENGTH(szFilename));

    m_logfile.paFile = fopen(szFilename, "wt");

    if (m_logfile.paFile == NULL)
        {
        // This may happen if the .log file is already
        // opened by another instance or the directory
        // in which the application is running is read-only.

        // MsgBox("Cannot create log file.");
        }
    } // CreateLogFile()


/////////////////////////////////////////////////////////////////////
//  This is used in case someone opens a .dbs file and would like to
//  know the content of the file.
const char g_szDebugSettingsHdr[] =
    "This binary file contains the debug settings for an application\r\n"
    "using the CWinLog object which was started in this directory.\r\n"
    "\r\n"
    "This file is auto generated and can delete without risk. You can\r\n"
    "also copy and rename this file to export the debug settings to a\r\n"
    "different application that uses the CWinLog object.\r\n"
    "\r\n"
    "The CWinLog class is a non-MFC object used to log activity to\r\n"
    "a .log file, a local window and the debugger.  If you are curious\r\n"
    "how the CWinLog class can be used in your project, take a look at\r\n"
    "\\nt\\private\\amovie\\filters.ks\\winlog\\CWinLog*.* files.\r\n"
    "\r\n"
    "- Dan Morin (March 1998).\r\n\r\n";


/////////////////////////////////////////////////////////////////////
//  WriteDebugSettingsToDisk()
//
//  Write the debug settings to disk.
//
//  IMPLEMENTATION NOTES
//  To simplify the code, the whole structure is written
//  to disk. There might be pointers and handles that
//  are stored to disk.
//  It is the responsibility of routine ReadDebugSettingsFromDisk() to
//  ensure pointers and handles are not loaded from the file.
//
void
CWinLog::WriteDebugSettingsToDisk()
    {
    TCHAR szFilename[_MAX_PATH];
    GetFilenameDebugSettings(OUT szFilename, LENGTH(szFilename));
    FILE * paFile = fopen(szFilename, "wb");
    if (paFile == NULL)
        {
        TRACE1("Unable to write debug settings. Can't create %s.\n", szFilename);
        return;
        }
    fwrite(IN g_szDebugSettingsHdr, sizeof(g_szDebugSettingsHdr), 1, paFile);
    DWORD cbData = sizeof(m_localwindow) + sizeof(m_debugger) + sizeof(m_logfile);
    fwrite(IN &cbData, sizeof(cbData), 1, paFile);
    fwrite(IN &m_localwindow, sizeof(m_localwindow), 1, paFile);
    fwrite(IN &m_debugger, sizeof(m_debugger), 1, paFile);
    fwrite(IN &m_logfile, sizeof(m_logfile), 1, paFile);
    fclose(paFile);
    } // WriteDebugSettingsToDisk()


/////////////////////////////////////////////////////////////////////
//  ReadDebugSettingsFromDisk()
//
//  Read the debug settings from a .dbs file.
//
//  If the file does not exist, then the current default settings
//  are preserved.
//
//  IMPLEMENTATION NOTES
//  This routine must ensure pointers and handles are not loaded from
//  the file.
//
void
CWinLog::ReadDebugSettingsFromDisk()
    {
    TCHAR szFilename[_MAX_PATH];
    GetFilenameDebugSettings(OUT szFilename, LENGTH(szFilename));
    FILE * paFile = fopen(szFilename, "rb");
    if (paFile == NULL)
        {
        // This is OK.  The .dbs file has never been created; the default settings will be used instead
        return;
        }
    char szHdr[sizeof(g_szDebugSettingsHdr)] = "??";
    fread(OUT szHdr, sizeof(szHdr), 1, paFile);
    if (0 != memcmp(g_szDebugSettingsHdr, szHdr, sizeof(szHdr)))
        {
        // We have a wrong header
        fclose(paFile);
        return;
        }
    DWORD cbData = 0;
    fread(OUT &cbData, sizeof(cbData), 1, paFile);
    if (cbData != sizeof(m_localwindow) + sizeof(m_debugger) + sizeof(m_logfile))
        {
        // We have a format that is out of date or was saved on a different platform
        fclose(paFile);
        return;
        }
    // Save pointers we want preserve
    HWND hwndLocalWindowT = m_localwindow.hwnd;
    FILE * pFileLogT = m_logfile.paFile;
    fread(OUT &m_localwindow, sizeof(m_localwindow), 1, paFile);
    fread(OUT &m_debugger, sizeof(m_debugger), 1, paFile);
    fread(OUT &m_logfile, sizeof(m_logfile), 1, paFile);
    fclose(paFile);
    m_localwindow.hwnd = hwndLocalWindowT;
    m_logfile.paFile = pFileLogT;
    } // ReadDebugSettingsFromDisk()



/////////////////////////////////////////////////////////////////////
//  GetFilenameLog()
//
//  Get the full-path for the log file.
//
void
CWinLog::GetFilenameLog(OUT LPTSTR pszFilename, int cchBufferMax)
    {
    MakeFullPathFilename(OUT pszFilename, cchBufferMax, m_szLogFilename, "log");
    }


/////////////////////////////////////////////////////////////////////
//  GetFilenameDebugSettings()
//
//  Get the full-path for the filename to store and retreive the
//  debug settings (.dbs file)
//
void
CWinLog::GetFilenameDebugSettings(OUT LPTSTR pszFilename, int cchBufferMax)
    {
    MakeFullPathFilename(OUT pszFilename, cchBufferMax, m_szLogFilename, "dbs");
    }


/////////////////////////////////////////////////////////////////////
//  LocalWindow_Create()
//
//  Create a local window to display logging activity.
//
//  IMPLEMENTATION NOTES
//  The routine creates a rich-edit control with read-only.
//  This is the easiest way to implement scrooling, text selection
//  and copy to clipboard.
//
void
CWinLog::LocalWindow_Create(HWND hwndParent)
    {
    Assert(IsWindow(hwndParent));
    #ifdef __USE_MFC__
    // Automatically use MFC's routine to initialize the instance handle
    g_hInstanceSave = AfxGetInstanceHandle();
    #endif
    Assert(g_hInstanceSave != NULL);

    if (g_hInstanceRichEdit == NULL)
        g_hInstanceRichEdit = ::LoadLibraryA("RICHED32.DLL");

    if (m_localwindow.hwnd != NULL)
        {
        Assert(IsWindow(m_localwindow.hwnd));
        return; // Window is already created
        }
    m_localwindow.hwnd = ::CreateWindowEx(
        0,      // Extended style
        "RichEdit",
        NULL,   // Caption
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL |
        ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE,
        0, 0, 200, 200,
        hwndParent,
        NULL,
        g_hInstanceSave,
        NULL);
    if (m_localwindow.hwnd == NULL)
        {
        DWORD dwErr = ::GetLastError();
        TRACE1("CWinLog::LocalWindow_Create() - Unable to create debug window. err=%d.\n", dwErr);
        return;
        }
    // Store the this pointer in the window long
    ::SetWindowLong(m_localwindow.hwnd, GWL_USERDATA, (LONG)this);

    if (g_hAcceleratorsRichEdit == NULL)
        {
        // Load the accelerators for the context menu
        g_hAcceleratorsRichEdit = ::LoadAccelerators(g_hInstanceSave, MAKEINTRESOURCE(IDR_ACCEL_CWINLOG));
        if (g_hAcceleratorsRichEdit == NULL)
            {
            // This error may be because you have not included file CWinLog.rc into your project.
            // This can be easily be done by including CWinLog.rc.rc file into your .rc2 file.
            DWORD dwErr = ::GetLastError();
            TRACE1("CWinLog::LocalWindow_Create() - Unable to load accelerators. err=%d.\n", dwErr);
            }
        }
    if (g_pfnWndProcRichEditOld == NULL)
        g_pfnWndProcRichEditOld = (WNDPROC)::GetWindowLongPtr(m_localwindow.hwnd, GWLP_WNDPROC);
    // Subclass the edit control
    ::SetWindowLongPtr(m_localwindow.hwnd, GWLP_WNDPROC, (LONG_PTR)WndProcRichEditEx);
    // Indent the left margin by two pixels
    SendMessage(m_localwindow.hwnd, EM_SETMARGINS, EC_LEFTMARGIN, MAKELONG(2, 0));
    LocalWindow_SetReadOnly(TRUE);
    LocalWindow_SetDefaultFont(crBlack, 8, "Arial");
    LocalWindow_ResizeWithinParent(hwndParent);
    } // LocalWindow_Create()


/////////////////////////////////////////////////////////////////////
//  LocalWindow_ResizeWithinParent()
//
//  Re-size the window to fit the client area of the parent.
//
//  USAGE
//  This method should be used when the parent receives a WM_SIZE message.
//
void
CWinLog::LocalWindow_ResizeWithinParent(HWND hwndParent)
    {
    Assert(IsWindow(hwndParent));
    if (m_localwindow.hwnd == NULL)
        return; // The local window has not been created
    RECT rc;
    ::GetClientRect(hwndParent, &rc);
    ::MoveWindow(m_localwindow.hwnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);
    }


/////////////////////////////////////////////////////////////////////
//  LocalWindow_SetFocus()
//
//  Set the focus to the local window
//
//  USAGE
//  This method should be used when the parent receives WM_SETFOCUS message
//  and wishes to set the focus to the log window.
//
void
CWinLog::LocalWindow_SetFocus()
    {
    if (m_localwindow.hwnd == NULL)
        return; // The local window has not been created
    ::SetFocus(m_localwindow.hwnd);
    }



/////////////////////////////////////////////////////////////////////
//  LocalWindow_SetReadOnly()
//
//  Prevent the user to edit and modify the content of the log window
//
void
CWinLog::LocalWindow_SetReadOnly(BOOL fReadOnly)
    {
    RichEdit_SetReadOnly(m_localwindow.hwnd, fReadOnly);
    }


/////////////////////////////////////////////////////////////////////
//  LocalWindow_SetDefaultFont()
//
//  Initialize a structure describing the character format for the
//  text to be inserted in the future.
//
void
CWinLog::LocalWindow_SetDefaultFont(
    COLORREF crTextColor,
    int cyTextHeight,       // Height of font in points
    LPCTSTR pszFaceName)
    {
    if (m_cfCharFormat.cbSize == 0)
        {
        // This is our first time we initialize the structure
        m_cfCharFormat.cbSize = sizeof (CHARFORMAT);
        m_cfCharFormat.dwMask = CFM_BOLD;
        m_cfCharFormat.dwEffects = 0;   // Turn off bold effect
        }
    if (crTextColor != crCurrentDefault)
        {
        m_cfCharFormat.dwMask |= CFM_COLOR;
        m_cfCharFormat.crTextColor = crTextColor;
        }
    if (cyTextHeight > 0)
        {
        m_cfCharFormat.dwMask |= CFM_SIZE;
        m_cfCharFormat.yHeight = cyTextHeight * 20;
        }
    if (pszFaceName != NULL)
        {
        m_cfCharFormat.dwMask |= CFM_FACE;
        strcpy(m_cfCharFormat.szFaceName, pszFaceName);
        }
    // Set the character format to the insertion point
    ::SendMessage(m_localwindow.hwnd, EM_SETCHARFORMAT, SCF_SELECTION, IN (LPARAM)&m_cfCharFormat);
    } // LocalWindow_SetDefaultFont()


/////////////////////////////////////////////////////////////////////
//  LocalWindow_LimitLines()
//
//  Limit the number of lines in the window (this is prevent the log
//  window to grow without bounds).
//
//  IMPLEMENTATION NOTES
//  To speed up the process, the number of lines is truncated only
//  when about 100 lines are added.
//
void
CWinLog::LocalWindow_LimitLines()
    {
    if (m_localwindow.cLinesMax <= 0)
        return; // we do not want to limit the number of lines
    if (m_localwindow.cAddText > 100)
        return; // SPEED: We do not check every times we add text
    m_localwindow.cAddText = 0;
    int cLines = ::SendMessage(m_localwindow.hwnd, EM_GETLINECOUNT, 0, 0);
    if (cLines < m_localwindow.cLinesMax)
        return;
    int cLinesDelete = m_localwindow.cLinesMax / 4;     // We delete one fourth of the content
    // Find out how many characters we want to delete
    int cch = ::SendMessage(m_localwindow.hwnd, EM_LINEINDEX, cLinesDelete, 0);
    // Select the text we want to delete
    RichEdit_SetSelection(m_localwindow.hwnd, 0, cch);
    RichEdit_ReplaceSelection(m_localwindow.hwnd, "[Auto Flush...]\n");
    } // LocalWindow_LimitLines()


/////////////////////////////////////////////////////////////////////
//  LocalWindow_AddText()
//
//  Add text to the log window with a specific color.
void
CWinLog::LocalWindow_AddText(LPCTSTR pszText, COLORREF crTextColor)
    {
    if (m_localwindow.hwnd == NULL)
        return;

    m_localwindow.cAddText++;
    LocalWindow_LimitLines();   // Prevent the log window to be too big

    RichEdit_MoveCursorToEnd(m_localwindow.hwnd);   // We want to insert the text at the end of the log
    // This is not very efficient, but the font color must be specified each time the cursor has
    // been moved. BTW: There is no way to append text without moving the cursor.
    LocalWindow_SetDefaultFont(crTextColor);    // We need to change the text color for each entry
    // Append the text
    ::SendMessage(m_localwindow.hwnd, EM_REPLACESEL, 0, (LPARAM)pszText);
    if (m_localwindow.fImmediateUpdate)
        {
        // Immediate update is slower but can be very handy if
        // the application is holding the CPU for a long time.
        LocalWindow_UpdateNow();
        }
    } // LocalWindow_AddText()


/////////////////////////////////////////////////////////////////////
//  LocalWindow_UpdateNow()
//
//  Force the window to repaint itself and scroll to
//  the bottom.
//
//  This routine may be handy if the fImmediateUpdate flag
//  is turned off but want to update the display once a while
//  while logging a large amount of data.
//
void
CWinLog::LocalWindow_UpdateNow()
    {
    if (m_localwindow.hwnd == NULL)
        return;
    HWND hwndFocusPrev = ::SetFocus(m_localwindow.hwnd);
    // Ensure the text we have inserted is visible
    RichEdit_ScrollToEnd(m_localwindow.hwnd);
    // Force a repaint now
    UpdateWindow(m_localwindow.hwnd);
    if (hwndFocusPrev != NULL)
        SetFocus(hwndFocusPrev);
    } // LocalWindow_UpdateNow()


/////////////////////////////////////////////////////////////////////
//  LocalWindow_OnCommand()
//
//  Send a WM_COMMAND message to the rich-edit control.
//
//  USAGE
//  This method was designed for the parent window to
//  forward command messages to the windows.  The parent
//  window is likely to receive commands from accelerators
//  such as ID_EDIT_COPY, ID_EDIT_PASSTE, ID_EDIT_UNDO that
//  need to be forwarded to the rich-edit control.
//
void
CWinLog::LocalWindow_OnCommand(UINT uCommandId)
    {
    ::SendMessage(m_localwindow.hwnd, WM_COMMAND, uCommandId, 0);
    }


/////////////////////////////////////////////////////////////////////
//  LogString()
//
//  Core routine to log a string to the window, the debugger or to a file.
//
//  The routine will log the string to the different target depending
//  on the severity level of the string and the threshold of each target.
//
void
CWinLog::LogString(const TLogStringInfo * pLogStringInfo)
    {
    Assert(pLogStringInfo != NULL);
    const SEVERITY_LEVEL_ENUM eSeverityLevelMessage = pLogStringInfo->eSeverityLevel;
    m_eSeverityPreviousEntry = eSeverityLevelMessage;           // Make a copy of the severity flags
    if (pLogStringInfo->crTextColor != crCurrentDefault)
        m_crTextColorPreviousEntry = pLogStringInfo->crTextColor;   // Make a copy of the color
    if (m_crTextColorPreviousEntry == crAutoSelect)
        m_crTextColorPreviousEntry = AutoSelectColor(pLogStringInfo->eSeverityLevel);

    if (eSeverityLevelMessage == eSeverityNull)
        return; // Do not log this string
    BOOL fLogToWindow = (eSeverityLevelMessage >= m_localwindow.eSeverityThreshold) && (m_localwindow.hwnd != NULL);
    BOOL fLogToDebugger = (eSeverityLevelMessage >= m_debugger.eSeverityThreshold);
    BOOL fLogToFile = (eSeverityLevelMessage >= m_logfile.eSeverityThreshold) && (m_logfile.paFile != NULL);
    if (fLogToWindow == FALSE && fLogToDebugger == FALSE && fLogToFile == FALSE)
        return; // There is no target to log the string

    BOOL fDisplayPopup = (fLogToWindow && m_localwindow.fAutoDisplayPopup && eSeverityLevelMessage >= eSeverityFatalError);
    if (pLogStringInfo->uFlags & LSI_mskfAlwaysDisplayPopup)
        fDisplayPopup = TRUE;
    if (pLogStringInfo->uFlags & LSI_mskfNeverDisplayPopup)
        fDisplayPopup = FALSE;

    TCHAR szMessage[2000];
    int cchMessage = pLogStringInfo->cchIndent;
    int cch = cchMessage;

    for (int i = 0; i < cch; i++)
        {
        szMessage[i] = ' ';
        }
    Assert(cchMessage >= 0);
    szMessage[cchMessage] = '\0';
    const TCHAR * pszText = pLogStringInfo->pszText;
    if (pszText != NULL)
        {
        if (pLogStringInfo->pvaList != NULL)
            {
            cch = vsprintf(OUT &szMessage[cchMessage], pszText, *pLogStringInfo->pvaList);
            Assert(cch >= 0);
            }
        else
            {
            strcpy(OUT &szMessage[cchMessage], pszText);
            }
        } // if
    while (szMessage[cchMessage] != '\0')
        cchMessage++;
    if (pLogStringInfo->uFlags & LST_mskfAddEOL)
        {
        szMessage[cchMessage++] = '\n';
        }
    szMessage[cchMessage++] = '\0';
    Assert(cchMessage < LENGTH(szMessage));

    if (fLogToDebugger)
        {
        // Send the string to the debugger
        OutputDebugString(szMessage);
        }
    if (fLogToWindow)
        {
        LocalWindow_AddText(szMessage, m_crTextColorPreviousEntry);
        }
    if (fLogToFile)
        {
        Assert(m_logfile.paFile != NULL);
        fprintf(m_logfile.paFile, "%s", szMessage);
        }

    if (fLogToDebugger && m_debugger.fBreakpoint)
        {
        // Break into the debugger
        DebugBreak();
        }
    if (fDisplayPopup)
        {
        // Cause a pop-up window to show
        int nResult = MsgBox(szMessage, MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 | MB_ICONEXCLAMATION | MB_TASKMODAL);
        if (nResult == IDABORT)
            {
            DebugBreak();
            exit(-1);
            }
        else if (nResult == IDRETRY)
            {
            DebugBreak();
            }
        }
    } // LogString()


/////////////////////////////////////////////////////////////////////
//  LogStringPrintfExVa()
//
//  This routine will format the string and log it depending on the severity level.
//
//  INPUT PARAMETERS
//  nSeverityFlags - Severity of the string.  This can be anything from eSeverityLevelNull
//          to combination eSeverityLevelExtreme.  This paremater can also be combined
//          with the bimary OR operator with most of the LST_mskf* flags.
//  crTextColor - Color for the text.  Any RGB() value that describes a color or one of the following:
//          crAutoSelect -  The color will be chosen according to the severity level.
//          crCurrentDefault - Use the color from the previous entry.
//  pszTextFmt - Pointer to a null-terminated string that to be formatted with sprintf().
//
void
CWinLog::LogStringPrintfExVa(
    int nSeverityFlags,
    COLORREF crTextColor,
    LPCTSTR pszTextFmt,
    va_list vaList)
    {
    Assert((nSeverityFlags & LSI_mskmPublicFlags) != LSI_mskmPublicFlags && "Too many flags");  // This error is typically by passing a -1 with other flags
    SEVERITY_LEVEL_ENUM eSeverity = (SEVERITY_LEVEL_ENUM)(nSeverityFlags & eSeverityMask);
    TLogStringInfo lsi;
    ZeroMemory(OUT &lsi, sizeof(lsi));
    lsi.uFlags = nSeverityFlags & LSI_mskmPublicFlags;
    lsi.crTextColor = crTextColor;
    lsi.eSeverityLevel = eSeverity;
    lsi.pszText = pszTextFmt;
    lsi.pvaList = &vaList;
    LogString(IN &lsi);
    } // LogStringPrintfExVa()


/////////////////////////////////////////////////////////////////////
//  LogStringPrintfEx()
//
//  Routine to log a string based on the severity level specified by.
//  The routine will format the string and display it with the specified color.
//
//  EXAMPLE
//  LogStringPrintfEx(eSeverityInfo | LST_mskfAddEOL, crAutoSelect, "Loading file %s", "myfile.txt");
//
void
CWinLog::LogStringPrintfEx(
    int nSeverityFlags,
    COLORREF crTextColor,
    LPCTSTR pszTextFmt,
    ...)
    {
    va_list vaList;
    va_start(vaList, pszTextFmt);
    LogStringPrintfExVa(nSeverityFlags, crTextColor, pszTextFmt, vaList);
    va_end(vaList);
    }


/////////////////////////////////////////////////////////////////////
//  LogStringPrintfSev()
//
//  Log a string based using the severity's default color.
//
void
CWinLog::LogStringPrintfSev(int nSeverityFlags, LPCTSTR pszTextFmt, ...)
    {
    va_list vaList;
    va_start(vaList, pszTextFmt);
    LogStringPrintfExVa(nSeverityFlags, crAutoSelect, pszTextFmt, vaList);
    va_end(vaList);
    }


/////////////////////////////////////////////////////////////////////
//  LogStringPrintfCo()
//
//  Log a string based on the severity of the previous entry.
//
//  This routine allow the user to specify the color while remaining at the same
//  severity.  This can be handy when there are several messages at the
//  same severity.
//
void
CWinLog::LogStringPrintfCo(COLORREF crTextColor, LPCTSTR pszTextFmt, ...)
    {
    va_list vaList;
    va_start(vaList, pszTextFmt);
    LogStringPrintfExVa(m_eSeverityPreviousEntry, crTextColor, pszTextFmt, vaList);
    va_end(vaList);
    }


/////////////////////////////////////////////////////////////////////
//  LogStringPrintf()
//
//  Log a string based on the severity and color of the previous entry.
//
void
CWinLog::LogStringPrintf(LPCTSTR pszTextFmt, ...)
    {
    va_list vaList;
    va_start(vaList, pszTextFmt);
    LogStringPrintfExVa(m_eSeverityPreviousEntry, m_crTextColorPreviousEntry, pszTextFmt, vaList);
    va_end(vaList);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winlog.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_WINLOGTYPE                  129
#define ID_TEST_TESTLOGGING1            32771
#define ID_TEST_REPEATTESTS             32772

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B4A31627_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
#define AFX_STDAFX_H__B4A31627_C03D_11D1_A47A_00C04FA3544A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B4A31627_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\winlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       winlog.h
//
//--------------------------------------------------------------------------

// winlog.h : main header file for the WINLOG application
//

#if !defined(AFX_WINLOG_H__B4A31625_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
#define AFX_WINLOG_H__B4A31625_C03D_11D1_A47A_00C04FA3544A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWinlogApp:
// See winlog.cpp for the implementation of this class
//

class CWinlogApp : public CWinApp
{
public:
	CWinlogApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinlogApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWinlogApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WINLOG_H__B4A31625_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	winlog.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\amkspin.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// amkspin.cpp  
//

#include <streams.h>            // quartz, includes windows
#include <measure.h>            // performance measurement (MSR_)
#include <winbase.h>

#include <initguid.h>
#include <olectl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"


STDMETHODIMP
AMKsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList,
    KSPIN_MEDIUM * MediumSet
    )
{
    PKSPIN_MEDIUM   Medium;

    *MediumList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**MediumList) + sizeof(*Medium)));
    if (!*MediumList) {
        return E_OUTOFMEMORY;
    }
    (*MediumList)->Count = 1;
    (*MediumList)->Size = sizeof(**MediumList) + sizeof(*Medium);
    Medium = reinterpret_cast<PKSPIN_MEDIUM>(*MediumList + 1);
    Medium->Set   = MediumSet->Set;
    Medium->Id    = MediumSet->Id;
    Medium->Flags = MediumSet->Flags;

    // The following special return code notifies the proxy that this pin is
    // not available as a kernel mode connection

    return S_FALSE;              
}


STDMETHODIMP
AMKsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    )
{
    PKSPIN_INTERFACE    Interface;

    *InterfaceList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**InterfaceList) + sizeof(*Interface)));
    if (!*InterfaceList) {
        return E_OUTOFMEMORY;
    }
    (*InterfaceList)->Count = 1;
    (*InterfaceList)->Size = sizeof(**InterfaceList) + sizeof(*Interface);
    Interface = reinterpret_cast<PKSPIN_INTERFACE>(*InterfaceList + 1);
    Interface->Set = KSINTERFACESETID_Standard;
    Interface->Id = KSINTERFACE_STANDARD_STREAMING;
    Interface->Flags = 0;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\winlogdoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       winlogdoc.cpp
//
//--------------------------------------------------------------------------

// winlogDoc.cpp : implementation of the CWinlogDoc class
//

#include "stdafx.h"
#include "winlog.h"

#include "winlogDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWinlogDoc

IMPLEMENT_DYNCREATE(CWinlogDoc, CDocument)

BEGIN_MESSAGE_MAP(CWinlogDoc, CDocument)
	//{{AFX_MSG_MAP(CWinlogDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWinlogDoc construction/destruction

CWinlogDoc::CWinlogDoc()
{
	// TODO: add one-time construction code here

}

CWinlogDoc::~CWinlogDoc()
{
}

BOOL CWinlogDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CWinlogDoc serialization

void CWinlogDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWinlogDoc diagnostics

#ifdef _DEBUG
void CWinlogDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWinlogDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWinlogDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\amkspin.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// amkspin.h  
//

STDMETHODIMP
AMKsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList,
    KSPIN_MEDIUM * MediumSet
    );

STDMETHODIMP
AMKsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\winlog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       winlog.cpp
//
//--------------------------------------------------------------------------

// winlog.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "winlog.h"

#include "MainFrm.h"
#include "winlogDoc.h"
#include "winlogView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWinlogApp

BEGIN_MESSAGE_MAP(CWinlogApp, CWinApp)
    //{{AFX_MSG_MAP(CWinlogApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWinlogApp construction

CWinlogApp::CWinlogApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWinlogApp object

CWinlogApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWinlogApp initialization

BOOL CWinlogApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CWinlogDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CWinlogView));
    if (pDocTemplate) {
        AddDocTemplate(pDocTemplate);

        // Parse command line for standard shell commands, DDE, file open
        CCommandLineInfo cmdInfo;
        ParseCommandLine(cmdInfo);

        // Dispatch commands specified on the command line
        if (!ProcessShellCommand(cmdInfo))
            return FALSE;

        // The one and only window has been initialized, so show and update it.
        m_pMainWnd->ShowWindow(SW_SHOW);
        m_pMainWnd->UpdateWindow();
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWinlogApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CWinlogApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\winlogview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       winlogview.cpp
//
//--------------------------------------------------------------------------

// winlogView.cpp : implementation of the CWinlogView class
//

#include "stdafx.h"
#include "winlog.h"

#include "winlogDoc.h"
#include "winlogView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "CWinLog.h"

void WinLog_LogTest1(CWinLog * pWinLog);
static CWinLog g_log;	// Global variable for the log window

/////////////////////////////////////////////////////////////////////////////
// CWinlogView

IMPLEMENT_DYNCREATE(CWinlogView, CView)

BEGIN_MESSAGE_MAP(CWinlogView, CView)
	//{{AFX_MSG_MAP(CWinlogView)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	ON_COMMAND(ID_TEST_REPEATTESTS, OnTestRepeattests)
	ON_UPDATE_COMMAND_UI(ID_TEST_REPEATTESTS, OnUpdateTestRepeattests)
	ON_COMMAND(ID_TEST_TESTLOGGING1, OnTestTestlogging1)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWinlogView construction/destruction

CWinlogView::CWinlogView()
{
	m_fContinuousLooping = FALSE;
}

CWinlogView::~CWinlogView()
{
}

BOOL CWinlogView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CWinlogView drawing

void CWinlogView::OnDraw(CDC* pDC)
{
	CWinlogDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
}

/////////////////////////////////////////////////////////////////////////////
// CWinlogView diagnostics

#ifdef _DEBUG
void CWinlogView::AssertValid() const
{
	CView::AssertValid();
}

void CWinlogView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CWinlogDoc* CWinlogView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWinlogDoc)));
	return (CWinlogDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWinlogView message handlers

int CWinlogView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	g_log.LocalWindow_Create(m_hWnd);	// Create the local window

	SetTimer(1, 800, NULL); // For continuous looping
	return 0;
}

void CWinlogView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	g_log.LocalWindow_ResizeWithinParent(m_hWnd);	// Resize the window within the parent rect	
}

void CWinlogView::OnSetFocus(CWnd* pOldWnd) 
{
	CView::OnSetFocus(pOldWnd);
	g_log.LocalWindow_SetFocus();	// Set the focus to the window	
}


// Methods to run tests
void CWinlogView::OnTestRepeattests() 
{
	// Toggle the looping bit
	m_fContinuousLooping = !m_fContinuousLooping;		
}

void CWinlogView::OnUpdateTestRepeattests(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_fContinuousLooping);	
}

void CWinlogView::OnTestTestlogging1() 
{
	WinLog_LogTest1(INOUT &g_log);		
}

void CWinlogView::OnTimer(UINT nIDEvent) 
{
	if (m_fContinuousLooping)
		{
		WinLog_LogTest1(INOUT &g_log);	
		}
	CView::OnTimer(nIDEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\winlogdoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       winlogdoc.h
//
//--------------------------------------------------------------------------

// winlogDoc.h : interface of the CWinlogDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WINLOGDOC_H__B4A3162B_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
#define AFX_WINLOGDOC_H__B4A3162B_C03D_11D1_A47A_00C04FA3544A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CWinlogDoc : public CDocument
{
protected: // create from serialization only
	CWinlogDoc();
	DECLARE_DYNCREATE(CWinlogDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinlogDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWinlogDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CWinlogDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WINLOGDOC_H__B4A3162B_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\ptvaudio.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// ptvaudio.cpp  Property page for TVAudio
//

#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "kssupp.h"
#include "xbar.h"
#include "ptvaudio.h"
#include "tvaudio.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CTVAudioProperties
// -------------------------------------------------------------------------

CUnknown *CTVAudioProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CTVAudioProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CTVAudioProperties::CTVAudioProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("TVAudio Property Page"), lpunk, 
        IDD_TVAudioProperties, IDS_TVAUDIOPROPNAME)
    , m_pTVAudio(NULL) 
{

}

// destructor
CTVAudioProperties::~CTVAudioProperties()
{
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CTVAudioProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pTVAudio == NULL);

    // Ask the filter for it's control interface
    HRESULT hr = pUnknown->QueryInterface(__uuidof(IAMTVAudio),(void **)&m_pTVAudio);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pTVAudio);

    // Get current filter state

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CTVAudioProperties::OnDisconnect()
{
    // Release the interface

    if (m_pTVAudio == NULL) {
        return E_UNEXPECTED;
    }

    m_pTVAudio->Release();
    m_pTVAudio = NULL;

    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CTVAudioProperties::OnActivate(void)
{
    InitPropertiesDialog(m_hwnd);

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CTVAudioProperties::OnDeactivate(void)
{
    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CTVAudioProperties::OnApplyChanges(void)
{

    return NOERROR;
}

//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR CTVAudioProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    int iNotify = HIWORD (wParam);
    long Mode;

    switch (uMsg) {

    case WM_INITDIALOG:
        m_hwnd = hwnd;
        return (INT_PTR)FALSE;    // I don't call setfocus...

    case WM_COMMAND:
        
        switch (LOWORD(wParam)) {

        case IDC_LANG_A:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_MONO_STEREO_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_LANG_A | Mode);
            }
            break;
        case IDC_LANG_B:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_MONO_STEREO_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_LANG_B | Mode);
            }
            break;
        case IDC_LANG_C:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_MONO_STEREO_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_LANG_C | Mode);
            }
            break;
        case IDC_MONO:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_LANGUAGE_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_MONO | Mode);
            }
            break;
        case IDC_STEREO:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_LANGUAGE_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_STEREO | Mode);
            }
            break;

      default:
            break;

        }

        break;


    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// InitPropertiesDialog
//
//
void CTVAudioProperties::InitPropertiesDialog(HWND hwndParent) 
{
    long AvailableModes, CurrentMode;
    HRESULT hr;

    if (m_pTVAudio == NULL)
        return;
    
    hr = m_pTVAudio->GetHardwareSupportedTVAudioModes (&AvailableModes);
    if (SUCCEEDED (hr)) {
        EnableWindow (GetDlgItem (m_hwnd, IDC_LANG_A), AvailableModes & KS_TVAUDIO_MODE_LANG_A);
        EnableWindow (GetDlgItem (m_hwnd, IDC_LANG_B), AvailableModes & KS_TVAUDIO_MODE_LANG_B);
        EnableWindow (GetDlgItem (m_hwnd, IDC_LANG_C), AvailableModes & KS_TVAUDIO_MODE_LANG_C);
        EnableWindow (GetDlgItem (m_hwnd, IDC_MONO),   AvailableModes & KS_TVAUDIO_MODE_MONO);
        EnableWindow (GetDlgItem (m_hwnd, IDC_STEREO), AvailableModes & KS_TVAUDIO_MODE_STEREO);
    }

    hr = m_pTVAudio->get_TVAudioMode (&CurrentMode);
    if (SUCCEEDED (hr)) {
        long ID = -1;

        if (CurrentMode & KS_TVAUDIO_MODE_LANG_A)
            ID = IDC_LANG_A;
        else if (CurrentMode & KS_TVAUDIO_MODE_LANG_B)
            ID = IDC_LANG_B;
        else if (CurrentMode & KS_TVAUDIO_MODE_LANG_C)
            ID = IDC_LANG_C;
            
        if (ID != -1) {
            CheckRadioButton(
                m_hwnd,
                IDC_LANG_A,
                IDC_LANG_C,
                ID);
        }

        ID = -1;

        if (CurrentMode & KS_TVAUDIO_MODE_MONO)
            ID = IDC_MONO;
        else if (CurrentMode & KS_TVAUDIO_MODE_STEREO)
            ID = IDC_STEREO;
            
        if (ID != -1) {
            CheckRadioButton(
                m_hwnd,
                IDC_MONO,
                IDC_STEREO,
                ID);
        }
    }

}


//
// SetDirty
//
// notifies the property page site of changes

void 
CTVAudioProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\ptvaudio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  ptvaudio.h  XBar property page

#ifndef _INC_PTVAUDIO_H
#define _INC_PTVAUDIO_H

// -------------------------------------------------------------------------
// CTVAudioProperties class
// -------------------------------------------------------------------------

class CTVAudioProperties : public CBasePropertyPage {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    CTVAudioProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CTVAudioProperties();

    void    InitPropertiesDialog(HWND hwndParent);
    void    UpdateOutputView();
    void    UpdateInputView(BOOL fShowSelectedInput);
    void    SetDirty();

    // Keep the original settings on entry
    
    IAMTVAudio       *m_pTVAudio;

};

#endif  // _INC_PTVAUDIO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\kssupp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __KSSUPPORT__
#define __KSSUPPORT__

class CKsSupport : 
	  public IKsPin
    , public IKsPropertySet
    , public CUnknown
{
protected:
	KSPIN_MEDIUM        m_Medium;
    GUID                m_CategoryGUID;
    KSPIN_COMMUNICATION m_Communication;

public:

    // Constructor and destructor
    CKsSupport(KSPIN_COMMUNICATION Communication, LPUNKNOWN pUnk) :
          m_Communication (Communication)
        , m_CategoryGUID (GUID_NULL)
        , CUnknown (TEXT ("CKsSupport"), pUnk)
        {
            m_Medium.Set = GUID_NULL;
            m_Medium.Id = 0;
            m_Medium.Flags = 0;   
        };

    ~CKsSupport()
        {};

    void SetKsMedium   (const KSPIN_MEDIUM *Medium)    {m_Medium = *Medium;};
    void SetKsCategory (const GUID *Category)  {m_CategoryGUID = *Category;};

    DECLARE_IUNKNOWN;

    // IKsPropertySet implementation

    STDMETHODIMP 
    Set (
        REFGUID guidPropSet, 
        DWORD dwPropID, 
        LPVOID pInstanceData, 
        DWORD cbInstanceData, 
        LPVOID pPropData, 
        DWORD cbPropData
        )
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP 
    Get (
        REFGUID guidPropSet, 
        DWORD dwPropID, 
        LPVOID pInstanceData, 
        DWORD cbInstanceData, 
        LPVOID pPropData, 
        DWORD cbPropData, 
        DWORD *pcbReturned
        )
    {
        if (guidPropSet != AMPROPSETID_Pin)
	        return E_PROP_SET_UNSUPPORTED;

        if (dwPropID != AMPROPERTY_PIN_CATEGORY && dwPropID != AMPROPERTY_PIN_MEDIUM)
	        return E_PROP_ID_UNSUPPORTED;

        if (pPropData == NULL && pcbReturned == NULL)
	        return E_POINTER;

        if (pcbReturned)
            *pcbReturned = ((dwPropID == AMPROPERTY_PIN_CATEGORY) ? 
                sizeof(GUID) : sizeof (KSPIN_MEDIUM));

        if (pPropData == NULL)
	        return S_OK;

        if (cbPropData < sizeof(GUID))
	        return E_UNEXPECTED;

        if (dwPropID == AMPROPERTY_PIN_CATEGORY) {
            *(GUID *)pPropData = m_CategoryGUID;
        }
        else if (dwPropID == AMPROPERTY_PIN_MEDIUM) {
            *(KSPIN_MEDIUM *)pPropData = m_Medium;
        }


        return S_OK;
    }

    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
    {
        if (guidPropSet != AMPROPSETID_Pin)
	        return E_PROP_SET_UNSUPPORTED;

        if (dwPropID != AMPROPERTY_PIN_CATEGORY && dwPropID != AMPROPERTY_PIN_MEDIUM)
	        return E_PROP_ID_UNSUPPORTED;

        if (pTypeSupport)
	        *pTypeSupport = KSPROPERTY_SUPPORT_GET;

        return S_OK;
    }


    // IKsPin implementation

    virtual STDMETHODIMP 
    KsQueryMediums(
        PKSMULTIPLE_ITEM* MediumList
        )
        { return ::AMKsQueryMediums (MediumList, &m_Medium); }; 

    virtual STDMETHODIMP
    KsQueryInterfaces(
        PKSMULTIPLE_ITEM* InterfaceList
        ) 
        { return ::AMKsQueryInterfaces (InterfaceList); };

    STDMETHODIMP
    KsCreateSinkPinHandle(
        KSPIN_INTERFACE& Interface,
        KSPIN_MEDIUM& Medium
        ) { return E_UNEXPECTED; };


    STDMETHODIMP
    KsGetCurrentCommunication(
        KSPIN_COMMUNICATION *Communication,
        KSPIN_INTERFACE *Interface,
        KSPIN_MEDIUM *Medium
        )
        {
            if (Communication != NULL) {
                *Communication = m_Communication; 
            }
            if (Interface != NULL) {
                Interface->Set = KSINTERFACESETID_Standard;
                Interface->Id = KSINTERFACE_STANDARD_STREAMING;
                Interface->Flags = 0;
            }
            if (Medium != NULL) {
                *Medium = m_Medium;
            }
            // Special return code that indicates 
            // Kernel transport is  not possible

            return S_FALSE;     
        };
    
    STDMETHODIMP 
    KsPropagateAcquire() 
        { return NOERROR; };


    STDMETHODIMP
    KsDeliver(IMediaSample* Sample, ULONG Flags) 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsMediaSamplesCompleted ( PKSSTREAM_SEGMENT StreamSegment )
        { return E_UNEXPECTED; };

    STDMETHODIMP_(IMemAllocator*)
    KsPeekAllocator(KSPEEKOPERATION Operation) 
        { return NULL; };

    STDMETHODIMP
    KsReceiveAllocator( IMemAllocator* MemAllocator) 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsRenegotiateAllocator() 
        { return E_UNEXPECTED; };

    STDMETHODIMP_(LONG)
    KsIncrementPendingIoCount() 
        { return E_UNEXPECTED; };

    STDMETHODIMP_(LONG)
    KsDecrementPendingIoCount() 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta) 
        { return E_UNEXPECTED; };
    
    STDMETHODIMP_(REFERENCE_TIME) 
    KsGetStartTime() 
        { return E_UNEXPECTED; };
};

#endif // __KSSUPPORT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\pxbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// pxbar.cpp  Property page for Xbar
//

#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "kssupp.h"
#include "xbar.h"
#include "pxbar.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CXBarProperties
// -------------------------------------------------------------------------

CUnknown *CXBarProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CXBarProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CXBarProperties::CXBarProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("Crossbar Property Page"), lpunk, 
        IDD_XBARProperties, IDS_CROSSBARPROPNAME)
    , m_pXBar(NULL) 
{

}

// destructor
CXBarProperties::~CXBarProperties()
{
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CXBarProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pXBar == NULL);

    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_IAMCrossbar,(void **)&m_pXBar);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pXBar);

    // Get current filter state

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CXBarProperties::OnDisconnect()
{
    // Release the interface

    if (m_pXBar == NULL) {
        return E_UNEXPECTED;
    }

    m_pXBar->Release();
    m_pXBar = NULL;

    if (m_pCanRoute) delete [] m_pCanRoute, m_pCanRoute = NULL;
    if (m_pRelatedInput) delete [] m_pRelatedInput, m_pRelatedInput = NULL;
    if (m_pRelatedOutput) delete [] m_pRelatedOutput, m_pRelatedOutput = NULL;
    if (m_pPhysicalTypeInput) delete [] m_pPhysicalTypeInput, m_pPhysicalTypeInput = NULL;
    if (m_pPhysicalTypeOutput) delete [] m_pPhysicalTypeOutput, m_pPhysicalTypeOutput = NULL;

    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CXBarProperties::OnActivate(void)
{
    InitPropertiesDialog(m_hwnd);

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CXBarProperties::OnDeactivate(void)
{
    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CXBarProperties::OnApplyChanges(void)
{
    long lIn, lOut, lActive, lIndexRelatedOut, lIndexRelatedIn, PhysicalType;
    HRESULT hr;

    lOut = ComboBox_GetCurSel (m_hLBOut);
    lActive = ComboBox_GetCurSel (m_hLBIn);  // This is the CB index
    lIn = (LONG)ComboBox_GetItemData (m_hLBIn, lActive);

    hr = m_pXBar->Route (lOut, lIn); 

    // Try to link related input and output pins if the 
    // control is checked

    if (Button_GetCheck (GetDlgItem (m_hwnd, IDC_LinkRelated))) {
        // Related output pin
        hr = m_pXBar->get_CrossbarPinInfo( 
                        FALSE,       // IsInputPin,
                        lOut,        // PinIndex,
                        &lIndexRelatedOut,
                        &PhysicalType);

        // Related input pin
        hr = m_pXBar->get_CrossbarPinInfo( 
                        TRUE,        // IsInputPin,
                        lIn,         // PinIndex,
                        &lIndexRelatedIn,
                        &PhysicalType);

        hr = m_pXBar->Route (lIndexRelatedOut, lIndexRelatedIn);         
    }

    UpdateInputView(TRUE /*fShowSelectedInput*/);

    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR CXBarProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    int iNotify = HIWORD (wParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        m_hwnd = hwnd;
        return (INT_PTR)TRUE;    // I don't call setfocus...

    case WM_COMMAND:
        
        switch (LOWORD(wParam)) {

        case IDC_OUTPIN:
            if (iNotify == CBN_SELCHANGE) {
                SetDirty();
                UpdateOutputView();
                UpdateInputView(TRUE/*fShowSelectedInput*/);
            }
            break;

        case IDC_INPIN:
            if (iNotify == CBN_SELCHANGE) {
                SetDirty();
                UpdateInputView(FALSE /*fShowSelectedInput*/);
            }
            break;

        default:
            break;

        }

        break;


    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// InitPropertiesDialog
//
//
void CXBarProperties::InitPropertiesDialog(HWND hwndParent) 
{
    HRESULT hr;

    if (m_pXBar == NULL)
        return;

    m_hLBOut = GetDlgItem (hwndParent, IDC_OUTPIN);
    m_hLBIn  = GetDlgItem (hwndParent, IDC_INPIN);

    TCHAR szName[MAX_PATH];
    long i, o;

    hr = m_pXBar->get_PinCounts (&m_OutputPinCount, &m_InputPinCount);

    // Sanity check
    ASSERT (m_OutputPinCount * m_InputPinCount < 256 * 256);

    m_pCanRoute = new BOOL [m_OutputPinCount * m_InputPinCount];
    m_pRelatedInput = new long [m_InputPinCount];
    m_pRelatedOutput = new long [m_OutputPinCount];
    m_pPhysicalTypeInput = new long [m_InputPinCount];
    m_pPhysicalTypeOutput = new long [m_OutputPinCount];

    if (!m_pCanRoute ||
        !m_pRelatedInput ||
        !m_pRelatedOutput ||
        !m_pPhysicalTypeInput ||
        !m_pPhysicalTypeOutput) {
        return;
    }
    
    //
    // Get all of the related pin info, and physical pin types
    //

    // Add all of the output pins to the output pin list box

    for (o = 0; o < m_OutputPinCount; o++) {
        if (SUCCEEDED (hr = m_pXBar->get_CrossbarPinInfo( 
                            FALSE,  // IsInputPin,
                            o,      // PinIndex,
                            &m_pRelatedOutput[o],
                            &m_pPhysicalTypeOutput[o]))) {
            StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), m_pPhysicalTypeOutput[o], FALSE, o);
            ComboBox_InsertString (m_hLBOut, o, szName);
        }
    }
     
    // Check all input pins
    // This probably should be dynamic, but it's useful for debugging
    // drivers to do all possiblities up front.

    for (i = 0; i < m_InputPinCount; i++) {
        if (SUCCEEDED (hr = m_pXBar->get_CrossbarPinInfo( 
                            TRUE,  // IsInputPin,
                            i,      // PinIndex,
                            &m_pRelatedInput[i],
                            &m_pPhysicalTypeInput[i]))) {
        }
    }

    // Check all possible routings
    // This probably should be dynamic, but it's useful for debugging
    // drivers to do all possiblities up front.

    for (o = 0; o < m_OutputPinCount; o++) {
        for (i = 0; i < m_InputPinCount; i++) {
            // The following returns either S_OK, or S_FALSE
            hr = m_pXBar->CanRoute (o, i);
            m_pCanRoute[o * m_InputPinCount + i] = (hr == S_OK);
        }
    }

    ComboBox_SetCurSel (m_hLBOut, 0);

    UpdateOutputView();
    UpdateInputView(TRUE /*fShowSelectedInput*/);
}

void CXBarProperties::UpdateOutputView() 
{
    HRESULT hr;
    long lOut, lIn, IndexRelated1, IndexRelated2, PhysicalType;
    TCHAR szName[MAX_PATH];

    lOut = ComboBox_GetCurSel (m_hLBOut);

    hr = m_pXBar->get_IsRoutedTo ( 
                    lOut,       // OutputPinIndex,
                    &lIn);      // *InputPinIndex

    // Show pin related to output pin
    hr = m_pXBar->get_CrossbarPinInfo( 
                    FALSE,               // IsInputPin,
                    lOut,                // PinIndex,
                    &IndexRelated1,
                    &PhysicalType);

    hr = m_pXBar->get_CrossbarPinInfo( 
                    FALSE,               // IsInputPin,
                    IndexRelated1,       // PinIndex,
                    &IndexRelated2,
                    &PhysicalType);

    StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), PhysicalType, FALSE, IndexRelated1);
    SetDlgItemText (m_hwnd, IDC_RELATEDOUTPUTPIN, szName);


    // Reset the contents of the input list box
    // and refill it with all of the legal routings
    ComboBox_ResetContent (m_hLBIn);

    long Active = 0;
    for (lIn = 0; lIn < m_InputPinCount; lIn++) {
        if (!m_pCanRoute [lOut * m_InputPinCount + lIn])
            continue;
        
        StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), m_pPhysicalTypeInput[lIn], TRUE, lIn);
        ComboBox_InsertString (m_hLBIn, Active, szName);
        // Save the actual pin index as private data in the listbox
        ComboBox_SetItemData (m_hLBIn, Active, lIn);
        Active++;
    }

}

void CXBarProperties::UpdateInputView(BOOL fShowSelectedInput) 
{
    HRESULT hr;
    long j, k, lOut, lIn, IndexRelated1, IndexRelated2, PhysicalType;
    TCHAR szName[MAX_PATH];

    lOut = ComboBox_GetCurSel (m_hLBOut);

    hr = m_pXBar->get_IsRoutedTo ( 
                    lOut,       // OutputPinIndex,
                    &lIn);      // *InputPinIndex

    hr = m_pXBar->get_CrossbarPinInfo( 
                    TRUE,       // IsInputPin,
                    lIn,        // PinIndex,
                    &IndexRelated1,
                    &PhysicalType);

    StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), PhysicalType, TRUE, lIn);
    SetDlgItemText (m_hwnd, IDC_CURRENT_INPUT, szName);

    // Show pin related to input pin
    hr = m_pXBar->get_CrossbarPinInfo( 
                    TRUE,               // IsInputPin,
                    IndexRelated1,       // PinIndex,
                    &IndexRelated2,
                    &PhysicalType);

    StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), PhysicalType, TRUE, IndexRelated1);
    SetDlgItemText (m_hwnd, IDC_RELATEDINPUTPIN, szName);

    if (fShowSelectedInput) {
        // Show the active input for the selected output pin
        for (j = 0; j < ComboBox_GetCount (m_hLBIn); j++) {
            k = (LONG)ComboBox_GetItemData (m_hLBIn, j);
            if (k == lIn) {
                ComboBox_SetCurSel (m_hLBIn, j);
                break;
            }
        }
    }
}



//
// SetDirty
//
// notifies the property page site of changes

void 
CXBarProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\winlog\winlogview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       winlogview.h
//
//--------------------------------------------------------------------------

// winlogView.h : interface of the CWinlogView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WINLOGVIEW_H__B4A3162D_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
#define AFX_WINLOGVIEW_H__B4A3162D_C03D_11D1_A47A_00C04FA3544A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CWinlogView : public CView
{
protected: // create from serialization only
	CWinlogView();
	DECLARE_DYNCREATE(CWinlogView)

// Attributes
public:
	CWinlogDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinlogView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWinlogView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CWinlogView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnTestRepeattests();
	afx_msg void OnUpdateTestRepeattests(CCmdUI* pCmdUI);
	afx_msg void OnTestTestlogging1();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL m_fContinuousLooping;		// Periodically loop through the test
};

#ifndef _DEBUG  // debug version in winlogView.cpp
inline CWinlogDoc* CWinlogView::GetDocument()
   { return (CWinlogDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WINLOGVIEW_H__B4A3162D_C03D_11D1_A47A_00C04FA3544A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\pxbar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  pxbar.h  XBar property page

#ifndef _INC_PXBAR_H
#define _INC_PXBAR_H

// -------------------------------------------------------------------------
// CXBarProperties class
// -------------------------------------------------------------------------

class CXBarProperties : public CBasePropertyPage {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    CXBarProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CXBarProperties();

    void    InitPropertiesDialog(HWND hwndParent);
    void    UpdateOutputView();
    void    UpdateInputView(BOOL fShowSelectedInput);
    void    SetDirty();

    // Keep the original settings on entry
    
    IAMCrossbar         *m_pXBar;
    HWND                m_hLBOut;
    HWND                m_hLBIn;
    long                m_InputPinCount;
    long                m_OutputPinCount;
    BOOL                *m_pCanRoute;
    long                *m_pRelatedInput;
    long                *m_pRelatedOutput;
    long                *m_pPhysicalTypeInput;
    long                *m_pPhysicalTypeOutput;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbar.rc
//
#define IDS_CROSSBARPROPNAME            1
#define IDS_TVAUDIOPROPNAME             2
#define IDD_XBARProperties              103
#define IDD_TVAudioProperties           104
#define IDC_RADIO1                      1000
#define IDC_INPIN                       1002
#define IDC_LinkRelated                 1003
#define IDC_RELATEDPIN                  1004
#define IDC_RELATEDINPUTPIN             1004
#define IDC_CURRENT_INPUT               1005
#define IDC_RELATEDOUTPUTPIN            1006
#define IDC_OUTPIN                      1015
#define IDC_LANG_A                      2000
#define IDC_LANG_B                      2001
#define IDC_LANG_C                      2002
#define IDC_MONO                        2010
#define IDC_STEREO                      2011
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\xbar\tvaudio.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <tchar.h>
#include <stdio.h>
#include <olectl.h>
#include <amtvuids.h>     // GUIDs  
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include "amkspin.h"
#include "kssupp.h"
#include "tvaudio.h"
#include "xbar.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

// Setup data


//
// CreateInstance
//
// Creator function for the class ID
//

CUnknown * WINAPI TVAudio::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new TVAudio(NAME("TVAudio Filter"), pUnk, phr);
}


//
// Constructor
//
TVAudio::TVAudio(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) 
    : m_pTVAudioInputPin (NULL)
    , m_pTVAudioOutputPin (NULL)
    , m_pPersistStreamDevice(NULL)
    , m_hDevice(NULL)
    , m_pDeviceName(NULL)
    , CPersistStream(pUnk, phr)
    , CBaseFilter(NAME("TVAudio filter"), pUnk, this, CLSID_TVAudioFilter)
{
    ASSERT(phr);
}


//
// Destructor
//
TVAudio::~TVAudio()
{
    delete m_pTVAudioInputPin;
    delete m_pTVAudioOutputPin;

    // close the device
    if(m_hDevice) {
    	CloseHandle(m_hDevice);
    }

    if (m_pDeviceName) {
        delete [] m_pDeviceName;
    }

    if (m_pPersistStreamDevice) {
       m_pPersistStreamDevice->Release();
    }
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP TVAudio::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof(IAMTVAudio)) {
        return GetInterface((IAMTVAudio *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    }
    else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *) this, ppv);
    }
    else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else {
        return CBaseFil